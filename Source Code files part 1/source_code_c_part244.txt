 string to an output buffer
//*****************************************************************************
HRESULT CMiniMd::Impl_GetStringW(ULONG ix, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer)
{
	LPCSTR		szString;				// Single byte version.
	int 		iSize;					// Size of resulting string, in wide chars.
	HRESULT 	hr = NOERROR;

	szString = getString(ix);

	if ( *szString == 0 )
	{
		// If emtpy string "", return pccBuffer 0
		if ( szOut && cchBuffer )
			szOut[0] = L'\0';
		if ( pcchBuffer )
			*pcchBuffer = 0;
		goto ErrExit;
	}
	if (!(iSize=::WszMultiByteToWideChar(CP_UTF8, 0, szString, -1, szOut, cchBuffer)))
	{
		// What was the problem?
		DWORD dwNT = GetLastError();

		// Not truncation?
		if (dwNT != ERROR_INSUFFICIENT_BUFFER)
			IfFailGo( HRESULT_FROM_NT(dwNT) );

		// Truncation error; get the size required.
		if (pcchBuffer)
			*pcchBuffer = ::WszMultiByteToWideChar(CP_UTF8, 0, szString, -1, szOut, 0);

		IfFailGo( CLDB_S_TRUNCATION );
	}
	if (pcchBuffer)
		*pcchBuffer = iSize;

ErrExit:
	return hr;
} // HRESULT CMiniMd::Impl_GetStringW()


//*****************************************************************************
// Given a table with a pointer (index) to a sequence of rows in another 
//  table, get the RID of the end row.  This is the STL-ish end; the first row
//  not in the list.  Thus, for a list of 0 elements, the start and end will
//  be the same.
//*****************************************************************************
int CMiniMd::Impl_GetEndRidForColumn(	// The End rid.
	const void	*pvRec, 				// Row that references another table.
	int			ixTbl, 					// Table containing the row.
	CMiniColDef &def, 					// Column containing the RID into other table.
	int			ixTbl2)					// The other table.
{
	const BYTE *pLast = m_pTable[ixTbl] + m_TableDefs[ixTbl].m_cbRec*(m_Schema.m_cRecs[ixTbl]);
	const BYTE *pRec = reinterpret_cast<const BYTE*>(pvRec);

	ULONG ixEnd;

	// Last rid in range from NEXT record, or count of table, if last record.
	_ASSERTE(pRec <= pLast);
	if (pRec < pLast)
		ixEnd = getIX(pRec+m_TableDefs[ixTbl].m_cbRec, def);
	else	// Convert count to 1-based rid.
		ixEnd = m_Schema.m_cRecs[ixTbl2] + 1;

	return ixEnd;
} // int CMiniMd::Impl_GetEndRidForColumn()


//*****************************************************************************
// return all found CAs in an enumerator
//*****************************************************************************
HRESULT CMiniMd::CommonEnumCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
    bool        fStopAtFirstFind,       // [IN] just find the first one
    HENUMInternal* phEnum)              // enumerator to fill up
{
    HRESULT     hr = S_OK;              // A result.
    HRESULT     hrRet = S_FALSE;        // Assume that we won't find any 
    ULONG       ridStart, ridEnd;       // Loop start and endpoints.

    _ASSERTE(phEnum != NULL);

    memset(phEnum, 0, sizeof(HENUMInternal));

    phEnum->m_tkKind = mdtCustomAttribute;

    HENUMInternal::InitDynamicArrayEnum(phEnum);

    // Get the list of custom values for the parent object.

    ridStart = getCustomAttributeForToken(tkObj, &ridEnd);
    if (ridStart == 0)
        return S_FALSE;

    // Look for one with the given name.
    for (; ridStart < ridEnd; ++ridStart)
    {
        if ( CompareCustomAttribute( tkObj, szName, ridStart) )
        {
            // If here, found a match.
            hrRet = S_OK;
            IfFailGo( HENUMInternal::AddElementToEnum(
                phEnum, 
                TokenFromRid(ridStart, mdtCustomAttribute)));
            if (fStopAtFirstFind)
                goto ErrExit;
        }
    }

ErrExit:
    if (FAILED(hr))
        return hr;
    return hrRet;

}   // CommonEnumCustomAttributeByName


//*****************************************************************************
// return just the blob value of the first found CA matching the query.
//*****************************************************************************
HRESULT CMiniMd::CommonGetCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
	const void	**ppData,				// [OUT] Put pointer to data here.
	ULONG		*pcbData)				// [OUT] Put size of data here.
{
    HRESULT         hr;
    ULONG           cbData;
    HENUMInternal   hEnum;
    mdCustomAttribute ca;
    CustomAttributeRec *pRec;

    hr = CommonEnumCustomAttributeByName(tkObj, szName, true, &hEnum);
    if (hr != S_OK)
        goto ErrExit;

    if (ppData)
    {
        // now get the record out.
        if (pcbData == 0)
            pcbData = &cbData;

        HENUMInternal::EnumNext(&hEnum, &ca);
        pRec = getCustomAttribute(RidFromToken(ca));
        *ppData = getValueOfCustomAttribute(pRec, pcbData);
    }
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    return hr;
}   // CommonGetCustomAttributeByName


// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\recordpool.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// RecordPool.cpp -- Implementation of record heaps.
//
//*****************************************************************************
#include "stdafx.h"
#include <RecordPool.h>

#define AGRESSIVE_GROWTH 1				// If true, grow pools agressively.

#define RECORDPOOL_GROW_FACTOR 8
#define RECORDPOOL_GROW_MAX 2048
#define RECORDPOOL_GROW_MINROWS 2
#define RECORDPOOL_GROW_DEFAULTROWS 16

HRESULT RecordPool::InitNew(	        // Return code.
	ULONG		cbRec,					// Record size.
	ULONG		cRecsInit) 				// Initial guess of count of record.
{
    HRESULT     hr;                     // A result.
	ULONG		ulGrow;					// Initial grow size of the pool.

	// Size of each record is fixed.
	m_cbRec = cbRec;

#if AGRESSIVE_GROWTH
	if (cRecsInit > 0)
		ulGrow = cbRec * cRecsInit;
	else
		ulGrow = cbRec * RECORDPOOL_GROW_DEFAULTROWS;
#else
	// Compute a grow size.  Target an initial value that is:
	//   1/8 of the initial estimate
	//   but not less than 2 rows
	//   nor greater than 2048 bytes
	ulGrow = cRecsInit / RECORDPOOL_GROW_FACTOR;
	ULONG ulGrowMax = ((RECORDPOOL_GROW_MAX / cbRec) - 1) * cbRec;
	if (ulGrow < RECORDPOOL_GROW_MINROWS)
		ulGrow = RECORDPOOL_GROW_MINROWS;
	ulGrow *= cbRec;
	if (ulGrow > ulGrowMax)
		ulGrow = ulGrowMax;
#endif // AGRESSIVE_GROWTH

	m_ulGrowInc = ulGrow;

    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

	// If there is an initial size for the record pool, grow to that now.
	if (cRecsInit)
		if (!Grow(cRecsInit * cbRec))
			return E_OUTOFMEMORY;

    return (S_OK);
} // HRESULT RecordPool::InitNew()

//*****************************************************************************
// Load a Record heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new Records.
//*****************************************************************************
HRESULT RecordPool::InitOnMem(			// Return code.
	ULONG			cbRec,				// Record size.
    void        	*pData,             // Predefined data.
    ULONG       	iSize,              // Size of data.
    RecordOpenFlags fReadOnly)          // true if append is forbidden.
{
    HRESULT     hr;
	int bReadOnly;
	m_cbRec = cbRec;

	// Convert our flags to a bool
	if(fReadOnly == READ_ONLY)
	{
		bReadOnly = TRUE;
	}
	else
	{
		bReadOnly = FALSE;
	}

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    // For init on existing mem case.
    if (pData && iSize)
    {

		// If we are doing an update in place don't make a copy
        // If we cannot update, then we don't need a hash table.
        if (fReadOnly == READ_ONLY || fReadOnly == UPDATE_INPLACE)
            return (S_OK);

		// Other wise copy the memory to do the update
        TakeOwnershipOfInitMem();
    }

    return (S_OK);
} // HRESULT RecordPool::InitOnMem()

//*****************************************************************************
// Allocate memory if we don't have any, or grow what we have.  If successful,
// then at least iRequired bytes will be allocated.
//*****************************************************************************
bool RecordPool::Grow(                 // true if successful.
    ULONG       iRequired)              // Min required bytes to allocate.
{
	// Allocate the memory.
	if (!StgPool::Grow(iRequired))
		return false;

	// Zero the new memory.
    memset(GetNextLocation(), 0, GetCbSegAvailable());

	return true;
} // bool RecordProol::Grow()

//*****************************************************************************
// The Record will be added to the pool.  The index of the Record in the pool
// is returned in *piIndex.  If the Record is already in the pool, then the
// index will be to the existing copy of the Record.
//*****************************************************************************
void *RecordPool::AddRecord(			// New record or NULL.
	ULONG		*piIndex)				// Return 1-based index of Record here.
{
    // Space on heap for new Record?
    if (m_cbRec > GetCbSegAvailable())
    {
        if (!Grow(m_cbRec))
            return 0;
    }

	// Records should be aligned on record boundaries.
	_ASSERTE((GetNextOffset() % m_cbRec) == 0);

    // Copy the Record to the heap.
    void *pNewRecord = GetNextLocation();

	// Give the 1-based index back to caller.
	if (piIndex)
		*piIndex = (GetNextOffset() / m_cbRec) + 1;

    // Update heap counters.
    SegAllocate(m_cbRec);
    SetDirty();

    return pNewRecord;
} // void *RecordPool::AddRecord()

//*****************************************************************************
// Insert a Record into the pool.  The index of the Record before which to
// insert is specified.  Shifts all records down.  Return a pointer to the
// new record.
//*****************************************************************************
void *RecordPool::InsertRecord(			// New record, or NULL.
	ULONG		iLocation)				// [IN] Insert record before this.
{
	StgPoolSeg	*pCurSeg;				// Current segment.
	StgPoolSeg	*pPrevSeg;				// Previous segment.
	BYTE		*pSegEnd;				// Last record in a segment.
	BYTE		*pFrom;					// A copy/move source.
	ULONG		cbMove;					// Bytes to move.
	void		*pNew;					// New record.

	// Notice the case of appending.
	if (iLocation == static_cast<ULONG>(Count()+1))
		return AddRecord();

	// If past end or before beginning, invalid.
	if (iLocation > static_cast<ULONG>(Count()) || iLocation == 0)
	{
		_ASSERTE(!"Invalid location for record insertion");
		return 0;
	}

	// This code works by allocating a new record at the end.
	// The last record is moved to the new end record.
	// Working backwards through the chained segments,
	//     shift the segment by one record, so the empty record
	//      is at the start of the segment instead of the end.
	// 	   copy the last record of the previous segment to the
	//      newly emptied first record of the current segment.
	// When the segment containing the insert point is finally
	//  reached, its last record is empty (from above loop), so
	//  shift from the insertion point to the end-1 by one record.


	// Current last record.
	pCurSeg = m_pCurSeg;
	pSegEnd = reinterpret_cast<BYTE*>(GetRecord(Count()));

	// Add an empty record to the end of the heap.
	if ((pNew = AddRecord()) == 0) return 0;

	// Copy the current last record to the new record.
	memcpy(pNew, pSegEnd, m_cbRec);

	// While the insert location is prior to the current segment,
	while (iLocation < GetIndexForRecord(pCurSeg->m_pSegData))
	{
		// Shift the segment up by one record.
		cbMove = (ULONG)(pSegEnd - pCurSeg->m_pSegData);
		memmove(pCurSeg->m_pSegData+m_cbRec, pCurSeg->m_pSegData, cbMove);

		// Find the previous segment.
		pPrevSeg = this;
		while (pPrevSeg->m_pNextSeg != pCurSeg)
			pPrevSeg = pPrevSeg->m_pNextSeg;

		// Copy the final record of the previous segment to the start of this one.
		pSegEnd = pPrevSeg->m_pSegData+pPrevSeg->m_cbSegNext-m_cbRec;
		memcpy(pCurSeg->m_pSegData, pSegEnd, m_cbRec);

		// Make the previous segment the current segment.
		pCurSeg = pPrevSeg;
	}

	// Shift at the insert location, forward by one.
	pFrom = reinterpret_cast<BYTE*>(GetRecord(iLocation));
	cbMove = (ULONG)(pSegEnd - pFrom);
	memmove(pFrom+m_cbRec, pFrom, cbMove);

	return pFrom;
} // void *RecordPool::InsertRecord()

//*****************************************************************************
// Return a pointer to a Record given an index previously handed out by
// AddRecord or FindRecord.
//*****************************************************************************
void *RecordPool::GetRecord(			// Pointer to Record in pool.
	ULONG		iIndex)					// 1-based index of Record in pool.
{
	_ASSERTE(iIndex > 0);

	// Convert to 0-based internal form, defer to implementation.
	return GetData((iIndex-1) * m_cbRec);
} // void *RecordPool::GetRecord()

//*****************************************************************************
// Return the first record in a pool, and set up a context for fast
//  iterating through the pool.  Note that this scheme does pretty minimal
//  error checking.
//*****************************************************************************
void *RecordPool::GetFirstRecord(		// Pointer to Record in pool.
	void		**pContext)				// Store context here.
{
	StgPoolSeg	**ppSeg = reinterpret_cast<StgPoolSeg**>(pContext);

	*ppSeg = static_cast<StgPoolSeg*>(this);
	return (*ppSeg)->m_pSegData;
} // void *RecordPool::GetFirstRecord()

//*****************************************************************************
// Given a pointer to a record, return a pointer to the next record.
//  Note that this scheme does pretty minimal error checking. In particular,
//  this will let the caller walk off of the end of valid data in the last
//  segment.
//*****************************************************************************
void *RecordPool::GetNextRecord(		// Pointer to Record in pool.
	void		*pRecord,				// Current record.
	void		**pContext)				// Stored context here.
{
	BYTE		*pbRec = reinterpret_cast<BYTE*>(pRecord);
	StgPoolSeg	**ppSeg = reinterpret_cast<StgPoolSeg**>(pContext);

	// Get the next record.
	pbRec += m_cbRec;

	// Is the next record outside of the current segment?
	if (static_cast<ULONG>(pbRec - (*ppSeg)->m_pSegData) >= (*ppSeg)->m_cbSegSize)
	{
		// Better be exactly one past current segment.
		_ASSERTE(static_cast<ULONG>(pbRec - (*ppSeg)->m_pSegData) == (*ppSeg)->m_cbSegSize);
		// Switch the context pointer.
		*ppSeg = (*ppSeg)->m_pNextSeg;
		// Next record is start of next segment.
		if (*ppSeg)
			return (*ppSeg)->m_pSegData;
		else
			return 0;
	}

	return pbRec;
} // void *RecordPool::GetNextRecord()

//*****************************************************************************
// Given a pointer to a record, determine the index corresponding to the
// record.
//*****************************************************************************
ULONG RecordPool::GetIndexForRecord(	// 1-based index of Record in pool.
	const void *pvRecord)				// Pointer to Record in pool.
{
	ULONG		iPrev = 0;				// cumulative index of previous segments.
	const StgPoolSeg *pSeg = this;
	const BYTE  *pRecord = reinterpret_cast<const BYTE*>(pvRecord);

	for (;;)
	{	// Does the current segment contain the record?
		if (pRecord >= pSeg->GetSegData() && pRecord < pSeg->GetSegData() + pSeg->GetSegSize())
		{	// The pointer should be to the start of a record.
			_ASSERTE(((pRecord - pSeg->GetSegData()) % m_cbRec) == 0);
			return (ULONG)(1 + iPrev + (pRecord - pSeg->GetSegData()) / m_cbRec);
		}
		_ASSERTE((pSeg->GetSegSize() % m_cbRec) == 0);
		iPrev += pSeg->GetSegSize() / m_cbRec;
		pSeg = pSeg->GetNextSeg();
		// If out of data, didn't find the record.
		if (pSeg == 0)
			return 0;
	}
} // ULONG RecordPool::GetIndexForRecord()

//*****************************************************************************
// Given a purported pointer to a record, determine if the pointer is valid.
//*****************************************************************************
int RecordPool::IsValidPointerForRecord(// true or false.
	const void *pvRecord)				// Pointer to Record in pool.
{
	ULONG		iPrev = 0;				// cumulative index of previous segments.
	const StgPoolSeg *pSeg = this;
	const BYTE  *pRecord = reinterpret_cast<const BYTE*>(pvRecord);

	for (;;)
	{	// Does the current segment contain the record?
		if (pRecord >= pSeg->GetSegData() && pRecord < pSeg->GetSegData() + pSeg->GetSegSize())
		{	// The pointer should be to the start of a record.
			return (((pRecord - pSeg->GetSegData()) % m_cbRec) == 0);
		}
		_ASSERTE((pSeg->GetSegSize() % m_cbRec) == 0);
		iPrev += pSeg->GetSegSize() / m_cbRec;
		pSeg = pSeg->GetNextSeg();
		// If out of data, didn't find the record.
		if (pSeg == 0)
			return false;
	}
} // int RecordPool::IsValidPointerForRecord()

//*****************************************************************************
// Replace the contents of this pool with those from another pool.  The other
//	pool loses ownership of the memory.
//*****************************************************************************
HRESULT RecordPool::ReplaceContents(
	RecordPool *pOther)					// The other record pool.
{
	// Release any memory currently held.
	Uninit();

	// Grab the new data.
	*this = *pOther;

	// If the other pool's curseg pointed to itself, make this pool point to itself.
	if (pOther->m_pCurSeg == pOther)
		m_pCurSeg = this;

	// Fix the other pool so it won't free the memory that this one
	//  just hijacked.
	pOther->m_pSegData = (BYTE*)m_zeros;
	pOther->m_pNextSeg = 0;
	pOther->Uninit();

	return S_OK;
} // HRESULT RecordPool::ReplaceContents()

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include <CrtWrap.h>
#include <WinWrap.h>
#include <utilcode.h>

#include <cor.h>
#include <corpriv.h>

#include "MDCommon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\metamodel.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModel.cpp -- Base portion of compressed COM+ metadata.
//
//*****************************************************************************
#include "stdafx.h"


#include <MetaModel.h>
#include <CorError.h>


#define OPTIMIZE_CODED_TOKENS           // If defined, pack all coded tokens.

//*****************************************************************************
// meta-meta model.
//*****************************************************************************

//-----------------------------------------------------------------------------
// Start of column definitions.
//-----------------------------------------------------------------------------
// Column type, offset, size.
#define SCHEMA_TABLE_START(tbl) static CMiniColDef r##tbl##Cols[] = {
#define SCHEMA_ITEM_NOFIXED()
#define SCHEMA_ITEM_ENTRY(col,typ) {typ, 0,0},
#define SCHEMA_ITEM_ENTRY2(col,typ,ofs,siz) {typ, ofs, siz},
#define SCHEMA_ITEM(tbl,typ,col) SCHEMA_ITEM_ENTRY2(col, i##typ, offsetof(tbl##Rec,m_##col), sizeof(((tbl##Rec*)(0))->m_##col))
#define SCHEMA_ITEM_RID(tbl,col,tbl2) SCHEMA_ITEM_ENTRY(col,TBL_##tbl2)
#define SCHEMA_ITEM_STRING(tbl,col) SCHEMA_ITEM_ENTRY(col,iSTRING)
#define SCHEMA_ITEM_GUID(tbl,col) SCHEMA_ITEM_ENTRY(col,iGUID)
#define SCHEMA_ITEM_BLOB(tbl,col) SCHEMA_ITEM_ENTRY(col,iBLOB)
#define SCHEMA_ITEM_CDTKN(tbl,col,tkns) SCHEMA_ITEM_ENTRY(col,iCodedToken+(CDTKN_##tkns))
#define SCHEMA_TABLE_END(tbl) };
//-----------------------------------------------------------------------------
#include "MetaModelColumnDefs.h"
//-----------------------------------------------------------------------------
#undef SCHEMA_TABLE_START
#undef SCHEMA_ITEM_NOFIXED
#undef SCHEMA_ITEM_ENTRY
#undef SCHEMA_ITEM_ENTRY2
#undef SCHEMA_ITEM
#undef SCHEMA_ITEM_RID
#undef SCHEMA_ITEM_STRING
#undef SCHEMA_ITEM_GUID
#undef SCHEMA_ITEM_BLOB
#undef SCHEMA_ITEM_CDTKN
#undef SCHEMA_TABLE_END
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Column names.
#define SCHEMA_TABLE_START(tbl) static const char *r##tbl##ColNames[] = {
#define SCHEMA_ITEM_NOFIXED()
#define SCHEMA_ITEM_ENTRY(col,typ) #col,
#define SCHEMA_ITEM_ENTRY2(col,typ,ofs,siz) #col,
#define SCHEMA_ITEM(tbl,typ,col) SCHEMA_ITEM_ENTRY2(col, i##typ, offsetof(tbl##Rec,m_##col), sizeof(((tbl##Rec*)(0))->m_##col))
#define SCHEMA_ITEM_RID(tbl,col,tbl2) SCHEMA_ITEM_ENTRY(col,TBL_##tbl2)
#define SCHEMA_ITEM_STRING(tbl,col) SCHEMA_ITEM_ENTRY(col,iSTRING)
#define SCHEMA_ITEM_GUID(tbl,col) SCHEMA_ITEM_ENTRY(col,iGUID)
#define SCHEMA_ITEM_BLOB(tbl,col) SCHEMA_ITEM_ENTRY(col,iBLOB)
#define SCHEMA_ITEM_CDTKN(tbl,col,tkns) SCHEMA_ITEM_ENTRY(col,iCodedToken+(CDTKN_##tkns))
#define SCHEMA_TABLE_END(tbl) };
//-----------------------------------------------------------------------------
#include "MetaModelColumnDefs.h"
//-----------------------------------------------------------------------------
#undef SCHEMA_TABLE_START
#undef SCHEMA_ITEM_NOFIXED
#undef SCHEMA_ITEM_ENTRY
#undef SCHEMA_ITEM_ENTRY2
#undef SCHEMA_ITEM
#undef SCHEMA_ITEM_RID
#undef SCHEMA_ITEM_STRING
#undef SCHEMA_ITEM_GUID
#undef SCHEMA_ITEM_BLOB
#undef SCHEMA_ITEM_CDTKN
#undef SCHEMA_TABLE_END
//-----------------------------------------------------------------------------
// End of column defninitions.
//-----------------------------------------------------------------------------

// Define the array of Coded Token Definitions.
#define MiniMdCodedToken(x) {lengthof(CMiniMdBase::mdt##x), CMiniMdBase::mdt##x, #x},
const CCodedTokenDef g_CodedTokens [] = {
    MiniMdCodedTokens()
};
#undef MiniMdCodedToken

// Define the array of Table Definitions.
#undef MiniMdTable
#define MiniMdTable(x) {r##x##Cols, lengthof(r##x##Cols), x##Rec::COL_KEY, 0, r##x##ColNames, #x}, 
const CMiniTableDefEx g_Tables[TBL_COUNT] = {
    MiniMdTables()
};

// Define the array of Ptr Tables.  This is initialized to TBL_COUNT here.
// The correct values will be set in the constructor for MiniMdRW.
#undef MiniMdTable
#define MiniMdTable(x) { TBL_COUNT, 0 },
TblCol g_PtrTableIxs[TBL_COUNT] = {
    MiniMdTables()
};

//*****************************************************************************
// Initialize a new schema.
//*****************************************************************************
void CMiniMdSchema::InitNew()
{
    // Make sure the tables fit in the mask.
    _ASSERTE(sizeof(m_maskvalid)*8 > TBL_COUNT);
	
    m_ulReserved = 0;   	    
	m_major = METAMODEL_MAJOR_VER;				
	m_minor = METAMODEL_MINOR_VER;
	m_heaps = 0;				
	m_rid = 0;					
	m_maskvalid = 0;			
	m_sorted = 0;				
	memset(m_cRecs, 0, sizeof(m_cRecs));		
	m_ulExtra = 0;				
} // void CMiniMdSchema::InitNew()

//*****************************************************************************
// Compress a schema into a compressed version of the schema.
//*****************************************************************************
ULONG CMiniMdSchema::SaveTo(
    void        *pvData)
{
    ULONG       ulData;                 // Bytes stored.
    CMiniMdSchema *pDest = reinterpret_cast<CMiniMdSchema*>(pvData);
    const unsigned __int64 one = 1;

    // Make sure the tables fit in the mask.
    _ASSERTE(sizeof(m_maskvalid)*8 > TBL_COUNT);

    // Set the flag for the extra data.
#if defined(EXTRA_DATA)
    if (m_ulExtra != 0)
        m_heaps |= EXTRA_DATA;
    else
#endif // 0
        m_heaps &= ~EXTRA_DATA;

    // Minor version is preset when we instantiate the MiniMd.
    m_minor = METAMODEL_MINOR_VER;
    m_major = METAMODEL_MAJOR_VER;

    // Transfer the fixed fields.
    *static_cast<CMiniMdSchemaBase*>(pDest) = *static_cast<CMiniMdSchemaBase*>(this);
    ulData = sizeof(CMiniMdSchemaBase);

    // Transfer the variable fields.
    m_maskvalid = 0;
    for (int iSrc=0, iDst=0; iSrc<TBL_COUNT; ++iSrc)
    {
        if (m_cRecs[iSrc])
        {
            pDest->m_cRecs[iDst++] = m_cRecs[iSrc];
            m_maskvalid |= (one << iSrc);
            ulData += sizeof(m_cRecs[iSrc]);
        }
    }
    // Refresh the mask.
    pDest->m_maskvalid = m_maskvalid;

#if defined(EXTRA_DATA)
    // Store the extra data.
    if (m_ulExtra != 0)
    {
        *reinterpret_cast<ULONG*>(&pDest->m_cRecs[iDst]) = m_ulExtra;
        ulData += sizeof(ULONG);
    }
#endif // 0
    return ulData;
} // ULONG CMiniMdSchema::SaveTo()

//*****************************************************************************
// Load a schema from a compressed version of the schema.
//*****************************************************************************
ULONG CMiniMdSchema::LoadFrom(          // Bytes consumed.
    const void      *pvData)            // Data to load from.
{
    ULONG       ulData;                 // Bytes consumed.
    const CMiniMdSchema *pSource = reinterpret_cast<const CMiniMdSchema*>(pvData);

    // Transfer the fixed fields.
    *static_cast<CMiniMdSchemaBase*>(this) = *static_cast<const UNALIGNED CMiniMdSchemaBase*>(pSource);
    ulData = sizeof(CMiniMdSchemaBase);

    unsigned __int64 maskvalid = m_maskvalid;

    // Transfer the variable fields.
    memset(m_cRecs, 0, sizeof(m_cRecs));
    for (int iSrc=0, iDst=0; iDst<TBL_COUNT; ++iDst, maskvalid >>= 1)
    {
        if (maskvalid & 1)
        {
            m_cRecs[iDst] = pSource->m_cRecs[iSrc++];
            ulData += sizeof(pSource->m_cRecs[iSrc]);
        }
    }
    // Also accumulate the sizes of any counters that we don't understand.
    for (iDst=TBL_COUNT; iDst<sizeof(m_maskvalid)*8; ++iDst, maskvalid >>= 1)
    {
        if (maskvalid & 1)
        {
            ulData += sizeof(m_cRecs[iSrc]);
            iSrc++;
        }
    }

    // Retrieve the extra data.
    if (m_heaps & EXTRA_DATA)
    {
        m_ulExtra = *reinterpret_cast<const ULONG*>(&pSource->m_cRecs[iSrc]);
        ulData += sizeof(ULONG);
    }

    return ulData;
} // ULONG CMiniMdSchema::LoadFrom()

const mdToken CMiniMdBase::mdtTypeDefOrRef[3] = {
    mdtTypeDef, 
    mdtTypeRef,
    mdtTypeSpec
};

// This array needs to be ordered the same as the source tables are processed (currently
//  {field, param, property}) for binary search.
const mdToken CMiniMdBase::mdtHasConstant[3] = {
    mdtFieldDef, 
    mdtParamDef, 
    mdtProperty
};

const mdToken CMiniMdBase::mdtHasCustomAttribute[21] = {
	mdtMethodDef, 
	mdtFieldDef, 
	mdtTypeRef, 
	mdtTypeDef, 
	mdtParamDef, 
	mdtInterfaceImpl, 
	mdtMemberRef, 
	mdtModule,
	mdtPermission,
	mdtProperty,
	mdtEvent,
	mdtSignature,
	mdtModuleRef,
    mdtTypeSpec,
    mdtAssembly,
    mdtAssemblyRef,
    mdtFile,
    mdtExportedType,
    mdtManifestResource,
};

const mdToken CMiniMdBase::mdtHasFieldMarshal[2] = {
    mdtFieldDef,
    mdtParamDef,
};

const mdToken CMiniMdBase::mdtHasDeclSecurity[3] = {
    mdtTypeDef,
    mdtMethodDef,
    mdtAssembly
};

const mdToken CMiniMdBase::mdtMemberRefParent[5] = {
    mdtTypeDef, 
    mdtTypeRef,
    mdtModuleRef,
    mdtMethodDef,
    mdtTypeSpec
};

const mdToken CMiniMdBase::mdtHasSemantic[2] = {
    mdtEvent,
    mdtProperty,
};

const mdToken CMiniMdBase::mdtMethodDefOrRef[2] = {
    mdtMethodDef, 
    mdtMemberRef
};

const mdToken CMiniMdBase::mdtMemberForwarded[2] = {
    mdtFieldDef,
    mdtMethodDef
};

const mdToken CMiniMdBase::mdtImplementation[3] = {
    mdtFile,
    mdtAssemblyRef,
    mdtExportedType
};

const mdToken CMiniMdBase::mdtCustomAttributeType[5] = {
    0,
    0,
    mdtMethodDef,
    mdtMemberRef,
    0
};

const mdToken CMiniMdBase::mdtResolutionScope[4] = {
    mdtModule,
    mdtModuleRef,
    mdtAssemblyRef,
    mdtTypeRef
};

const int CMiniMdBase::m_cb[] = {0,1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}; 

//*****************************************************************************
// Function to encode a token into fewer bits.  Looks up token type in array of types.
//*****************************************************************************
// @consider whether this could be a binary search.
ULONG CMiniMdBase::encodeToken(             // The coded token.
    RID         rid,                    // Rid to encode.
    mdToken     typ,                    // Token type to encode.
    const mdToken rTokens[],            // Table of valid token.
    ULONG32     cTokens)                // Size of the table.
{
    mdToken tk = TypeFromToken(typ);
    for (size_t ix=0; ix<cTokens; ++ix)
        if (rTokens[ix] == tk)
            break;
    _ASSERTE(ix < cTokens);
    //@FUTURE: make compile-time calculation
    return (ULONG)((rid << m_cb[cTokens]) | ix);
} // ULONG CMiniMd::encodeToken)


//*****************************************************************************
// Helpers for populating the hard-coded schema.
//*****************************************************************************
inline BYTE cbRID(ULONG ixMax) { return ixMax > USHRT_MAX ? sizeof(ULONG) : sizeof(USHORT); }

#define _CBTKN(cRecs,tkns) cbRID(cRecs << m_cb[lengthof(tkns)])





CMiniMdBase::CMiniMdBase()
{
#undef MiniMdTable
#define MiniMdTable(tbl)                                    \
        m_TableDefs[TBL_##tbl] = g_Tables[TBL_##tbl].m_Def; \
        m_TableDefs[TBL_##tbl].m_pColDefs = m_##tbl##Col;
    MiniMdTables()

    // Validator depends on the Table Ids and the Token Ids being identical.
    // Catch it if this ever breaks.
    _ASSERTE((TypeFromToken(mdtModule) >> 24)           == TBL_Module);
    _ASSERTE((TypeFromToken(mdtTypeRef) >> 24)          == TBL_TypeRef);
    _ASSERTE((TypeFromToken(mdtTypeDef) >> 24)          == TBL_TypeDef);
    _ASSERTE((TypeFromToken(mdtFieldDef) >> 24)         == TBL_Field);
    _ASSERTE((TypeFromToken(mdtMethodDef) >> 24)        == TBL_Method);
    _ASSERTE((TypeFromToken(mdtParamDef) >> 24)         == TBL_Param);
    _ASSERTE((TypeFromToken(mdtInterfaceImpl) >> 24)    == TBL_InterfaceImpl);
    _ASSERTE((TypeFromToken(mdtMemberRef) >> 24)        == TBL_MemberRef);
    _ASSERTE((TypeFromToken(mdtCustomAttribute) >> 24)      == TBL_CustomAttribute);
    _ASSERTE((TypeFromToken(mdtPermission) >> 24)       == TBL_DeclSecurity);
    _ASSERTE((TypeFromToken(mdtSignature) >> 24)        == TBL_StandAloneSig);
    _ASSERTE((TypeFromToken(mdtEvent) >> 24)            == TBL_Event);
    _ASSERTE((TypeFromToken(mdtProperty) >> 24)         == TBL_Property);
    _ASSERTE((TypeFromToken(mdtModuleRef) >> 24)        == TBL_ModuleRef);
    _ASSERTE((TypeFromToken(mdtTypeSpec) >> 24)         == TBL_TypeSpec);
    _ASSERTE((TypeFromToken(mdtAssembly) >> 24)         == TBL_Assembly);
    _ASSERTE((TypeFromToken(mdtAssemblyRef) >> 24)      == TBL_AssemblyRef);
    _ASSERTE((TypeFromToken(mdtFile) >> 24)             == TBL_File);
    _ASSERTE((TypeFromToken(mdtExportedType) >> 24)     == TBL_ExportedType);
    _ASSERTE((TypeFromToken(mdtManifestResource) >> 24) == TBL_ManifestResource);
}

ULONG CMiniMdBase::SchemaPopulate2(
    int         bExtra)                 // Reserve an extra bit for rid columns?
{
    ULONG       cbTotal = 0;            // Total size of all tables.

    // How big are the various pool inidices?
    m_iStringsMask = (m_Schema.m_heaps & CMiniMdSchema::HEAP_STRING_4) ? 0xffffffff : 0xffff;
    m_iGuidsMask = (m_Schema.m_heaps & CMiniMdSchema::HEAP_GUID_4) ? 0xffffffff : 0xffff;
    m_iBlobsMask = (m_Schema.m_heaps & CMiniMdSchema::HEAP_BLOB_4) ? 0xffffffff : 0xffff;

    // Make extra bits exactly zero or one bit.
    if (bExtra) bExtra = 1;

    // Until ENC, make extra bits exactly zero.
    bExtra = 0;

    // For each table...
    for (int ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        // Pointer to the template CMiniTableDef.
        const CMiniTableDef *pTable = &g_Tables[ixTbl].m_Def;
        // Pointer to the per-MiniMd CMiniColDefs.
        CMiniColDef *pCols = m_TableDefs[ixTbl].m_pColDefs;

        InitColsForTable(m_Schema, ixTbl, &m_TableDefs[ixTbl], bExtra);

        // Accumulate size of this table.
        cbTotal += m_TableDefs[ixTbl].m_cbRec * vGetCountRecs(ixTbl);
    }

    // Allocate the heaps for the tables.
    return cbTotal;
} // ULONG CMiniMdBase::SchemaPopulate2()

//*****************************************************************************
// Initialize the column defs for a table, based on their types and sizes.
//*****************************************************************************
void CMiniMdBase::InitColsForTable(     //
    CMiniMdSchema &Schema,              // Schema with sizes.
    int         ixTbl,                  // Index of table to init.                                 
    CMiniTableDef *pTable,              // Table to init.
    int         bExtra)                 // Extra bits for rid column.
{
    CMiniColDef *pCols;                 // The col defs to init.
    BYTE        iOffset;                // Running size of a record.
    BYTE        iSize;                  // Size of a field.

	_ASSERTE(bExtra == 0 || bExtra == 1);

	bExtra = 0;//@FUTURE: save in schema header.  until then use 0.
    
	iOffset = 0;
    pCols = pTable->m_pColDefs;

    // # rows in largest table.
    ULONG       cMaxTbl = 1 << Schema.m_rid;        
    
    // For each column in the table...
    for (ULONG ixCol=0; ixCol<pTable->m_cCols; ++ixCol)
    {
        // Initialize from the template values (type, maybe offset, size).
        pCols[ixCol] = g_Tables[ixTbl].m_Def.m_pColDefs[ixCol];

        // Is the field a RID into a table?
        if (pCols[ixCol].m_Type <= iRidMax)
        {
            iSize = cbRID(Schema.m_cRecs[pCols[ixCol].m_Type] << bExtra);
        }
        else
        // Is the field a coded token?
        if (pCols[ixCol].m_Type <= iCodedTokenMax)
        {
            ULONG iCdTkn = pCols[ixCol].m_Type - iCodedToken;
            ULONG cRecs = 0;

#if defined(OPTIMIZE_CODED_TOKENS)
            ULONG ixTbl;
            _ASSERTE(iCdTkn < lengthof(g_CodedTokens));
            CCodedTokenDef const *pCTD = &g_CodedTokens[iCdTkn];

            // Iterate the token list of this coded token.
            for (ULONG ixToken=0; ixToken<pCTD->m_cTokens; ++ixToken)
            {   // Ignore string tokens.
				if (pCTD->m_pTokens[ixToken] != mdtString)
				{
					// Get the table for the token.
					ixTbl = CMiniMdRW::GetTableForToken(pCTD->m_pTokens[ixToken]);
					_ASSERTE(ixTbl < TBL_COUNT);
					// If largest token seen so far, remember it.
					if (Schema.m_cRecs[ixTbl] > cRecs)
						cRecs = Schema.m_cRecs[ixTbl];
				}
            }

            iSize = cbRID(cRecs << (bExtra + m_cb[pCTD->m_cTokens]));

#else //defined(OPTIMIZE_CODED_TOKENS)
            switch (iCdTkn)
            {
            case CDTKN_TypeDefOrRef:
                cRecs = max(Schema.m_cRecs[TBL_TypeDef],Schema.m_cRecs[TBL_TypeRef]);
                break;
            case CDTKN_HasSemantic:
                cRecs = max(Schema.m_cRecs[TBL_Event],Schema.m_cRecs[TBL_Property]);
                break;
            case CDTKN_MethodDefOrRef:
                cRecs = max(Schema.m_cRecs[TBL_Method],Schema.m_cRecs[TBL_MemberRef]);
                break;
            case CDTKN_ResolutionScope:
                cRecs = max(Schema.m_cRecs[TBL_ModuleRef],Schema.m_cRecs[TBL_AssemblyRef]);
                break;
            default:
                cRecs = cMaxTbl;
                break;
            }
            iSize = cbRID(cRecs << m_cb[g_CodedTokens[iCdTkn].m_cTokens]);
#endif // defined(OPTIMIZE_CODED_TOKENS)
		
		}
        else
        {   // Fixed type.
            switch (pCols[ixCol].m_Type)
            {
            case iBYTE:
                iSize = 1;
                _ASSERTE(pCols[ixCol].m_cbColumn == iSize);
                _ASSERTE(pCols[ixCol].m_oColumn == iOffset);
                break;
            case iSHORT:
            case iUSHORT:
                iSize = 2;
                _ASSERTE(pCols[ixCol].m_cbColumn == iSize);
                _ASSERTE(pCols[ixCol].m_oColumn == iOffset);
                break;
            case iLONG:
            case iULONG:
                iSize = 4;
                _ASSERTE(pCols[ixCol].m_cbColumn == iSize);
                _ASSERTE(pCols[ixCol].m_oColumn == iOffset);
                break;
            case iSTRING:
                iSize = (Schema.m_heaps & CMiniMdSchema::HEAP_STRING_4) ? 4 : 2;
                break;
            case iGUID:
                iSize = (Schema.m_heaps & CMiniMdSchema::HEAP_GUID_4) ? 4 : 2;
                break;
            case iBLOB:
                iSize = (Schema.m_heaps & CMiniMdSchema::HEAP_BLOB_4) ? 4 : 2;
                break;
            default:
                _ASSERTE(!"Unexpected schema type");
                iSize = 0;
                break;
            }
        }

        // Now save the size and offset.
        pCols[ixCol].m_oColumn = iOffset;
        pCols[ixCol].m_cbColumn = iSize;

        // Align to 2 bytes.
        iSize += iSize & 1;
         
        iOffset += iSize;
    }
    // Record size of entire record.
    pTable->m_cbRec = iOffset;

    // If no key, set to a distinct value.
    if (pTable->m_iKey >= pTable->m_cCols)
        pTable->m_iKey = -1;

} // void CMiniMdBase::InitColsForTable()

//*****************************************************************************
// Get the count of records in a table.  Virtual.
//*****************************************************************************
ULONG CMiniMdBase::vGetCountRecs(       // Count of rows in table
    ULONG       ixTbl)                  // Table index
{
    _ASSERTE(ixTbl < TBL_COUNT);
    return m_Schema.m_cRecs[ixTbl];
} // ULONG CMiniMdBase::vGetCountRecs()

//*****************************************************************************
// Search a table for the row containing the given key value.
//  EG. Constant table has pointer back to Param or Field.
//*****************************************************************************
RID CMiniMdBase::vSearchTable(		    // RID of matching row, or 0.
    ULONG       ixTbl,                  // Table to search.
    CMiniColDef sColumn,                // Sorted key column, containing search value.
    ULONG       ulTarget)               // Target for search.
{
    const void  *pRow;                  // Row from a table.
    ULONG       val;                    // Value from a row.

    int         lo,mid,hi;              // binary search indices.

    // Start with entire table.
    lo = 1;
    hi = vGetCountRecs(ixTbl);
    // While there are rows in the range...
    while (lo <= hi)
    {   // Look at the one in the middle.
        mid = (lo + hi) / 2;
        pRow = vGetRow(ixTbl, mid);
        val = getIX(pRow, sColumn);
        // If equal to the target, done.
        if (val == ulTarget)
            return mid;
        // If middle item is too small, search the top half.
        if (val < ulTarget)
            lo = mid + 1;
        else // but if middle is to big, search bottom half.
            hi = mid - 1;
    }
    // Didn't find anything that matched.
    return 0;
} // RID CMiniMdBase::vSearchTable()

//*****************************************************************************
// Search a table for the highest-RID row containing a value that is less than
//  or equal to the target value.  EG.  TypeDef points to first Field, but if 
//  a TypeDef has no fields, it points to first field of next TypeDef.
//*****************************************************************************
RID CMiniMdBase::vSearchTableNotGreater( // RID of matching row, or 0.
    ULONG       ixTbl,                  // Table to search.
    CMiniColDef sColumn,                // the column def containing search value
    ULONG       ulTarget)               // target for search
{
    const void  *pRow;                  // Row from a table.
    ULONG       cRecs;                  // Rows in the table.
    ULONG       val;                    // Value from a table.
    ULONG       lo,mid,hi;              // binary search indices.

    cRecs = vGetCountRecs(ixTbl); 
#if defined(_DEBUG)
    // Old, brute force method is kept around as a check of the slightly tricky
    //  non-equal binary search.
    int         iDebugIx;

    // starting from the end of the table...
    for (iDebugIx = cRecs; iDebugIx >= 1; iDebugIx--)
    {
        pRow = vGetRow(ixTbl, iDebugIx);
        val = getIX(pRow, sColumn);
        if (val <= ulTarget)
            break;
    }
#endif

    // Start with entire table.
    lo = 1;
    hi = cRecs;
    // If no recs, return.
    if (lo > hi)
    {
        _ASSERTE(iDebugIx == 0);
        return 0;
    }
    // While there are rows in the range...
    while (lo <= hi)
    {   // Look at the one in the middle.
        mid = (lo + hi) / 2;
        pRow = vGetRow(ixTbl, mid);
        val = getIX(pRow, sColumn);
        // If equal to the target, done searching.
        if (val == ulTarget)
            break;
        // If middle item is too small, search the top half.
        if (val < ulTarget)
            lo = mid + 1;
        else // but if middle is to big, search bottom half.
            hi = mid - 1;
    }
    // May or may not have found anything that matched.  Mid will be close, but may
    //  be to high or too low.  It should point to the highest acceptable
    //  record.

    // If the value is greater than the target, back up just until the value is
    //  less than or equal to the target.  SHOULD only be one step.
    if (val > ulTarget)
    {
        while (val > ulTarget)
        {
            // If there is nothing else to look at, we won't find it.
            if (--mid < 1)
                break;
            pRow = vGetRow(ixTbl, mid);
            val = getIX(pRow, sColumn);
        }
    }
    else
    {
        // Value is less than or equal to the target.  As long as the next 
        //  record is also acceptable, move forward.
        while (mid < cRecs)
        {
            // There is another record.  Get its value.
            pRow = vGetRow(ixTbl, mid+1);
            val = getIX(pRow, sColumn);
            // If that record is too high, stop.
            if (val > ulTarget)
                break;
            mid++;
        }
    }
    
    // Return the value that's just less than the target.
    _ASSERTE(mid == (ULONG)iDebugIx);
    return mid;
} // RID CMiniMdBase::vSearchTableNotGreater()

//*****************************************************************************
// Search a table for multiple (adjacent) rows containing the given
//  key value.  EG, InterfaceImpls all point back to the implementing class.
//*****************************************************************************
RID CMiniMdBase::SearchTableForMultipleRows( // First RID found, or 0.
    ULONG       ixTbl,                  // Table to search.
    CMiniColDef sColumn,                // Sorted key column, containing search value.
    ULONG       ulTarget,               // Target for search.
    RID         *pEnd)                  // [OPTIONAL, OUT] 
{
    ULONG       ridBegin;               // RID of first entry.
    ULONG       ridEnd;                 // RID of first entry past last entry.

    // Search for any entry in the table.
    ridBegin = vSearchTable(ixTbl, sColumn, ulTarget);

    // If nothing found, return invalid RID.
    if (ridBegin == 0)
    {
        if (pEnd) *pEnd = 0;
        return 0;
    }

    // End will be at least one larger than found record.
    ridEnd = ridBegin + 1;

    // Search back to start of group.
    while (ridBegin > 1 && getIX(vGetRow(ixTbl, ridBegin-1), sColumn) == ulTarget)
        --ridBegin;

    // If desired, search forward to end of group.
    if (pEnd)
    {
        while (ridEnd <= vGetCountRecs(ixTbl) && 
               getIX(vGetRow(ixTbl, ridEnd), sColumn) == ulTarget)
            ++ridEnd;
        *pEnd = ridEnd;
    }

    return ridBegin;    
} // RID CMiniMdBase::SearchTableForMultipleRows()


//*****************************************************************************
// @FUTURE: a better implementation?? Linear search is used!
// It is non-trivial to sort propertymap. VB is generating properties in 
// non-sorted order!!!
//
//*****************************************************************************
RID CMiniMdBase::FindPropertyMapFor(
    RID         ridParent)
{
    ULONG       i;
    ULONG       iCount;
    const void  *pRec;
    HRESULT     hr = NOERROR;
    RID         rid;

    iCount = vGetCountRecs(TBL_PropertyMap);

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRec = vGetRow(TBL_PropertyMap, i);

        // linear search for propertymap record
        rid = getIX(pRec, _COLDEF(PropertyMap,Parent));
        if (rid == ridParent)
            return i;
    }
    return 0;
} // RID CMiniMdBase::FindPropertyMapFor()


//*****************************************************************************
// @FUTURE: a better implementation?? Linear search is used!
// It is non-trivial to sort eventmap. VB is generating events in 
// non-sorted order!!!
//
//*****************************************************************************
RID CMiniMdBase::FindEventMapFor(
    RID         ridParent)
{
    ULONG       i;
    ULONG       iCount;
    const void  *pRec;
    HRESULT     hr = NOERROR;
    RID         rid;

    iCount = vGetCountRecs(TBL_EventMap);

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRec = vGetRow(TBL_EventMap, i);

        // linear search for propertymap record
        rid = getIX(pRec, _COLDEF(EventMap,Parent));
        if (rid == ridParent)
            return i;
    }
    return 0;
} // RID CMiniMdBase::FindEventMapFor()


//*****************************************************************************
// Search for a custom value with a given type.
//*****************************************************************************
RID CMiniMdBase::FindCustomAttributeFor(// RID of custom value, or 0.
    RID         rid,                    // The object's rid.
    mdToken     tkObj,                  // The object's type.
    mdToken     tkType)                 // Type of custom value.
{
    int         ixFound;                // index of some custom value row.
    ULONG       ulTarget = encodeToken(rid,tkObj,mdtHasCustomAttribute,lengthof(mdtHasCustomAttribute)); // encoded token representing target.
    ULONG       ixCur;                  // Current row being examined.
    mdToken     tkFound;                // Type of some custom value row.
    const void  *pCur;                  // A custom value entry.

    // Search for any entry in CustomAttribute table.  Convert to RID.
    ixFound = vSearchTable(TBL_CustomAttribute, _COLDEF(CustomAttribute,Parent), ulTarget);
    if (ixFound == 0)
        return 0;

    // Found an entry that matches the item.  Could be anywhere in a range of 
    //  custom values for the item, somewhat at random.  Search for a match
    //  on name.  On entry to the first loop, we know the object is the desired
    //  one, so the object test is at the bottom.
    ixCur = ixFound;
    pCur = vGetRow(TBL_CustomAttribute, ixCur);
    for(;;)
    {
        // Test the type of the current row.
        tkFound = getIX(pCur, _COLDEF(CustomAttribute,Type));
        tkFound = decodeToken(tkFound, mdtCustomAttributeType, lengthof(mdtCustomAttributeType));
        if (tkFound == tkType)
            return ixCur;
        // Was this the last row of the CustomAttribute table?
        if (ixCur == vGetCountRecs(TBL_CustomAttribute))
            break;
        // No match, more rows, try for the next row.
        ++ixCur;
        // Get the row and see if it is for the same object.
        pCur = vGetRow(TBL_CustomAttribute, ixCur);
        if (getIX(pCur, _COLDEF(CustomAttribute,Parent)) != ulTarget)
            break;
    }
    // Didn't find the name looking up.  Try looking down.
    ixCur = ixFound - 1;
    for(;;)
    {
        // Run out of table yet?
        if (ixCur == 0)
            break;
        // Get the row and see if it is for the same object.
        pCur = vGetRow(TBL_CustomAttribute, ixCur);
        // still looking at the same object?
        if (getIX(pCur, _COLDEF(CustomAttribute,Parent)) != ulTarget)
            break;
        // Test the type of the current row.
        tkFound = getIX(pCur, _COLDEF(CustomAttribute,Type));
        tkFound = decodeToken(tkFound, mdtCustomAttributeType, lengthof(mdtCustomAttributeType));
        if (tkFound == tkType)
            return ixCur;
        // No match, try for the previous row.
        --ixCur;
    }
    // Didn't find anything.
    return 0;
} // RID CMiniMdBase::FindCustomAttributeFor()

// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtimestub\runtimestub.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Empty.cpp
//
// Helper code for empty extern ref in src\complib\Meta\emitapi.cpp (Meta.lib)
//*****************************************************************************
#include <windows.h> 
#include <wtypes.h> 
#include "corhdr.h"

class CMiniMdRW;
struct IMetaModelCommon;
class MDTOKENMAP;
class CQuickBytes;

HRESULT STDMETHODCALLTYPE
GetInternalWithRWFormat(
    LPVOID      pData, 
    ULONG       cbData, 
	DWORD		flags,					// [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
	REFIID		riid,					// [in] The interface desired.
	void		**ppIUnk)				// [out] Return interface on success.
{
    return E_NOTIMPL;
}

HRESULT TranslateSigHelper(             // S_OK or error.
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
    IMetaModelCommon *pAssemCommon,     // [IN] Assembly import scope.
    const void  *pbHashValue,           // [IN] Hash value.
    ULONG       cbHashValue,            // [IN] Size in bytes.
    IMetaModelCommon *pCommon,          // [IN] The scope to merge into the emit scope.
    PCCOR_SIGNATURE pbSigImp,           // [IN] signature from the imported scope
    MDTOKENMAP  *ptkMap,                // [IN] Internal OID mapping structure.
    CQuickBytes *pqkSigEmit,            // [OUT] translated signature
    ULONG       cbStartEmit,            // [IN] start point of buffer to write to
    ULONG       *pcbImp,                // [OUT] total number of bytes consumed from pbSigImp
    ULONG       *pcbEmit)               // [OUT] total number of bytes write to pqkSigEmit
{
    return E_NOTIMPL;
}

class CMiniMdRW
{
public:
    static unsigned long __stdcall GetTableForToken(mdToken);
};

unsigned long __stdcall CMiniMdRW::GetTableForToken(mdToken)
{
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\binarytree.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __BINARYTREE_H__
#define __BINARYTREE_H__

template <class KeyType, class DataType>
class BinaryTree
{
protected:
    //---------------------------------------------------------------------------------------------------------------
    // This represents a node in the memory block binary search tree
    class Node
    {
    public:
        Node(KeyType key, DataType *pData) : 
            m_pParent(NULL), m_pLeft(NULL), m_pRight(NULL), m_key(key), m_pData(pData) {}

        // Parent, left and right children of the node
        Node           *m_pParent;
        Node           *m_pLeft;
        Node           *m_pRight;

        // This is the actual memory block
        KeyType         m_key;
        DataType       *m_pData;
    };

    Node           *m_pRoot;          // Root of the binary search tree
    Node           *m_pCursor;        // Used for iterating over the tree

    Node *FindFirst_(Node *pRoot)
    {
        if (pRoot == NULL)
            return NULL;

        while (pRoot->m_pLeft != NULL)
            pRoot = pRoot->m_pLeft;

        return pRoot;
    }

    Node *FindNext_(Node *pCursor)
    {
        if (pCursor == NULL)
            return NULL;

        if (pCursor->m_pRight != NULL)
            return FindFirst_(pCursor->m_pRight);

        while (pCursor->m_pParent != NULL && pCursor->m_pParent->m_pRight == pCursor)
            pCursor = pCursor->m_pParent;

        // This will be null if we were just on the last element
        return pCursor->m_pParent;
    }

    Node *Find_(KeyType key, Node *pRoot)
    {
        Node *pCur = pRoot;
        while (pCur != NULL)
        {
            if (key < pCur->m_key)
                // The block is less than the current
                pCur = pCur->m_pLeft;
            else if (pCur->m_key < key)
                // The block is greater than the current
                pCur = pCur->m_pRight;
            else
                // Found it!
                break;
        }

        // Return result
        return (pCur);
    }

    Node *Insert_(KeyType key, DataType *pData, Node **ppRoot)
    {
        Node  *pParent = NULL;
        Node **ppCur = ppRoot;
        while (*ppCur != NULL)
        {
            pParent = *ppCur;
            DataType *pCur = (*ppCur)->m_pData;

            if (key < pCur->Key())
                // The block to add is less than the current
                ppCur = &((*ppCur)->m_pLeft);
            else if (pCur->Key() < key)
                // The block to add is greater than the current
                ppCur = &((*ppCur)->m_pRight);
            else
                // This means the block is already in the tree
                return (NULL);
        }

        // Allocate new node
        Node *pNewNode = new Node(key, pData);
        if (pNewNode == NULL)
            return NULL;

        // Add new node
        pNewNode->m_pParent = pParent;
        *ppCur = pNewNode;

        // Indicate success
        return (pNewNode);
    }

#if 0
    void left_rotate(Node *x)
    {
        Node *y;
        y = x->m_pRight;
        /* Turn y's left sub-tree into x's right sub-tree */
        x->m_pRight = y->m_pLeft;
        if (y->m_pLeft != NULL)
            y->m_pLeft->m_pParent = x;
        /* y's new parent was x's parent */
        y->m_pParent = x->m_pParent;
        /* Set the parent to point to y instead of x */
        /* First see whether we're at the root */
        if (x->m_pParent == NULL)
            m_pRoot = y;
        else if (x == (x->m_pParent)->m_pLeft)
            /* x was on the left of its parent */
            x->m_pParent->m_pLeft = y;
        else
            /* x must have been on the right */
            x->m_pParent->m_pRight = y;
        /* Finally, put x on y's left */
        y->m_pLeft = x;
        x->m_pParent = y;
    }
    
    void right_rotate(Node *x)
    {
        Node *y;
        y = x->m_pLeft;
        /* Turn y's left sub-tree into x's right sub-tree */
        x->m_pLeft = y->m_pRight;
        if (y->m_pRight != NULL)
            y->m_pRight->m_pParent = x;
        /* y's new parent was x's parent */
        y->m_pParent = x->m_pParent;
        /* Set the parent to point to y instead of x */
        /* First see whether we're at the root */
        if (x->m_pParent == NULL)
            m_pRoot = y;
        else if (x == (x->m_pParent)->m_pRight)
            /* x was on the left of its parent */
            x->m_pParent->m_pRight = y;
        else
            /* x must have been on the right */
            x->m_pParent->m_pLeft = y;
        /* Finally, put x on y's left */
        y->m_pRight = x;
        x->m_pParent = y;
    }
    
    void rb_insert(Node *x)
    {
        Node *y;
        /* Insert in the tree in the usual way */
        tree_insert(x);
        /* Now restore the red-black property */
        x->m_colour = red;
        while ((x != m_pRoot) && (x->m_pParent->m_colour == red))
        {
            if (x->m_pParent == x->m_pParent->m_pParent->m_pLeft)
            {
                /* If x's parent is a left, y is x's right 'uncle' */
                y = x->m_pParent->m_pParent->m_pRight;
                if (y->m_colour == red)
                {
                    /* case 1 - change the m_colours */
                    x->m_pParent->m_colour = black;
                    y->m_colour = black;
                    x->m_pParent->m_pParent->m_colour = red;
                    /* Move x up the tree */
                    x = x->m_pParent->m_pParent;
                }
                else
                {
                    /* y is a black node */
                    if (x == x->m_pParent->m_pRight)
                    { 
                        /* and x is to the right */
                        /* case 2 - move x up and rotate */
                        x = x->m_pParent;
                        left_rotate(x);
                    }
                    /* case 3 */
                    x->m_pParent->m_colour = black;
                    x->m_pParent->m_pParent->m_colour = red;
                    right_rotate(x->m_pParent->m_pParent);
                }
            }
            else
            {
                /* If x's parent is a left, y is x's right 'uncle' */
                y = x->m_pParent->m_pParent->m_pLeft;
                if (y->m_colour == red)
                {
                    /* case 1 - change the m_colours */
                    x->m_pParent->m_colour = black;
                    y->m_colour = black;
                    x->m_pParent->m_pParent->m_colour = red;
                    /* Move x up the tree */
                    x = x->m_pParent->m_pParent;
                }
                else
                {
                    /* y is a black node */
                    if (x == x->m_pParent->m_pLeft)
                    { 
                        /* and x is to the right */
                        /* case 2 - move x up and rotate */
                        x = x->m_pParent;
                        left_rotate(x);
                    }
                    /* case 3 */
                    x->m_pParent->m_colour = black;
                    x->m_pParent->m_pParent->m_colour = red;
                    right_rotate(x->m_pParent->m_pParent);
                }
            }
            /* Colour the root black */
            m_pRoot->m_colour = black;
        }
    }

    void tree_insert(Node *x)
    {
    }
#endif

public:
    BinaryTree() : m_pRoot(NULL), m_pCursor(NULL) { }

    BOOL Insert(KeyType key, DataType *pData)
    {
        return Insert_(key, pData, &m_pRoot) != NULL;
    }

    DataType *Find(KeyType key)
    {
        Node *pNode = Find_(key, m_pRoot);

        return pNode == NULL ? NULL : pNode->m_pData;
    }

    void Reset()
    {
        m_pCursor = NULL;
    }

    DataType *Next()
    {
        Node *pRes;

        if (m_pCursor == (Node *)0xFFFFFFFF)
            return NULL;
        else if (m_pCursor == NULL)
            m_pCursor = pRes = FindFirst_(m_pRoot);
        else
            m_pCursor = pRes = FindNext_(m_pCursor);

        if (pRes == NULL)
            m_pCursor = (Node *)0xFFFFFFFF;

        return (pRes == NULL ? NULL : pRes->m_pData);
    }
};

#endif // __BINARY_TREE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\metamodelcolumndefs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelColumnDefs.h -- Table definitions for MetaData.
//
//*****************************************************************************

	//
	// These are used by #defining appropriately, then #including this file.
	//
    //-------------------------------------------------------------------------
    //Module
    SCHEMA_TABLE_START(Module)
    SCHEMA_ITEM(Module, USHORT, Generation)
    SCHEMA_ITEM_STRING(Module, Name)
    SCHEMA_ITEM_GUID(Module, Mvid)
    SCHEMA_ITEM_GUID(Module, EncId)
    SCHEMA_ITEM_GUID(Module, EncBaseId)
    SCHEMA_TABLE_END(Module)

    //-------------------------------------------------------------------------
    //TypeRef
    SCHEMA_TABLE_START(TypeRef)
    SCHEMA_ITEM_CDTKN(TypeRef, ResolutionScope, ResolutionScope)
    SCHEMA_ITEM_STRING(TypeRef, Name)
    SCHEMA_ITEM_STRING(TypeRef, Namespace)
    SCHEMA_TABLE_END(TypeRef)

    //-------------------------------------------------------------------------
    // TypeDef
    SCHEMA_TABLE_START(TypeDef)
    SCHEMA_ITEM(TypeDef, ULONG, Flags)
    SCHEMA_ITEM_STRING(TypeDef, Name)
    SCHEMA_ITEM_STRING(TypeDef, Namespace)
    SCHEMA_ITEM_CDTKN(TypeDef, Extends, TypeDefOrRef)
    SCHEMA_ITEM_RID(TypeDef, FieldList, Field)
    SCHEMA_ITEM_RID(TypeDef, MethodList, Method)
    SCHEMA_TABLE_END(TypeDef)

    //-------------------------------------------------------------------------
    //FieldPtr
    SCHEMA_TABLE_START(FieldPtr)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(FieldPtr, Field, Field)
    SCHEMA_TABLE_END(FieldPtr)

    //-------------------------------------------------------------------------
    //Field
    SCHEMA_TABLE_START(Field)
    SCHEMA_ITEM(Field, USHORT, Flags)
    SCHEMA_ITEM_STRING(Field,Name)
    SCHEMA_ITEM_BLOB(Field,Signature)
    SCHEMA_TABLE_END(Field)

    //-------------------------------------------------------------------------
    //MethodPtr
    SCHEMA_TABLE_START(MethodPtr)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(MethodPtr, Method, Method)
    SCHEMA_TABLE_END(MethodPtr)

    //-------------------------------------------------------------------------
    //Method
    SCHEMA_TABLE_START(Method)
    SCHEMA_ITEM(Method, ULONG, RVA)
    SCHEMA_ITEM(Method, USHORT, ImplFlags)
    SCHEMA_ITEM(Method, USHORT, Flags)
    SCHEMA_ITEM_STRING(Method,Name)
    SCHEMA_ITEM_BLOB(Method,Signature)
    SCHEMA_ITEM_RID(Method,ParamList,Param)
    SCHEMA_TABLE_END(Method)

    //-------------------------------------------------------------------------
    //ParamPtr
    SCHEMA_TABLE_START(ParamPtr)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(ParamPtr, Param, Param)
    SCHEMA_TABLE_END(ParamPtr)

    //-------------------------------------------------------------------------
    // Param
    SCHEMA_TABLE_START(Param)
    SCHEMA_ITEM(Param, USHORT, Flags)
    SCHEMA_ITEM(Param, USHORT, Sequence)
    SCHEMA_ITEM_STRING(Param,Name)
    SCHEMA_TABLE_END(Param)

    //-------------------------------------------------------------------------
    //InterfaceImpl
    SCHEMA_TABLE_START(InterfaceImpl)
    SCHEMA_ITEM_RID(InterfaceImpl,Class,TypeDef)
    SCHEMA_ITEM_CDTKN(InterfaceImpl,Interface,TypeDefOrRef)
    SCHEMA_TABLE_END(InterfaceImpl)

    //-------------------------------------------------------------------------
    //MemberRef
    SCHEMA_TABLE_START(MemberRef)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_CDTKN(MemberRef,Class,MemberRefParent)
    SCHEMA_ITEM_STRING(MemberRef,Name)
    SCHEMA_ITEM_BLOB(MemberRef,Signature)
    SCHEMA_TABLE_END(MemberRef)

    //-------------------------------------------------------------------------
    //Constant
    SCHEMA_TABLE_START(Constant)
    SCHEMA_ITEM(Constant, BYTE, Type)
    SCHEMA_ITEM_CDTKN(Constant,Parent,HasConstant)
    SCHEMA_ITEM_BLOB(Constant,Value)
    SCHEMA_TABLE_END(Constant)

	//-------------------------------------------------------------------------
	//CustomAttribute
	SCHEMA_TABLE_START(CustomAttribute)
	SCHEMA_ITEM_NOFIXED()
	SCHEMA_ITEM_CDTKN(CustomAttribute,Parent,HasCustomAttribute)
	SCHEMA_ITEM_CDTKN(CustomAttribute,Type,CustomAttributeType)
	SCHEMA_ITEM_BLOB(CustomAttribute,Value)
	SCHEMA_TABLE_END(CustomAttribute)

    //-------------------------------------------------------------------------
    //FieldMarshal
    SCHEMA_TABLE_START(FieldMarshal)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_CDTKN(FieldMarshal,Parent,HasFieldMarshal)
    SCHEMA_ITEM_BLOB(FieldMarshal,NativeType)
    SCHEMA_TABLE_END(FieldMarshal)

    //-------------------------------------------------------------------------
    //DeclSecurity
    SCHEMA_TABLE_START(DeclSecurity)
    SCHEMA_ITEM(DeclSecurity, SHORT, Action)
    SCHEMA_ITEM_CDTKN(DeclSecurity,Parent,HasDeclSecurity)
    SCHEMA_ITEM_BLOB(DeclSecurity,PermissionSet)
    SCHEMA_TABLE_END(DeclSecurity)

    //-------------------------------------------------------------------------
    //ClassLayout
    SCHEMA_TABLE_START(ClassLayout)
    SCHEMA_ITEM(ClassLayout, USHORT, PackingSize)
    SCHEMA_ITEM(ClassLayout, ULONG, ClassSize)
    SCHEMA_ITEM_RID(ClassLayout,Parent,TypeDef)
    SCHEMA_TABLE_END(ClassLayout)

    //-------------------------------------------------------------------------
    //FieldLayout
    SCHEMA_TABLE_START(FieldLayout)
    SCHEMA_ITEM(FieldLayout, ULONG, OffSet)
    SCHEMA_ITEM_RID(FieldLayout, Field, Field)
    SCHEMA_TABLE_END(FieldLayout)

    //-------------------------------------------------------------------------
    //StandAloneSig
    SCHEMA_TABLE_START(StandAloneSig)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_BLOB(StandAloneSig,Signature)
    SCHEMA_TABLE_END(StandAloneSig)

    //-------------------------------------------------------------------------
    //EventMap
    SCHEMA_TABLE_START(EventMap)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(EventMap,Parent,TypeDef)
    SCHEMA_ITEM_RID(EventMap,EventList,Event)
    SCHEMA_TABLE_END(EventMap)

    //-------------------------------------------------------------------------
    //EventPtr
    SCHEMA_TABLE_START(EventPtr)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(EventPtr, Event, Event)
    SCHEMA_TABLE_END(EventPtr)

    //-------------------------------------------------------------------------
    //Event
    SCHEMA_TABLE_START(Event)
    SCHEMA_ITEM(Event, USHORT, EventFlags)
    SCHEMA_ITEM_STRING(Event,Name)
    SCHEMA_ITEM_CDTKN(Event,EventType,TypeDefOrRef)
    SCHEMA_TABLE_END(Event)

    //-------------------------------------------------------------------------
    //PropertyMap
    SCHEMA_TABLE_START(PropertyMap)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(PropertyMap,Parent,TypeDef)
    SCHEMA_ITEM_RID(PropertyMap,PropertyList,Property)
    SCHEMA_TABLE_END(PropertyMap)

    //-------------------------------------------------------------------------
    //PropertyPtr
    SCHEMA_TABLE_START(PropertyPtr)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_RID(PropertyPtr, Property, Property)
    SCHEMA_TABLE_END(PropertyPtr)

    //-------------------------------------------------------------------------
    //Property
    SCHEMA_TABLE_START(Property)
    SCHEMA_ITEM(Property, USHORT, PropFlags)
    SCHEMA_ITEM_STRING(Property,Name)
    SCHEMA_ITEM_BLOB(Property,Type)
    SCHEMA_TABLE_END(Property)

    //-------------------------------------------------------------------------
    //MethodSemantics
    SCHEMA_TABLE_START(MethodSemantics)
    SCHEMA_ITEM(MethodSemantics, USHORT, Semantic)
    SCHEMA_ITEM_RID(MethodSemantics,Method,Method)
    SCHEMA_ITEM_CDTKN(MethodSemantics,Association,HasSemantic)
    SCHEMA_TABLE_END(MethodSemantics)

    //-------------------------------------------------------------------------
    //MethodImpl
    SCHEMA_TABLE_START(MethodImpl)
    SCHEMA_ITEM_RID(MethodImpl,Class,TypeDef)
    SCHEMA_ITEM_CDTKN(MethodImpl,MethodBody,MethodDefOrRef)
    SCHEMA_ITEM_CDTKN(MethodImpl, MethodDeclaration, MethodDefOrRef)
    SCHEMA_TABLE_END(MethodImpl)

    //-------------------------------------------------------------------------
    //ModuleRef
    SCHEMA_TABLE_START(ModuleRef)
    SCHEMA_ITEM_NOFIXED() 
    SCHEMA_ITEM_STRING(ModuleRef, Name)
    SCHEMA_TABLE_END(ModuleRef)
    
    //-------------------------------------------------------------------------
    // TypeSpec
    SCHEMA_TABLE_START(TypeSpec)
    SCHEMA_ITEM_NOFIXED()
    SCHEMA_ITEM_BLOB(TypeSpec,Signature)
    SCHEMA_TABLE_END(TypeSpec)

    //-------------------------------------------------------------------------
    // ENCLog
    SCHEMA_TABLE_START(ENCLog)
    SCHEMA_ITEM(ENCLog, ULONG, Token)
    SCHEMA_ITEM(ENCLog, ULONG, FuncCode)
    SCHEMA_TABLE_END(ENCLog)

    //-------------------------------------------------------------------------
    // ImplMap
    SCHEMA_TABLE_START(ImplMap)
    SCHEMA_ITEM(ImplMap, USHORT, MappingFlags)
    SCHEMA_ITEM_CDTKN(ImplMap, MemberForwarded, MemberForwarded)
    SCHEMA_ITEM_STRING(ImplMap, ImportName)
    SCHEMA_ITEM_RID(ImplMap, ImportScope, ModuleRef)
    SCHEMA_TABLE_END(ImplMap)

    //-------------------------------------------------------------------------
    // ENCMap
    SCHEMA_TABLE_START(ENCMap)
    SCHEMA_ITEM(ENCMap, ULONG, Token)
    SCHEMA_TABLE_END(ENCMap)

    //-------------------------------------------------------------------------
    // FieldRVA
    SCHEMA_TABLE_START(FieldRVA)
    SCHEMA_ITEM(FieldRVA, ULONG, RVA)
    SCHEMA_ITEM_RID(FieldRVA, Field, Field)
    SCHEMA_TABLE_END(FieldRVA)

    //-------------------------------------------------------------------------
    // Assembly
    SCHEMA_TABLE_START(Assembly)
    SCHEMA_ITEM(Assembly, ULONG, HashAlgId)
    SCHEMA_ITEM(Assembly, USHORT, MajorVersion)
    SCHEMA_ITEM(Assembly, USHORT, MinorVersion)
    SCHEMA_ITEM(Assembly, USHORT, BuildNumber)
    SCHEMA_ITEM(Assembly, USHORT, RevisionNumber)
    SCHEMA_ITEM(Assembly, ULONG, Flags)
    SCHEMA_ITEM_BLOB(Assembly, PublicKey)
    SCHEMA_ITEM_STRING(Assembly, Name)
    SCHEMA_ITEM_STRING(Assembly, Locale)
    SCHEMA_TABLE_END(Assembly)

    //-------------------------------------------------------------------------
    // AssemblyProcessor
	SCHEMA_TABLE_START(AssemblyProcessor)
	SCHEMA_ITEM(AssemblyProcessor, ULONG, Processor)
	SCHEMA_TABLE_END(AssemblyProcessor)

    //-------------------------------------------------------------------------
    // AssemblyOS
    SCHEMA_TABLE_START(AssemblyOS)
    SCHEMA_ITEM(AssemblyOS, ULONG, OSPlatformId)
    SCHEMA_ITEM(AssemblyOS, ULONG, OSMajorVersion)
    SCHEMA_ITEM(AssemblyOS, ULONG, OSMinorVersion)
    SCHEMA_TABLE_END(AssemblyOS)

    //-------------------------------------------------------------------------
    // AssemblyRef
    SCHEMA_TABLE_START(AssemblyRef)
    SCHEMA_ITEM(AssemblyRef, USHORT, MajorVersion)
    SCHEMA_ITEM(AssemblyRef, USHORT, MinorVersion)
    SCHEMA_ITEM(AssemblyRef, USHORT, BuildNumber)
    SCHEMA_ITEM(AssemblyRef, USHORT, RevisionNumber)
    SCHEMA_ITEM(AssemblyRef, ULONG, Flags)
    SCHEMA_ITEM_BLOB(AssemblyRef, PublicKeyOrToken)
    SCHEMA_ITEM_STRING(AssemblyRef, Name)
    SCHEMA_ITEM_STRING(AssemblyRef, Locale)
	SCHEMA_ITEM_BLOB(AssemblyRef, HashValue)
    SCHEMA_TABLE_END(AssemblyRef)

    //-------------------------------------------------------------------------
    // AssemblyRefProcessor
    SCHEMA_TABLE_START(AssemblyRefProcessor)
    SCHEMA_ITEM(AssemblyRefProcessor, ULONG, Processor)
    SCHEMA_ITEM_RID(AssemblyRefProcessor, AssemblyRef, AssemblyRef)
    SCHEMA_TABLE_END(AssemblyRefProcessor)

    //-------------------------------------------------------------------------
    // AssemblyRefOS
    SCHEMA_TABLE_START(AssemblyRefOS)
    SCHEMA_ITEM(AssemblyRefOS, ULONG, OSPlatformId)
    SCHEMA_ITEM(AssemblyRefOS, ULONG, OSMajorVersion)
    SCHEMA_ITEM(AssemblyRefOS, ULONG, OSMinorVersion)
    SCHEMA_ITEM_RID(AssemblyRefOS, AssemblyRef, AssemblyRef)
    SCHEMA_TABLE_END(AssemblyRefOS)

    //-------------------------------------------------------------------------
    // File
    SCHEMA_TABLE_START(File)
    SCHEMA_ITEM(File, ULONG, Flags)
    SCHEMA_ITEM_STRING(File, Name)
    SCHEMA_ITEM_BLOB(File, HashValue)
    SCHEMA_TABLE_END(File)

    //-------------------------------------------------------------------------
    // ExportedType
    SCHEMA_TABLE_START(ExportedType)
    SCHEMA_ITEM(ExportedType, ULONG, Flags)
    SCHEMA_ITEM(ExportedType, ULONG, TypeDefId)
    SCHEMA_ITEM_STRING(ExportedType, TypeName)
    SCHEMA_ITEM_STRING(ExportedType, TypeNamespace)
    SCHEMA_ITEM_CDTKN(ExportedType, Implementation, Implementation)
    SCHEMA_TABLE_END(ExportedType)

    //-------------------------------------------------------------------------
    // ManifestResource
    SCHEMA_TABLE_START(ManifestResource)
    SCHEMA_ITEM(ManifestResource, ULONG, Offset)
    SCHEMA_ITEM(ManifestResource, ULONG, Flags)
    SCHEMA_ITEM_STRING(ManifestResource, Name)
    SCHEMA_ITEM_CDTKN(ManifestResource, Implementation, Implementation)
    SCHEMA_TABLE_END(ManifestResource)

    //-------------------------------------------------------------------------
    // NestedClass
    SCHEMA_TABLE_START(NestedClass)
    SCHEMA_ITEM_RID(NestedClass, NestedClass, TypeDef)
    SCHEMA_ITEM_RID(NestedClass, EnclosingClass, TypeDef)
    SCHEMA_TABLE_END(NestedClass)
    

// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\memory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: MEMORY.H
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================

#pragma once

#ifndef _WINDEF_
#ifndef _WINNT_
typedef long                LONG;
typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef BYTE               *PBYTE;
typedef DWORD               DWORD_PTR, *PDWORD_PTR;
typedef void               *HANDLE;
typedef LONG                HRESULT;
typedef unsigned long       SIZE_T;
#define NULL 0
#define TRUE 1
#define FALSE 0
#endif
#endif

#include "binarytree.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Forward declarations

class ProcessMemory;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

class ProcessMemoryReader
{
protected:
    DWORD               m_dwPid;
    HANDLE              m_hProcess;

public:
    // Ctor
    ProcessMemoryReader(DWORD dwPid) : m_dwPid(dwPid), m_hProcess(NULL) {}

    // Dtor
    ~ProcessMemoryReader();

    // Returns true if this object has been initialized
    inline BOOL         IsInit() { return m_hProcess != NULL; }

    // Initializes the object.
    HRESULT             Init();

    // Reads the specified block of memory from the process, and copies it into
    // the buffer provided.  Upon success returns S_OK.
    HRESULT             ReadMemory(DWORD_PTR pdwRemoteAddr, PBYTE pbBuffer, SIZE_T cbLength);

    // Returns the handle to the process
    HANDLE              GetProcHandle() { return m_hProcess; }

    // Returns true if the block of memory is read-only
    //BOOL                IsExecute(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength);
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

class ProcessMemoryBlock
{
protected:
    ProcessMemoryReader *m_pMemReader;      // This object will do the memory reading
    DWORD_PTR            m_pdwRemoteAddr;   // The location of the memory in the remote process
    SIZE_T               m_cbSize;
    PBYTE                m_pbData;          // The contents of the memory in this process

public:
    // Ctor
    ProcessMemoryBlock(DWORD_PTR pdwRemoteAddr, SIZE_T cbSize, ProcessMemoryReader *pMemReader) :
        m_pdwRemoteAddr(pdwRemoteAddr),  m_cbSize(cbSize), m_pbData(NULL), m_pMemReader(pMemReader)
    { }

    // Dtor
    ~ProcessMemoryBlock();

    // Returns the remote address of the memory block
    DWORD_PTR           GetRemoteAddress() { return m_pdwRemoteAddr; }

    // Gets a pointer to the data contained by this object.  Returns NULL on failure.
    PBYTE               GetData();

    // Returns the size in bytes of the data contained in this block
    SIZE_T              GetSize() { return m_cbSize; }

    // Returns the offset into the Data that the pdwRemoteAddress corresponds to
    SIZE_T              GetOffsetOf(DWORD_PTR pdwRemoteAddress)
        { /*_ASSERTE(Contains(pdwRemoteAddress));*/ return (pdwRemoteAddress - GetRemoteAddress()); }

    // Returns true if this block contains the remote address specified
    BOOL                Contains(DWORD_PTR pdwRemoteAddr)
        { return (GetRemoteAddress() <= pdwRemoteAddr && pdwRemoteAddr < (GetRemoteAddress() + m_cbSize)); }

};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

class ProcessPage : public ProcessMemoryBlock
{
protected:
    static SIZE_T s_cbPageSize;
    static DWORD  s_dwPageBoundaryMask;

    static BOOL IsInit()
        { return s_cbPageSize != 0; }

public:
    // Ctor
    ProcessPage(DWORD_PTR pdwRemoteAddr, ProcessMemoryReader *pMemReader) :
        ProcessMemoryBlock(pdwRemoteAddr, s_cbPageSize, pMemReader)
    { }

    DWORD_PTR Key() { return GetRemoteAddress(); }

    // Returns the Win32 memory information for this page of memory
    BOOL GetMemoryInfo(/*MEMORY_BASIC_INFORMATION*/void *pMemInfo);

    // Static initializer for ProcessPage - must call before using
    static void Init();

    // Returns the system page size - must call ProcessPage::Init first
    static SIZE_T GetPageSize()
        { return s_cbPageSize; }

    // Returns the page boundary for an address
    static DWORD_PTR GetPageBoundary(DWORD_PTR pdwRemoteAddr)
        { return ((DWORD_PTR)((DWORD)pdwRemoteAddr & s_dwPageBoundaryMask)); }

};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

class ProcessPageAndBitMap : public ProcessPage
{
protected:
    const static DWORD c_cBitsPerByte = 8;                                  // How many bits per byte

    static SIZE_T s_cBytesInBitField;
    static BOOL IsInit()
        { return s_cBytesInBitField != 0; }
   
    // This bit field is used to keep track of what bits of memory have actually been read (rather than cached)
    BYTE *m_rgMemBitField;

    SIZE_T FindFirstSetBit(SIZE_T iStartBit);
    SIZE_T FindFirstUnsetBit(SIZE_T iStartBit);
    BOOL GetBitAt(SIZE_T iBit);
    void SetBitAt(SIZE_T iBit, BOOL fBit);

    // Private common memory mark/unmark function
    void MarkMemoryHelper(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength, BOOL fBit);

public:
    // Ctor
    ProcessPageAndBitMap(DWORD_PTR pdwRemoteAddr, ProcessMemoryReader *pMemReader);

    // Marks memory range
    void MarkMemory(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength);

    // Unmarks memory range
    void UnmarkMemory(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength);

    // Gets the first block of memory and size that was read from this page with an address
    // >= *ppdwRemoteAddr and contained by the page and return it in ppdwRemoteAddr and pcbLength
    // Returns false if there is no memory at or beyond *ppdwRemoteAddr in this page that was read.
    BOOL GetContiguousReadBlock(/*IN/OUT*/ DWORD_PTR *ppdwRemoteAddr, /*OUT*/SIZE_T *pcbLength);

    // Coalesces blocks of read memory that have less than cbMinUnreadBytes between them
    void Coalesce(SIZE_T cbMinUnreadBytes);

    // Static initializer for ProcessPage - must call before using
    static void Init()
        { ProcessPage::Init(); s_cBytesInBitField = GetPageSize() / c_cBitsPerByte; }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

class ProcessMemory
{
private:
    //---------------------------------------------------------------------------------------------------------------
    // Static helpers

protected:
    DWORD                 m_dwPid;          // ID of the process
    ProcessMemoryReader  *m_pMemReader;     // For reading the process' memory

    // This binary tree contains all pages that have been read
    BinaryTree<DWORD_PTR, ProcessPageAndBitMap> m_tree;

    // Find block that contains pdwRemoteAddr
    ProcessPageAndBitMap *FindPage(DWORD_PTR pdwRemoteAddr);

    // Adds the block to the hash.  Fails if block already there.
    BOOL                AddPage(ProcessPageAndBitMap *pMemBlock);

    // Adds the block to the hash.  Fails if block already there.
    BOOL                AddPage(DWORD_PTR pdwRemoteAddr);

    // This will search for a ProcessPageAndBitMap containing the address of pdwRemoteAddr, and if it can't find
    // one, it will create and add one.  If anything goes wrong, it returns null
    ProcessPageAndBitMap *GetPage(DWORD_PTR pdwRemoteAddr);

    // Internal function that takes the remote address, rounds to previous page
    // boundary, figures out how many pages need copying, then creates ProcessPageAndBitMap
    // objects for each page.
    HRESULT             AddMemory(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength);

    SIZE_T              GetPageSize() { return ProcessPage::GetPageSize(); }

    // Will [un]cache the range specified in blocks
    BOOL                MarkMemHelper(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength, BOOL fMark);

    ProcessPageAndBitMap *m_pPageCursor;
    DWORD_PTR             m_pdwMemCursor;

    BOOL                  m_fAutoMark;

public:
    // Ctor
    ProcessMemory(DWORD dwPid) :
        m_dwPid(dwPid), m_pMemReader(NULL), m_pPageCursor(NULL), m_pdwMemCursor(0),
        m_fAutoMark(FALSE) {}

    // Dtor
    ~ProcessMemory();

    // Returns true if this object has been initialized
    BOOL        IsInit() { return m_pMemReader != NULL; }

    // Initializes the object to read memory from a specific process.
    HRESULT     Init();

    // Will cache the range specified in blocks
    BOOL        MarkMem(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength);

    // Will uncache the range specified in blocks
    BOOL        UnmarkMem(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength);

    // Copies cbLength bytes from the contents of pdwRemoteAddress in the external process
    // into pdwBuffer.  If returns FALSE, the memory could not be accessed or copied.
    BOOL        CopyMem(DWORD_PTR pdwRemoteAddress, PBYTE pbBuffer, SIZE_T cbLength);

    // Writes the memory range to file hFile
    HRESULT     WriteMemToFile(HANDLE hFile, DWORD_PTR pdwRemoteAddress, SIZE_T cbLength);

    // Returns the handle to the process
    HANDLE      GetProcHandle() { return m_pMemReader->GetProcHandle(); }

    // Returns the first contiguous block of read memory
    void        ResetContiguousReadBlock();

    // Returns the next contiguous block of read memory
    BOOL        NextContiguousReadBlock(DWORD_PTR *ppdwRemoteAddress, SIZE_T *pcbLength);
    
    // Clears the bits for all pages that are ExecuteRead flagged.
    void        ClearIncompatibleImageSections();

    // Coalesces blocks of read memory that have less than cbMinUnreadBytes between them
    void        Coalesce(SIZE_T cbMinUnreadBytes);

    // This will set whether or not memory is automatically marked when it is read
    void        SetAutoMark(BOOL fIsOn) { m_fAutoMark = fIsOn; }

    // This will set whether or not memory is automatically marked when it is read
    BOOL        GetAutoMark() { return (m_fAutoMark); }
};

#define move(dst, src)                                                          \
{                                                                               \
    DWORD_PTR srcPtr = (DWORD_PTR)src;                                          \
    BOOL fRes = g_pProcMem->CopyMem(srcPtr, (PBYTE)&dst, sizeof(dst));          \
    if (!fRes) return;                                                          \
}

#define move_res(dst, src, res)                                                 \
{                                                                               \
    DWORD_PTR srcPtr = (DWORD_PTR)src;                                          \
    res = g_pProcMem->CopyMem((DWORD_PTR)srcPtr, (PBYTE)&dst, sizeof(dst));     \
}

#define move_n(dst, src, size)                                                  \
{                                                                               \
    DWORD_PTR srcPtr = (DWORD_PTR)src;                                          \
    BOOL fRes = g_pProcMem->CopyMem((DWORD_PTR)srcPtr, (PBYTE)&dst, size);      \
    if (!fRes) return;                                                          \
}

#define move_n_res(dst, src, size, res)                                         \
{                                                                               \
    DWORD_PTR srcPtr = (DWORD_PTR)src;                                          \
    res = g_pProcMem->CopyMem((DWORD_PTR)srcPtr, (PBYTE)&dst, size);            \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\memory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: MEMORY.CPP
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================

#include "common.h"
#include "stdio.h"
#include "memory.h"
#include "peb.h"
#include "minidump.h"

#include <windows.h>
#include <crtdbg.h>

SIZE_T ProcessPage::s_cbPageSize = 0;
DWORD  ProcessPage::s_dwPageBoundaryMask = 0;

SIZE_T ProcessPageAndBitMap::s_cBytesInBitField = 0;

static BYTE bBit0 = 0x80;
static BYTE bBit1 = 0x40;
static BYTE bBit2 = 0x20;
static BYTE bBit3 = 0x10;
static BYTE bBit4 = 0x08;
static BYTE bBit5 = 0x04;
static BYTE bBit6 = 0x02;
static BYTE bBit7 = 0x01;
static BYTE bBitAll = 0xFF;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Dtor

ProcessMemoryReader::~ProcessMemoryReader()
{
    if (m_hProcess != NULL)
    {
        CloseHandle(m_hProcess);
        m_hProcess = NULL;
    }

    m_dwPid = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initializes the object.

HRESULT ProcessMemoryReader::Init()
{
    _ASSERTE(m_dwPid != 0);
    m_hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, m_dwPid);

    if (m_hProcess == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reads the specified block of memory from the process, and copies it into
// the buffer provided.  Upon success returns S_OK.

HRESULT ProcessMemoryReader::ReadMemory(DWORD_PTR pdwRemoteAddr, PBYTE pbBuffer, SIZE_T cbLength)
{
    // If it's not already initialized, do so
    if (!IsInit())
    {
        HRESULT hr = Init();

        if (FAILED(hr))
            return hr;
    }
    _ASSERTE(IsInit());

    // Try and read the process memory
    DWORD dwBytesRead;
    BOOL fRes = ReadProcessMemory(m_hProcess, (LPCVOID) pdwRemoteAddr, (LPVOID) pbBuffer, cbLength, &dwBytesRead);

    // If it fails return the error
    if (!fRes)
        return HRESULT_FROM_WIN32(GetLastError());

    // Indicate success
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Dtor

ProcessMemoryBlock::~ProcessMemoryBlock()
{
    if (m_pbData)
    {
        delete m_pbData;
        m_pbData = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets a pointer to the data contained by this object.  Returns NULL on failure.

PBYTE ProcessMemoryBlock::GetData()
{
    if (m_pbData == NULL)
    {
        // Allocate the buffer to hold the data
        m_pbData = new BYTE[m_cbSize];
        _ASSERTE(m_pbData);

        // Out of memory
        if (m_pbData == NULL)
            return NULL;

        // Fill the buffer with the data contents
        HRESULT hr = m_pMemReader->ReadMemory(m_pdwRemoteAddr, m_pbData, m_cbSize);

        if (FAILED(hr))
        {
            delete [] m_pbData;
            m_pbData = NULL;
        }
    }

    return m_pbData;
}

///////////////////////////////////////////////////////////////////////////////////////////
// Returns the Win32 memory information for this page of memory

BOOL ProcessPage::GetMemoryInfo(/*MEMORY_BASIC_INFORMATION*/void *pMemInfo)
{
    DWORD cbWritten = VirtualQueryEx(
        m_pMemReader->GetProcHandle(), (LPCVOID) GetRemoteAddress(),
        (MEMORY_BASIC_INFORMATION *) pMemInfo, sizeof(MEMORY_BASIC_INFORMATION));

    return (cbWritten == sizeof(MEMORY_BASIC_INFORMATION));
}

///////////////////////////////////////////////////////////////////////////////////////////
// Initializor 

/* static */
void ProcessPage::Init()
{
    if (IsInit())
        return;

    // Get the page size for the machine
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    s_cbPageSize = (SIZE_T) sysInfo.dwPageSize;

    _ASSERTE((s_cbPageSize & (s_cbPageSize - 1)) == 0);
    s_dwPageBoundaryMask = ~(s_cbPageSize - 1);
}

///////////////////////////////////////////////////////////////////////////////////////////
//

ProcessPageAndBitMap::ProcessPageAndBitMap(DWORD_PTR pdwRemoteAddr, ProcessMemoryReader *pMemReader) :
    ProcessPage(pdwRemoteAddr, pMemReader)
{
    pdwRemoteAddr = GetPageBoundary(pdwRemoteAddr);
    m_rgMemBitField = new BYTE[s_cBytesInBitField];
    memset((void *) m_rgMemBitField, 0, s_cBytesInBitField);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Marks the memory range
void ProcessPageAndBitMap::MarkMemoryHelper(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength, BOOL fBit)
{
    _ASSERTE(Contains(pdwRemoteAddr) && Contains(pdwRemoteAddr + cbLength - 1));
    if (!(Contains(pdwRemoteAddr) && Contains(pdwRemoteAddr + cbLength - 1)))
        return;

    SIZE_T cbOffset = GetOffsetOf(pdwRemoteAddr);

    SIZE_T iStartByte = cbOffset / 8;
    SIZE_T iEndByte = (cbOffset + cbLength) / 8;

    BYTE   bStartBit = bBit0 >> (cbOffset % 8);
    BYTE   bEndBit   = bBit0 >> (cbOffset + cbLength) % 8;

    if (iStartByte == iEndByte)
    {
        BYTE bCurBit = bStartBit;
        while (bCurBit != bEndBit)
        {
            if (fBit)
                m_rgMemBitField[iStartByte] |= bCurBit;
            else
                m_rgMemBitField[iStartByte] &= ~bCurBit;

            bCurBit = bCurBit >> 1;
        }
    }

    else
    {
        // First set all the bits for the first byte, which may not be all the bits
        {
            BYTE bCurBit = bStartBit;
            while (bCurBit != 0)
            {
                if (fBit)
                    m_rgMemBitField[iStartByte] |= bCurBit;
                else
                    m_rgMemBitField[iStartByte] &= ~bCurBit;

                bCurBit = bCurBit >> 1;
            }
        }

        BYTE *pCurByte = m_rgMemBitField + iStartByte + 1;
        BYTE *pStopByte = m_rgMemBitField + iEndByte;
        while (pCurByte != pStopByte)
        {
            if (fBit)
                *pCurByte++ = ~0;
            else
                *pCurByte++ = 0;
        }

        // Last set all the bits for the last byte, which may not be all the bits
        {
            BYTE bCurBit  = bBit0;
            while (bCurBit != bEndBit)
            {
                if (fBit)
                    m_rgMemBitField[iEndByte] |= bCurBit;
                else
                    m_rgMemBitField[iEndByte] &= ~bCurBit;

                bCurBit = bCurBit >> 1;
            }
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Marks the memory range
void ProcessPageAndBitMap::MarkMemory(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength)
{
    MarkMemoryHelper(pdwRemoteAddr, cbLength, TRUE);
}

// Unmarks memory range
void ProcessPageAndBitMap::UnmarkMemory(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength)
{
    MarkMemoryHelper(pdwRemoteAddr, cbLength, FALSE);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

SIZE_T ProcessPageAndBitMap::FindFirstSetBit(SIZE_T iStartBit)
{
    SIZE_T iStartByte = iStartBit / 8;

    SIZE_T iCurByte = iStartByte;
    SIZE_T iCurBit;
    BYTE   bCurBit;

    iCurBit = iStartBit % 8;
    bCurBit = bBit0 >> iCurBit;

    while (bCurBit != 0 && !(bCurBit & m_rgMemBitField[iCurByte]))
    {
        bCurBit = bCurBit >> 1;
        iCurBit++;
    }

    if (bCurBit == 0)
    {
        while (++iCurByte < s_cBytesInBitField && m_rgMemBitField[iCurByte] == 0)
        { }

        if (iCurByte != s_cBytesInBitField)
        {
            iCurBit = 0;
            bCurBit = bBit0;

            while (!(bCurBit & m_rgMemBitField[iCurByte]))
            {
                bCurBit = bCurBit >> 1;
                iCurBit++;
                _ASSERTE(iCurBit != 8);
            }
        }
    }

    if (iCurByte == s_cBytesInBitField)
        return -1;

    return (iCurByte * 8 + iCurBit);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

SIZE_T ProcessPageAndBitMap::FindFirstUnsetBit(SIZE_T iStartBit)
{
    SIZE_T iStartByte = iStartBit / 8;

    SIZE_T iCurByte = iStartByte;
    SIZE_T iCurBit;
    BYTE   bCurBit;

    iCurBit = iStartBit % 8;
    bCurBit = bBit0 >> iCurBit;

    while (bCurBit != 0 && bCurBit & m_rgMemBitField[iCurByte])
    {
        bCurBit = bCurBit >> 1;
        iCurBit++;
    }

    if (bCurBit == 0)
    {
        while (++iCurByte < s_cBytesInBitField && m_rgMemBitField[++iCurByte] == bBitAll)
        { }

        if (iCurByte != s_cBytesInBitField)
        {
            iCurBit = 0;
            bCurBit = bBit0;
    
            while (bCurBit & m_rgMemBitField[iCurByte])
            {
                bCurBit = bCurBit >> 1;
                iCurBit++;
                _ASSERTE(iCurBit != 8);
            }
        }
    }

    if (iCurByte == s_cBytesInBitField)
        return -1;

    return (iCurByte * 8 + iCurBit);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

BOOL ProcessPageAndBitMap::GetBitAt(SIZE_T iBit)
{
    SIZE_T iCurByte = iBit / 8;
    SIZE_T iCurBit = iBit % 8;
    BYTE   bCurBit = bBit0 >> iCurBit;

    return ((m_rgMemBitField[iCurByte] & bCurBit) != 0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

void ProcessPageAndBitMap::SetBitAt(SIZE_T iBit, BOOL fBit)
{
    SIZE_T iCurByte = iBit / 8;
    SIZE_T iCurBit = iBit % 8;
    BYTE   bCurBit = bBit0 >> iCurBit;

    if (fBit)
        m_rgMemBitField[iCurByte] = (m_rgMemBitField[iCurByte] | bCurBit);
    else
        m_rgMemBitField[iCurByte] = (m_rgMemBitField[iCurByte] & ~bCurBit);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Gets the first block of memory and size that was read from this page with an address
// >= *ppdwRemoteADdr and return it in ppdwRemoteAddr and pcbLength
// Returns false if there is no memory at or beyond *ppdwRemoteAddr in this page that was read.

BOOL ProcessPageAndBitMap::GetContiguousReadBlock(/*IN/OUT*/ DWORD_PTR *ppdwRemoteAddr, /*OUT*/SIZE_T *pcbLength)
{
    _ASSERTE(ppdwRemoteAddr != NULL);

    if (!Contains(*ppdwRemoteAddr))
        return (FALSE);

    SIZE_T cbOffset = GetOffsetOf(*ppdwRemoteAddr);

    cbOffset = FindFirstSetBit(cbOffset);
    if (cbOffset == -1)
        return (FALSE);

    SIZE_T cbOffsetEnd = FindFirstUnsetBit(cbOffset);
    if (cbOffsetEnd == -1)
        cbOffsetEnd = GetPageSize();

    _ASSERTE(cbOffsetEnd - cbOffset <= GetPageSize());

    *ppdwRemoteAddr = cbOffset + GetRemoteAddress();
    *pcbLength = cbOffsetEnd - cbOffset;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////
// Coalesces blocks of read memory that have less than cbMinUnreadBytes between them
void ProcessPageAndBitMap::Coalesce(SIZE_T cbMinUnreadBytes)
{

    SIZE_T iUnsetBit = 0;
    SIZE_T iSetBit = 0;
    while ((iUnsetBit = FindFirstUnsetBit(iSetBit)) != -1 && (iSetBit = FindFirstSetBit(iUnsetBit)) != -1)
    {
        if (iSetBit - iUnsetBit < cbMinUnreadBytes)
        {
            while (iUnsetBit < iSetBit)
            {
                SetBitAt(iUnsetBit, TRUE);
                iUnsetBit++;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////
// Dtor

ProcessMemory::~ProcessMemory()
{
    if (m_pMemReader != NULL)
    {
        delete m_pMemReader;
        m_pMemReader = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initializes the object to read memory from a specific process.

HRESULT ProcessMemory::Init()
{
    _ASSERTE(!IsInit());        // Make sure we're not re-initializing the object

    HRESULT hr = S_OK;

    // Check for basic errors
    if (m_dwPid == 0)
        return E_INVALIDARG;

    // Create the memory reader
    m_pMemReader = new ProcessMemoryReader(m_dwPid);

    if (!m_pMemReader)
    {
        hr = E_OUTOFMEMORY; goto LExit;
    }

    // Try and initialize the memory reader
    hr = m_pMemReader->Init();

    if (FAILED(hr)) goto LExit;

    LExit:
    if (FAILED(hr))
    {
        if (m_pMemReader)
        {
            delete m_pMemReader;
            m_pMemReader = NULL;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Searches for a ProcessMemoryBlock containing the address of pdwRemoteAddr

ProcessPageAndBitMap *ProcessMemory::FindPage(DWORD_PTR pdwRemoteAddr)
{
    pdwRemoteAddr = ProcessPage::GetPageBoundary(pdwRemoteAddr);
    return m_tree.Find(pdwRemoteAddr);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tries to add the block to the hash.  If there's already one there, returns false

BOOL ProcessMemory::AddPage(ProcessPageAndBitMap *pMemBlock)
{
    return m_tree.Insert(pMemBlock->GetRemoteAddress(), pMemBlock);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tries to add the block to the hash.  If there's already one there, returns false

BOOL ProcessMemory::AddPage(DWORD_PTR pdwRemoteAddr)
{
    if (FindPage(pdwRemoteAddr))
        return FALSE;

    pdwRemoteAddr = ProcessPage::GetPageBoundary(pdwRemoteAddr);

    ProcessPageAndBitMap *pMemBlock = new ProcessPageAndBitMap(pdwRemoteAddr, m_pMemReader);
    _ASSERTE(pMemBlock != NULL);

    if (pMemBlock == NULL)
        return FALSE;

    BOOL fRes = AddPage(pMemBlock);
    _ASSERTE(fRes);

    if (!fRes)
    {
        delete pMemBlock;
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This will search for a ProcessMemoryBlock containing the address of pdwRemoteAddr, and if it can't find
// one, it will create and add one.  If anything goes wrong, it returns null

ProcessPageAndBitMap *ProcessMemory::GetPage(DWORD_PTR pdwRemoteAddr)
{
    ProcessPageAndBitMap *pMemBlock = FindPage(pdwRemoteAddr);

    if (pMemBlock == NULL && AddPage(pdwRemoteAddr))
    {
        return FindPage(pdwRemoteAddr);
    }
    _ASSERTE(pMemBlock != NULL);

    return pMemBlock;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Internal function that takes the remote address, rounds to previous page
// boundary, figures out how many pages need copying, then creates ProcessMemoryBlock
// objects for each page.

HRESULT ProcessMemory::AddMemory(DWORD_PTR pdwRemoteAddr, SIZE_T cbLength)
{
    _ASSERTE(pdwRemoteAddr != NULL && cbLength != 0);
    _ASSERTE(IsInit());

    // Get the address of the preceeding page boundary
    DWORD_PTR pdwFirstPage = ProcessPage::GetPageBoundary(pdwRemoteAddr);
    DWORD_PTR pdwCurPage = pdwFirstPage;

    // This points to the first page *beyond* the last page to be added
    DWORD_PTR pdwLastPage = ProcessPage::GetPageBoundary(pdwRemoteAddr + cbLength - 1) + GetPageSize();

    // Now get all of the pages and add them to the hash
    while (pdwCurPage != pdwLastPage)
    {
        // Add this page.  If it's already in the hash, this doesn't hurt anything - it just returns success
        ProcessPageAndBitMap *pBlock = new ProcessPageAndBitMap(pdwCurPage, m_pMemReader);
        if (pBlock != NULL)
            return E_OUTOFMEMORY;

        HRESULT hr = AddPage(pBlock);
        _ASSERTE(SUCCEEDED(hr));

        if (FAILED(hr))
            return hr;

        pdwCurPage += GetPageSize();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Will [un]cache the range specified in blocks

BOOL ProcessMemory::MarkMemHelper(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength, BOOL fMark)
{
    // Get the address of the preceeding page boundary
    DWORD_PTR pdwFirstBlock = ProcessPage::GetPageBoundary(pdwRemoteAddress);

    // This points to the start of the page *after* that last page that contains data to be copied
    DWORD_PTR pdwLastBlock = ProcessPage::GetPageBoundary(pdwRemoteAddress + (cbLength - 1) + GetPageSize());

    // This is the current page being copied
    DWORD_PTR pdwCurBlock = pdwFirstBlock;

    // Now get all of the pages and add them to the hash
    while (pdwCurBlock != pdwLastBlock)
    {
        // Get the block for the first page
        ProcessPageAndBitMap *pCurBlock = GetPage(pdwCurBlock);
        _ASSERTE(pCurBlock != NULL && pCurBlock->GetSize() == GetPageSize());

        if (!pCurBlock)
            return FALSE;

        // Figure out where in the current page to start copying from
        SIZE_T cbUnusedPre = max(pdwCurBlock, pdwRemoteAddress) - pdwCurBlock;
        DWORD_PTR  pdwStart = pdwCurBlock + cbUnusedPre;

        // Figure out where to end copying
        SIZE_T cbUnusedPost =
            (pdwCurBlock + GetPageSize()) - min(pdwRemoteAddress + cbLength, pdwCurBlock + GetPageSize());
        DWORD_PTR  pdwEnd = pdwCurBlock + GetPageSize() - cbUnusedPost;

        // Total unused bytes in this page
        SIZE_T cbUnusedTotal = cbUnusedPre + cbUnusedPost;
        SIZE_T cbCopyLength = pCurBlock->GetSize() - cbUnusedTotal;

        PBYTE pbData = pCurBlock->GetData();

        if (pbData != NULL)
        {
            // Mark the memory as being read
            if (fMark)
                pCurBlock->MarkMemory(pdwCurBlock + cbUnusedPre, cbCopyLength);

            // Mark the memory as being unread
            else
                pCurBlock->UnmarkMemory(pdwCurBlock + cbUnusedPre, cbCopyLength);
        }

        pdwCurBlock += GetPageSize();
        _ASSERTE(pdwCurBlock <= pdwLastBlock);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Will cache the range specified in blocks

BOOL ProcessMemory::MarkMem(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength)
{
    return MarkMemHelper(pdwRemoteAddress, cbLength, TRUE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Will [un]cache the range specified in blocks

BOOL ProcessMemory::UnmarkMem(DWORD_PTR pdwRemoteAddress, SIZE_T cbLength)
{
    return MarkMemHelper(pdwRemoteAddress, cbLength, FALSE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copies cbLength bytes from the contents of pdwRemoteAddress in the external process
// into pdwBuffer.  If returns FALSE, the memory could not be accessed or copied.

BOOL ProcessMemory::CopyMem(DWORD_PTR pdwRemoteAddress, PBYTE pbBuffer, SIZE_T cbLength)
{
    // Get the address of the preceeding page boundary
    DWORD_PTR pdwFirstBlock = ProcessPage::GetPageBoundary(pdwRemoteAddress);

    // This points to the start of the page *after* that last page that contains data to be copied
    DWORD_PTR pdwLastBlock = ProcessPage::GetPageBoundary(pdwRemoteAddress + (cbLength - 1) + GetPageSize());

    // This is the current page being copied
    DWORD_PTR pdwCurBlock = pdwFirstBlock;

    // This keeps track of the next place to write in the buffer
    PBYTE pbCurBuf = pbBuffer;

    // Now get all of the pages and add them to the hash
    while (pdwCurBlock != pdwLastBlock)
    {
        // Get the block for the first page
        ProcessPageAndBitMap *pCurBlock = GetPage(pdwCurBlock);
        _ASSERTE(pCurBlock != NULL && pdwCurBlock == pCurBlock->GetRemoteAddress());
        _ASSERTE(pCurBlock->GetSize() == GetPageSize());

        if (!pCurBlock)
            return FALSE;

        // Figure out where in the current page to start copying from
        SIZE_T cbUnusedPre = max(pdwCurBlock, pdwRemoteAddress) - pdwCurBlock;
        DWORD_PTR  pdwStart = pdwCurBlock + cbUnusedPre;

        // Figure out where to end copying
        SIZE_T cbUnusedPost =
            (pdwCurBlock + GetPageSize()) - min(pdwRemoteAddress + cbLength, pdwCurBlock + GetPageSize());
        DWORD_PTR  pdwEnd = pdwCurBlock + GetPageSize() - cbUnusedPost;

        // Total unused bytes in this page
        SIZE_T cbUnusedTotal = cbUnusedPre + cbUnusedPost;
        SIZE_T cbCopyLength = pCurBlock->GetSize() - cbUnusedTotal;

        // Points to the page data
        PBYTE pbData = pCurBlock->GetData();

        if (pbData == NULL)
            return FALSE;

        // Mark the memory as being read
        if (m_fAutoMark)
            pCurBlock->MarkMemory(pdwCurBlock + cbUnusedPre, cbCopyLength);

        // Actually copy now
        ::memcpy((PVOID)pbCurBuf, (LPCVOID) (pbData + cbUnusedPre), cbCopyLength);

        // Increase the buffer pointer and page address
        pbCurBuf += cbCopyLength;
        pdwCurBlock += GetPageSize();
        _ASSERTE(pdwCurBlock <= pdwLastBlock);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Returns the first contiguous block of read memory

void ProcessMemory::ResetContiguousReadBlock()
{
    m_tree.Reset();
    m_pPageCursor = m_tree.Next();

    if (m_pPageCursor != NULL)
        m_pdwMemCursor = m_pPageCursor->GetRemoteAddress();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Returns the next contiguous block of read memory

BOOL ProcessMemory::NextContiguousReadBlock(DWORD_PTR *ppdwRemoteAddress, SIZE_T *pcbLength)
{
    if (m_pPageCursor == NULL)
        return FALSE;

    *ppdwRemoteAddress = m_pdwMemCursor;
    if (m_pPageCursor->GetContiguousReadBlock(ppdwRemoteAddress, pcbLength))
    {
        m_pdwMemCursor = *ppdwRemoteAddress + *pcbLength;
        return TRUE;
    }

    ProcessPageAndBitMap *pPage;
    while ((pPage = m_tree.Next()) != NULL)
    {
        *ppdwRemoteAddress = pPage->GetRemoteAddress();

        if (pPage->GetContiguousReadBlock(ppdwRemoteAddress, pcbLength))
        {
            m_pPageCursor = pPage;
            m_pdwMemCursor = *ppdwRemoteAddress + *pcbLength;
            return TRUE;
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Clears the bits for all pages that are ExecuteRead flagged.

#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
#define IMAGE_DIRECTORY_ENTRY_COMHEADER 14
#endif

// User-mode minidump can be created with data segments
// embedded in the dump.  If that's the case, don't map
// such sections.
#define IS_MINI_DATA_SECTION(SecHeader)                                       \
    (((SecHeader)->Characteristics & IMAGE_SCN_MEM_WRITE) &&                  \
     ((SecHeader)->Characteristics & IMAGE_SCN_MEM_READ) &&                   \
     (((SecHeader)->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ||    \
      ((SecHeader)->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)))


void ProcessMemory::ClearIncompatibleImageSections()
{
    ResetLoadedModuleBaseEnum();

    DWORD_PTR hrModule;
    while ((hrModule = GetNextLoadedModuleBase()) != NULL)
    {
        BOOL fRes;

        // Get the DOS header
        IMAGE_DOS_HEADER hDOS;
        move_res(hDOS, hrModule, fRes);
        if (!fRes) continue;

        if ((hDOS.e_magic != IMAGE_DOS_SIGNATURE) || (hDOS.e_lfanew == 0))
            continue;

        // Get the NT headers
        IMAGE_NT_HEADERS hNT;
        DWORD_PTR prNT = (DWORD_PTR) (hDOS.e_lfanew + hrModule);
        move_res(hNT, prNT, fRes);
        if (!fRes) continue;

        if ((hNT.Signature != IMAGE_NT_SIGNATURE) ||
            (hNT.FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
            (hNT.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC))
        {
            continue;
        }

        DWORD_PTR prSection =
            prNT + FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) + hNT.FileHeader.SizeOfOptionalHeader;

        // Can't save the header into the dump file, so unmark it.
        g_pProcMem->UnmarkMem(hrModule, (prSection + hNT.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) - hrModule);

        // If there is a COM20 header, then we don't want to mess around with this image
        IMAGE_DATA_DIRECTORY *entry = &hNT.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER];

        if (entry->VirtualAddress != 0 || entry->Size != 0)
            continue;

        ULONG i;
        for (i = 0; i < hNT.FileHeader.NumberOfSections; i++)
        {
            IMAGE_SECTION_HEADER hSection;
            move_res(hSection, prSection + (i * sizeof(IMAGE_SECTION_HEADER)), fRes);
            if (!fRes) continue;

            if (!IS_MINI_DATA_SECTION(&hSection))
            {
                DWORD_PTR prSecStart = hrModule + hSection.VirtualAddress;
                DWORD_PTR prSecEnd = prSecStart + hSection.Misc.VirtualSize;

                m_tree.Reset();

                ProcessPageAndBitMap *pPage;
                while ((pPage = m_tree.Next()) != NULL)
                {
                    if (prSecStart < pPage->GetRemoteAddress() && pPage->GetRemoteAddress() < prSecEnd)
                    {
                        SIZE_T length = min(pPage->GetSize(), hSection.Misc.VirtualSize);
                        pPage->UnmarkMemory(pPage->GetRemoteAddress(), length);
                    }
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Coalesces blocks of read memory that have less than cbMinUnreadBytes between them

void ProcessMemory::Coalesce(SIZE_T cbMinUnreadBytes)
{
    m_tree.Reset();

    ProcessPageAndBitMap *pPage;
    while ((pPage = m_tree.Next()) != NULL)
        pPage->Coalesce(cbMinUnreadBytes);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Writes the memory range to file hFile

HRESULT ProcessMemory::WriteMemToFile(HANDLE hFile, DWORD_PTR pdwRemoteAddress, SIZE_T cbLength)
{
    DWORD_PTR pdwStart = pdwRemoteAddress;
    DWORD_PTR pdwEnd = pdwRemoteAddress + cbLength;
    DWORD_PTR pdwCur = pdwStart;

    SIZE_T    cbTotalWritten = 0;

    while (pdwCur < pdwEnd)
    {
        // Get the block for the first page
        ProcessPageAndBitMap *pCurBlock = GetPage(pdwCur);

        if (pCurBlock)
        {
            DWORD_PTR pdwWriteStart = max(pCurBlock->GetRemoteAddress(), pdwCur);
            DWORD_PTR pdwWriteEnd   = min(pCurBlock->GetRemoteAddress() + GetPageSize(), pdwEnd);
            SIZE_T    cbWrite       = pdwWriteEnd - pdwWriteStart;
            SIZE_T    cbWriteOffset = pCurBlock->GetOffsetOf(pdwWriteStart);

            // Get the data for the page
            PBYTE pbData = pCurBlock->GetData();

            // Write the portion of data that needs writing
            DWORD  cbWritten;
            BOOL fRes = WriteFile(hFile, (LPCVOID) (pbData + cbWriteOffset), cbWrite, &cbWritten, NULL);
            _ASSERTE(fRes && cbWrite == cbWritten);

            if (cbWrite != cbWritten)
                return FALSE;

            pdwCur += cbWritten;
            cbTotalWritten += cbWritten;
        }
        else
            return E_FAIL;
    }

    _ASSERTE(cbTotalWritten == cbLength);

    return TRUE;

    /*
    // Get the address of the preceeding page boundary
    DWORD_PTR pdwFirstPage = GetNearestPageBoundary(pdwRemoteAddress);

    // This points to the start of the page *after* that last page that contains data to be copied
    DWORD_PTR pdwLastPage = GetNearestPageBoundary(pdwRemoteAddress + (cbLength - 1) + m_cbPageSize);

    // This is the current page being copied
    DWORD_PTR pdwCurPage = pdwFirstPage;

    // Now get all of the pages and add them to the hash
    while (pdwCurPage != pdwLastPage)
    {
        // Get the block for the first page
        ProcessMemoryBlock *pCurBlock = GetPage(pdwCurPage);
        _ASSERTE(pCurBlock);

        if (!pCurBlock)
            return FALSE;

        // Figure out where in the current page to start copying from
        SIZE_T cbUnusedPre = max(pdwCurPage, pdwRemoteAddress) - pdwCurPage;
        DWORD_PTR  pdwStart = pdwCurPage + cbUnusedPre;

        // Figure out where to end copying
        SIZE_T cbUnusedPost =
            (pdwCurPage + pCurBlock->GetLength()) - min(pdwRemoteAddress + cbLength, pdwCurPage + pCurBlock->GetLength());
        DWORD_PTR  pdwEnd = pdwCurPage + m_cbPageSize - cbUnusedPost;

        // Total unused bytes in this page
        SIZE_T cbUnusedTotal = cbUnusedPre + cbUnusedPost;
        SIZE_T cbCopyLength = pCurBlock->GetLength() - cbUnusedTotal;

        // Points to the page data
        PBYTE pbData = pCurBlock->GetData();
        _ASSERTE(pbData != NULL);

        if (pbData == NULL)
            return FALSE;

        // Write to the file
        DWORD cbWritten;
        WriteFile(hFile, (LPCVOID) (pbData + cbUnusedPre), (DWORD) cbCopyLength, (LPDWORD) &cbWritten, NULL);
        _ASSERTE(cbWritten == cbCopyLength);

        // Increase the page address
        pdwCurPage += m_cbPageSize;
        _ASSERTE(pdwCurPage <= pdwLastPage);
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#define _heapList _heapList_int
#define _METHODTOKEN _METHODTOKEN_int
#define alloc_context alloc_context_int
#define AppDomain AppDomain_int
#define ApplicationSecurityDescriptor ApplicationSecurityDescriptor_int
#define AppSecurityBoundary AppSecurityBoundary_int
#define ArrayClass ArrayClass_int
#define ArrayList ArrayList_int
#define Assembly Assembly_int
#define AssemblyMetaDataInternal AssemblyMetaDataInternal_int
#define AssemblySink AssemblySink_int
#define AwareLock AwareLock_int
#define BaseDomain BaseDomain_int
#define BaseObject BaseObject_int
#define ClassLoader ClassLoader_int
#define CodeManState CodeManState_int
#define ComCallWrapperCache ComCallWrapperCache_int
#define Context Context_int
#define CorModule CorModule_int
#define CrawlFrame CrawlFrame_int
#define Crst Crst_int
#define CRWLock CRWLock_int
#define CtxPolicyList CtxPolicyList_int
#define DomainLocalBlock DomainLocalBlock_int
#define EE_ILEXCEPTION EE_ILEXCEPTION_int
#define EEClass EEClass_int
#define EEClassHashTable EEClassHashTable_int
#define EEJitManager EEJitManager_int
#define EEMarshalingData EEMarshalingData_int
#define EEScopeClassHashTable EEScopeClassHashTable_int
#define EEStringHashTable EEStringHashTable_int
#define EEUnicodeStringHashTable EEUnicodeStringHashTable_int
#define EEUtf8StringHashTable EEUtf8StringHashTable_int
#define ExposedType ExposedType_int
#define FieldDesc FieldDesc_int
#define Fjit_hdrInfo Fjit_hdrInfo_int
#define Frame Frame_int
#define gc_heap gc_heap_int
#define GCCoverageInfo GCCoverageInfo_int
#define GCHeap GCHeap_int
#define generation generation_int
#define HashMap HashMap_int
#define HeapList HeapList_int
#define heap_segment heap_segment_int
#define IApplicationContext IApplicationContext_int
#define IAssembly IAssembly_int
#define IAssemblyName IAssemblyName_int
#define ICodeManager ICodeManager_int
#define IJitCompiler IJitCompiler_int
#define IJitManager IJitManager_int
#define InterfaceHintCache InterfaceHintCache_int
#define InterfaceInfo_t InterfaceInfo_t_int
#define InterfaceVTableMapMgr InterfaceVTableMapMgr_int
#define ISymUnmanagedReader ISymUnmanagedReader_int
#define JittedMethodInfo JittedMethodInfo_int
#define large_object_block large_object_block_int
#define ListLock ListLock_int
#define LoaderHeap LoaderHeap_int
#define LoaderHeapBlock LoaderHeapBlock_int
#define LockedListElement LockedListElement_int
#define MethodDesc MethodDesc_int
#define MethodDescChunk MethodDescChunk_int
#define MethodTable MethodTable_int
#define Module Module_int
#define Object Object_int
#define PEFile PEFile_int
#define plug plug_int
#define PtrHashMap PtrHashMap_int
#define SecurityProperties SecurityProperties_int
#define SharedDomain SharedDomain_int
#define SLink SLink_int
#define SList SList_int
#define SparseVTableMap SparseVTableMap_int
#define StackingAllocator StackingAllocator_int
#define StringObject StringObject_int
#define StubCallInstrs StubCallInstrs_int
#define SyncBlock SyncBlock_int
#define SyncBlockCache SyncBlockCache_int
#define SyncTableEntry SyncTableEntry_int
#define SystemDomain SystemDomain_int
#define Thread Thread_int
#define ThreadStore ThreadStore_int
#define TypeDesc TypeDesc_int
#define TypeHandle TypeHandle_int
#define UnlockedLoaderHeap UnlockedLoaderHeap_int
#define COR_ILMETHOD_SECT_EH_FAT_int
#define CORCOMPILE_METHOD_HEADER_int
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\minidump.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: MINIDUMP.H
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================

#pragma once
#include "common.h"

#include "minidumppriv.h"
#include "memory.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Globals

extern ProcessMemory *g_pProcMem;
extern MiniDumpBlock *g_pMDB;
extern MiniDumpInternalData *g_pMDID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\peb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "peb.h"
#include <nt.h>
#include <ntrtl.h>

#define offsetof(s,m)   ((size_t)&(((s *)0)->m))
#define FALSE 0
#define TRUE 1

extern ProcessMemory *g_pProcMem;

static DWORD_PTR g_pvPeb = NULL;
static DWORD_PTR g_pvMod = NULL;
static DWORD_PTR g_pvModFirst = NULL;

BOOL SaveString(DWORD_PTR prStr)
{
    BOOL fRes;

    if (prStr == NULL) return (TRUE);

    UNICODE_STRING str = {0, 0, 0};
    move_res(str, prStr, fRes);
    if (!fRes) return (FALSE);

    if (str.Buffer == 0 || str.Length == 0)
        return (TRUE);

    fRes = g_pProcMem->MarkMem((DWORD_PTR) str.Buffer, (SIZE_T) str.Length + sizeof(WCHAR));
    if (!fRes) return (FALSE);

    return (TRUE);
}

BOOL SaveTebInfo(DWORD_PTR prTeb, BOOL fSavePeb)
{
    // Add the teb range to the address ranges
    BOOL fRes = g_pProcMem->MarkMem(prTeb, sizeof(TEB));
    if (!fRes) return (fRes);

    // Should we save the PEB?
    if (fSavePeb)
    {
        DWORD_PTR pvPeb;
        move_res(pvPeb, prTeb + offsetof(TEB, ProcessEnvironmentBlock), fRes);
        if (!fRes) return (FALSE);

        fRes = g_pProcMem->MarkMem(pvPeb, sizeof(PEB));
        if (!fRes) return (FALSE);

        // Save for later
        g_pvPeb = pvPeb;

        // Now follow the loader table links and save them
        DWORD_PTR pvLdr;
        move_res(pvLdr, pvPeb + offsetof(PEB, Ldr), fRes);
        if (!fRes) return (FALSE);

        fRes = g_pProcMem->MarkMem(pvLdr, sizeof(PEB_LDR_DATA));
        if (!fRes) return (FALSE);

        // Get the pointer to the first module entry
        DWORD_PTR pvMod;
        DWORD_PTR pvModFirst;
        move_res(pvMod, pvLdr + offsetof(PEB_LDR_DATA, InLoadOrderModuleList), fRes);
        if (!fRes) return (FALSE);

        // Now go over all the entries and save them
        pvModFirst = pvMod;
        while (pvMod != NULL)
        {
            fRes = g_pProcMem->MarkMem(pvMod, sizeof(LDR_DATA_TABLE_ENTRY));
            if (!fRes) return (FALSE);

            fRes = SaveString(pvMod + offsetof(LDR_DATA_TABLE_ENTRY, FullDllName));
            if (!fRes) return (FALSE);

            fRes = SaveString(pvMod + offsetof(LDR_DATA_TABLE_ENTRY, BaseDllName));
            if (!fRes) return (FALSE);

            move_res(pvMod, pvMod + offsetof(LDR_DATA_TABLE_ENTRY, InLoadOrderLinks), fRes);
            if (!fRes) return (FALSE);

            if (pvMod == pvModFirst) break;
        }

        // Now save the process parameters
        DWORD_PTR pvParam;
        move_res(pvParam, pvPeb + offsetof(PEB, ProcessParameters), fRes);
        if (!fRes) return (FALSE);

        RTL_USER_PROCESS_PARAMETERS param;
        move_res(param, pvParam, fRes);
        if (!fRes) return (FALSE);

        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, WindowTitle));
        if (!fRes) return (FALSE);
        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, DesktopInfo));
        if (!fRes) return (FALSE);
        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, CommandLine));
        if (!fRes) return (FALSE);
        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, ImagePathName));
        if (!fRes) return (FALSE);
        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, DllPath));
        if (!fRes) return (FALSE);
        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, ShellInfo));
        if (!fRes) return (FALSE);
        fRes = SaveString(pvParam + offsetof(RTL_USER_PROCESS_PARAMETERS, RuntimeData));
        if (!fRes) return (FALSE);
    }

    return (fRes);
}

void ResetLoadedModuleBaseEnum()
{
    g_pvModFirst = NULL;
    g_pvMod = NULL;
}

DWORD_PTR GetNextLoadedModuleBase()
{
    BOOL fRes;
    DWORD_PTR res = NULL;

    if (g_pvPeb != NULL)
    {
        if (g_pvModFirst == NULL)
        {

            // Now follow the loader table links and save them
            DWORD_PTR pvLdr;
            move_res(pvLdr, g_pvPeb + offsetof(PEB, Ldr), fRes);
            if (!fRes) return (NULL);

            // Get the pointer to the first module entry
            move_res(g_pvMod, pvLdr + offsetof(PEB_LDR_DATA, InLoadOrderModuleList), fRes);
            if (!fRes) return (NULL);

            // Now go over all the entries and save them
            g_pvModFirst = g_pvMod;
        }

        DWORD_PTR pvModNext;
        move_res(pvModNext, g_pvMod + offsetof(LDR_DATA_TABLE_ENTRY, InLoadOrderLinks), fRes);

        if (pvModNext != g_pvModFirst)
        {
            move_res(res, g_pvMod + offsetof(LDR_DATA_TABLE_ENTRY, DllBase), fRes);
            if (!fRes) return (NULL);

            move_res(g_pvMod, g_pvMod + offsetof(LDR_DATA_TABLE_ENTRY, InLoadOrderLinks), fRes);
            if (!fRes) return (NULL);
        }
    }

    return (res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\minidump.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: MINIDUMP.CPP
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================

#include "common.h"
#include "minidump.h"

#include <windows.h>
#include <crtdbg.h>

#include "winwrap.h"
#include "minidumppriv.h"

#include "IPCManagerInterface.h"
#include "stacktrace.h"
#include "memory.h"

#define UINT16 unsigned __int16
#include <dbghelp.h>
#undef UINT16

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Globals

ProcessMemory *g_pProcMem = NULL;
MiniDumpBlock *g_pMDB = NULL;
MiniDumpInternalData *g_pMDID = NULL;

static SIZE_T cNumPageBuckets = 251;

BOOL WriteMiniDumpFile(HANDLE hFile);
BOOL RunningOnWinNT();

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is the entrypoint that will perform the work to create the minidump

STDAPI CorCreateMiniDump(DWORD dwProcessId, WCHAR *szOutFilename)
{
    HRESULT             hr      = E_FAIL;
    IPCReaderInterface *ipc     = NULL;
    HANDLE              hFile   = INVALID_HANDLE_VALUE;
    BOOL                fRes    = FALSE;

    // Initialize stuff
    ProcessPageAndBitMap::Init();

    // Create the file, overwriting existing files if necessary
    hFile = WszCreateFile(szOutFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto LExit;
    }

    ipc = (IPCReaderInterface *) new IPCReaderImpl();
    if (ipc == NULL)
        goto LExit;

    hr = ipc->OpenPrivateBlockOnPidReadOnly(dwProcessId);

    if (FAILED(hr))
        goto LExit;

    // Get the shared MiniDump block
    g_pMDB = ipc->GetMiniDumpBlock();
    _ASSERTE(g_pMDB);

    if (!g_pMDB)
    {
        hr = E_FAIL;
        goto LExit;
    }

    // Create a process memory reader
    g_pProcMem = new ProcessMemory(dwProcessId);
    _ASSERTE(g_pProcMem);

    if (g_pProcMem == NULL)
        return (E_OUTOFMEMORY);

    // Initialize the process memory object
    hr = g_pProcMem->Init();
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr))
        goto LExit;

    g_pProcMem->SetAutoMark(TRUE);

    // Add the MiniDumpInternalData block as an element to be saved.
    g_pProcMem->MarkMem((DWORD_PTR)g_pMDB->pInternalData, g_pMDB->dwInternalDataSize);

    // Allocate the block for the internal data block
    g_pMDID = new MiniDumpInternalData;

    if (g_pMDID == NULL)
        goto LExit;

    // Make a copy of the MiniDumpInternalData structure
    fRes = g_pProcMem->CopyMem((DWORD_PTR) g_pMDB->pInternalData, (PBYTE) g_pMDID, sizeof(MiniDumpInternalData));
    _ASSERTE(fRes);

    if (!fRes)
    {
        hr = E_FAIL;
        goto LExit;
    }

    // Now preserve all the listed extra memory blocks
    for (SIZE_T i = 0; i < g_pMDID->cExtraBlocks; i++)
        g_pProcMem->MarkMem((DWORD_PTR)g_pMDID->rgExtraBlocks[i].pbStart, g_pMDID->rgExtraBlocks[i].cbLen);

    // Now read all the thrad objects
    ReadThreads();

    // Now write the minidump
    fRes = WriteMiniDumpFile(hFile);
    _ASSERTE(fRes);

LExit:
    // Close the file
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (g_pMDID)
        delete g_pMDID;

    return hr;
}

#define WRITE(data, len)                                                    \
{                                                                           \
    DWORD __bytesWritten;                                                   \
    WriteFile(hFile, (LPCVOID) data, (DWORD) len, &__bytesWritten, NULL);   \
    if (__bytesWritten != (DWORD) len)                                      \
    {                                                                       \
        if (pMemList != NULL) delete [] pMemList;                           \
        return (FALSE);                                                     \
    }                                                                       \
    cbBytesWritten += __bytesWritten;                                       \
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This will write out the memory stream in a raw format that the office "heapmerge" tool will understand and be
// able to merge back into a real minidump.
//
// The format is:
//
// ULONG32 numEntries                                   - number of memory ranges in the file
// MINIDUMP_MEMORY_DESCRIPTOR descriptors[numEntries]   - array of memory descriptors
// RAW DATA                                             - the data for all memory ranges

BOOL WriteMiniDumpFile(HANDLE hFile)
{
    SIZE_T                  cbCurFileRVA        = 0;
    SIZE_T                  cbBytesWritten      = 0;

    MINIDUMP_MEMORY_LIST   *pMemList            = NULL;
    SIZE_T                  cbMemList           = 0;

    // This will count the number of contiguous blocks
    DWORD_PTR pdwAddr;
    SIZE_T cbLen;
    SIZE_T cEntries = 0;

    g_pProcMem->Coalesce(sizeof(MINIDUMP_MEMORY_DESCRIPTOR));

    if (RunningOnWinNT())
        g_pProcMem->ClearIncompatibleImageSections();

    g_pProcMem->ResetContiguousReadBlock();
    while (g_pProcMem->NextContiguousReadBlock(&pdwAddr, &cbLen))
        cEntries++;

    // Now allocate the MINIDUMP_MEMORY_LIST array
    cbMemList = sizeof(MINIDUMP_MEMORY_LIST) + (sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cEntries);
    pMemList = (MINIDUMP_MEMORY_LIST *) new BYTE[cbMemList];
    _ASSERTE(pMemList);

    if (!pMemList)
        return (FALSE);

    // Increase the file RVA by the size of the memory list
    cbCurFileRVA += cbMemList;

    // Now loop over the address ranges collecting the necessary information to fill out the memory list
    g_pProcMem->ResetContiguousReadBlock();
    for (SIZE_T i = 0; g_pProcMem->NextContiguousReadBlock(&pdwAddr, &cbLen); i++)
    {
        _ASSERTE(i < cEntries);

        pMemList->MemoryRanges[i].StartOfMemoryRange = (ULONG64) pdwAddr;
        pMemList->MemoryRanges[i].Memory.DataSize = (ULONG32) cbLen;
        pMemList->MemoryRanges[i].Memory.Rva = cbCurFileRVA;

        cbCurFileRVA += cbLen;
    }

    // Set the number of entries in the structure
    pMemList->NumberOfMemoryRanges = (ULONG32) cEntries;

    // Now that we've filled out the memory list, write it to the file
    WRITE(pMemList, cbMemList);

    // Don't need the memory list anymore
    delete [] pMemList;

    // Now we can loop again writing out the memory ranges to file
    g_pProcMem->ResetContiguousReadBlock();
    while (g_pProcMem->NextContiguousReadBlock(&pdwAddr, &cbLen))
    {
        HRESULT hr = g_pProcMem->WriteMemToFile(hFile, pdwAddr, cbLen);

        if (FAILED(hr))
            return (FALSE);

        cbBytesWritten += cbLen;
    }

    _ASSERTE(i == cEntries);
    _ASSERTE(cbBytesWritten == cbCurFileRVA);

    DWORD dumpSig = 0x00141F2B; // 100000th prime number ;-)
    DWORD cbWritten;
    WriteFile(hFile, &dumpSig, sizeof(dumpSig), &cbWritten, NULL);

    return (TRUE);
}

/*
BOOL WriteMiniDumpFile(HANDLE hFile)
{
    DWORD dwBytesWritten;       // Used for WriteFile calls
    BOOL  fRes;                 // Used for results of WriteFile

    // Keep track of the current file offset that we've written to
    SIZE_T cbCurFileRVA = 0;

    // Create the MiniDump header
    MINIDUMP_HEADER header = {0};

    header.NumberOfStreams = 1;
    header.StreamDirectoryRva = cbCurFileRVA + sizeof(MINIDUMP_HEADER);

    // Write the header to the file
    fRes = WriteFile(hFile, (LPCVOID) &header, sizeof(MINIDUMP_HEADER), &dwBytesWritten, NULL);
    _ASSERTE(fRes && dwBytesWritten == sizeof(MINIDUMP_HEADER));

    if (!fRes)
        return (FALSE);

    // Add the size of the header to the current location in file
    cbCurFileRVA += sizeof(MINIDUMP_HEADER);

    // There is only one directory at the moment for a memory stream
    MINIDUMP_DIRECTORY directory = {0};
    directory.StreamType = MemoryListStream;
    directory.Location.Rva = cbCurFileRVA + sizeof(MINIDUMP_DIRECTORY);

    // The number of AddressRanges in pAddrs equals the number of memory list entries
    SIZE_T cMemListEntries = g_pAddrs->NumEntries();

    // This is the length in bytes of the memory list structure
    SIZE_T cbMemList = sizeof(MINIDUMP_MEMORY_LIST) + (sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cMemListEntries);

    // Save this into the cbCurFileRVA
    cbCurFileRVA += cbMemList;

    // Create the Minidump memory list
    MINIDUMP_MEMORY_LIST *pMemList = (MINIDUMP_MEMORY_LIST *) new BYTE[cbMemList];
    _ASSERTE(pMemList != NULL);

    if (pMemList == NULL)
        return (FALSE);

    // Save how many entries there are
    pMemList->NumberOfMemoryRanges = cMemListEntries;

    // Cycle over the entries, filling the individual sizes and keeping a size total
    SIZE_T cbMemoryTotal = cbMemList;
    AddressRange *pRange = g_pAddrs->First();
    for (SIZE_T i = 0; pRange != NULL; i++)
    {
        _ASSERTE(i < cMemListEntries);

        pMemList->MemoryRanges[i].StartOfMemoryRange = (ULONG64) pRange->GetStart();
        pMemList->MemoryRanges[i].Memory.DataSize = pRange->GetLength();
        pMemList->MemoryRanges[i].Memory.Rva = cbCurFileRVA;

        cbMemoryTotal += pRange->GetLength();
        cbCurFileRVA += pRange->GetLength();

        pRange = g_pAddrs->Next(pRange);
    }

    // Finish filling out the directory and write it to the file
    directory.Location.DataSize = cbMemoryTotal;
    fRes = WriteFile(hFile, (LPCVOID) &directory, sizeof(MINIDUMP_DIRECTORY), &dwBytesWritten, NULL);
    _ASSERTE(fRes && dwBytesWritten == sizeof(MINIDUMP_DIRECTORY));

    // If the write failed, return failure
    if (!fRes)
    {
        delete [] pMemList;
        return (fRes);
    }

    // Write the directory list
    fRes = WriteFile(hFile, (LPCVOID) pMemList, cbMemList, &dwBytesWritten, NULL);
    _ASSERTE(fRes && dwBytesWritten == cbMemList);

    // We're done with the memory range list
    delete [] pMemList;

    // If the write failed, return failure
    if (!fRes)
        return (fRes);

    // Now we can loop again writing out the memory ranges to file
    for (i = 0, pRange = g_pAddrs->First(); pRange != NULL; i++, pRange = g_pAddrs->Next(pRange))
        g_pProcMem->WriteMemToFile(hFile, pRange->GetStart(), pRange->GetLength());

    // Indicate success
    return (TRUE);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\peb.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#include "memory.h"

BOOL SaveTebInfo(DWORD_PTR prTeb, BOOL fSavePeb);
void ResetLoadedModuleBaseEnum();
DWORD_PTR GetNextLoadedModuleBase();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\stacktrace.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: STACKTRACE.CPP
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================


#include <windows.h>
#include <crtdbg.h>

#include "common.h"
#include "peb.h"
#include "stacktrace.h"
#include "minidump.h"
#include "memory.h"
#include "gcinfo.h"

BOOL RunningOnWinNT();

typedef LPVOID PEXCEPTION_ROUTINE;
typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

#include "eestructs.h"

size_t FASTCALL decodeUnsigned(const BYTE *src, unsigned* val);
BOOL CallStatus = FALSE;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void ReadThreads()
{
    __try
    {
        // Add the thread store object
        DWORD_PTR v_g_pThreadStore;
        move(v_g_pThreadStore, g_pMDID->ppb_g_pThreadStore);
        g_pProcMem->MarkMem((DWORD_PTR) v_g_pThreadStore, g_pMDID->cbThreadStoreObjectSize);

        //
        // Add all of the thread objects
        //

        SIZE_T cbNextOffset = g_pMDID->cbThreadNextOffset;
        SIZE_T cbObjectSize = g_pMDID->cbThreadObjectSize;

        // The thread link structure is wierd - it's actually a pointer to the m_pNext pointer within
        // the object, so to get the object, one needs to subtract cbNextOffset from the pointer
        DWORD_PTR ppbrCurThreadNext = (DWORD_PTR)g_pMDID->ppbThreadListHead;
        DWORD_PTR pbrCurThreadNext;
        DWORD_PTR pbrCurThread;

        move(pbrCurThreadNext, ppbrCurThreadNext);

        BOOL      fPebSaved = FALSE;
        DWORD_PTR prTeb = NULL;

        while (pbrCurThreadNext != NULL)
        {
            // Calculate the beginning of the thread object
            pbrCurThread = pbrCurThreadNext - cbNextOffset;

            // Add the entire object
            g_pProcMem->MarkMem(pbrCurThread, cbObjectSize);

            // Get the handle for this thread
            HANDLE hrThread;
            move(hrThread, pbrCurThread + g_pMDID->cbThreadHandleOffset);

            // Get the stack base address
            DWORD_PTR prStackBase;
            move(prStackBase, pbrCurThread + g_pMDID->cbThreadStackBaseOffset);

            // Save the context of the thread
            DWORD_PTR prContext;
            move(prContext, pbrCurThread + g_pMDID->cbThreadContextOffset);
            g_pProcMem->MarkMem(prContext, g_pMDID->cbSizeOfContext);

            // Save the domain of the thread
            DWORD_PTR prDomain;
            move(prDomain, pbrCurThread + g_pMDID->cbThreadDomainOffset);
            if (prDomain == 0)
                move(prDomain, prContext + g_pMDID->cbOffsetOf_CTX_m_pDomain);

            if (prDomain != 0)
                g_pProcMem->MarkMem(prDomain, g_pMDID->cbSizeOfContext);

            // Save the last thrown object handle
            DWORD_PTR prLastThrownObject;
            move(prLastThrownObject, pbrCurThread + g_pMDID->cbThreadLastThrownObjectHandleOffset);
            if (prLastThrownObject != NULL)
            {
                DWORD_PTR prMT;
                move(prMT, prLastThrownObject);

                if (prMT)
                    g_pProcMem->MarkMem(prMT, g_pMDID->cbSizeOfMethodTable);
            }

            // Save the TEB, and possibly the PEB, but only for WinNT
            if (RunningOnWinNT())
            {
                move(prTeb, pbrCurThread + g_pMDID->cbThreadTEBOffset);
                BOOL fRes = SaveTebInfo(prTeb, !fPebSaved);
                _ASSERTE(fRes);
                fPebSaved = TRUE;

            }

            // Now crawl the stack and save all that strike would need in doing the same
            CrawlStack(hrThread, prStackBase);

            // Move on to the next thread
            move(pbrCurThreadNext, pbrCurThreadNext);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        _ASSERTE(!"Exception occured.");
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

void CrawlStack(HANDLE hrThread, DWORD_PTR prStackBase)
{
    __try
    {
        // Duplicate the handle into this process
        HANDLE hThread;
        BOOL fRes = DuplicateHandle(g_pProcMem->GetProcHandle(), hrThread, GetCurrentProcess(), &hThread,
                                    THREAD_GET_CONTEXT, FALSE, 0);
    
        if (!fRes)
            return;
    
        // Get the thread's context
        CONTEXT ctx;
        ctx.ContextFlags = CONTEXT_CONTROL;
        GetThreadContext(hThread, &ctx);
    
        // Set the flags
        StackTraceFlags stFlags;
        stFlags.dwEip = ctx.Eip;
        stFlags.pbrStackTop = ctx.Esp;
        stFlags.pbrStackBase = prStackBase;

        __try
        {
            StackTrace(stFlags);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            _ASSERTE(!"Exception occured.");
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        _ASSERTE(!"Exception occured.");
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

void StackTrace(StackTraceFlags stFlags)
{
    BOOL fIsEBPFrame = FALSE;

    PrintCallInfo (0, (DWORD_PTR)stFlags.dwEip, TRUE);

    DWORD_PTR ptr = (DWORD_PTR)(((DWORD)stFlags.pbrStackTop) & ~3);  // make certain dword aligned

    while (ptr < stFlags.pbrStackBase)
    {
        DWORD_PTR retAddr;
        DWORD_PTR whereCalled;
        move(retAddr, ptr);

        g_pProcMem->SetAutoMark(FALSE);
        isRetAddr(retAddr, &whereCalled);

        if (whereCalled)
        {
            g_pProcMem->SetAutoMark(TRUE);
            isRetAddr(retAddr, &whereCalled);
            g_pProcMem->SetAutoMark(FALSE);
            // Re-execute the function to mark the bits for saving
            BOOL bOutput = PrintCallInfo (ptr-4, retAddr, FALSE);

            if (bOutput)
            {
                g_pProcMem->SetAutoMark(TRUE);
                isRetAddr(retAddr, &whereCalled);
                PrintCallInfo (ptr-4, retAddr, FALSE);
                g_pProcMem->SetAutoMark(FALSE);
            }

            if (whereCalled != (DWORD_PTR)0xFFFFFFFF)
            {
                bOutput = PrintCallInfo (0, whereCalled, TRUE);

                if (bOutput)
                {
                    g_pProcMem->SetAutoMark(TRUE);
                    PrintCallInfo (0, whereCalled, TRUE);
                    g_pProcMem->SetAutoMark(FALSE);
                }
            }
        }
        ptr += sizeof (DWORD_PTR);

        g_pProcMem->SetAutoMark(TRUE);
    }

    g_pProcMem->SetAutoMark(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void MethodDesc::Fill (DWORD_PTR &dwStartAddr)
{
    memset (this, 0xCC, sizeof(*this));

    // If this is a debug build, also fill out some of the debug information
    if (g_pMDID->fIsDebugBuild)
    {
        move(m_pDebugEEClass, dwStartAddr + g_pMDID->cbOffsetOf_m_pDebugEEClass);
        move(m_pszDebugMethodName, dwStartAddr + g_pMDID->cbOffsetOf_m_pszDebugMethodName);
        move(m_pszDebugMethodSignature, dwStartAddr + g_pMDID->cbOffsetOf_m_pszDebugMethodSignature);
    }

    move(m_wFlags, dwStartAddr + g_pMDID->cbOffsetOf_m_wFlags);
    move(m_CodeOrIL, dwStartAddr + g_pMDID->cbOffsetOf_m_dwCodeOrIL);

    DWORD_PTR dwAddr = dwStartAddr + g_pMDID->cbMD_IndexOffset;
    char ch;
    move (ch, dwAddr);
    dwAddr = dwStartAddr + ch * MethodDesc::ALIGNMENT + g_pMDID->cbMD_SkewOffset;

    MethodDescChunk vMDChunk;
    vMDChunk.Fill(dwAddr);

    BYTE tokrange = vMDChunk.m_tokrange;
    dwAddr = dwStartAddr - METHOD_PREPAD;

    StubCallInstrs vStubCall;
    vStubCall.Fill(dwAddr);

    unsigned __int16 tokremainder = vStubCall.m_wTokenRemainder;
    m_dwToken = (tokrange << 16) | tokremainder;
    m_dwToken |= mdtMethodDef;
    dwStartAddr += g_pMDID->cbMethodDescSize;

    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void MethodDescChunk::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
    _ASSERTE(g_pMDID->cbMethodDescChunkSize > 0);
    move(m_tokrange, dwStartAddr + g_pMDID->cbOffsetOf_m_tokrange);
    dwStartAddr += g_pMDID->cbMethodDescChunkSize;
    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void MethodTable::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    move(m_pEEClass, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_pEEClass);
    move(m_pModule, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_pModule);
    move(m_pEEClass, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_pEEClass);
    move(m_wFlags, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_wFlags);
    move(m_BaseSize, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_BaseSize);
    move(m_ComponentSize, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_ComponentSize);
    move(m_wNumInterface, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_wNumInterface);
    move(m_pIMap, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_pIMap);
    move(m_cbSlots, dwStartAddr + g_pMDID->cbOffsetOf_MT_m_cbSlots);
    m_Vtable[0] = (SLOT)(dwStartAddr + g_pMDID->cbOffsetOf_MT_m_Vtable);
    dwStartAddr += g_pMDID->cbSizeOfMethodTable;;
    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void EEClass::Fill (DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;

    memset (this, 0xCC, sizeof(*this));
    if (g_pMDID->fIsDebugBuild)
        move(m_szDebugClassName, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_szDebugClassName);
    move(m_cl, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_cl);
    move(m_pParentClass, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_pParentClass);
    move(m_pLoader, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_pLoader);
    move(m_pMethodTable, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_pMethodTable);
    move(m_wNumVtableSlots, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wNumVtableSlots);
    move(m_wNumMethodSlots, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wNumMethodSlots);
    move(m_dwAttrClass, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_dwAttrClass);
    move(m_VMFlags, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_VMFlags);
    move(m_wNumInstanceFields, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wNumInstanceFields);
    move(m_wNumStaticFields, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wNumStaticFields);
    move(m_wThreadStaticOffset, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wThreadStaticOffset);
    move(m_wContextStaticOffset, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wContextStaticOffset);
    move(m_wThreadStaticsSize, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wThreadStaticsSize);
    move(m_wContextStaticsSize, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_wContextStaticsSize);
    move(m_pFieldDescList, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_pFieldDescList);
    move(m_pMethodTable, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_pMethodTable);
    move(m_SiblingsChain, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_SiblingsChain);
    move(m_ChildrenChain, dwStartAddr + g_pMDID->cbOffsetOf_CLS_m_ChildrenChain);
    dwStartAddr += g_pMDID->cbSizeOfEEClass;

    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void Module::Fill(DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;

    move(m_dwFlags, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_dwFlags);
    move(m_pAssembly, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_pAssembly);
    move(m_file, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_file);
    move(m_zapFile, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_zapFile);
    move(m_pLookupTableHeap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_pLookupTableHeap);
    move(m_TypeDefToMethodTableMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_TypeDefToMethodTableMap);
    move(m_TypeRefToMethodTableMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_TypeRefToMethodTableMap);
    move(m_MethodDefToDescMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_MethodDefToDescMap);
    move(m_FieldDefToDescMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_FieldDefToDescMap);
    move(m_MemberRefToDescMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_MemberRefToDescMap);
    move(m_FileReferencesMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_FileReferencesMap);
    move(m_AssemblyReferencesMap, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_AssemblyReferencesMap);
    move(m_pNextModule, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_pNextModule);
    move(m_dwBaseClassIndex, dwStartAddr + g_pMDID->cbOffsetOf_MOD_m_dwBaseClassIndex);
    dwStartAddr += g_pMDID->cbSizeOfModule;

    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void PEFile::Fill(DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;

    move(m_wszSourceFile, dwStartAddr + g_pMDID->cbOffsetOf_PEF_m_wszSourceFile);
    move(m_hModule, dwStartAddr + g_pMDID->cbOffsetOf_PEF_m_hModule);
    move(m_base, dwStartAddr + g_pMDID->cbOffsetOf_PEF_m_base);
    move(m_pNT, dwStartAddr + g_pMDID->cbOffsetOf_PEF_m_pNT);
    dwStartAddr += g_pMDID->cbSizeOfPEFile;

    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Routine Description:
//
//    This function is called to determine if a DWORD on the stack is
//    a return address.
//    It does this by checking several bytes before the DWORD to see if
//    there is a call instruction.
//

void isRetAddr(DWORD_PTR retAddr, DWORD_PTR* whereCalled)
{
    *whereCalled = 0;
    // don't waste time values clearly out of range
    if (retAddr < 0x1000 || retAddr > 0xC0000000)   
        return;

    unsigned char spotend[6];
    move (spotend, retAddr-6);
    unsigned char *spot = spotend+6;
    DWORD_PTR addr;
    BOOL fres;

    // Note this is possible to be spoofed, but pretty unlikely
    // call XXXXXXXX
    if (spot[-5] == 0xE8) {
        move (*whereCalled, retAddr-4);
        *whereCalled += retAddr;
        //*whereCalled = *((int*) (retAddr-4)) + retAddr;
        if (*whereCalled < 0xC0000000 && *whereCalled > 0x1000) {
            move_res(addr,*whereCalled,fres);
            if (fres) {
                DWORD_PTR callee;
                if (GetCalleeSite(*whereCalled, callee)) {
                    *whereCalled = callee;
                }
            }
            return;
        }
        else
            *whereCalled = 0;
    }

    // call [XXXXXXXX]
    if (spot[-6] == 0xFF && (spot[-5] == 025))  {
        move (addr, retAddr-4);
        move (*whereCalled, addr);
        //*whereCalled = **((unsigned**) (retAddr-4));
        if (*whereCalled < 0xC0000000 && *whereCalled > 0x1000) {
            move_res(addr,*whereCalled,fres);
            if (fres) {
                DWORD_PTR callee;
                if (GetCalleeSite(*whereCalled, callee)) {
                    *whereCalled = callee;
                }
            }
            return;
        }
        else
            *whereCalled = 0;
    }

    // call [REG+XX]
    if (spot[-3] == 0xFF && (spot[-2] & ~7) == 0120 && (spot[-2] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    if (spot[-4] == 0xFF && spot[-3] == 0124)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }

    // call [REG+XXXX]
    if (spot[-6] == 0xFF && (spot[-5] & ~7) == 0220 && (spot[-5] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    if (spot[-7] == 0xFF && spot[-6] == 0224)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // call [REG]
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0020 && (spot[-1] & 7) != 4 && (spot[-1] & 7) != 5)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // call REG
    if (spot[-2] == 0xFF && (spot[-1] & ~7) == 0320 && (spot[-1] & 7) != 4)
    {
        *whereCalled = 0xFFFFFFFF;
        return;
    }
    
    // There are other cases, but I don't believe they are used.
    return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Return TRUE if we have saved something.

BOOL SaveCallInfo (DWORD_PTR vEBP, DWORD_PTR IP, StackTraceFlags& stFlags, BOOL bSymbolOnly)
{
    /*
    char Symbol[1024];
    char filename[MAX_PATH+1];
    */
    WCHAR mdName[mdNameLen];
    ULONG64 Displacement;
    BOOL bOutput = FALSE;

    DWORD_PTR methodDesc;
    methodDesc = MDForCall (IP);

    if (methodDesc)
    {
        bOutput = TRUE;
        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        _ASSERTE(CallStatus);
        GetMDIPOffset (IP, &vMD, Displacement);
        if (Displacement != 0 && Displacement != -1)
        NameForMD (methodDesc, mdName);
    }
    else
    {
        /*
        bOutput = TRUE;
        HRESULT hr;
        hr = g_ExtSymbols->GetNameByOffset(IP, Symbol, 1024, NULL, &Displacement);
        if (SUCCEEDED(hr) && Symbol[0] != '\0')
        {
            ULONG line;
            hr = g_ExtSymbols->GetLineByOffset (IP, &line, filename,
                                                MAX_PATH+1, NULL, NULL);
        }
        else*/ if (!IsMethodDesc(IP, TRUE))
            (void *)0;
    }
    return bOutput;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Return 0 for non-managed call.  Otherwise return MD address.

DWORD_PTR MDForCall(DWORD_PTR callee)
{
    // call managed code?
    JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR IP = callee;
    DWORD_PTR gcinfoAddr;

    if (!GetCalleeSite (callee, IP))
        return 0;

    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc)
    {
        return methodDesc;
    }

    // call stub
    //char line[256];
    //DisasmAndClean (IP, line, 256);
    //char *ptr = line;
    //NextTerm (ptr);
    //NextTerm (ptr);
    // This assumes that the current IP is a call (we don't bother to check), and
    // so just check if the dword afterwards is a method desc
    g_pProcMem->MarkMem(IP, 5);
    IP += 5;
    if (/*!strncmp (ptr, "call ", 5)
        &&*/ IsMethodDesc(IP, FALSE))
    {
        return IP;
    }
    /*
    else if (!strncmp (ptr, "jmp ", 4))
    {
        // For EJIT/debugger/profiler
        NextTerm (ptr);
        INT_PTR value;
        methodDesc = 0;
        if (GetValueFromExpr (ptr, value))
        {
            IP2MethodDesc (value, methodDesc, jitType, gcinfoAddr);
        }
        return methodDesc;
    }
    */
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Find next term. A term is seperated by space or ,

void NextTerm (char *& ptr)
{
    // If we have a byref, skip to ']'
    if (IsByRef (ptr))
    {
        while (ptr[0] != ']' && ptr[0] != '\0')
            ptr ++;
        if (ptr[0] == ']')
            ptr ++;
    }
    
    while (!IsTermSep (ptr[0]))
        ptr ++;
    while (IsTermSep(ptr[0]) && (*ptr != '\0'))
        ptr ++;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// If byref, move to pass the byref prefix

BOOL IsByRef (char *& ptr)
{
    BOOL bByRef = FALSE;
    if (ptr[0] == '[')
    {
        bByRef = TRUE;
        ptr ++;
    }
    else if (!strncmp (ptr, "dword ptr [", 11))
    {
        bByRef = TRUE;
        ptr += 11;
    }
    return bByRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

BOOL IsTermSep (char ch)
{
    return (ch == '\0' || isspace (ch) || ch == ',' || ch == '\n');
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Find the real callee site.  Handle JMP instruction.
// Return TRUE if we get the address, FALSE if not.

BOOL GetCalleeSite(DWORD_PTR IP, DWORD_PTR &IPCallee)
{
    // Get the 6 bytes pointed to by IP
    BYTE instr[6];

    BOOL fRes;
    move_res(instr, IP, fRes);
    if (!fRes) return (FALSE);

    // Figure out if this is a JMP instruction
    switch (instr[0])
    {
    case 0xEB:
        IPCallee = IP + instr[1];
        return (TRUE);
        break;

    case 0xE9:
        // For now, only deal with this type of jmp instruction
        IPCallee = IP + *((SIZE_T *)&instr[1]);
        return (TRUE);
        break;

    case 0xFF:
		//
		// Read opcode modifier from modr/m
		//
        if (instr[1] == 0x25) {
            // jmp [dsp32]
            move_res(IPCallee, *(DWORD*)&instr[2], fRes);
            return (TRUE);
        }
        else
        {
            switch ((instr[1]&0x38)>>3)
            {
            case 4:

            case 5:
                _ASSERTE(!"Dunno how to deal with this.");
                break;

            default:
                break;
            }
        }

    case 0xEA:
        //_ASSERTE(!"Dunno how to deal with this.");
        break;
    }

    IPCallee = IP;

    return (TRUE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

JitType GetJitType (DWORD_PTR Jit_vtbl)
{
    // Decide EEJitManager/EconoJitManager
    static BOOL  fIsInit = FALSE;
    static DWORD_PTR EEJitManager_vtbl = (DWORD_PTR) -1;
    static DWORD_PTR EconoJitManager_vtbl = (DWORD_PTR) -1;
    static DWORD_PTR MNativeJitManager_vtbl = (DWORD_PTR) -1;

    if (!fIsInit)
    {
        BOOL fRes;
        if (g_pMDID->ppbEEJitManagerVtable != NULL)
            move_res(EEJitManager_vtbl, g_pMDID->ppbEEJitManagerVtable, fRes);
        if (g_pMDID->ppbEconoJitManagerVtable != NULL)
            move_res(EconoJitManager_vtbl, g_pMDID->ppbEconoJitManagerVtable, fRes);
        if (g_pMDID->ppbMNativeJitManagerVtable != NULL)
            move_res(MNativeJitManager_vtbl, g_pMDID->ppbMNativeJitManagerVtable, fRes);

        fIsInit = TRUE;
    }

    if (Jit_vtbl == EEJitManager_vtbl)
        return JIT;
    else if (Jit_vtbl == EconoJitManager_vtbl)
        return EJIT;
    else if (Jit_vtbl == MNativeJitManager_vtbl)
        return PJIT;
    else
        return UNKNOWN;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    This function is called to get the address of MethodDesc
//    given an ip address

// @todo - The following static was moved to file global to avoid the VC7
//         compiler problem with statics in functions containing trys.
//         When the next VC7 LKG comes out, these can be returned to the function

static DWORD_PTR pJMIT = 0;
// jitType: 1 for normal JIT generated code, 2 for EJIT, 0 for unknown
void IP2MethodDesc (DWORD_PTR IP, DWORD_PTR &methodDesc, JitType &jitType, DWORD_PTR &gcinfoAddr)
{
    jitType = UNKNOWN;
    DWORD_PTR dwAddrString;
    methodDesc = 0;
    gcinfoAddr = 0;
    DWORD_PTR EEManager;

    move(EEManager, g_pMDID->ppbEEManagerRangeTree);

    RangeSection RS;

    DWORD_PTR RSAddr = EEManager;
    while (RSAddr)
    {
        move (RS, RSAddr);
        if (IP < RS.LowAddress)
            RSAddr = RS.pleft;
        else if (IP > RS.HighAddress)
            RSAddr = RS.pright;
        else
            break;
    }
    
    if (RSAddr == 0)
    {
        return;
    }

    DWORD_PTR JitMan = RSAddr + sizeof(PVOID) * 2;
    move (JitMan, JitMan);

    DWORD_PTR vtbl;
    move (vtbl, JitMan);
    jitType = GetJitType (vtbl);
    
    // for EEJitManager
    if (jitType == JIT)
    {
        dwAddrString = JitMan + sizeof(DWORD_PTR)*7;
        DWORD_PTR HeapListAddr;
        move (HeapListAddr, dwAddrString);
        HeapList Hp;
        move (Hp, HeapListAddr);
        DWORD_PTR pCHdr = 0;
        while (1)
        {
            if (Hp.startAddress < IP && Hp.endAddress >= IP)
            {
                DWORD_PTR codeHead;
                FindHeader(Hp.pHdrMap, IP - Hp.mapBase, codeHead);
                if (codeHead == 0)
                {
                    _ASSERTE(!"fail in FindHeader\n");
                    return;
                }
                pCHdr = codeHead + Hp.mapBase;
                break;
            }
            if (Hp.hpNext == 0)
                break;
            move (Hp, Hp.hpNext);
        }
        if (pCHdr == 0)
        {
            return;
        }
        pCHdr += 2*sizeof(PVOID);
        move (methodDesc, pCHdr);

        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);

        if (!CallStatus)
        {
            methodDesc = 0;
            return;
        }

        dwAddr = vMD.m_CodeOrIL;

        // for EJit and Profiler, m_dwCodeOrIL has the address of a stub
        unsigned char ch;
        move (ch, dwAddr);
        if (ch == 0xe9)
        {
            int offsetValue;
            move (offsetValue, dwAddr + 1);
            dwAddr = dwAddr + 5 + offsetValue;
        }
        dwAddr = dwAddr - 3*sizeof(void*);
        move(gcinfoAddr, dwAddr);
    }
    /*
    else if (jitType == EJIT)
    {
        // First see if IP is the stub address

        if (pJMIT == 0)
            pJMIT = GetValueFromExpression ("MSCOREE!EconoJitManager__m_JittedMethodInfoHdr");

        DWORD_PTR vJMIT;
        // static for pJMIT moved to file static
        move (vJMIT, pJMIT);
#define PAGE_SIZE 0x1000
#define JMIT_BLOCK_SIZE PAGE_SIZE           // size of individual blocks of JMITs that are chained together                     
        while (vJMIT)
        {
            if (ControlC || (ControlC = IsInterrupt()))
                return;
            if (IP >= vJMIT && IP < vJMIT + JMIT_BLOCK_SIZE)
            {
                DWORD_PTR u1 = IP + 8;
                DWORD_PTR MD;
                move (u1, u1);
                if (u1 & 1)
                    MD = u1 & ~1;
                else
                    move (MD, u1);
                methodDesc = MD;
                return;
            }
            move (vJMIT, vJMIT);
        }
        
        signed low, mid, high;
        low = 0;
        static DWORD_PTR m_PcToMdMap_len = 0;
        static DWORD_PTR m_PcToMdMap = 0;
        if (m_PcToMdMap_len == 0)
        {
            m_PcToMdMap_len =
                GetValueFromExpression ("MSCOREE!EconoJitManager__m_PcToMdMap_len");
            m_PcToMdMap =
                GetValueFromExpression ("MSCOREE!EconoJitManager__m_PcToMdMap");
        }
        DWORD_PTR v_m_PcToMdMap_len;
        DWORD_PTR v_m_PcToMdMap;
        move (v_m_PcToMdMap_len, m_PcToMdMap_len);
        move (v_m_PcToMdMap, m_PcToMdMap);

        typedef struct {
            MethodDesc*     pMD;
            BYTE*           pCodeEnd;
        } PCToMDMap;
        high = (int)((v_m_PcToMdMap_len/ sizeof(PCToMDMap)) - 1);
        PCToMDMap vPCToMDMap;
        
        while (low < high) {
            if (ControlC || (ControlC = IsInterrupt()))
                return;
            mid = (low+high)/2;
            move (vPCToMDMap, v_m_PcToMdMap+mid*sizeof(PCToMDMap));
            if ( (unsigned) vPCToMDMap.pCodeEnd < IP ) {
                low = mid+1;
            }
            else {
                high = mid;
            }
        }
        move (vPCToMDMap, v_m_PcToMdMap+low*sizeof(PCToMDMap));
        methodDesc =  (DWORD_PTR)vPCToMDMap.pMD;
    }
    */
    else if (jitType == PJIT)
    {
        DWORD_PTR codeHead;
        FindHeader (RS.ptable, IP-RS.LowAddress, codeHead);
        DWORD_PTR pCHdr = codeHead + RS.LowAddress;
        CORCOMPILE_METHOD_HEADER head;
        head.Fill(pCHdr);
        methodDesc = (DWORD_PTR)head.methodDesc;
        gcinfoAddr = (DWORD_PTR)head.gcInfo;
    }
    return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Get the offset of curIP relative to the beginning of a MD method  *
*    considering if we JMP to the body of MD from m_dwCodeOrIL,        *  
*    e.g.  EJIT or Profiler                                            *
*                                                                      *
\**********************************************************************/
void GetMDIPOffset (DWORD_PTR curIP, MethodDesc *pMD, ULONG64 &offset)
{
    DWORD_PTR IPBegin = pMD->m_CodeOrIL;
    GetCalleeSite (pMD->m_CodeOrIL, IPBegin);
    
    // If we have ECall, Array ECall, special method
    int mdType = (pMD->m_wFlags & mdcClassification)
        >> mdcClassificationShift;
    if (mdType == mcECall || mdType == mcArray || mdType == mcEEImpl)
    {
        offset = -1;
        return;
    }
    
    CodeInfo codeInfo;
    CodeInfoForMethodDesc (*pMD, codeInfo);

    offset = curIP - IPBegin;
    if (!(curIP >= IPBegin && offset <= codeInfo.methodSize))
        offset = -1;
}

#define NPDW  (sizeof(DWORD_PTR)*2)
#define ADDR2POS(x) ((x) >> 5)
#define ADDR2OFFS(x) ((((x)&0x1f)>> 2)+1)
#define POS2SHIFTCOUNT(x) (28 - (((x)%NPDW)<< 2))
#define POSOFF2ADDR(pos, of) (((pos) << 5) + (((of)-1)<< 2))

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void FindHeader(DWORD_PTR pMap, DWORD_PTR addr, DWORD_PTR &codeHead)
{
    DWORD_PTR tmp;

    DWORD_PTR startPos = ADDR2POS(addr);    // align to 32byte buckets
                                            // ( == index into the array of nibbles)
    codeHead = 0;
    DWORD_PTR offset = ADDR2OFFS(addr);     // this is the offset inside the bucket + 1


    pMap += (startPos/NPDW)*sizeof(DWORD_PTR);        // points to the proper DWORD of the map
                                    // get DWORD and shift down our nibble

    move (tmp, pMap);
    tmp = tmp >> POS2SHIFTCOUNT(startPos);


    // don't allow equality in the next check (tmp&0xf == offset)
    // there are code blocks that terminate with a call instruction
    // (like call throwobject), i.e. their return address is
    // right behind the code block. If the memory manager allocates
    // heap blocks w/o gaps, we could find the next header in such
    // cases. Therefore we exclude the first DWORD of the header
    // from our search, but since we call this function for code
    // anyway (which starts at the end of the header) this is not
    // a problem.
    if ((tmp&0xf) && ((tmp&0xf) < offset) )
    {
        codeHead = POSOFF2ADDR(startPos, tmp&0xf);
        return;
    }

    // is there a header in the remainder of the DWORD ?
    tmp = tmp >> 4;

    if (tmp)
    {
        startPos--;
        while (!(tmp&0xf))
        {
            tmp = tmp >> 4;
            startPos--;
        }
        codeHead = POSOFF2ADDR(startPos, tmp&0xf);
        return;
    }

    // we skipped the remainder of the DWORD,
    // so we must set startPos to the highest position of
    // previous DWORD

    startPos = (startPos/NPDW) * NPDW - 1;

    // skip "headerless" DWORDS

    pMap -= sizeof(DWORD_PTR);
    move (tmp, pMap);
    while (!tmp)
    {
        startPos -= NPDW;
        pMap -= sizeof(DWORD_PTR);
        move (tmp, pMap);
    }
    
    while (!(tmp&0xf))
    {
        tmp = tmp >> 4;
        startPos--;
    }

    codeHead = POSOFF2ADDR(startPos, tmp&0xf);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    This function is called to find the name of a MethodDesc using metadata API.

void NameForMD (DWORD_PTR MDAddr, WCHAR *mdName)
{
    mdName[0] = L'\0';
    MethodDesc vMD;
    DWORD_PTR dwAddr = MDAddr;
    vMD.Fill (dwAddr);
    if (CallStatus)
    {
        if (g_pMDID->fIsDebugBuild)
        {
            DWORD_PTR EEClassAddr;
            move (EEClassAddr, vMD.m_pDebugEEClass);
            PrintString (EEClassAddr, FALSE, -1, mdName);
            wcscat (mdName, L".");
            WCHAR name[2048];
            name[0] = L'\0';
            PrintString ((DWORD_PTR)vMD.m_pszDebugMethodName, FALSE, -1, name);
            wcscat (mdName, name);
        }
        else
        {
            dwAddr = MDAddr;
            DWORD_PTR pMT;
            GetMethodTable(&vMD, dwAddr, pMT);
                    
            MethodTable MT;
            MT.Fill (pMT);
            WCHAR StringData[MAX_PATH+1];
            FileNameForMT (&MT, StringData);
            /*
            NameForToken(StringData,
                         (vMD.m_dwToken & 0x00ffffff)|0x06000000,
                         mdName);
            */
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of a MethodDesc.              *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/

BOOL IsMethodDesc(DWORD_PTR value, BOOL bPrint)
{
    MethodDesc vMD;
    DWORD_PTR dwAddr = value;
    vMD.Fill ( dwAddr);
    if (!CallStatus)
        return FALSE;
    DWORD_PTR methodAddr;
    GetMethodTable (&vMD, value, methodAddr);
    if (methodAddr == 0)
        return FALSE;
    if (IsMethodTable (methodAddr))
    {    
        if (bPrint)
        {
            WCHAR mdName[mdNameLen];
            NameForMD (value, mdName);
            //dprintf (" (stub for %S)", mdName);
        }
        return TRUE;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Return TRUE if value is the address of a MethodTable.             *  
*    We verify that MethodTable and EEClass are right.
*                                                                      *
\**********************************************************************/

BOOL IsMethodTable (DWORD_PTR value)
{
    MethodTable vMethTable;
    DWORD_PTR dwAddr = value;
    vMethTable.Fill (dwAddr);
    if (!CallStatus)
        return FALSE;
    EEClass eeclass;
    dwAddr = (DWORD_PTR)vMethTable.m_pEEClass;
    eeclass.Fill (dwAddr);
    if (!CallStatus)
        return FALSE;
    if ((DWORD_PTR)eeclass.m_pMethodTable == value)
    {
        return TRUE;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    Find the begin and end of the code for a managed function.        *  
*                                                                      *
\**********************************************************************/
void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &codeInfo, BOOL bSimple)
{
    codeInfo.IPBegin = 0;
    codeInfo.methodSize = 0;
    
    DWORD_PTR ip = MD.m_CodeOrIL;

    // for EJit and Profiler, m_dwCodeOrIL has the address of a stub
    unsigned char ch;
    move (ch, ip);
    if (ch == 0xe9)
    {
        int offsetValue;
        move (offsetValue, ip + 1);
        ip = ip + 5 + offsetValue;
    }
    
    DWORD_PTR methodDesc;
    IP2MethodDesc (ip, methodDesc, codeInfo.jitType, codeInfo.gcinfoAddr);
    if (!methodDesc || codeInfo.jitType == UNKNOWN)
    {
        //dprintf ("Not jitted code\n");
        return;
    }

    if (codeInfo.jitType == JIT || codeInfo.jitType == PJIT)
    {
        DWORD_PTR vAddr = codeInfo.gcinfoAddr;
        BYTE tmp[8];
        // We avoid using move here, because we do not want to return
        move(tmp, vAddr);
        decodeUnsigned(tmp, &codeInfo.methodSize);
        if (!bSimple)
        {
            // assume that GC encoding table is never more than
            // 40 + methodSize * 2
            int tableSize = 40 + codeInfo.methodSize*2;
            BYTE *table = (BYTE*) _alloca (tableSize);
            const BYTE *tableStart = table;
            memset (table, 0, tableSize);
            // We avoid using move here, because we do not want to return
            /*
            if (!SafeReadMemory(vAddr, table, tableSize, NULL))
            {
                //dprintf ("Could not read memory %x\n", vAddr);
                return;
            }
            */
            move_n(table, vAddr, tableSize);
        
            InfoHdr vheader;
            InfoHdr *header = &vheader;
            unsigned count;
        
            table += decodeUnsigned(table, &codeInfo.methodSize);

            BYTE headerEncoding = *table++;

            decodeHeaderFirst(headerEncoding, header);
            while (headerEncoding & 0x80)
            {
                headerEncoding = *table++;
                decodeHeaderNext(headerEncoding, header);
            }

            if (header->untrackedCnt == 0xffff)
            {
                table += decodeUnsigned(table, &count);
                header->untrackedCnt = count;
            }

            if (header->varPtrTableSize == 0xffff)
            {
                table += decodeUnsigned(table, &count);
                header->varPtrTableSize = count;
            }

            codeInfo.prologSize = header->prologSize;
            codeInfo.epilogStart = header->epilogSize;
            codeInfo.epilogCount = header->epilogCount;
            codeInfo.epilogAtEnd = header->epilogAtEnd;
            codeInfo.ediSaved = header->ediSaved;
            codeInfo.esiSaved = header->esiSaved;
            codeInfo.ebxSaved = header->ebxSaved;
            codeInfo.ebpSaved = header->ebpSaved;
            codeInfo.ebpFrame = header->ebpFrame;
            codeInfo.argCount = header->argCount * sizeof(void*);
            
            if  (header->epilogCount > 1 || (header->epilogCount != 0 &&
                                             header->epilogAtEnd == 0))
            {
                unsigned offs = 0;

                for (unsigned i = 0; i < header->epilogCount; i++)
                {
                    table += decodeUDelta(table, &offs, offs);
                    codeInfo.epilogStart = offs;
                    break;
                }
            }
            else
            {
                if  (header->epilogCount)
                    codeInfo.epilogStart = (unsigned char)(codeInfo.methodSize
                        - codeInfo.epilogStart);
            }
        }
    }
    
    codeInfo.IPBegin = ip;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the address of Methodtable for    *  
*    a given MethodDesc.                                               *
*                                                                      *
\**********************************************************************/
void GetMethodTable(MethodDesc* pMD, DWORD_PTR MDAddr, DWORD_PTR &methodTable)
{
    methodTable = 0;
    DWORD_PTR pMT = MDAddr + g_pMDID->cbMD_IndexOffset;
    char ch;
    move (ch, pMT);
    pMT = MDAddr + ch*MethodDesc::ALIGNMENT + g_pMDID->cbMD_SkewOffset;
    move (methodTable, pMT);
    return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the module name given a method    *  
*    table.  The name is stored in StringData.                         *
*                                                                      *
\**********************************************************************/
void FileNameForMT (MethodTable *pMT, WCHAR *fileName)
{
    fileName[0] = L'\0';
    DWORD_PTR addr = (DWORD_PTR)pMT->m_pModule;
    Module vModule;
    vModule.Fill (addr);
    FileNameForModule (&vModule, fileName);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the file name given a Module.     *  
*                                                                      *
\**********************************************************************/
void FileNameForModule (Module *pModule, WCHAR *fileName)
{
    DWORD_PTR dwAddr = (DWORD_PTR)pModule->m_file;
    if (dwAddr == 0)
        dwAddr = (DWORD_PTR)pModule->m_zapFile;
    PEFile vPEFile;
    vPEFile.Fill (dwAddr);
    FileNameForHandle (vPEFile.m_hModule, fileName);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to find the file name given a file        *  
*    handle.                                                           *
*                                                                      *
\**********************************************************************/
void FileNameForHandle (HANDLE handle, WCHAR *fileName)
{
    fileName[0] = L'\0';
    if (((UINT_PTR)handle & CORHANDLE_MASK) != 0)
    {
        handle = (HANDLE)(((UINT_PTR)handle) & ~CORHANDLE_MASK);
        DWORD_PTR addr = (DWORD_PTR)(((PBYTE) handle) - sizeof(LPSTR*));
        DWORD_PTR first;
        move (first, addr);
        if (first == 0)
        {
            return;
        }
        DWORD length = (DWORD)(((UINT_PTR) handle - (UINT_PTR)first) - sizeof(LPSTR*));
        char name[4*MAX_PATH+1];
        if (length > 4*MAX_PATH+1)
            length = 4*MAX_PATH+1;
        move_n(name, first, length);
        MultiByteToWideChar(CP_UTF8, 0, name, length, fileName, MAX_PATH);
    }
    else
    {
        //DllsName ((INT_PTR)handle, fileName);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**********************************************************************\
* Routine Description:                                                 *
*                                                                      *
*    This function is called to print a string beginning at strAddr.   *  
*    If buffer is non-NULL, print to buffer; Otherwise to screen.
*    If bWCHAR is true, treat the memory contents as WCHAR.            *
*    If length is not -1, it specifies the number of CHAR/WCHAR to be  *
*    read; Otherwise the string length is determined by NULL char.     *
*                                                                      *
\**********************************************************************/
// if buffer is not NULL, always convert to WCHAR
void PrintString (DWORD_PTR strAddr, BOOL bWCHAR, DWORD_PTR length, WCHAR *buffer)
{
    if (buffer)
        buffer[0] = L'\0';
    DWORD len = 0;
    char name[256];
    DWORD totallen = 0;
    int gap;
    if (bWCHAR)
    {
        gap = 2;
        if (length != -1)
            length *= 2;
    }
    else
    {
        gap = 1;
    }
    while (1)
    {
        ULONG readLen = 256;

        BOOL fRes;
        move_n_res(name, (strAddr + totallen), readLen, fRes);
        if (!fRes)
            return;
            
        // move might return
        // move (name, (BYTE*)strAddr + totallen);
        if (length == -1)
        {
            for (len = 0; len <= 256u-gap; len += gap)
                if (name[len] == '\0' && (!bWCHAR || name[len+1] == '\0'))
                    break;
        }
        else
            len = 256;
        if (len == 256)
        {
            len -= gap;
            for (int n = 0; n < gap; n ++)
                name[255-n] = '\0';
        }
        if (bWCHAR)
        {
            if (buffer)
            {
                wcscat (buffer, (WCHAR*)name);
            }
            /*
            else
                dprintf ("%S", name);
            */
        }
        else
        {
            if (buffer)
            {
                WCHAR temp[256];
                for (int n = 0; name[n] != '\0'; n ++)
                    temp[n] = name[n];
                temp[n] = L'\0';
                wcscat (buffer, temp);
            }
            /*
            else
                dprintf ("%s", name);
            */
        }
        totallen += len;
        if (length != -1)
        {
            if (totallen >= length)
            {
                break;
            }
        }
        else if (len < 255 || totallen > 1024)
        {
            break;
        }
    }
}

size_t FunctionType (size_t EIP)
{
     JitType jitType;
    DWORD_PTR methodDesc;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (EIP, methodDesc, jitType, gcinfoAddr);
    if (methodDesc) {
        return methodDesc;
    }
    else
        return 1;
}
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Return TRUE if we have printed something.

BOOL PrintCallInfo (DWORD_PTR vEBP, DWORD_PTR IP, BOOL bSymbolOnly)
{
    //char Symbol[1024];
    //char filename[MAX_PATH+1];
    WCHAR mdName[mdNameLen];
    ULONG64 Displacement;
    BOOL bOutput = FALSE;

    DWORD_PTR methodDesc = FunctionType (IP);

    /*
    JitType jitType;
    DWORD_PTR gcinfoAddr;
    IP2MethodDesc (IP, methodDesc, jitType, gcinfoAddr);
    */
    if (methodDesc > 1)
    {
        bOutput = TRUE;
        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        GetMDIPOffset (IP, &vMD, Displacement);
        NameForMD (methodDesc, mdName);
    }
    else
    {
        if (methodDesc == 0) {
        }
        else if (IsMethodDesc (IP, TRUE))
        {
            bOutput = TRUE;
            WCHAR mdName[mdNameLen];
            NameForMD (IP, mdName);
        }
        else if (IsMethodDesc (IP+5, TRUE)) {
            bOutput = TRUE;
            WCHAR mdName[mdNameLen];
            NameForMD (IP+5, mdName);
        }
    }
    return bOutput;
#if 0
    //char Symbol[1024];
    //char filename[MAX_PATH+1];
    WCHAR mdName[mdNameLen];
    ULONG64 Displacement;
    BOOL bOutput = FALSE;

    DWORD_PTR methodDesc;
    methodDesc = MDForCall (IP);

    if (methodDesc)
    {
        bOutput = TRUE;
        /*
        if (!bSymbolOnly)
            ExtOut ("%08x %08x ", vEBP, IP);
        */
        //ExtOut ("(MethodDesc %#x ", methodDesc);
        MethodDesc vMD;
        DWORD_PTR dwAddr = methodDesc;
        vMD.Fill (dwAddr);
        GetMDIPOffset (IP, &vMD, Displacement);
        /*
        if (Displacement != 0 && Displacement != -1)
            ExtOut ("+%#x ", Displacement);
        */
        NameForMD (methodDesc, mdName);
        //ExtOut ("%S)", mdName);
    }
    else
    {
        /*
        bOutput = TRUE;
        if (!bSymbolOnly)
            ExtOut ("%08x %08x ", vEBP, IP);
        HRESULT hr;
        hr = g_ExtSymbols->GetNameByOffset(IP, Symbol, 1024, NULL, &Displacement);
        if (SUCCEEDED(hr) && Symbol[0] != '\0')
        {
            ExtOut ("%s", Symbol);
            if (Displacement)
                ExtOut ("+%#x", Displacement);
            ULONG line;
            hr = g_ExtSymbols->GetLineByOffset (IP, &line, filename,
                                                MAX_PATH+1, NULL, NULL);
            if (SUCCEEDED (hr))
                ExtOut (" [%s:%d]", filename, line);
        }
        else if (!IsMethodDesc (IP, TRUE))
            ExtOut ("%08x", IP);
        */
        IsMethodDesc(IP, TRUE);
    }
    return bOutput;
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void StubCallInstrs::Fill(DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
    move(m_wTokenRemainder, dwStartAddr + g_pMDID->cbOffsetOf_SCI_m_wTokenRemainder);
    dwStartAddr += g_pMDID->cbSizeOfStubCallInstrs;
    CallStatus = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

void CORCOMPILE_METHOD_HEADER::Fill(DWORD_PTR &dwStartAddr)
{
    CallStatus = FALSE;
    memset (this, 0xCC, sizeof(*this));
    move(gcInfo, dwStartAddr + g_pMDID->cbOffsetOf_CCMH_gcInfo);
    move(methodDesc, dwStartAddr + g_pMDID->cbOffsetOf_CCMH_methodDesc);
    dwStartAddr += g_pMDID->cbSizeOfCORCOMPILE_METHOD_HEADER;
    CallStatus = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ndphlpr\makefile.inc ===
copy_target: $(TARGETNAME)
        copy $(TARGETNAME) $(TARGETPATH)
        copy $(TARGETNAME) $(TARGETCOMPLUS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ndphlpr\src\ndphlpr.asm ===
; ==++==
; 
;   Copyright (c) Microsoft Corporation.  All rights reserved.
; 
; ==--==
;*******************************************************************************
;
;  (C)
;
;  TITLE:       NDPHLPR.ASM
;
;  AUTHOR:      Tracy Sharpe
;               Frank Peschel-Gallee (GetThreadContext)
;               Rudi Martin (minor updates for NDP)
;
;  DATE:        18 April 1996
;
;*******************************************************************************

        .386p

        .xlist
        INCLUDE VMM.INC
        INCLUDE VWIN32.INC
        INCLUDE WINERROR.INC
        INCLUDE KS386.INC
        INCLUDE NDPHLPR.INC
        .list

Declare_Virtual_Device NDPHLPR, 1, 0, NDPHLPR_Control, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER

VxD_LOCKED_DATA_SEG
GetThreadFault  Exception_Handler_Struc <0, NDPHLPR_TRY_START, NDPHLPR_TRY_END, NDPHLPR_FaultHandler>
VxD_LOCKED_DATA_ENDS

;
;  NDPHLPR_Control
;
;  Standard system control procedure.
;

BeginProc NDPHLPR_Control, LOCKED

        cmp     eax, SYS_DYNAMIC_DEVICE_INIT
        je      NDPHLPR_DynamicDeviceInit
        cmp     eax, W32_DEVICEIOCONTROL
        je      NDPHLPR_DevIOCntl
        cmp     eax, SYS_DYNAMIC_DEVICE_EXIT
        je      NDPHLPR_DynamicDeviceExit
        clc
        ret

EndProc NDPHLPR_Control

;
;  NDPHLPR_DynamicDeviceInit
;

BeginProc NDPHLPR_DynamicDeviceInit, LOCKED

; Check VWIN32 version to determine offsets of some internal fields in the
; thread block.

        VxDCall VWIN32_Get_Version

        cmp     eax, 0104h
        jb      NDPHLPR_InstallGetThreadXcptHandler
        mov     R0HandleOffset, PTB_R0Handle_Memphis

NDPHLPR_InstallGetThreadXcptHandler:
        mov esi, OFFSET32 GetThreadFault
        VMMCall Install_Exception_Handler

        clc
        ret

EndProc NDPHLPR_DynamicDeviceInit

;
;  NDPHLPR_DynamicDeviceExit
;

BeginProc NDPHLPR_DynamicDeviceExit, LOCKED

        mov esi, OFFSET32 GetThreadFault
        VMMCall Remove_Exception_Handler

        clc
        ret

EndProc NDPHLPR_DynamicDeviceExit

PTB_R0Handle            equ     5Ch
PTB_R0Handle_Memphis    equ     54h

VxD_PAGEABLE_DATA_SEG

        PUBLIC  ObsfMask
ObsfMask        dd  0
        PUBLIC  FlatCs
FlatCs          dd  0
        PUBLIC  R0HandleOffset
R0HandleOffset  dd      PTB_R0Handle


CONTEXTSIZE textequ <CsSegSs+4>

VxD_PAGEABLE_DATA_ENDS

BeginProc NDPHLPR_FaultHandler, LOCKED
        mov     eax, ERROR_INVALID_PARAMETER
        ret
EndProc NDPHLPR_FaultHandler

;******************************************************************************
;
;  NDPHLPR_DevIOCntl
;
;
;   Entry: ESI = &DIOCParams
;   Exit:  CY on failure, NC on success
;
;==============================================================================

BeginProc NDPHLPR_DevIOCntl, W32
        mov     ebx, [esi].dwIoControlCode
        cmp     ebx, NDPHLPRX_GetThreadContext
        je      NDPHLPR_GetThreadContext
        cmp     ebx, NDPHLPRX_SetThreadContext
        je      NDPHLPR_SetThreadContext
        cmp     ebx, NDPHLPRX_Init
        je      NDPHLPR_InitMask
        cmp     ebx, DIOC_GETVERSION
        je      NDPHLPR_Return
        cmp     ebx, DIOC_CLOSEHANDLE
        jne     NDPHLPR_FaultHandler

NDPHLPR_Return:
        xor     eax, eax
        clc
        ret

NDPHLPR_TRY_START LABEL NEAR

;******************************************************************************
;
;  NDPHLPR_InitMask
;
;   Initialize the obsfucation value and store ring3 flat CS
;
;   Entry: ESI = &DIOCParams
;   Exit:  jumps to appropriate return lables
;
;==============================================================================

NDPHLPR_InitMask:
        cmp     [esi].cbInBuffer,4
        jne     NDPHLPR_FaultHandler
        mov     eax, [esi].lpvOutBuffer
        cmp     eax, 0
        je      NDPHLPR_FaultHandler
        cmp     [esi].cbOutBuffer, 4
        jne     NDPHLPR_FaultHandler
        mov     dword ptr [eax], NDPHLPRX_Version

        mov     ebx, [esi].lpvInBuffer
        cmp     ebx, 0
        je      NDPHLPR_FaultHandler

        cmp     ObsfMask, 0             ; have we been called before ?
        jnz     NDPHLPR_Return

        VxDCall VWIN32_GetCurrentProcessHandle
        xor     eax, [ebx]
        mov     ObsfMask, eax

        VMMCall Get_Cur_Thread_Handle   ; EDI = currentThreadHandle
        mov     edi, [edi].TCB_ClientPtr
        movzx   eax, [edi].Client_CS    ; assuming that the caller (Ring3)
                                        ; has "the" flat CS selector, we will
                                        ; compare against that CS
        mov     FlatCs, eax
        jmp     NDPHLPR_Return

;******************************************************************************
;
;  NDPHLPR_GetThreadContext
;
;   Try to get the thread's context, fail if thread is "terminating",
;   in nested execution or CS is not win32 flat selector.
;
;   Entry: ESI = &DIOCParams
;          esi.lpvInBuffer == esi.lpvOutBuffer == PNDPHLPR_CONTEXT
;   Exit:  jumps to appropriate return lables
;
;==============================================================================
NDPHLPR_GetThreadContext:
        cmp     [esi].cbInBuffer, CONTEXTSIZE+NDPHLPRX_ctx
        jb      NDPHLPR_FaultHandler
        mov     edi, [esi].lpvInBuffer
        cmp     edi, 0
        je      NDPHLPR_FaultHandler
        mov     ebx, dword ptr [esi].lpvOutBuffer
        cmp     ebx, 0
        jz      NDPHLPR_FaultHandler
        cmp     dword ptr [esi].cbOutBuffer, CONTEXTSIZE+NDPHLPRX_ctx
        jb      NDPHLPR_FaultHandler
        cmp     ebx, edi
        jne     NDPHLPR_FaultHandler
        cmp     dword ptr [esi].lpcbBytesReturned, 0
        jz      NDPHLPR_FaultHandler
        mov     ecx, dword ptr [edi+NDPHLPRX_threadId]    ; get ptdb
        xor     ecx, [ObsfMask]                      ; unscramble handle, ecx = ptdbx

        mov     edi, ecx
        add     edi, R0HandleOffset
        mov     edi, [edi]              ; get R0ThreadHandle
        or      edi, edi
        jz      NDPHLPR_FaultHandler

                                    ; are we in nested execution ?
                                    ; if yes, only CS:EIP, EFlags and SS:ESP
                                    ; are reliable, so no use in obtaining the
                                    ; context

        ; check if setcontext apc is still pending

        cmp     dword ptr [ebx+NDPHLPRX_data], ecx
        je      NDPHLPR_GotContext        ; YES, so we still have it in PNDPHLPR_CONTEXT


        cmp     [edi].TCB_PMLockStackCount, 0
        jnz     NDPHLPR_BadContext

        lea     eax, byte ptr [ebx+NDPHLPRX_ctx] ; get address of win32 context

        push    eax                 ; push context buffer
        push    edi                 ; push R0ThreadHandle
        VxDCall _VWIN32_Get_Thread_Context
        add     esp, 8              ; pop params
        or      eax, eax
        jz      NDPHLPR_FaultHandler
                                    ; now check if the context seems to be
                                    ; reasonable, i.e a win32 context
        mov     eax, FlatCs         ; cs on flat selector ?
        cmp     ax, [ebx+CsSegCs+NDPHLPRX_ctx]
        jne     NDPHLPR_BadContext
                                    ; now check if we are in virtual mode
        test    dword ptr [ebx+CsEFlags+NDPHLPRX_ctx], VM_MASK
        jnz     NDPHLPR_BadContext
NDPHLPR_GotContext:
        mov     edi, [esi].lpcbBytesReturned
        mov     dword ptr [edi], CONTEXTSIZE
        jmp     NDPHLPR_Return        ; no, v86 bit not set, we are fine


;******************************************************************************
;
;  NDPHLPR_SetThreadContext
;
;   Set a thread's context, quietly fail if thread is "terminating".
;   If thread is in nested execution, schedule a Kernel APC.
;
;   Entry: ESI = &DIOCParams
;          esi.lpvInBuffer == esi.lpvOutBuffer == PNDPHLPR_CONTEXT
;   Exit:  jumps to appropriate return lables
;
;==============================================================================
NDPHLPR_SetThreadContext:
        cmp     dword ptr [esi].cbInBuffer, CONTEXTSIZE+NDPHLPRX_ctx
        mov     ebx, dword ptr [esi].lpvInBuffer
        jb      NDPHLPR_FaultHandler
        cmp     ebx, 0
        jz      NDPHLPR_FaultHandler
        mov     edi, dword ptr [ebx+NDPHLPRX_threadId] ; get ptdb
        cmp     dword ptr [esi].lpcbBytesReturned, 0
        jz      NDPHLPR_FaultHandler
        xor     edi, [ObsfMask]         ; unscramble handle
        mov     ecx, edi                ; ecx = ptdb

        add     edi, R0HandleOffset
        mov     edi, [edi]              ; get R0ThreadHandle
        or      edi, edi
        jz      NDPHLPR_FaultHandler

                                    ; are we in nested execution ?
                                    ; if yes, only CS:EIP, EFlags and SS:ESP
                                    ; are reliable, so no use in obtaining the
                                    ; context
        cmp     [edi].TCB_PMLockStackCount, 0
        jnz     NDPHLPR_ScheduleEvent

        lea     eax, byte ptr [ebx+NDPHLPRX_ctx]     ; get win32 context
        push    eax                 ; push context buffer
        push    edi                 ; push R0ThreadHandle
        VxDCall _VWIN32_Set_Thread_Context
        add     esp, 8              ; pop params
        mov     dword ptr [ebx+NDPHLPRX_data], 0 ; mark context as "not pending"
        or      eax, eax
        jz      NDPHLPR_FaultHandler
        jmp     NDPHLPR_Return


NDPHLPR_TRY_END LABEL NEAR            ; end of "try" block

;  thread is in nested execution, schedule a KernelApc
;  IN: ebx = context, ecx = ptdbx, edi = R0ThreadHandle
NDPHLPR_ScheduleEvent:
        cmp     dword ptr [ebx+NDPHLPRX_data], ecx ; is apc already pending ?
        jz      NDPHLPR_Return               ; YES, we're done
        mov     dword ptr [ebx+NDPHLPRX_data], ecx ; mark context record as pending
        VxDCall _VWIN32_QueueKernelAPC, <offset32 NDPHLPR_SetContextApc, ebx, edi, 0>
        jnz     NDPHLPR_Return

NDPHLPR_BadContext:
        mov     eax, NDPHLPRX_BadContext
        ret

EndProc NDPHLPR_DevIOCntl

;******************************************************************************
;
;  NDPHLPR_SetContextApc
;
;   Try to get the threads context, fail if thread is "terminating",
;   in nested execution or CS is not win32 flat selector.
;
;   Entry: [ESP+4] == PNDPHLPR_CONTEXT
;   Exit:
;
;==============================================================================
; call back for kernel APCs
;
BeginProc NDPHLPR_SetContextApc, W32, SCALL, ESP
ArgVar pCtx, DWORD
        EnterProc
        SaveReg <esi, edi, ebx>
        mov     ebx, [pCtx]             ; esi = new context

        VMMcall Get_Cur_Thread_Handle   ; edi = R0ThreadHandle

        mov     esi, dword ptr [ebx+NDPHLPRX_data]   ; ebx = ptdb


;; ASSERT START
                ; still in nested execution ???
;        cmp     [edi].TCB_PMLockStackCount, 0
;        jz      @f
;        int     3
;@@:
;; ASSERT END

        ; is context still valid ?
        cmp     esi, 0                  ; is context record still marked as pending ?
        je      ApcDone                 ; NO, we are done
                                        ; YES, ebx = ptbx
        lea     eax, byte ptr [ebx+NDPHLPRX_ctx]
        push    eax
        push    edi
        VxDCall _VWIN32_Set_Thread_Context
        add     esp, 8
        mov     dword ptr [ebx+NDPHLPRX_data], 0 ; reset "pending"
;; ASSERT START
;        or      eax, eax
;        jnz     ApcDone
;        int     3
;; ASSERT END
ApcDone:
        RestoreReg <ebx, edi, esi>
        LeaveProc
        Return
EndProc NDPHLPR_SetContextApc

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ndphlpr\src\ndphlpr.inc ===
NDPHLPRX_Init                EQU     86427531H
NDPHLPRX_GetThreadContext    EQU     86421357H
NDPHLPRX_SetThreadContext    EQU     8642135AH
NDPHLPRX_BadContext          EQU     4647H
NDPHLPRX_Version             EQU     40H

NDPHLPRX_status              EQU     00H
NDPHLPRX_data                EQU     04H
NDPHLPRX_threadId            EQU     08H
NDPHLPRX_ctx                 EQU     0CH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\minidump\stacktrace.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: STACKTRACE.H
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================

#pragma once
#include "common.h"

#include <windows.h>
#include <windef.h>
#include "winwrap.h"
#include "minidumppriv.h"

enum JitType {UNKNOWN=0, JIT, EJIT, PJIT};
class MethodDesc;
class MethodTable;
class Module;
struct CodeInfo;

#define CORHANDLE_MASK 0x1

struct StackTraceFlags
{
    DWORD_PTR pbrStackTop;
    DWORD_PTR pbrStackBase;
    DWORD dwEip;
};

void CrawlStack(HANDLE hrThread, DWORD_PTR prStackBase);
void ReadThreads();
void StackTrace(StackTraceFlags stFlags);
void isRetAddr(DWORD_PTR retAddr, DWORD_PTR* whereCalled);
BOOL SaveCallInfo (DWORD_PTR vEBP, DWORD_PTR IP, StackTraceFlags& stFlags, BOOL bSymbolOnly);
DWORD_PTR MDForCall (DWORD_PTR callee);
void NextTerm (char *& ptr);
BOOL IsByRef (char *& ptr);
BOOL IsTermSep (char ch);
BOOL GetCalleeSite (DWORD_PTR IP, DWORD_PTR &IPCallee);
JitType GetJitType (DWORD_PTR Jit_vtbl);
void IP2MethodDesc (DWORD_PTR IP, DWORD_PTR &methodDesc, JitType &jitType, DWORD_PTR &gcinfoAddr);
void GetMDIPOffset (DWORD_PTR curIP, MethodDesc *pMD, ULONG64 &offset);
void FindHeader(DWORD_PTR pMap, DWORD_PTR addr, DWORD_PTR &codeHead);
void NameForMD (DWORD_PTR MDAddr, WCHAR *mdName);
BOOL IsMethodDesc (DWORD_PTR value, BOOL bPrint);
BOOL IsMethodTable (DWORD_PTR value);
void CodeInfoForMethodDesc (MethodDesc &MD, CodeInfo &codeInfo, BOOL bSimple = TRUE);
void GetMethodTable(MethodDesc* pMD, DWORD_PTR MDAddr, DWORD_PTR &methodTable);
void FileNameForMT (MethodTable *pMT, WCHAR *fileName);
void FileNameForModule (Module *pModule, WCHAR *fileName);
void FileNameForHandle (HANDLE handle, WCHAR *fileName);
void PrintString (DWORD_PTR strAddr, BOOL bWCHAR, DWORD_PTR length, WCHAR *buffer);
BOOL PrintCallInfo (DWORD_PTR vEBP, DWORD_PTR IP, BOOL bSymbolOnly);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ndphlpr\src\ks386.inc ===
;
; Process State Enumerated Type Values
;

ProcessInMemory equ 00H
ProcessOutOfMemory equ 01H
ProcessInTransition equ 02H

;
; Thread State Enumerated Type Values
;

Initialized equ 00H
Ready equ 01H
Running equ 02H
Standby equ 03H
Terminated equ 04H
Waiting equ 05H

;
; Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00H
WrEventPair equ 0EH
WaitAny equ 01H
WaitAll equ 00H

;
; Apc State Structure Offset Definitions
;

AsApcListHead equ 00H
AsProcess equ 010H
AsKernelApcInProgress equ 014H
AsKernelApcPending equ 015H
AsUserApcPending equ 016H

;
; Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 01H
DATA_BUS_ERROR equ 02EH
DATA_COHERENCY_EXCEPTION equ 055H
HAL1_INITIALIZATION_FAILED equ 061H
INSTRUCTION_BUS_ERROR equ 02FH
INSTRUCTION_COHERENCY_EXCEPTION equ 056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 03DH
INTERRUPT_UNWIND_ATTEMPTED equ 03CH
INVALID_AFFINITY_SET equ 03H
INVALID_DATA_ACCESS_TRAP equ 04H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 04AH
IRQL_NOT_LESS_OR_EQUAL equ 0AH
KMODE_EXCEPTION_NOT_HANDLED equ 01EH
NMI_HARDWARE_FAILURE equ 080H
NO_USER_MODE_CONTEXT equ 0EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 049H
PANIC_STACK_SWITCH equ 02BH
SPIN_LOCK_INIT_FAILURE equ 081H
SYSTEM_EXIT_OWNED_MUTEX equ 039H
SYSTEM_SERVICE_EXCEPTION equ 03BH
SYSTEM_UNWIND_PREVIOUS_USER equ 03AH
TRAP_CAUSE_UNKNOWN equ 012H
UNEXPECTED_KERNEL_MODE_TRAP equ 07FH

;
; Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 01H

;
; Client Id Structure Offset Definitions
;

CidUniqueProcess equ 00H
CidUniqueThread equ 04H

;
; Critical Section Structure Offset Definitions
;

CsDebugInfo equ 00H
CsLockCount equ 04H
CsRecursionCount equ 08H
CsOwningThread equ 0CH
CsLockSemaphore equ 010H

;
; Critical Section Debug Information Structure Offset Definitions
;

CsType equ 00H
CsCreatorBackTraceIndex equ 02H
CsCriticalSection equ 04H
CsProcessLocksList equ 08H
CsEntryCount equ 010H
CsContentionCount equ 014H

;
; Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 01H
EXCEPTION_UNWINDING equ 02H
EXCEPTION_EXIT_UNWIND equ 04H
EXCEPTION_STACK_INVALID equ 08H
EXCEPTION_NESTED_CALL equ 010H
EXCEPTION_TARGET_UNWIND equ 020H
EXCEPTION_COLLIDED_UNWIND equ 040H
EXCEPTION_UNWIND equ 066H
EXCEPTION_EXECUTE_HANDLER equ 01H
EXCEPTION_CONTINUE_SEARCH equ 00H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH
EXCEPTION_CHAIN_END equ 0FFFFFFFFH

ExceptionContinueExecution equ 00H
ExceptionContinueSearch equ 01H
ExceptionNestedException equ 02H
ExceptionCollidedUnwind equ 03H

ErExceptionCode equ 00H
ErExceptionFlags equ 04H
ErExceptionRecord equ 08H
ErExceptionAddress equ 0CH
ErNumberParameters equ 010H
ErExceptionInformation equ 014H
ExceptionRecordLength equ 050H

;
; Fast Mutex Structure Offset Definitions
;

FmCount equ 00H
FmOwner equ 04H
FmContention equ 08H
FmEvent equ 0CH
FmOldIrql equ 01CH

;
; Interrupt Priority Request Level Definitions
;

APC_LEVEL equ 01H
DISPATCH_LEVEL equ 02H
CLOCK1_LEVEL equ 01CH
CLOCK2_LEVEL equ 01CH
IPI_LEVEL equ 01DH
POWER_LEVEL equ 01EH
PROFILE_LEVEL equ 01BH
HIGH_LEVEL equ 01FH
SYNCH_LEVEL equ 01CH

;
; Large Integer Structure Offset Definitions
;

LiLowPart equ 00H
LiHighPart equ 04H

;
; List Entry Structure Offset Definitions
;

LsFlink equ 00H
LsBlink equ 04H

;
; String Structure Offset Definitions
;

StrLength equ 00H
StrMaximumLength equ 02H
StrBuffer equ 04H

;
; System Time Structure Offset Definitions
;

StLowTime equ 00H
StHigh1Time equ 04H
StHigh2Time equ 08H

;
; Time Structure Offset Definitions
;

TmLowTime equ 00H
TmHighTime equ 04H

;
; Thread Switch Counter Offset Definitions
;

TwFindAny equ 00H
TwFindIdeal equ 04H
TwFindLast equ 08H
TwIdleAny equ 0CH
TwIdleCurrent equ 010H
TwIdleIdeal equ 014H
TwIdleLast equ 018H
TwPreemptAny equ 01CH
TwPreemptCurrent equ 020H
TwPreemptLast equ 024H
TwSwitchToIdle equ 028H

;
; Status Code Definitions
;

STATUS_ACCESS_VIOLATION equ 0C0000005H
STATUS_ARRAY_BOUNDS_EXCEEDED equ 0C000008CH
STATUS_BAD_COMPRESSION_BUFFER equ 0C0000242H
STATUS_BREAKPOINT equ 080000003H
STATUS_DATATYPE_MISALIGNMENT equ 080000002H
STATUS_FLOAT_DENORMAL_OPERAND equ 0C000008DH
STATUS_FLOAT_DIVIDE_BY_ZERO equ 0C000008EH
STATUS_FLOAT_INEXACT_RESULT equ 0C000008FH
STATUS_FLOAT_INVALID_OPERATION equ 0C0000090H
STATUS_FLOAT_OVERFLOW equ 0C0000091H
STATUS_FLOAT_STACK_CHECK equ 0C0000092H
STATUS_FLOAT_UNDERFLOW equ 0C0000093H
STATUS_GUARD_PAGE_VIOLATION equ 080000001H
STATUS_ILLEGAL_FLOAT_CONTEXT equ 0C000014AH
STATUS_ILLEGAL_INSTRUCTION equ 0C000001DH
STATUS_INSTRUCTION_MISALIGNMENT equ 0C00000AAH
STATUS_INVALID_HANDLE equ 0C0000008H
STATUS_INVALID_LOCK_SEQUENCE equ 0C000001EH
STATUS_INVALID_OWNER equ 0C000005AH
STATUS_INVALID_PARAMETER_1 equ 0C00000EFH
STATUS_INVALID_SYSTEM_SERVICE equ 0C000001CH
STATUS_INTEGER_DIVIDE_BY_ZERO equ 0C0000094H
STATUS_INTEGER_OVERFLOW equ 0C0000095H
STATUS_IN_PAGE_ERROR equ 0C0000006H
STATUS_KERNEL_APC equ 0100H
STATUS_LONGJUMP equ 080000026H
STATUS_NO_CALLBACK_ACTIVE equ 0C0000258H
STATUS_NO_EVENT_PAIR equ 0C000014EH
STATUS_PRIVILEGED_INSTRUCTION equ 0C0000096H
STATUS_SINGLE_STEP equ 080000004H
STATUS_STACK_OVERFLOW equ 0C00000FDH
STATUS_SUCCESS equ 00H
STATUS_THREAD_IS_TERMINATING equ 0C000004BH
STATUS_TIMEOUT equ 0102H
STATUS_UNWIND equ 0C0000027H
STATUS_WAKE_SYSTEM_DEBUGGER equ 080000007H

;
; APC Object Structure Offset Definitions
;

ApType equ 00H
ApSize equ 02H
ApThread equ 08H
ApApcListEntry equ 0CH
ApKernelRoutine equ 014H
ApRundownRoutine equ 018H
ApNormalRoutine equ 01CH
ApNormalContext equ 020H
ApSystemArgument1 equ 024H
ApSystemArgument2 equ 028H
ApApcStateIndex equ 02CH
ApApcMode equ 02DH
ApInserted equ 02EH
ApcObjectLength equ 030H

;
; DPC object Structure Offset Definitions
;

DpType equ 00H
DpNumber equ 02H
DpImportance equ 03H
DpDpcListEntry equ 04H
DpDeferredRoutine equ 0CH
DpDeferredContext equ 010H
DpSystemArgument1 equ 014H
DpSystemArgument2 equ 018H
DpLock equ 01CH
DpcObjectLength equ 020H

;
; Device Queue Object Structure Offset Definitions
;

DvType equ 00H
DvSize equ 02H
DvDeviceListHead equ 04H
DvSpinLock equ 0CH
DvBusy equ 010H
DeviceQueueObjectLength equ 014H

;
; Device Queue Entry Structure Offset Definitions
;

DeDeviceListEntry equ 00H
DeSortKey equ 08H
DeInserted equ 0CH
DeviceQueueEntryLength equ 010H

;
; Event Object Structure Offset Definitions
;

EvType equ 00H
EvSize equ 02H
EvSignalState equ 04H
EvWaitListHead equ 08H
EventObjectLength equ 010H

;
; Event Pair Object Structure Offset Definitions
;

EpType equ 00H
EpSize equ 02H
EpEventLow equ 04H
EpEventHigh equ 014H

;
; Interrupt Object Structure Offset Definitions
;

InLevelSensitive equ 00H
InLatched equ 01H

InType equ 00H
InSize equ 02H
InInterruptListEntry equ 04H
InServiceRoutine equ 0CH
InServiceContext equ 010H
InSpinLock equ 014H
InActualLock equ 01CH
InDispatchAddress equ 020H
InVector equ 024H
InIrql equ 028H
InSynchronizeIrql equ 029H
InFloatingSave equ 02AH
InConnected equ 02BH
InNumber equ 02CH
InMode equ 030H
InShareVector equ 02DH
InDispatchCode equ 03CH
InterruptObjectLength equ 01E4H

NORMAL_DISPATCH_LENGTH equ 01A8H
DISPATCH_LENGTH equ 01A8H

;
; Process Object Structure Offset Definitions
;

PrType equ 00H
PrSize equ 02H
PrSignalState equ 04H
PrProfileListHead equ 010H
PrDirectoryTableBase equ 018H
PrLdtDescriptor equ 020H
PrInt21Descriptor equ 028H
PrIopmOffset equ 030H
PrIopl equ 032H
PrVdmFlag equ 033H
PrActiveProcessors equ 034H
PrKernelTime equ 038H
PrUserTime equ 03CH
PrReadyListHead equ 040H
PrSwapListEntry equ 048H
PrThreadListHead equ 050H
PrProcessLock equ 058H
PrAffinity equ 05CH
PrStackCount equ 060H
PrBasePriority equ 062H
PrThreadQuantum equ 063H
PrAutoAlignment equ 064H
PrState equ 065H
ProcessObjectLength equ 070H
ExtendedProcessObjectLength equ 0200H

;
; Profile Object Structure Offset Definitions
;

PfType equ 00H
PfSize equ 02H
PfProfileListEntry equ 04H
PfProcess equ 0CH
PfRangeBase equ 010H
PfRangeLimit equ 014H
PfBucketShift equ 018H
PfBuffer equ 01CH
PfSegment equ 020H
PfAffinity equ 024H
PfSource equ 028H
PfStarted equ 02AH
ProfileObjectLength equ 02CH

;
; Queue Object Structure Offset Definitions
;

QuType equ 00H
QuSize equ 02H
QuSignalState equ 04H
QuEntryListHead equ 010H
QuCurrentCount equ 018H
QuMaximumCount equ 01CH
QuThreadListHead equ 020H
QueueObjectLength equ 028H

;
; Thread Object Structure Offset Definitions
;

EeKernelEventPair equ 00H
EtCid equ 01E0H
EtEventPair equ 0224H
EtPerformanceCountLow equ 0204H
EtPerformanceCountHigh equ 023CH
EtEthreadLength equ 0240H

ThType equ 00H
ThSize equ 02H
ThSignalState equ 04H
ThMutantListHead equ 010H
ThInitialStack equ 018H
ThStackLimit equ 01CH
ThTeb equ 020H
ThTlsArray equ 024H
ThKernelStack equ 028H
ThDebugActive equ 02CH
ThState equ 02DH
ThAlerted equ 02EH
ThIopl equ 030H
ThNpxState equ 031H
ThSaturation equ 032H
ThPriority equ 033H
ThApcState equ 034H
ThContextSwitches equ 04CH
ThWaitStatus equ 050H
ThWaitIrql equ 054H
ThWaitMode equ 055H
ThWaitNext equ 056H
ThWaitReason equ 057H
ThWaitBlockList equ 058H
ThWaitListEntry equ 05CH
ThWaitTime equ 064H
ThBasePriority equ 068H
ThDecrementCount equ 069H
ThPriorityDecrement equ 06AH
ThQuantum equ 06BH
ThWaitBlock equ 06CH
ThKernelApcDisable equ 0D0H
ThSection equ 0D4H
ThSystemView equ 0D8H
ThThreadView equ 0DCH
ThQueue equ 0E0H
ThApcQueueLock equ 0E4H
ThTimer equ 0E8H
ThQueueListEntry equ 0110H
ThAffinity equ 0118H
ThPreempted equ 011CH
ThProcessReadyQueue equ 011DH
ThKernelStackResident equ 011EH
ThNextProcessor equ 011FH
ThCallbackStack equ 0120H
ThWin32Thread equ 0124H
ThTrapFrame equ 0128H
ThApcStatePointer equ 012CH
ThPreviousMode equ 0137H
ThEnableStackSwap equ 0134H
ThLargeStack equ 0135H
ThKernelTime equ 0138H
ThUserTime equ 013CH
ThSavedApcState equ 0140H
ThAlertable equ 0158H
ThApcStateIndex equ 0159H
ThApcQueueable equ 015AH
ThAutoAlignment equ 015BH
ThStackBase equ 015CH
ThSuspendApc equ 0160H
ThSuspendSemaphore equ 0190H
ThThreadListEntry equ 01A4H
ThFreezeCount equ 01ACH
ThSuspendCount equ 01ADH
ThIdealProcessor equ 01AEH
ThDisableBoost equ 01AFH
ThreadObjectLength equ 01B0H
ExtendedThreadObjectLength equ 0240H

EVENT_WAIT_BLOCK_OFFSET equ 09CH
NPX_STATE_NOT_LOADED equ 0AH
NPX_STATE_LOADED equ 00H

;
; Timer object Structure Offset Definitions
;

TiType equ 00H
TiSize equ 02H
TiInserted equ 03H
TiSignalState equ 04H
TiDueTime equ 010H
TiTimerListEntry equ 018H
TiDpc equ 020H
TiPeriod equ 024H
TimerObjectLength equ 028H

TIMER_TABLE_SIZE equ 080H

;
; Wait Block Structure Offset Definitions
;

WbWaitListEntry equ 00H
WbThread equ 08H
WbObject equ 0CH
WbNextWaitBlock equ 010H
WbWaitKey equ 014H
WbWaitType equ 016H

;
; Fiber Structure Offset Definitions
;

FbFiberData equ 00H
FbExceptionList equ 04H
FbStackBase equ 08H
FbStackLimit equ 0CH
FbDeallocationStack equ 010H
FbFiberContext equ 014H

;
; Process Environment Block Structure Offset Definitions
;

PeKernelCallbackTable equ 02CH

;
; Thread Environment Block Structure Offset Definitions
;

TeStackBase equ 04H
TeStackLimit equ 08H
TeFiberData equ 010H
TeEnvironmentPointer equ 01CH
TeClientId equ 020H
TeActiveRpcHandle equ 028H
TeThreadLocalStoragePointer equ 02CH
TePeb equ 030H
TeCsrClientThread equ 03CH
TeSoftFpcr equ 0C8H
TeGdiClientPID equ 06F4H
TeGdiClientTID equ 06F8H
TeGdiThreadLocalInfo equ 06FCH
TeglDispatchTable equ 0714H
TeglSectionInfo equ 0BE0H
TeglSection equ 0BE4H
TeglTable equ 0BE8H
TeglCurrentRC equ 0BECH
TeglContext equ 0BF0H
TeDeallocationStack equ 0E0CH
TeGdiBatchCount equ 0F70H
TeInstrumentation equ 0F2CH

; 
;  Apc Record Structure Offset Definitions
; 

ArNormalRoutine equ 00H
ArNormalContext equ 04H
ArSystemArgument1 equ 08H
ArSystemArgument2 equ 0CH
ApcRecordLength equ 010H


; 
;  Processor Control Registers Structure Offset Definitions
; 

KI_BEGIN_KERNEL_RESERVED equ 0FFDF0000H
ifdef NT_UP
    P0PCRADDRESS equ 0FFDFF000H
    PCR equ ds:[0FFDFF000H]
else
    PCR equ fs:
endif

PcExceptionList equ 00H
PcInitialStack equ 04H
PcStackLimit equ 08H
PcSelfPcr equ 01CH
PcPrcb equ 020H
PcTeb equ 018H
PcIrql equ 024H
PcIRR equ 028H
PcIrrActive equ 02CH
PcIDR equ 030H
PcIdt equ 038H
PcGdt equ 03CH
PcTss equ 040H
PcDebugActive equ 050H
PcNumber equ 051H
PcVdmAlert equ 052H
PcSetMember equ 048H
PcStallScaleFactor equ 04CH
PcHal equ 094H
PcKernel equ 054H
PcPrcbData equ 0120H
ProcessorControlRegisterLength equ 0678H
TebPeb equ 030H
PebBeingDebugged equ 02H
PebKernelCallbackTable equ 02CH

;
;   Defines for user shared data
;
USER_SHARED_DATA equ 0FFDF0000H
MM_SHARED_USER_DATA_VA equ 07FFE0000H
USERDATA equ ds:[0FFDF0000H]
UsTickCountLow equ 00H
UsTickCountMultiplier equ 04H
UsInterruptTime equ 08H
UsSystemTime equ 014H

;
;  Tss Structure Offset Definitions
;

TssEsp0 equ 04H
TssCR3 equ 01CH
TssIoMapBase equ 066H
TssIoMaps equ 068H
TssLength equ 020ACH

;
;  Gdt Descriptor Offset Definitions
;

KGDT_R3_DATA equ 020H
KGDT_R3_CODE equ 018H
KGDT_R0_CODE equ 08H
KGDT_R0_DATA equ 010H
KGDT_R0_PCR equ 030H
KGDT_STACK16 equ 0F8H
KGDT_CODE16 equ 0F0H
KGDT_TSS equ 028H
KGDT_R3_TEB equ 038H
KGDT_DF_TSS equ 050H
KGDT_NMI_TSS equ 058H
KGDT_LDT equ 048H

;
;  GdtEntry Offset Definitions
;

KgdtBaseLow equ 02H
KgdtBaseMid equ 04H
KgdtBaseHi equ 07H
KgdtLimitHi equ 06H
KgdtLimitLow equ 00H


;
; Processor Block Structure Offset Definitions
;

PbCurrentThread equ 04H
PbNextThread equ 08H
PbIdleThread equ 0CH
PbNumber equ 010H
PbSetMember equ 014H
PbCpuID equ 019H
PbCpuType equ 018H
PbCpuStep equ 01AH
PbHalReserved equ 017CH
PbProcessorState equ 01CH
PbNpxThread equ 01BCH
PbInterruptCount equ 01C0H
PbKernelTime equ 01C4H
PbUserTime equ 01C8H
PbDpcTime equ 01CCH
PbInterruptTime equ 01D0H
PbApcBypassCount equ 01D4H
PbDpcBypassCount equ 01D8H
PbAdjustDpcThreshold equ 01DCH
PbThreadStartCount equ 01F4H
PbAlignmentFixupCount equ 021CH
PbContextSwitches equ 0220H
PbDcacheFlushCount equ 0224H
PbExceptionDispatchCount equ 0228H
PbFirstLevelTbFills equ 022CH
PbFloatingEmulationCount equ 0230H
PbIcacheFlushCount equ 0234H
PbSecondLevelTbFills equ 0238H
PbSystemCalls equ 023CH
PbSmallNPagedPoolLookasideLists equ 0280H
PbSmallPagedPoolLookasideLists equ 0380H
PbCurrentPacket equ 0480H
PbTargetSet equ 048CH
PbWorkerRoutine equ 0490H
PbIpiFrozen equ 0494H
PbRequestSummary equ 04A0H
PbSignalDone equ 04A4H
PbIpiFrame equ 04ACH
PbDpcInterruptRequested equ 04C0H
PbMaximumDpcQueueDepth equ 04D0H
PbMinimumDpcRate equ 04D4H
PbDpcListHead equ 04E0H
PbDpcQueueDepth equ 04E8H
PbDpcRoutineActive equ 04ECH
PbDpcCount equ 04F0H
PbDpcLastCount equ 04F4H
PbDpcRequestRate equ 04F8H
PbDpcLock equ 0528H
PbSkipTick equ 052CH
PbQuantumEnd equ 0550H
ProcessorBlockLength equ 0560H

;
; Immediate Interprocessor Command Definitions
;

IPI_APC equ 01H
IPI_DPC equ 02H
IPI_FREEZE equ 04H
IPI_PACKET_READY equ 08H
; 
;  Thread Environment Block Structure Offset Definitions
; 

TbExceptionList equ 00H
TbStackBase equ 04H
TbStackLimit equ 08H
TbEnvironmentPointer equ 01CH
TbVersion equ 010H
TbFiberData equ 010H
TbArbitraryUserPointer equ 014H
TbClientId equ 020H
TbThreadLocalStoragePointer equ 02CH
TbCountOfOwnedCriticalSections equ 038H
TbSystemReserved1 equ 0CCH
TbSystemReserved2 equ 01D4H
TbVdm equ 0F18H
TbCsrClientThread equ 03CH
TbGdiClientPID equ 06F4H
TbGdiClientTID equ 06F8H
TbGdiThreadLocalInfo equ 06FCH
TbglDispatchTable equ 0714H
TbglSectionInfo equ 0BE0H
TbglSection equ 0BE4H
TbglTable equ 0BE8H
TbglCurrentRC equ 0BECH
TbglContext equ 0BF0H
TbWin32ClientInfo equ 044H
TbWOW32Reserved equ 0C0H
TbWin32ThreadInfo equ 040H
TbSpare1 equ 01A4H
TbExceptionCode equ 01A8H
TbDeallocationStack equ 0E0CH
TbGdiBatchCount equ 0F70H
;
;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0AH
TfMinute equ 08H
TfHour equ 06H
TfWeekday equ 0EH
TfDay equ 04H
TfMonth equ 02H
TfYear equ 00H
TfMilliseconds equ 0CH

; 
;  constants for system irql and IDT vector conversion
; 

MAXIMUM_IDTVECTOR equ 0FFH
MAXIMUM_PRIMARY_VECTOR equ 0FFH
PRIMARY_VECTOR_BASE equ 030H
RPL_MASK equ 03H
MODE_MASK equ 01H

; 
;  Flags in the CR0 register
; 

CR0_PG equ 080000000H
CR0_ET equ 010H
CR0_TS equ 08H
CR0_EM equ 04H
CR0_MP equ 02H
CR0_PE equ 01H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 020H

; 
;  Flags in the CR4 register
; 

CR4_VME equ 01H
CR4_PVI equ 02H
CR4_TSD equ 04H
CR4_DE equ 08H
CR4_PSE equ 010H
CR4_PAE equ 020H
CR4_MCE equ 040H
CR4_PGE equ 080H
; 
;  Miscellaneous Definitions
; 

MAXIMUM_PROCESSORS equ 020H
INITIAL_STALL_COUNT equ 064H
IRQL_NOT_GREATER_OR_EQUAL equ 09H
IRQL_NOT_LESS_OR_EQUAL equ 0AH
BASE_PRIORITY_THRESHOLD equ 08H
EVENT_PAIR_INCREMENT equ 01H
LOW_REALTIME_PRIORITY equ 010H
BlackHole equ 0FFFFA000H
KERNEL_LARGE_STACK_COMMIT equ 03000H
KERNEL_STACK_SIZE equ 03000H
DOUBLE_FAULT_STACK_SIZE equ 01000H
EFLAG_SELECT equ 0C000H
BREAKPOINT_BREAK  equ 00H
IPI_FREEZE equ 04H
CLOCK_QUANTUM_DECREMENT equ 03H
READY_SKIP_QUANTUM equ 02H
THREAD_QUANTUM equ 06H
WAIT_QUANTUM_DECREMENT equ 01H
ROUND_TRIP_DECREMENT_COUNT equ 010H

; 
;  Trap Frame Offset Definitions and Length
; 

TsExceptionList equ 04CH
TsPreviousPreviousMode equ 048H
TsSegGs equ 030H
TsSegFs equ 050H
TsSegEs equ 034H
TsSegDs equ 038H
TsEdi equ 054H
TsEsi equ 058H
TsEbp equ 060H
TsEbx equ 05CH
TsEdx equ 03CH
TsEcx equ 040H
TsEax equ 044H
TsErrCode equ 064H
TsEip equ 068H
TsSegCs equ 06CH
TsEflags equ 070H
TsHardwareEsp equ 074H
TsHardwareSegSs equ 078H
TsTempSegCs equ 010H
TsTempEsp equ 014H
TsDbgEbp equ 00H
TsDbgEip equ 04H
TsDbgArgMark equ 08H
TsDbgArgPointer equ 0CH
TsDr0 equ 018H
TsDr1 equ 01CH
TsDr2 equ 020H
TsDr3 equ 024H
TsDr6 equ 028H
TsDr7 equ 02CH
TsV86Es equ 07CH
TsV86Ds equ 080H
TsV86Fs equ 084H
TsV86Gs equ 088H
KTRAP_FRAME_LENGTH equ 08CH
KTRAP_FRAME_ALIGN equ 04H
FRAME_EDITED equ 0FFF8H
EFLAGS_ALIGN_CHECK equ 040000H
EFLAGS_V86_MASK equ 020000H
EFLAGS_INTERRUPT_MASK equ 0200H
EFLAGS_VIF equ 080000H
EFLAGS_VIP equ 0100000H
EFLAGS_USER_SANITIZE equ 01E0DD7H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010007H
CONTEXT_DEBUG_REGISTERS equ 010010H
CONTEXT_CONTROL equ 010001H
CONTEXT_FLOATING_POINT equ 010008H
CONTEXT_INTEGER equ 010002H
CONTEXT_SEGMENTS equ 010004H

CsContextFlags equ 00H
CsFloatSave equ 01CH
CsSegGs equ 08CH
CsSegFs equ 090H
CsSegEs equ 094H
CsSegDs equ 098H
CsEdi equ 09CH
CsEsi equ 0A0H
CsEbp equ 0B4H
CsEbx equ 0A4H
CsEdx equ 0A8H
CsEcx equ 0ACH
CsEax equ 0B0H
CsEip equ 0B8H
CsSegCs equ 0BCH
CsEflags equ 0C0H
CsEsp equ 0C4H
CsSegSs equ 0C8H
CsDr0 equ 04H
CsDr1 equ 08H
CsDr2 equ 0CH
CsDr3 equ 010H
CsDr6 equ 014H
CsDr7 equ 018H
ContextFrameLength equ 0D0H
DR6_LEGAL equ 0E00FH
DR7_LEGAL equ 0FFFF0155H
DR7_ACTIVE equ 055H
ErrHandler equ 04H
ErrNext equ 00H

;
;  Floating save area field offset definitions
;
FpControlWord   equ 00H
FpStatusWord    equ 04H
FpTagWord       equ 08H
FpErrorOffset   equ 0CH
FpErrorSelector equ 010H
FpDataOffset    equ 014H
FpDataSelector  equ 018H
FpRegisterArea  equ 01CH
FpCr0NpxState   equ 06CH

NPX_FRAME_LENGTH equ 070H
;
;  Processor State Frame Offset Definitions
;

PsContextFrame equ 00H
PsSpecialRegisters equ 0CCH
SrCr0 equ 00H
SrCr2 equ 04H
SrCr3 equ 08H
SrCr4 equ 0CH
SrKernelDr0 equ 010H
SrKernelDr1 equ 014H
SrKernelDr2 equ 018H
SrKernelDr3 equ 01CH
SrKernelDr6 equ 020H
SrKernelDr7 equ 024H
SrGdtr equ 02AH
SrIdtr equ 032H
SrTr equ 038H
SrLdtr equ 03AH
ProcessorStateLength equ 0120H
;
;  EPROCESS
;

EpDebugPort equ 0FCH

;
;  NTDDK Resource
;

RsOwnerThreads equ 08H
RsOwnerCounts equ 0CH
RsTableSize equ 010H
RsActiveCount equ 012H
RsFlag equ 014H
RsInitialOwnerThreads equ 01CH
RsOwnedExclusive equ 080H
;
;  Machine type definitions (Temporarily)
;

MACHINE_TYPE_ISA equ 00H
MACHINE_TYPE_EISA equ 01H
MACHINE_TYPE_MCA equ 02H
;
;  KeFeatureBits defines
;

KF_V86_VIS equ 01H
KF_RDTSC equ 02H
KF_CR4 equ 04H
KF_GLOBAL_PAGE equ 010H
KF_LARGE_PAGE equ 020H
KF_CMPXCHG8B equ 080H
;
;  LoaderParameterBlock offsets relative to base
;

LpbLoadOrderListHead equ 00H
LpbMemoryDescriptorListHead equ 08H
LpbKernelStack equ 018H
LpbPrcb equ 01CH
LpbProcess equ 020H
LpbThread equ 024H
LpbI386 equ 05CH
LpbRegistryLength equ 028H
LpbRegistryBase equ 02CH
LpbConfigurationRoot equ 030H
LpbArcBootDeviceName equ 034H
LpbArcHalDeviceName equ 038H

;
;  System Service Descriptor Table structure definitions.
;

NUMBER_SERVICE_TABLES equ 02H
SERVICE_NUMBER_MASK equ 0FFFH
SERVICE_TABLE_SHIFT equ 08H
SERVICE_TABLE_MASK equ 010H
SERVICE_TABLE_TEST equ 01000H
SdBase equ 00H
SdCount equ 04H
SdLimit equ 08H
SdNumber equ 0CH
PAGE_SIZE equ 01000H

;
;  VDM equates.
;

VDM_INDEX_Invalid equ 00H
VDM_INDEX_0F equ 01H
VDM_INDEX_ESPrefix equ 02H
VDM_INDEX_CSPrefix equ 03H
VDM_INDEX_SSPrefix equ 04H
VDM_INDEX_DSPrefix equ 05H
VDM_INDEX_FSPrefix equ 06H
VDM_INDEX_GSPrefix equ 07H
VDM_INDEX_OPER32Prefix equ 08H
VDM_INDEX_ADDR32Prefix equ 09H
VDM_INDEX_INSB equ 0AH
VDM_INDEX_INSW equ 0BH
VDM_INDEX_OUTSB equ 0CH
VDM_INDEX_OUTSW equ 0DH
VDM_INDEX_PUSHF equ 0EH
VDM_INDEX_POPF equ 0FH
VDM_INDEX_INTnn equ 010H
VDM_INDEX_INTO equ 011H
VDM_INDEX_IRET equ 012H
VDM_INDEX_NPX equ 013H
VDM_INDEX_INBimm equ 014H
VDM_INDEX_INWimm equ 015H
VDM_INDEX_OUTBimm equ 016H
VDM_INDEX_OUTWimm equ 017H
VDM_INDEX_INB equ 018H
VDM_INDEX_INW equ 019H
VDM_INDEX_OUTB equ 01AH
VDM_INDEX_OUTW equ 01BH
VDM_INDEX_LOCKPrefix equ 01CH
VDM_INDEX_REPNEPrefix equ 01DH
VDM_INDEX_REPPrefix equ 01EH
VDM_INDEX_CLI equ 01FH
VDM_INDEX_STI equ 020H
VDM_INDEX_HLT equ 021H
MAX_VDM_INDEX equ 022H

;
;  VDM feature bits.
;

V86_VIRTUAL_INT_EXTENSIONS equ 01H
PM_VIRTUAL_INT_EXTENSIONS equ 02H

;
;  Selector types.
;

SEL_TYPE_NP equ 040H

;
; Usermode callout frame definitions
;

CuInStk equ 00H
CuTrFr equ 04H
CuCbStk equ 08H
CuEdi equ 0CH
CuEsi equ 010H
CuEbx equ 014H
CuEbp equ 018H
CuRet equ 01CH
CuOutBf equ 020H
CuOutLn equ 024H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\counters\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ndphlpr\src\test.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dprintf.h>
#include "ndphlpr.h"


DWORD g_dwCounter = 0;


DWORD WINAPI TargetThread(LPVOID pvDummy)
{
    printf("TargetThread started\n");
    for (;;)
        g_dwCounter++;
    return 0;
}


void DisplayContext(CONTEXT *pContext)
{
    printf("Flags : %08X\n", pContext->ContextFlags);
    printf("SegGs : %08X\n", pContext->SegGs);
    printf("SegFs : %08X\n", pContext->SegFs);
    printf("SegEs : %08X\n", pContext->SegEs);
    printf("SegDs : %08X\n", pContext->SegDs);
    printf("Edi   : %08X\n", pContext->Edi);
    printf("Esi   : %08X\n", pContext->Esi);
    printf("Ebx   : %08X\n", pContext->Ebx);
    printf("Edx   : %08X\n", pContext->Edx);
    printf("Ecx   : %08X\n", pContext->Ecx);
    printf("Eax   : %08X\n", pContext->Eax);
    printf("Ebp   : %08X\n", pContext->Ebp);
    printf("Eip   : %08X\n", pContext->Eip);
    printf("SegCs : %08X\n", pContext->SegCs);
    printf("EFlags: %08X\n", pContext->EFlags);
    printf("Esp   : %08X\n", pContext->Esp);
    printf("SegSs : %08X\n", pContext->SegSs);
}


int main(int argc, char **argv)
{
    HANDLE hVxD = CreateFile("\\\\.\\NDPHLPR.VXD",
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
                             NULL);
    if (hVxD == INVALID_HANDLE_VALUE) {
        printf("Failed to open device, error %u\n", GetLastError());
        return 1;
    }

    DWORD dwProcID = GetCurrentProcessId();
    DWORD dwVersion;
    DWORD dwDummy;
    if (!DeviceIoControl(hVxD,
                         NDPHLPR_Init,
                         &dwProcID,
                         sizeof(DWORD),
                         &dwVersion,
                         sizeof(DWORD),
                         &dwDummy,
                         NULL)) {
        printf("DeviceIoControl(NDPHLPR_Init) failed, error %u\n", GetLastError());
        return 1;
    }

    if (dwVersion != NDPHLPR_Version) {
        printf("NDPHLPR version is incorrect %08X vs %08X\n", dwVersion, NDPHLPR_Version);
        return 1;
    }

    DWORD dwThreadID;
    HANDLE hThread = CreateThread(NULL,
                                  0,
                                  TargetThread,
                                  NULL,
                                  0,
                                  &dwThreadID);
    if (hThread == NULL) {
        printf("Failed to create target thread, error %u\n", GetLastError());
        return 1;
    }

    Sleep(1000);

    NDPHLPR_CONTEXT sCtx;
    sCtx.NDPHLPR_status = 0;
    sCtx.NDPHLPR_data = 0;
    sCtx.NDPHLPR_threadId = dwThreadID;
    sCtx.NDPHLPR_ctx.ContextFlags = CONTEXT_FULL;

    CONTEXT sOldContext;

    for (DWORD dwIteration = 0;; dwIteration++) {

        if (SuspendThread(hThread) == -1) {
            printf("Failed to suspend thread, error %u\n", GetLastError());
            return 1;
        }

        if (!DeviceIoControl(hVxD,
                             NDPHLPR_GetThreadContext,
                             &sCtx,
                             sizeof(NDPHLPR_CONTEXT),
                             &sCtx,
                             sizeof(NDPHLPR_CONTEXT),
                             &dwDummy,
                             NULL)) {
            printf("DeviceIoControl(NDPHLPR_GetThreadContext) failed on iteration %u, error %u\n", dwIteration, GetLastError());

            if (dwIteration & 1) {
                printf("Setting thread context...\n");
                if (!DeviceIoControl(hVxD,
                                     NDPHLPR_SetThreadContext,
                                     &sCtx,
                                     sizeof(NDPHLPR_CONTEXT),
                                     &sCtx,
                                     sizeof(NDPHLPR_CONTEXT),
                                     &dwDummy,
                                     NULL)) {
                    printf("DeviceIoControl(NDPHLPR_SetThreadContext) failed on iteration %u, error %u\n", dwIteration, GetLastError());
                    return 1;
                }
            }

            DWORD dwRetries = 1;
            while (dwRetries < 1000) {
                if (DeviceIoControl(hVxD,
                                    NDPHLPR_GetThreadContext,
                                    &sCtx,
                                    sizeof(NDPHLPR_CONTEXT),
                                    &sCtx,
                                    sizeof(NDPHLPR_CONTEXT),
                                    &dwDummy,
                                    NULL)) {
                    printf("Succeeded after %u retries\n");
                    break;
                }
                dwRetries++;
            }
            if (dwRetries == 1000)
                printf("Gave up after 1000 retries\n");
        }

        if ((dwIteration % 1000) == 0)
            if (!DeviceIoControl(hVxD,
                                 NDPHLPR_SetThreadContext,
                                 &sCtx,
                                 sizeof(NDPHLPR_CONTEXT),
                                 &sCtx,
                                 sizeof(NDPHLPR_CONTEXT),
                                 &dwDummy,
                                 NULL))
                printf("DeviceIoControl(NDPHLPR_SetThreadContext) failed on iteration %u, error %u\n", dwIteration, GetLastError());

        if (ResumeThread(hThread) == -1) {
            printf("Failed to resume thread, error %u\n", GetLastError());
            return 1;
        }

        if ((dwIteration % 1000) == 0)
            dprintf("**** Test iteration %u ****\n", dwIteration);

        Sleep(1);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\common\util.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// util.h
//
// These are util-related items used by profiling tools.
//
//*****************************************************************************
#pragma once
#define MAX_CLASSNAME_LENGTH    1024

//*****************************************************************************
// This helper method will derive an output file name based on the EXE which
// is running. The name is in the format <path>\app_<pid>.csv, where <path>
// is the full path to the EXE, and <pid> is the process id you are running.
// Of course this won't inline, but it gives a common place for this code
// without having to export the method from the EE.
//*****************************************************************************
inline void GetIcecapProfileOutFile(LPWSTR szOut)
{
    WCHAR   rcExeName[_MAX_PATH];
    WCHAR   rcDrive[_MAX_PATH];
    WCHAR   rcDir[_MAX_PATH];
    WCHAR   rcFileName[_MAX_PATH];

    if (!WszGetModuleFileName(NULL, rcExeName, NumItems(rcExeName)))
        wcscpy(rcExeName, L"icecap.csv");

    SplitPath(rcExeName, rcDrive, rcDir, rcFileName, NULL);
    // ensure don't overflow _MAX_PATH
    if (wcslen(rcDrive)+wcslen(rcDir)+wcslen(rcFileName)+9+4 >= _MAX_PATH)
    {
        wcscpy(rcExeName, L"icecap.csv");
        SplitPath(rcExeName, rcDrive, rcDir, rcFileName, NULL);
    }

    swprintf(&rcFileName[wcslen(rcFileName)], L"_%08x", GetCurrentProcessId());
    MakePath(szOut, rcDrive, rcDir, rcFileName, L".csv");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\counters\perfcounters.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: PerfCounters.CPP
// 
// ===========================================================================


// PerfCounters.cpp
#include "stdafx.h"

// Always enable perf counters
#define ENABLE_PERF_COUNTERS
#include "PerfCounters.h"

#include "IPCManagerInterface.h"

#ifdef ENABLE_PERF_COUNTERS
extern IPCWriterInterface*	g_pIPCManagerInterface;


//-----------------------------------------------------------------------------
// Instantiate static data
//-----------------------------------------------------------------------------

PerfCounterIPCControlBlock PerfCounters::m_garbage;

HANDLE PerfCounters::m_hGlobalMapPerf = NULL;


PerfCounterIPCControlBlock * PerfCounters::m_pGlobalPerf = &PerfCounters::m_garbage;
PerfCounterIPCControlBlock * PerfCounters::m_pPrivatePerf = &PerfCounters::m_garbage;

BOOL PerfCounters::m_fInit = false;


//-----------------------------------------------------------------------------
// Should never actually instantiate this class, so assert.
// ctor is also private, so we should never be here.
//-----------------------------------------------------------------------------
PerfCounters::PerfCounters()
{
	_ASSERTE(false);
}

//-----------------------------------------------------------------------------
// Create or Open memory mapped files for IPC for both shared & private
//-----------------------------------------------------------------------------
HRESULT PerfCounters::Init() // static
{
// @todo: not opening the private IPC block is not a good enough reason
// to fail. so we return NO_ERROR. If we do fail, just drop something in
// the logs. PerfCounters are designed to work even if not connected.

// Should only be called once
	_ASSERTE(!m_fInit);
	_ASSERTE(g_pIPCManagerInterface != NULL);

	
	HRESULT hr = NOERROR;
    BOOL globalMapAlreadyCreated = FALSE;
	void * pArena = NULL;

// Open shared block
	LPSECURITY_ATTRIBUTES pSecurity = NULL;
    
    hr = g_pIPCManagerInterface->GetSecurityAttributes(GetCurrentProcessId(), &pSecurity);
    // No need to check the HR. pSecurity will be NULL if it fails, and this logic doesn't care.

    if (RunningOnWinNT5())
    {
        m_hGlobalMapPerf = WszCreateFileMapping(
            (HANDLE) -1,				// Current file handle. 
            pSecurity,					// Default security. 
            PAGE_READWRITE,             // Read/write permission. 
            0,                          // Max. object size. 
            sizeof(PerfCounterIPCControlBlock),	// Size of hFile. 
            L"Global\\" SHARED_PERF_IPC_NAME);		// Name of mapping object. 
    }
    else
    {
        m_hGlobalMapPerf = WszCreateFileMapping(
            (HANDLE) -1,				// Current file handle. 
            pSecurity,					// Default security. 
            PAGE_READWRITE,             // Read/write permission. 
            0,                          // Max. object size. 
            sizeof(PerfCounterIPCControlBlock),	// Size of hFile. 
            SHARED_PERF_IPC_NAME);		// Name of mapping object. 
    }

    g_pIPCManagerInterface->DestroySecurityAttributes(pSecurity);
    pSecurity = NULL;
    
	if (m_hGlobalMapPerf == NULL) 
	{		
		//hr = HRESULT_FROM_WIN32(GetLastError());	
		hr = NO_ERROR;
		goto errExit;
	}
    else
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS) 
        {
            globalMapAlreadyCreated = TRUE;
        }
    }

// Map shared block into memory
	pArena = MapViewOfFile(m_hGlobalMapPerf, // Handle to mapping object. 
		FILE_MAP_ALL_ACCESS,               // Read/write permission 
		0,                                 // Max. object size. 
		0,                                 // Size of hFile. 
		0); 
	
	if (pArena == NULL) 
	{
		CloseHandle(m_hGlobalMapPerf);
		//hr = HRESULT_FROM_WIN32(GetLastError());	
		hr = NO_ERROR;
		goto errExit;
	}

    m_pGlobalPerf = (PerfCounterIPCControlBlock*) pArena;

    // Set Version & attr. 
    // Note, if we're not updating counters, either this block doesn't exist, or
    // if it does, these fields are 0. So clients can know the validity of the data
    if (! globalMapAlreadyCreated) 
        memset (m_pGlobalPerf, 0, sizeof (PerfCounterIPCControlBlock));
    m_pGlobalPerf->m_cBytes = sizeof(PerfCounterIPCControlBlock);
    m_pGlobalPerf->m_wAttrs = PERF_ATTR_ON | PERF_ATTR_GLOBAL;
	

errExit:
    m_pPrivatePerf= g_pIPCManagerInterface->GetPerfBlock();

    // Set attributes
    if (m_pPrivatePerf != NULL)
    {
        memset (m_pPrivatePerf, 0, sizeof (PerfCounterIPCControlBlock));
        m_pPrivatePerf->m_cBytes = sizeof(PerfCounterIPCControlBlock);
        m_pPrivatePerf->m_wAttrs = PERF_ATTR_ON;
    }

    if (SUCCEEDED(hr)) 
    {
        m_fInit = true;
    } else {
        Terminate();
    }

	return hr;
}

//-----------------------------------------------------------------------------
// Reset certain counters to 0 at closure because we could still have
// dangling references to us
//-----------------------------------------------------------------------------
void ResetCounters()
{
// Signify this block is no longer being updated
	GetPrivatePerfCounters().m_wAttrs &= ~PERF_ATTR_ON;

    for(int iGen = 0; iGen < MAX_TRACKED_GENS; iGen ++)
	{
		GetPrivatePerfCounters().m_GC.cGenHeapSize[iGen] = 0;
	}

	GetPrivatePerfCounters().m_GC.cLrgObjSize = 0;
}

//-----------------------------------------------------------------------------
// Shutdown - close handles
//-----------------------------------------------------------------------------
void PerfCounters::Terminate() // static
{
// @jms - do we have any threading issues to worry about here?

// Should be created first
	_ASSERTE(m_fInit);

// Reset counters to zero for dangling references
	ResetCounters();

// release global handles 
	if (m_hGlobalMapPerf != NULL)
	{
		::CloseHandle(m_hGlobalMapPerf);
		m_hGlobalMapPerf = NULL;
	}

	if (m_pGlobalPerf != &PerfCounters::m_garbage)
	{
		UnmapViewOfFile(m_pGlobalPerf);
		m_pGlobalPerf = &PerfCounters::m_garbage;
	}

	if (m_pPrivatePerf != &PerfCounters::m_garbage)
	{
		m_pPrivatePerf = &PerfCounters::m_garbage;
	}

	m_fInit = false;

}

Perf_Contexts *GetPrivateContextsPerfCounters()
{
    return (Perf_Contexts *)((unsigned char *)PerfCounters::GetPrivatePerfCounterPtr() + offsetof (PerfCounterIPCControlBlock, m_Context));
}

Perf_Contexts *GetGlobalContextsPerfCounters()
{
    return (Perf_Contexts *)((unsigned char *)PerfCounters::GetGlobalPerfCounterPtr() + offsetof (PerfCounterIPCControlBlock, m_Context));
}

#endif // ENABLE_PERF_COUNTERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\common\callbackbase.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#pragma once

#include "CorProf.h"
#include "UtilCode.h" 

/* ------------------------------------------------------------------------- *
 * ProfCallback is a base implementation of ICorProfilerCallback that cannot
 * be instantiated.
 * ------------------------------------------------------------------------- */

class ProfCallbackBase : public ICorProfilerCallback
{
    /*********************************************************************
     * IUnknown Support
     */

private:    
    long      m_refCount;

public:
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long refCount = InterlockedDecrement(&m_refCount);

        if (refCount == 0)
            delete this;

        return (refCount);
    }

	COM_METHOD QueryInterface(REFIID id, void **pInterface)
	{
		if (id == IID_IUnknown)
			*pInterface = (IUnknown *)(ICorProfilerCallback *)this;
		else
		{
			*pInterface = NULL;
			return (E_NOINTERFACE);
		}
	
		AddRef();

		return (S_OK);
	}


protected:
    /*********************************************************************
     * Constructor and Destructor are protected so objects of this base
	 * class are not instantiated.
     */
    ProfCallbackBase() : m_refCount(0)
	{
	}

    virtual ~ProfCallbackBase()
	{
	}

public:
    /*********************************************************************
     * ICorProfilerCallback methods
     */
    COM_METHOD Initialize( 
        /* [in] */  IUnknown *pEventInfo)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ClassLoadStarted( 
        /* [in] */ ClassID classId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ClassLoadFinished( 
        /* [in] */ ClassID classId,
		/* [in] */ HRESULT hrStatus)
	{
		return (E_NOTIMPL);
	}

	COM_METHOD ClassUnloadStarted( 
		/* [in] */ ClassID classId)
	{
		return (E_NOTIMPL);
	}

	COM_METHOD ClassUnloadFinished( 
        /* [in] */ ClassID classId,
		/* [in] */ HRESULT hrStatus)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ContextCrossing( 
        /* [in] */ ThreadID threadId,
        /* [in] */ ContextID fromContextId,
        /* [in] */ ContextID toContextId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD NotifyFunctionEntry( 
        /* [in] */ ThreadID threadId,
        /* [in] */ ULONG ip)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD NotifyFunctionExit( 
        /* [in] */ ThreadID threadId,
        /* [in] */ ULONG ip)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD NotifyFunctionTailCall( 
        /* [in] */ ThreadID threadId,
        /* [in] */ ULONG ip)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD FunctionUnloadStarted( 
        /* [in] */ FunctionID functionId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RuntimeSuspendStarted(COR_PRF_SUSPEND_REASON suspendReason)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RuntimeSuspendFinished()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RuntimeSuspendAborted()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RuntimeResumeStarted()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RuntimeResumeFinished()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RuntimeThreadSuspended(
        /* [in] */ ThreadID threadId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RuntimeThreadResumed(
        /* [in] */ ThreadID threadId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RemotingClientInvocationStarted()
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RemotingClientSendingMessage(GUID *pCookie, BOOL fIsAsync)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RemotingClientReceivingReply(GUID *pCookie, BOOL fIsAsync)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RemotingClientInvocationFinished()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RemotingServerReceivingMessage(GUID *pCookie, BOOL fIsAsync)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RemotingServerInvocationStarted()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD RemotingServerInvocationReturned()
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RemotingServerSendingReply(GUID *pCookie, BOOL fIsAsync)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD JITCompilationFinished( 
        /* [in] */ FunctionID functionId,
		/* [in] */ HRESULT hrStatus,
        /* [in] */ BOOL fIsSafeToBlock)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD JITCompilationStarted( 
        /* [in] */ FunctionID functionId,
        /* [in] */ BOOL fIsSafeToBlock)
	{
		return (E_NOTIMPL);
	}
    
	COM_METHOD JITCachedFunctionSearchStarted(
        /* [in] */  FunctionID functionId,
        /* [out] */ BOOL       *pbUseCachedFunction)
	{
		return (E_NOTIMPL);
	}

	COM_METHOD JITCachedFunctionSearchFinished(
		/* [in] */  FunctionID functionId,
		/* [in] */  COR_PRF_JIT_CACHE result)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD JITFunctionPitched(
        /* [in] */ FunctionID functionId)
    {
        return (E_NOTIMPL);
    }

    COM_METHOD JITInlining(
        /* [in] */  FunctionID    callerId,
        /* [in] */  FunctionID    calleeId,
        /* [out] */ BOOL         *pfShouldInline)
    {
        return (E_NOTIMPL);
    }

    COM_METHOD ModuleLoadStarted( 
        /* [in] */ ModuleID moduleId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ModuleLoadFinished( 
        /* [in] */ ModuleID moduleId,
		/* [in] */ HRESULT hrStatus)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ModuleUnloadStarted( 
        /* [in] */ ModuleID moduleId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ModuleUnloadFinished( 
        /* [in] */ ModuleID moduleId,
		/* [in] */ HRESULT hrStatus)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ModuleAttachedToAssembly( 
        ModuleID    moduleId,
        AssemblyID  AssemblyId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD AppDomainCreationStarted( 
        AppDomainID appDomainId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AppDomainCreationFinished( 
        AppDomainID appDomainId,
        HRESULT     hrStatus)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AppDomainShutdownStarted( 
        AppDomainID appDomainId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AppDomainShutdownFinished( 
        AppDomainID appDomainId,
        HRESULT     hrStatus)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AssemblyLoadStarted( 
        AssemblyID  assemblyId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AssemblyLoadFinished( 
        AssemblyID  assemblyId,
        HRESULT     hrStatus)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AssemblyUnloadStarted( 
        AssemblyID  assemblyId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD AssemblyUnloadFinished( 
        AssemblyID  assemblyId,
        HRESULT     hrStatus)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD MovedReferences( 
        /* [in] */ ULONG cMovedObjectRefs,
        /* [in] */ ObjectID oldObjectRefs[],
        /* [in] */ ObjectID newObjectRefs[],
        /* [in] */ ULONG cObjectRefSize[])
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ObjectAllocated( 
        /* [in] */ ObjectID objectId,
        /* [in] */ ClassID classId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ObjectsAllocatedByClass( 
        /* [in] */ ULONG cClassCount,
        /* [size_is][in] */ ClassID __RPC_FAR classIds[  ],
        /* [size_is][in] */ ULONG __RPC_FAR cObjects[  ])
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ObjectReferences( 
        /* [in] */ ObjectID objectId,
        /* [in] */ ClassID classId,
        /* [in] */ ULONG cObjectRefs,
        /* [size_is][in] */ ObjectID __RPC_FAR objectRefIds[  ])
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD RootReferences( 
        /* [in] */ ULONG cRootRefs,
        /* [size_is][in] */ ObjectID __RPC_FAR rootRefIds[  ])
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD Shutdown(void)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ThreadCreated( 
        /* [in] */ ThreadID threadId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ThreadDestroyed( 
        /* [in] */ ThreadID threadId)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ThreadAssignedToOSThread(
        /* [in] */ ThreadID managedThreadId,
        /* [in] */ DWORD osThreadId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD UnmanagedToManagedTransition( 
        /* [in] */ FunctionID functionId,
        /* [in] */ COR_PRF_TRANSITION_REASON reason)
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ManagedToUnmanagedTransition( 
        /* [in] */ FunctionID functionId,
        /* [in] */ COR_PRF_TRANSITION_REASON reason)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionThrown(
        /* [in] */ ObjectID thrownObjectId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionSearchFunctionEnter(
        /* [in] */ FunctionID functionId)
    {
        return (E_NOTIMPL);
    }

    COM_METHOD ExceptionSearchFunctionLeave()
    {
        return (E_NOTIMPL);
    }

    COM_METHOD ExceptionSearchFilterEnter(
        /* [in] */ FunctionID funcId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionSearchFilterLeave()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionSearchCatcherFound (
        /* [in] */ FunctionID functionId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionOSHandlerEnter(
        /* [in] */ FunctionID funcId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionOSHandlerLeave(
        /* [in] */ FunctionID funcId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionUnwindFunctionEnter(
        /* [in] */ FunctionID functionId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionUnwindFunctionLeave()
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ExceptionUnwindFinallyEnter(
        /* [in] */ FunctionID functionId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionUnwindFinallyLeave()
	{
		return (E_NOTIMPL);
	}
    
    COM_METHOD ExceptionCatcherEnter(
        /* [in] */ FunctionID functionId,
        /* [in] */ ObjectID objectId)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionCatcherLeave()
	{
		return (E_NOTIMPL);
	}

    COM_METHOD COMClassicVTableCreated(
       /* [in] */ ClassID wrappedClassId,
       /* [in] */ REFGUID implementedIID,
       /* [in] */ void *pVTable,
       /* [in] */ ULONG cSlots)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD COMClassicVTableDestroyed(
       /* [in] */ ClassID wrappedClassId,
       /* [in] */ REFGUID implementedIID,
       /* [in] */ void *pVTable)
	{
		return (E_NOTIMPL);
	}

    COM_METHOD ExceptionCLRCatcherFound()
    {
        return (E_NOTIMPL);
    }

    COM_METHOD ExceptionCLRCatcherExecute()
    {
        return (E_NOTIMPL);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\eetoprofinterfaceimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************
#include "stdafx.h"
#include "EEToProfInterfaceImpl.h"

//********** Globals. *********************************************************


class GCTogglePre
{
public:
    FORCEINLINE GCTogglePre(ThreadID threadId)
    {
        if (threadId != 0)
        {
            m_threadId= threadId;
            m_bIsCoopMode = g_pProfToEEInterface->PreemptiveGCDisabled(m_threadId);
            if (m_bIsCoopMode)
                g_pProfToEEInterface->EnablePreemptiveGC(m_threadId);
        }
        else
            m_threadId = 0;
    }
    FORCEINLINE ~GCTogglePre()
    {
        if (m_threadId != 0 && m_bIsCoopMode)
            g_pProfToEEInterface->DisablePreemptiveGC(m_threadId);
    }
private:
    ThreadID    m_threadId;
    BOOL        m_bIsCoopMode;
};

class GCToggleCoop
{
public:
    FORCEINLINE GCToggleCoop(ThreadID threadId)
    {
        if (threadId != 0)
        {
            m_threadId= threadId;
            m_bIsCoopMode = g_pProfToEEInterface->PreemptiveGCDisabled(m_threadId);
            if (!m_bIsCoopMode)
                g_pProfToEEInterface->DisablePreemptiveGC(m_threadId);
        }
        else
            m_threadId = 0;
    }
    FORCEINLINE ~GCToggleCoop()
    {
        if (m_threadId != 0 && !m_bIsCoopMode)
            g_pProfToEEInterface->EnablePreemptiveGC(m_threadId);
    }
private:
    ThreadID    m_threadId;
    BOOL        m_bIsCoopMode;
};


//********** Code. ************************************************************

EEToProfInterfaceImpl::t_AllocByClassData *EEToProfInterfaceImpl::m_pSavedAllocDataBlock = NULL;

EEToProfInterfaceImpl::EEToProfInterfaceImpl() :
    m_pRootRefDataFreeList(NULL), m_pMovedRefDataFreeList(NULL), m_pGUID(NULL), m_lGUIDCount(0)
{
}

HRESULT EEToProfInterfaceImpl::Init()
{
    // Used to initialize the WinWrap so that WszXXX works
    OnUnicodeSystem();
    return (S_OK);
}

void EEToProfInterfaceImpl::Terminate(BOOL fProcessDetach)
{
    g_pProfToEEInterface->Terminate();
    g_pProfToEEInterface = NULL;

    // Delete the structs associated with GC moved references
    while (m_pMovedRefDataFreeList)
    {
        t_MovedReferencesData *pDel = m_pMovedRefDataFreeList;
        m_pMovedRefDataFreeList = m_pMovedRefDataFreeList->pNext;
        delete pDel;
    }

    // Delete the structs associated with root references
    while (m_pRootRefDataFreeList)
    {
        t_RootReferencesData *pDel = m_pRootRefDataFreeList;
        m_pRootRefDataFreeList = m_pRootRefDataFreeList->pNext;
        delete pDel;
    }

    if (m_pSavedAllocDataBlock)
    {
        _ASSERTE((UINT)m_pSavedAllocDataBlock != 0xFFFFFFFF);

        _ASSERTE(m_pSavedAllocDataBlock->pHashTable != NULL);
        // Get rid of the hash table
        if (m_pSavedAllocDataBlock->pHashTable)
            delete m_pSavedAllocDataBlock->pHashTable;

        // Get rid of the two arrays used to hold class<->numinstance info
        if (m_pSavedAllocDataBlock->cLength != 0)
        {
            _ASSERTE(m_pSavedAllocDataBlock->arrClsId != NULL);
            _ASSERTE(m_pSavedAllocDataBlock->arrcObjects != NULL);

            delete [] m_pSavedAllocDataBlock->arrClsId;
            delete [] m_pSavedAllocDataBlock->arrcObjects;
        }

        // Get rid of the hash array used by the hash table
        if (m_pSavedAllocDataBlock->arrHash)
        {
            free((void *)m_pSavedAllocDataBlock->arrHash);
        }
    }

    if (m_pGUID)
        delete m_pGUID;

    // If we're in process detach, then do nothing related
    // to cleaning up the profiler DLL.
    if (g_pCallback && !fProcessDetach)
    {
		g_pCallback->Release();
	    g_pCallback = NULL;
    }

    // The runtime can't free me, cause I'm in a separate DLL with my own
    // memory management.
    delete this;
}

// This is called by the EE if the profiling bit is set.
HRESULT EEToProfInterfaceImpl::CreateProfiler(WCHAR *wszCLSID)
{
    // Try and CoCreate the registered profiler
    HRESULT hr = CoCreateProfiler(wszCLSID, &g_pCallback);

    // If profiler was CoCreated, initialize it.
    if (SUCCEEDED(hr))
    {
        // First, create an ICorProfilerInfo object for the initialize
        CorProfInfo *pInfo = new CorProfInfo();
        _ASSERTE(pInfo != NULL);

        if (pInfo != NULL)
        {
            // Now call the initialize method on the profiler.
            //@TODO: Fix first argument
            DWORD dwEvents = 0;

            g_pInfo = pInfo;
            
            pInfo->AddRef();
            hr = g_pCallback->Initialize((IUnknown *)(ICorProfilerInfo *)pInfo);

            // If initialize failed, then they will not have addref'd the object
            // and it will die here.  If initialize succeeded, then if they want
            // the info interface they will have addref'd it and this will just
            // decrement the addref counter.
            pInfo->Release();
        }
        else
            hr = E_OUTOFMEMORY;

        if (FAILED(hr))
        {
            RELEASE(g_pCallback);
            g_pCallback = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return (hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// THREAD EVENTS
//

HRESULT EEToProfInterfaceImpl::ThreadCreated(ThreadID threadId)
{
    _ASSERTE(g_pCallback != NULL);

    LOG((LF_CORPROF, LL_INFO100, "**PROF: Notifying profiler of created "
         "thread.\n"));

    GCTogglePre gc(threadId);

    // Notify the profiler of the newly created thread.
    return (g_pCallback->ThreadCreated(threadId));
}

HRESULT EEToProfInterfaceImpl::ThreadDestroyed(ThreadID threadId)
{
    _ASSERTE(g_pCallback != NULL);

    LOG((LF_CORPROF, LL_INFO100, "**PROF: Notifying profiler of destroyed "
         "thread.\n"));
    
    // Notify the profiler of the destroyed thread
    return (g_pCallback->ThreadDestroyed(threadId));
}

HRESULT EEToProfInterfaceImpl::ThreadAssignedToOSThread(ThreadID managedThreadId,
                                                              DWORD osThreadId)
{
    _ASSERTE(g_pCallback != NULL);

    LOG((LF_CORPROF, LL_INFO100, "**PROF: Notifying profiler of thread assignment.\n"));
    
    // Notify the profiler of the destroyed thread
    return (g_pCallback->ThreadAssignedToOSThread(managedThreadId, osThreadId));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// EE STARTUP/SHUTDOWN EVENTS
//

HRESULT EEToProfInterfaceImpl::Shutdown(ThreadID threadId)
{
    _ASSERTE(g_pCallback != NULL);

    LOG((LF_CORPROF, LL_INFO10, "**PROF: Notifying profiler that "
         "shutdown is beginning.\n"));

    GCTogglePre gc(threadId);

    return (g_pCallback->Shutdown());
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// JIT/FUNCTION EVENTS
//

HRESULT EEToProfInterfaceImpl::FunctionUnloadStarted(ThreadID threadId, FunctionID functionId)
{
    _ASSERTE(functionId != 0);

    LOG((LF_CORPROF, LL_INFO100, "**PROF: FunctionUnloadStarted 0x%08x.\n", functionId));

    GCTogglePre gc(threadId);

    return (g_pCallback->FunctionUnloadStarted(functionId));
}

HRESULT EEToProfInterfaceImpl::JITCompilationFinished(ThreadID threadId, FunctionID functionId,
                                                      HRESULT hrStatus, BOOL fIsSafeToBlock)
{
	_ASSERTE(functionId != 0);

    LOG((LF_CORPROF, LL_INFO1000, "**PROF: JITCompilationFinished 0x%08x, hr=0x%08x.\n", functionId, hrStatus));

    GCTogglePre *pgc;

    if (fIsSafeToBlock)
    {
        pgc = (GCTogglePre *)_alloca(sizeof(GCTogglePre));
        pgc = new ((void *)pgc) GCTogglePre(threadId);
    }

	HRESULT hr = g_pCallback->JITCompilationFinished(functionId, hrStatus, fIsSafeToBlock);

    if (fIsSafeToBlock)
        pgc->~GCTogglePre();

    return (hr);
}


HRESULT EEToProfInterfaceImpl::JITCompilationStarted(ThreadID threadId, FunctionID functionId,
                                                     BOOL fIsSafeToBlock)
{
	_ASSERTE(functionId != 0);

    LOG((LF_CORPROF, LL_INFO1000, "**PROF: JITCompilationStarted 0x%08x.\n", functionId));

    GCTogglePre *pgc;

    if (fIsSafeToBlock)
    {
        pgc = (GCTogglePre *)_alloca(sizeof(GCTogglePre));
        pgc = new ((void *)pgc) GCTogglePre(threadId);
    }

    HRESULT hr = g_pCallback->JITCompilationStarted(functionId, fIsSafeToBlock);

    if (fIsSafeToBlock)
        pgc->~GCTogglePre();

    return (hr);
}

HRESULT EEToProfInterfaceImpl::JITCachedFunctionSearchStarted(
                            		/* [in] */	ThreadID   threadId,
                                    /* [in] */  FunctionID functionId,
                                    /* [out] */ BOOL       *pbUseCachedFunction)
{
	_ASSERTE(functionId != 0);
    _ASSERTE(pbUseCachedFunction != NULL);

    LOG((LF_CORPROF, LL_INFO1000, "**PROF: JITCachedFunctionSearchStarted 0x%08x.\n", functionId));

    GCTogglePre gc(threadId);

	return (g_pCallback->JITCachedFunctionSearchStarted(functionId, pbUseCachedFunction));
}

HRESULT EEToProfInterfaceImpl::JITCachedFunctionSearchFinished(
									/* [in] */	ThreadID threadId,
									/* [in] */  FunctionID functionId,
									/* [in] */  COR_PRF_JIT_CACHE result)
{
	_ASSERTE(functionId != 0);

    LOG((LF_CORPROF, LL_INFO1000, "**PROF: JITCachedFunctionSearchFinished 0x%08x, %s.\n", functionId,
		(result == COR_PRF_CACHED_FUNCTION_FOUND ? "Cached function found" : "Cached function not found")));

    GCTogglePre gc(threadId);

	return (g_pCallback->JITCachedFunctionSearchFinished(functionId, result));
}


HRESULT EEToProfInterfaceImpl::JITFunctionPitched(ThreadID threadId, FunctionID functionId)
{
	_ASSERTE(functionId != 0);

    LOG((LF_CORPROF, LL_INFO1000, "**PROF: JITFunctionPitched 0x%08x.\n", functionId));

    GCTogglePre gc(threadId);

	return (g_pCallback->JITFunctionPitched(functionId));
}

HRESULT EEToProfInterfaceImpl::JITInlining(
    /* [in] */  ThreadID      threadId,
    /* [in] */  FunctionID    callerId,
    /* [in] */  FunctionID    calleeId,
    /* [out] */ BOOL         *pfShouldInline)
{
	_ASSERTE(callerId != 0);
    _ASSERTE(calleeId != 0);

    LOG((LF_CORPROF, LL_INFO1000, "**PROF: JITInlining caller: 0x%08x, callee: 0x%08x.\n", callerId, calleeId));

    GCTogglePre gc(threadId);

	return (g_pCallback->JITInlining(callerId, calleeId, pfShouldInline));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// MODULE EVENTS
//

HRESULT EEToProfInterfaceImpl::ModuleLoadStarted(ThreadID threadId, ModuleID moduleId)
{
    _ASSERTE(moduleId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: ModuleLoadStarted 0x%08x.\n", moduleId));
//@Todo    GCTogglePre gc(threadId);

    g_pProfToEEInterface->SetCurrentPointerForDebugger((void *)(Module *)moduleId, PT_MODULE);
    HRESULT hr = (g_pCallback->ModuleLoadStarted(moduleId));

    return hr;
}


HRESULT EEToProfInterfaceImpl::ModuleLoadFinished(
    ThreadID    threadId,
	ModuleID	moduleId, 
	HRESULT		hrStatus)
{
	_ASSERTE(moduleId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: ModuleLoadFinished 0x%08x.\n", moduleId));

    HRESULT hr = (g_pCallback->ModuleLoadFinished(moduleId, hrStatus));
    g_pProfToEEInterface->SetCurrentPointerForDebugger(NULL, PT_MODULE);

    return hr;
}


HRESULT EEToProfInterfaceImpl::ModuleUnloadStarted(
    ThreadID    threadId, 
    ModuleID    moduleId)
{
	_ASSERTE(moduleId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: ModuleUnloadStarted 0x%08x.\n", moduleId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ModuleUnloadStarted(moduleId));
}


HRESULT EEToProfInterfaceImpl::ModuleUnloadFinished(
    ThreadID    threadId, 
	ModuleID	moduleId, 
	HRESULT		hrStatus)
{
	_ASSERTE(moduleId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: ModuleUnloadFinished 0x%08x.\n", moduleId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ModuleUnloadFinished(moduleId, hrStatus));
}


HRESULT EEToProfInterfaceImpl::ModuleAttachedToAssembly( 
    ThreadID    threadId, 
    ModuleID    moduleId,
    AssemblyID  AssemblyId)
{
	_ASSERTE(moduleId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: ModuleAttachedToAssembly 0x%08x, 0x%08x.\n", moduleId, AssemblyId));

    g_pProfToEEInterface->SetCurrentPointerForDebugger((void *)(Module *)moduleId, PT_MODULE);
    HRESULT hr = (g_pCallback->ModuleAttachedToAssembly(moduleId, AssemblyId));
    g_pProfToEEInterface->SetCurrentPointerForDebugger(NULL, PT_MODULE);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// CLASS EVENTS
//

HRESULT EEToProfInterfaceImpl::ClassLoadStarted(
    ThreadID    threadId, 
	ClassID		classId)
{
	_ASSERTE(classId != 0);
    LOG((LF_CORPROF, LL_INFO100, "**PROF: ClassLoadStarted 0x%08x.\n", classId));
	return (g_pCallback->ClassLoadStarted(classId));
}


HRESULT EEToProfInterfaceImpl::ClassLoadFinished(
    ThreadID    threadId,
	ClassID		classId,
	HRESULT		hrStatus)
{
	_ASSERTE(classId != 0);
    LOG((LF_CORPROF, LL_INFO100, "**PROF: ClassLoadFinished 0x%08x, 0x%08x.\n", classId, hrStatus));
	return (g_pCallback->ClassLoadFinished(classId, hrStatus));
}


HRESULT EEToProfInterfaceImpl::ClassUnloadStarted( 
    ThreadID    threadId, 
    ClassID classId)
{
	_ASSERTE(classId != 0);
    LOG((LF_CORPROF, LL_INFO100, "**PROF: ClassUnloadStarted 0x%08x.\n", classId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ClassUnloadStarted(classId));
}


HRESULT EEToProfInterfaceImpl::ClassUnloadFinished( 
    ThreadID    threadId, 
    ClassID     classId,
    HRESULT     hrStatus)
{
	_ASSERTE(classId != 0);
    LOG((LF_CORPROF, LL_INFO100, "**PROF: ClassUnloadFinished 0x%08x, 0x%08x.\n", classId, hrStatus));
    GCTogglePre gc(threadId);
	return (g_pCallback->ClassUnloadFinished(classId, hrStatus));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// APPDOMAIN EVENTS
//

HRESULT EEToProfInterfaceImpl::AppDomainCreationStarted( 
    ThreadID    threadId, 
    AppDomainID appDomainId)
{
	_ASSERTE(appDomainId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AppDomainCreationStarted 0x%08x.\n", appDomainId));
	return (g_pCallback->AppDomainCreationStarted(appDomainId));
}


HRESULT EEToProfInterfaceImpl::AppDomainCreationFinished( 
    ThreadID    threadId, 
    AppDomainID appDomainId,
    HRESULT     hrStatus)
{
	_ASSERTE(appDomainId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AppDomainCreationFinished 0x%08x, 0x%08x.\n", appDomainId, hrStatus));
	return (g_pCallback->AppDomainCreationFinished(appDomainId, hrStatus));
}

HRESULT EEToProfInterfaceImpl::AppDomainShutdownStarted( 
    ThreadID    threadId, 
    AppDomainID appDomainId)
{
	_ASSERTE(appDomainId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AppDomainShutdownStarted 0x%08x.\n", appDomainId));
    GCTogglePre gc(threadId);
	return (g_pCallback->AppDomainShutdownStarted(appDomainId));
}

HRESULT EEToProfInterfaceImpl::AppDomainShutdownFinished( 
    ThreadID    threadId, 
    AppDomainID appDomainId,
    HRESULT     hrStatus)
{
	_ASSERTE(appDomainId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AppDomainShutdownFinished 0x%08x, 0x%08x.\n", appDomainId, hrStatus));
    GCTogglePre gc(threadId);
	return (g_pCallback->AppDomainShutdownFinished(appDomainId, hrStatus));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// ASSEMBLY EVENTS
//

HRESULT EEToProfInterfaceImpl::AssemblyLoadStarted( 
    ThreadID    threadId, 
    AssemblyID  assemblyId)
{
	_ASSERTE(assemblyId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AssemblyLoadStarted 0x%08x.\n", assemblyId));
    g_pProfToEEInterface->SetCurrentPointerForDebugger((void *)assemblyId, PT_ASSEMBLY);
	return (g_pCallback->AssemblyLoadStarted(assemblyId));
}

HRESULT EEToProfInterfaceImpl::AssemblyLoadFinished( 
    ThreadID    threadId, 
    AssemblyID  assemblyId,
    HRESULT     hrStatus)
{
	_ASSERTE(assemblyId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AssemblyLoadFinished 0x%08x, 0x%08x.\n", assemblyId, hrStatus));
	HRESULT hr = (g_pCallback->AssemblyLoadFinished(assemblyId, hrStatus));
    g_pProfToEEInterface->SetCurrentPointerForDebugger(NULL, PT_ASSEMBLY);
    return hr;
}

HRESULT EEToProfInterfaceImpl::AssemblyUnloadStarted( 
    ThreadID    threadId, 
    AssemblyID  assemblyId)
{
	_ASSERTE(assemblyId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AssemblyUnloadStarted 0x%08x.\n", assemblyId));
    GCTogglePre gc(threadId);
	return (g_pCallback->AssemblyUnloadStarted(assemblyId));
}

HRESULT EEToProfInterfaceImpl::AssemblyUnloadFinished( 
    ThreadID    threadId, 
    AssemblyID  assemblyId,
    HRESULT     hrStatus)
{
	_ASSERTE(assemblyId != 0);
    LOG((LF_CORPROF, LL_INFO10, "**PROF: AssemblyUnloadFinished 0x%08x, 0x%08x.\n", assemblyId, hrStatus));
    GCTogglePre gc(threadId);
	return (g_pCallback->AssemblyUnloadFinished(assemblyId, hrStatus));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// TRANSITION EVENTS
//

HRESULT EEToProfInterfaceImpl::UnmanagedToManagedTransition(
    FunctionID functionId,
    COR_PRF_TRANSITION_REASON reason)
{
    _ASSERTE(reason == COR_PRF_TRANSITION_CALL || reason == COR_PRF_TRANSITION_RETURN);

    LOG((LF_CORPROF, LL_INFO10000, "**PROF: UnmanagedToManagedTransition 0x%08x.\n", functionId));
    // Unnecessary to toggle GC, as it is guaranteed that preemptive GC is enabled for this call
    //GCTogglePre gc(threadId);

    // @TODO: When breaking changes are possible, reason will not be cast to a FunctionID
    return(g_pCallback->UnmanagedToManagedTransition(functionId, reason));
}

HRESULT EEToProfInterfaceImpl::ManagedToUnmanagedTransition(
    FunctionID functionId,
    COR_PRF_TRANSITION_REASON reason)
{
    _ASSERTE(reason == COR_PRF_TRANSITION_CALL || reason == COR_PRF_TRANSITION_RETURN);

    LOG((LF_CORPROF, LL_INFO10000, "**PROF: NotifyManagedToUnanagedTransition 0x%08x.\n", functionId));
    // Unnecessary to toggle GC, as it is guaranteed that preemptive GC is enabled for this call
    //GCTogglePre gc(threadId);

    // @TODO: When breaking changes are possible, reason will not be cast to a FunctionID
    return (g_pCallback->ManagedToUnmanagedTransition(functionId, reason));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// EXCEPTION EVENTS
//

HRESULT EEToProfInterfaceImpl::ExceptionThrown(
    ThreadID threadId,
    ObjectID thrownObjectId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionThrown. ObjectID: 0x%08x. ThreadID: 0x%08x\n",
         thrownObjectId, threadId));

    _ASSERTE(g_pInfo != NULL);

    DWORD dwMask;
    g_pInfo->GetEventMask(&dwMask);

    if (dwMask & COR_PRF_ENABLE_INPROC_DEBUGGING)
    {
        GCTogglePre gc(threadId);
        return (g_pCallback->ExceptionThrown(NULL));
    }
    else
    {
        return (g_pCallback->ExceptionThrown(thrownObjectId));
    }
}

HRESULT EEToProfInterfaceImpl::ExceptionSearchFunctionEnter(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionSearchFunctionEnter. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ExceptionSearchFunctionEnter(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionSearchFunctionLeave(
    ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionSearchFunctionLeave. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ExceptionSearchFunctionLeave());
}

HRESULT EEToProfInterfaceImpl::ExceptionSearchFilterEnter(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionSearchFilterEnter. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ExceptionSearchFilterEnter(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionSearchFilterLeave(
    ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionFilterLeave. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ExceptionSearchFilterLeave());
}

HRESULT EEToProfInterfaceImpl::ExceptionSearchCatcherFound(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionSearchCatcherFound. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->ExceptionSearchCatcherFound(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionOSHandlerEnter(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionOSHandlerEnter. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionOSHandlerEnter(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionOSHandlerLeave(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionOSHandlerLeave. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionOSHandlerLeave(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionUnwindFunctionEnter(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionUnwindFunctionEnter. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionUnwindFunctionEnter(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionUnwindFunctionLeave(
    ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionUnwindFunctionLeave. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionUnwindFunctionLeave());
}

HRESULT EEToProfInterfaceImpl::ExceptionUnwindFinallyEnter(
    ThreadID threadId,
    FunctionID functionId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionUnwindFinallyEnter. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionUnwindFinallyEnter(functionId));
}

HRESULT EEToProfInterfaceImpl::ExceptionUnwindFinallyLeave(
    ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionUnwindFinallyLeave. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionUnwindFinallyLeave());
}

HRESULT EEToProfInterfaceImpl::ExceptionCatcherEnter(
    ThreadID threadId,
    FunctionID functionId,
    ObjectID objectId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionCatcherEnter. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionCatcherEnter(functionId, objectId));
}

HRESULT EEToProfInterfaceImpl::ExceptionCatcherLeave(
    ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionCatcherLeave. ThreadID: 0x%08x\n", threadId));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionCatcherLeave());
}

HRESULT EEToProfInterfaceImpl::ExceptionCLRCatcherFound()
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionCLRCatcherFound"));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionCLRCatcherFound());
}

HRESULT EEToProfInterfaceImpl::ExceptionCLRCatcherExecute()
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ExceptionCLRCatcherExecute"));

    // NOTE: Cannot enable preemptive GC here, since the stack may not be in a GC-friendly state.
    //       Thus, the profiler cannot block on this call.

	return (g_pCallback->ExceptionCLRCatcherExecute());
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
// CCW EVENTS
//
HRESULT EEToProfInterfaceImpl::COMClassicVTableCreated( 
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable,
    /* [in] */ ULONG cSlots,
    /* [in] */ ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: COMClassicWrapperCreated %#x %#08x... %#x %d.\n", 
         wrappedClassId, implementedIID.Data1, pVTable, cSlots));
    
    // Someone's doing a forbid GC that prevents this
    // GCTogglePre gc(threadId);

    return (g_pCallback->COMClassicVTableCreated(wrappedClassId, implementedIID, pVTable, cSlots));
}

HRESULT EEToProfInterfaceImpl::COMClassicVTableDestroyed( 
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable,
    /* [in] */ ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: COMClassicWrapperDestroyed %#x %#08x... %#x.\n", 
         wrappedClassId, implementedIID.Data1, pVTable));
    
    // Someone's doing a forbid GC that prevents this
    // GCTogglePre gc(threadId);

    return (g_pCallback->COMClassicVTableDestroyed(wrappedClassId, implementedIID, pVTable));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// GC EVENTS
//

HRESULT EEToProfInterfaceImpl::RuntimeSuspendStarted(
    COR_PRF_SUSPEND_REASON suspendReason, ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: RuntimeSuspendStarted. ThreadID 0x%08x.\n", 
         threadId));
    
    return (g_pCallback->RuntimeSuspendStarted(suspendReason));
}

HRESULT EEToProfInterfaceImpl::RuntimeSuspendFinished(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: RuntimeSuspendFinished. ThreadID 0x%08x.\n", 
         threadId));
    
    return (g_pCallback->RuntimeSuspendFinished());
}

HRESULT EEToProfInterfaceImpl::RuntimeSuspendAborted(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: RuntimeSuspendAborted. ThreadID 0x%08x.\n", 
         threadId));
    
    return (g_pCallback->RuntimeSuspendAborted());
}

HRESULT EEToProfInterfaceImpl::RuntimeResumeStarted(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: RuntimeResumeStarted. ThreadID 0x%08x.\n", 
         threadId));
    
    return (g_pCallback->RuntimeResumeStarted());
}

HRESULT EEToProfInterfaceImpl::RuntimeResumeFinished(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO100, "**PROF: RuntimeResumeFinished. ThreadID 0x%08x.\n", 
         threadId));
    GCTogglePre gc(threadId);
    return (g_pCallback->RuntimeResumeFinished());
}

HRESULT EEToProfInterfaceImpl::RuntimeThreadSuspended(ThreadID suspendedThreadId,
                                                      ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RuntimeThreadSuspended. ThreadID 0x%08x.\n", 
         suspendedThreadId));
    
    return (g_pCallback->RuntimeThreadSuspended(suspendedThreadId));
}

HRESULT EEToProfInterfaceImpl::RuntimeThreadResumed(ThreadID resumedThreadId,
                                                    ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RuntimeThreadResumed. ThreadID 0x%08x.\n", 
         resumedThreadId));

    return (g_pCallback->RuntimeThreadResumed(resumedThreadId));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// REMOTING
//

HRESULT EEToProfInterfaceImpl::RemotingClientInvocationStarted(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingClientInvocationStarted. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingClientInvocationStarted());
}

HRESULT EEToProfInterfaceImpl::RemotingClientSendingMessage(ThreadID threadId, GUID *pCookie,
                                                            BOOL fIsAsync)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingClientSendingMessage. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingClientSendingMessage(pCookie, fIsAsync));
}

HRESULT EEToProfInterfaceImpl::RemotingClientReceivingReply(ThreadID threadId, GUID *pCookie,
                                                            BOOL fIsAsync)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingClientReceivingReply. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingClientReceivingReply(pCookie, fIsAsync));
}

HRESULT EEToProfInterfaceImpl::RemotingClientInvocationFinished(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingClientInvocationFinished. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingClientInvocationFinished());
}

HRESULT EEToProfInterfaceImpl::RemotingServerReceivingMessage(ThreadID threadId, GUID *pCookie,
                                                              BOOL fIsAsync)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingServerReceivingMessage. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingServerReceivingMessage(pCookie, fIsAsync));
}

HRESULT EEToProfInterfaceImpl::RemotingServerInvocationStarted(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingServerInvocationStarted. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingServerInvocationStarted());
}

HRESULT EEToProfInterfaceImpl::RemotingServerInvocationReturned(ThreadID threadId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingServerInvocationReturned. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingServerInvocationReturned());
}

HRESULT EEToProfInterfaceImpl::RemotingServerSendingReply(ThreadID threadId, GUID *pCookie,
                                                          BOOL fIsAsync)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: RemotingServerSendingReply. ThreadID: 0x%08x\n", threadId));
    GCTogglePre gc(threadId);
	return (g_pCallback->RemotingServerSendingReply(pCookie, fIsAsync));
}

HRESULT EEToProfInterfaceImpl::InitGUID()
{
    if (!m_pGUID)
    {
        m_pGUID = new GUID;
        if (!m_pGUID)
            return (E_OUTOFMEMORY);

        return (CoCreateGuid(m_pGUID));
    }

    return (S_OK);
}

void EEToProfInterfaceImpl::GetGUID(GUID *pGUID)
{
    _ASSERTE(m_pGUID && pGUID); // the member GUID and the argument should both be valid

    // Copy the contents of the template GUID
    memcpy(pGUID, m_pGUID, sizeof(GUID));

    // Adjust the last two bytes 
    pGUID->Data4[6] = (BYTE) GetCurrentThreadId();
    pGUID->Data4[7] = (BYTE) InterlockedIncrement((LPLONG)&m_lGUIDCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// GC EVENTS
//

HRESULT EEToProfInterfaceImpl::ObjectAllocated( 
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId)
{
    LOG((LF_CORPROF, LL_INFO1000, "**PROF: ObjectAllocated. ObjectID: 0x%08x.  ClassID: 0x%08x\n", objectId, classId));
	return (g_pCallback->ObjectAllocated(objectId, classId));
}


HRESULT EEToProfInterfaceImpl::MovedReference(BYTE *pbMemBlockStart,
                       BYTE *pbMemBlockEnd,
                       ptrdiff_t cbRelocDistance,
                       void *pHeapId)
{
    _ASSERTE(pHeapId);
    _ASSERTE(*((size_t *)pHeapId) != 0xFFFFFFFF);

    // Get a pointer to the data for this heap
    t_MovedReferencesData *pData = (t_MovedReferencesData *)(*((size_t *)pHeapId));

    // If this is the first notification of a moved reference for this heap
    // in this particular gc activation, then we need to get a ref data block
    // from the free list of blocks, or if that's empty then we need to
    // allocate a new one.
    if (pData == NULL)
    {
        // Lock for access to the free list
        m_critSecMovedRefsFL.Lock();

        if (m_pMovedRefDataFreeList == NULL)
        {
            // Unlock immediately, since we have no use for the free list and
            // we don't want to block anyone else.
            m_critSecMovedRefsFL.UnLock();

            // Allocate struct
            pData = new t_MovedReferencesData;
            if (!pData)
                return (E_OUTOFMEMORY);

        }

        // Otherwise, grab one from the list of free blocks
        else
        {
            // Get the first element from the free list
            pData = m_pMovedRefDataFreeList;
            m_pMovedRefDataFreeList = m_pMovedRefDataFreeList->pNext;

            // Done, let others in.
            m_critSecMovedRefsFL.UnLock();
        }

        // Now init the new block

        // Set our index to the beginning
        pData->curIdx = 0;

        // Set the cookie so that we will be provided it on subsequent
        // callbacks
        ((*((size_t *)pHeapId))) = (size_t)pData;
    }

    _ASSERTE(pData->curIdx >= 0 && pData->curIdx <= MAX_REFERENCES);

    // If the struct has been filled, then we need to notify the profiler of
    // these moved references and clear the struct for the next load of
    // moved references
    if (pData->curIdx == MAX_REFERENCES)
    {
        MovedReferences(pData);
        pData->curIdx = 0;
    }

    // Now save the information in the struct
    pData->arrpbMemBlockStartOld[pData->curIdx] = pbMemBlockStart;
    pData->arrpbMemBlockStartNew[pData->curIdx] = pbMemBlockStart + cbRelocDistance;
    pData->arrMemBlockSize[pData->curIdx] = pbMemBlockEnd - pbMemBlockStart;

    // Increment the index into the parallel arrays
    pData->curIdx += 1;

    return (S_OK);
}

HRESULT EEToProfInterfaceImpl::EndMovedReferences(void *pHeapId)
{
    _ASSERTE(pHeapId);
    _ASSERTE((*((size_t *)pHeapId)) != 0xFFFFFFFF);

    HRESULT hr = S_OK;

    // Get a pointer to the data for this heap
    t_MovedReferencesData *pData = (t_MovedReferencesData *)(*((size_t *)pHeapId));

    // If there were no moved references, profiler doesn't need to know
    if (!pData)
        return (S_OK);

    // Communicate the moved references to the profiler
    _ASSERTE(pData->curIdx> 0);
    hr = MovedReferences(pData);

    // Now we're done with the data block, we can shove it onto the free list
    m_critSecMovedRefsFL.Lock();
    pData->pNext = m_pMovedRefDataFreeList;
    m_pMovedRefDataFreeList = pData;
    m_critSecMovedRefsFL.UnLock();

#ifdef _DEBUG
    // Set the cookie to an invalid number
    (*((size_t *)pHeapId)) = 0xFFFFFFFF;
#endif // _DEBUG

    return (hr);
}

HRESULT EEToProfInterfaceImpl::MovedReferences(t_MovedReferencesData *pData)
{
    LOG((LF_CORPROF, LL_INFO10000, "**PROF: MovedReferences.\n"));

    return (g_pCallback->MovedReferences((ULONG)pData->curIdx,
                                               (ObjectID *)pData->arrpbMemBlockStartOld,
                                               (ObjectID *)pData->arrpbMemBlockStartNew,
                                               (ULONG *)pData->arrMemBlockSize));
}

HRESULT EEToProfInterfaceImpl::RootReference(ObjectID objId, void *pHeapId)
{
    _ASSERTE(pHeapId);
    _ASSERTE((*((size_t *)pHeapId)) != 0xFFFFFFFF);

    // Get a pointer to the data for this heap
    t_RootReferencesData *pData = (t_RootReferencesData *)(*((size_t *)pHeapId));

    // If this is the first notification of a root reference for this heap
    // in this particular gc activation, then we need to get a root data block
    // from the free list of blocks, or if that's empty then we need to
    // allocate a new one.
    if (pData == NULL)
    {
        // Lock for access to the free list
        m_critSecRootRefsFL.Lock();

        if (m_pRootRefDataFreeList == NULL)
        {
            // Unlock immediately, since we have no use for the free list and
            // we don't want to block anyone else.
            m_critSecRootRefsFL.UnLock();

            // Allocate struct
            pData = new t_RootReferencesData;
            if (!pData)
                return (E_OUTOFMEMORY);

        }

        // Otherwise, grab one from the list of free blocks
        else
        {
            // Get the first element from the free list
            pData = m_pRootRefDataFreeList;
            m_pRootRefDataFreeList = m_pRootRefDataFreeList->pNext;

            // Done, let others in.
            m_critSecRootRefsFL.UnLock();
        }

        // Now init the new block

        // Set our index to the beginning
        pData->curIdx = 0;

        // Set the cookie so that we will be provided it on subsequent
        // callbacks
        *((size_t *)pHeapId) = (size_t)pData;
    }

    _ASSERTE(pData->curIdx >= 0 && pData->curIdx <= MAX_ROOTS);

    // If the struct has been filled, then we need to notify the profiler of
    // these root references and clear the struct for the next load of
    // root references
    if (pData->curIdx == MAX_ROOTS)
    {
        RootReferences(pData);
        pData->curIdx = 0;
    }

    // Now save the information in the struct
    pData->arrRoot[pData->curIdx++] = objId;

    return (S_OK);
}

HRESULT EEToProfInterfaceImpl::EndRootReferences(void *pHeapId)
{
    _ASSERTE(pHeapId);
    _ASSERTE((*((size_t *)pHeapId)) != 0xFFFFFFFF);

    // Get a pointer to the data for this heap
    t_RootReferencesData *pData = (t_RootReferencesData *)(*((size_t *)pHeapId));

    // Notify the profiler
    HRESULT hr = RootReferences(pData);

    if (pData)
    {
        // Now we're done with the data block, we can shove it onto the free list
        m_critSecRootRefsFL.Lock();
        pData->pNext = m_pRootRefDataFreeList;
        m_pRootRefDataFreeList = pData;
        m_critSecRootRefsFL.UnLock();
    }

#ifdef _DEBUG
    // Set the cookie to an invalid number
    (*((size_t *)pHeapId)) = 0xFFFFFFFF;
#endif // _DEBUG

    return (hr);
}

HRESULT EEToProfInterfaceImpl::RootReferences(t_RootReferencesData *pData)
{
    LOG((LF_CORPROF, LL_INFO10000, "**PROF: RootReferences.\n"));
    
    if (pData)
        return (g_pCallback->RootReferences(pData->curIdx, (ObjectID *)pData->arrRoot));
    else
        return (g_pCallback->RootReferences(0, NULL));
}

#define HASH_ARRAY_SIZE_INITIAL 1024
#define HASH_ARRAY_SIZE_INC     256
#define HASH_NUM_BUCKETS        32
#define HASH(x)       ((x)%71)  // A simple hash function
HRESULT EEToProfInterfaceImpl::AllocByClass(ObjectID objId, ClassID clsId, void* pHeapId)
{
#ifdef _DEBUG
    // This is a slight attempt to make sure that this is never called in a multi-threaded
    // manner.  This heap walk should be done by one thread at a time only.
    static DWORD dwProcId = 0xFFFFFFFF;
#endif

    _ASSERTE(pHeapId != NULL);
    _ASSERTE((*((size_t *)pHeapId)) != 0xFFFFFFFF);

    // The heapId they pass in is really a t_AllocByClassData struct ptr.
    t_AllocByClassData *pData = (t_AllocByClassData *)(*((size_t *)pHeapId));

    // If it's null, need to allocate one
    if (pData == NULL)
    {
#ifdef _DEBUG
        // This is a slight attempt to make sure that this is never called in a multi-threaded
        // manner.  This heap walk should be done by one thread at a time only.
        dwProcId = GetCurrentProcessId();
#endif

        // See if we've saved a data block from a previous GC
        if (m_pSavedAllocDataBlock != NULL)
            pData = m_pSavedAllocDataBlock;

        // This means we need to allocate all the memory to keep track of the info
        else
        {
            // Get a new alloc data block
            pData = new t_AllocByClassData;
            if (pData == NULL)
                return (E_OUTOFMEMORY);

            // Create a new hash table
            pData->pHashTable = new CHashTableImpl(HASH_NUM_BUCKETS);
            if (!pData->pHashTable)
            {
                delete pData;
                return (E_OUTOFMEMORY);
            }

            // Get the memory for the array that the hash table is going to use
            pData->arrHash = (CLASSHASHENTRY *)malloc(HASH_ARRAY_SIZE_INITIAL * sizeof(CLASSHASHENTRY));
            if (pData->arrHash == NULL)
            {
                delete pData->pHashTable;
                delete pData;
                return (E_OUTOFMEMORY);
            }

            // Save the number of elements in the array
            pData->cHash = HASH_ARRAY_SIZE_INITIAL;

            // Now initialize the hash table
            HRESULT hr = pData->pHashTable->NewInit((BYTE *)pData->arrHash, sizeof(CLASSHASHENTRY));
            if (hr == E_OUTOFMEMORY)
            {
                free((void *)pData->arrHash);
                delete pData->pHashTable;
                delete pData;
                return (E_OUTOFMEMORY);
            }
            _ASSERTE(pData->pHashTable->IsInited());

            // Null some entries
            pData->arrClsId = NULL;
            pData->arrcObjects = NULL;
            pData->cLength = 0;

            // Hold on to the structure
            m_pSavedAllocDataBlock = pData;
        }

        // Got some memory and hash table to store entries, yay!
        *((size_t *)pHeapId) = (size_t)pData;

        // Initialize the data
        pData->iHash = 0;
        pData->pHashTable->Clear();
    }

    _ASSERTE(pData->iHash <= pData->cHash);
    _ASSERTE(dwProcId == GetCurrentProcessId());

    // Lookup to see if this class already has an entry
    CLASSHASHENTRY *pEntry = (CLASSHASHENTRY *)pData->pHashTable->Find(HASH((USHORT)clsId), (BYTE *)clsId);

    // If this class has already been encountered, just increment the counter.
    if (pEntry)
        pEntry->m_count++;

    // Otherwise, need to add this one as a new entry in the hash table
    else
    {
        // If we're full, we need to realloc
        if (pData->iHash == pData->cHash)
        {
            // Save the old memory pointer
            CLASSHASHENTRY *pOldArray = pData->arrHash;

            // Try to realloc the memory
            pData->arrHash = (CLASSHASHENTRY *) realloc((void *)pData->arrHash,
                                                        (pData->cHash + HASH_ARRAY_SIZE_INC) * sizeof(CLASSHASHENTRY));

            if (!pData->arrHash)
            {
                // Set it back to the old array
                pData->arrHash = pOldArray;
                return (E_OUTOFMEMORY);
            }

            // Tell the hash table that the memory location of the array has changed
            pData->pHashTable->SetTable((BYTE *)pData->arrHash);

            // Save the new size of the array
            pData->cHash += HASH_ARRAY_SIZE_INC;
        }

        // Now add the new entry
        CLASSHASHENTRY *pEntry = (CLASSHASHENTRY *) pData->pHashTable->Add(HASH((USHORT)clsId), pData->iHash++);

        pEntry->m_clsId = clsId;
        pEntry->m_count = 1;
    }

    // Indicate success
    return (S_OK);
}

HRESULT EEToProfInterfaceImpl::EndAllocByClass(void *pHeapId)
{
    _ASSERTE(pHeapId != NULL);
    _ASSERTE((*((size_t *)pHeapId)) != 0xFFFFFFFF);

    HRESULT hr = S_OK;

    t_AllocByClassData *pData = (t_AllocByClassData *)(*((size_t *)pHeapId));

    // Notify the profiler if there are elements to notify it of
    if (pData != NULL)
        hr = NotifyAllocByClass(pData);

#ifdef _DEBUG
    (*((size_t *)pHeapId)) = 0xFFFFFFFF;
#endif // _DEBUG

    return (hr);
}


HRESULT EEToProfInterfaceImpl::NotifyAllocByClass(t_AllocByClassData *pData)
{
    _ASSERTE(pData != NULL);
    _ASSERTE(pData->iHash > 0);

    // If the arrays are not long enough, get rid of them.
    if (pData->cLength != 0 && pData->iHash > pData->cLength)
    {
        _ASSERTE(pData->arrClsId != NULL && pData->arrcObjects != NULL);
        delete [] pData->arrClsId;
        delete [] pData->arrcObjects;
        pData->cLength = 0;
    }

    // If there are no arrays, must allocate them.
    if (pData->cLength == 0)
    {
        pData->arrClsId = new ClassID[pData->iHash];
        if (pData->arrClsId == NULL)
            return (E_OUTOFMEMORY);

        pData->arrcObjects = new ULONG[pData->iHash];
        if (pData->arrcObjects == NULL)
        {
            delete [] pData->arrClsId;
            pData->arrClsId= NULL;

            return (E_OUTOFMEMORY);
        }

        // Indicate that the memory was successfully allocated
        pData->cLength = pData->iHash;
    }

    // Now copy all the data
    HASHFIND hFind;
    CLASSHASHENTRY *pCur = (CLASSHASHENTRY *) pData->pHashTable->FindFirstEntry(&hFind);
    size_t iCur = 0;    // current index for arrays

    while (pCur != NULL)
    {
        _ASSERTE(iCur < pData->iHash);

        pData->arrClsId[iCur] = pCur->m_clsId;
        pData->arrcObjects[iCur] = pCur->m_count;

        // Move to the next entry
        iCur++;
        pCur = (CLASSHASHENTRY *) pData->pHashTable->FindNextEntry(&hFind);
    }

    _ASSERTE(iCur == pData->iHash);

    LOG((LF_CORPROF, LL_INFO10000, "**PROF: RootReferences.\n"));

    // Now communicate the results to the profiler
    return (g_pCallback->ObjectsAllocatedByClass(pData->iHash, pData->arrClsId, pData->arrcObjects));
}

HRESULT EEToProfInterfaceImpl::ObjectReference(ObjectID objId,
                                               ClassID clsId,
                                               ULONG cNumRefs,
                                               ObjectID *arrObjRef)
{
    // Notify the profiler of the object ref
    LOG((LF_CORPROF, LL_INFO100000, "**PROF: ObjectReferences.\n"));
    
    return g_pCallback->ObjectReferences(objId, clsId, cNumRefs, arrObjRef);
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\counters\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdio.h>

#include <Windows.h>
#include <WinWrap.h>
#include <cor.h>
#include <CorError.h>
#include <utilcode.h>

#ifdef _DEBUG
#define LOGGING
#endif

#include <log.h>


#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\info.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "StdAfx.h"
#include "Profile.h"
#include "CorProf.h"
#include "Cor.h"

//*****************************************************************************
//*****************************************************************************
CorProfInfo::CorProfInfo() : m_dwEventMask(COR_PRF_MONITOR_NONE),
    CorProfBase()
{
    g_pInfo = NULL;
}

//*****************************************************************************
//*****************************************************************************
CorProfInfo::~CorProfInfo()
{
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::QueryInterface(REFIID id, void **pInterface)
{
    if (pInterface == NULL)
        return (E_POINTER);

    if (id == IID_ICorProfilerInfo)
        *pInterface = (ICorProfilerInfo *)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown *)(ICorProfilerInfo *)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return (S_OK);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetClassFromObject( 
    /* [in] */ ObjectID objectId,
    /* [out] */ ClassID *pClassId)
{
    if (objectId == NULL)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetClassFromObject(objectId, pClassId));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetClassFromToken( 
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ClassID *pClassId)
{
    if (moduleId == NULL || typeDef == mdTypeDefNil || typeDef == NULL)
        return (E_INVALIDARG);

	return (g_pProfToEEInterface->GetClassFromToken(moduleId, typeDef, pClassId));

}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetCodeInfo( 
    /* [in] */ FunctionID functionId,
    /* [out] */ LPCBYTE *pStart,
    /* [out] */ ULONG *pcSize)
{
    if (functionId == NULL)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetCodeInfo(functionId, pStart, pcSize));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetEventMask( 
    /* [out] */ DWORD *pdwEvents)
{
    if (pdwEvents)
        *pdwEvents = m_dwEventMask;

    return (S_OK);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetFunctionFromIP( 
    /* [in] */ LPCBYTE ip,
    /* [out] */ FunctionID *pFunctionId)
{
    return (g_pProfToEEInterface->GetFunctionFromIP(ip, pFunctionId));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetFunctionFromToken( 
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdToken token,
    /* [out] */ FunctionID *pFunctionId)
{
    if (moduleId == NULL || token == mdTokenNil)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetFunctionFromToken(moduleId, token, pFunctionId));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetHandleFromThread( 
    /* [in] */ ThreadID threadId,
    /* [out] */ HANDLE *phThread)
{
    if (threadId == NULL)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetHandleFromThread(threadId, phThread));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetObjectSize( 
    /* [in] */ ObjectID objectId,
    /* [out] */ ULONG *pcSize)
{
    if (objectId == NULL)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetObjectSize(objectId, pcSize));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::IsArrayClass(
    /* [in] */  ClassID classId,
    /* [out] */ CorElementType *pBaseElemType,
    /* [out] */ ClassID *pBaseClassId,
    /* [out] */ ULONG   *pcRank)
{
    if (classId == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->IsArrayClass(classId, pBaseElemType, pBaseClassId, pcRank);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetThreadInfo( 
    /* [in] */ ThreadID threadId,
    /* [out] */ DWORD *pdwWin32ThreadId)
{
    if (threadId == NULL)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetThreadInfo(threadId, pdwWin32ThreadId));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetCurrentThreadID(
    /* [out] */ ThreadID *pThreadId)
{
    return (g_pProfToEEInterface->GetCurrentThreadID(pThreadId));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetClassIDInfo( 
    /* [in] */ ClassID classId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdTypeDef *pTypeDefToken)
{
    if (classId == NULL)
        return (E_INVALIDARG);

	return (g_pProfToEEInterface->GetClassIDInfo(classId, pModuleId, pTypeDefToken));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetFunctionInfo( 
    /* [in] */ FunctionID functionId,
    /* [out] */ ClassID  *pClassId,
	/* [out] */ ModuleID  *pModuleId,
    /* [out] */ mdToken  *pToken)
{
    if (functionId == NULL)
        return (E_INVALIDARG);

	return (g_pProfToEEInterface->GetFunctionInfo(functionId, pClassId, pModuleId, pToken));
}


//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::SetEventMask( 
    /* [in] */ DWORD dwEvents)
{
    // First make sure that the EE can accomodate the changes
    if (g_pProfToEEInterface->SetEventMask(dwEvents))
    {
        m_dwEventMask = dwEvents;
        return (S_OK);
    }

    return (E_FAIL);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::SetEnterLeaveFunctionHooks(FunctionEnter *pFuncEnter,
												   FunctionLeave *pFuncLeave,
												   FunctionTailcall *pFuncTailcall)
{
    if (pFuncEnter == NULL || pFuncLeave == NULL || pFuncTailcall == NULL)
        return (E_INVALIDARG);

	return (g_pProfToEEInterface->SetEnterLeaveFunctionHooks(pFuncEnter, pFuncLeave, pFuncTailcall));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::SetFunctionIDMapper(FunctionIDMapper *pFunc)
{
	return (g_pProfToEEInterface->SetFunctionIDMapper(pFunc));
}

//*****************************************************************************
// Need to return a metadata import scope for this method.  This amounts to
// finding the method desc behind this item, getting it's token, and then
// getting a metadata dispenser for it.
//*****************************************************************************
COM_METHOD CorProfInfo::GetTokenAndMetaDataFromFunction(
	FunctionID	functionId,
	REFIID		riid,
	IUnknown	**ppOut,
	mdToken		*pToken)
{
    if (functionId == NULL)
        return (E_INVALIDARG);

    return (g_pProfToEEInterface->GetTokenFromFunction(functionId, riid, ppOut, pToken));
}


//*****************************************************************************
// Retrieve information about a given module.
//*****************************************************************************
COM_METHOD CorProfInfo::GetModuleInfo(
	ModuleID	moduleId,
	LPCBYTE		*ppBaseLoadAddress,
	ULONG		cchName, 
	ULONG		*pcchName,
	WCHAR		szName[],
    AssemblyID  *pAssemblyId)
{
    if (moduleId == NULL)
        return (E_INVALIDARG);

	return g_pProfToEEInterface->GetModuleInfo(moduleId, ppBaseLoadAddress,
			cchName, pcchName, szName, pAssemblyId);
}


//*****************************************************************************
// Get a metadata interface insance which maps to the given module.
// One may ask for the metadata to be opened in read+write mode, but
// this will result in slower metadata execution of the program, because
// changes made to the metadata cannot be optimized as they were from
// the compiler.
//*****************************************************************************
COM_METHOD CorProfInfo::GetModuleMetaData(
	ModuleID	moduleId,
	DWORD		dwOpenFlags,
	REFIID		riid,
	IUnknown	**ppOut)
{
    if (moduleId == NULL)
        return (E_INVALIDARG);

    if (!(dwOpenFlags == ofRead || dwOpenFlags == ofWrite || dwOpenFlags == (ofRead | ofWrite)))
        return (E_INVALIDARG);

	return g_pProfToEEInterface->GetModuleMetaData(moduleId, dwOpenFlags,
			riid, ppOut);
}


//*****************************************************************************
// Retrieve a pointer to the body of a method starting at it's header.
// A method is coped by the module it lives in.  Because this function
// is designed to give a tool access to IL before it has been loaded
// by the Runtime, it uses the metadata token of the method to find
// the instance desired.  Note that this function has no effect on
// already compiled code.
//*****************************************************************************
COM_METHOD CorProfInfo::GetILFunctionBody(
	ModuleID	moduleId,
	mdMethodDef	methodId,
	LPCBYTE		*ppMethodHeader,
	ULONG		*pcbMethodSize)
{
    if (moduleId == NULL ||
        methodId == mdMethodDefNil ||
        methodId == 0 ||
        TypeFromToken(methodId) != mdtMethodDef)
        return (E_INVALIDARG);

	return g_pProfToEEInterface->GetILFunctionBody(moduleId, methodId,
				ppMethodHeader, pcbMethodSize);
}


//*****************************************************************************
// IL method bodies must be located as RVA's to the loaded module, which
// means they come after the module within 4 gb.  In order to make it
// easier for a tool to swap out the body of a method, this allocator
// will ensure memory allocated after that point.
//*****************************************************************************
COM_METHOD CorProfInfo::GetILFunctionBodyAllocator(
	ModuleID	moduleId,
	IMethodMalloc **ppMalloc)
{
    if (moduleId == NULL)
        return (E_INVALIDARG);

    if (ppMalloc)
	    return g_pProfToEEInterface->GetILFunctionBodyAllocator(moduleId, ppMalloc);
    else
        return (S_OK);
}


//*****************************************************************************
// Replaces the method body for a function in a module.  This will replace
// the RVA of the method in the metadata to point to this new method body,
// and adjust any internal data structures as required.  This function can
// only be called on those methods which have never been compiled by a JITTER.
// Please use the GetILFunctionBodyAllocator to allocate space for the new method to
// ensure the buffer is compatible.
//*****************************************************************************
COM_METHOD CorProfInfo::SetILFunctionBody(
	ModuleID	moduleId,
	mdMethodDef	methodId,
	LPCBYTE		pbNewILMethodHeader)
{
    if (moduleId == NULL ||
        methodId == mdMethodDefNil ||
        TypeFromToken(methodId) != mdtMethodDef ||
        pbNewILMethodHeader == NULL)
    {
        return (E_INVALIDARG);
    }

	return g_pProfToEEInterface->SetILFunctionBody(moduleId, methodId,
				pbNewILMethodHeader);
}


//*****************************************************************************
// Retrieve app domain information given its id.
//*****************************************************************************
COM_METHOD CorProfInfo::GetAppDomainInfo( 
    AppDomainID appDomainId,
    ULONG       cchName,
    ULONG       *pcchName,
    WCHAR       szName[  ],
    ProcessID   *pProcessId)
{
    if (appDomainId == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->GetAppDomainInfo(appDomainId, cchName, pcchName, szName, pProcessId);
}


//*****************************************************************************
// Retrieve information about an assembly given its ID.
//*****************************************************************************
COM_METHOD CorProfInfo::GetAssemblyInfo( 
    AssemblyID  assemblyId,
    ULONG       cchName,
    ULONG       *pcchName,
    WCHAR       szName[  ],
    AppDomainID *pAppDomainId,
    ModuleID    *pModuleId)
{
    if (assemblyId == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->GetAssemblyInfo(assemblyId, cchName, pcchName, szName, 
                             pAppDomainId, pModuleId);
}

//*****************************************************************************
// Marks a function as requiring a re-JIT.  The function will be re-JITted
// at its next invocation.  The normal profiller events will give the profiller
// an opportunity to replace the IL prior to the JIT.  By this means, a tool
// can effectively replace a function at runtime.  Note that active instances
// of the function are not affected by the replacement.
//*****************************************************************************
COM_METHOD CorProfInfo::SetFunctionReJIT(
    FunctionID functionId)
{
    if (functionId == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->SetFunctionReJIT(functionId);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::SetILInstrumentedCodeMap(
        FunctionID functionId,
        BOOL fStartJit,
        ULONG cILMapEntries,
        COR_IL_MAP rgILMapEntries[])
{
    if (functionId == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->SetILInstrumentedCodeMap(functionId,
                                                          fStartJit,
                                                          cILMapEntries,
                                                          rgILMapEntries);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::ForceGC()
{
    return g_pProfToEEInterface->ForceGC();
}

/*
 * GetInprocInspectionInterface is used to get an interface to the
 * in-process portion of the debug interface, which is useful for things
 * like doing a stack trace.
 *
 * ppicd: *ppicd will be filled in with a pointer to the interface, or
 *          NULL if the interface is unavailable.
 */
COM_METHOD CorProfInfo::GetInprocInspectionInterface(
        IUnknown **ppicd)
{
    if (ppicd)
        return ForwardInprocInspectionRequestToEE(ppicd, false);
    else
        return (S_OK);
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetInprocInspectionIThisThread(
        IUnknown **ppicd)
{
    if (ppicd)
        return ForwardInprocInspectionRequestToEE(ppicd, true);
    else
        return (S_OK);
}

//*****************************************************************************
//*****************************************************************************
HRESULT inline CorProfInfo::ForwardInprocInspectionRequestToEE(IUnknown **ppicd, bool fThisThread)
{
    return (g_pProfToEEInterface->GetInprocInspectionInterfaceFromEE(ppicd, fThisThread));
}

//*****************************************************************************
//*****************************************************************************
COM_METHOD CorProfInfo::GetThreadContext(
    ThreadID threadId,
    ContextID *pContextId)
{
    if (threadId == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->GetThreadContext(threadId, pContextId);
}

//*****************************************************************************
// The profiler MUST call this function before using the in-process debugging
// APIs.  fThisThreadOnly indicates whether in-proc debugging will be used to
// trace the stack of the current managed thread only, or whether it might be
// used to trace the stack of any managed thread.
//*****************************************************************************
COM_METHOD CorProfInfo::BeginInprocDebugging(BOOL fThisThreadOnly, DWORD *pdwProfilerContext)
{
    if (pdwProfilerContext == NULL)
        return (E_INVALIDARG);

    return g_pProfToEEInterface->BeginInprocDebugging(fThisThreadOnly, pdwProfilerContext);
}

//*****************************************************************************
// The profiler MUST call this function when it is done using the in-process
// debugging APIs.  Failing to do so will result in undefined behaviour of
// the runtime.
//*****************************************************************************
COM_METHOD CorProfInfo::EndInprocDebugging(DWORD dwProfilerContext)
{
    return g_pProfToEEInterface->EndInprocDebugging(dwProfilerContext);
}
COM_METHOD CorProfInfo::GetILToNativeMapping(
            /* [in] */  FunctionID functionId,
            /* [in] */  ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [out, size_is(cMap), length_is(*pcMap)] */
                COR_DEBUG_IL_TO_NATIVE_MAP map[])
{
    if (functionId == NULL)
        return (E_INVALIDARG);

    if (cMap > 0 && (!pcMap || !map))
        return (E_INVALIDARG);

    return g_pProfToEEInterface->GetILToNativeMapping(functionId, cMap, pcMap, map);
}


#ifdef __ICECAP_HACK__
//*****************************************************************************
// Turn a function ID into it's mapped it.
//*****************************************************************************
COM_METHOD CorProfInfo::GetProfilingHandleForFunctionId(
	FunctionID	functionId,
	UINT_PTR	*pProfilingHandle)
{
	HRESULT		hr;
    if (functionId == 0)
		hr = E_INVALIDARG;
	else
		hr = g_pProfToEEInterface->GetProfilingHandle(functionId, pProfilingHandle);
	return (hr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\eetoprofinterfaceimpl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#ifndef __EETOPROFINTERFACEIMPL_H__
#define __EETOPROFINTERFACEIMPL_H__

#include <stddef.h>
#include "ProfilePriv.h"
#include "Profile.h"
#include "utsem.h"
#include "EEProfInterfaces.h"

class EEToProfInterfaceImpl : public EEToProfInterface
{
public:
    EEToProfInterfaceImpl();

    HRESULT Init();

    void Terminate(BOOL fProcessDetach);

    // This is called by the EE if the profiling bit is set.
    HRESULT CreateProfiler(
        WCHAR       *wszCLSID);

//////////////////////////////////////////////////////////////////////////
// Thread Events
//
    
    HRESULT ThreadCreated(
        ThreadID    threadID);
    
    HRESULT ThreadDestroyed(
        ThreadID    threadID);

    HRESULT ThreadAssignedToOSThread(ThreadID managedThreadId,
                                           DWORD osThreadId);

//////////////////////////////////////////////////////////////////////////
// Startup/Shutdown Events
//
    
    HRESULT Shutdown(
        ThreadID    threadID);

//////////////////////////////////////////////////////////////////////////
// JIT/Function Events
//
    
    HRESULT FunctionUnloadStarted(
        ThreadID    threadID,
        FunctionID  functionId);

	HRESULT JITCompilationFinished(
        ThreadID    threadID, 
        FunctionID  functionId, 
        HRESULT     hrStatus,
        BOOL        fIsSafeToBlock);

    HRESULT JITCompilationStarted(
        ThreadID    threadId, 
        FunctionID  functionId,
        BOOL        fIsSafeToBlock);
	
	HRESULT JITCachedFunctionSearchStarted(
		/* [in] */	ThreadID threadId,
        /* [in] */  FunctionID functionId,
		/* [out] */ BOOL *pbUseCachedFunction);

	HRESULT JITCachedFunctionSearchFinished(
		/* [in] */	ThreadID threadId,
		/* [in] */  FunctionID functionId,
		/* [in] */  COR_PRF_JIT_CACHE result);

    HRESULT JITFunctionPitched(ThreadID threadId,
                               FunctionID functionId);

    HRESULT JITInlining(
        /* [in] */  ThreadID      threadId,
        /* [in] */  FunctionID    callerId,
        /* [in] */  FunctionID    calleeId,
        /* [out] */ BOOL         *pfShouldInline);

//////////////////////////////////////////////////////////////////////////
// Module Events
//
    
	HRESULT ModuleLoadStarted(
        ThreadID    threadID, 
        ModuleID    moduleId);

	HRESULT ModuleLoadFinished(
        ThreadID    threadID, 
		ModuleID	moduleId, 
		HRESULT		hrStatus);
	
	HRESULT ModuleUnloadStarted(
        ThreadID    threadID, 
        ModuleID    moduleId);

	HRESULT ModuleUnloadFinished(
        ThreadID    threadID, 
		ModuleID	moduleId, 
		HRESULT		hrStatus);
    
    HRESULT ModuleAttachedToAssembly( 
        ThreadID    threadID, 
        ModuleID    moduleId,
        AssemblyID  AssemblyId);

//////////////////////////////////////////////////////////////////////////
// Class Events
//
    
	HRESULT ClassLoadStarted(
        ThreadID    threadID, 
		ClassID		classId);

	HRESULT ClassLoadFinished(
        ThreadID    threadID, 
		ClassID		classId,
		HRESULT		hrStatus);

	HRESULT ClassUnloadStarted( 
        ThreadID    threadID, 
		ClassID classId);

	HRESULT ClassUnloadFinished( 
        ThreadID    threadID, 
		ClassID classId,
		HRESULT hrStatus);

//////////////////////////////////////////////////////////////////////////
// AppDomain Events
//
    
    HRESULT AppDomainCreationStarted( 
        ThreadID    threadId, 
        AppDomainID appDomainId);
    
    HRESULT AppDomainCreationFinished( 
        ThreadID    threadId, 
        AppDomainID appDomainId,
        HRESULT     hrStatus);
    
    HRESULT AppDomainShutdownStarted( 
        ThreadID    threadId, 
        AppDomainID appDomainId);
    
    HRESULT AppDomainShutdownFinished( 
        ThreadID    threadId, 
        AppDomainID appDomainId,
        HRESULT     hrStatus);

//////////////////////////////////////////////////////////////////////////
// Assembly Events
//

    HRESULT AssemblyLoadStarted( 
        ThreadID    threadId, 
        AssemblyID  assemblyId);
    
    HRESULT AssemblyLoadFinished( 
        ThreadID    threadId, 
        AssemblyID  assemblyId,
        HRESULT     hrStatus);
    
    HRESULT AssemblyUnloadStarted( 
        ThreadID    threadId, 
        AssemblyID  assemblyId);
    
    HRESULT AssemblyUnloadFinished( 
        ThreadID    threadId, 
        AssemblyID  assemblyId,
        HRESULT     hrStatus);

//////////////////////////////////////////////////////////////////////////
// Transition Events
//

    HRESULT UnmanagedToManagedTransition(
        FunctionID functionId,
        COR_PRF_TRANSITION_REASON reason);

    HRESULT ManagedToUnmanagedTransition(
        FunctionID functionId,
        COR_PRF_TRANSITION_REASON reason);

//////////////////////////////////////////////////////////////////////////
// Exception Events
//

    HRESULT ExceptionThrown(
        ThreadID threadId,
        ObjectID thrownObjectId);

    HRESULT ExceptionSearchFunctionEnter(
        ThreadID threadId,
        FunctionID functionId);

    HRESULT ExceptionSearchFunctionLeave(
        ThreadID threadId);

    HRESULT ExceptionSearchFilterEnter(
        ThreadID threadId,
        FunctionID funcId);

    HRESULT ExceptionSearchFilterLeave(
        ThreadID threadId);

    HRESULT ExceptionSearchCatcherFound(
        ThreadID threadId,
        FunctionID functionId);

    HRESULT ExceptionOSHandlerEnter(
        ThreadID threadId,
        FunctionID funcId);

    HRESULT ExceptionOSHandlerLeave(
        ThreadID threadId,
        FunctionID funcId);

    HRESULT ExceptionUnwindFunctionEnter(
        ThreadID threadId,
        FunctionID functionId);

    HRESULT ExceptionUnwindFunctionLeave(
        ThreadID threadId);
    
    HRESULT ExceptionUnwindFinallyEnter(
        ThreadID threadId,
        FunctionID functionId);

    HRESULT ExceptionUnwindFinallyLeave(
        ThreadID threadId);
    
    HRESULT ExceptionCatcherEnter(
        ThreadID threadId,
        FunctionID functionId,
        ObjectID objectId);

    HRESULT ExceptionCatcherLeave(
        ThreadID threadId);

    HRESULT ExceptionCLRCatcherFound();

    HRESULT ExceptionCLRCatcherExecute();

//////////////////////////////////////////////////////////////////////////
// CCW Events
//

    HRESULT COMClassicVTableCreated( 
        /* [in] */ ClassID wrappedClassId,
        /* [in] */ REFGUID implementedIID,
        /* [in] */ void *pVTable,
        /* [in] */ ULONG cSlots,
        /* [in] */ ThreadID threadId);
    
    HRESULT COMClassicVTableDestroyed( 
        /* [in] */ ClassID wrappedClassId,
        /* [in] */ REFGUID implementedIID,
        /* [in] */ void *pVTable,
        /* [in] */ ThreadID threadId);

//////////////////////////////////////////////////////////////////////////
// Remoting Events
//

    HRESULT RemotingClientInvocationStarted(ThreadID threadId);
    
    HRESULT RemotingClientSendingMessage(ThreadID threadId, GUID *pCookie,
                                         BOOL fIsAsync);

    HRESULT RemotingClientReceivingReply(ThreadID threadId, GUID *pCookie,
                                         BOOL fIsAsync);
    
    HRESULT RemotingClientInvocationFinished(ThreadID threadId);

    HRESULT RemotingServerReceivingMessage(ThreadID threadId, GUID *pCookie,
                                           BOOL fIsAsync);
    
    HRESULT RemotingServerInvocationStarted(ThreadID threadId);

    HRESULT RemotingServerInvocationReturned(ThreadID threadId);
    
    HRESULT RemotingServerSendingReply(ThreadID threadId, GUID *pCookie,
                                       BOOL fIsAsync);

private:
    // This is used as a cookie template for remoting calls
    GUID *m_pGUID;

    // This is an incrementing counter for constructing unique GUIDS from
    // m_pGUID
    LONG m_lGUIDCount;

public:
    // This fills in the non call-specific portions of the cookie GUID.
    // This should only be called once at startup if necessary.
    HRESULT InitGUID();

    // This will assign a mostly-unique GUID.  If enough calls to GetGUID
    // are made from the same thread, then the GUIDs will cycle.
    // (Current, it will cycle every 256 calls)
    void GetGUID(GUID *pGUID);

//////////////////////////////////////////////////////////////////////////
// GC Events
//

    HRESULT RuntimeSuspendStarted(COR_PRF_SUSPEND_REASON suspendReason,
                                  ThreadID threadId);
    
    HRESULT RuntimeSuspendFinished(ThreadID threadId);
    
    HRESULT RuntimeSuspendAborted(ThreadID threadId);
    
    HRESULT RuntimeResumeStarted(ThreadID threadId);
    
    HRESULT RuntimeResumeFinished(ThreadID threadId);

    HRESULT RuntimeThreadSuspended(ThreadID suspendedThreadId,
                                   ThreadID threadId);

    HRESULT RuntimeThreadResumed(ThreadID resumedThreadId,
                                 ThreadID threadid);

    HRESULT ObjectAllocated( 
        /* [in] */ ObjectID objectId,
        /* [in] */ ClassID classId);

/*
 * GC Moved References Notification Stuff
 */
private:
    #define MAX_REFERENCES 512

    struct t_MovedReferencesData
    {
        size_t curIdx;
        BYTE *arrpbMemBlockStartOld[MAX_REFERENCES];
        BYTE *arrpbMemBlockStartNew[MAX_REFERENCES];
        size_t arrMemBlockSize[MAX_REFERENCES];
        t_MovedReferencesData *pNext;
    };

    // This will contain a list of free ref data structs, so they
    // don't have to be re-allocated on every GC
    struct t_MovedReferencesData *m_pMovedRefDataFreeList;

    // This is for managing access to the free list above.
    CSemExclusive m_critSecMovedRefsFL;

    HRESULT MovedReferences(t_MovedReferencesData *pData);

public:
    HRESULT MovedReference(BYTE *pbMemBlockStart,
                           BYTE *pbMemBlockEnd,
                           ptrdiff_t cbRelocDistance,
                           void *pHeapId);

    HRESULT EndMovedReferences(void *pHeapId);

/*
 * GC Root notification stuff
 */
private:
    #define MAX_ROOTS 508

    // This contains the data for a bunch of roots for a particular heap
    // during a particular run of gc.
    struct t_RootReferencesData
    {
        size_t                  curIdx;
        ObjectID                arrRoot[MAX_ROOTS];
        t_RootReferencesData    *pNext;
    };

    // This will contain a list of free ref data structs, so they
    // don't have to be re-allocated on every GC
    struct t_RootReferencesData *m_pRootRefDataFreeList;

    // This is for managing access to the free list above.
    CSemExclusive m_critSecRootRefsFL;

    HRESULT RootReferences(t_RootReferencesData *pData);

public:
    HRESULT RootReference(ObjectID objId, void *pHeapId);

    HRESULT EndRootReferences(void *pHeapId);

/*
 * Generation 0 Allocation by Class notification stuff
 */
private:
    // This is for a hashing of ClassID values
    struct CLASSHASHENTRY : HASHENTRY
    {
        ClassID         m_clsId;        // The class ID (also the key)
        size_t          m_count;        // How many of this class have been counted
    };
    
    // This is a simple implementation of CHashTable to provide a very simple
    // implementation of the Cmp pure virtual function
    class CHashTableImpl : public CHashTable
    {
    public:
        CHashTableImpl(USHORT iBuckets) : CHashTable(iBuckets) {}

    protected:
        virtual BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
        {
            ClassID key = (ClassID) pc1;
            ClassID val = ((CLASSHASHENTRY *)pc2)->m_clsId;

            return (key != val);
        }
    };

    // This contains the data for storing allocation information
    // in terms of numbers of objects sorted by class.
    struct t_AllocByClassData
    {
        CHashTableImpl     *pHashTable;     // The hash table
        CLASSHASHENTRY     *arrHash;        // Array that the hashtable uses for linking
        size_t             cHash;           // The total number of elements in arrHash
        size_t             iHash;           // Next empty entry in the hash array
        ClassID            *arrClsId;       // Array of ClassIDs for the call to ObjectsAllocatedByClass
        ULONG              *arrcObjects;    // Array of counts for the call to ObjectsAllocatedByClass
        size_t             cLength;         // Length of the above two parallel arrays
    };

    // Since this stuff can only be performed by one thread (right now), we don't need
    // to make this thread safe and can just have one block we reuse every time around
    static t_AllocByClassData *m_pSavedAllocDataBlock;

    HRESULT NotifyAllocByClass(t_AllocByClassData *pData);

public:
    HRESULT AllocByClass(ObjectID objId, ClassID clsId, void* pHeapId);

    HRESULT EndAllocByClass(void *pHeapId);

/*
 * Heap walk notification stuff
 */
    HRESULT ObjectReference(ObjectID objId,
                            ClassID clsId,
                            ULONG cNumRefs,
                            ObjectID *arrObjRef);
};

#endif // __EETOPROFINTERFACEIMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\profile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#ifndef __PROFILE_H__
#define __PROFILE_H__

#include <Windows.h>

#include "corprof.h"
#include "EEProfInterfaces.h"

#define COM_METHOD HRESULT STDMETHODCALLTYPE

class CorProfInfo;

extern ProfToEEInterface    *g_pProfToEEInterface;
extern ICorProfilerCallback *g_pCallback;
extern CorProfInfo          *g_pInfo;

class CorProfBase : public IUnknown
{
public:
    CorProfBase() : m_refCount(0)
    {
    }

    virtual ~CorProfBase() {}

    ULONG STDMETHODCALLTYPE BaseAddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE BaseRelease() 
    {
        long refCount = InterlockedDecrement((long *) &m_refCount);

        if (refCount == 0)
            delete this;

        return (refCount);
    }

private:
    // For ref counting of COM objects
    ULONG m_refCount;

};

class CorProfInfo : public CorProfBase, public ICorProfilerInfo
{
public:

    /*********************************************************************
     * Ctor/Dtor
     */
    CorProfInfo();

    virtual ~CorProfInfo();

    /*********************************************************************
     * IUnknown support
     */

    COM_METHOD QueryInterface(REFIID id, void **pInterface);

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    
    /*********************************************************************
     * ICorProfilerInfo support
     */
    COM_METHOD GetClassFromObject( 
        /* [in] */ ObjectID objectId,
        /* [out] */ ClassID *pClassId);

    COM_METHOD GetClassFromToken( 
        /* [in] */ ModuleID moduleId,
        /* [in] */ mdTypeDef typeDef,
        /* [out] */ ClassID *pClassId);
    
    COM_METHOD GetCodeInfo( 
        /* [in] */ FunctionID functionId,
        /* [out] */ LPCBYTE *pStart,
        /* [out] */ ULONG *pcSize);
    
    COM_METHOD GetEventMask( 
        /* [out] */ DWORD *pdwEvents);
    
    COM_METHOD GetFunctionFromIP( 
        /* [in] */ LPCBYTE ip,
        /* [out] */ FunctionID *pFunctionId);
    
    COM_METHOD GetFunctionFromToken( 
        /* [in] */ ModuleID ModuleId,
        /* [in] */ mdToken token,
        /* [out] */ FunctionID *pFunctionId);
    
    /* [local] */ COM_METHOD GetHandleFromThread( 
        /* [in] */ ThreadID ThreadID,
        /* [out] */ HANDLE *phThread);
    
    COM_METHOD GetObjectSize( 
        /* [in] */ ObjectID objectId,
        /* [out] */ ULONG *pcSize);
    
    COM_METHOD IsArrayClass(
        /* [in] */  ClassID classId,
        /* [out] */ CorElementType *pBaseElemType,
        /* [out] */ ClassID *pBaseClassId,
        /* [out] */ ULONG   *pcRank);
    
    COM_METHOD GetThreadInfo( 
        /* [in] */ ThreadID threadId,
        /* [out] */ DWORD *pdwWin32ThreadId);

	COM_METHOD GetCurrentThreadID(
        /* [out] */ ThreadID *pThreadId);


    COM_METHOD GetClassIDInfo( 
        /* [in] */ ClassID classId,
        /* [out] */ ModuleID  *pModuleId,
        /* [out] */ mdTypeDef  *pTypeDefToken);

    COM_METHOD GetFunctionInfo( 
        /* [in] */ FunctionID functionId,
        /* [out] */ ClassID  *pClassId,
        /* [out] */ ModuleID  *pModuleId,
        /* [out] */ mdToken  *pToken);
    
    COM_METHOD SetEventMask( 
        /* [in] */ DWORD dwEvents);

	COM_METHOD SetEnterLeaveFunctionHooks(
		/* [in] */ FunctionEnter *pFuncEnter,
		/* [in] */ FunctionLeave *pFuncLeave,
		/* [in] */ FunctionTailcall *pFuncTailcall);

	COM_METHOD SetFunctionIDMapper(
		/* [in] */ FunctionIDMapper *pFunc);
    
    COM_METHOD SetILMapFlag();

    COM_METHOD GetTokenAndMetaDataFromFunction(
		FunctionID	functionId,
		REFIID		riid,
		IUnknown	**ppImport,
		mdToken		*pToken);

	COM_METHOD GetModuleInfo(
		ModuleID	moduleId,
		LPCBYTE		*ppBaseLoadAddress,
		ULONG		cchName, 
		ULONG		*pcchName,
		WCHAR		szName[],
        AssemblyID  *pAssemblyId);

	COM_METHOD GetModuleMetaData(
		ModuleID	moduleId,
		DWORD		dwOpenFlags,
		REFIID		riid,
		IUnknown	**ppOut);

	COM_METHOD GetILFunctionBody(
		ModuleID	moduleId,
		mdMethodDef	methodid,
		LPCBYTE		*ppMethodHeader,
		ULONG		*pcbMethodSize);

	COM_METHOD GetILFunctionBodyAllocator(
		ModuleID	moduleId,
		IMethodMalloc **ppMalloc);

	COM_METHOD SetILFunctionBody(
		ModuleID	moduleId,
		mdMethodDef	methodid,
		LPCBYTE		pbNewILMethodHeader);
    
    COM_METHOD GetAppDomainInfo( 
        AppDomainID appDomainId,
        ULONG       cchName,
        ULONG       *pcchName,
        WCHAR       szName[  ],
        ProcessID   *pProcessId);

    COM_METHOD GetAssemblyInfo( 
        AssemblyID  assemblyId,
        ULONG     cchName,
        ULONG     *pcchName,
        WCHAR       szName[  ],
        AppDomainID *pAppDomainId,
        ModuleID    *pModuleId);

	COM_METHOD SetFunctionReJIT(
		FunctionID	functionId);

    COM_METHOD SetILInstrumentedCodeMap(
        FunctionID functionID,
        BOOL fStartJit,
        ULONG cILMapEntries,
        COR_IL_MAP rgILMapEntries[]);

    COM_METHOD ForceGC();

    COM_METHOD GetInprocInspectionInterface(
        IUnknown **ppicd);

    COM_METHOD GetInprocInspectionIThisThread(
        IUnknown **ppicd);

    COM_METHOD GetThreadContext(
        ThreadID threadId,
        ContextID *pContextId);

    COM_METHOD BeginInprocDebugging(
        BOOL   fThisThreadOnly,
        DWORD *pdwProfilerContext);

    COM_METHOD EndInprocDebugging(
        DWORD  dwProfilerContext);
        
    COM_METHOD GetILToNativeMapping(
                /* [in] */  FunctionID functionId,
                /* [in] */  ULONG32 cMap,
                /* [out] */ ULONG32 *pcMap,
                /* [out, size_is(cMap), length_is(*pcMap)] */
                    COR_DEBUG_IL_TO_NATIVE_MAP map[]);

#ifdef __ICECAP_HACK__
	COM_METHOD GetProfilingHandleForFunctionId(
		FunctionID	functionId,
		UINT_PTR	*pProfilingHandle);
#endif

private:
    HRESULT ForwardInprocInspectionRequestToEE(IUnknown **ppicd, 
                                               bool fThisThread);

    DWORD m_dwEventMask;
};

/*
 * This will attempt to CoCreate a profiler, if one has been registered.
 */
HRESULT CoCreateProfiler(WCHAR *wszCLSID, ICorProfilerCallback **ppCallback);

#endif //__PROFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\profile.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "StdAfx.h"
#include "EEProfInterfaces.h"
#include "EEToProfInterfaceImpl.h"
#include "CorProf.h"

ProfToEEInterface    *g_pProfToEEInterface = NULL;
ICorProfilerCallback *g_pCallback          = NULL;
CorProfInfo          *g_pInfo              = NULL;

/*
 * GetEEProfInterface is used to get the interface with the profiler code.
 */
void __cdecl GetEEToProfInterface(EEToProfInterface **ppEEProf)
{
    InitializeLogging();

    LOG((LF_CORPROF, LL_INFO10, "**PROF: EE has requested interface to "
         "profiling code.\n"));
    
    // Check if we're given a bogus pointer
    if (ppEEProf == NULL)
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: EE provided invalid pointer.  "
             "%s::%d.\n", __FILE__, __LINE__));
        return;
    }

    // Initial value
    *ppEEProf = NULL;

    // Create a new Impl object and cast it to the virtual class type
    EEToProfInterface *pEEProf =
        (EEToProfInterface *) new EEToProfInterfaceImpl();
    
    _ASSERTE(pEEProf != NULL);

    // If we succeeded, send it back
    if (pEEProf != NULL)
        if (SUCCEEDED(pEEProf->Init()))
            *ppEEProf = pEEProf;
        else
            delete pEEProf;

    return;
}

/*
 * SetProfEEInterface is used to provide the profiler code with an interface
 * to the profiler.
 */
void __cdecl SetProfToEEInterface(ProfToEEInterface *pProfEE)
{
    InitializeLogging();

    LOG((LF_CORPROF, LL_INFO10, "**PROF: Profiling code being provided with EE interface.\n"));

    // Save the pointer
    g_pProfToEEInterface = pProfEE;

    return;
}

/*
 * This will attempt to CoCreate all registered profilers
 */
HRESULT CoCreateProfiler(WCHAR *wszCLSID, ICorProfilerCallback **ppCallback)
{
    LOG((LF_CORPROF, LL_INFO10, "**PROF: Entered CoCreateProfiler.\n"));

    HRESULT hr;

    // Translate the string into a CLSID
    CLSID clsid;
	if (*wszCLSID == L'{')
		hr = CLSIDFromString(wszCLSID, &clsid);
	else
	{
		WCHAR *szFrom, *szTo;
		for (szFrom=szTo=wszCLSID;  *szFrom;  )
		{
			if (*szFrom == L'"')
			{
				++szFrom;
				continue;
			}
			*szTo++ = *szFrom++;
		}
		*szTo = 0;
		hr = CLSIDFromProgID(wszCLSID, &clsid);
	}

#ifdef LOGGING
    if (hr == E_INVALIDARG || hr == CO_E_CLASSSTRING || hr == REGDB_E_WRITEREGDB)
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: Invalid CLSID or ProgID. %s::%d\n",
             __FILE__, __LINE__));
    }
#endif

    if (FAILED(hr))
        return (hr);

    // Create an instance of the profiler
    hr = FakeCoCreateInstance(clsid, IID_ICorProfilerCallback, (LPVOID *)ppCallback);

   _ASSERTE(hr!=CLASS_E_NOAGGREGATION);

#ifdef LOGGING
    if (hr == REGDB_E_CLASSNOTREG)
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: Profiler class %S not "
             "registered.\n", wszCLSID));
    }
#endif

    // Return the result of the CoCreateInstance operation
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\ee\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdio.h>

#include <Windows.h>
#include <WinWrap.h>
#include <cor.h>
#include <CorError.h>
#include <utilcode.h>

#ifdef _DEBUG
#define LOGGING
#endif

#include <log.h>

#include "profile.h"
#include "corprof.h"

#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************

#ifndef __ClassFactory__h__
#define __ClassFactory__h__

#include <CorProf.h>						// Public header definitions.

// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};

//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}

	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);

private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};

#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\classfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"
#include "ClassFactory.h"
#include "mscorcap.h"
#include "UtilCode.h"

// Registration Information
#define REGKEY_THIS_PROFILER_NAME		L"Common Language Runtime IceCap Profiler"
#define REGKEY_ENTIRE					PROFILER_REGKEY_ROOT L"\\" REGKEY_THIS_PROFILER_NAME

#define REGVALUE_THIS_PROFID			L"CLRIcecapProfile.CorIcecapProfiler"
#define REGVALUE_THIS_HELPSTRING		L"The Common Language Runtime profiler to hook with IceCap"

// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();


//********** Globals. *********************************************************

static const LPCWSTR g_szCoclassDesc	= L"Microsoft Common Language Runtime Icecap Profiler";
static const LPCWSTR g_szProgIDPrefix	= L"CLRIcecapProfile";
static const LPCWSTR g_szThreadingModel = L"Both";
const int			 g_iVersion = 1; // Version of coclasses.
HINSTANCE			 g_hInst;		 // Instance handle to this piece of code.

// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
	&CLSID_CorIcecapProfiler,	L"CorIcecapProfiler", 	ProfCallback::CreateObject,
	NULL,						NULL,					NULL
};


//********** Locals. **********************************************************

STDAPI DllUnregisterServer(void);

//********** Code. ************************************************************

//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.
//*****************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	// Save off the instance handle for later use.
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		OnUnicodeSystem();
		g_hInst = hInstance;
		DisableThreadLibraryCalls(hInstance);
#ifdef LOGGING		
		InitializeLogging();
#endif
	}

    // This is in case the process shuts down through a call to ExitProcess,
    // which will cause the profiling DLL to be unloaded before the runtime
    // DLL, which means we have to simulate the shutdown.
    else if (dwReason == DLL_PROCESS_DETACH && g_pCallback != NULL
             && lpReserved != NULL)
    {
        g_pCallback->Shutdown();
        g_pCallback->Release();
        _ASSERTE(g_pCallback == NULL);
    }
	return TRUE;
}

//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
STDAPI DllRegisterServer(void)
{
	const COCLASS_REGISTER *pCoClass;	// Loop control.
	WCHAR		rcModule[_MAX_PATH];	// This server's module name.
	HRESULT 	hr = S_OK;

	HKEY		hKey	= NULL;			// regkey for COMPlus\Profiler
	HKEY		hSubKey = NULL;			// regkey for our dll
	DWORD		dwAction;				// current action on registry
	long		lStatus;				// status from registry
	
	// Initialize some variables so WszXXX will work
	OnUnicodeSystem();

	// Erase all doubt from old entries.
	DllUnregisterServer();

	// Get the filename for this module.
	if(!WszGetModuleFileName(GetModuleInst(), rcModule, NumItems(rcModule)))
	    return E_UNEXPECTED;

	// For each item in the coclass list, register it.
	for (pCoClass=g_CoClasses;	pCoClass->pClsid;  pCoClass++)
	{
		// Register the class with default values.
		if (FAILED(hr = REGUTIL::RegisterCOMClass(
				*pCoClass->pClsid, 
				g_szCoclassDesc, 
				g_szProgIDPrefix,
				g_iVersion, 
				pCoClass->szProgID, 
				g_szThreadingModel, 
				rcModule)))
			goto ErrExit;
	}

	// Add us to the COM+ profiler list
	
	// 1. Create or Open COMPlus\Profiler key.
	lStatus = WszRegCreateKeyEx(
		HKEY_LOCAL_MACHINE,					// handle to an open key
		PROFILER_REGKEY_ROOT,					// address of subkey name
		0,									// reserved
		L"Class",							// address of class string
		REG_OPTION_NON_VOLATILE,			// special options flag
		KEY_ALL_ACCESS,						// desired security access
		NULL,								// address of key security structure
		&hKey,								// address of buffer for opened handle
		&dwAction							// address of disposition value buffer
	);
 	
	if (lStatus != ERROR_SUCCESS)
	{
		hr = HRESULT_FROM_WIN32(lStatus);
		goto ErrExit;
	}	

	// 2. Add our profiler to the sub key
	lStatus = WszRegCreateKeyEx(
		hKey,								// handle to an open key
		REGKEY_THIS_PROFILER_NAME,			// address of subkey name
		0,									// reserved
		L"Class",							// address of class string
		REG_OPTION_NON_VOLATILE,			// special options flag
		KEY_ALL_ACCESS,						// desired security access
		NULL,								// address of key security structure
		&hSubKey,							// address of buffer for opened handle
		&dwAction							// address of disposition value buffer
	);
 	
	if (lStatus != ERROR_SUCCESS)
	{
		hr = HRESULT_FROM_WIN32(lStatus);
		goto ErrExit;
	}	

	// 3. Add the PROFID value (scope needed b/c of goto)
	{
		const long cBytes = sizeof(REGVALUE_THIS_PROFID);
		lStatus = WszRegSetValueEx(hSubKey, PROFILER_REGVALUE_PROFID, 0, REG_SZ, (BYTE*) REGVALUE_THIS_PROFID, cBytes);
	}
	if (lStatus != ERROR_SUCCESS)
	{
		hr = HRESULT_FROM_WIN32(lStatus);
		goto ErrExit;
	}		

	// 4. Add a help string	
	{
		const long cBytes = sizeof(REGVALUE_THIS_HELPSTRING);
		lStatus = WszRegSetValueEx(hSubKey, PROFILER_REGVALUE_HELPSTRING, 0, REG_SZ, (BYTE*) REGVALUE_THIS_HELPSTRING, cBytes);
	}

	if (lStatus != ERROR_SUCCESS)
	{
		hr = HRESULT_FROM_WIN32(lStatus);
		goto ErrExit;
	}		

ErrExit:
	if (hKey != NULL) 
	{
		CloseHandle(hKey);
	}
	if (hSubKey != NULL) 
	{
		CloseHandle(hSubKey);
	}

	if (FAILED(hr))
		DllUnregisterServer();
	return (hr);
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
STDAPI DllUnregisterServer(void)
{
	const COCLASS_REGISTER *pCoClass;	// Loop control.

	HKEY hKey = NULL;					// registry key
	long lStatus;						// status of reg operations

	// Initialize some variables so WszXXX will work
	OnUnicodeSystem();

	// For each item in the coclass list, unregister it.
	for (pCoClass=g_CoClasses;	pCoClass->pClsid;  pCoClass++)
	{
		REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
					g_iVersion, pCoClass->szProgID);
	}

	// 1. Open our key's parent (because we can only delete children of an open key)
	// Note, REGUTIL only deletes from HKEY_CLASSES_ROOT, so can't use it
	lStatus = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, PROFILER_REGKEY_ROOT, 0, KEY_ALL_ACCESS, &hKey);
	if (lStatus == ERROR_SUCCESS) 
	{
		// 2. Delete our key;  we'll leave the parent key open for other profilers.
		WszRegDeleteKey(hKey, REGKEY_THIS_PROFILER_NAME);
		CloseHandle(hKey);
	}

	return (S_OK);
}


//*****************************************************************************
// Called by COM to get a class factory for a given CLSID.	If it is one we
// support, instantiate a class factory object and prepare for create instance.
//*****************************************************************************
STDAPI DllGetClassObject(				// Return code.
	REFCLSID	rclsid, 				// The class to desired.
	REFIID		riid,					// Interface wanted on class factory.
	LPVOID FAR	*ppv)					// Return interface pointer here.
{
	CClassFactory *pClassFactory;		// To create class factory object.
	const COCLASS_REGISTER *pCoClass;	// Loop control.
	HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

	// Scan for the right one.
	for (pCoClass=g_CoClasses;	pCoClass->pClsid;  pCoClass++)
	{
		if (*pCoClass->pClsid == rclsid)
		{
			// Allocate the new factory object.
			pClassFactory = new CClassFactory(pCoClass);
			if (!pClassFactory)
				return (E_OUTOFMEMORY);
	
			// Pick the v-table based on the caller's request.
			hr = pClassFactory->QueryInterface(riid, ppv);
	
			// Always release the local reference, if QI failed it will be
			// the only one and the object gets freed.
			pClassFactory->Release();
			break;
		}
	}
	return (hr);
}



//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
	REFIID		riid,
	void		**ppvObject)
{
	HRESULT 	hr;
	
	// Avoid confusion.
	*ppvObject = NULL;
	
	// Pick the right v-table based on the IID passed in.
	if (riid == IID_IUnknown)
		*ppvObject = (IUnknown *) this;
	else if (riid == IID_IClassFactory)
		*ppvObject = (IClassFactory *) this;
	
	// If successful, add a reference for out pointer and return.
	if (*ppvObject)
	{
		hr = S_OK;
		AddRef();
	}
	else
		hr = E_NOINTERFACE;
	return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
	IUnknown	*pUnkOuter,
	REFIID		riid,
	void		**ppvObject)
{
	HRESULT 	hr;
	
	// Avoid confusion.
	*ppvObject = NULL;
	_ASSERTE(m_pCoClass);
	
	// Aggregation is not supported by these objects.
	if (pUnkOuter)
		return (CLASS_E_NOAGGREGATION);
	
	// Ask the object to create an instance of itself, and check the iid.
	hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
	return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
	BOOL		fLock)
{
//@todo: hook up lock server logic.
	return (S_OK);
}





//*****************************************************************************
// This helper provides access to the instance handle of the loaded image.
//*****************************************************************************
HINSTANCE GetModuleInst()
{
	return g_hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\callback.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Callback.cpp
//
// Implements the profiling callbacks and does the right thing for icecap.
//
//*****************************************************************************
#include "StdAfx.h"
#include "mscorcap.h"
#include "PrettyPrintSig.h"
#include "icecap.h"

#define SZ_DEFAULT_LOG_FILE     L"icecap.csv"
#define SZ_CRLF                 "\r\n"
#define SZ_COLUMNHDR            "FunctionId,Name\r\n"
#define SZ_SIGNATURES           L"signatures"
#define LEN_SZ_SIGNATURES       ((sizeof(SZ_SIGNATURES) - 1) / sizeof(WCHAR))
#define BUFFER_SIZE             (8 * 1096)

extern "C"
{
typedef BOOL (__stdcall *PFN_SUSPENDPROFILNG)(int nLevel, DWORD dwid);
typedef BOOL (__stdcall *PFN_RESUMEPROFILNG)(int nLevel, DWORD dwid);
}

#ifndef PROFILE_THREADLEVEL
#define PROFILE_GLOBALLEVEL 1
#define PROFILE_PROCESSLEVEL 2
#define PROFILE_THREADLEVEL 3
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)
#endif


const char* PrettyPrintSig(
    PCCOR_SIGNATURE typePtr,            // type to convert,
    unsigned typeLen,                   // length of type
    const char* name,                   // can be "", the name of the method for this sig
    CQuickBytes *out,                   // where to put the pretty printed string
    IMetaDataImport *pIMDI);            // Import api to use.

// Global for use by DllMain
ProfCallback *g_pCallback = NULL;

ProfCallback::ProfCallback() :
    m_pInfo(NULL),
    m_wszFilename(NULL),
    m_eSig(SIG_NONE)
{
}

ProfCallback::~ProfCallback()
{
    if (m_pInfo)
        RELEASE(m_pInfo);

    // Prevent anyone else from doing a delete on an already deleted object
    g_pCallback = NULL;

    delete [] m_wszFilename;
    _ASSERTE(!(m_wszFilename = NULL));
}

COM_METHOD ProfCallback::Initialize(
    /* [in] */  IUnknown *pEventInfoUnk)
{
    HRESULT hr = S_OK;

    ICorProfilerInfo *pEventInfo;

    // Comes back addref'd
    hr = pEventInfoUnk->QueryInterface(IID_ICorProfilerInfo, (void **)&pEventInfo);

    if (FAILED(hr))
        return (hr);

    // By default, always get jit completion events.
    DWORD dwRequestedEvents = COR_PRF_MONITOR_JIT_COMPILATION | COR_PRF_MONITOR_CACHE_SEARCHES;

    // Called to initialize the WinWrap stuff so that WszXXX functions work
    OnUnicodeSystem();

    // Read the configuration from the PROF_CONFIG environment variable
    {
        WCHAR wszBuffer[BUF_SIZE];
        WCHAR *wszEnv = wszBuffer;
        DWORD cEnv = BUF_SIZE;
        DWORD cRes = WszGetEnvironmentVariable(CONFIG_ENV_VAR, wszEnv, cEnv);

        if (cRes != 0)
        {
            // Need to allocate a bigger string and try again
            if (cRes > cEnv)
            {
                wszEnv = (WCHAR *)_alloca(cRes * sizeof(WCHAR));
                cRes = WszGetEnvironmentVariable(CONFIG_ENV_VAR, wszEnv,
                                                       cRes);

                _ASSERTE(cRes != 0);
            }

            hr = ParseConfig(wszEnv, &dwRequestedEvents);
        }

        // Else set default values
        else
            hr = ParseConfig(NULL, &dwRequestedEvents);
    }

    if (SUCCEEDED(hr))
    {
        hr = pEventInfo->SetEventMask(dwRequestedEvents);
        _ASSERTE((dwRequestedEvents | (COR_PRF_MONITOR_JIT_COMPILATION | COR_PRF_MONITOR_CACHE_SEARCHES)) && SUCCEEDED(hr));
    }

    if (SUCCEEDED(hr))
    {
        hr = IcecapProbes::LoadIcecap(pEventInfo);
    }

    if (SUCCEEDED(hr))
    {
        // Save the info interface
        m_pInfo = pEventInfo;
    }
    else
        pEventInfo->Release();

    return (hr);
}

//*****************************************************************************
// Record each unique function id that get's jit compiled.  This list will be
// used at shut down to correlate probe values (which use Function ID) to
// their corresponding name values.
//*****************************************************************************
COM_METHOD ProfCallback::JITCompilationFinished(
    FunctionID  functionId,
    HRESULT     hrStatus)
{
    if (FAILED(hrStatus))
        return (S_OK);

    FunctionID *p = m_FuncIdList.Append();
    if (!p)
        return (E_OUTOFMEMORY);
    *p = functionId;
    return (S_OK);
}

COM_METHOD ProfCallback::JITCachedFunctionSearchFinished(
	FunctionID functionId,
	COR_PRF_JIT_CACHE result)
{
	if (result == COR_PRF_CACHED_FUNCTION_FOUND)
	{
    	FunctionID *p = m_FuncIdList.Append();

    	if (!p)
        	return (E_OUTOFMEMORY);

    	*p = functionId;
    	return (S_OK);

	}
    return (S_OK);
}


COM_METHOD ProfCallback::Shutdown()
{
    HINSTANCE   hInst = 0;
    HRESULT     hr = S_OK;

    // This is freaky: the module may be memory unmapped but still in NT's
    // internal linked list of loaded modules, so we assume that icecap.dll has
    // already been unloaded and don't try to do anything else with it.

    // Walk the list of JIT'd functions and dump their names into the
    // log file.

    // Open the output file
    HANDLE hOutFile = WszCreateFile(m_wszFilename, GENERIC_WRITE, 0, NULL,
                                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hOutFile != INVALID_HANDLE_VALUE)
    {
        hr = _DumpFunctionNamesToFile(hOutFile);
        CloseHandle(hOutFile);
    }

    // File was not opened for some reason
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    // Free up the library.
    IcecapProbes::UnloadIcecap();

    return (hr);
}

#define DELIMS L" \t"

HRESULT ProfCallback::ParseConfig(WCHAR *wszConfig, DWORD *pdwRequestedEvents)
{
    HRESULT hr = S_OK;

    if (wszConfig != NULL)
    {
        for (WCHAR *wszToken = wcstok(wszConfig, DELIMS);
               SUCCEEDED(hr) && wszToken != NULL;
               wszToken = wcstok(NULL, DELIMS))
        {
            if (wszToken[0] != L'/' || wszToken[1] == L'\0')
                hr = E_INVALIDARG;

            // Other options.
            else
            {
                switch (wszToken[1])
                {
                    // Signatures
                    case L's':
                    case L'S':
                    {
                        if (_wcsnicmp(&wszToken[1], SZ_SIGNATURES, LEN_SZ_SIGNATURES) == 0)
                        {
                            WCHAR *wszOpt = &wszToken[LEN_SZ_SIGNATURES + 2];
                            if (_wcsicmp(wszOpt, L"none") == 0)
                                m_eSig = SIG_NONE;
                            else if (_wcsicmp(wszOpt, L"always") == 0)
                                m_eSig = SIG_ALWAYS;
                            else
                                goto BadArg;
                        }
                        else
                            goto BadArg;
                    }
                    break;

                    // Profiling type.
                    case L'f':
                    case L'F':
                    {
                        /*
                        if (_wcsicmp(&wszToken[1], L"fastcap") == 0)
                            *pdwRequestedEvents |= COR_PRF_MONITOR_STARTEND;
                        */

                        // Not allowed.
                        WszMessageBoxInternal(NULL, L"Invalid option: fastcap.  Currently unsupported in Icecap 4.1."
                            L"  Fix being investigated, no ETA.", L"Unsupported option",
                            MB_OK | MB_ICONEXCLAMATION);


                        return (E_INVALIDARG);
                    }
                    break;

                    case L'c':
                    case L'C':
                    if (_wcsicmp(&wszToken[1], L"callcap") == 0)
                        *pdwRequestedEvents |= COR_PRF_MONITOR_ENTERLEAVE;
                    break;

                    // Bad arg.
                    default:
                    BadArg:
                    wprintf(L"Unknown option: '%s'\n", wszToken);
                    return (E_INVALIDARG);
                }

            }
        }
    }

    // Check for type flags, if none given default.
    if ((*pdwRequestedEvents & (/*COR_PRF_MONITOR_STARTEND |*/ COR_PRF_MONITOR_ENTERLEAVE)) == 0)
        *pdwRequestedEvents |= /*COR_PRF_MONITOR_STARTEND |*/ COR_PRF_MONITOR_ENTERLEAVE;

    // Provide default file name.  This is done using the pattern ("%s_%08x.csv", szApp, pid).
    // This gives the report tool a deterministic way to find the correct dump file for
    // a given run.  If you recycle a PID for the same file name with this tecnique,
    // you're on your own:-)
    if (SUCCEEDED(hr))
    {
        WCHAR   rcExeName[_MAX_PATH];
        GetIcecapProfileOutFile(rcExeName);
        m_wszFilename = new WCHAR[wcslen(rcExeName) + 1];
        wcscpy(m_wszFilename, rcExeName);
    }

    return (hr);
}


//*****************************************************************************
// Walk the list of loaded functions, get their names, and then dump the list
// to the output symbol file.
//*****************************************************************************
HRESULT ProfCallback::_DumpFunctionNamesToFile( // Return code.
    HANDLE      hOutFile)               // Output file.
{
    UINT        i, iLen;                // Loop control.
    WCHAR       *szName = 0;            // Name buffer for fetch.
    ULONG       cchName, cch;           // How many chars max in name.
    char        *rgBuff = 0;            // Write buffer.
    FunctionID  funcId;                 // Orig func id
    FunctionID  handle;                 // Profiling handle.
    ULONG       cbOffset;               // Current offset in buffer.
    ULONG       cbMax;                  // Max size of the buffer.
    ULONG       cb;                     // Working size buffer.
    HRESULT     hr;

    // Allocate a buffer to use for name lookup.
    cbMax = BUFFER_SIZE;
    rgBuff = (char *) malloc(cbMax);
    cchName = MAX_CLASSNAME_LENGTH;
    szName = (WCHAR *) malloc(cchName * 2);
    if (!rgBuff || !szName)
    {
        hr = OutOfMemory();
        goto ErrExit;
    }

    // Init the copy buffer with the column header.
    strcpy(rgBuff, SZ_COLUMNHDR);
    cbOffset = sizeof(SZ_COLUMNHDR) - 1;

    LOG((LF_CORPROF, LL_INFO10, "**PROFTABLE: MethodDesc, Handle,   Name\n"));

    // Walk every JIT'd method and get it's name.
    for (i=0;  i < IcecapProbes::GetFunctionCount();    i++)
    {
        // Dump the current text of the file.
        if (cbMax - cbOffset < 32)
        {
            if (!WriteFile(hOutFile, rgBuff, cbOffset, &cb, NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ErrExit;
            }
            cbOffset = 0;
        }

        // Add the function id to the dump.
        funcId = IcecapProbes::GetFunctionID(i);
        handle = IcecapProbes::GetMappedID(i);

        cbOffset += sprintf(&rgBuff[cbOffset], "%08x,", handle);
        LOG((LF_CORPROF, LL_INFO10, "**PROFTABLE: %08x,   %08x, ", funcId, handle));

RetryName:
        hr = GetStringForFunction(IcecapProbes::GetFunctionID(i), szName, cchName, &cch);
        if (FAILED(hr))
            goto ErrExit;

        // If the name was truncated, then make the name buffer bigger.
        if (cch > cchName)
        {
            WCHAR *sz = (WCHAR *) realloc(szName, (cchName + cch + 128) * 2);
            if (!sz)
            {
                hr = OutOfMemory();
                goto ErrExit;
            }
            szName = sz;
            cchName += cch + 128;
            goto RetryName;
        }

        LOG((LF_CORPROF, LL_INFO10, "%S\n", szName));

        // If the name cannot fit successfully into the disk buffer (assuming
        // worst case scenario of 2 bytes per unicode char), then the buffer
        // is too small and needs to get flushed to disk.
        if (cbMax - cbOffset < (cch * 2) + sizeof(SZ_CRLF))
        {
            // If this fires, it means that the copy buffer was too small.
            _ASSERTE(cch > 0);

            // Dump everything we do have before the truncation.
            if (!WriteFile(hOutFile, rgBuff, cbOffset, &cb, NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ErrExit;
            }

            // Reset the buffer to use the whole thing.
            cbOffset = 0;
        }

        // Convert the name buffer into the disk buffer.
        iLen = WideCharToMultiByte(CP_ACP, 0,
                    szName, -1,
                    &rgBuff[cbOffset], cbMax - cbOffset,
                    NULL, NULL);
        if (!iLen)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrExit;
        }
        --iLen;
        strcpy(&rgBuff[cbOffset + iLen], SZ_CRLF);
        cbOffset = cbOffset + iLen + sizeof(SZ_CRLF) - 1;
    }

    // If there is data left in the write buffer, flush it.
    if (cbOffset)
    {
        if (!WriteFile(hOutFile, rgBuff, cbOffset, &cb, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrExit;
        }
    }

ErrExit:
    if (rgBuff)
        free(rgBuff);
    if (szName)
        free(szName);
    return (hr);
}


//*****************************************************************************
// Given a function id, turn it into the corresponding name which will be used
// for symbol resolution.
//*****************************************************************************
HRESULT ProfCallback::GetStringForFunction( // Return code.
    FunctionID  functionId,             // ID of the function to get name for.
    WCHAR       *wszName,               // Output buffer for name.
    ULONG       cchName,                // Max chars for output buffer.
    ULONG       *pcName)                // Return name (truncation check).
{
    IMetaDataImport *pImport = 0;       // Metadata for reading.
    mdMethodDef funcToken;              // Token for metadata.
    HRESULT hr = S_OK;

    *wszName = 0;

    // Get the scope and token for the current function
    hr = m_pInfo->GetTokenAndMetaDataFromFunction(functionId, IID_IMetaDataImport,
            (IUnknown **) &pImport, &funcToken);

    if (SUCCEEDED(hr))
    {
        // Initially, get the size of the function name string
        ULONG cFuncName;

        mdTypeDef classToken;
        WCHAR  wszFuncBuffer[BUF_SIZE];
        WCHAR  *wszFuncName = wszFuncBuffer;
        PCCOR_SIGNATURE pvSigBlob;
        ULONG  cbSig;

RetryName:
        hr = pImport->GetMethodProps(funcToken, &classToken,
                    wszFuncBuffer, BUF_SIZE, &cFuncName,
                    NULL,
                    &pvSigBlob, &cbSig,
                    NULL, NULL);

        // If the function name is longer than the buffer, try again
        if (hr == CLDB_S_TRUNCATION)
        {
            wszFuncName = (WCHAR *)_alloca(cFuncName * sizeof(WCHAR));
            goto RetryName;
        }

        // Now get the name of the class
        if (SUCCEEDED(hr))
        {
            // Class name
            WCHAR wszClassBuffer[BUF_SIZE];
            WCHAR *wszClassName = wszClassBuffer;
            ULONG cClassName = BUF_SIZE;

            // Not a global function
            if (classToken != mdTypeDefNil)
            {
RetryClassName:
                hr = pImport->GetTypeDefProps(classToken, wszClassName,
                                            cClassName, &cClassName, NULL,
                                            NULL);

                if (hr == CLDB_S_TRUNCATION)
                {
                    wszClassName = (WCHAR *)_alloca(cClassName * sizeof(WCHAR));
                    goto RetryClassName;
                }
            }

            // It's a global function
            else
                wszClassName = L"<Global>";

            if (SUCCEEDED(hr))
            {
                *pcName = wcslen(wszClassName) + sizeof(NAMESPACE_SEPARATOR_WSTR) +
                          wcslen(wszFuncName) + 1;

                // Check if the provided buffer is big enough
                if (cchName < *pcName)
                {
                    hr = S_FALSE;
                }

                // Otherwise, the buffer is big enough
                else
                {
                    wcscat(wszName, wszClassName);
                    wcscat(wszName, NAMESPACE_SEPARATOR_WSTR);
                    wcscat(wszName, wszFuncName);

                    // Add the formatted signature only if need be.
                    if (m_eSig == SIG_ALWAYS)
                    {
                        CQuickBytes qb;

                        PrettyPrintSig(pvSigBlob, cbSig, wszName,
                            &qb, pImport);

                        // Copy big name for output, make sure it is null.
                        ULONG iCopy = qb.Size() / sizeof(WCHAR);
                        if (iCopy > cchName)
                            iCopy = cchName;
                        wcsncpy(wszName, (LPCWSTR) qb.Ptr(), cchName);
                        wszName[cchName - 1] = 0;
                    }

                    // Change spaces and commas into underscores so
                    // that icecap doesn't have problems with them.
                    WCHAR *sz;
                    for (sz = (WCHAR *) wszName; *sz;  sz++)
                    {
                        switch (*sz)
                        {
                            case L' ':
                            case L',':
                            case L'?':
                            case L'@':
                                *sz = L'_';
                                break;
                        }
                    }

                    hr = S_OK;
                }
            }
        }
    }

    if (pImport) pImport->Release();
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\icecap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Icecap.cpp
//
//*****************************************************************************
#include "stdafx.h"
#include "Icecap.h"
#include "Winwrap.h"
#include "utsem.h"


//********** Types. ***********************************************************

#define ICECAP_NAME	L"icecap.dll"

// reserver enough room for 1,000,000 methods to get tracked.
const ULONG MaxRangeSize = (((1000000 - 1) & ~(4096 - 1)) + 4096);

const int DEFAULT_GROWTH_INC = 1000;

const DWORD InvalidTlsIndex = 0xFFFFFFFF;

/*
extern "C" BOOL _declspec(dllexport) _stdcall  
EmitModuleLoadRecord(void *pImageBase, DWORD dwImageSize, LPCSTR szModulePath);

extern "C" BOOL _declspec(dllexport) _stdcall 
EmitModuleUnoadRecord(void *pImageBase, DWORD dwImageSize)
*/

extern "C"
{
typedef BOOL (__stdcall *PFN_EMITMODULELOADRECORD)(void *pImageBaes, DWORD dwImageSize, LPCSTR szModulePath);
typedef BOOL (__stdcall *PFN_EMITMODULEUNLOADRECORD)(void *pImageBaes, DWORD dwImageSize);
}


//********** Locals. **********************************************************
void SetIcecapStubbedHelpers(ICorProfilerInfo *pInfo);


//********** Globals. *********************************************************
HINSTANCE g_hIcecap = 0;			// Loaded instance, externed in icecap.h

static PFN_EMITMODULELOADRECORD g_pfnEmitLoad = 0;
static PFN_EMITMODULEUNLOADRECORD g_pfnEmitUnload = 0;



#ifdef _DEBUG
#define TBL_ENTRY(name)	name, 0, "_CAP_" # name
#else
#define TBL_ENTRY(name) 0, "_CAP_" # name
#endif

ICECAP_FUNCS IcecapFuncs[NUM_ICECAP_PROBES] = 
{
// /fastcap
	TBL_ENTRY(Start_Profiling		),
	TBL_ENTRY(End_Profiling			),
// /callcap
	TBL_ENTRY(Enter_Function		),
	TBL_ENTRY(Exit_Function			),
// Helper methods
	TBL_ENTRY(Profiling				),
};

// Stores the last entry associated with a thread
struct LastEntry
{
	FunctionID m_funcId;
	FunctionID m_index;
};




//********** Code. ************************************************************


class CIcecapMapTable : public CDynArray<FunctionID> 
{
public:
	CIcecapMapTable::CIcecapMapTable() :
		CDynArray<FunctionID>(DEFAULT_GROWTH_INC)
	{ }
};



//*****************************************************************************
// This class is used to track the allocated range and the map table.
// The ID range is reserved virtual memory, which is never actually
// committed.  This keeps working set size reasonable, while giving us a 
// range that no other apps will get loaded into.
//*****************************************************************************
class IcecapMap
{
public:
	//*************************************************************************
	IcecapMap() :
		m_pBase(0), m_cbSize(0), m_SlotMax(0), m_dwTlsIndex(InvalidTlsIndex),
		m_dwNextEntryIndex(0)
	{}

	//*************************************************************************
	~IcecapMap()
	{
		if (m_pBase)
			VERIFY(VirtualFree(m_pBase, 0, MEM_RELEASE));
		m_pBase = 0;
		m_cbSize = 0;
		m_SlotMax = 0;
		m_rgTable.Clear();
	}

	//*************************************************************************
	// This method reserves a range of method IDs, 1 byte for every method.
	HRESULT Init()
	{
		m_Lock.LockWrite();		// This is paranoid, but just making sure

		_ASSERTE(m_dwTlsIndex == InvalidTlsIndex);	// Don't initialize twice
		m_dwTlsIndex = TlsAlloc();

		// Something is seriously wrong if TlsAlloc fails
		if (m_dwTlsIndex == 0 && GetLastError() != NO_ERROR)
		{
			_ASSERTE(!"TlsAlloc failed!");
			return (HRESULT_FROM_WIN32(GetLastError()));
		}

		VERIFY(m_pBase = VirtualAlloc(0, MaxRangeSize, MEM_RESERVE, PAGE_NOACCESS));

		if (!m_pBase)
			return (OutOfMemory());

		m_cbSize = MaxRangeSize;

		m_Lock.UnlockWrite();	// More paranoia

		return (S_OK);
	}

	//*************************************************************************
	// Map an entry to its ID range value.
	FunctionID GetProfilingHandle(FunctionID funcId, BOOL *pbHookFunction)
	{
		_ASSERTE(m_dwTlsIndex != InvalidTlsIndex);
		_ASSERTE(pbHookFunction);

		*pbHookFunction = TRUE;

		LastEntry *pLastEntry = (LastEntry *) TlsGetValue(m_dwTlsIndex);

		// Need to associate a last entry structure with this thread
		if (pLastEntry == NULL)
		{
			pLastEntry = new LastEntry;
			_ASSERTE(pLastEntry != NULL && "Out of memory!");

			// Bail!
			if (pLastEntry == NULL)
				ExitProcess(1);

			// Set the tls entry for this thread
			VERIFY(TlsSetValue(m_dwTlsIndex, (LPVOID) pLastEntry));	

			// Invalidate the entry
			pLastEntry->m_funcId = 0;
		}

		// Search for the entry if it is not equal to the value in the TLS cache
		if (pLastEntry->m_funcId != funcId)
		{
            int i;

			m_Lock.LockWrite();

            // Linear search for the entry
            for (i = m_rgTable.Count() - 1; i >= 0; i--)
            {
                _ASSERTE(0 <= i && i < m_rgTable.Count());

                if (m_rgTable[i] == funcId)
                {
                    m_Lock.UnlockWrite();
                    return ((UINT_PTR)((UINT) i + (UINT) m_pBase));
                }
            }

            //
            // If we get here it was not found in the list - add it
            //

			// Get the next index available
			DWORD dwIndex = m_dwNextEntryIndex++;

			// Store the most recent pair with the thread
			pLastEntry->m_funcId = funcId;
			pLastEntry->m_index = (FunctionID)((UINT) dwIndex);

			// Save the function id associated with the index
			FunctionID *pFuncIdEntry = m_rgTable.Insert(dwIndex);
			_ASSERTE(pFuncIdEntry != NULL);

            if (pFuncIdEntry != NULL)
			    *pFuncIdEntry = funcId;

			m_Lock.UnlockWrite();
		}

		// Return the calculated value
		return ((UINT_PTR)((UINT) pLastEntry->m_index + (UINT) m_pBase));
	}

	UINT GetFunctionCount()
	{
		return (m_rgTable.Count());
	}

	FunctionID GetFunctionID(UINT uiIndex)
	{
        _ASSERTE(uiIndex < (UINT) m_rgTable.Count());
		return (m_rgTable[uiIndex]);
	}

	FunctionID GetMappedID(UINT uiIndex)
	{
        _ASSERTE(uiIndex < (UINT) m_rgTable.Count());
		return (uiIndex + (UINT) m_pBase);
	}

public:
	void		*m_pBase;				// The ID range base.
	UINT_PTR	m_cbSize;				// How big is the range.
	UINT_PTR	m_SlotMax;				// Current slot max.
	CIcecapMapTable m_rgTable;			// The mapping table into this range.
	UTSemReadWrite m_Lock;				// Mutual exclusion on heap map table.
	DWORD m_dwTlsIndex;					// Tls entry for storing function ids
	DWORD m_dwNextEntryIndex;			// Next free entry for mapping
};

static IcecapMap *g_pIcecapRange = 0;


//*****************************************************************************
// Load icecap.dll and get the address of the probes and helpers we will 
// be calling.
//*****************************************************************************
HRESULT IcecapProbes::LoadIcecap(ICorProfilerInfo *pInfo)
{
	int			i;
	HRESULT		hr = S_OK;
	
#if defined(_DEBUG)
	{
		for (int i=0;  i<NUM_ICECAP_PROBES;  i++)
			_ASSERTE(IcecapFuncs[i].id == i);
	}
#endif

	// Load the icecap probe library into this process.
	if (g_hIcecap)
		return (S_OK);

/*
    Thread  *thread = GetThread();
    BOOL     toggleGC = (thread && thread->PreemptiveGCDisabled());

    if (toggleGC)
        thread->EnablePreemptiveGC();
*/

	g_hIcecap = WszLoadLibrary(ICECAP_NAME);
	if (!g_hIcecap)
	{
		WCHAR		rcPath[1024];
		WCHAR		rcMsg[1280];

		// Save off the return error.
		hr = HRESULT_FROM_WIN32(GetLastError());

		// Tell the user what happened.
		if (!WszGetEnvironmentVariable(L"path", rcPath, NumItems(rcPath)))
			wcscpy(rcPath, L"<error>");
		swprintf(rcMsg, L"Could not find icecap.dll on path:\n%s", rcPath);
		WszMessageBoxInternal(GetDesktopWindow(), rcMsg,
			L"COM+ Icecap Integration", MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

        LOG((LF_CORPROF, LL_INFO10, "**PROF: Failed to load icecap.dll: %08x.\n", hr));
		goto ErrExit;
	}
	LOG((LF_CORPROF, LL_INFO10, "**PROF: Loaded icecap.dll.\n", hr));

	// Get the address of each helper method.
	for (i=0;  i<NUM_ICECAP_PROBES;  i++)
	{
		IcecapFuncs[i].pfn = (UINT_PTR) GetProcAddress(g_hIcecap, IcecapFuncs[i].szFunction);
		if (!IcecapFuncs[i].pfn)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG((LF_CORPROF, LL_INFO10, "**PROF: Failed get icecap probe %s, %d, %8x\n", IcecapFuncs[i].szFunction, i, hr));
			goto ErrExit;
		}
	}

	// Get the module entry points.
	if ((g_pfnEmitLoad = (PFN_EMITMODULELOADRECORD) GetProcAddress(g_hIcecap, "EmitModuleLoadRecord")) == 0 ||
		(g_pfnEmitUnload = (PFN_EMITMODULEUNLOADRECORD) GetProcAddress(g_hIcecap, "EmitModuleUnloadRecord")) == 0)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG((LF_CORPROF, LL_INFO10, "**PROF: Failed GetProcAddress in icecap %8x\n", hr));
		goto ErrExit;
	}

	// Allocate the mapping data structure.
	g_pIcecapRange = new IcecapMap;
	if (!g_pIcecapRange)
	{
		hr = OutOfMemory();
		goto ErrExit;
	}
	hr = g_pIcecapRange->Init();

	// Emit a load record for the ID range.
	{
		WCHAR	rcExeName[_MAX_PATH];
		char rcname[_MAX_PATH];

		// Get the output file name and convert it for use in the icecap api.
		GetIcecapProfileOutFile(rcExeName);
		Wsz_wcstombs(rcname, rcExeName, _MAX_PATH);
		
		// Tell the Icecap API about our fake module.
		BOOL bRtn = (*g_pfnEmitLoad)(g_pIcecapRange->m_pBase, g_pIcecapRange->m_cbSize, rcname);
		_ASSERTE(bRtn);
		LOG((LF_CORPROF, LL_INFO10, "**PROF: Emitted module load record for base %08x of size %08x with name '%s'\n",
					g_pIcecapRange->m_pBase, g_pIcecapRange->m_cbSize, rcname));
	}

	// Init the jit helper table to have these probe values.  The JIT will
	// access the data by calling getHelperFtn().
	SetIcecapStubbedHelpers(pInfo);

ErrExit:
	if (FAILED(hr))
		UnloadIcecap();

/*
    if (toggleGC)
        thread->DisablePreemptiveGC();
*/

	return (hr);
}


//*****************************************************************************
// Unload the icecap dll and zero out entry points.
//*****************************************************************************
void IcecapProbes::UnloadIcecap()
{
    // This is freaky: the module may be memory unmapped but still in NT's
    // internal linked list of loaded modules, so we assume that icecap.dll has
    // already been unloaded and don't try to do anything else with it.

	for (int i=0;  i<NUM_ICECAP_PROBES;  i++)
		IcecapFuncs[i].pfn = 0;

	// Free the map data if allocated.
	if (g_pIcecapRange)
		delete g_pIcecapRange;
	g_pIcecapRange = 0;

	LOG((LF_CORPROF, LL_INFO10, "**PROF: icecap.dll unloaded.\n"));
}



//*****************************************************************************
// Given a method, return a unique value that can be passed into Icecap probes.
// This value must be unique in a process so that the icecap report tool can
// correlate it back to a symbol name.  The value used is either the native
// IP for native code (N/Direct or ECall), or a value out of the icecap function
// map.
//*****************************************************************************
UINT_PTR IcecapProbes::GetProfilingHandle(	// Return a profiling handle.
	FunctionID funcId,					// The method handle to get ID for.
	BOOL *pbHookFunction)
{
	_ASSERTE(g_pIcecapRange);
	return (g_pIcecapRange->GetProfilingHandle(funcId, pbHookFunction));
}

//*****************************************************************************
// Get the number of functions in the table
//*****************************************************************************
UINT IcecapProbes::GetFunctionCount()
{
	return g_pIcecapRange->GetFunctionCount();
}

//*****************************************************************************
// Get a particular function
//*****************************************************************************
FunctionID IcecapProbes::GetFunctionID(UINT uiIndex)
{
	return g_pIcecapRange->GetFunctionID(uiIndex);
}

FunctionID IcecapProbes::GetMappedID(UINT uiIndex)
{
	return g_pIcecapRange->GetMappedID(uiIndex);
}

//*****************************************************************************
// Provides the necessary function pointers to the EE
//*****************************************************************************
void SetIcecapStubbedHelpers(ICorProfilerInfo *pInfo)
{
	_ASSERTE(pInfo != NULL);

	pInfo->SetEnterLeaveFunctionHooks(
        (FunctionEnter *) IcecapFuncs[Enter_Function].pfn,
		(FunctionLeave *) IcecapFuncs[Exit_Function].pfn,
        (FunctionLeave *) IcecapFuncs[Exit_Function].pfn);

	pInfo->SetFunctionIDMapper((FunctionIDMapper *) &IcecapProbes::GetProfilingHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\icecap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Icecap.h
//
//
//*****************************************************************************
#ifndef __Icecap_h__
#define __Icecap_h__

extern HINSTANCE g_hIcecap;

enum IcecapMethodID
{
// /fastcap probes for wrapping a function call.
	Start_Profiling,
	End_Profiling,
// /callcap probes for function prologue/epilogue hooks.
	Enter_Function,
	Exit_Function,
// Helper methods.
	Profiling,
	NUM_ICECAP_PROBES
};


struct ICECAP_FUNCS
{
#ifdef _DEBUG
	IcecapMethodID id;					// Check enum to array.
#endif
	UINT_PTR	pfn;					// Entry point for this method.
	LPCSTR		szFunction;				// Name of function.
};
extern ICECAP_FUNCS IcecapFuncs[NUM_ICECAP_PROBES];

inline UINT_PTR GetIcecapMethod(IcecapMethodID type)
{
	_ASSERTE(IcecapFuncs[type].pfn);
	return IcecapFuncs[type].pfn;
}


//*****************************************************************************
// This class is used to control the loading of icecap and the probes used
// by the JIT.
//@Todo: at some point (after M8 -- I don't have time) it needs to be decided
// how much hard coded support Icecap gets vs integration in the same way
// we decide how to support Rational and NuMega.
//*****************************************************************************
struct IcecapProbes
{
//*****************************************************************************
// Load icecap.dll and get the address of the probes and helpers we will 
// be calling.
//*****************************************************************************
	static HRESULT LoadIcecap(ICorProfilerInfo *pInfo);

//*****************************************************************************
// Unload the icecap dll and zero out entry points.
//*****************************************************************************
	static void UnloadIcecap();

//*****************************************************************************
// Given a method, return a unique value that can be passed into Icecap probes.
// This value must be unique in a process so that the icecap report tool can
// correlate it back to a symbol name.  The value used is either the native
// IP for native code (N/Direct or ECall), or a value out of the icecap function
// map.
//*****************************************************************************
	static UINT_PTR GetProfilingHandle(		// Return a profiling handle.
		FunctionID funcId,					// The method handle to get ID for.
		BOOL *pbHookFunction);

	static UINT GetFunctionCount();
	static FunctionID GetFunctionID(UINT uiIndex);
	static FunctionID GetMappedID(UINT uiIndex);
};

#endif // __Icecap_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdio.h>

#include <Windows.h>
#include <cor.h>
#include <CorError.h>
#include <crtdbg.h>

#include "corprof.h"
#include "utilcode.h"
#include "winwrap.h"
#include "..\common\util.h"

#define COM_METHOD HRESULT STDMETHODCALLTYPE

#ifdef _DEBUG

#define LOGGING

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif

#include "log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************

#ifndef __ClassFactory__h__
#define __ClassFactory__h__

#include <CorProf.h>						// Public header definitions.

// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};

//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}

	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);

private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};

#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\mscorcap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#ifndef __PROFILER_H__
#define __PROFILER_H__

#include "CorProf.h"
#include "UtilCode.h"
#include "..\common\CallbackBase.h"


#define BUF_SIZE 512
#define DEFAULT_SAMPLE_DELAY 5 // in milliseconds
#define DEFAULT_DUMP_FREQ    1000 // in milliseconds
#define CONFIG_ENV_VAR       L"PROF_CONFIG"

// {33DFF741-DA5F-11d2-8A9C-0080C792E5D8}
extern const GUID __declspec(selectany) CLSID_CorIcecapProfiler =
{ 0x33dff741, 0xda5f, 0x11d2, { 0x8a, 0x9c, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };



//********** Types. ***********************************************************

typedef CDynArray<FunctionID> FUNCTIONIDLIST;

enum SIGTYPE
{
	SIG_NONE,							// Signatures are never shown.
	SIG_ALWAYS							// Signatures are always shown.
};


// Forward declarations
class ThreadSampler;
class ProfCallback;

extern ProfCallback *g_pCallback;

/* ------------------------------------------------------------------------- *
 * ProfCallback is an implementation of ICorProfilerCallback
 * ------------------------------------------------------------------------- */

class ProfCallback : public ProfCallbackBase
{
public:
    ProfCallback();

    virtual ~ProfCallback();

    /*********************************************************************
     * IUnknown Support
     */

    COM_METHOD QueryInterface(REFIID id, void **pInterface)
    {
    	if (id == IID_ICorProfilerCallback)
    		*pInterface = (ICorProfilerCallback *)this;
        else
            return (ProfCallbackBase::QueryInterface(id, pInterface));

        AddRef();

    	return (S_OK);
    }

    /*********************************************************************
     * ICorProfilerCallback methods
     */
    COM_METHOD Initialize(
        /* [in] */ IUnknown *pEventInfoUnk);

    COM_METHOD JITCompilationFinished(
        /* [in] */ FunctionID functionId,
		/* [in] */ HRESULT hrStatus);

	COM_METHOD JITCachedFunctionSearchFinished(
					FunctionID functionID,
					COR_PRF_JIT_CACHE result);


    COM_METHOD Shutdown( void);

    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_ICorProfilerCallback)
            return (E_NOINTERFACE);

        ProfCallback *ppc = new ProfCallback();

        if (ppc == NULL)
            return (E_OUTOFMEMORY);

        ppc->AddRef();
        *object = (ICorProfilerCallback *)ppc;

        // Save this for DllMain's use if necessary
        g_pCallback = ppc;

        return (S_OK);
    }


//*****************************************************************************
// Given a function id, turn it into the corresponding name which will be used
// for symbol resolution.
//*****************************************************************************
	HRESULT GetStringForFunction(			// Return code.
		FunctionID	functionId,				// ID of the function to get name for.
		WCHAR		*wszName,				// Output buffer for name.
		ULONG		cchName,				// Max chars for output buffer.
		ULONG		*pcName);				// Return name (truncation check).

//*****************************************************************************
// Walk the list of loaded functions, get their names, and then dump the list
// to the output symbol file.
//*****************************************************************************
	HRESULT _DumpFunctionNamesToFile(		// Return code.
		HANDLE		hOutFile);				// Output file.

private:

    /*
     * This is used to parse the configuration switches
     */
    HRESULT ParseConfig(WCHAR *wszConfig, DWORD *pdwRequestedEvents);

    ICorProfilerInfo *m_pInfo;			// Callback into EE for more info.
    WCHAR            *m_wszFilename;	// Name of output file.
	FUNCTIONIDLIST	m_FuncIdList;		// List of JIT compiled methods.
	enum SIGTYPE	m_eSig;				// How to log signatures.
};




#endif /* __PROFILER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mscorcap.dll"
#define VER_FILEDESCRIPTION_STR "COM+ Runtime profiler dll\0"
#define VER_ORIGFILENAME_STR    "mscorcap.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorcap\vc\corcap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
[sysimport(dll="kernel32.dll", name="OutputDebugStringW")]
void OutStr(wchar_t *sz);

[sysimport(dll="kernel32.dll", name="OutputDebugStringA")]
void OutStrA(wchar_t *sz);

[sysimport(dll="goomba.dll", name="fubar")]
void DoesntExist();

[sysimport(dll="user32.dll", name="MessageBoxW")]
int MsgBox(long hwnd, wchar_t *szText, wchar_t *szCaption, unsigned long uType);

[sysimport(dll="kernel32.dll", name="LoadLibraryW")]
unsigned LoadLib(wchar_t *sz);


//[sysimport(dll="kernel32.dll", name="OutputDebugString"), charset=auto]
//void OutStr(wchar_t *sz);


int g_iFoo = 0;


class a
{
public:
	virtual void f1()
	{
		Console.WriteLine("a::f1");
	}
};

class b
{
public:
	virtual void f1()
	{
		Console.WriteLine("b::f1");
	}

	virtual void f1(System.Int32 iFoo)
	{
		Console.WriteLine("b::f1 with int32 " + iFoo.ToString());
	}
};


void This_is_averylong_name_for_a_function_dont_you_think(int isum)
{
	for (int j=0;  j<5000;  j++)
		;
	g_iFoo += j+isum;
}

void TestingObjectAllocate()
{
	String foo = new String("foo_bar");
	Console.WriteLine(foo);
}

void IWillThrow()
{
	for (int j=0;  j<1;  j++)
		;

	throw(new Exception("I threw"));
}

void CallingOutToWin32()
{
//	for (int k=0;  k<1;  k++)
		OutStr(L"debug test\n");
}

void DeadCode()
{
	OutStrA(L"foo");
	DoesntExist();
}

#if 0
interface IFooBar1
{
	HRESULT foo(int i) = 0;
};

interface IFooBar2
{
	HRESULT foo(int i) = 0;
};

class CFooBar : implements IFooBar1, IFooBar2
{
public:
	HRESULT IFooBar1::foo(int i)
	{ 
		Console.WriteLine("in IFooBar1::bar"); 
		return i + 5;
	}
	HRESULT IFooBar2::foo(int i)
	{ 
		Console.WriteLine("in IFooBar2::bar"); 
		return i + 5;
	}
};
#endif

int DoHello()
{
	Console.WriteLine("Hello world");
	return (0);
}

int main()
{
#if 1

	for (int j=0;  j<2;  j++)
	{
		try
		{
			IWillThrow();
		}
		catch(...)
		{
		}
	}
    return 1;
#else
//	while (1)
//		TestingObjectAllocate();

	for (int i=0;  i<5;  i++)
		This_is_averylong_name_for_a_function_dont_you_think(i);
	System.Int32 iFoo = g_iFoo;
	Console.WriteLine("g_foo = " + iFoo.ToString());

DoHello();
//return (0);
//	LoadLib("c:\\temp\\mscoree.dll");

	b bobj = new b;
	bobj.f1();
	
	System.Int32 iVal = 45;
	bobj.f1(iVal);

//	MsgBox(0, L"This is a test of p-invoke", L"My caption", 0);

	for (int j=0;  j<2;  j++)
	{
		try
		{
			IWillThrow();
		}
		catch(...)
		{
		}
	}

	CallingOutToWin32();
	return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\callbackilc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Callback.cpp
//
// Implements the profiling callbacks and does the right thing for icecap.
//
//*****************************************************************************
#include "StdAfx.h"
#include "mscorilc.h"
#include "..\common\util.h"
#include "PrettyPrintSig.h"



typedef enum opcode_t
{
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) c,
#include "opcode.def"
#undef OPDEF
  CEE_COUNT,        /* number of instructions and macros pre-defined */
} OPCODE;

int g_iCompiled = 0;

//********** Locals. **********************************************************

#define _TESTCODE 1


#define SZ_CRLF                 "\r\n"
#define SZ_COLUMNHDR            "CallCount,FunctionId,Name\r\n"
#define SZ_SIGNATURES           L"signatures"
#define LEN_SZ_SIGNATURES       ((sizeof(SZ_SIGNATURES) - 1) / sizeof(WCHAR))
#define BUFFER_SIZE             (8 * 1096)

#define SZ_FUNC_CALL            L"ILCoverFunc"

#define SZ_SPACES               L""

const char* PrettyPrintSig(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
    unsigned typeLen,                   // length of type
    const char* name,                   // can be "", the name of the method for this sig   
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMetaDataImport *pIMDI);            // Import api to use.

static void FixupExceptions(const COR_ILMETHOD_SECT *pSect, int offset);


//********** Globals. *********************************************************
static ProfCallback *g_pProfCallback = 0;



//********** Code. ************************************************************

ProfCallback::ProfCallback() : 
    m_pInfo(NULL),
    m_mdSecurityManager(mdTokenNil),
    m_tdSecurityManager(mdTokenNil),
    m_midClassLibs(0),
    m_bInstrument(true),
    m_wszFilename(0),
    m_eSig(SIG_NONE),
    m_indent(0)
{
    _ASSERTE(g_pProfCallback == 0 && "Only allowed one instance of ProfCallback");
    g_pProfCallback = this;
}

ProfCallback::~ProfCallback()
{
    g_pProfCallback = 0;

    _ASSERTE(m_pInfo != NULL);
    RELEASE(m_pInfo);

    delete [] m_wszFilename;
    _ASSERTE(!(m_wszFilename = NULL));

}

COM_METHOD ProfCallback::Initialize( 
    /* [in] */ IUnknown *pEventInfoUnk,
    /* [out] */ DWORD *pdwRequestedEvents)
{
    HRESULT hr = S_OK;

    ICorProfilerInfo *pEventInfo;
    
    // Comes back addref'd
    hr = pEventInfoUnk->QueryInterface(IID_ICorProfilerInfo, (void **)&pEventInfo);

    if (FAILED(hr))
        return (hr);

    // Set default events.
    *pdwRequestedEvents = 
            COR_PRF_MONITOR_JIT_COMPILATION | 
#if _TESTCODE
            COR_PRF_MONITOR_APPDOMAIN_LOADS |
            COR_PRF_MONITOR_ASSEMBLY_LOADS |
#endif            
            COR_PRF_MONITOR_MODULE_LOADS |
            COR_PRF_MONITOR_CLASS_LOADS;

    // Called to initialize the WinWrap stuff so that WszXXX functions work
    OnUnicodeSystem();

    // Read the configuration from the PROF_CONFIG environment variable
    {
        WCHAR wszBuffer[BUF_SIZE];
        WCHAR *wszEnv = wszBuffer;
        DWORD cEnv = BUF_SIZE;
        DWORD cRes = WszGetEnvironmentVariable(CONFIG_ENV_VAR, wszEnv, cEnv);

        if (cRes != 0)
        {
            // Need to allocate a bigger string and try again
            if (cRes > cEnv)
            {
                wszEnv = (WCHAR *)_alloca(cRes * sizeof(WCHAR));
                cRes = WszGetEnvironmentVariable(CONFIG_ENV_VAR, wszEnv,
                                                       cRes);

                _ASSERTE(cRes != 0);
            }

            hr = ParseConfig(wszEnv, pdwRequestedEvents);
        }

        // Else set default values
        else
            hr = ParseConfig(NULL, pdwRequestedEvents);
    }

    if (SUCCEEDED(hr))
        m_pInfo = pEventInfo;
    else
        pEventInfo->Release();

    return (hr);
}


COM_METHOD ProfCallback::ClassLoadStarted( 
    /* [in] */ ClassID classId)
{
    WCHAR       *szName;
    HRESULT     hr;

    // Pull back the name of the class for output.
    hr = GetNameOfClass(classId, szName);
    if (hr == S_OK)
    {
        Printf(L"%*sLoading class: %s\n", m_indent*2, SZ_SPACES, szName);
        delete [] szName;
    }
    ++m_indent;
    return (hr);
}


//*****************************************************************************
// This event is fired as the class is being loaded.  This snippet of code
// will get back the class name from the metadata at this point.  One could
// also modify the class metadata itself now if required.
//*****************************************************************************
COM_METHOD ProfCallback::ClassLoadFinished( 
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus)
{
    WCHAR       *szName;
    HRESULT     hr;

    --m_indent;

    // Pull back the name of the class for output.
    hr = GetNameOfClass(classId, szName);
    if (hr == S_OK)
    {
        if (FAILED(hrStatus))
            Printf(L"%*sClass load of %s failed with error code 0x%08x.\n", m_indent*2, SZ_SPACES, szName, hrStatus);
        else
            Printf(L"%*sClass load of %s succeeded.\n", m_indent*2, SZ_SPACES, szName);
        delete [] szName;
    }
    return (hr);
}

#include "CorInfo.h" 

//*****************************************************************************
// Before a method is compiled, instrument the code to call our function
// cover probe.  This amounts to adding a call to ILCoverFunc(FunctionId).
//*****************************************************************************
COM_METHOD ProfCallback::JITCompilationStarted( 
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fIsSafeToBlock)
{
    IMethodMalloc *pMalloc = 0;         // Allocator for new method body.
    IMetaDataEmit *pEmit = 0;           // Metadata emitter.
    LPCBYTE     pMethodHeader;          // Pointer to method header.
    ULONG       cbMethod;               // How big is the method now.
    mdToken     tkMethod;               // Token of the method in the metadata.
    ModuleID    moduleId;               // What module does method live in.
    BYTE        *rgCode = 0;            // Working buffer for compile.
    int         iLen = 0;               // Length of method.
    int         cbExtra = 0;            // Extra space required for method.
    HRESULT     hr;

    COR_IL_MAP *rgILMap = NULL;
    SIZE_T cILMap = 0;

    rgILMap = (COR_IL_MAP *)CoTaskMemAlloc( sizeof(COR_IL_MAP)*1);
    if( rgILMap==NULL)
        return E_OUTOFMEMORY;

    cILMap = 1;
    rgILMap[0].oldOffset = 0;
    rgILMap[0].newOffset = 10;

    hr = m_pInfo->SetILInstrumentedCodeMap(functionId, TRUE, cILMap, rgILMap);
    if( FAILED(hr) )
        return hr;
        
#ifdef _TESTCODE
    {
        LPCBYTE pStart;
        ULONG cSize;
        m_pInfo->GetCodeInfo(functionId, &pStart, &cSize);
    }
#endif

    // Get the metadata token and metadata for updating.
    hr = m_pInfo->GetTokenAndMetaDataFromFunction(
            functionId,
            IID_IMetaDataEmit,
            (IUnknown **) &pEmit,
            &tkMethod);
    if (FAILED(hr)) goto ErrExit;

    // Need to turn the function id into its parent module to update.
    hr = m_pInfo->GetFunctionInfo(functionId,
            0,
            &moduleId,
            0);
    if (FAILED(hr)) goto ErrExit;

    // @todo: skip the class libraries instrumentation for right now.  The
    // problem is that this code currently doesn't handle the security
    // initialization of static functions.
    if (m_midClassLibs == moduleId)
        return (S_OK);

    // Now get a pointer to the code for this method.
    hr = m_pInfo->GetILFunctionBody(moduleId,
            tkMethod,
            &pMethodHeader,
            &cbMethod);
    if (FAILED(hr)) goto ErrExit;

    // Get an allocator which knows how to put memory in valid RVA range.
    hr = m_pInfo->GetILFunctionBodyAllocator( //@Todo: cache
            moduleId,
            &pMalloc);
    if (FAILED(hr)) goto ErrExit;

    // Allocate room for the existing method and some extra for the call.
    rgCode = (BYTE *) pMalloc->Alloc(cbMethod + cbExtra + 16);
    if (!rgCode)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    // Probe insertion code.
    {
        // Probe data template.
        static const BYTE rgProbeCall[] =
        {
            0x20,                                   // CEE_LDC_I4, Load 4 byte constant (FunctionID)
            0x01, 0x02, 0x03, 0x04,                 // 4 byte constant to overwrite.
            0x28,                                   // CEE_CALL, Call probe method.
            0x0a, 0x0b, 0x0c, 0x0d,                 // Token for the probe.
        };

        ModuleData *pModuleData = m_ModuleList.FindById(moduleId);
        _ASSERTE(pModuleData);

        if (((COR_ILMETHOD_TINY *) pMethodHeader)->IsTiny())
        {
            COR_ILMETHOD_TINY *pMethod = (COR_ILMETHOD_TINY *) pMethodHeader;
            
            // If adding the probe call doesn't make this a fat method, then
            // just add it.
            if (pMethod->GetCodeSize() + NumItems(rgProbeCall) < 64)
            {
                // Copy the header elements.
                iLen = sizeof(COR_ILMETHOD_TINY);
                memcpy(&rgCode[0], pMethod, iLen);

                // Add the probe.
                rgCode[iLen++] = 0x20; //@Todo: this macro is wrong? CEE_LDC_I4;
                *((ULONG *) (&rgCode[iLen])) = functionId;
                iLen += sizeof(ULONG);

                rgCode[iLen++] = 0x28; //CEE_CALL;
                *((ULONG *) (&rgCode[iLen])) = pModuleData->tkProbe;
                iLen += sizeof(ULONG);

                // Copy the rest of the method body.
                memcpy(&rgCode[iLen], pMethod->GetCode(), pMethod->GetCodeSize());
                iLen += pMethod->GetCodeSize() - sizeof(COR_ILMETHOD_TINY);

                rgCode[0] = CorILMethod_TinyFormat1 | ((iLen & 0xff) << 2);
            }
            // Otherwise need to migrate the entire header.
            else
            {
                // Create a fat header for the method.
                COR_ILMETHOD_FAT * pTo =  (COR_ILMETHOD_FAT *) rgCode;
                memset(pTo, 0, sizeof(COR_ILMETHOD_FAT));
                pTo->Flags = CorILMethod_FatFormat;
                pTo->Size = sizeof(COR_ILMETHOD_FAT) / sizeof(DWORD);
                pTo->MaxStack = ((COR_ILMETHOD_TINY *) 0)->GetMaxStack();
            
                // Copy the header elements.
                iLen = sizeof(COR_ILMETHOD_FAT);

                // Add the probe.
                rgCode[iLen++] = 0x20; //@Todo: this macro is wrong? CEE_LDC_I4;
                *((ULONG *) (&rgCode[iLen])) = functionId;
                iLen += sizeof(ULONG);

                rgCode[iLen++] = 0x28; //CEE_CALL;
                *((ULONG *) (&rgCode[iLen])) = pModuleData->tkProbe;
                iLen += sizeof(ULONG);

                // Copy the rest of the method body.
                memcpy(&rgCode[iLen], pMethod->GetCode(), pMethod->GetCodeSize());
                iLen += pMethod->GetCodeSize() - sizeof(COR_ILMETHOD_FAT);
                
                // Set the new code size.
                pTo->CodeSize = iLen;
            }
        }
        // Handle a fat method format.
        else
        {
            COR_ILMETHOD_FAT *pMethod = (COR_ILMETHOD_FAT *) pMethodHeader;
            COR_ILMETHOD_FAT *pTo = (COR_ILMETHOD_FAT *) rgCode;

            // Copy the header elements.
            iLen = sizeof(COR_ILMETHOD_FAT);
            memcpy(&rgCode[0], pMethod, iLen);

            // Add the probe.
            rgCode[iLen++] = 0x20; //@Todo: this macro is wrong? CEE_LDC_I4;
            *((ULONG *) (&rgCode[iLen])) = functionId;
            iLen += sizeof(ULONG);

            rgCode[iLen++] = 0x28; //CEE_CALL;
            *((ULONG *) (&rgCode[iLen])) = pModuleData->tkProbe;
            iLen += sizeof(ULONG);

            // Copy the rest of the method body.
            memcpy(&rgCode[iLen], pMethod->GetCode(), pMethod->GetCodeSize());
            iLen += pMethod->GetCodeSize();

            // Reset the size of the code itself in the header.
            pTo->CodeSize = iLen - sizeof(COR_ILMETHOD_FAT);

            if (cbExtra)
            {
                iLen = ALIGN4BYTE(iLen);
                memcpy(&rgCode[iLen], pMethod->GetSect(), cbExtra);
            }

            // Fix up exception lists by size of probe.
            FixupExceptions(pTo->GetSect(), sizeof(rgProbeCall));
        }
    }

    // Replace the method body with this new function.
    if (rgCode && iLen)
    {
        hr = m_pInfo->SetILFunctionBody(
                        moduleId,
                        tkMethod,
                        rgCode);
    }

ErrExit:
    if (pEmit)
        pEmit->Release();
    if (pMalloc)
        pMalloc->Release();
    return (hr);
}


//*****************************************************************************
// Record each unique function id that get's jit compiled.  This list will be
// used at shut down to correlate probe values (which use Function ID) to
// their corresponding name values.
//*****************************************************************************
COM_METHOD ProfCallback::JITCompilationFinished( 
    FunctionID  functionId,
    HRESULT     hrStatus,
    BOOL        fIsSafeToBlock)
{
    CLock       sLock(GetLock());
    FunctionData *p = m_FuncIdList.Append();
    if (!p)
        return (E_OUTOFMEMORY);
    p->CallCount = 0;
    p->id = functionId;

#ifdef _TESTCODE
{
    LPCBYTE pStart;
    ULONG cSize;
    m_pInfo->GetCodeInfo(functionId, &pStart, &cSize);
}
#endif

    return (S_OK);
}


//*****************************************************************************
// This'll get called, but we don't care.
//*****************************************************************************
COM_METHOD ProfCallback::ModuleLoadStarted( 
    /* [in] */ ModuleID moduleId)
{

#ifdef _TESTCODE
{
    LPCBYTE     pBaseLoad;
    AssemblyID  assemID;
    WCHAR       rcName[_MAX_PATH];
    ULONG       cchName;
    HRESULT     hr;

    hr = m_pInfo->GetModuleInfo(moduleId, 
                    &pBaseLoad,
                    NumItems(rcName),
                    &cchName,
                    rcName,
                    &assemID);
    _ASSERTE(hr == CORPROF_E_DATAINCOMPLETE);   
}
#endif

    return (E_NOTIMPL);
}


//*****************************************************************************
// After a module has been loaded, we need to open the metadata for it in
// read+write mode in order to add our probes to it.
//*****************************************************************************
COM_METHOD ProfCallback::ModuleLoadFinished( 
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus)
{
    IMetaDataEmit *pEmit = 0;           // Metadata interface.
    mdToken     tkProbe;                // Probe token.
    LPCBYTE     BaseAddress;            // Base address of the loaded module.
    WCHAR       rcModule[MAX_PATH];     // Path to module.
    WCHAR       rcDll[MAX_PATH];        // Name of file.
    HRESULT     hr;
    
    // we don't care about failed loads in this code.
    if (FAILED(hrStatus)) 
        return (S_OK);

    // Try to get the metadata for the module first of all.
    hr = m_pInfo->GetModuleMetaData(moduleId, ofWrite | ofRead,
            IID_IMetaDataEmit, (IUnknown **) &pEmit);
    if (FAILED(hr)) goto ErrExit;
    
    // Add the new metadata required to call our probes.
    hr = AddProbesToMetadata(pEmit, &tkProbe);
    if (FAILED(hr)) goto ErrExit;

    // Get the extra data about this module.
    hr = m_pInfo->GetModuleInfo(moduleId,
            &BaseAddress,
            MAX_PATH, 0, rcModule, 0);
    if (FAILED(hr)) goto ErrExit;

#if 0 //@todo: need to do this check dynamically.

    // If this is the class libraries, then we need to find the
    // security manager so we don't insert a probe in it.
    _wsplitpath(rcModule, 0, 0, rcDll, 0);
    if (_wcsicmp(rcDll, L"mscorlib") == 0)
    {
        IMetaDataImport *pImport;
        pEmit->QueryInterface(IID_IMetaDataImport, (void **) &pImport);
        hr = GetSecurityManager(pImport);
        if (FAILED(hr)) goto ErrExit;
        pImport->Release();
    }

#endif

    // Add a new module entry.
    if (hr == S_OK)
    {
        CLock sLock(GetLock());
        ModuleData *p = m_ModuleList.Append();
        if (!p)
            hr = E_OUTOFMEMORY;
        new (p) ModuleData;
        p->id = moduleId;
        p->pEmit = pEmit;
        p->tkProbe = tkProbe;
        p->BaseAddress = BaseAddress;
        p->SetName(rcModule);

        _wsplitpath(rcModule, 0, 0, rcDll, 0);
        if (_wcsicmp(rcDll, L"MSCORLIB") == 0)
            m_midClassLibs = moduleId;
    }

ErrExit:
    // Clean up on failure.
    if (FAILED(hr) && pEmit)
        pEmit->Release();
    return (hr);
}

COM_METHOD ProfCallback::ModuleUnloadStarted( 
    /* [in] */ ModuleID moduleId)
{
#ifdef _TESTCODE
{
    LPCBYTE     pBaseLoad;
    AssemblyID  assemID;
    WCHAR       rcName[_MAX_PATH];
    ULONG       cchName;
    HRESULT     hr;

    hr = m_pInfo->GetModuleInfo(moduleId, 
                    &pBaseLoad,
                    NumItems(rcName),
                    &cchName,
                    rcName,
                    &assemID);
    _ASSERTE(hr == S_OK);   
}
#endif

    return (E_NOTIMPL);
}


COM_METHOD ProfCallback::ModuleAttachedToAssembly( 
    ModuleID    moduleId,
    AssemblyID  AssemblyId)
{
#ifdef _TESTCODE
{
    LPCBYTE     pBaseLoad;
    AssemblyID  assemID;
    WCHAR       rcName[_MAX_PATH];
    ULONG       cchName;
    HRESULT     hr;

    hr = m_pInfo->GetModuleInfo(moduleId, 
                    &pBaseLoad,
                    NumItems(rcName),
                    &cchName,
                    rcName,
                    &assemID);
    _ASSERTE(hr == S_OK);   
    _ASSERTE(assemID == AssemblyId);

    AppDomainID appdomainid;
    hr = m_pInfo->GetAssemblyInfo(assemID, _MAX_PATH, &cchName, rcName, &appdomainid, 0 /*&moduleid*/);
    _ASSERTE(hr == S_OK);
}
#endif
    
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AppDomainCreationFinished( 
    AppDomainID appDomainId,
    HRESULT     hrStatus)
{
#ifdef _TESTCODE
    {
        HRESULT     hr;
        wchar_t     rcName[228];
        ULONG       cb;
        hr = m_pInfo->GetAppDomainInfo(appDomainId, NumItems(rcName), &cb, rcName, 0);
    }
#endif

    return (S_OK);
}

COM_METHOD ProfCallback::Shutdown()
{
    HRESULT     hr = S_OK;

    CLock       sLock(GetLock());

    // Walk the list of JIT'd functions and dump their names into the 
    // log file.

    // Open the output file
    HANDLE hOutFile = WszCreateFile(m_wszFilename, GENERIC_WRITE, 0, NULL,
                                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hOutFile != INVALID_HANDLE_VALUE)
    {
        hr = _DumpFunctionNamesToFile(hOutFile);
        CloseHandle(hOutFile);
    }

    // File was not opened for some reason
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
    return (hr);
}

#define DELIMS L" \t"

HRESULT ProfCallback::ParseConfig(WCHAR *wszConfig, DWORD *pdwRequestedEvents)
{
    HRESULT hr = S_OK;

    if (wszConfig != NULL)
    {
        for (WCHAR *wszToken = wcstok(wszConfig, DELIMS);
               SUCCEEDED(hr) && wszToken != NULL;
               wszToken = wcstok(NULL, DELIMS))
        {
            if (wszToken[0] != L'/' || wszToken[1] == L'\0')
                hr = E_INVALIDARG;
    
            // Other options.
            else 
            {
                switch (wszToken[1])
                {
                    // Signatures
                    case L's':
                    case L'S':
                    {
                        if (_wcsnicmp(&wszToken[1], SZ_SIGNATURES, LEN_SZ_SIGNATURES) == 0)
                        {
                            WCHAR *wszOpt = &wszToken[LEN_SZ_SIGNATURES + 2];
                            if (_wcsicmp(wszOpt, L"none") == 0)
                                m_eSig = SIG_NONE;
                            else if (_wcsicmp(wszOpt, L"always") == 0)
                                m_eSig = SIG_ALWAYS;
                            else
                                goto BadArg;
                        }
                        else
                            goto BadArg;
                    }
                    break;
                
                    // Bad arg.
                    default:
                    BadArg:
                    wprintf(L"Unknown option: '%s'\n", wszToken);
                    return (E_INVALIDARG);
                }

            }
        }
    }

    // Provide default file name.  This is done using the pattern ("%s_%08x.csv", szApp, pid).
    // This gives the report tool a deterministic way to find the correct dump file for
    // a given run.  If you recycle a PID for the same file name with this tecnique,
    // you're on your own:-)
    if (SUCCEEDED(hr))
    {
        WCHAR   rcExeName[_MAX_PATH];
        GetIcecapProfileOutFile(rcExeName);
        m_wszFilename = new WCHAR[wcslen(rcExeName) + 1];
        wcscpy(m_wszFilename, rcExeName);
    }

    return (hr);
}


//*****************************************************************************
// Walk the list of loaded functions, get their names, and then dump the list
// to the output symbol file.
//*****************************************************************************
HRESULT ProfCallback::_DumpFunctionNamesToFile( // Return code.
    HANDLE      hOutFile)               // Output file.
{
    int         i, iLen;                // Loop control.
    WCHAR       *szName = 0;            // Name buffer for fetch.
    ULONG       cchName, cch;           // How many chars max in name.
    char        *rgBuff = 0;            // Write buffer.
    ULONG       cbOffset;               // Current offset in buffer.
    ULONG       cbMax;                  // Max size of the buffer.
    ULONG       cb;                     // Working size buffer.
    HRESULT     hr;
    
    // Allocate a buffer to use for name lookup.
    cbMax = BUFFER_SIZE;
    rgBuff = (char *) malloc(cbMax);
    cchName = MAX_CLASSNAME_LENGTH;
    szName = (WCHAR *) malloc(cchName * 2);
    if (!rgBuff || !szName)
    {
        hr = OutOfMemory();
        goto ErrExit;
    }

    // Init the copy buffer with the column header.
    strcpy(rgBuff, SZ_COLUMNHDR);
    cbOffset = sizeof(SZ_COLUMNHDR) - 1;

    LOG((LF_CORPROF, LL_INFO10, "**PROFTABLE: MethodDesc, Handle, Name\n"));

    // Walk every JIT'd method and get it's name.
    for (i=0;  i<m_FuncIdList.Count();  i++)
    {
        // Dump the current text of the file.
        if (cbMax - cbOffset < 32)
        {
            if (!WriteFile(hOutFile, rgBuff, cbOffset, &cb, NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ErrExit;
            }
            cbOffset = 0;
        }

        // Add the function id to the dump.
        FunctionData *pFuncData = m_FuncIdList.Get(i);
        cbOffset += sprintf(&rgBuff[cbOffset], "%d,%08x,", 
                pFuncData->CallCount, pFuncData->id);

RetryName:
        hr = GetStringForFunction(m_FuncIdList[i].id, szName, cchName, &cch);
        if (FAILED(hr))
            goto ErrExit;

        // If the name was truncated, then make the name buffer bigger.
        if (cch > cchName)
        {
            WCHAR *sz = (WCHAR *) realloc(szName, (cchName + cch + 128) * 2);
            if (!sz)
            {
                hr = OutOfMemory();
                goto ErrExit;
            }
            szName = sz;
            cchName += cch + 128;
            goto RetryName;
        }

        LOG((LF_CORPROF, LL_INFO10, "%S\n", szName));

        // If the name cannot fit successfully into the disk buffer (assuming
        // worst case scenario of 2 bytes per unicode char), then the buffer
        // is too small and needs to get flushed to disk.
        if (cbMax - cbOffset < (cch * 2) + sizeof(SZ_CRLF))
        {
            // If this fires, it means that the copy buffer was too small.
            _ASSERTE(cch > 0);

            // Dump everything we do have before the truncation.
            if (!WriteFile(hOutFile, rgBuff, cbOffset, &cb, NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ErrExit;
            }

            // Reset the buffer to use the whole thing.
            cbOffset = 0;
        }

        // Convert the name buffer into the disk buffer.
        iLen = WideCharToMultiByte(CP_ACP, 0,
                    szName, -1,
                    &rgBuff[cbOffset], cbMax - cbOffset,
                    NULL, NULL);
        if (!iLen)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrExit;
        }
        --iLen;
        strcpy(&rgBuff[cbOffset + iLen], SZ_CRLF);
        cbOffset = cbOffset + iLen + sizeof(SZ_CRLF) - 1;
    }

    // If there is data left in the write buffer, flush it.
    if (cbOffset)
    {
        if (!WriteFile(hOutFile, rgBuff, cbOffset, &cb, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrExit;
        }
    }

ErrExit:
    if (rgBuff)
        free(rgBuff);
    if (szName)
        free(szName);
    return (hr);
}


//*****************************************************************************
// Given a function id, turn it into the corresponding name which will be used
// for symbol resolution.
//*****************************************************************************
HRESULT ProfCallback::GetStringForFunction( // Return code.
    FunctionID  functionId,             // ID of the function to get name for.
    WCHAR       *wszName,               // Output buffer for name.
    ULONG       cchName,                // Max chars for output buffer.
    ULONG       *pcName)                // Return name (truncation check).
{
    IMetaDataImport *pImport = 0;       // Metadata for reading.
    mdMethodDef funcToken;              // Token for metadata.
    HRESULT hr = S_OK;

    *wszName = 0;

    // Get the scope and token for the current function
    hr = m_pInfo->GetTokenAndMetaDataFromFunction(functionId, IID_IMetaDataImport, 
            (IUnknown **) &pImport, &funcToken);
    
    if (SUCCEEDED(hr))
    {
        // Initially, get the size of the function name string
        ULONG cFuncName;

        mdTypeDef classToken;
        WCHAR  wszFuncBuffer[BUF_SIZE];
        WCHAR  *wszFuncName = wszFuncBuffer;
        PCCOR_SIGNATURE pvSigBlob;
        ULONG  cbSig;

RetryName:
        hr = pImport->GetMethodProps(funcToken, &classToken, 
                    wszFuncBuffer, BUF_SIZE, &cFuncName, 
                    NULL, 
                    &pvSigBlob, &cbSig,
                    NULL, NULL);

        // If the function name is longer than the buffer, try again
        if (hr == CLDB_S_TRUNCATION)
        {
            wszFuncName = (WCHAR *)_alloca(cFuncName * sizeof(WCHAR));
            goto RetryName;
        }

        // Now get the name of the class
        if (SUCCEEDED(hr))
        {
            // Class name
            WCHAR wszClassBuffer[BUF_SIZE];
            WCHAR *wszClassName = wszClassBuffer;
            ULONG cClassName = BUF_SIZE;

            // Not a global function
            if (classToken != mdTypeDefNil)
            {
RetryClassName:
                hr = pImport->GetTypeDefProps(classToken, wszClassName,
                                            cClassName, &cClassName, NULL, 
                                            NULL);

                if (hr == CLDB_S_TRUNCATION)
                {
                    wszClassName = (WCHAR *)_alloca(cClassName * sizeof(WCHAR));
                    goto RetryClassName;
                }
            }

            // It's a global function
            else
                wszClassName = L"<Global>";

            if (SUCCEEDED(hr))
            {
                *pcName = wcslen(wszClassName) + sizeof(NAMESPACE_SEPARATOR_WSTR) +
                          wcslen(wszFuncName) + 1;

                // Check if the provided buffer is big enough
                if (cchName < *pcName)
                {
                    hr = S_FALSE;
                }

                // Otherwise, the buffer is big enough
                else
                {
                    wcscat(wszName, wszClassName);
                    wcscat(wszName, NAMESPACE_SEPARATOR_WSTR);
                    wcscat(wszName, wszFuncName);

                    // Add the formatted signature only if need be.
                    if (m_eSig == SIG_ALWAYS)
                    {
                        CQuickBytes qb;

                        PrettyPrintSig(pvSigBlob, cbSig, wszName,
                            &qb, pImport);

                        // Change spaces and commas into underscores so 
                        // that icecap doesn't have problems with them.
                        WCHAR *sz;
                        for (sz = (WCHAR *) qb.Ptr(); *sz;  sz++)
                        {
                            switch (*sz)
                            {
                                case L' ':
                                case L',':
                                    *sz = L'_';
                                    break;
                            }
                        }

                        // Copy big name for output, make sure it is null.
                        ULONG iCopy = qb.Size() / sizeof(WCHAR);
                        if (iCopy > cchName)
                            iCopy = cchName;
                        wcsncpy(wszName, (LPCWSTR) qb.Ptr(), cchName);
                        wszName[cchName - 1] = 0;
                    }

                    hr = S_OK;
                }
            }
        }
    }

    if (pImport) pImport->Release();
    return (hr);
}




//*****************************************************************************
// This method will add a new P-Invoke method definition into the metadata
// which we can then use to instrument code.  All pieces of code will be 
// updated to call this probe, first thing.
//*****************************************************************************
HRESULT ProfCallback::AddProbesToMetadata(
    IMetaDataEmit *pEmit,               // Emit interface for changes.
    mdToken     *ptk)                   // Return token here.
{
    mdToken     tkModuleRef;            // ModuleRef token.
    WCHAR       rcModule[_MAX_PATH];    // Name of this dll.
    HRESULT     hr;

    static const COR_SIGNATURE rgSig[] =
    {
        IMAGE_CEE_CS_CALLCONV_DEFAULT,      // __stdcall
        1,                                  // Argument count
        ELEMENT_TYPE_VOID,                  // Return type.
        ELEMENT_TYPE_U4                     // unsigned FunctionID
    };

    // Add a new global method def to the module which will be a place holder
    // for our probe.
    hr = pEmit->DefineMethod(mdTokenNil, 
                SZ_FUNC_CALL,
                mdPublic | mdStatic | mdPinvokeImpl,
                rgSig,
                NumItems(rgSig),
                0,
                miIL,
                ptk);
    if (FAILED(hr)) goto ErrExit;

    // Create a Module Reference to this dll so that P-Invoke can find the
    // entry point.
    DWORD ret;
    VERIFY(ret = WszGetModuleFileName(GetModuleInst(), rcModule, NumItems(rcModule)));
    if( ret == 0) 
	return E_UNEXPECTED;
    
    hr = pEmit->DefineModuleRef(rcModule, &tkModuleRef);
    if (FAILED(hr)) goto ErrExit;

    // Finally, we can add the P-Invoke mapping data which ties it altogether.
    hr = pEmit->DefinePinvokeMap(*ptk, 
                pmNoMangle | pmCallConvStdcall,
                SZ_FUNC_CALL,
                tkModuleRef);

ErrExit:
    return (hr);
}


//*****************************************************************************
// Helper method that given a class Id, can format the name.
//*****************************************************************************
HRESULT ProfCallback::GetNameOfClass(
    ClassID     classId,
    LPWSTR      &szName)
{
    ModuleID    moduleId;
    mdTypeDef   td;
    ULONG       cchName;
    HRESULT     hr;

    hr = m_pInfo->GetClassIDInfo(classId, &moduleId, &td);
    if (hr == S_OK)
    {
        IMetaDataImport *pImport = 0;
        ModuleData *pModuleData = m_ModuleList.FindById(moduleId);
        pModuleData->pEmit->QueryInterface(IID_IMetaDataImport, (void **) &pImport);

        hr = pImport->GetTypeDefProps(td, 0, 0, &cchName,
                0, 0);
        if (hr == S_OK)
        {
            szName = new WCHAR[cchName];
            if (szName)
            {
                hr = pImport->GetTypeDefProps(td, 
                        szName, cchName, 0,
                        0, 0);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        
        if (pImport)
            pImport->Release();
    }
    return (hr);
}


//*****************************************************************************
// Because this code is using P-Invoke, there is a nasty problem getting
// security initialized.  If you instrument the static ctor for security,
// then the call to your P-Invoke stub will cause security to try to init 
// itself, which causes a recursion.  So to get around this, you must not
// introduce the probe to the security static ctor and its call graph.
//*****************************************************************************
HRESULT ProfCallback::GetSecurityManager(
    IMetaDataImport *pImport)           // Metadata import API.
{
return 0;
#if 0
    LPCWSTR     szTypeDef = L"System.Security.SecurityManager";
    ULONG       mdCount = 0;
    mdMethodDef rgMD[10];
    WCHAR       szMD[MAX_CLASSNAME_LENGTH];
    HCORENUM    phEnum = 0;
    ULONG       i = 0;
    HRESULT     hr;
    
    hr = pImport->FindTypeDefByName(
            szTypeDef,              // [IN] Name of the Type.
            mdTokenNil,             // [IN] Enclosing class.
            &m_tdSecurityManager);  // [OUT] Put the TypeDef token here.
    if (FAILED(hr))
    {
        printf("Failed to find SecurityManager class");
        goto ErrExit;
    }
    hr = pImport->EnumMethods(&phEnum, m_SecurityManager, 0, 0, 0);
    if (FAILED(hr))
        goto ErrExit;
    
    while ((hr = pImport->EnumMethods(&phEnum, m_SecurityManager, rgMD, NumItems(rgMD), &mdCount)) == S_OK && 
        mdCount)
    {
        // Run through the methods and fill out our members
        for (i = 0; i < mdCount; i++)
        {
            hr = pImport->GetMethodProps(
                rgMD[i],                    
                NULL,                       
                szMD,                       
                MAX_CLASSNAME_LENGTH,                  
                NULL,                       
                NULL,                       
                NULL,                       
                NULL,                       
                NULL,                       
                NULL);
            if (FAILED(hr))
                goto ErrExit;

            if (wcscmp(COR_CCTOR_METHOD_NAME_W , szMD) == 0)
            {
                m_mdSecurityManager = rgMD[i];
                break;
            }
        }
    }       

    if (m_mdSecurityManager == mdTokenNil)
    {
        Printf(L"Failed to find SecurityManager " COR_CCTOR_METHOD_NAME_W);
        goto ErrExit;
    }

    pImport->CloseEnum(&phEnum);

ErrExit:
    return (hr);
#endif
}




//*****************************************************************************
// Called by the probe whenever a method is executed.  We use this as a chance
// to go updated the method count.
//*****************************************************************************
void ProfCallback::FunctionExecuted(
    FunctionID  fid)                    // Function called.
{
    CLock       sLock(GetLock());
    FunctionData *p = m_FuncIdList.FindById(fid);
    ++p->CallCount;
}


//*****************************************************************************
// This method is exported from this DLL so that P-Invoke can get to it.  When
// code is changed before it is jitted, it is updated to call this method.
// This method will then record each function that is actually run.
//*****************************************************************************
extern "C"
{

void __stdcall ILCoverFunc(unsigned __int32 FunctionId)
{
    g_pProfCallback->FunctionExecuted(FunctionId);
}

};



//*****************************************************************************
// Walk the list of sections of data looking for exceptions. Fix up their
// offset data by the size of the inserted probe.
//*****************************************************************************
void FixupExceptions(const COR_ILMETHOD_SECT *pSect, int offset)
{
    while (pSect)
    {
        if (pSect->Kind() == CorILMethod_Sect_EHTable)
        {
            COR_ILMETHOD_SECT_EH *peh = (COR_ILMETHOD_SECT_EH *) pSect;
            if (!peh->IsFat())
            {
                COR_ILMETHOD_SECT_EH_SMALL *pSmall = (COR_ILMETHOD_SECT_EH_SMALL *) peh;
    
                for (unsigned i=0;  i<peh->EHCount();  i++)
                {
                    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL *pseh = &pSmall->Clauses[i];

                    if (pseh->Flags & COR_ILEXCEPTION_CLAUSE_FILTER)
                        pseh->FilterOffset += offset;

                    pseh->TryOffset += offset;
                    pseh->HandlerOffset += offset;
                }
            }
            else
            {
                COR_ILMETHOD_SECT_EH_FAT *pFat = (COR_ILMETHOD_SECT_EH_FAT *) peh;

                for (unsigned i=0;  i<peh->EHCount();  i++)
                {
                    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT *pfeh = &pFat->Clauses[i];

                    if (pfeh->Flags & COR_ILEXCEPTION_CLAUSE_FILTER)
                        pfeh->FilterOffset += offset;

                    pfeh->HandlerOffset += offset;
                    pfeh->TryOffset += offset;
                }
            }
        }
        pSect = pSect->Next();
    }
}



//*****************************************************************************
// A printf method which can figure out where output goes.
//*****************************************************************************
int __cdecl Printf(                     // cch
    const WCHAR *szFmt,                 // Format control string.
    ...)                                // Data.
{
    static HANDLE hOutput = INVALID_HANDLE_VALUE;
    va_list     marker;                 // User text.
    WCHAR       rcMsgw[1024];           // Buffer for format.

#ifdef _TESTCODE
//@Todo: take this out, just testing a theory.
return (0);
#endif

    // Get standard output handle.
    if (hOutput == INVALID_HANDLE_VALUE)
    {
        hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
        if (hOutput == INVALID_HANDLE_VALUE)
            return (-1);
    }

    // Format the error.
    va_start(marker, szFmt);
    _vsnwprintf(rcMsgw, sizeof(rcMsgw)/sizeof(rcMsgw[0]), szFmt, marker);
    rcMsgw[sizeof(rcMsgw)/sizeof(rcMsgw[0]) - 1] = 0;
    va_end(marker);
    
    ULONG cb;
    int iLen = wcslen(rcMsgw);
    char        rcMsg[NumItems(rcMsgw) * 2];
    iLen = wcstombs(rcMsg, rcMsgw, iLen + 1);
    const char *sz;
    for (sz=rcMsg;  *sz;  )
    {
        const char *szcrlf = strchr(sz, '\n');
        if (!szcrlf)
            szcrlf = sz + strlen(sz);
        WriteFile(hOutput, rcMsg, szcrlf - sz, &cb, 0);
        sz = szcrlf;
        if (*sz == '\n')
        {
            WriteFile(hOutput, "\r\n", 2, &cb, 0);
            ++sz;
        }
    }
    return (iLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdio.h>

#include <Windows.h>
#include <cor.h>
#include <CorError.h>
#include <crtdbg.h>

#include "corprof.h"

#define COM_METHOD HRESULT STDMETHODCALLTYPE

#ifdef _DEBUG

#define LOGGING

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif

#include "log.h"

HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>

#define THROW_ERROR(txt)		{ DEBUGOUTPUT(L"*** " L##txt L"\r\n"); throw 1; }
#define THROW_ERROR1(txt,var1)	{ DEBUGOUTPUT1(L"*** " L##txt L"\r\n", var1); throw 1; }
#define CheckHrAndThrow(txt) \
	if (FAILED(hr)) { DEBUGOUTPUT2(L"ERROR in %s hr=%0x \r\n",txt,hr); throw((int)hr); }


#ifndef DEBUG
#define DEBUGOUTPUT(s) {WszOutputDebugString(s);};
#define DEBUGOUTPUT1(s,v1) {wchar_t buf[1000]; _snwprintf(buf,999,s,v1); WszOutputDebugString(buf);}
#define DEBUGOUTPUT2(s,v1,v2) {wchar_t buf[1000]; _snwprintf(buf,999,s,v1,v2); WszOutputDebugString(buf);}
#define DEBUGOUTPUT3(s,v1,v2,v3) {wchar_t buf[1000]; _snwprintf(buf,999,s,v1,v2,v3); WszOutputDebugString(buf);}
#else
#define DEBUGOUTPUT(s) ;
#define DEBUGOUTPUT1(s,v1) ;
#define DEBUGOUTPUT2(s,v1,v2) ;
#define DEBUGOUTPUT3(s,v1,v2,v3) ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mscorilc.dll"
#define VER_FILEDESCRIPTION_STR "Common Language Runtime profiler dll\0"
#define VER_ORIGFILENAME_STR    "mscorilc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\classfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"
#include "ClassFactory.h"
#include "mscorilc.h"
#include "UtilCode.h"
#include "Mscoree.h"

// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();


//********** Globals. *********************************************************

static const LPCWSTR g_szCoclassDesc    = L"Microsoft Common Language Runtime Code Coverage Profile DLL";
static const LPCWSTR g_szProgIDPrefix   = L"CLRCodeCoverageTool";
static const LPCWSTR g_szThreadingModel = L"Both";
const int            g_iVersion = 1; // Version of coclasses.
HINSTANCE            g_hInst;        // Instance handle to this piece of code.

// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
    &CLSID_CorCodeCoverage,     L"CLRCodeCoverageTool",         ProfCallback::CreateObject,
    NULL,                       NULL,                           NULL
};


//********** Locals. **********************************************************

STDAPI DllUnregisterServer(void);

//********** Code. ************************************************************

//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.
//*****************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Save off the instance handle for later use.
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        OnUnicodeSystem();
        g_hInst = hInstance;
        DisableThreadLibraryCalls(hInstance);
#ifdef LOGGING      
        InitializeLogging();
#endif
    }
    return TRUE;
}

//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
STDAPI DllRegisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.
    HRESULT     hr = S_OK;

    // Initialize some variables so WszXXX will work
    OnUnicodeSystem();

    // Erase all doubt from old entries.
    DllUnregisterServer();

    // Get the filename for this module.
    if(!WszGetModuleFileName(GetModuleInst(), rcModule, NumItems(rcModule)))
        return E_UNEXPECTED;
    
    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    IfFailGo(GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth));

    // For each item in the coclass list, register it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        // Register the class with default values.
        if (FAILED(hr = REGUTIL::RegisterCOMClass(
                *pCoClass->pClsid, 
                g_szCoclassDesc, 
                g_szProgIDPrefix,
                g_iVersion, 
                pCoClass->szProgID, 
                g_szThreadingModel, 
                rcModule,
                GetModuleInst(),
                NULL,
                rcVersion,
                true,
                false)))
            goto ErrExit;
    }

ErrExit:
    if (FAILED(hr))
        DllUnregisterServer();
    return (hr);
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
STDAPI DllUnregisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    // Initialize some variables so WszXXX will work
    OnUnicodeSystem();

    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
                    g_iVersion, pCoClass->szProgID, true);
    }
    return (S_OK);
}


//*****************************************************************************
// Called by COM to get a class factory for a given CLSID.  If it is one we
// support, instantiate a class factory object and prepare for create instance.
//*****************************************************************************
STDAPI DllGetClassObjectInternal(               // Return code.
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    CClassFactory *pClassFactory;       // To create class factory object.
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    // Scan for the right one.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        if (*pCoClass->pClsid == rclsid)
        {
            // Allocate the new factory object.
            pClassFactory = new CClassFactory(pCoClass);
            if (!pClassFactory)
                return (E_OUTOFMEMORY);
    
            // Pick the v-table based on the caller's request.
            hr = pClassFactory->QueryInterface(riid, ppv);
    
            // Always release the local reference, if QI failed it will be
            // the only one and the object gets freed.
            pClassFactory->Release();
            break;
        }
    }
    return (hr);
}



//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;
    
    // Avoid confusion.
    *ppvObject = NULL;
    
    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;
    
    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;
    
    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);
    
    // Aggregation is not supported by these objects.
    if (pUnkOuter)
        return (CLASS_E_NOAGGREGATION);
    
    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
    BOOL        fLock)
{
//@todo: hook up lock server logic.
    return (S_OK);
}





//*****************************************************************************
// This helper provides access to the instance handle of the loaded image.
//*****************************************************************************
HINSTANCE GetModuleInst()
{
    return g_hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\mscorilc\mscorilc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#ifndef __PROFILER_H__
#define __PROFILER_H__

#include "..\common\callbackbase.h"
#include "CorProf.h"
#include "UtilCode.h" 
#include <utsem.h>


#define BUF_SIZE 512
#define DEFAULT_SAMPLE_DELAY 5 // in milliseconds
#define DEFAULT_DUMP_FREQ    1000 // in milliseconds
#define CONFIG_ENV_VAR       L"PROF_CONFIG"


// {3DF3799F-2832-11d3-8531-00A0C9B4D50C}
extern const GUID __declspec(selectany) CLSID_CorCodeCoverage = 
{ 0x3df3799f, 0x2832, 0x11d3, { 0x85, 0x31, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };



int __cdecl Printf(                     // cch
    const WCHAR *szFmt,                 // Format control string.
    ...);                               // Data.


//********** Types. ***********************************************************


struct ModuleData
{
    ModuleData()
    { memset(this, 0, sizeof(ModuleData)); }

    ~ModuleData()
    {
        if (szName)
            delete [] szName;
    }

    ModuleID    id;                     // Profiling handle for module.
    IMetaDataEmit *pEmit;               // Metadata handle.
    mdToken     tkProbe;                // Metadata token for probe call.

    // Info.
    LPCBYTE     BaseAddress;            // Load address of the module.
    LPWSTR      szName;                 // Name of the loaded dll.

    inline void SetName(LPCWSTR szIn)
    {
        if (szName) delete [] szName;
        szName = new WCHAR[wcslen(szIn) + 1];
        if (szName)
            wcscpy(szName, szIn);
    }

};

struct FunctionData
{
    FunctionID  id;                     // Profiling handle of function.
    unsigned    CallCount;              // How many times did it get called?
};

typedef CDynArray<FunctionData> FUNCTIONIDLIST;
typedef CDynArray<ModuleData> MODULELIST;

enum SIGTYPE
{
    SIG_NONE,                           // Signatures are never shown.
    SIG_ALWAYS                          // Signatures are always shown.
};


// Helper class provides a lookup mechanism.
class CModuleList : public MODULELIST
{
public:
    ModuleData *FindById(ModuleID id)
    {
        for (int i=0;  i<Count();  i++)
        {
            ModuleData *p = Get(i);
            if (p->id == id)
                return (p);
        }
        return (0);
    }
};

class CFunctionList : public FUNCTIONIDLIST
{
public:
    FunctionData *FindById(FunctionID id)
    {
        for (int i=0;  i<Count();  i++)
        {
            FunctionData *p = Get(i);
            if (p->id == id)
                return (p);
        }
        return (0);
    }
};


/* ------------------------------------------------------------------------- *
 * ProfCallback is an implementation of ICorProfilerCallback
 * ------------------------------------------------------------------------- */

class ProfCallback : public ProfCallbackBase
{
public:
    ProfCallback();

    ~ProfCallback();

    /*********************************************************************
     * IUnknown Support
     */

    COM_METHOD QueryInterface(REFIID id, void **pInterface)
    {
    	if (id == IID_ICorProfilerCallback)
    		*pInterface = (ICorProfilerCallback *)this;
        else
            return (ProfCallbackBase::QueryInterface(id, pInterface));

        AddRef();

    	return (S_OK);
    }


    /*********************************************************************
     * ICorProfilerCallback methods
     */
    COM_METHOD Initialize( 
        /* [in] */ IUnknown *pEventInfoUnk,
        /* [out] */ DWORD *pdwRequestedEvents);
    
    COM_METHOD ClassLoadStarted( 
        /* [in] */ ClassID classId);
    
    COM_METHOD ClassLoadFinished( 
        /* [in] */ ClassID classId,
        /* [in] */ HRESULT hrStatus);

    COM_METHOD JITCompilationFinished( 
        /* [in] */ FunctionID functionId,
        /* [in] */ HRESULT hrStatus,
        /* [in] */ BOOL fIsSafeToBlock);
    
    COM_METHOD JITCompilationStarted( 
        /* [in] */ FunctionID functionId,
        /* [in] */ BOOL fIsSafeToBlock);
    
    COM_METHOD ModuleLoadStarted( 
        /* [in] */ ModuleID moduleId);
    
    COM_METHOD ModuleLoadFinished( 
        /* [in] */ ModuleID moduleId,
        /* [in] */ HRESULT hrStatus);
    
    COM_METHOD ModuleUnloadStarted( 
        /* [in] */ ModuleID moduleId);
    
    COM_METHOD ModuleAttachedToAssembly( 
        ModuleID    moduleId,
        AssemblyID  AssemblyId);

    COM_METHOD AppDomainCreationFinished( 
        AppDomainID appDomainId,
        HRESULT     hrStatus);
    
    COM_METHOD Shutdown( void);
    
    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_ICorProfilerCallback)
            return (E_NOINTERFACE);

        ProfCallback *ppc = new ProfCallback();

        if (ppc == NULL)
            return (E_OUTOFMEMORY);

        ppc->AddRef();
        *object = (ICorProfilerCallback *)ppc;

        return (S_OK);
    }


//*****************************************************************************
// Given a function id, turn it into the corresponding name which will be used
// for symbol resolution.
//*****************************************************************************
    HRESULT GetStringForFunction(           // Return code.
        FunctionID  functionId,             // ID of the function to get name for.
        WCHAR       *wszName,               // Output buffer for name.
        ULONG       cchName,                // Max chars for output buffer.
        ULONG       *pcName);               // Return name (truncation check).

//*****************************************************************************
// Walk the list of loaded functions, get their names, and then dump the list
// to the output symbol file.
//*****************************************************************************
    HRESULT _DumpFunctionNamesToFile(       // Return code.
        HANDLE      hOutFile);              // Output file.

//*****************************************************************************
// This method will add a new P-Invoke method definition into the metadata
// which we can then use to instrument code.  All pieces of code will be 
// updated to call this probe, first thing.
//*****************************************************************************
    HRESULT AddProbesToMetadata(
        IMetaDataEmit *pEmit,               // Emit interface for changes.
        mdToken     *ptk);                  // Return token here.

//*****************************************************************************
// Called by the probe whenever a method is executed.  We use this as a chance
// to go updated the method count.
//*****************************************************************************
    void FunctionExecuted(
        FunctionID  fid);                   // Function called.

//*****************************************************************************
// Helper method that given a class Id, can format the name.
//*****************************************************************************
    HRESULT GetNameOfClass(
        ClassID     classId,
        LPWSTR      &szName);

//*****************************************************************************
// Because this code is using P-Invoke, there is a nasty problem getting
// security initialized.  If you instrument the static ctor for security,
// then the call to your P-Invoke stub will cause security to try to init 
// itself, which causes a recursion.  So to get around this, you must not
// introduce the probe to the security static ctor and its call graph.
//*****************************************************************************
    HRESULT GetSecurityManager(
        IMetaDataImport *pImport);          // Metadata import API.

    bool IsInstrumenting()
    { return (m_bInstrument); }

    CSemExclusive *GetLock()
    { return (&m_Lock); }

private:

    /*
     * This is used to parse the configuration switches
     */
    HRESULT ParseConfig(WCHAR *wszConfig, DWORD *pdwRequestedEvents);

    // Locking/callback infrastructure.
    ICorProfilerInfo *m_pInfo;          // Callback into EE for more info.
    CSemExclusive   m_Lock;             // List protection.

    // Probe insertion data.
    mdToken         m_mdSecurityManager;// static class initializer
    mdToken         m_tdSecurityManager;// Typedef of security class
    ModuleID        m_midClassLibs;     // ID of the class libraries.
    bool            m_bInstrument;      // true if code should be instrumented.
    CFunctionList   m_FuncIdList;       // List of JIT compiled methods.
    CModuleList     m_ModuleList;       // List of loaded modules.

    // User option data values.
    WCHAR           *m_wszFilename;     // Name of output file.
    enum SIGTYPE    m_eSig;             // How to log signatures.
    int             m_indent;           // Index for pretty print.
};




#endif /* __PROFILER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\getconfigstring.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// CheckParser1.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <xmlparser.hpp>
#include <objbase.h>
#include <mscorcfg.h>
#include <stdio.h>
#include "common.h"                 
#include "GetConfigString.h"
#include "GetStringConfigFactory.h"


/*
Searched string "xxxxxx" has located bt following format:
....
<section>
....   
<add tag-key-name="tag-key-value" attr-name="xxxxxxxx" .../>
....   
</section>
....
*/


HRESULT hr;

//////////////////////////////////////////////////////////////////////
HRESULT _stdcall GetConfigString( LPCWSTR confFileName,
								 LPCWSTR section,
								 LPCWSTR tagKeyName,
								 LPCWSTR attrName,
								 LPWSTR strbuf,
								 DWORD buflen)               
{
	IXMLParser     *pIXMLParser = NULL;
	IStream        *pFile = NULL;
	GetStringConfigFactory *factory = NULL; 

	hr = CreateConfigStream(confFileName, &pFile);
	if(FAILED(hr)) goto Exit;

	hr = GetXMLObject(&pIXMLParser);
	if(FAILED(hr)) goto Exit;

	factory = new GetStringConfigFactory(section, tagKeyName, attrName, strbuf, buflen);
	if ( ! factory) { 
		hr = E_OUTOFMEMORY; 
		goto Exit; 
	}

	factory->AddRef();
	hr = pIXMLParser->SetInput(pFile);  
	if ( ! SUCCEEDED(hr)) 
		goto Exit;

	hr = pIXMLParser->SetFactory(factory);
	if ( ! SUCCEEDED(hr)) 
		goto Exit;

	hr = pIXMLParser->Run(-1);

Exit:  
	if (hr==XML_E_MISSINGROOT)
		hr=S_OK;

	if (hr==HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		hr=S_FALSE;

	if (pIXMLParser) { 
		pIXMLParser->Release();
		pIXMLParser= NULL ; 
	}
	if ( factory) {
		factory->Release();
		factory=NULL;
	}
	if ( pFile) {
		pFile->Release();
		pFile=NULL;
	}

	if (hr) {		
		return -1;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\getconfigstring.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include <windows.h>

HRESULT _stdcall GetConfigString( LPCWSTR confFileName,
								 LPCWSTR section,
								 LPCWSTR tagKeyName, 		 
								 LPCWSTR attrName, 
								 LPWSTR strbuf,
								 DWORD buflen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\getstringconfigfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Parses XML file and fills output buffer with specific tag string value
//

#ifndef PERFCCONFIGFACTORY_H
#define PERFCCONFIGFACTORY_H

#define MAX_CONFIG_STRING_SIZE  250

class GetStringConfigFactory : public _unknown<IXMLNodeFactory, &IID_IXMLNodeFactory>
{

public:
	GetStringConfigFactory(LPCWSTR section,
		LPCWSTR tagKeyName,					   
		LPCWSTR attrName,   
		LPWSTR strbuf, 
		DWORD buflen);
	virtual ~GetStringConfigFactory();

	HRESULT STDMETHODCALLTYPE NotifyEvent( 
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ XML_NODEFACTORY_EVENT iEvt);

		HRESULT STDMETHODCALLTYPE BeginChildren( 
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

		HRESULT STDMETHODCALLTYPE EndChildren( 
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

		HRESULT STDMETHODCALLTYPE Error( 
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ HRESULT hrErrorCode,
		/* [in] */ USHORT cNumRecs,
		/* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

		HRESULT STDMETHODCALLTYPE CreateNode( 
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ PVOID pNodeParent,
		/* [in] */ USHORT cNumRecs,
		/* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

private:


	HRESULT CopyResultString(LPCWSTR strbuf, DWORD buflen);
	void 	TrimStringToBuf(LPCWSTR wsz, DWORD lgth); 

	// Parameter Data

	LPCWSTR m_section;		 //	L"system.diagnostics"
	LPCWSTR m_tagKeyName;	 //	L"name"				 --	 attr to detect our element
	LPCWSTR m_tagKeyValue;	 //	L"FileMappingSize"	 --	 key value to detect our element
	LPCWSTR m_attrName;		 // L"value"		<-- name of attr containing searched value.
	LPWSTR 	m_strbuf;      /*out*/ 	   
	DWORD 	m_buflen;      /*out*/ 

	// Data

	LPWSTR  m_pLastKey;
	DWORD   m_dwLastKey;

	DWORD   m_Depth;					// current depth of elements
	BOOL    m_IsInsideSection;
	bool    m_SearchComplete; 			// true, when string is found 

	// temporary buffer for trimmed string    
	WCHAR  m_wstr[MAX_CONFIG_STRING_SIZE+2]; 
	DWORD  m_dwSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\performancecountermanager.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once
#pragma warning(disable:4786)

#include "SharedPerformanceCounter.h"

/////////////////////////////////////////////////////////////
struct LARGE_COUNTER_DATA {
	LARGE_INTEGER value;
};

struct  DWORD_COUNTER_DATA {
	int value;
};

struct ObjectData {
	int				m_ObjectId;					// key to search object on request
	TInt_Array		m_CounterTypes;
	TInt_Array		m_CounterNameHashCodes;            
	TWStr_Array		m_CounterNames;
	int				m_CategoryNameHashCode;
	std::wstring	m_CategoryName;
	int				m_FirstCounterId;
	int				m_FirstHelpId;
};

typedef	std::vector<ObjectData> TObjects_Table;

/////////////////////////////////////////////////////////////

class CPerformanceCounterManager : CSharedPerformanceCounter 
{
public:
	CPerformanceCounterManager();
	virtual ~CPerformanceCounterManager();

	void CollectData( 
		/* [in] */ long			id,
		/* [in] */ LPWSTR		valueName,
		/* [in] */ INT_PTR		data,
		/* [in] */ long			totalBytes,
		/* [out]*/ PINT_PTR		res );

		void	CleanIds();		// starts IDs from scratch

private:

	bool 	m_closed;		
	bool	m_initError;
	bool	m_FirstEntry;
	unsigned int		m_queryIndex;
	LARGE_INTEGER	m_PerfFrequency;

	// lookup structures
	TObjects_Table	m_perfObjects;

	std::wstring				m_previousQuery;
	std::auto_ptr< TInt_Array >	m_queryIds;	// object numbers requested

protected:

	void Initialize();                    
	int GetCurrentQueryId(std::wstring requested_items);
	int GetSpaceRequired(int objectId); 
	void CopyAllKeys(TInt_Array& keys);				// copies all keys to array
	TInt_Array* GetObjectIds(std::wstring query);

	ObjectData& FindDataForObjectId(int objId);		// analog of hash table search in managed code 
	bool IsObjectIdContained(int objId);			// Search "hash" table and return 'true' if ObjectId is contained.

	BYTE_PTR CreateDataForObject(int id, BYTE_PTR data);
	void	 InitPerfObjectType(BYTE_PTR ptr, ObjectData& data, int numInstances, int totalByteLength); 
	int		 InitCounterDefinition(BYTE_PTR ptr, int counterIndex, ObjectData& data, int nextCounterOffset); 
	BYTE_PTR InitCounterData(	BYTE_PTR ptr, int instanceNameHashCode, 
		std::wstring instanceName, ObjectData& data); 
	BYTE_PTR InitInstanceDefinition(BYTE_PTR ptr, int parentObjectTitleIndex,
		int parentObjectInstance, int uniqueID, std::wstring name);

	LARGE_INTEGER	GetFrequency(); 
	LARGE_INTEGER	GetCurrentPerfTime(); 

};

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\getstringconfigfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Parses XML file and fills output buffer with specific tag string value
//

#include "stdafx.h"
#include <mscoree.h>
#include <xmlparser.hpp>
#include <objbase.h>
#include <mscorcfg.h>

#include "Common.h"
#include "GetConfigString.h"
#include "GetStringConfigFactory.h"

#define ISWHITE(ch) ((ch) >= 0x09 && (ch) <= 0x0D || (ch) == 0x20)

typedef enum { 
	CURR_ATTR_TYPE_INVALID = 0,
	CURR_ATTR_TYPE_KEY,
	CURR_ATTR_TYPE_VALUE ,
	CURR_ATTR_TYPE_UNKNOWN
} CurrentAttributeBrand;

//---------------------------------------------------------------------------
GetStringConfigFactory::GetStringConfigFactory(
	LPCWSTR section,
	LPCWSTR tagKeyName,					   
	LPCWSTR attrName,   
	LPWSTR strbuf,           /*out*/ 
	DWORD buflen)
{
	m_section = section;
	m_tagKeyName = tagKeyName;	
	m_attrName = attrName;
	m_strbuf  = strbuf ;
	m_buflen  = buflen ;

	m_Depth = 0;
	m_IsInsideSection = FALSE;
	m_strbuf[0] = 0;                    // clean output
	m_SearchComplete = false; 
}

//---------------------------------------------------------------------------
GetStringConfigFactory::~GetStringConfigFactory() 
{
}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE GetStringConfigFactory::Error( 
	/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
	/* [in] */ HRESULT hrErrorCode,
	/* [in] */ USHORT cNumRecs,
	/* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
	WCHAR * error_info; 
	pSource->GetErrorInfo(&error_info);
	return hrErrorCode;
}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE GetStringConfigFactory::NotifyEvent( 
	/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
	/* [in] */ XML_NODEFACTORY_EVENT iEvt)
{    
	if(iEvt == XMLNF_ENDDOCUMENT) {
		// @TODO: add error handling ??
	}
	return S_OK;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE GetStringConfigFactory::BeginChildren( 
	/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
	/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
	m_Depth++;
	if ( m_IsInsideSection || m_SearchComplete ) 
		return S_OK;

	TrimStringToBuf( (WCHAR*) pNodeInfo->pwcText, pNodeInfo->ulLen);       
	if (_wcsicmp(m_wstr, m_section) == 0 ) {      // section start found
		if (m_Depth > 1 ) {
			m_IsInsideSection = TRUE;
		}
	}
	return S_OK;
}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE GetStringConfigFactory::EndChildren( 
	/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
	if ( fEmptyNode ) { 
		return S_OK;
	}

	m_Depth--;
	if ( !m_IsInsideSection ) 
		return S_OK;

	TrimStringToBuf((WCHAR*) pNodeInfo->pwcText, pNodeInfo->ulLen);
	if (wcscmp(m_wstr, m_section) == 0) {
		m_IsInsideSection = FALSE;        
	}
	return S_OK;
}

//---------------------------------------------------------------------------
//    Trim the string value into the buffer 'm_wstr' 
void GetStringConfigFactory::TrimStringToBuf(LPCWSTR ptr, DWORD lgth) 
{
	if ( lgth > MAX_CONFIG_STRING_SIZE )   
		lgth = MAX_CONFIG_STRING_SIZE;

    for(;*ptr && ISWHITE(*ptr) && lgth>0; ptr++, lgth--);
    while( lgth > 0 && ISWHITE(ptr[lgth-1]))
            lgth--;
	wcsncpy(m_wstr, ptr, lgth);
	m_dwSize = lgth;
	m_wstr[lgth] = L'\0';
}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE GetStringConfigFactory::CreateNode( 
	/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
	/* [in] */ PVOID pNode,
	/* [in] */ USHORT cNumRecs,
	/* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
	DWORD  i; 
	BOOL fAttributeFound = FALSE;
	CurrentAttributeBrand curr_attr_brand = CURR_ATTR_TYPE_INVALID;

	if (!m_IsInsideSection || m_SearchComplete) 
		return S_OK;

	//
	//  Iterate through tag's tokens
	//
	for( i = 0; i < cNumRecs; i++) { 
		DWORD type = apNodeInfo[i]->dwType;            
		if (type != XML_ELEMENT && type != XML_ATTRIBUTE && type != XML_PCDATA) 
			continue;

		TrimStringToBuf((WCHAR*) apNodeInfo[i]->pwcText, apNodeInfo[i]->ulLen);

		switch(type) {

			case XML_ELEMENT :                     
				if(wcscmp(m_wstr, m_tagKeyName) != 0)
					return S_OK;

				break;
			case XML_ATTRIBUTE :                                     
				if(wcscmp(m_wstr, m_attrName) == 0) 
					fAttributeFound = TRUE;

				break;            
			case XML_PCDATA :                        
				if (fAttributeFound) {               
					wcsncpy(m_strbuf, m_wstr, m_buflen);     // copy string to destination
					m_strbuf[m_buflen-1] = 0;                // put EOS for safety                
					return S_OK;
				}            
				break ;     

			default: 
				;

		} // end-switch

	} // end-for

	return S_OK;
}

///
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\performancecountermanager.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "stdafx.h"
#include <windows.h>
#include "Common.h"
#include "PerformanceCounterManager.h"
#pragma warning(disable:4267)
#pragma warning(disable:4786)
#pragma warning(disable:4244)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPerformanceCounterManager::CPerformanceCounterManager()
{
	m_closed		= false;
	m_initError	= false;
	m_FirstEntry	= true;
	m_queryIndex	= 0;
	m_PerfFrequency = ZeroLargeInteger();
}

////////////////////////////////////////////////////////////////////////
CPerformanceCounterManager::~CPerformanceCounterManager()
{
}

/////////////////////////////////////////////////////////////////////
//       res == -1 - initialization error
//       res == -2 -  more data
void CPerformanceCounterManager::CollectData( 
	/* [in] */ long			id,
	/* [in] */ LPWSTR		valueName,
	/* [in] */ INT_PTR		data,
	/* [in] */ long			totalBytes,
	/* [out]*/ PINT_PTR		res )
{	
	if (m_closed) 
		*res = (INT_PTR)(-1);
	else {
		try {                    
			Initialize();                    
			if (m_initError) 
				*res = (INT_PTR)(-1);
			else {
				std::wstring requestedItems = valueName;
				int id = GetCurrentQueryId(requestedItems);
				if (id == 0) 
					*res = data;
				else {
					if (GetSpaceRequired(id) > totalBytes) 
						*res = (INT_PTR)(-2);
					else                                                                         
						*res = (INT_PTR)CreateDataForObject(id, (BYTE_PTR)data);
				}                            
			}                     
		}
		catch (...) {                
			DEBUGOUTPUT(L"*** CPerformanceCounterManager::CollectData error \r\n"); 
			m_initError = true;
			*res = (INT_PTR)(-1);                    
			m_FirstEntry = false;
		}
	}
}

////////////////////////////////////////////////////////////////////////
// starts IDs from scratch
void	CPerformanceCounterManager::CleanIds()		
{
	m_previousQuery = L"";
}

////////////////////////////////////////////////////////////////////////
int CPerformanceCounterManager::GetCurrentQueryId(std::wstring query)
{
	int result = 0;
	if (query != m_previousQuery) {
		m_previousQuery = query;
		m_queryIds.reset(0);
	}

	if (m_queryIds.get() == 0) {
		m_queryIds.reset( GetObjectIds(query) );
		if (m_queryIds.get() == 0)
			goto leave;
		m_queryIndex = 0;
	}

	result = (*m_queryIds)[m_queryIndex];
	++m_queryIndex;
	if ( m_queryIndex == (*m_queryIds).size() )
		m_queryIds.reset(0);

leave:	
	return result;                
}

////////////////////////////////////////////////////////////////////////
//  Fill array of object ids from the string
TInt_Array* CPerformanceCounterManager::GetObjectIds(std::wstring query) 
{
	if ( m_perfObjects.size() == 0 )
		return 0;	// no managed counters installed

	std::auto_ptr<TInt_Array> ids( new TInt_Array );                
	if (query == L"Global") {
		CopyAllKeys(*ids);		// copy all keys to 
	}                
	else {     
		const   wchar_t* pwc = query.c_str();
		int		pos = 0;
		int		reqlen = query.size();
		bool	space_required = false;	// true, when we are skippnig to the next space 
		wchar_t *endScanWChar;

		while ( pos < reqlen) 
		{
			if ( !iswspace(*pwc) ) // non-space found
			{
				if (!space_required) {
					int currentId = wcstol(pwc, &endScanWChar, 10);
					if ( IsObjectIdContained(currentId) )	
						ids->push_back(currentId);			// Store Id, if its ours.
					space_required = true;
				}
			}
			else // space found
			{
				if (space_required) {
					space_required = false;
				}
			}
			pos++;
			pwc++;
		}


	}

	if (ids->size() == 0)
		return 0;

	return ids.release();                
}

/////////////////////////////////////////////////////////////////////////////////////////
void CPerformanceCounterManager::CopyAllKeys(TInt_Array& keys)
{
	for ( DWORD i=0; i< m_perfObjects.size(); i++ )
	{
		keys.push_back( m_perfObjects[i].m_ObjectId );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
// return size in bytes, required for the object
int CPerformanceCounterManager::GetSpaceRequired(int objectId) 
{
    ObjectData& data = FindDataForObjectId(objectId);

    int totalSize = 0;
    int numberOfInstances = GetNumberOfInstances(data.m_CategoryNameHashCode, data.m_CategoryName);

    totalSize += sizeof(PERF_OBJECT_TYPE);
    totalSize += data.m_CounterNameHashCodes.size() * sizeof(PERF_COUNTER_DEFINITION);

    if ( numberOfInstances == 0) 
    {
        totalSize += data.m_CounterNameHashCodes.size() * LARGE_INTEGER_SIZE + DWORD_SIZE;
    } 
    else 
    {
        // + 7 is the worst case for the 8-byte alignment of the name. 
        int instanceSize = sizeof(PERF_INSTANCE_DEFINITION) + 2*(MAX_SIZEOF_INSTANCE_NAME + 1)
            + (data.m_CounterNameHashCodes.size() * LARGE_INTEGER_SIZE) + DWORD_SIZE + 7;
        totalSize+= numberOfInstances * instanceSize;
    }

    return totalSize;
}

/////////////////////////////////////////////////////////////////////////////////////////
//	Analog of hash table search in managed code.
ObjectData& CPerformanceCounterManager::FindDataForObjectId(int objId)
{
	// Linear search for appropriate object by Id.
	for (DWORD objidx = 0; objidx < m_perfObjects.size(); objidx++) 
	{
		if ( m_perfObjects[objidx].m_FirstCounterId == objId )
			return m_perfObjects[objidx];
	}
	THROW_ERROR1("ERROR CreateDataForObject() objId: %d  not found.", objId);
}

/////////////////////////////////////////////////////////////////////////////////////////
//	Search "hash" table and return 'true' if ObjectId is contained.
bool CPerformanceCounterManager::IsObjectIdContained(int objId)
{
	// Linear search for appropriate object by Id.
	for (DWORD objidx = 0; objidx < m_perfObjects.size(); objidx++) 
	{
		if ( m_perfObjects[objidx].m_FirstCounterId == objId )
			return true;
	}
	return false;
}

/////////////////////////////////////////////////////////////////////////////////////////
BYTE_PTR CPerformanceCounterManager::CreateDataForObject(int objId, BYTE_PTR ptr)
{
	BYTE_PTR startPtr = ptr;
	int numInstances = PERF_NO_INSTANCES;

	ObjectData& data = FindDataForObjectId(objId);
	// Init the PerfObjectType later, just skip over it for now.
	ptr += sizeof(PERF_OBJECT_TYPE);

	// Start the counter offset at 4 to skip over the counter block size
	int nextCounterOffset = 4;
	for (DWORD i = 0; i < data.m_CounterNameHashCodes.size(); i++) {            
		nextCounterOffset += InitCounterDefinition( ptr, i, data, nextCounterOffset );
		ptr += sizeof(PERF_COUNTER_DEFINITION);
	}

	// now ptr points at the begining of the instances block or counter block (for global counter)
	TWStr_Array instanceNames;
	GetInstanceNames(data.m_CategoryNameHashCode, data.m_CategoryName, instanceNames);

	if (instanceNames.size() == 0) {
		ptr = InitCounterData(ptr, SingleInstanceHashCode, SingleInstanceName, data);
	} 
	else {
		for (DWORD index = 0; index < instanceNames.size(); ++index) {                    
			ptr = InitInstanceDefinition(ptr, 0, 0, PERF_NO_UNIQUE_ID, instanceNames[index]);
			std::wstring instanceName = instanceNames[index]; 
			WStrToLower ( instanceName );
			ptr = InitCounterData(ptr, GetWstrHashCode(instanceName), instanceName, data);
		}
		numInstances = instanceNames.size();
	}

	// update arguments for return
	InitPerfObjectType(startPtr, data, numInstances, ptr - startPtr);    
	return ptr;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CPerformanceCounterManager::InitPerfObjectType(BYTE_PTR ptr, ObjectData& data, int numInstances, int totalByteLength) 
{
	PERF_OBJECT_TYPE perfObjType;

	perfObjType.TotalByteLength = totalByteLength;
	perfObjType.DefinitionLength = sizeof(PERF_OBJECT_TYPE) + data.m_CounterNameHashCodes.size() *
		sizeof(PERF_COUNTER_DEFINITION);
	perfObjType.HeaderLength = sizeof(PERF_OBJECT_TYPE);
	perfObjType.ObjectNameTitleIndex = data.m_FirstCounterId;
	perfObjType.ObjectNameTitle = 0;
	perfObjType.ObjectHelpTitleIndex = data.m_FirstHelpId;
	perfObjType.ObjectHelpTitle = 0;
	perfObjType.DetailLevel = PERF_DETAIL_NOVICE;
	perfObjType.NumCounters = data.m_CounterNameHashCodes.size();
	perfObjType.DefaultCounter = 0;
	perfObjType.NumInstances = numInstances;
	perfObjType.CodePage = 0;                                
	perfObjType.PerfTime = (LARGE_INTEGER)GetCurrentPerfTime();
	perfObjType.PerfFreq = (LARGE_INTEGER)GetFrequency();                              

	memcpy(ptr, &perfObjType, sizeof(perfObjType) );
}


LARGE_INTEGER CPerformanceCounterManager::GetFrequency() 
{
	if (m_PerfFrequency.HighPart == 0 && m_PerfFrequency.LowPart == 0) 
		::QueryPerformanceFrequency(&m_PerfFrequency);
	return m_PerfFrequency;
}


LARGE_INTEGER CPerformanceCounterManager::GetCurrentPerfTime() 
{
	LARGE_INTEGER perfTime;
	::QueryPerformanceCounter(&perfTime);
	return perfTime;
}

////////////////////////////////////////////////////////////////////////
int CPerformanceCounterManager::InitCounterDefinition(BYTE_PTR ptr, int counterIndex, 
													  ObjectData& data, int nextCounterOffset) 
{
	PERF_COUNTER_DEFINITION perfCounter;
	perfCounter.ByteLength = sizeof(PERF_COUNTER_DEFINITION);
	perfCounter.CounterNameTitleIndex = data.m_FirstCounterId + 2 + counterIndex * 2;
	perfCounter.CounterNameTitle = 0;
	perfCounter.CounterHelpTitleIndex = data.m_FirstHelpId + 2 + counterIndex * 2;
	perfCounter.CounterHelpTitle = 0;
	perfCounter.DefaultScale = 0;
	perfCounter.DetailLevel = PERF_DETAIL_NOVICE;

	int counterType = data.m_CounterTypes[counterIndex];
	perfCounter.CounterType = counterType;

	if ( ((counterType & PERF_SIZE_LARGE) != 0) || (counterType == PERF_AVERAGE_TIMER)) 
	{
		perfCounter.CounterSize = LARGE_INTEGER_SIZE;
	}
	else { // Since we only support two counter sizes, if it's not an Int64, must be an Int32.
		perfCounter.CounterSize = DWORD_SIZE;
	}

	perfCounter.CounterOffset = nextCounterOffset;
	int retVal = perfCounter.CounterSize;

	memcpy(ptr, &perfCounter, sizeof(perfCounter) );
	return retVal;
}

////////////////////////////////////////////////////////////////////////
BYTE_PTR CPerformanceCounterManager::InitCounterData(BYTE_PTR ptr, int instanceNameHashCode, 
													 std::wstring instanceName, ObjectData& data) 
{
	PERF_COUNTER_BLOCK counterBlock;
	BYTE_PTR startPtr = ptr;
	ptr += sizeof(PERF_COUNTER_BLOCK);

	for (DWORD index = 0; index < data.m_CounterNameHashCodes.size(); ++index) 
	{
		LARGE_INTEGER counterValue = GetCounterValue(data.m_CategoryNameHashCode, data.m_CategoryName,
			data.m_CounterNameHashCodes[index], data.m_CounterNames[index], 
			instanceNameHashCode, instanceName);
		if ( ((data.m_CounterTypes[index] & PERF_SIZE_LARGE) != 0) || 
			(data.m_CounterTypes[index] == PERF_AVERAGE_TIMER) ) 
		{
			LARGE_COUNTER_DATA counterData;
			counterData.value = counterValue;
			memcpy(ptr, &counterData, sizeof(counterData) );
			ptr += sizeof(LARGE_COUNTER_DATA);                        
		}
		else  // Must be DWORD size
		{
			DWORD_COUNTER_DATA counterData;
			counterData.value = ConvLargeToInt(counterValue);
			memcpy(ptr, &counterData, sizeof(counterData) );
			ptr += sizeof(DWORD_COUNTER_DATA);                        
		}
	}

	// Make sure our data block is 8-byte aligned (unsafe code).
	int diff = (ptr - startPtr) % 8;
	// Null out block (because our data is either 32 or 64 bits, at most we'll need to zero out 4 bytes).
	if (diff != 0) 
	{                
		*((DWORD*)ptr) = 0;
		ptr +=  4;
	}

	counterBlock.ByteLength = ptr - startPtr;            
	memcpy(startPtr, &counterBlock, sizeof(counterBlock) );    
	return ptr;
}      

////////////////////////////////////////////////////////////////////////
BYTE_PTR CPerformanceCounterManager::InitInstanceDefinition(BYTE_PTR ptr, int parentObjectTitleIndex,
															int parentObjectInstance, int uniqueID, std::wstring name) 
{
	PERF_INSTANCE_DEFINITION inst;
	BYTE_PTR startPtr = ptr;
	int nameLengthInBytes = (name.size() + 1) * 2;  //Unicode

	inst.ParentObjectTitleIndex = parentObjectTitleIndex;
	inst.ParentObjectInstance = parentObjectInstance;
	inst.UniqueID = uniqueID;
	inst.NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
	inst.NameLength = nameLengthInBytes;

	// 8 byte alignment (unsafe code)
	int diff = 8 - ((inst.NameOffset + nameLengthInBytes) % 8);
	inst.ByteLength = inst.NameOffset + nameLengthInBytes + diff;

	// Write instance definition to unmanaged memory
	memcpy(startPtr, &inst, sizeof(inst) );

	//
	//	Deal with the instance name.
	//

	// Length is the length of the string, plus null, plus the padding needed
	DWORD length = name.size() + 1 + (diff / 2);

	wchar_t* pwc = (wchar_t*) (ptr + sizeof(PERF_INSTANCE_DEFINITION));
	DWORD idx = 0;
	for (; idx < name.size(); idx++, pwc++ )
		*pwc = name[idx];
	for (; idx < length; idx++,pwc++ )
		*pwc = 0;		// padding with zeroes

	return ptr + inst.ByteLength;
}


////////////////////////////////////////////////////////////////////////
//		I n i t i a l i z e
////////////////////////////////////////////////////////////////////////

#define PERF_SUBKY_NAME			L"\\Performance"
#define SUBKEY_NAME_MAX_SIZE	512		// maximum length of subkey
#define VALUE_BUFSIZE 1024

#define CHECK_KEY_STRING(key,val) keyValueSize = VALUE_BUFSIZE; \
	hr = WszRegQueryValueEx(currentKey, key, NULL, &keyType, (LPBYTE)keyValue, &keyValueSize);\
	if ( hr != ERROR_SUCCESS || keyType	!= REG_SZ || _wcsicmp(keyValue, val) != 0) \
	continue;

#define GET_KEY_DWORD(key,var) keyValueSize = VALUE_BUFSIZE;\
	hr = WszRegQueryValueEx(currentKey, key, NULL, &keyType, (LPBYTE)keyValue, &keyValueSize);\
	if ( hr != ERROR_SUCCESS || keyType	!= REG_DWORD ) continue; \
	var = (keyValue[1]<<16) + keyValue[0];

////////////////////////////////////////////////////////////////////////
// Fill 'perfObjects' list from registry
void CPerformanceCounterManager::Initialize()
{
	if ( !m_FirstEntry ) 
		return;

	if ( m_FileView.m_FileMappingHandle == 0 )
		m_FileView.Initialize();

	HRESULT  hr;
	HKEY parentKey;
	hr = WszRegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services", 0,   
		KEY_READ ,  &parentKey);
	CheckHrAndThrow(L"RegOpenKeyEx (Services)");

	for (int idx = 0; ; idx++)	// enumerate 'Services' keys
	{		

		wchar_t  subKeyName[SUBKEY_NAME_MAX_SIZE+20]; 
		DWORD    subKeyNameSize = SUBKEY_NAME_MAX_SIZE; 
		hr = WszRegEnumKeyEx( parentKey, idx, subKeyName, &subKeyNameSize, 0,0,0,0);
		if ( hr == ERROR_INSUFFICIENT_BUFFER)
			continue;
		if ( hr != ERROR_SUCCESS && hr != ERROR_MORE_DATA)
			break;

		HKEY currentKey = 0;
		try {  

			// Get '\Performance' subkey
			wcsncpy( subKeyName + subKeyNameSize, PERF_SUBKY_NAME, wcslen(PERF_SUBKY_NAME) + 2 );

			hr = WszRegOpenKeyEx( parentKey, subKeyName,0, KEY_READ, &currentKey);
			if ( currentKey == 0)
				continue;

			wchar_t keyValue[VALUE_BUFSIZE+2];
			DWORD	keyValueSize = VALUE_BUFSIZE;
			DWORD	keyType;

			CHECK_KEY_STRING(L"Library", L"netfxperf.dll");				// check shim name
			CHECK_KEY_STRING(L"Collect", L"CollectPerformanceData");	// check entry point
			CHECK_KEY_STRING(L"Open",	 L"OpenPerformanceData");		// check entry point
			CHECK_KEY_STRING(L"Close",	 L"ClosePerformanceData");		// check entry point

			keyValueSize = VALUE_BUFSIZE;
			hr = WszRegQueryValueEx(currentKey, L"Disable Performance Counters", NULL, &keyType, (LPBYTE)keyValue, &keyValueSize);
			if ( hr == ERROR_SUCCESS && keyType == REG_DWORD && (keyValue[0] != 0 || keyValue[1] != 0) ) 
				continue;

			int firstCounterId;
			GET_KEY_DWORD(L"First Counter", firstCounterId);
			int lastCounterId;
			GET_KEY_DWORD(L"Last Counter", lastCounterId);
			int firstHelpId;
			GET_KEY_DWORD(L"First Help", firstHelpId);

			if ( firstCounterId == -1 || firstHelpId == -1 ) 
				continue;

			// Start filling 'ObjectData' structure.
			ObjectData data;
			subKeyName[subKeyNameSize] = 0;							// restore subkey (i.e. object) name string
			data.m_CategoryName = subKeyName;
			WStrToLower( data.m_CategoryName );				
			data.m_CategoryNameHashCode = GetWstrHashCode( data.m_CategoryName );
			data.m_FirstCounterId = firstCounterId; 
			data.m_FirstHelpId = firstHelpId;

			keyValueSize = 0;
			hr = WszRegQueryValueEx(currentKey, L"Counter Types", NULL, &keyType, NULL, &keyValueSize);
			if ( hr == ERROR_SUCCESS && (keyType == REG_MULTI_SZ || keyType == REG_BINARY) )
			{
				wchar_t* valueBuffer = (wchar_t*) LocalAlloc( LMEM_FIXED, keyValueSize); 
				hr = WszRegQueryValueEx(currentKey, L"Counter Types", NULL, &keyType, (LPBYTE)valueBuffer, &keyValueSize);
				if (hr == ERROR_SUCCESS) {
					keyValueSize /= 2;
					GetUniNumbers(valueBuffer, keyValueSize, data.m_CounterTypes); 
				}				
				LocalFree(valueBuffer);  
			}

			keyValueSize = 0;
			hr = WszRegQueryValueEx(currentKey, L"Counter Names", NULL, &keyType, NULL, &keyValueSize);
			if ( hr == ERROR_SUCCESS && (keyType == REG_MULTI_SZ || keyType == REG_BINARY) )
			{
				wchar_t* valueBuffer = (wchar_t*) LocalAlloc( LMEM_FIXED, keyValueSize); 
				hr = WszRegQueryValueEx(currentKey, L"Counter Names", NULL, &keyType, (LPBYTE)valueBuffer, &keyValueSize);
				if (hr == ERROR_SUCCESS) {
					keyValueSize /= 2;
					GetUniStrings(valueBuffer, keyValueSize, data.m_CounterNames); 
					for (DWORD i = 0; i < data.m_CounterNames.size() ; i++) {
						WStrToLower( data.m_CounterNames[i] );				
						data.m_CounterNameHashCodes.push_back( GetWstrHashCode( data.m_CounterNames[i] ) );
					}
				}

				LocalFree(valueBuffer);  
			}

			data.m_ObjectId = data.m_FirstCounterId;	// assume it's an object id			
			m_perfObjects.push_back( data );
		}
		catch(...) {			
		}
		if ( currentKey != 0 )
			RegCloseKey(currentKey);
	}

	if (parentKey != 0)
		RegCloseKey(parentKey);               
	m_FirstEntry = false;      
}


////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\performancecounterprovider.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "stdafx.h"
#include <windows.h>
#include "PerformanceCounterManager.h"
#include "PerformanceCounterProvider.h"
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4786)

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

#define ON_ERROR_EXIT() \
	do { if (hr) { if (1) goto Cleanup; } } while (0)


//////////////////////////////////////////////////////////////////////
#define PAGE_SIZE 0x1000
#define MIN_STACK_SPACE_REQUIRED 0x10000

DWORD   dwOpenCount = 0;        // count of "Open" threads
CPerformanceCounterManager* pManager = 0;

DWORD GetQueryType (IN LPWSTR);
size_t GetRemainingStackSpace();   

//////////////////////////////////////////////////////////////////////
/**
* Open routine
* Does nothing except counting threads that entered it
*/
DWORD PFC_EXPORT APIENTRY 
OpenPerformanceData(LPWSTR lpDeviceNames) 
{
	//
	//  Since WINLOGON is multi-threaded and will call this routine in
	//  order to service remote performance queries, this library
	//  must keep track of how many times it has been opened (i.e.
	//  how many threads have accessed it). the registry routines will
	//  limit access to the initialization routine to only one thread 
	//  at a time so synchronization (i.e. reentrancy) should not be a problem	
	dwOpenCount++;
	if ( pManager == 0 )
		pManager = new CPerformanceCounterManager;

	return ERROR_SUCCESS;
}

/**
* The CollectData function called inside ::RegQueryValueEx() handler.
*/
DWORD PFC_EXPORT APIENTRY 
CollectPerformanceData(
					   IN LPWSTR lpValueName,
					   IN OUT LPVOID *lppData, 
					   IN OUT LPDWORD lpcbTotalBytes, 
					   IN OUT LPDWORD lpNumObjectTypes) 
{	
	DWORD dwQueryType;
	INT_PTR res;

	LPBYTE startPtr = (LPBYTE)*lppData;
	// see if this is a foreign (i.e. non-NT) computer data request 
	// this routine does not service requests for data from Non-NT computers
	dwQueryType = GetQueryType (lpValueName); 
	if (dwQueryType == QUERY_FOREIGN) goto Cleanup;

	pManager->CollectData(0, lpValueName, (INT_PTR)*lppData, *lpcbTotalBytes, & res);

	if (res == -2) { // more data necessary
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;		
		return ERROR_MORE_DATA;
	} else if (res == -1) {
		goto Cleanup;
	}

	*lpcbTotalBytes = PtrToUint((LPBYTE)res - startPtr);
	*lpNumObjectTypes = 1;
	*lppData = (VOID*) res;
	return ERROR_SUCCESS; 

Cleanup:
	*lpcbTotalBytes = (DWORD) 0;
	*lpNumObjectTypes = (DWORD) 0;    
	return ERROR_SUCCESS; //it should be this way
}

/**
* Close routine
* Releases PerfCounterManager if it's not needed anymore.
*/

DWORD PFC_EXPORT APIENTRY 
ClosePerformanceData()
{    
	if (!(--dwOpenCount)) {         
		if ( pManager != 0 ) {
			delete pManager;
			pManager = 0;
		}
	}
	return ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////////////

/* 
Returns the type of query described in the lpValue string so that
the appropriate processing method may be used

Arguments

IN lpValue
string passed to PerfRegQuery Value for processing

Return Value

QUERY_GLOBAL
if lpValue == 0 (null pointer)
lpValue == pointer to Null string
lpValue == pointer to "Global" string

QUERY_FOREIGN
if lpValue == pointer to "Foriegn" string

QUERY_COSTLY
if lpValue == pointer to "Costly" string

otherwise:

QUERY_ITEMS
*/
DWORD GetQueryType (IN LPWSTR lpValue)
{
	static WCHAR GLOBAL_STRING[] = L"Global";
	static WCHAR FOREIGN_STRING[] = L"Foreign";
	static WCHAR COSTLY_STRING[] = L"Costly";

	WCHAR   *pwcArgChar, *pwcTypeChar;
	BOOL    bFound;

	if (lpValue == 0) {
		return QUERY_GLOBAL;
	} 
	else if (*lpValue == 0) {
		return QUERY_GLOBAL;
	}

	// check for "Global" request

	pwcArgChar = lpValue;
	pwcTypeChar = GLOBAL_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;          // bail out now
		}
	}

	if (bFound) return QUERY_GLOBAL;

	// check for "Foreign" request

	pwcArgChar = lpValue;
	pwcTypeChar = FOREIGN_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;          // bail out now
		}
	}

	if (bFound) return QUERY_FOREIGN;

	// check for "Costly" request

	pwcArgChar = lpValue;
	pwcTypeChar = COSTLY_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;          // bail out now
		}
	}

	if (bFound) return QUERY_COSTLY;

	// if not Global and not Foreign and not Costly, 
	// then it must be an item list

	return QUERY_ITEMS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\sharedperformancecounter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "stdafx.h"
#include "fusionsetup.h"
#include "Common.h"
#include "SharedPerformanceCounter.h"
#include "GetConfigString.h"
#include "aclapi.h"
#pragma warning(disable:4786)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSharedPerformanceCounter::CSharedPerformanceCounter() :
SingleInstanceName(L"systemdiagnosticssharedsingleinstance"),
SingleInstanceHashCode( GetWstrHashCode(SingleInstanceName) )
{
}

////////////////////////////////////////////////////////////////////////
CSharedPerformanceCounter::~CSharedPerformanceCounter()
{
    m_FileView.Close();
}

////////////////////////////////////////////////////////////////////////
bool CSharedPerformanceCounter::EnterCriticalSection(int* spinLockPointer) 
{
	return InterlockedCompareExchange((LPLONG)spinLockPointer, 1, 0) == 0 ;                        
}

////////////////////////////////////////////////////////////////////////
void CSharedPerformanceCounter::WaitForCriticalSection(int* spinLockPointer) 
{            
	int spinCount = MaxSpinCount;
	while (*spinLockPointer != 0) {
		::Sleep(1);
		--spinCount;
		if (spinCount == 0)
			throw ERROR_POSSIBLE_DEADLOCK;                    
	}                    
}

////////////////////////////////////////////////////////////////////////
void CSharedPerformanceCounter::ExitCriticalSection(int* spinLockPointer) 
{            
	*spinLockPointer = 0;
}        

////////////////////////////////////////////////////////////////////////
BYTE_PTR CSharedPerformanceCounter::ResolveOffset(int offset) 
{    
	if ( offset > m_FileView.m_FileMappingSize || offset < 0) 
		THROW_ERROR1("Mapping is corrupted. Offset: %0x", offset);
	return m_FileView.m_FileViewAddress + offset;
}

////////////////////////////////////////////////////////////////////////
int  CSharedPerformanceCounter::GetNumberOfInstances(int categoryNameHashCode, std::wstring& categoryName)
{
	CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
	if (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer) ||
		categoryPointer->m_FirstInstanceOffset == 0)
		return 0;

	int count = 0;                 
	InstanceEntry* currentInstancePointer =  (InstanceEntry*)(ResolveOffset(categoryPointer->m_FirstInstanceOffset));
	if (currentInstancePointer->m_InstanceNameHashCode == SingleInstanceHashCode)
		return 0;

	for(;;) {
		if (currentInstancePointer->m_RefCount > 0) 
			++ count;

		if (currentInstancePointer->m_NextInstanceOffset == 0)
			break;
		else                                                                                                                                       
			currentInstancePointer = (InstanceEntry*)( ResolveOffset(currentInstancePointer->m_NextInstanceOffset) );                          
	}                                 

	return count;
}


////////////////////////////////////////////////////////////////////////
void CSharedPerformanceCounter::GetInstanceNames(int categoryNameHashCode, 
												 std::wstring& categoryName, TWStr_Array& instancesNames)
{
	instancesNames.erase(instancesNames.begin(), instancesNames.end() );

	CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
	if (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer) ||
		categoryPointer->m_FirstInstanceOffset == 0)
		return;

	InstanceEntry* currentInstancePointer = (InstanceEntry*)(ResolveOffset(categoryPointer->m_FirstInstanceOffset));
	if (currentInstancePointer->m_InstanceNameHashCode == SingleInstanceHashCode)
		return;

	for(;;){                       
		if (currentInstancePointer->m_RefCount > 0) {                    
			std::wstring instanceName = (wchar_t*)ResolveOffset(currentInstancePointer->m_InstanceNameOffset);
			instancesNames.push_back(instanceName.substr(0, MAX_SIZEOF_INSTANCE_NAME));       
		}

		if (currentInstancePointer->m_NextInstanceOffset == 0)
			break;
		else                                                                                                                                       
			currentInstancePointer = (InstanceEntry*)ResolveOffset(currentInstancePointer->m_NextInstanceOffset);                          
	}                                 
}

////////////////////////////////////////////////////////////////////////
LARGE_INTEGER CSharedPerformanceCounter::GetCounterValue(
	int categoryNameHashCode, std::wstring& categoryName, 
	int counterNameHashCode, std::wstring& counterName, 
	int instanceNameHashCode, std::wstring& instanceName ) 
{                      
	CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
	if ( !FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer)) {		
		return ZeroLargeInteger();
	}

	InstanceEntry* instancePointer = (InstanceEntry*)(ResolveOffset(categoryPointer->m_FirstInstanceOffset));
	if ( !FindInstance(instanceNameHashCode, instanceName, instancePointer, &instancePointer)) {		
		return ZeroLargeInteger();
	}

	CounterEntry* counterPointer = (CounterEntry*)(ResolveOffset(instancePointer->m_FirstCounterOffset));
	if ( !FindCounter(counterNameHashCode, counterName, counterPointer, &counterPointer)) {		
		return ZeroLargeInteger();
	}

	return counterPointer->m_Value;                    
}

////////////////////////////////////////////////////////////////////////
bool CSharedPerformanceCounter::FindCategory(int categoryNameHashCode, std::wstring categoryName,
											 CategoryEntry* firstCategoryPointer, 
											 CategoryEntry** returnCategoryPointerReference)
{
	CategoryEntry* currentCategoryPointer = firstCategoryPointer;
	CategoryEntry* previousCategoryPointer = firstCategoryPointer;
	for(;;) 
	{
		WaitForCriticalSection(&(currentCategoryPointer->m_SpinLock));
		if (currentCategoryPointer->m_CategoryNameHashCode == categoryNameHashCode) 
		{
			std::wstring currentCategoryName = (wchar_t*)(ResolveOffset(currentCategoryPointer->m_CategoryNameOffset));
			if (categoryName == currentCategoryName) { 
				*returnCategoryPointerReference = currentCategoryPointer;                                                                
				return true;   
			}                          
		}   

		previousCategoryPointer = currentCategoryPointer;
		if (currentCategoryPointer->m_NextCategoryOffset != 0) 
			currentCategoryPointer = (CategoryEntry*)(ResolveOffset(currentCategoryPointer->m_NextCategoryOffset));
		else 
		{
			*returnCategoryPointerReference = previousCategoryPointer;
			return false;            
		}                             
	}                        
}  

////////////////////////////////////////////////////////////////////////
bool CSharedPerformanceCounter::FindCounter(int counterNameHashCode, std::wstring counterName, 
											CounterEntry* firstCounterPointer, 
											CounterEntry** returnCounterPointerReference) 
{            
	CounterEntry* currentCounterPointer = firstCounterPointer;
	CounterEntry* previousCounterPointer = firstCounterPointer;
	for(;;) 
	{
		WaitForCriticalSection(&(currentCounterPointer->m_SpinLock));
		if (currentCounterPointer->m_CounterNameHashCode == counterNameHashCode) 
		{                    
			std::wstring currentCounterName = (wchar_t*)(ResolveOffset(currentCounterPointer->m_CounterNameOffset));
			if (counterName == currentCounterName) 
			{ 
				*returnCounterPointerReference = currentCounterPointer;
				return true;   
			}                        
		}   

		previousCounterPointer = currentCounterPointer;
		if (currentCounterPointer->m_NextCounterOffset != 0)
			currentCounterPointer = (CounterEntry*)(ResolveOffset(currentCounterPointer->m_NextCounterOffset));
		else 
		{
			*returnCounterPointerReference = previousCounterPointer;
			return false;            
		}                             
	}                        
}                                                        

////////////////////////////////////////////////////////////////////////
bool CSharedPerformanceCounter::FindInstance(int instanceNameHashCode, std::wstring instanceName, 
											 InstanceEntry* firstInstancePointer, 
											 InstanceEntry** returnInstancePointerReference) 
{             
	InstanceEntry* currentInstancePointer = firstInstancePointer;
	InstanceEntry* previousInstancePointer = firstInstancePointer;
	for(;;) 
	{
		WaitForCriticalSection(&(currentInstancePointer->m_SpinLock));
		if (currentInstancePointer->m_InstanceNameHashCode == instanceNameHashCode) 
		{
			std::wstring currentInstanceName = (wchar_t*)(ResolveOffset(currentInstancePointer->m_InstanceNameOffset));
			if (instanceName == currentInstanceName) 
			{ 
				*returnInstancePointerReference = currentInstancePointer;
				return true;   
			}                        
		}                    

		previousInstancePointer = currentInstancePointer;                         
		if (currentInstancePointer->m_NextInstanceOffset != 0)        
			currentInstancePointer =  (InstanceEntry*)(ResolveOffset(currentInstancePointer->m_NextInstanceOffset));
		else 
		{
			*returnInstancePointerReference = previousInstancePointer;
			return false;            
		}                                                     
	}                        
}                                                        


////////////////////////////////////////////////////////////////////////
//	 U t i l i t y     F u n c t i o n s
////////////////////////////////////////////////////////////////////////

// This .NET hash function is publically documented and may NEVER be changed.
int GetWstrHashCode(const std::wstring& wstr)
{
	UINT32 hash = 5381;
	for(DWORD i=0; i < wstr.size(); i++)
		hash = ((hash << 5) + hash) ^ wstr[i];
	return (int)hash;
}

////////////////////////////////////////////////////////////////////////
void WStrToLower(std::wstring& wstr) 
{
	if ( wstr.size() ==0 )
		return;
	wchar_t* buf = new wchar_t[ wstr.size() + 2];
	DWORD pos = 0;

	while ( pos < wstr.size())
	{
		buf[pos] = towlower( wstr[pos] );		
		pos++;
	}

	buf[pos] = 0;	// force eos
	wstr = buf;
	delete [] buf;
}

////////////////////////////////////////////////////////////////////////
void GetUniNumbers(wchar_t * pwc, DWORD data_len, TInt_Array&   arr_int)
{
	wchar_t *endScanWChar;
	DWORD pos = 0;
	wchar_t * wpstr = pwc;	// ptr to a beginning of string
	while ( pos < data_len) 
	{
		if ( *pwc == 0 ) // eos found
		{
			if ( wpstr != pwc )
			{
				arr_int.push_back( wcstol(wpstr, &endScanWChar, 10) );
				wpstr = pwc  + 1;
			}
		}
		pos++;
		pwc++;
	}

	if ( wpstr != pwc &&  *wpstr != 0)		// handle last element
	{
		*pwc = 0;	// force eos
		arr_int.push_back( wcstol(wpstr, &endScanWChar, 10) );
	}
}

////////////////////////////////////////////////////////////////////////
void GetUniStrings(wchar_t * pwc, DWORD data_len, TWStr_Array&  arr_str) 
{
	DWORD pos = 0;
	wchar_t * wpstr = pwc;	// ptr to a beginning of string
	while ( pos < data_len) 
	{
		if ( *pwc == 0 ) // eos found
		{
			if ( wpstr != pwc )
			{	
				arr_str.push_back( std::wstring(wpstr) );
				wpstr = pwc + 1;
			}
		}
		pos++;
		pwc++;
	}

	if ( wpstr != pwc &&  *wpstr != 0)		// handle last element
	{
		*pwc = 0;	// force eos
		arr_str.push_back( std::wstring(wpstr) );
	}
	//	size_t mbstowcs( wchar_t *wcstr, const char *mbstr, size_t count ) // multibyte to wchar_t*
}

////////////////////////////////////////////////////////////////////////////////
int	ConvLargeToInt(LARGE_INTEGER large)	// unsafe code
{
	int i = (int)(large.LowPart & 0x7fffffff);	// clear sign bit 
	return ( large.HighPart < 0 ) ? -i : i;		// take sign into account
}

////////////////////////////////////////////////////////////////////////////////
//		F i l e M a p p i n g
////////////////////////////////////////////////////////////////////////////////

CSharedPerformanceCounter::FileMapping::FileMapping() {
	m_FileMappingSize = 0;
	m_FileViewAddress = 0;                    
	m_IsGhosted = false;
	m_FileMappingHandle = 0;                    
}                        

void CSharedPerformanceCounter::FileMapping::Close() {
	if (m_FileMappingHandle != 0) 
		::CloseHandle(m_FileMappingHandle);

	if (m_FileViewAddress != 0) 
		::UnmapViewOfFile(m_FileViewAddress);                        

	m_FileViewAddress = 0;        
	m_FileMappingHandle = 0;               
}            

/////////////////////////////////////////////////////////////////////////                      
void CSharedPerformanceCounter::FileMapping::GetMappingSize() {
	m_FileMappingSize = DEFUALT_FILEMAPPING_SIZE;		// defualit value, change later. 
	HRESULT hr;
	WCHAR systemDir[_MAX_PATH+9];
	DWORD dwSize = _MAX_PATH;
	WCHAR configFile[] = MACHINE_CONFIGURATION_FILE;

	hr = GetInternalSystemDirectory(systemDir, &dwSize);
	if(SUCCEEDED(hr)) {
		DWORD configSize = sizeof(configFile) / sizeof(WCHAR) - 1;
		if(configSize + dwSize <= _MAX_PATH) {
			wcscat(systemDir, configFile);

			//  --------------- Config file format is: 
			//    <system.diagnostics>
			//         <performanceCounters filemappingsize="1000000" />
			//    </system.diagnostics>
			//    
#define WCBUF_LEN	250
			wchar_t wcbuf[WCBUF_LEN+2];
			wcbuf[0] = 0;
			hr = GetConfigString(systemDir,
				L"system.diagnostics",
				L"performanceCounters",
				L"filemappingsize",
				wcbuf,
				WCBUF_LEN);        	
			if(SUCCEEDED(hr) && wcbuf[0] != 0) {
				wchar_t *endScanWChar;
				m_FileMappingSize = wcstol(wcbuf, &endScanWChar, 10);
				if (m_FileMappingSize < MIN_FILEMAPPING_SIZE)
					m_FileMappingSize = MIN_FILEMAPPING_SIZE;

				if (m_FileMappingSize > MAX_FILEMAPPING_SIZE)
					m_FileMappingSize = MAX_FILEMAPPING_SIZE; 

			}
		}  
	}
}

///////////////////////////////////////////////////////////////////////
void CSharedPerformanceCounter::FileMapping::Initialize() {

	char* mappingName;
	if (GetMajorNTVersion() >= 5)		// Win2000 or higher 
		mappingName = "Global\\netfxcustomperfcounters.1.0";
	else
		mappingName = "netfxcustomperfcounters.1.0";

	SECURITY_DESCRIPTOR securityDescriptor;
	memset(&securityDescriptor, 0 , sizeof(securityDescriptor) );
	if ( !::InitializeSecurityDescriptor(&securityDescriptor, SECURITY_DESCRIPTOR_REVISION) )
		THROW_ERROR("Can't initialize Security Descriptor");

        PACL pAcl = CreateDacl();
    
	if ( !::SetSecurityDescriptorDacl(&securityDescriptor, TRUE, pAcl, FALSE) ) {
	    LocalFree(pAcl);
		THROW_ERROR("Can't set Security Descriptor Dacl");
	}

	SECURITY_ATTRIBUTES securityAttributes;
	memset(&securityAttributes, 0 , sizeof(securityAttributes) );
	securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	securityAttributes.lpSecurityDescriptor = &securityDescriptor;                               
	securityAttributes.bInheritHandle = FALSE;
	GetMappingSize();

	m_FileMappingHandle = CreateFileMappingA( HANDLE(-1), 
		&securityAttributes, 
		PAGE_READWRITE, 0, 
		m_FileMappingSize, 
		mappingName);

        LocalFree(pAcl);

	int err = ::GetLastError();
	if (m_FileMappingHandle == 0 && (err == ERROR_ALREADY_EXISTS || err == ERROR_ACCESS_DENIED))
	{
		m_FileMappingHandle = ::OpenFileMappingA(FILE_MAP_READ, FALSE, mappingName);  // FILE_MAP_READ, FILE_MAP_ALL_ACCESS
	}

	if (m_FileMappingHandle == 0)
		THROW_ERROR("Can't create MapView. ");

	m_FileViewAddress = (BYTE_PTR)::MapViewOfFile(m_FileMappingHandle, FILE_MAP_READ, 0,0,0); 
	if (m_FileViewAddress == 0) 
	{                   
		// THROW_ERROR("Can't get address of MapView");
		THROW_ERROR1("Can't get address of MapView: error %d ", ::GetLastError());
	}

	::InterlockedCompareExchange((LPLONG)&m_FileViewAddress, 4, 0);
}

/////////////////////////////////////////////////////////////
DWORD	GetMajorNTVersion() 
{

	OSVERSIONINFOW   osvi;
	memset( &osvi,  0, sizeof( osvi ));    
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	WszGetVersionEx( &osvi );

	if ( osvi.dwPlatformId != VER_PLATFORM_WIN32_NT )
		THROW_ERROR("ERROR: Non NT environment.");
	return osvi.dwMajorVersion;
}

/////////////////////////////////////////////////////////////
PACL CreateDacl() 
{
    // create a DACL to only allow reading and writing to the memory
    PSID pEveryoneSID = NULL;
    PACL pACL = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    EXPLICIT_ACCESS ea[1];
    DWORD dwRes;
    
 	if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pEveryoneSID) ) 
        THROW_ERROR1("Can't initialize sid: %d", ::GetLastError());

    memset(ea, 0 , sizeof(EXPLICIT_ACCESS) );	
    ea[0].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

    dwRes = SetEntriesInAcl(1, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes) 
        THROW_ERROR1("Can't create acl: %d", ::GetLastError());

    return pACL;
}

/////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#define _CRTIMP 
#include <winwrap.h>                    // Windows wrappers.
#include <utilcode.h>

#include <ole2.h>						// OLE definitions
#include "oledb.h"						// OLE DB headers.
#include "oledberr.h"					// OLE DB Error messages.
#include "msdadc.h"						// Data type conversion service.

#define _COMPLIB_GUIDS_


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_


#include "Intrinsic.h"					// Functions to make intrinsic.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\sharedperformancecounter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once
#pragma warning(disable:4512)
#pragma warning(disable:4786)

#define MaxSpinCount	10000
#include <stdlib.h>
#include <assert.h>
#include <memory>
#include <string>
#include <vector>
#include <windows.h>
#include <winperf.h>
#include "Common.h"

typedef	char*	BYTE_PTR;

typedef	std::vector<int>			TInt_Array;
typedef	std::vector<std::string>	TStr_Array;
typedef	std::vector<std::wstring>	TWStr_Array;

#define	LARGE_INTEGER_SIZE			8 
#define	DWORD_SIZE					4 
#define	MAX_SIZEOF_INSTANCE_NAME	64
#define DEFUALT_FILEMAPPING_SIZE 524288
#define MAX_FILEMAPPING_SIZE 33554432
#define MIN_FILEMAPPING_SIZE 32768

/////////////////////////////////////////////////////////////
class CSharedPerformanceCounter  
{
private:

	// PRIVATE DATA

	struct CategoryEntry {           
		int m_SpinLock;
		int m_CategoryNameHashCode;            
		int m_CategoryNameOffset;
		int m_FirstInstanceOffset;    
		int m_NextCategoryOffset;            
	};

	struct InstanceEntry {        
		int m_SpinLock;
		int m_InstanceNameHashCode;
		int m_InstanceNameOffset;                                    
		int m_RefCount;            
		int m_FirstCounterOffset;
		int m_NextInstanceOffset;
	};

	struct CounterEntry {            
		int m_SpinLock;
		int m_CounterNameHashCode;
		int m_CounterNameOffset;
		LARGE_INTEGER m_Value;            
		int m_NextCounterOffset;            
	};

protected:
	CSharedPerformanceCounter();
	virtual ~CSharedPerformanceCounter();

public:

	bool EnterCriticalSection(int* spinLockPointer);
	void WaitForCriticalSection(int* spinLockPointer);
	void ExitCriticalSection(int* spinLockPointer);

	int  GetNumberOfInstances(int categoryNameHashCode, std::wstring& CategoryName);
	void GetInstanceNames(int categoryNameHashCode, std::wstring& categoryName, TWStr_Array& list/*out*/); 
	LARGE_INTEGER GetCounterValue(	int categoryNameHashCode, std::wstring& categoryName, 
		int counterNameHashCode, std::wstring& counterName, 
		int instanceNameHashCode, std::wstring& instanceName);                      



	// PUBLIC DATA
	const std::wstring SingleInstanceName;
	const int SingleInstanceHashCode;                

private:

	BYTE_PTR ResolveOffset(int offset); 
	bool FindCategory(int categoryNameHashCode, std::wstring categoryName, 
		CategoryEntry* firstCategoryPointer, CategoryEntry** returnCategoryPointerReference);
	bool FindCounter(int counterNameHashCode, std::wstring counterName, CounterEntry* firstCounterPointer, 
		CounterEntry** returnCounterPointerReference); 
	bool FindInstance(int instanceNameHashCode, std::wstring instanceName, InstanceEntry* firstInstancePointer, 
		InstanceEntry** returnInstancePointerReference); 

protected:
	/////////////////////////////////////////////////////////////
	struct FileMapping {
		int			m_FileMappingSize;
		BYTE_PTR	m_FileViewAddress;                    
		bool		m_IsGhosted;
		HANDLE		m_FileMappingHandle;                    

		static const std::string FileMappingName;

		FileMapping();
		void	Close();
		void	Initialize();
		void 	GetMappingSize();	// read setting from config
	};

	FileMapping		m_FileView;
};


/////////////////////////////////////////////////////////////
//	Global functions and macroes

inline LARGE_INTEGER ZeroLargeInteger()
{
	LARGE_INTEGER lll;
	lll.LowPart = 0;
	lll.HighPart = 0;
	return lll;
}

int  GetWstrHashCode(const std::wstring & wstr);
void GetUniStrings(wchar_t * wcp, DWORD data_len, TWStr_Array&  arr_str);
void GetUniNumbers(wchar_t * wcp, DWORD data_len, TInt_Array&   arr_int);
void WStrToLower(std::wstring & ); 
int	ConvLargeToInt(LARGE_INTEGER large);
DWORD	GetMajorNTVersion();
PACL 	CreateDacl();

void OutputToLog(wchar_t * wcp, WORD eventType = EVENTLOG_ERROR_TYPE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"perfcounter.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft performance counter extension for .NET Runtime\0"
#define VER_ORIGFILENAME_STR    "perfcounter.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfcounter\performancecounterprovider.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the PFMNCCOUNTER_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// PFMNCCOUNTER_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.

//#define PFMNCCOUNTER_API __declspec(dllexport)
//#define PFC_EXPORT       __declspec(dllexport)
#define PFC_EXPORT 

#if 0
DWORD PFC_EXPORT APIENTRY OpenPerformanceData(LPWSTR lpDeviceNames); 
DWORD PFC_EXPORT APIENTRY CollectPerformanceData(
	IN LPWSTR lpValueName,
	IN OUT LPVOID *lppData, 
	IN OUT LPDWORD lpcbTotalBytes, 
	IN OUT LPDWORD lpNumObjectTypes); 
DWORD PFC_EXPORT APIENTRY ClosePerformanceData();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\bytestream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"

#include "ByteStream.h"

//-----------------------------------------------------------------------------
// Initialize our ByteStream with an existing buffer
//-----------------------------------------------------------------------------
ByteStream::ByteStream(LPVOID * ppData, long cBytes)
{
	_ASSERTE(cBytes > 0);

	m_pHead = m_pCurData = (BYTE*) *ppData;
	m_cBytes = cBytes;
}

//-----------------------------------------------------------------------------
// Wrap MemCopy
//-----------------------------------------------------------------------------
void ByteStream::WriteMem(const void * pSrc, long cSize)
{
// check for buffer overflow
	_ASSERTE((m_pCurData + cSize) < (m_pHead + m_cBytes));

// Actually write
	memmove(m_pCurData, pSrc, cSize);
	m_pCurData += cSize;
}
	
//-----------------------------------------------------------------------------
// helper to align buffer
//-----------------------------------------------------------------------------
void ByteStream::WritePad(long cSize)
{
// check for buffer overflow
	_ASSERTE((m_pCurData + cSize) < (m_pHead + m_cBytes));

// Actually write
	memset(m_pCurData, 0, cSize);

#ifdef _DEBUG
	memset(m_pCurData, 0xcccccccc, cSize);
#endif //#ifdef _DEBUG
	
    m_pCurData += cSize;
}

//-----------------------------------------------------------------------------
// Write to  a struct in place. Alternative to copying existing struct in.
//-----------------------------------------------------------------------------
void * ByteStream::WriteStructInPlace(long cSize)
{
	_ASSERTE((m_pCurData + cSize) < (m_pHead + m_cBytes));

	void * pVoid = (void*) m_pCurData;
	m_pCurData += cSize;
	return pVoid;
}

//-----------------------------------------------------------------------------
// Get total amount we've written
//-----------------------------------------------------------------------------
DWORD ByteStream::GetWrittenSize() const
{
	return (m_pCurData - m_pHead);
}

//-----------------------------------------------------------------------------
// Get the current pointer - this could allow you to trash the buffer,
// but we don't care. We're optimizing for simplicty & speed over security
//-----------------------------------------------------------------------------
void * ByteStream::GetCurrentPtr()
{
	return m_pCurData;
}

//-----------------------------------------------------------------------------
// Get the start pointer.
//-----------------------------------------------------------------------------
void * ByteStream::GetHeadPtr()
{
	return m_pHead;
}

//-----------------------------------------------------------------------------
// Get the total size we're allowed to have in the byte stream (set in ctor).
//-----------------------------------------------------------------------------
DWORD ByteStream::GetTotalByteLength() const
{
	return m_cBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\corperfmonsymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\bytestream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ByteStream.h - manage a byte stream
//
//*****************************************************************************

#ifndef _BYTESTREAM_H_
#define _BYTESTREAM_H_

//-----------------------------------------------------------------------------
// Utility class to write to byte streams and manage buffer size
// The primary purpose is to sequentially write void* memory. ByteStream cleans
// up lots of messy typecasts & pointer arithmetic to shift the cur ptr.
// Our focus is still on efficiency, not on security (since this is highly trusted)
//-----------------------------------------------------------------------------
class ByteStream
{
public:
// Initialize ByteStream with head and size
	ByteStream(LPVOID * ppData, long cBytes);

// Write via memcopy
	void WriteMem(const void * pSrc, long cSize); 
	void * WriteStructInPlace(long cSize);
	void WritePad(long cSize);
/*
// Write via mapping to a typesafe struct
	template<class T> T* WriteStructInPlace(T)
	{
		_ASSERTE((m_pCurData + cSize) < (m_pHead + m_cBytes));

		T* pStruct = (T*) m_pStream;
		m_pStream += sizeof(T);
		return pStruct;
	}
	// usage: Cookie * pC =  bs.WriteStructInPlace(Cookie());
*/

	DWORD GetWrittenSize() const;
	void * GetHeadPtr();
	void * GetCurrentPtr();
	DWORD GetTotalByteLength() const;
protected:
	BYTE * m_pHead;		// start of block
	BYTE * m_pCurData;	// pointer to current data
	DWORD m_cBytes;		// Total length of byte stream

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\corappnode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorAppNode.cpp
// 
// Manage instance nodes to track COM+ apps.
//*****************************************************************************



#include "stdafx.h"

// Headers for COM+ Perf Counters

#include "CORPerfMonExt.h"
#include "IPCManagerInterface.h"
#include "CorAppNode.h"

#include "PSAPIUtil.h"

extern PSAPI_dll g_PSAPI;

//void OpenGlobalCounters();
//void CloseGlobalCounters();

//-----------------------------------------------------------------------------
// Clear all to empty
//-----------------------------------------------------------------------------
CorAppInstanceNode::CorAppInstanceNode()
{	
	m_PID			= 0;	
	m_pIPCReader	= NULL;
}

CorAppInstanceNode::~CorAppInstanceNode() // virtual
{
	ClosePrivateIPCBlock(m_pIPCReader, (PerfCounterIPCControlBlock * &) m_pIPCBlock);

}

//-----------------------------------------------------------------------------
// Global node
//-----------------------------------------------------------------------------
CorAppGlobalInstanceNode::CorAppGlobalInstanceNode()
{
	wcscpy(m_Name, L"_Global_");
}

//-----------------------------------------------------------------------------
// Ctor & dtor
//-----------------------------------------------------------------------------
CorAppInstanceList::CorAppInstanceList()
{
	m_pGlobalCtrs = NULL;
	m_hGlobalMapPerf = NULL;
	m_pGlobal = &m_GlobalNode;


	m_GlobalNode.m_pIPCBlock = m_pGlobalCtrs;	
}

CorAppInstanceList::~CorAppInstanceList()
{
	
}

//-----------------------------------------------------------------------------
// Some up all per-process nodes to get a global node
//-----------------------------------------------------------------------------
void CorAppInstanceList::CalcGlobal() // virtual 
{
/*
	PerfCounterIPCControlBlock * pTotal = m_GlobalNode.GetWriteableIPCBlock();

	BaseInstanceNode * pNode = GetHead();
	while (pNode != NULL)
	{
		
		
		
		pNode = GetNext(pNode);
	}
*/
}

//-----------------------------------------------------------------------------
// Enumerate all the processes
//-----------------------------------------------------------------------------
void CorAppInstanceList::Enumerate() // virtual 
{
// Try to open global block
	if (m_pGlobalCtrs == NULL) {
		OpenGlobalCounters();
	}

// Must have gotten Enum functions from PSAPI.dll to get instances
	if (!g_PSAPI.IsLoaded()) return;


	DWORD cbSize = 40;				// initial size of array
	const DWORD cbSizeInc = 20;		// size to increment each loop
	DWORD cbNeeded;					// how much space we needed
	DWORD * pArray = NULL;			// array of PIDS

// Empty our nodes
	Free();

// Get raw list of all processes
	pArray = new DWORD[cbSize];
	if (pArray == NULL) return;

	BOOL fOk = g_PSAPI.EnumProcesses(pArray, cbSize, &cbNeeded);
	while (cbNeeded == cbSize) {
	// Increment array size
		delete [] pArray;
		cbSize += cbSizeInc;
		pArray = new DWORD[cbSize];
		if (pArray == NULL) return;

	// Try again
		BOOL fOk = g_PSAPI.EnumProcesses(pArray, cbSize, &cbNeeded);
	} 

	const long cProcess = cbNeeded / sizeof(DWORD);

// Go through array and get names
	for(int i = 0; i < cProcess; i ++)
	{
		// Can we open a Counter IPC block on the given PID?
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pArray[i]);
		if (hProcess != NULL)
		{
			HMODULE hMod;
			DWORD dwSizeMod = 0;

			if (g_PSAPI.EnumProcessModules(hProcess, &hMod, sizeof(hMod), &dwSizeMod))
			{
			// Try to connect to the IPC Block for this PID
				CorAppInstanceNode * pNode = 
					CorAppInstanceNode::CreateFromPID(pArray[i]);
				
				if (pNode) 
				{
					AddNode(pNode);

					DWORD dwSizeName = g_PSAPI.GetModuleBaseName(
						hProcess, 
						hMod, 
						pNode->GetWriteableName(),
						APP_STRING_LEN);					
				}
			}
			CloseHandle(hProcess);
		}
	
	} // end for


	delete [] pArray;
	
}


//-----------------------------------------------------------------------------
// Try to create  an instance node for the given PID. This requires a shared
// IPC block for that PID exists. Returns NULL on failure, else the new node
// with attachment to the block
//-----------------------------------------------------------------------------
CorAppInstanceNode* CorAppInstanceNode::CreateFromPID(DWORD PID) // static

{
	PerfCounterIPCControlBlock * pBlock = NULL;
	IPCReaderInterface * pIPCReader = NULL;

// try to connect to the block
	if (OpenPrivateIPCBlock(PID, pIPCReader, pBlock)) {
		CorAppInstanceNode * pNode = new CorAppInstanceNode;
		if (pNode == NULL) return NULL;

	// Set members to IPC Block
		pNode->m_pIPCReader	= pIPCReader;
		pNode->m_pIPCBlock	= pBlock;
		pNode->m_PID		= PID;		
		
		return pNode;

	}
	return NULL;
}


//-----------------------------------------------------------------------------
// Close a block and NULL both references
//-----------------------------------------------------------------------------
void ClosePrivateIPCBlock(IPCReaderInterface * & pIPCReader, PerfCounterIPCControlBlock * & pBlock)
{
	pIPCReader->ClosePrivateBlock();
	delete pIPCReader;
	pIPCReader	= NULL;
	pBlock		= NULL;
}

//-----------------------------------------------------------------------------
// Try to open a per process block. return true if success, else false 
// (we don't care why we can't open it)
//-----------------------------------------------------------------------------
bool OpenPrivateIPCBlock(DWORD pid, IPCReaderInterface * & pIPCReader, PerfCounterIPCControlBlock * &pBlock)
{
	bool fRet = true;
// Allocate a new reader
	pIPCReader = new IPCReaderInterface;
	if (pIPCReader == NULL)
	{
		fRet = false;
		goto errExit;
	}

// Try to open the private block
	pIPCReader->OpenPrivateBlockOnPid(pid);

	if (!pIPCReader->IsPrivateBlockOpen())
	{		
		fRet = false;
		goto errExit;
	}

	pBlock = pIPCReader->GetPerfBlock();
	if (pBlock == NULL)
	{
		fRet = false;
		goto errExit;
	}

errExit:
	if (!fRet && pIPCReader) 
	{
		ClosePrivateIPCBlock(pIPCReader, pBlock);
	}

	return fRet;
}

//-----------------------------------------------------------------------------
// Close the global COM+ block
//-----------------------------------------------------------------------------
void CorAppInstanceList::CloseGlobalCounters()
{
// Release holds to shared mem-mapped files
	if (m_pGlobalCtrs != NULL)
	{
		UnmapViewOfFile(m_pGlobalCtrs);
		m_pGlobalCtrs = NULL;
		m_GlobalNode.m_pIPCBlock = m_pGlobalCtrs;
	}
	
	if (m_hGlobalMapPerf != NULL) {
		CloseHandle(m_hGlobalMapPerf);
		m_hGlobalMapPerf = NULL;
	}

}

//-----------------------------------------------------------------------------
// Open global COM+ counter block
//-----------------------------------------------------------------------------
void CorAppInstanceList::OpenGlobalCounters()
{

	void * pArena		= NULL;	
	DWORD dwErr			= 0;

	SetLastError(0);
// Open shared block
    if (RunningOnWinNT5())
    {
        m_hGlobalMapPerf = WszOpenFileMapping(
            FILE_MAP_ALL_ACCESS, 
            FALSE,		// mode
            L"Global\\" SHARED_PERF_IPC_NAME);		// Name of mapping object. 
    }
    else
    {
        m_hGlobalMapPerf = WszOpenFileMapping(
            FILE_MAP_ALL_ACCESS, 
            FALSE,		// mode
            SHARED_PERF_IPC_NAME);		// Name of mapping object. 
    }


	dwErr = GetLastError();
	if (m_hGlobalMapPerf == NULL) 
	{		
		goto errExit;
	}

	SetLastError(0);
// Map shared block into memory
	pArena = MapViewOfFile(m_hGlobalMapPerf,	// Handle to mapping object. 
		FILE_MAP_ALL_ACCESS,					// Read/write permission 
		0,								// Max. object size. 
		0,                              // Size of hFile. 
		0); 

	dwErr = GetLastError();
	
	if (pArena == NULL) 
	{		
		goto errExit;
	}



// Cleanup & return
errExit:

	m_pGlobalCtrs = (PerfCounterIPCControlBlock*) pArena;
	m_GlobalNode.m_pIPCBlock = m_pGlobalCtrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\ctrdefimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CtrDefImpl.cpp : 
// Implement specific counters definitions & byte maps. This is the only file
// You need to change if you're going to add new counters / categories.
// Counters are exported from this file via PerfObjectContainer::PerfObjectArray
// 
//*****************************************************************************

/*****************************************************************************/
// To add a new category:
/*****************************************************************************/

#include "stdafx.h"

// Headers for COM+ Perf Counters


// Headers for PerfMon
//#include "CORPerfMonExt.h"
#include <WinPerf.h>        // Connect to PerfMon
#include "PerfCounterDefs.h"
#include "CORPerfMonSymbols.h"

#include "ByteStream.h"
#include "PerfObjectBase.h"
#include "PerfObjectDerived.h" // For classes derived from PerfObjectBase.
#include "CtrDefImpl.h"
#include "CorAppNode.h"
#include "PerfObjectContainer.h"

// Need ByteStream in case someone overrides virtual PerfBaseObject::CopyInstanceData() 
// to write calculated values

extern CorAppInstanceList           g_CorInstList;


//-----------------------------------------------------------------------------
// Extra Perf_Counter_Definitions for COM+
//-----------------------------------------------------------------------------

// PerfCounters work with ByteStreams, so very important to be aligned properly
#pragma pack(4)
struct TRI_COUNTER_DEFINITION 
{
    PERF_COUNTER_DEFINITION m_Cur;  // Current value
    PERF_COUNTER_DEFINITION m_Total;    // Total value
    PERF_COUNTER_DEFINITION m_Inst; // Instantaneous value
};

// Initialize a TRI_COUNTER_DEFINITION struct.
// Symbol table should postpend with "_CUR", "_TOTAL", and "_INST".
// @todo - Is "rate" the rate of the current or total

// Trio Counter (TRICOUNT) - Handles a Current, Total, and Inst. value
#define TRI_COUNTER(idx, offset, scale, level) { \
    NUM_COUNTER(idx ## _CUR, offset + offsetof(TRICOUNT, Cur), scale, level), \
    NUM_COUNTER(idx ## _TOTAL, offset + offsetof(TRICOUNT, Total), scale, level), \
    RATE_COUNTER(idx ## _INST, offset  + offsetof(TRICOUNT, Total), scale, level), \
}

#pragma pack(4)
struct DUAL_COUNTER_DEFINITION 
{
    PERF_COUNTER_DEFINITION m_Total;    // Total value
    PERF_COUNTER_DEFINITION m_Inst; // Instantaneous value (rate)
};

// Initialize a DUAL_COUNTER_DEFINITION struct.
// Symbol table should postpend with "_TOTAL", and "_INST".

// Dual Counter (DUALCOUNT) - Handles a Total, and Inst value
#define DUAL_COUNTER(idx, offset, scale, level) { \
    NUM_COUNTER(idx ## _TOTAL, offset + offsetof(DUALCOUNT, Total), scale, level), \
    RATE_COUNTER(idx ## _INST, offset  + offsetof(DUALCOUNT, Total), scale, level), \
}


//-----------------------------------------------------------------------------
// constant Definitions for object & counters
//-----------------------------------------------------------------------------
struct COR_CTR_DEF
{
    PERF_OBJECT_TYPE        m_objPerf;
    
// GC Memory
    PERF_COUNTER_DEFINITION m_Gen0Collections;
    PERF_COUNTER_DEFINITION m_Gen1Collections;
    PERF_COUNTER_DEFINITION m_Gen2Collections;

    PERF_COUNTER_DEFINITION m_Gen0PromotedBytes;
    PERF_COUNTER_DEFINITION m_Gen1PromotedBytes;

    PERF_COUNTER_DEFINITION m_Gen0PromotionRate;
    PERF_COUNTER_DEFINITION m_Gen1PromotionRate;

    PERF_COUNTER_DEFINITION m_Gen0PromotedFinalizationBytes;
    PERF_COUNTER_DEFINITION m_Gen1PromotedFinalizationBytes;
    
    PERF_COUNTER_DEFINITION m_Gen0HeapSize;
    PERF_COUNTER_DEFINITION m_Gen1HeapSize;
    PERF_COUNTER_DEFINITION m_Gen2HeapSize;
    PERF_COUNTER_DEFINITION m_LrgObjHeapSize;

    PERF_COUNTER_DEFINITION m_NumSurviveFinalize;
    PERF_COUNTER_DEFINITION m_NumHandles;

    PERF_COUNTER_DEFINITION m_BytesAllocated;

    PERF_COUNTER_DEFINITION m_NumInducedGCs;

    PERF_COUNTER_DEFINITION m_PerTimeInGC;
    PERF_COUNTER_DEFINITION m_PerTimeInGCBase;

    PERF_COUNTER_DEFINITION m_TotalHeapSize;
    PERF_COUNTER_DEFINITION m_TotalCommittedSize;
    PERF_COUNTER_DEFINITION m_TotalReservedSize;

    PERF_COUNTER_DEFINITION m_cPinnedObj;
    PERF_COUNTER_DEFINITION m_cSinkBlocks;

};

// Data block - contains actual data samples
struct COR_CTR_DATA
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
// Counter Sections
    Perf_GC         m_GC;

// All calculated values must go at end
    DWORD           m_cbTotalHeapSize;
};

//-----------------------------------------------------------------------------

//----------------------------------------------------------------------------- 
class PerfObjectMain : public PerfObjectBase
{
public:
    PerfObjectMain(COR_CTR_DEF * pCtrDef) : PerfObjectBase(
        (PERF_OBJECT_TYPE *) pCtrDef,
        sizeof(COR_CTR_DATA),
        offsetof(PerfCounterIPCControlBlock, m_GC),
        sizeof(Perf_GC),
        &g_CorInstList
    )
    {
        
        
    };
    virtual void CopyInstanceData(ByteStream & out, const UnknownIPCBlockLayout * pDataSrc) const;
};



//-----------------------------------------------------------------------------
// Instance of COM+ counter defs definitions
//-----------------------------------------------------------------------------
COR_CTR_DEF CtrDef = {
    OBJECT_TYPE(COR_CTR_DEF, DotNetCLR_Memory_OBJECT),

//.............................................................................
// GC
    MEM_COUNTER(GEN0_COLLECTIONS_COUNTER, offsetof(COR_CTR_DATA, m_GC.cGenCollections[0]), -1, PERF_DETAIL_NOVICE), 
    MEM_COUNTER(GEN1_COLLECTIONS_COUNTER, offsetof(COR_CTR_DATA, m_GC.cGenCollections[1]), -1, PERF_DETAIL_NOVICE),     
    MEM_COUNTER(GEN2_COLLECTIONS_COUNTER, offsetof(COR_CTR_DATA, m_GC.cGenCollections[2]), -1, PERF_DETAIL_NOVICE), 

    MEM_COUNTER(GEN0_BYTES_PROMOTED_COUNTER, offsetof(COR_CTR_DATA, m_GC.cbPromotedMem[0]), -4, PERF_DETAIL_NOVICE),    
    MEM_COUNTER(GEN1_BYTES_PROMOTED_COUNTER, offsetof(COR_CTR_DATA, m_GC.cbPromotedMem[1]), -4, PERF_DETAIL_NOVICE),    
    
    RATE_COUNTER(GEN0_PROMOTION_RATE, offsetof(COR_CTR_DATA, m_GC.cbPromotedMem[0]), -4, PERF_DETAIL_NOVICE),   
    RATE_COUNTER(GEN1_PROMOTION_RATE, offsetof(COR_CTR_DATA, m_GC.cbPromotedMem[1]), -4, PERF_DETAIL_NOVICE),   

    MEM_COUNTER(GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER, offsetof(COR_CTR_DATA, m_GC.cbPromotedFinalizationMem[0]), -4, PERF_DETAIL_NOVICE),   
    MEM_COUNTER(GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER, offsetof(COR_CTR_DATA, m_GC.cbPromotedFinalizationMem[1]), -4, PERF_DETAIL_NOVICE),   

    MEM_COUNTER(GEN0_HEAP_SIZE_COUNTER, offsetof(COR_CTR_DATA, m_GC.cGenHeapSize[0]), -4, PERF_DETAIL_NOVICE),  
    MEM_COUNTER(GEN1_HEAP_SIZE_COUNTER, offsetof(COR_CTR_DATA, m_GC.cGenHeapSize[1]), -4, PERF_DETAIL_NOVICE),  
    MEM_COUNTER(GEN2_HEAP_SIZE_COUNTER, offsetof(COR_CTR_DATA, m_GC.cGenHeapSize[2]), -4, PERF_DETAIL_NOVICE),  

    MEM_COUNTER(LARGE_OBJECT_SIZE_COUNTER, offsetof(COR_CTR_DATA, m_GC.cLrgObjSize), -4, PERF_DETAIL_NOVICE),   
    MEM_COUNTER(SURVIVE_FINALIZE_COUNTER, offsetof(COR_CTR_DATA, m_GC.cSurviveFinalize), -1, PERF_DETAIL_NOVICE),   
    MEM_COUNTER(NUM_HANDLES_COUNTER, offsetof(COR_CTR_DATA, m_GC.cHandles), -1, PERF_DETAIL_NOVICE),    
    RATE_COUNTER(ALLOCATION_RATE_COUNTER, offsetof(COR_CTR_DATA, m_GC.cbAlloc), -6, PERF_DETAIL_NOVICE),
    MEM_COUNTER(INDUCED_GC_COUNTER, offsetof(COR_CTR_DATA, m_GC.cInducedGCs), 0, PERF_DETAIL_NOVICE),   
    
    RAW_FRACTION_COUNTER(PER_TIME_IN_GC_COUNTER, offsetof(COR_CTR_DATA, m_GC.timeInGC), 0, PERF_DETAIL_NOVICE), 
    RAW_BASE_COUNTER(PER_TIME_IN_GC_COUNTER_BASE, offsetof(COR_CTR_DATA, m_GC.timeInGCBase), 0, PERF_DETAIL_NOVICE),    

    MEM_COUNTER(TOTAL_HEAP_SIZE_COUNTER, offsetof(COR_CTR_DATA, m_cbTotalHeapSize), -4, PERF_DETAIL_NOVICE),    
    
    MEM_COUNTER(TOTAL_COMMITTED_MEM_COUNTER, offsetof(COR_CTR_DATA, m_GC.cTotalCommittedBytes), -4, PERF_DETAIL_NOVICE),    
    MEM_COUNTER(TOTAL_RESERVED_MEM_COUNTER, offsetof(COR_CTR_DATA, m_GC.cTotalReservedBytes), -4, PERF_DETAIL_NOVICE),  

    MEM_COUNTER(GC_PINNED_OBJECTS, offsetof(COR_CTR_DATA, m_GC.cPinnedObj), 0, PERF_DETAIL_NOVICE),
    MEM_COUNTER(GC_SINKBLOCKS, offsetof(COR_CTR_DATA, m_GC.cSinkBlocks), -1, PERF_DETAIL_NOVICE),   
        
};


PerfObjectMain PerfObject_GC(&CtrDef);



//-----------------------------------------------------------------------------
// Copy pertinent info out of the IPC block and into the stream
//-----------------------------------------------------------------------------
void PerfObjectMain::CopyInstanceData(
    ByteStream & out, 
    const UnknownIPCBlockLayout * pDataSrc
) const // virtual 
{
    COR_CTR_DATA * pCorData = (COR_CTR_DATA*) out.GetCurrentPtr();

    const PerfCounterIPCControlBlock * pTypedDataSrc = 
        (const PerfCounterIPCControlBlock *) pDataSrc;
// Copy all marshall-able data. This will move the GetCurrentPtr().
    MarshallInstanceData(out, pDataSrc);

// PerfMonDll can calculate some counters from EE data
    if (pDataSrc != NULL) 
    {
        pCorData->m_cbTotalHeapSize = 0;
        for(int iGen =0; iGen < MAX_TRACKED_GENS; iGen ++) 
        {       
            pCorData->m_cbTotalHeapSize  += pTypedDataSrc->m_GC.cGenHeapSize[iGen];
        }
        pCorData->m_cbTotalHeapSize  += pTypedDataSrc->m_GC.cLrgObjSize;

    }

// Skip memory
    out.WriteStructInPlace(sizeof(pCorData->m_cbTotalHeapSize));

}


/*
// Template for new category. Copy this and rename "_NEW" to "_MyCategory"

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_NEW
{
    PERF_OBJECT_TYPE        m_objPerf;

// Copy 1 PERF_COUNTER_DEFINITION for each counter

};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_NEW
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
// Add data here (copy from PerfCounterIPCControlBlock in PerfCounters.h)
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_NEW DefInst_NEW =
{
//  OBJECT_TYPE(CategoryDefinition_NEW, <OBject ID here>),
    
//.............................................................................
// Have *_COUNTER macros for each PERF_COUNTER_DEFINITION
 
};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
PerfObjectBase PerfObject_NEW(
    &DefInst_NEW,   
    sizeof(ByteLayout_NEW), 
    <marshall offset>,
    <marshall len>
    &g_CorInstList // list if we instances per-process
);

#error Don't forget to add PerfObject_NEW to PerfObjectContainer::PerfObjectArray[] below

*/

/*****************************************************************************/
// Category
/*****************************************************************************/


/*****************************************************************************/
// Loading

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_Loading
{
    PERF_OBJECT_TYPE        m_objPerf;

// Loading
    TRI_COUNTER_DEFINITION m_Classes;
    TRI_COUNTER_DEFINITION m_AppDomains;
    TRI_COUNTER_DEFINITION m_Assemblies;
    PERF_COUNTER_DEFINITION m_timeLoading;
    PERF_COUNTER_DEFINITION m_cAsmSearchLen;
    DUAL_COUNTER_DEFINITION m_cLoadFailures;
    PERF_COUNTER_DEFINITION m_cbLoaderHeapSize;
    DUAL_COUNTER_DEFINITION m_AppDomainsUnloaded;
};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_Loading
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
    Perf_Loading m_Loading;
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_Loading DefInst_Loading =
{
    OBJECT_TYPE(CategoryDefinition_Loading, DotNetCLR_Loading_OBJECT),
    
//............................................................................. 
// Loading
    TRI_COUNTER(LOADING_CLASSES, offsetof(ByteLayout_Loading, m_Loading.cClassesLoaded), -1, PERF_DETAIL_NOVICE),
    TRI_COUNTER(LOADING_APPDOMAINS, offsetof(ByteLayout_Loading, m_Loading.cAppDomains), -1, PERF_DETAIL_NOVICE),
    TRI_COUNTER(LOADING_ASSEMBLIES, offsetof(ByteLayout_Loading, m_Loading.cAssemblies), -1, PERF_DETAIL_NOVICE),
    
    TIME_COUNTER(LOADING_TIME, offsetof(ByteLayout_Loading, m_Loading.timeLoading), 0, PERF_DETAIL_NOVICE), // NYI
    NUM_COUNTER(LOADING_ASMSEARCHLEN, offsetof(ByteLayout_Loading, m_Loading.cAsmSearchLen), 0, PERF_DETAIL_NOVICE),
    DUAL_COUNTER(LOADING_LOADFAILURES, offsetof(ByteLayout_Loading, m_Loading.cLoadFailures), 0, PERF_DETAIL_NOVICE),
    NUM_COUNTER(LOADING_HEAPSIZE, offsetof(ByteLayout_Loading, m_Loading.cbLoaderHeapSize), -4, PERF_DETAIL_NOVICE),
    DUAL_COUNTER(LOADING_APPDOMAINS_UNLOADED, offsetof(ByteLayout_Loading, m_Loading.cAppDomainsUnloaded), 0, PERF_DETAIL_NOVICE),
};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
#ifndef PERFMON_LOGGING
PerfObjectBase PerfObject_Loading(
#else
PerfObjectLoading PerfObject_Loading(
#endif //#ifndef PERFMON_LOGGING
    &DefInst_Loading,   
    sizeof(ByteLayout_Loading), 
    offsetof(PerfCounterIPCControlBlock, m_Loading),
    sizeof(Perf_Loading),
    &g_CorInstList // list if we instances per-process
);

/*****************************************************************************/
// Jit

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_Jit
{
    PERF_OBJECT_TYPE        m_objPerf;

// Jitting
    PERF_COUNTER_DEFINITION m_MethodsJitted;
    TRI_COUNTER_DEFINITION  m_JittedIL;
//    DUAL_COUNTER_DEFINITION   m_BytesPitched;  // temporarily taken out because Ejit is not supported Jit.
    PERF_COUNTER_DEFINITION m_JitFailures;
    PERF_COUNTER_DEFINITION m_TimeInJit;
    PERF_COUNTER_DEFINITION m_TimeInJitBase;


};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_Jit
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
    Perf_Jit                m_Jit;
// Add data here (copy from PerfCounterIPCControlBlock in PerfCounters.h)
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_Jit DefInst_Jit =
{
    OBJECT_TYPE(CategoryDefinition_Jit, DotNetCLR_Jit_OBJECT),
    
//.............................................................................
// Jitting
    NUM_COUNTER(TOTAL_METHODS_JITTED, offsetof(ByteLayout_Jit, m_Jit.cMethodsJitted), -4, PERF_DETAIL_NOVICE),  
    TRI_COUNTER(JITTED_IL, offsetof(ByteLayout_Jit, m_Jit.cbILJitted), -4, PERF_DETAIL_NOVICE), 
    NUM_COUNTER(JIT_FAILURES, offsetof(ByteLayout_Jit, m_Jit.cJitFailures), -4, PERF_DETAIL_NOVICE),    
    RAW_FRACTION_COUNTER(TIME_IN_JIT, offsetof(ByteLayout_Jit, m_Jit.timeInJit), 0, PERF_DETAIL_NOVICE),    
    RAW_BASE_COUNTER(TIME_IN_JIT_BASE, offsetof(ByteLayout_Jit, m_Jit.timeInJitBase), 0, PERF_DETAIL_NOVICE),   
 
//  DUAL_COUNTER(BYTES_PITCHED, offsetof(ByteLayout_Jit, m_Jit.cbPitched), -4, PERF_DETAIL_NOVICE), 
};
//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
#ifndef PERFMON_LOGGING
PerfObjectBase PerfObject_Jit(
#else
PerfObjectJit PerfObject_Jit(
#endif // #ifndef PERFMON_LOGGING
    &DefInst_Jit,   
    sizeof(ByteLayout_Jit), 
    offsetof(PerfCounterIPCControlBlock, m_Jit),
    sizeof(Perf_Jit),
    &g_CorInstList // list if we instances per-process
);

/*****************************************************************************/
// Interop

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_Interop
{
    PERF_OBJECT_TYPE        m_objPerf;

// Interop
    PERF_COUNTER_DEFINITION m_NumCCWs;
    PERF_COUNTER_DEFINITION m_NumStubs;
    PERF_COUNTER_DEFINITION m_NumMarshalling;
    PERF_COUNTER_DEFINITION m_TLBImports;
    PERF_COUNTER_DEFINITION m_TLBExports;
};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_Interop
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
    Perf_Interop            m_Interop;
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_Interop DefInst_Interop =
{
    OBJECT_TYPE(CategoryDefinition_Interop, DotNetCLR_Interop_OBJECT),
    
//.............................................................................
// Interop  
    NUM_COUNTER(CURRENT_CCW, offsetof(ByteLayout_Interop, m_Interop.cCCW), 1, PERF_DETAIL_NOVICE),  
    NUM_COUNTER(CURRENT_STUBS, offsetof(ByteLayout_Interop, m_Interop.cStubs), 1, PERF_DETAIL_NOVICE),
    NUM_COUNTER(NUM_MARSHALLING, offsetof(ByteLayout_Interop, m_Interop.cMarshalling), 0, PERF_DETAIL_NOVICE),
    NUM_COUNTER(TOTAL_TLB_IMPORTS, offsetof(ByteLayout_Interop, m_Interop.cTLBImports), -1, PERF_DETAIL_NOVICE),
    NUM_COUNTER(TOTAL_TLB_EXPORTS, offsetof(ByteLayout_Interop, m_Interop.cTLBExports), -1, PERF_DETAIL_NOVICE),

};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
#ifndef PERFMON_LOGGING
PerfObjectBase PerfObject_Interop(
#else
PerfObjectInterop PerfObject_Interop(
#endif // #ifndef PERFMON_LOGGING
    &DefInst_Interop,   
    sizeof(ByteLayout_Interop), 
    offsetof(PerfCounterIPCControlBlock, m_Interop),
    sizeof(Perf_Interop),
    &g_CorInstList // list if we instances per-process
);

/*****************************************************************************/
// Locks

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_LocksAndThreads
{
    PERF_OBJECT_TYPE        m_objPerf;
    
// Locks
    DUAL_COUNTER_DEFINITION m_Contention;
    TRI_COUNTER_DEFINITION  m_QueueLength;
// Threading 
    PERF_COUNTER_DEFINITION m_CurrentThreadsLogical;
    PERF_COUNTER_DEFINITION m_CurrentThreadsPhysical;
    TRI_COUNTER_DEFINITION m_RecognizedThreads;
};

//-----------------------------------------------------------------------------
// Byte layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_LocksAndThreads
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
// Counter Sections 
    Perf_LocksAndThreads        m_LocksAndThreads;

};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_LocksAndThreads DefInst_LocksAndThreads =
{
    OBJECT_TYPE(CategoryDefinition_LocksAndThreads, DotNetCLR_LocksAndThreads_OBJECT),
    
//.............................................................................
// Locks
    DUAL_COUNTER(CONTENTION, offsetof(ByteLayout_LocksAndThreads, m_LocksAndThreads.cContention), -1, PERF_DETAIL_NOVICE),
    TRI_COUNTER(QUEUE_LENGTH, offsetof(ByteLayout_LocksAndThreads, m_LocksAndThreads.cQueueLength), -1, PERF_DETAIL_NOVICE),
    NUM_COUNTER(CURRENT_LOGICAL_THREADS, offsetof(ByteLayout_LocksAndThreads, m_LocksAndThreads.cCurrentThreadsLogical), -1, PERF_DETAIL_NOVICE),
    NUM_COUNTER(CURRENT_PHYSICAL_THREADS, offsetof(ByteLayout_LocksAndThreads, m_LocksAndThreads.cCurrentThreadsPhysical), -1, PERF_DETAIL_NOVICE),
    TRI_COUNTER(RECOGNIZED_THREADS, offsetof(ByteLayout_LocksAndThreads, m_LocksAndThreads.cRecognizedThreads), -1, PERF_DETAIL_NOVICE),
};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
#ifndef PERFMON_LOGGING
PerfObjectBase PerfObject_LocksAndThreads(
#else
PerfObjectLocksAndThreads PerfObject_LocksAndThreads(
#endif // #ifndef PERFMON_LOGGING
    &DefInst_LocksAndThreads,   
    sizeof(ByteLayout_LocksAndThreads), 
    offsetof(PerfCounterIPCControlBlock, m_LocksAndThreads),    
    sizeof(Perf_LocksAndThreads),
    &g_CorInstList
);


/*****************************************************************************/
// Exceptions

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_Excep
{
    PERF_OBJECT_TYPE        m_objPerf;

// Copy 1 PERF_COUNTER_DEFINITION for each counter
    DUAL_COUNTER_DEFINITION m_Thrown;
    PERF_COUNTER_DEFINITION m_FiltersRun;
    PERF_COUNTER_DEFINITION m_FinallysRun;
    PERF_COUNTER_DEFINITION m_ThrowToCatchStackDepth;

};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_Excep
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
// Add data here
    Perf_Excep m_Excep;
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_Excep DefInst_Excep =
{
    OBJECT_TYPE(CategoryDefinition_Excep, DotNetCLR_Excep_OBJECT),
    
//.............................................................................
// Exceptions
    DUAL_COUNTER(EXCEP_THROWN, offsetof(ByteLayout_Excep, m_Excep.cThrown), -1, PERF_DETAIL_NOVICE),    
    RATE_COUNTER(TOTAL_EXCEP_FILTERS_RUN, offsetof(ByteLayout_Excep, m_Excep.cFiltersExecuted), -1, PERF_DETAIL_NOVICE),    
    RATE_COUNTER(TOTAL_EXCEP_FINALLYS_RUN, offsetof(ByteLayout_Excep, m_Excep.cFinallysExecuted), -1, PERF_DETAIL_NOVICE),  
    NUM_COUNTER(EXCEPT_STACK_DEPTH, offsetof(ByteLayout_Excep, m_Excep.cThrowToCatchStackDepth), -1, PERF_DETAIL_NOVICE),   

 
};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
#ifndef PERFMON_LOGGING
PerfObjectBase PerfObject_Excep(
#else
PerfObjectExcep PerfObject_Excep(
#endif // #ifndef PERFMON_LOGGING
    &DefInst_Excep,     
    sizeof(ByteLayout_Excep), 
    offsetof(PerfCounterIPCControlBlock, m_Excep),
    sizeof(Perf_Excep),
    &g_CorInstList // list if we instances per-process
);

// Template for new category. Copy this and rename "_NEW" to "_MyCategory"

/*****************************************************************************/
// Contexts & Remoting
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_Contexts
{
    PERF_OBJECT_TYPE        m_objPerf;

// Copy 1 PERF_COUNTER_DEFINITION for each counter
    // We could have used DUAL_COUNTER_DEFINITION for the RemoteCalls rate and total but
    // the remote calls is  the default counter and hence has to be ahead in order...
    PERF_COUNTER_DEFINITION cRemoteCallsRate;   // Instantaneous value (rate) remote calls/sec
    PERF_COUNTER_DEFINITION cRemoteCallsTotal;  // Total value of remote calls
    PERF_COUNTER_DEFINITION cChannels;      // Number of current channels
    PERF_COUNTER_DEFINITION cProxies;
    PERF_COUNTER_DEFINITION cClasses;       // # of Context-bound classes
    PERF_COUNTER_DEFINITION cObjAlloc;      // # of context bound objects allocated
    PERF_COUNTER_DEFINITION cContexts;


};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_Contexts
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
// Add data here (copy from PerfCounterIPCControlBlock in PerfCounters.h)
    Perf_Contexts   m_Context;
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_Contexts DefInst_Contexts =
{
    OBJECT_TYPE(CategoryDefinition_Contexts, DotNetCLR_Remoting_OBJECT),
    
//.............................................................................
    RATE_COUNTER(CONTEXT_REMOTECALLS_INST, offsetof(ByteLayout_Contexts, m_Context.cRemoteCalls), -1, PERF_DETAIL_NOVICE),
    NUM_COUNTER(CONTEXT_REMOTECALLS_TOTAL, offsetof(ByteLayout_Contexts, m_Context.cRemoteCalls), -1, PERF_DETAIL_NOVICE),
    NUM_COUNTER(CONTEXT_CHANNELS, offsetof(ByteLayout_Contexts, m_Context.cChannels), -1, PERF_DETAIL_NOVICE),  
    NUM_COUNTER(CONTEXT_PROXIES, offsetof(ByteLayout_Contexts, m_Context.cProxies), -1, PERF_DETAIL_NOVICE),    
    NUM_COUNTER(CONTEXT_CLASSES, offsetof(ByteLayout_Contexts, m_Context.cClasses), -1, PERF_DETAIL_NOVICE),    
    RATE_COUNTER(CONTEXT_OBJALLOC, offsetof(ByteLayout_Contexts, m_Context.cObjAlloc), -1, PERF_DETAIL_NOVICE), 
    NUM_COUNTER(CONTEXT_CONTEXTS, offsetof(ByteLayout_Contexts, m_Context.cContexts), -1, PERF_DETAIL_NOVICE),  
 
};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
PerfObjectBase PerfObject_Contexts(
    &DefInst_Contexts,  
    sizeof(ByteLayout_Contexts), 
    offsetof(PerfCounterIPCControlBlock, m_Context),
    sizeof(Perf_Contexts),
    &g_CorInstList // list if we instances per-process
);



/*****************************************************************************/
// Security
/*****************************************************************************/

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
struct CategoryDefinition_Security
{
    PERF_OBJECT_TYPE        m_objPerf;

// Copy 1 PERF_COUNTER_DEFINITION for each counter
    PERF_COUNTER_DEFINITION cTotalRTChecks;                 // Total runtime checks
    PERF_COUNTER_DEFINITION timeAuthorize;                  // % time authenticating
    PERF_COUNTER_DEFINITION cLinkChecks;                    // link time checks
    PERF_COUNTER_DEFINITION timeRTchecks;                   // % time in Runtime checks
    PERF_COUNTER_DEFINITION timeRTchecksBase;               // % time in Runtime checks base counter
    PERF_COUNTER_DEFINITION stackWalkDepth;                 // depth of stack for security checks

};

//-----------------------------------------------------------------------------
// Byte Layout for instance data
//-----------------------------------------------------------------------------
struct ByteLayout_Security
{
    PERF_COUNTER_BLOCK      m_CtrBlk;
    
// Add data here (copy from PerfCounterIPCControlBlock in PerfCounters.h)
    Perf_Security   m_Security;
};

//-----------------------------------------------------------------------------
// Instantiation of Definitions
//-----------------------------------------------------------------------------
CategoryDefinition_Security DefInst_Security =
{
    OBJECT_TYPE(CategoryDefinition_Security, DotNetCLR_Security_OBJECT),
    
//.............................................................................
    NUM_COUNTER(SECURITY_TOTALRTCHECKS, offsetof(ByteLayout_Security, m_Security.cTotalRTChecks), -1, PERF_DETAIL_NOVICE),
    TIME_COUNTER(SECURITY_TIMEAUTHORIZE, offsetof(ByteLayout_Security, m_Security.timeAuthorize), 0, PERF_DETAIL_NOVICE), // NYI
    NUM_COUNTER(SECURITY_LINKCHECKS, offsetof(ByteLayout_Security, m_Security.cLinkChecks), -1, PERF_DETAIL_NOVICE),
    RAW_FRACTION_COUNTER(SECURITY_TIMERTCHECKS, offsetof(ByteLayout_Security, m_Security.timeRTchecks), 0, PERF_DETAIL_NOVICE),
    RAW_BASE_COUNTER(SECURITY_TIMERTCHECKS_BASE, offsetof(ByteLayout_Security, m_Security.timeRTchecksBase), 0, PERF_DETAIL_NOVICE),
    NUM_COUNTER(SECURITY_DEPTHSECURITY, offsetof(ByteLayout_Security, m_Security.stackWalkDepth), -1, PERF_DETAIL_NOVICE)
};

//-----------------------------------------------------------------------------
// Instance of CounterObject
//-----------------------------------------------------------------------------
#ifndef PERFMON_LOGGING
PerfObjectBase PerfObject_Security(
#else
PerfObjectSecurity PerfObject_Security(
#endif // #ifndef PERFMON_LOGGING
    &DefInst_Security,  
    sizeof(ByteLayout_Security), 
    offsetof(PerfCounterIPCControlBlock, m_Security),
    sizeof(Perf_Security),
    &g_CorInstList // list if we instances per-process
);


/*****************************************************************************/
// Container to track all the perf objects. This lets us add new objects
// and not have to touch the enumeration code sprinkled throughout the rest
// of the dll.
//
// Add new counter objects to this array list. (order doesn't matter)
/*****************************************************************************/
PerfObjectBase * PerfObjectContainer::PerfObjectArray[] =  // static
{
    &PerfObject_GC,
    &PerfObject_Interop,
    &PerfObject_Excep,
    &PerfObject_Loading,
    &PerfObject_LocksAndThreads,
    &PerfObject_Jit,
    &PerfObject_Contexts,
    &PerfObject_Security

};

//-----------------------------------------------------------------------------
// Calculate size of array
//-----------------------------------------------------------------------------
const DWORD PerfObjectContainer::Count = sizeof(PerfObjectArray) / sizeof(PerfObjectBase *); // static


#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\instancelist.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// InstanceList.cpp - manage different instance lists for each object
//
//*****************************************************************************

#include "stdafx.h"

#include "InstanceList.h"

//-----------------------------------------------------------------------------
// ctor
//-----------------------------------------------------------------------------
BaseInstanceNode::BaseInstanceNode()
{
	m_Name[0]	= 0;
	m_pIPCBlock = NULL;
	m_pNext		= NULL;
}

//-----------------------------------------------------------------------------
// Destruction 
//-----------------------------------------------------------------------------
BaseInstanceNode::~BaseInstanceNode() // virtual 
{
	m_pNext		= NULL;
// Base class has nothing to do, but derived class may allocate objects.	
}

//-----------------------------------------------------------------------------
// InstanceList calls this to get rid of node.
// * Default impl is to just delete. This is good if the list owns the node.
// * But if list doesn't own node, we can override this to prevent the
// list from calling delete.
//-----------------------------------------------------------------------------
void BaseInstanceNode::DestroyFromList() // virtual 
{
	delete this;
}



//-----------------------------------------------------------------------------
// ctor
//-----------------------------------------------------------------------------
InstanceList::InstanceList()
{
	m_pHead = NULL;
	m_Count = 0;
	m_pGlobal = NULL;
}

//-----------------------------------------------------------------------------
// dtor - avoid memory leaks
//-----------------------------------------------------------------------------
InstanceList::~InstanceList()
{
	Free();
}

//-----------------------------------------------------------------------------
// Add this node to our list
//-----------------------------------------------------------------------------
void InstanceList::AddNode(BaseInstanceNode * pNewNode)
{
	_ASSERTE(pNewNode != NULL);	
	if (pNewNode == NULL) return;

// Node shouldn't already be in a list
	_ASSERTE(pNewNode->m_pNext == NULL);

// link in
	pNewNode->m_pNext = m_pHead;
	m_pHead = pNewNode;

	m_Count ++;
}



//-----------------------------------------------------------------------------
// Free our list (get all nodes, count goes to 0)
//-----------------------------------------------------------------------------
void InstanceList::Free()
{
	BaseInstanceNode* pCur = m_pHead;
	while (pCur != NULL)
	{
		m_pHead = pCur->m_pNext;
		pCur->m_pNext = NULL;
		//delete pCur;
		pCur->DestroyFromList();
		pCur = m_pHead;
		m_Count--;
	}
	_ASSERTE(m_Count == 0);
}

//-----------------------------------------------------------------------------
// Don't have to calculate globals, so provide an empty base class definition
//-----------------------------------------------------------------------------
void InstanceList::CalcGlobal() // virtual 
{


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\corperfmonext.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CORPerfMonExt.h - header for PerfMon Ext Dll for the COM+ perf counters 
//
//*****************************************************************************




#ifndef _CORPERFMONEXT_H_
#define _CORPERFMONEXT_H_

// Always use PerfCounters
#define ENABLE_PERF_COUNTERS

#include <WinPerf.h>		// Connect to PerfMon
#include "PerfCounterDefs.h"	// Connect to COM+

struct PerfCounterIPCControlBlock;
class IPCReaderInterface;

//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------
enum EPerfQueryType
{
	QUERY_GLOBAL    = 1,
	QUERY_ITEMS     = 2,
	QUERY_FOREIGN   = 3,
	QUERY_COSTLY    = 4
};

EPerfQueryType GetQueryType (IN LPWSTR lpValue);

// Check if any of the #s are in the list
BOOL IsAnyNumberInUnicodeList (
    IN DWORD	dwNumberArray[],	// array
	IN DWORD	cCount,				// # Elements in array
    IN LPWSTR	lpwszUnicodeList	// string
);



//-----------------------------------------------------------------------------
// Prototypes for utility functions
//-----------------------------------------------------------------------------

bool OpenPrivateIPCBlock(DWORD PID, IPCReaderInterface * & pIPCReader, PerfCounterIPCControlBlock * &pBlock);
void ClosePrivateIPCBlock(IPCReaderInterface * & pIPCReader, PerfCounterIPCControlBlock * & pBlock);

#ifdef PERFMON_LOGGING
#define PERFMON_LOG(x) do {PerfObjectContainer::PerfMonLog x;} while (0)
#else
#define PERFMON_LOG(x)
#endif //#ifdef PERFMON_LOGGING

#endif // _CORPERFMONEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\corappnode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorAppNode.h
// 
// Manage instance nodes to track COM+ apps.
//*****************************************************************************


#ifndef _CORAPPNODE_H_
#define _CORAPPNODE_H_

#include "InstanceList.h"

struct PerfCounterIPCControlBlock;
class IPCReaderInterface;

class CorAppInstanceList;

//-----------------------------------------------------------------------------
// Node to wrap global memory block
//-----------------------------------------------------------------------------
class CorAppGlobalInstanceNode : public BaseInstanceNode
{
	CorAppGlobalInstanceNode();

	friend class CorAppInstanceList;

	PerfCounterIPCControlBlock * GetWriteableIPCBlock();
};

//-----------------------------------------------------------------------------
// CorAppInstanceNode to connect to COM+ IPC Blocks on COM+ apps.
//-----------------------------------------------------------------------------
class CorAppInstanceNode : public BaseInstanceNode
{
public:
	CorAppInstanceNode();
	virtual ~CorAppInstanceNode();

	const PerfCounterIPCControlBlock *	GetIPCBlock();

	static CorAppInstanceNode* CreateFromPID(DWORD pid);

	wchar_t * GetWriteableName();

protected:
	DWORD							m_PID;
	IPCReaderInterface *			m_pIPCReader;	// Mechanism to connect /read IPC file
	//PerfCounterIPCControlBlock *	m_pIPCBlock;	// point to our specific block
		
};

//-----------------------------------------------------------------------------
// Derive to get Enumeration functionality
//-----------------------------------------------------------------------------
class CorAppInstanceList : public InstanceList
{
public:
	CorAppInstanceList();
	~CorAppInstanceList();

	virtual void Enumerate();
	virtual void CalcGlobal();

	void OpenGlobalCounters();
	void CloseGlobalCounters();

protected:
	CorAppGlobalInstanceNode		m_GlobalNode;

	PerfCounterIPCControlBlock *	m_pGlobalCtrs;
	HANDLE							m_hGlobalMapPerf;
};



//-----------------------------------------------------------------------------
// We can provide type safety on our IPCBlock
//-----------------------------------------------------------------------------
inline const PerfCounterIPCControlBlock *	CorAppInstanceNode::GetIPCBlock()
{
	return (PerfCounterIPCControlBlock *) m_pIPCBlock;
}

//-----------------------------------------------------------------------------
// Get name buffer so we can fill it out.
//-----------------------------------------------------------------------------
inline wchar_t * CorAppInstanceNode::GetWriteableName()
{
	return m_Name;
}

//-----------------------------------------------------------------------------
// Return a writeable version of our IPC block. Only the CorAppInstanceList
// Can call us. Used to do summation
//-----------------------------------------------------------------------------
inline PerfCounterIPCControlBlock * CorAppGlobalInstanceNode::GetWriteableIPCBlock()
{
	return (PerfCounterIPCControlBlock *) m_pIPCBlock;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\instancelist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// InstanceList.h - manage different instance lists & base nodes for each object
//
//*****************************************************************************


#ifndef _INSTANCELIST_H_
#define _INSTANCELIST_H_


//-----------------------------------------------------------------------------
// Individual Node for an instance. Will release its handles
//-----------------------------------------------------------------------------
class InstanceList;
const int APP_STRING_LEN = 16;	// size of an app inst string name

//-----------------------------------------------------------------------------
// Base Node. Derived classes must allocate (via static Create() func), attach
// to an IPCBlock, and provide an instance name.
// 
// PerfObjectBase just gets a node*. Auto-Marshalling is blind and will take
// the void*; but if we do custom marshalling, we can always use
// dynamic_cast<> to get a derived node class and then get a type-safe IPCBlock
//-----------------------------------------------------------------------------
class BaseInstanceNode
{
protected:
	BaseInstanceNode();		
public:

// Destruction 
	virtual ~BaseInstanceNode();
	virtual void DestroyFromList();

// Get Data
	const wchar_t * GetName() const;
	void * GetDataBlock() const;

protected:
	//void AddThisNodeToList(InstanceList* pList);
	
	wchar_t					m_Name[APP_STRING_LEN];
	void *					m_pIPCBlock;

private:
// Derived classes don't need to bother maintaining linked list node
	BaseInstanceNode *		m_pNext;

	friend InstanceList;
};

//-----------------------------------------------------------------------------
// Utility to manage a list of instances. Implement with a simple linked list
// because we don't know the size in advance
//-----------------------------------------------------------------------------
class InstanceList
{
public:
	InstanceList();
	~InstanceList();

	void Free();

	BaseInstanceNode * GetHead() const;
	BaseInstanceNode * GetNext(BaseInstanceNode *) const;

	long GetCount() const;

// We're responsible for creating own own list. This is the only place
// that can add nodes to our list.
	virtual void Enumerate() = 0;

// Calculate global data - must know node layout to do this, so make virtual
	virtual void CalcGlobal();

// Get the global node. May return NULL if we don't have one. 
	BaseInstanceNode * GetGlobalNode();

protected:
	void AddNode(BaseInstanceNode * pNewNode);

	BaseInstanceNode *	m_pGlobal;	// node for global data

private:
	BaseInstanceNode*	m_pHead;	// array of instance nodes
	long				m_Count;	// count of elements in array

	friend BaseInstanceNode;
};
/*
//-----------------------------------------------------------------------------
// When derived node is created, it can add itself to the list.
//-----------------------------------------------------------------------------
inline void BaseInstanceNode::AddThisNodeToList(InstanceList * pList)
{
	pList->AddNode(this);
}
*/
//-----------------------------------------------------------------------------
// Return the name of this instance
//-----------------------------------------------------------------------------
inline const wchar_t * BaseInstanceNode::GetName() const
{
	return m_Name;
}

//-----------------------------------------------------------------------------
// Return a pointer to the IPC block.
// Note a derived class could provide type safety
//-----------------------------------------------------------------------------
inline void * BaseInstanceNode::GetDataBlock() const
{
	return m_pIPCBlock;
}


//-----------------------------------------------------------------------------
// Enumeration functions. 
//-----------------------------------------------------------------------------
inline BaseInstanceNode * InstanceList::GetHead() const
{
	return m_pHead;
}

inline BaseInstanceNode * InstanceList::GetNext(BaseInstanceNode * pCurNode) const
{
	if (pCurNode == NULL) return NULL;
	return pCurNode->m_pNext;
}

//-----------------------------------------------------------------------------
// Get the count of nodes in the list
//-----------------------------------------------------------------------------
inline long InstanceList::GetCount() const
{
	return m_Count;
}

//-----------------------------------------------------------------------------
// Get the global node
//-----------------------------------------------------------------------------
inline BaseInstanceNode * InstanceList::GetGlobalNode()
{
	return m_pGlobal;
}

#endif // _INSTANCELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\ctrdefimpl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CtrDefImpl.h - provides macros to help define counters & objects. Putting
// them here keeps CtrDefImpl.cpp less cluttered.
//
//*****************************************************************************

#ifndef _CTRDEFIMPL_H_
#define _CTRDEFIMPL_H_

#include <WinPerf.h>		// Connect to PerfMon

//-----------------------------------------------------------------------------
// Use nested structures to pack PERF structs and our custom counters together
// in the right format. This will let us replace yucky pointer arithmetic
// with clean & robust struct accessors. 

// See "$\com99\DevDoc\PerfMonDllSpec.doc" to add new counters or categories.

// Have Helper macros to initialize the PERF_COUNTER_DEFINITIONs. Why?
// 1. parameter reduction: auto fill out sizeof, NULLs, etc
// 2. safety - combine parameters properly for a counter type
// 3. compatible - we can still fill things out ourselves
// Note, it would be cleaner to do this with a ctor, but VC
// doesn't want to compile ctors in initialization lists. 

// Design of perf counter forces us to use the following conditional defines. 
// Performance counters need explicite layout info and also use of predefined
// enums like PERF_COUNTER_RAWCOUNT which have predefined sizes. 

#ifdef __IA64

#define CUSTOM_PERF_COUNTER_FOR_MEM PERF_COUNTER_LARGE_RAWCOUNT
#define CUSTOM_PERF_COUNTER_FOR_RATE PERF_COUNTER_BULK_COUNTER

#else // win32 stuff

#define CUSTOM_PERF_COUNTER_FOR_MEM PERF_COUNTER_RAWCOUNT
#define CUSTOM_PERF_COUNTER_FOR_RATE PERF_COUNTER_COUNTER

#endif // #ifdef __IA64

// Define the PERF_OBJECT_TYPE for a given definition structure
// defstruct - The new CategoryDefinition strucutre
// idx - index for symbol table in symbols.h
#define OBJECT_TYPE(defstruct, idx) {	\
	0,									\
    sizeof (defstruct),					\
    sizeof (PERF_OBJECT_TYPE),			\
    idx,								\
    NULL,								\
    idx,								\
    NULL,								\
    PERF_DETAIL_NOVICE,					\
    NUM_COUNTERS(defstruct),			\
    0,									\
    1,									\
    0									\
}


// Raw Counter (DWORD) - for raw numbers like Total Classes Loaded.
#define NUM_COUNTER(idx, offset, scale, level) { \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(PERF_COUNTER_RAWCOUNT),                 \
		(sizeof(DWORD)),                         \
		(offset)                                 \
}

// Mem Counter (size_t) - for memory sizes that may change on different machines
#define MEM_COUNTER(idx, offset, scale, level) { \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(CUSTOM_PERF_COUNTER_FOR_MEM),           \
		(sizeof(size_t)),                        \
		(offset)                                 \
}

// Rate Counter (int64) - for rates like Allocated Bytes / Sec
#define RATE_COUNTER(idx, offset, scale, level){ \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(CUSTOM_PERF_COUNTER_FOR_RATE),          \
		(sizeof(size_t)),                        \
		(offset)                                 \
}

// Time Counter (LONGLONG) - for int64 times like, %Time in GC
#define TIME_COUNTER(idx, offset, scale, level){ \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(PERF_COUNTER_TIMER),				     \
		(sizeof(LONGLONG)),                      \
		(offset)                                 \
}

// Bulk Counter (LONGLONG) - to count byte transmission rates.
#define BULK_COUNTER(idx, offset, scale, level){ \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(PERF_COUNTER_BULK_COUNT),				     \
		(sizeof(LONGLONG)),                      \
		(offset)                                 \
}

// Alternate Timer Counter (DWORD) - to count busy time, either 1 or 0 at the sample time
#define RAW_FRACTION_COUNTER(idx, offset, scale, level){ \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(PERF_RAW_FRACTION),				     \
		(sizeof(DWORD)),                         \
		(offset)                                 \
}

// base for Timer counter above
#define RAW_BASE_COUNTER(idx, offset, scale, level){ \
		(sizeof(PERF_COUNTER_DEFINITION)),       \
		(idx),                                   \
		(NULL),                                  \
		(idx),                                   \
		(NULL),                                  \
		(scale),                                 \
		(level),                                 \
		(PERF_RAW_BASE),  				     \
		(sizeof(DWORD)),                         \
		(offset)                                 \
}


// Calculate # of counters in definition structure s
#define NUM_COUNTERS(s) ((sizeof (s) - sizeof(PERF_OBJECT_TYPE)) / sizeof (PERF_COUNTER_DEFINITION))

#endif // _CTRDEFIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\corperfmonext.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CORPerfMonExt.cpp : 
// Main file of PerfMon Ext Dll which glues PerfMon & COM+ EE stats.
// Inludes all Dll entry points.//
//*****************************************************************************

#include "stdafx.h"



// Headers for PerfMon
#include "CORPerfMonExt.h"
//#include "CORPerfMonSymbols.h"

#include "IPCFuncCall.h"

#include "ByteStream.h"
#include "PerfObjectBase.h"
#include "PSAPIUtil.h"
#include "InstanceList.h"
#include "CorAppNode.h"
#include "PerfObjectContainer.h"
#include "..\..\dlls\mscorrc\resource.h"

// Location in Registry that client app's (COM+) perf data is stored
#define CLIENT_APPNAME L".NETFramework"
#define REGKEY_APP_PERF_DATA L"system\\CurrentControlSet\\Services\\" CLIENT_APPNAME L"\\Performance"

#define REGVALUE_FIRST_COUNTER	L"First Counter"
#define REGVALUE_FIRST_HELP		L"First Help"


// Command lines to install / uninstall our registry settings
#define LODCTR_CMDLINE		L"lodctr CORPerfMonSymbols.ini"
#define UNLODCTR_CMDLINE	L"unlodctr" CLIENT_APPNAME
#define INIREG_CMDLINE		L"CORPerfMon.reg"

#define IS_ALIGNED_8(cbSize) (((cbSize) & 0x00000007) == 0)
#define GET_ALIGNED_8(cbSize) (((cbSize) & 0x00000007) ? (cbSize + 8 - ((cbSize) & 0x00000007)) : cbSize)

void EnumCOMPlusProcess();
//-----------------------------------------------------------------------------
// Global data
//-----------------------------------------------------------------------------


CorAppInstanceList			g_CorInstList;

IPCFuncCallHandler				g_func;

// Connection to Dynamic Loading of PSAPI.dll
PSAPI_dll g_PSAPI;
 
// Critical section to protect re-enumerating while we're using the list
CRITICAL_SECTION g_csEnum;

// Global variable to track the number of times OpenCtrs has been called. 
DWORD g_dwNumOpenCtrsCalled = 0;

//-----------------------------------------------------------------------------
// Entry point
//-----------------------------------------------------------------------------
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{	
	OnUnicodeSystem();
// Only run this on WinNT
	if (!RunningOnWinNT())
	{
		CorMessageBox(NULL, IDS_PERFORMANCEMON_WINNT_ERR, IDS_PERFORMANCEMON_WINNT_TITLE, MB_OK | MB_ICONEXCLAMATION, TRUE);
		return FALSE;
	}

    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			OnUnicodeSystem();
			break;
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


//-----------------------------------------------------------------------------
// UnLoad Library
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Helper function to run LodCtr
//-----------------------------------------------------------------------------
int RunLodCtr()
{
	return _wsystem(LODCTR_CMDLINE);
}

//-----------------------------------------------------------------------------
// Helper function to run UnLodCtr
//-----------------------------------------------------------------------------
int RunUnLodCtr()
{
	return _wsystem(UNLODCTR_CMDLINE);
}

//-----------------------------------------------------------------------------
// Register data under [HKLM\SYSTEM\CurrentControlSet\Services\COMPlus\Performance]
//-----------------------------------------------------------------------------
int RegisterServiceSettings()
{
	return _wsystem(INIREG_CMDLINE);
}

STDAPI DllRegisterServer(void)
{
	RunUnLodCtr();
	
	RunLodCtr();
	RegisterServiceSettings();

	return S_OK;
}

STDAPI DllUnRegisterServer(void)
{
	RunUnLodCtr();

	return S_OK;
}




void AuxThreadCallBack()
{
	LOCKCOUNTINCL("AuxThreadCallBack in corpermonext");								\
	EnterCriticalSection(&g_csEnum);
	EnumCOMPlusProcess();
	LeaveCriticalSection(&g_csEnum);
	LOCKCOUNTDECL("AuxThreadCallBack in corpermonext");								\

}


//-----------------------------------------------------------------------------
// Exported API call: Open counters
//-----------------------------------------------------------------------------
extern "C" DWORD APIENTRY OpenCtrs(LPWSTR sz)
{
	long status				= ERROR_SUCCESS;	// error control code
	HKEY hKeyPerf			= NULL;				// reg key 
	DWORD size				= 0;				// size of value from reg
	DWORD type				= 0;				// type of data from registry

	DWORD dwFirstCounter	= 0;				// idx of our first counter
	DWORD dwFirstHelp		= 0;				// idx of our first help

    // If Open is bineg called the first time do real initialization
    if (g_dwNumOpenCtrsCalled == 0)
    {
        // Create the CS
    	InitializeCriticalSection(&g_csEnum);
    
        // Check for PSAPI
    	g_PSAPI.Load();
    
    
        // Open shared memory handle
    	g_CorInstList.OpenGlobalCounters();
    
        // Grab these values from the registry
    	
    	status = WszRegOpenKeyEx(
    		HKEY_LOCAL_MACHINE, 
    		REGKEY_APP_PERF_DATA,
    		0L, KEY_READ, &hKeyPerf);
    
    	if (status != ERROR_SUCCESS) goto errExit;
    
    	size = sizeof(DWORD);
    	status = WszRegQueryValueEx(
    		hKeyPerf, REGVALUE_FIRST_COUNTER,
    		0l, &type, 
    		(BYTE*) &dwFirstCounter,&size);
    
    	if (status != ERROR_SUCCESS) goto errExit;
    
    
    	size = sizeof(DWORD);
    	status = WszRegQueryValueEx(
    		hKeyPerf, REGVALUE_FIRST_HELP,
    		0l, &type, 
    		(BYTE*) &dwFirstHelp,&size);
    
    	if (status != ERROR_SUCCESS) goto errExit;
    
        // Convert offsets from relative to absolutes
    	{
    		for(DWORD i = 0; i < PerfObjectContainer::Count; i++)
    		{
    			PerfObjectContainer::GetPerfObject(i).TouchUpOffsets(dwFirstCounter, dwFirstHelp);
    		}
    	}
    	//PerfObject_Main.TouchUpOffsets(dwFirstCounter, dwFirstHelp);
    	//PerfObject_Locks.TouchUpOffsets(dwFirstCounter, dwFirstHelp);
        // ...
    
        // Create FuncCallHandler to re-enumerate when COM+ EE starts or terminates.		
    	g_func.InitFCHandler(AuxThreadCallBack);
    
        // attempt to assert existing debug privileges so OpenProcess 
        // in enum will succeed.  We don't care about return values:
        // if we can't do it since we don't have the privilege, ignore.
        HANDLE hToken = 0;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
                TOKEN_PRIVILEGES    newPrivs;
                if (LookupPrivilegeValueW(NULL, L"SeDebugPrivilege", &newPrivs.Privileges[0].Luid))
                {
                    newPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                    newPrivs.PrivilegeCount = 1;
                    AdjustTokenPrivileges(hToken, FALSE, &newPrivs, 0, NULL, NULL);
                }
                CloseHandle(hToken);
        }

        // Make sure that we enum the processes at least once
        EnumCOMPlusProcess();
    
#ifdef PERFMON_LOGGING
        // Open the debug log.
        PerfObjectContainer::PerfMonDebugLogInit("PerfMon.log");
#endif //#ifdef PERFMON_LOGGING
    }
    
    // The call to OpenCtrs is synchronized by the registry so we don't have to synchronize this
    _ASSERTE (status == ERROR_SUCCESS);
    g_dwNumOpenCtrsCalled++;

errExit:
	if (hKeyPerf != NULL) 
	{
		RegCloseKey(hKeyPerf);
		hKeyPerf = NULL;
	}

	return status;
}

#if defined(_DEBUG)
//-----------------------------------------------------------------------------
// Debug only function: If there's a single error in the bytestream, the 
// counters will simply not show up in PerfMon's add dialog, and probably
// not get updated in the chart. Unfortunately, PerfMon gives no hint
// as to where the error lies. 
//
// Hence we have a verifier on our end. We go through and check the integrity
// ourselves. If any of the ASSERTs fire here, we then can see why and 
// more quickly narrow down the problem.
// 
// This is really only an issue when you add new counters / categories.
//-----------------------------------------------------------------------------
void VerifyOutputStream(
	const BYTE* pHead,
	ObjReqVector vctRequest,
	DWORD cObjects,
	DWORD cbWrittenSize
)
{
	const PERF_OBJECT_TYPE * pObj = (PERF_OBJECT_TYPE *) pHead;
	DWORD iObjIdx = 0;

// Loop through each object that we said we had
// Note: 
// 1. we have to do a lot of pointer arithmetic to traverse this. To be
// consistent, we'll case a pointer to a const BYTE *, add a byte value
// and then cast it to the target type
// 2. Since we're  only reading to verify, all pointers are const.
	for(DWORD iObject = 0; iObject < cObjects; iObject++) 
	{
	// Get which of our PerfMon objects is in here.  This will provide us with
	// extra numbers to assert against. If IsBitSet() asserts, then we went
	// outputted more objects than we specified in the request vector. This
	// should never happen.
		while (!vctRequest.IsBitSet(iObjIdx)) {
			iObjIdx++;
		};		
		const PerfObjectBase * pObjBase = &PerfObjectContainer::GetPerfObject(iObjIdx);
		iObjIdx++;
		

	// Check header size is correct
		_ASSERTE(pObj->HeaderLength == sizeof (PERF_OBJECT_TYPE));

	// Make sure definition size is correct
		const DWORD cbExpectedLen = 
			sizeof(PERF_OBJECT_TYPE) + 
			(pObj->NumCounters * sizeof(PERF_COUNTER_DEFINITION));
		_ASSERTE(pObj->DefinitionLength == cbExpectedLen);

	
	// Go through each counter and check:
		const PERF_COUNTER_DEFINITION	* pCtrDef = (PERF_COUNTER_DEFINITION*) 
			(((BYTE*) pObj) + sizeof(PERF_OBJECT_TYPE));

		DWORD iCounter;
		DWORD cbExpectedInstance = 0;
		for(iCounter = 0; iCounter < pObj->NumCounters; iCounter ++, pCtrDef ++) 
		{
		// Check size for corruption. (check for errors in the instantiation vs 
		// definitions of objects)
			_ASSERTE(pCtrDef->ByteLength == sizeof(PERF_COUNTER_DEFINITION));
            _ASSERTE(IS_ALIGNED_8 (pCtrDef->ByteLength));
			
		// Each counter definition has an offset for where to find its data.
		// The offset is a count of bytes from the beginning of the PERF_COUNTER_BLOCK
		// to the raw data. It's the same for all instances.
		// Check that offset is within the data block.
			const DWORD offset = pCtrDef->CounterOffset;
			_ASSERTE(offset >= sizeof(PERF_COUNTER_BLOCK));
			_ASSERTE(offset + pCtrDef->CounterSize <= pObjBase->GetInstanceDataByteLength());

		// Each counter definition says how large it expects it data to be. Sum these
		// up and compare with the actual data size in the next section
			cbExpectedInstance += pCtrDef->CounterSize;
		}

	// Check that the amount of data being used by the counters is at least the
	// size of the counter data. (Allowed to be greater since multiple counters can use
	// the same instance data and so we double count) If this check fails:
	// 1. we probably set the point to the instance data wrong	
	// 2. we may have removed some counters and not removed their spot in the byte layout
		_ASSERTE(cbExpectedInstance >= pObjBase->GetInstanceDataByteLength() - sizeof(PERF_COUNTER_BLOCK));


	// Go through each instance and check
		const PERF_INSTANCE_DEFINITION * pInst = 
			(const PERF_INSTANCE_DEFINITION *) ((const BYTE*) pObj + pObj->DefinitionLength);
		
		for(long iInstance = 0; iInstance < pObj->NumInstances; iInstance++)
		{
		// Each instance is a PERF_INSTANCE_DEFINITION, followed by a unicode string name
		// followed by a PERF_COUNTER_BLOCK and then the raw dump of the counter data. 
		// Note the name is a variale size.

		// check sizes for corruption
			_ASSERTE(pInst->NameOffset == sizeof(PERF_INSTANCE_DEFINITION));
			
            _ASSERTE(IS_ALIGNED_8 (pInst->ByteLength));
            _ASSERTE(pInst->ByteLength == GET_ALIGNED_8(pInst->NameLength + pInst->NameOffset));

			const PERF_COUNTER_BLOCK * pCtrBlk = 
				(const PERF_COUNTER_BLOCK *) ((const BYTE *) pInst + pInst->ByteLength);

            _ASSERTE(IS_ALIGNED_8 (pCtrBlk->ByteLength));
            _ASSERTE(pCtrBlk->ByteLength == GET_ALIGNED_8(pObjBase->GetInstanceDataByteLength()));
		
		// Move to next instance.  
			pInst = (const PERF_INSTANCE_DEFINITION *) ((const BYTE *) pInst + pCtrBlk->ByteLength + pInst->ByteLength);
		}
	// At end of this object's data. Check size delta as expected
		const DWORD cbTotal = (const BYTE *) pInst - (const BYTE *) pObj;
		_ASSERTE(cbTotal == pObj->TotalByteLength);
        _ASSERTE(IS_ALIGNED_8 (pObj->TotalByteLength));

	// Go to next object
		pObj = (const PERF_OBJECT_TYPE *) ((const BYTE *) pObj + pObj->TotalByteLength);

	} // end object
	
// Check total size
	const DWORD cbTotal = (const BYTE *) pObj - (const BYTE *) pHead;
	_ASSERTE(cbTotal == cbWrittenSize);

} // VerifyOutputStream
#endif

//-----------------------------------------------------------------------------
// Workhorse for collect call. This part encapsulated in a critical section
//-----------------------------------------------------------------------------
/*
DWORD CollectWorker(ByteStream & stream, EPerfQueryType eQuery)
{

}
*/
//-----------------------------------------------------------------------------
// Exported API call: Collect data on counters
//-----------------------------------------------------------------------------
extern "C" DWORD APIENTRY CollectCtrs(LPWSTR szQuery, LPVOID * ppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes)
{
    // We expect the call to Open before any calls to Collect.
    _ASSERTE (g_dwNumOpenCtrsCalled > 0);

	const DWORD dwBufferSize = *lpcbBytes;
// Zero out buffers
	*lpcbBytes = 0;
	*lpcObjectTypes = 0;

	ByteStream stream(ppData, dwBufferSize);

// Check query types.
	EPerfQueryType eQuery = GetQueryType(szQuery);
	ObjReqVector vctRequest;

// Need cs here in case aux thread starts enumeration
	LOCKCOUNTINCL("CollectCtrs in corpermonext");								\
	EnterCriticalSection(&g_csEnum);

//.............................................................................
	switch (eQuery)
	{
// Don't service foriegn computers		
	case QUERY_FOREIGN:
		LeaveCriticalSection(&g_csEnum);
		LOCKCOUNTDECL("collectctrs in corpermonext");								\

		return ERROR_SUCCESS;		
		break;

// Global means update our lists and send everything. 
	case QUERY_GLOBAL:
		EnumCOMPlusProcess();
		vctRequest.SetAllHigh();	
		break;

// Get exact objects we're looking for
	case QUERY_ITEMS:	
	
// GetRequestedObjects() is robust enough to handle anything else.
	default:
		vctRequest = PerfObjectContainer::GetRequestedObjects(szQuery);
		break;

	}

//.............................................................................
// Calculate amount of space needed for the given request vector
	const DWORD cbSpaceNeeded = 
		PerfObjectContainer::GetPredictedTotalBytesNeeded(vctRequest);
	
	if (dwBufferSize < cbSpaceNeeded) {
		LeaveCriticalSection(&g_csEnum);
		LOCKCOUNTDECL("collectctrs in corpermonext");								\

		return ERROR_MORE_DATA;			
	}

//.............................................................................
// Actually write out objects for given request
	DWORD cObjWritten = PerfObjectContainer::WriteRequestedObjects(stream, vctRequest);
	
#if defined(_DEBUG)
	VerifyOutputStream(
		(const BYTE*) stream.GetHeadPtr(), 
		vctRequest,
		cObjWritten,
		stream.GetWrittenSize());
#endif

	LeaveCriticalSection(&g_csEnum);
	LOCKCOUNTDECL("collectctrs in corpermonext");								\

//.............................................................................
//	update OUT parameters

	*ppData			= stream.GetCurrentPtr();
	*lpcObjectTypes = cObjWritten;
    *lpcbBytes		= stream.GetWrittenSize();
    
    _ASSERTE(IS_ALIGNED_8 (*lpcbBytes));
        

	return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
// Exported API call: Close counters
//-----------------------------------------------------------------------------
extern "C" DWORD APIENTRY CloseCtrs(void)
{
	
    if (--g_dwNumOpenCtrsCalled == 0)
    {
#ifdef PERFMON_LOGGING
        // Close the debug log.
        PerfObjectContainer::PerfMonDebugLogTerminate();
#endif //#ifdef PERFMON_LOGGING
    
        g_func.TerminateFCHandler();

        g_CorInstList.CloseGlobalCounters();

        // Free all instances
        g_CorInstList.Free();


        // Release attachment to PSAPI
        g_PSAPI.Free();


        DeleteCriticalSection(&g_csEnum);

    }
	
    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
// Enumerate the COM+ processes on our list
//-----------------------------------------------------------------------------
void EnumCOMPlusProcess()
{
	g_CorInstList.Enumerate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfmonhelperclasses.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfMonHelperClasses.cpp
// 
// Utilities classes for COR PerfMon Ext Dll.
// Although these util classes are pretty generic, Each of them is designed
// to make the COR Ext Dll code cleaner, not for reusable components.
//*****************************************************************************

#include "stdafx.h"

// Headers for COM+ Perf Counters

#include "CORPerfMonExt.h"
#include "IPCManagerInterface.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\makefile.inc ===
doscript: 
!if "$(TARGETCOMPLUS)" != ""
	binplace -e -r $(TARGETCOMPLUS) -p $(BINPLACE_PLACEFILE) corperfmonsymbols.ini corperfmonsymbols.h init.bat
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfmonextutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfMonExtUtil.cpp
//
// Utility functions for PerfMon Extension Dlls. Modified from MSDN samples
//*****************************************************************************

#include "stdafx.h"

#include <WinPerf.h>

#include "CORPerfMonExt.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
ULONG                   ulInfoBufferSize = 0;


DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string 

//-----------------------------------------------------------------------------
// GetQueryType()
//-----------------------------------------------------------------------------
EPerfQueryType
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfobjectcontainer.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfObjectContainer.cpp
// 
// Container to deal with all generic PerfObject needs
//*****************************************************************************

#include "stdafx.h"

// Headers for COM+ Perf Counters


// Headers for PerfMon
//#include "CORPerfMonExt.h"
#include <WinPerf.h>		// Connect to PerfMon
#include "PerfCounterDefs.h"
#include "CORPerfMonSymbols.h"

#include "ByteStream.h"
#include "PerfObjectBase.h"
//#include "CtrDefImpl.h"
#include "CorAppNode.h"
#include "PerfObjectContainer.h"

#ifdef PERFMON_LOGGING
HANDLE PerfObjectContainer::m_hLogFile = 0;
#endif //#ifdef PERFMON_LOGGING


//-----------------------------------------------------------------------------
// Used by ObjReqVector GetRequestedObjects (string)
// 
// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
//-----------------------------------------------------------------------------
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)



//-----------------------------------------------------------------------------
// Safe container to get a perf object
//-----------------------------------------------------------------------------
PerfObjectBase & PerfObjectContainer::GetPerfObject(DWORD idx) // static 
{
	_ASSERTE(idx < Count && idx >= 0);
	_ASSERTE(PerfObjectArray[idx] != NULL);

	return *PerfObjectArray[idx];
}

//-----------------------------------------------------------------------------
// Predict the total bytes we need
//-----------------------------------------------------------------------------
DWORD PerfObjectContainer::GetPredictedTotalBytesNeeded(ObjReqVector vctRequest)
{
// Now that we know which objects we need to write,
// we can determine total space needed 
	DWORD iObject;

	DWORD dwBytesNeeded = 0;
	for(iObject = 0; iObject < Count; iObject++) {
		if (vctRequest.IsBitSet(iObject)) {
			dwBytesNeeded += GetPerfObject(iObject).GetPredictedByteLength();		
		}
	}

	return dwBytesNeeded;

}

//-----------------------------------------------------------------------------
// Write all objects. Assume we have enough space in stream.
// Returns # of objects written
//-----------------------------------------------------------------------------
DWORD PerfObjectContainer::WriteRequestedObjects(
	ByteStream & stream, 
	ObjReqVector vctRequest
) // static
{
	if (vctRequest.IsEmpty())
	{
		return 0;
	}

	DWORD iObject;
	DWORD cTotalObjectsWritten = 0;

// Enumerate through and write each one out	
	for(iObject = 0; iObject < Count; iObject++) {
		if (vctRequest.IsBitSet(iObject)) {
			PerfObjectContainer::GetPerfObject(iObject).WriteAllData(stream);
			cTotalObjectsWritten++;
		}
	}

	return cTotalObjectsWritten;
}

//-----------------------------------------------------------------------------
// IsAnyNumberInUnicodeList()
// We parse each number in the string, and then compare that with all elements
// in the array.
// ObjReqVector is just a bit stream indicating which objects are needed.
//-----------------------------------------------------------------------------
ObjReqVector PerfObjectContainer::GetRequestedObjects ( // static
	LPCWSTR	szItemList
)
{
	_ASSERTE(Count > 0);

// Since we return the requested objects as a bit stream, we limit
// the number of objects to the number of bits in the stream.
	_ASSERTE(Count < sizeof(ObjReqVector) * 8);

	ObjReqVector vctRequest;
	vctRequest.Reset();

    DWORD   dwThisNumber;
    const WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;    
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (szItemList == 0) 
	{
		return vctRequest;    // null pointer, # not found
	}

    pwcThisChar = szItemList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimiter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
				// Now that we parsed it, compare with each number in array                   
					for(DWORD i = 0; i < Count; i++) {
						if (GetPerfObject(i).GetObjectDef()->ObjectNameTitleIndex == dwThisNumber) {
							//return TRUE;
							vctRequest.SetBitHigh(i);
						}
					}
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return vctRequest;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

	return vctRequest;

}   // IsAnyNumberInUnicodeList


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
#ifdef PERFMON_LOGGING
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// PerfMonLogInit()
// Initialize debuggin related stuff. Open the log file.
//-----------------------------------------------------------------------------
void PerfObjectContainer::PerfMonDebugLogInit (char* szFileName)
{
    char szOutStr[512];
    DWORD dwWriteByte;
    
    m_hLogFile = CreateFileA (szFileName, 
                         GENERIC_WRITE,
                         0,    
                         0,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         0);
            
    if (m_hLogFile != INVALID_HANDLE_VALUE) {
        if (SetFilePointer (m_hLogFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {
            sprintf (szOutStr, "PerfMon Log BEGIN-------------\n");
            WriteFile (m_hLogFile, szOutStr, strlen(szOutStr), &dwWriteByte, NULL);
        }
        else 
        {
            if (!CloseHandle (m_hLogFile))
                printf("ERROR: In closing file\n");
        }
    }
}

//-----------------------------------------------------------------------------
// PerfMonLogTerminate()
// Shutdown logging.
//-----------------------------------------------------------------------------
void PerfObjectContainer::PerfMonDebugLogTerminate()
{
    CloseHandle (m_hLogFile);
}

//-----------------------------------------------------------------------------
// PerfMonLog()
// PerfmonLog has overloaded implementations which log the counter data being 
// written out to the stream. This helps a lot in debuggin and isolating the 
// points of failure.
//-----------------------------------------------------------------------------
void PerfObjectContainer::PerfMonLog (char *szLogStr, DWORD dwVal)
{
    char szOutStr[512];
    DWORD dwWriteByte;
    
    sprintf (szOutStr, "%s %d", szLogStr, dwVal);
    WriteFile (m_hLogFile, szOutStr, strlen(szOutStr), &dwWriteByte, NULL);
}

void PerfObjectContainer::PerfMonLog (char *szLogStr, LPCWSTR szName)
{
    char szOutStr[512];
    DWORD dwWriteByte;

    sprintf (szOutStr, "%s %s", szLogStr, szName);
    WriteFile (m_hLogFile, szOutStr, strlen(szOutStr), &dwWriteByte, NULL);
}
   
void PerfObjectContainer::PerfMonLog (char *szLogStr, LONGLONG lVal)
{
    char szOutStr[512];
    DWORD dwWriteByte;
    
    sprintf (szOutStr, "%s %g", szLogStr, lVal);
    WriteFile (m_hLogFile, szOutStr, strlen(szOutStr), &dwWriteByte, NULL);
}

void PerfObjectContainer::PerfMonLog (char *szLogStr)
{
    char szOutStr[512];
    DWORD dwWriteByte;
    
    sprintf (szOutStr, "%s", szLogStr);
    WriteFile (m_hLogFile, szOutStr, strlen(szOutStr), &dwWriteByte, NULL);
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
#endif //PERFMON_LOGGING
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfobjectcontainer.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfObjectContainer.h
// 
// Container to deal with all generic PerfObject needs
//*****************************************************************************

#ifndef _PERFOBJECTCONTAINER_H_
#define _PERFOBJECTCONTAINER_H_

#include "ByteStream.h"

class PerfObjectBase;

//-----------------------------------------------------------------------------
// Object Request Vector - tells which objects we want to write out
// This is highly coupled with PerfObjectContainer.
// 
// Implemented as a bit vector for highly efficiency. That's good for 32 objs.
//-----------------------------------------------------------------------------
class ObjReqVector {
private:		
	__int32 m_data;

public:
// Set all bits to 0.
	void Reset();

// set all bits to 1
	void SetAllHigh();

// return true if we have any non-0 bits
	bool IsEmpty() const;

// Set bit i to high
	void SetBitHigh(int i);

// return true if bit i is high, else false.
	bool IsBitSet(int i) const;
};

//-----------------------------------------------------------------------------
// Container class to encapsulate all the PerfObjects
//-----------------------------------------------------------------------------
class PerfObjectContainer
{
protected:
// This array holds pointers to each PerfObjectBase. This means we have to
// instantiate the array in CtrDefImpl.cpp and not PerfObjectBase.cpp
	static PerfObjectBase * PerfObjectArray[];
	
public:
	static PerfObjectBase & GetPerfObject(DWORD idx);
	static const DWORD Count;
    
	static DWORD WriteRequestedObjects(ByteStream & stream, ObjReqVector vctRequest);
	static DWORD GetPredictedTotalBytesNeeded(ObjReqVector vctRequest);
	static ObjReqVector GetRequestedObjects(LPCWSTR szItemList);
#ifdef PERFMON_LOGGING
    static void PerfMonDebugLogInit(char* szFileName);
    static void PerfMonDebugLogTerminate();
    static void PerfMonLog (char *szLogStr, DWORD dwVal);
    static void PerfMonLog (char *szLogStr, LPCWSTR szName);
    static void PerfMonLog (char *szLogStr, LONGLONG lVal);
    static void PerfMonLog (char *szLogStr);
#endif //#ifdef PERFMON_LOGGING
protected:

private:
#ifdef PERFMON_LOGGING
    static HANDLE m_hLogFile;
#endif //#ifdef PERFMON_LOGGING
	
};

//-----------------------------------------------------------------------------
// Bit vector to store which objects we want
//-----------------------------------------------------------------------------
inline void ObjReqVector::Reset()
{
	m_data = 0;
}

inline void ObjReqVector::SetAllHigh()
{
	m_data = -1; // all 1s in 2s compl. notation.
}

inline bool ObjReqVector::IsEmpty() const
{
	return (0 == m_data);
}

inline void ObjReqVector::SetBitHigh(int i)
{
	_ASSERTE(i < (sizeof(m_data) * 8));

	m_data |= (1 << i);
};

inline bool ObjReqVector::IsBitSet(int i) const
{
	_ASSERTE(i < (sizeof(m_data) * 8));

	return (m_data & (1 << i)) != 0;
};

#endif // _PERFOBJECTCONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfobjectbase.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CORPerfMonExt.cpp : 
// Main file of PerfMon Ext Dll which glues PerfMon & COM+ EE stats.
// Inludes all Dll entry points.//
//*****************************************************************************

#include "stdafx.h"

// Headers for COM+ Perf Counters

// Headers for PerfMon
#include "CORPerfMonExt.h"

#include "IPCFuncCall.h"
#include "ByteStream.h"
#include "PerfObjectBase.h"
#include "InstanceList.h"

//-----------------------------------------------------------------------------
// Good for all basic counter categories with no calculated data
//-----------------------------------------------------------------------------
PerfObjectBase::PerfObjectBase(
	void * pCtrDef, 
	DWORD cbInstanceData, 
	DWORD cbMarshallOffset, 
	DWORD cbMarshallLen,
	InstanceList * pInstanceList
) : m_pCtrDef			((PERF_OBJECT_TYPE*) pCtrDef), 
	m_cbMarshallOffset	(cbMarshallOffset),
	m_cbMarshallLen		(cbMarshallLen),
	m_cbInstanceData	(cbInstanceData),
	m_pInstanceList		(pInstanceList)
{
// Quick checksum on definition. 
	_ASSERTE(m_pCtrDef->HeaderLength == sizeof (PERF_OBJECT_TYPE));

}


//-----------------------------------------------------------------------------
// Get data out of object header
//-----------------------------------------------------------------------------
DWORD PerfObjectBase::GetNumInstances() const
{	
	return m_pCtrDef->NumInstances;
}

DWORD PerfObjectBase::GetNumCounters() const
{
	return m_pCtrDef->NumCounters;
}

DWORD PerfObjectBase::GetInstanceDataByteLength() const
{
	return m_cbInstanceData;
}	

//-----------------------------------------------------------------------------
// Prediction. Not binding.
//-----------------------------------------------------------------------------
DWORD PerfObjectBase::GetPredictedByteLength() const
{
	DWORD cInstances = m_pInstanceList->GetCount() + 1;

	return 
		m_pCtrDef->DefinitionLength +			// size of definitions
		(										// + size per instance
			sizeof(PERF_INSTANCE_DEFINITION) +	//		inst header
			APP_STRING_LEN * sizeof(wchar_t) +	//		string len
			m_cbInstanceData)					//		inst data
		* cInstances;							// * times total number of instances
}

//-----------------------------------------------------------------------------
// Set the number of instances
//-----------------------------------------------------------------------------
void PerfObjectBase::SetNumInstances(DWORD cInstances)
{
	m_pCtrDef->NumInstances = cInstances;
	m_pCtrDef->TotalByteLength = 
		m_pCtrDef->DefinitionLength +			// size of definitions
		(										// + size per instance
			sizeof(PERF_INSTANCE_DEFINITION) +	//		inst header
			APP_STRING_LEN * sizeof(wchar_t) +	//		string len
			m_cbInstanceData)					//		inst data
		* cInstances;							// * times total number of instances

}


//-----------------------------------------------------------------------------
// Must convert offsets from relative to absolute
//-----------------------------------------------------------------------------
void PerfObjectBase::TouchUpOffsets(DWORD dwFirstCounter, DWORD dwFirstHelp)
{
// touch up object
	m_pCtrDef->ObjectNameTitleIndex += dwFirstCounter;
	m_pCtrDef->ObjectHelpTitleIndex += dwFirstHelp;


// Touch up each counter
	PERF_COUNTER_DEFINITION	* pCtrDef = (PERF_COUNTER_DEFINITION*) 
		(((BYTE*) m_pCtrDef) + sizeof(PERF_OBJECT_TYPE));

	for(DWORD i = 0; i < m_pCtrDef->NumCounters; i ++, pCtrDef ++) 
	{
		pCtrDef->CounterNameTitleIndex += dwFirstCounter;
		pCtrDef->CounterHelpTitleIndex += dwFirstHelp;		
	}
	

}

//-----------------------------------------------------------------------------
// Write out all data: Definitions, instance headers, names, data
// This must connect to instance list & IPC block
//-----------------------------------------------------------------------------
void PerfObjectBase::WriteAllData(ByteStream & stream)
{
    DWORD dwSizeStart = stream.GetWrittenSize();
	PERF_OBJECT_TYPE* pHeader = (PERF_OBJECT_TYPE*) stream.GetCurrentPtr();

	_ASSERTE(m_pInstanceList != NULL);

	m_pCtrDef->NumInstances = 0;

// Write out constant definitions to the stream
	WriteDefinitions(stream);

// Calculate Global instance
// Write out node for global block (first instance)	
	BaseInstanceNode * pGlobalNode = m_pInstanceList->GetGlobalNode();

	// const UnknownIPCBlockLayout * pGlobalCtrs = (const UnknownIPCBlockLayout *) pGlobalNode->GetDataBlock();
	//WriteInstance(stream, L"_Global_", p_gGlobalCtrs);
	//WriteInstance(stream, L"_Global_", pGlobalCtrs);
	WriteInstance(stream, pGlobalNode);

// Write out each of the remaining instances

	BaseInstanceNode * pNode = m_pInstanceList->GetHead();	
	while (pNode != NULL) {
		//WriteInstance(stream, pNode->GetName(), (const UnknownIPCBlockLayout *) pNode->GetDataBlock());
		WriteInstance(stream, pNode);

		pNode = m_pInstanceList->GetNext(pNode);
	}

	DWORD dwSizeEnd = stream.GetWrittenSize();

// Touchup size (done after we set instance size)
	pHeader->TotalByteLength = dwSizeEnd - dwSizeStart;
	pHeader->NumInstances = m_pCtrDef->NumInstances;

}

//-----------------------------------------------------------------------------
// Copy the constant definition data 
//-----------------------------------------------------------------------------
void PerfObjectBase::WriteDefinitions(ByteStream & stream) const
{
	_ASSERTE(m_pCtrDef != NULL);

	_ASSERTE(m_pCtrDef->HeaderLength == sizeof(PERF_OBJECT_TYPE));

// Note: size still needs to be touched up
	stream.WriteMem(m_pCtrDef, m_pCtrDef->DefinitionLength);
}


//-----------------------------------------------------------------------------
// Writing a single instance (includes header, name, and Data)
//-----------------------------------------------------------------------------
void PerfObjectBase::WriteInstance(ByteStream & stream, const BaseInstanceNode * pNode)
//void PerfObjectBase::WriteInstance(ByteStream & stream, LPCWSTR szName, const UnknownIPCBlockLayout * pDataSrc)
{
// Null instance
	if (pNode == NULL)
	{
		return;
	}
	
	m_pCtrDef->NumInstances ++;
	



	LPCWSTR szName = pNode->GetName();
	const UnknownIPCBlockLayout * pDataSrc =  
        (const UnknownIPCBlockLayout *) pNode->GetDataBlock();
    
// Write out node for global block
	WriteInstanceHeader(stream, szName);	
	
#ifdef PERFMON_LOGGING
    DebugLogInstance(pDataSrc, szName);
#endif //#ifdef PERFMON_LOGGING

// Call virtual function. Base class implementation just calls Marshall().
// Derived classes can override to add any calculated values.
	CopyInstanceData(stream, pDataSrc);
}

//-----------------------------------------------------------------------------
// Write out the instance header
// This includes PERF_INSTANCE_DEFINITION, a unicode name, and touchups
//-----------------------------------------------------------------------------
void PerfObjectBase::WriteInstanceHeader(ByteStream & stream, LPCWSTR szName)
{
// Get bytes (including null terminator) of szName
	const int cBytesName = (wcslen(szName) + 1)* sizeof(wchar_t);


	PERF_INSTANCE_DEFINITION * pDef = 
		(PERF_INSTANCE_DEFINITION*) stream.WriteStructInPlace(sizeof(PERF_INSTANCE_DEFINITION));


	pDef->ByteLength				= sizeof(PERF_INSTANCE_DEFINITION) + cBytesName;
	//pDef->ParentObjectTitleIndex	= CtrDef.m_objPerf.ObjectNameTitleIndex;
	pDef->ParentObjectTitleIndex	= 0;
	pDef->ParentObjectInstance		= -1;
	pDef->UniqueID					= PERF_NO_UNIQUE_ID;
	pDef->NameOffset				= sizeof(PERF_INSTANCE_DEFINITION);		
	pDef->NameLength				= cBytesName;
	
// Write unicode string
	stream.WriteMem(szName, cBytesName);

// Pad to 8-byte boundary
    long lPadBytes = 0;
    if ((lPadBytes = (pDef->ByteLength & 0x0000007)) != 0)
    {
        lPadBytes = 8 - lPadBytes;
        pDef->ByteLength += lPadBytes;
        _ASSERTE((pDef->ByteLength & 0x00000007) == 0);
        // Write out pad bytes, this has the side-effect of incrementing the stream pointer 
        stream.WritePad (lPadBytes);
    }
}


//-----------------------------------------------------------------------------
// Copy pertinent info out of the IPC block and into the stream
// Base class implementation just does auto-marshall. Only need to override
// if you have calculated values.
//-----------------------------------------------------------------------------
void PerfObjectBase::CopyInstanceData(ByteStream & out, const UnknownIPCBlockLayout * pDataSrc) const // virtual
{
	MarshallInstanceData(out, pDataSrc);
}

//-----------------------------------------------------------------------------
// Auto marshall from the IPCblock into the stream
//-----------------------------------------------------------------------------
void PerfObjectBase::MarshallInstanceData(
		ByteStream & stream, 
		const UnknownIPCBlockLayout * pDataSrc) const
{
// Asserts here to make sure marshall information was set correctly:
// Marshall offset is a byte offset into the UnknownIPCBlockLayout
// Marshall len is # of bytes to copy from that block, into the byte stream.
// If this check fails:
// 1. May have removed counters, and not updated marshalling
	_ASSERTE(m_cbMarshallOffset > 0);	
	_ASSERTE(sizeof(PERF_COUNTER_BLOCK) + m_cbMarshallLen <= m_cbInstanceData);

	PERF_COUNTER_BLOCK * pCtrBlk = 
		(PERF_COUNTER_BLOCK*) stream.WriteStructInPlace(sizeof(PERF_COUNTER_BLOCK));

    // Make sure that the buffer returned for counter data fields is 8-byte aligned
    long lPadBytes = 0;
    if ((lPadBytes = (m_cbInstanceData & 0x00000007)) != 0)
        lPadBytes = 8 - lPadBytes;

    // Update the PERF_COUNTER_BLOCK.ByteLength
	pCtrBlk->ByteLength = m_cbInstanceData + lPadBytes;

    _ASSERTE((pCtrBlk->ByteLength & 0x00000007) == 0);

	if (pDataSrc == NULL) 
	{
	// Skip over bytes
		stream.WriteStructInPlace(m_cbMarshallLen);	
        // Write out pad bytes, this has the side-effect of incrementing the stream pointer 
        if (lPadBytes)
            stream.WritePad (lPadBytes);
		return;
	}

// Direct copy for normal counters
	BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;

	stream.WriteMem(pvStart, m_cbMarshallLen);
    
    // Write out pad bytes, this has the side-effect of incrementing the stream pointer 
    if (lPadBytes)
        stream.WritePad (lPadBytes);

}

#ifdef PERFMON_LOGGING
// Log counter data for debugging
void PerfObjectBase::DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName) 
{
    // Do nothing.
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfobjectbase.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfObjectBase.h
// 
// Base object to tie everything together for perf counters as well as 
// implementation to publish them through a byte stream
//*****************************************************************************

#ifndef _PERFOBJECTBASE_H_
#define _PERFOBJECTBASE_H_

#include <winperf.h>
//struct PERF_OBJECT_TYPE;
//struct PerfCounterIPCControlBlock;
class ByteStream;
class BaseInstanceNode;
class InstanceList;


struct UnknownIPCBlockLayout;

//-----------------------------------------------------------------------------
// Create a derived instance of this class for each PerfMon Object that we want
//-----------------------------------------------------------------------------
class PerfObjectBase
{
public:
	//PerfObjectBase(PERF_OBJECT_TYPE * pCtrDef);

	PerfObjectBase(
		void * pCtrDef, 
		DWORD cbInstanceData, 
		DWORD cbMarshallOffset, 
		DWORD cbMarshallLen,
		InstanceList * pInstanceList
	);

// Write out all data: Definitions, instance headers, names, data
// This must connect to instance list & IPC block
	void WriteAllData(ByteStream & out);

// Get various stats for this object from header
	DWORD GetNumInstances() const;
	DWORD GetNumCounters() const;
	DWORD GetTotalByteLength() const;

	DWORD GetInstanceDataByteLength() const;
	const PERF_OBJECT_TYPE * GetObjectDef() const;
	
// Predict 
	DWORD GetPredictedByteLength() const;

// Must convert offsets from relative to absolute
	void TouchUpOffsets(DWORD dwFirstCounter, DWORD dwFirstHelp);

// Set the number of instances, byte len, etc.
	void SetNumInstances(DWORD cInstances);


// Do we write this Perf Object out.
	void SetWriteFlag(bool fWrite);
	bool GetWriteFlag() const;


protected:
	//void WriteInstance(ByteStream & stream, LPCWSTR szName, const UnknownIPCBlockLayout * DataSrc);
	void WriteInstance(ByteStream & stream, const BaseInstanceNode * pNode);
	
	void WriteInstanceHeader(ByteStream & stream, LPCWSTR szName);

// Copy pertinent info out of the IPC block and into the stream
	virtual void CopyInstanceData(ByteStream & out, const UnknownIPCBlockLayout * DataSrc) const;
	//virtual void CopyInstanceData(ByteStream & out, const BaseInstanceNode * pNode) const;
	

// Copy the definition block (pointer to by m_pCtrDef).
	void WriteDefinitions(ByteStream & out) const;

// Auto marshall from the IPCblock into the stream
	void MarshallInstanceData(ByteStream & out, const UnknownIPCBlockLayout * DataSrc) const;

#ifdef PERFMON_LOGGING
// Log counter data for debugging
    virtual void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
#endif

protected:
// Pointer to a Counter Definition layout.
// Since # of instances changes, we can't make this const
	PERF_OBJECT_TYPE * const m_pCtrDef;

// Count of bytes for each instance data (not including header)
	DWORD m_cbInstanceData;

// Instance list
	InstanceList * const m_pInstanceList;

// Offset & size to marshall (in IPC block)
	DWORD m_cbMarshallOffset;
	DWORD m_cbMarshallLen;

// Do we need to write this object?
	bool m_fOutput;
};

//-----------------------------------------------------------------------------
// Inline functions
//-----------------------------------------------------------------------------
inline const PERF_OBJECT_TYPE * PerfObjectBase::GetObjectDef() const
{
	return m_pCtrDef;
}

inline DWORD PerfObjectBase::GetTotalByteLength() const
{
	return m_pCtrDef->TotalByteLength;
}

#endif // _PERFOBJECTBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfobjectderived.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfObjectDerived.cpp : 
// All perf objects that are derived from the PerfObjectBase are defined here.
// These derived classes can specialize functions of the base class for logging, special
// counter computation etc.
//*****************************************************************************

#include "stdafx.h"
#include "CorPerfMonExt.h"
#include "PerfObjectContainer.h"
#include "PerfObjectDerived.h"

#ifdef PERFMON_LOGGING
void PerfObjectJit::DebugLogInstance(const UnknownIPCBlockLayout * pDataSrc, LPCWSTR szName)
{
    if (pDataSrc != NULL)   
    {
        PERFMON_LOG(("Logging data for ", szName));
        
        BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;

        PERFMON_LOG(("cMethodsJitted ", ((Perf_Jit *)pvStart)->cMethodsJitted));
//        PERFMON_LOG(("cbILJitted ", ((Perf_Jit *)pvStart)->cbILJitted));
//        PERFMON_LOG(("cbPitched ", ((Perf_Jit *)pvStart)->cbPitched));
        PERFMON_LOG(("cJitFailures ", ((Perf_Jit *)pvStart)->cJitFailures));
        PERFMON_LOG(("timeInjit ", ((Perf_Jit *)pvStart)->timeInJit));
        PERFMON_LOG(("\n "));
    }
}


void PerfObjectSecurity::DebugLogInstance(const UnknownIPCBlockLayout * pDataSrc, LPCWSTR szName)
{
    if (pDataSrc != NULL)   
    {
        PERFMON_LOG(("Logging data for ", szName));
        
        BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;

        PERFMON_LOG(("timeAuthorize ", ((Perf_Security *)pvStart)->timeAuthorize));
        PERFMON_LOG(("cLinkChecks ", ((Perf_Security *)pvStart)->cLinkChecks));
        PERFMON_LOG(("depthRemote ", ((Perf_Security *)pvStart)->depthRemote));
        PERFMON_LOG(("timeRTchecks ", ((Perf_Security *)pvStart)->timeRTchecks));
        PERFMON_LOG(("cTotalRTChecks ", ((Perf_Security *)pvStart)->cTotalRTChecks));
        PERFMON_LOG(("stackWalkDepth ", ((Perf_Security *)pvStart)->stackWalkDepth));
        PERFMON_LOG(("\n "));
    }
}

void PerfObjectLoading::DebugLogInstance(const UnknownIPCBlockLayout * pDataSrc, LPCWSTR szName)
{
    if (pDataSrc != NULL)   
    {
        PERFMON_LOG(("Logging data for ", szName));
        
        BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;
        
        //PERFMON_LOG(("MethodsJitted ", ((Perf_Jit *)pvStart)->cMethodsJitted);
        PERFMON_LOG(("\n "));
    }
}

void PerfObjectInterop::DebugLogInstance(const UnknownIPCBlockLayout * pDataSrc, LPCWSTR szName)
{
    if (pDataSrc != NULL)   
    {
        PERFMON_LOG(("Logging data for ", szName));
        
        BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;
        
        //PERFMON_LOG(("MethodsJitted ", ((Perf_Jit *)pvStart)->cMethodsJitted);
        PERFMON_LOG(("\n "));
    }
}

void PerfObjectLocksAndThreads::DebugLogInstance(const UnknownIPCBlockLayout * pDataSrc, LPCWSTR szName)
{
    if (pDataSrc != NULL)   
    {
        PERFMON_LOG(("Logging data for ", szName));
        
        BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;
        
        PERFMON_LOG(("\n "));
    }
}

void PerfObjectExcep::DebugLogInstance(const UnknownIPCBlockLayout * pDataSrc, LPCWSTR szName)
{
    if (pDataSrc != NULL)   
    {
        PERFMON_LOG(("Logging data for ", szName));
        
        BYTE * pvStart = (BYTE*) pDataSrc + m_cbMarshallOffset;
        
//        PERFMON_LOG((" ExcepThrown ", ((Perf_Excep *)pvStart)->cThrown));
        PERFMON_LOG((" FiltersRun ", ((Perf_Excep *)pvStart)->cFiltersExecuted));
        PERFMON_LOG((" Filanally executed ", ((Perf_Excep *)pvStart)->cFinallysExecuted));
        PERFMON_LOG((" StackDepth ", ((Perf_Excep *)pvStart)->cThrowToCatchStackDepth));
        PERFMON_LOG(("\n "));
    }
}

#endif  //#define PERFMON_LOGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\perfobjectderived.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PerfObjectBase.h
// 
// Base object to tie everything together for perf counters as well as 
// implementation to publish them through a byte stream
//*****************************************************************************

#ifndef _PERFOBJECTDERIVED_H_
#define _PERFOBJECTDERIVED_H_

#include "PerfObjectBase.h"
//class PerfObjectBase;


#ifdef PERFMON_LOGGING
class PerfObjectLoading : public PerfObjectBase
{
public:
    PerfObjectLoading(
                void * pCtrDef,
                DWORD cbInstanceData,
                DWORD cbMarshallOffset,
                DWORD cbMarshallLen,
                InstanceList * pInstanceList
        ) : PerfObjectBase(pCtrDef,
                       cbInstanceData,
                       cbMarshallOffset,
                       cbMarshallLen,
                       pInstanceList
                       )
    {};
    void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
};

class PerfObjectJit : public PerfObjectBase
{
public:
    PerfObjectJit(
                void * pCtrDef,
                DWORD cbInstanceData,
                DWORD cbMarshallOffset,
                DWORD cbMarshallLen,
                InstanceList * pInstanceList
        ) : PerfObjectBase(pCtrDef,
                       cbInstanceData,
                       cbMarshallOffset,
                       cbMarshallLen,
                       pInstanceList
                       )
    {};
    void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
};

class PerfObjectInterop : public PerfObjectBase
{
public:
    PerfObjectInterop(
                void * pCtrDef,
                DWORD cbInstanceData,
                DWORD cbMarshallOffset,
                DWORD cbMarshallLen,
                InstanceList * pInstanceList
        ) : PerfObjectBase(pCtrDef,
                       cbInstanceData,
                       cbMarshallOffset,
                       cbMarshallLen,
                       pInstanceList
                       )
    {};
    void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
};

class PerfObjectLocksAndThreads : public PerfObjectBase
{
public:
    PerfObjectLocksAndThreads(
                void * pCtrDef,
                DWORD cbInstanceData,
                DWORD cbMarshallOffset,
                DWORD cbMarshallLen,
                InstanceList * pInstanceList
        ) : PerfObjectBase(pCtrDef,
                       cbInstanceData,
                       cbMarshallOffset,
                       cbMarshallLen,
                       pInstanceList
                       )
    {};
    void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
};

class PerfObjectExcep : public PerfObjectBase
{
public:
    PerfObjectExcep(
                void * pCtrDef,
                DWORD cbInstanceData,
                DWORD cbMarshallOffset,
                DWORD cbMarshallLen,
                InstanceList * pInstanceList
        ) : PerfObjectBase(pCtrDef,
                       cbInstanceData,
                       cbMarshallOffset,
                       cbMarshallLen,
                       pInstanceList
                       )
    {};
    void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
};

class PerfObjectSecurity : public PerfObjectBase
{
public:
    PerfObjectSecurity(
                void * pCtrDef,
                DWORD cbInstanceData,
                DWORD cbMarshallOffset,
                DWORD cbMarshallLen,
                InstanceList * pInstanceList
        ) : PerfObjectBase(pCtrDef,
                       cbInstanceData,
                       cbMarshallOffset,
                       cbMarshallLen,
                       pInstanceList
                       )
    {};
    void DebugLogInstance(const UnknownIPCBlockLayout * DataSrc, LPCWSTR szName);
};

#endif // #ifdef PERFMON_LOGGING

#endif // _PERFOBJECTDERIVED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmonhelp\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

// Headers for COM+ Perf Counters
#include <WinWrap.h>
#include <windows.h>
#include <stddef.h>
#include <process.h>
#include "UtilCode.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\psapiutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PSAPIUtil.cpp
// 
// Implementation to connect to PSAPI.dll
//*****************************************************************************

#include "stdafx.h"


#include "PSAPIUtil.h"
#include "..\..\dlls\mscorrc\resource.h"
//-----------------------------------------------------------------------------
// Manage Connection to Dynamic Loading of PSAPI.dll
// Use this to protect our usage of the dll and manage the global namespace
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Set everything to NULL
//-----------------------------------------------------------------------------
PSAPI_dll::PSAPI_dll()
{
	m_hInstPSAPI			= NULL;
	m_pfEnumProcess			= NULL;
	m_pfEnumModules			= NULL;
	m_pfGetModuleBaseName	= NULL;

	m_fIsLoaded				= false;
}

//-----------------------------------------------------------------------------
// have dtor release library
//-----------------------------------------------------------------------------
PSAPI_dll::~PSAPI_dll()
{
	Free();
}

//-----------------------------------------------------------------------------
// Wrap GetProcAddress(), but provide message box for failure (which can
// happen in free builds, so don't use an ASSERT)
//-----------------------------------------------------------------------------
void* PSAPI_dll::HelperGetProcAddress(const char * szFuncName)
{
	_ASSERTE(m_hInstPSAPI != NULL);

	void * pFn = GetProcAddress(m_hInstPSAPI, szFuncName);
	if (pFn == NULL) 
	{
	// Print polite error message
		CorMessageBox(NULL, IDS_PERFORMANCEMON_FUNCNOTFOUND, IDS_PERFORMANCEMON_FUNCNOTFOUND_TITLE, MB_OK | MB_ICONWARNING, TRUE, szFuncName);

	// Set success flag to false
		m_fIsLoaded = false;
		return NULL;
	}
	return pFn;
}


//-----------------------------------------------------------------------------
// Load the library and hook up to the functions
// Print error messages on failure
// Return true on success, false on any failure.
// Note: false means we can still run, but just can get per-process info
//-----------------------------------------------------------------------------
bool PSAPI_dll::Load()
{
	if (IsLoaded()) return true;

// Set success to true. First one to spot an error should flip this to false
	m_fIsLoaded = true;

	m_hInstPSAPI = WszLoadLibrary(L"PSAPI.dll");
	if (m_hInstPSAPI == NULL) {
		CorMessageBox(NULL, 
			IDS_PERFORMANCEMON_PSAPINOTFOUND, 
			IDS_PERFORMANCEMON_PSAPINOTFOUND_TITLE, 
			MB_OK | MB_ICONWARNING,
			TRUE);

		m_fIsLoaded = false;
		goto errExit;
	}

// Note: no WszGetProcAddress() function
	m_pfEnumProcess			= (BOOL (WINAPI *)(DWORD*, DWORD cb, DWORD*)) HelperGetProcAddress("EnumProcesses");
	m_pfEnumModules			= (BOOL (WINAPI *)(HANDLE, HMODULE*, DWORD, DWORD*)) HelperGetProcAddress("EnumProcessModules");
	m_pfGetModuleBaseName	= (DWORD (WINAPI *)(HANDLE, HMODULE, LPTSTR, DWORD nSize)) HelperGetProcAddress("GetModuleBaseNameW");
	

errExit:
// If failed, then release any holds we had anyway.
	if (!m_fIsLoaded) 
	{
		Free();
	}

	return m_fIsLoaded;
}

//-----------------------------------------------------------------------------
// Release any claims we have to PSAPI.dll
//-----------------------------------------------------------------------------
void PSAPI_dll::Free()
{
	if (m_hInstPSAPI) 
	{
		FreeLibrary(m_hInstPSAPI);
	}

	m_hInstPSAPI			= NULL;
	m_pfEnumProcess			= NULL;
	m_pfEnumModules			= NULL;
	m_pfGetModuleBaseName	= NULL;

	m_fIsLoaded				= false;

}

//-----------------------------------------------------------------------------
// Return true if we are fully attached to PSAPI, else false
//-----------------------------------------------------------------------------
bool PSAPI_dll::IsLoaded()
{
	return m_fIsLoaded;
}

//-----------------------------------------------------------------------------
// Place holder function so that we can call CorMessageBox in utilcode.lib
//-----------------------------------------------------------------------------
HINSTANCE GetModuleInst(){
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************

#ifndef __ClassFactory__h__
#define __ClassFactory__h__

#include <CorProf.h>						// Public header definitions.

// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};

//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}

	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);

private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};

#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\callback.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "StdAfx.h"
#include "Profiler.h"

#define SZ_DEFAULT_LOG_FILE  L"PROFILER.OUT"

#define PREFIX "ProfTrace:  "

ProfCallback *g_Prof = NULL;

void __stdcall EnterStub(FunctionID functionID)
{
    g_Prof->Enter(functionID);
}

void __stdcall LeaveStub(FunctionID functionID)
{
    g_Prof->Leave(functionID);
}
              
void __stdcall TailcallStub(FunctionID functionID)
{
    g_Prof->Tailcall(functionID);
}
              
void __declspec(naked) EnterNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp+16]
        call EnterStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
}

void __declspec(naked) LeaveNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp+16]
        call LeaveStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
}

void __declspec(naked) TailcallNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp+16]
        call TailcallStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
}

ProfCallback::ProfCallback() : m_pInfo(NULL)
{
    _ASSERTE(g_Prof == NULL);
    g_Prof = this;
}

ProfCallback::~ProfCallback()
{
    if (m_pInfo)
    {
        _ASSERTE(m_pInfo != NULL);
        RELEASE(m_pInfo);
    }
    g_Prof = NULL;
}

COM_METHOD ProfCallback::Initialize( 
    /* [in] */ IUnknown *pProfilerInfoUnk,
    /* [out] */ DWORD *pdwRequestedEvents)
{
    HRESULT hr = S_OK;

    ICorProfilerInfo *pProfilerInfo;
    
    // Comes back addref'd
    hr = pProfilerInfoUnk->QueryInterface(IID_ICorProfilerInfo, (void **)&pProfilerInfo);

    if (FAILED(hr))
        return (hr);

    Printf(PREFIX "Ininitialize(%08x, %08x)\n", pProfilerInfo, pdwRequestedEvents);

    m_pInfo = pProfilerInfo;
    hr = pProfilerInfo->SetEnterLeaveFunctionHooks ( (FunctionEnter *) &EnterNaked,
                                                     (FunctionLeave *) &LeaveNaked,
                                                     (FunctionTailcall *) &TailcallNaked );


    *pdwRequestedEvents = COR_PRF_MONITOR_ENTERLEAVE 
                        | COR_PRF_MONITOR_EXCEPTIONS
                        | COR_PRF_MONITOR_CCW
                        ; // | COR_PRF_MONITOR_ALL;
    return (S_OK);
}

COM_METHOD ProfCallback::ClassLoadStarted( 
    /* [in] */ ClassID classId)
{
    Printf(PREFIX "ClassLoadStarted(%08x)\n", classId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ClassLoadFinished( 
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus)
{
    Printf(PREFIX "ClassLoadFinished(%08x, %08x)\n", classId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ClassUnloadStarted( 
    /* [in] */ ClassID classId)
{
    Printf(PREFIX "ClassUnloadStarted(%08x)\n", classId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ClassUnloadFinished( 
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus)
{
    Printf(PREFIX "ClassUnloadFinished(%08x, %08x)\n", classId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ModuleLoadStarted( 
    /* [in] */ ModuleID moduleId)
{
    Printf(PREFIX "ModuleLoadStarted(%08x)\n", moduleId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ModuleLoadFinished( 
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus)
{
    Printf(PREFIX "ModuleLoadFinished(%08x, %08x)\n", moduleId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ModuleUnloadStarted( 
    /* [in] */ ModuleID moduleId)
{
    Printf(PREFIX "ModuleUnloadStarted(%08x)\n", moduleId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ModuleUnloadFinished( 
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus)
{
    Printf(PREFIX "ModuleUnloadFinished(%08x, %08x)\n", moduleId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ModuleAttachedToAssembly( 
    ModuleID    moduleId,
    AssemblyID  AssemblyId)
{
    Printf(PREFIX "ModuleAttachedToAssembly(%08x, %08x)\n", moduleId, AssemblyId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AppDomainCreationStarted( 
    AppDomainID appDomainId)
{   
    Printf(PREFIX "AppDomainCreationStarted(%08x)\n", appDomainId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AppDomainCreationFinished( 
    AppDomainID appDomainId,
    HRESULT     hrStatus)
{   
    Printf(PREFIX "AppDomainCreationFinished(%08x, %08x)\n", appDomainId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AppDomainShutdownStarted( 
    AppDomainID appDomainId)
{   
    Printf(PREFIX "AppDomainShutdownStarted(%08x)\n", appDomainId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AppDomainShutdownFinished( 
    AppDomainID appDomainId,
    HRESULT     hrStatus)
{   
    Printf(PREFIX "AppDomainShutdownFinished(%08x, %08x)\n", appDomainId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AssemblyLoadStarted( 
    AssemblyID  assemblyId)
{   
    Printf(PREFIX "AssemblyLoadStarted(%08x)\n", assemblyId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::AssemblyLoadFinished( 
    AssemblyID  assemblyId,
    HRESULT     hrStatus)
{   
    Printf(PREFIX "AssemblyLoadFinished(%08x, %08x)\n", assemblyId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::NotifyAssemblyUnLoadStarted( 
    AssemblyID  assemblyId)
{   
    Printf(PREFIX "NotifyAssemblyUnLoadStarted(%08x\n", assemblyId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::NotifyAssemblyUnLoadFinished( 
    AssemblyID  assemblyId,
    HRESULT     hrStatus)
{   
    Printf(PREFIX "NotifyAssemblyUnLoadFinished(%08x, %08x)\n", assemblyId, hrStatus);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionOccurred(
    /* [in] */ ObjectID thrownObjectId)
{
    Printf(PREFIX "ExceptionOccurred(%08x)\n", thrownObjectId);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionHandlerEnter(
    /* [in] */ FunctionID func)
{
    FunctionTrace("ExceptionHandlerEnter", func);
    //Printf(PREFIX "ExceptionHandlerEnter(%08x)\n", func);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionHandlerLeave(
    /* [in] */ FunctionID func)
{
    FunctionTrace("ExceptionHandlerLeave", func);
    //Printf(PREFIX "ExceptionHandlerLeave(%#x)\n", func);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionFilterEnter(
    /* [in] */ FunctionID func)
{
    FunctionTrace("ExceptionFilterEnter", func);
    //Printf(PREFIX "ExceptionFilterEnter(%08x)\n", func);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionFilterLeave()
{
    Printf(PREFIX "ExceptionFilterLeave()\n");
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionSearch(
    /* [in] */ FunctionID func)
{
    FunctionTrace("ExceptionSearch", func);
    //Printf(PREFIX "ExceptionSearch(%08x)\n", func);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionUnwind(
    /* [in] */ FunctionID func)
{
    FunctionTrace("ExceptionUnwind", func);
    //Printf(PREFIX "ExceptionUnwind(%08x)\n", func);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::ExceptionHandled(
    /* [in] */ FunctionID func)
{
    FunctionTrace("ExceptionHandled", func);
    //Printf(PREFIX "ExceptionHandled(%08x)\n", func);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::COMClassicVTableCreated( 
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable,
    /* [in] */ ULONG cSlots)
{
    Printf(PREFIX "COMClassicVTableCreated(%#x, %#x-..., %#x, %d)\n", wrappedClassId, implementedIID.Data1, pVTable, cSlots);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::COMClassicVTableDestroyed( 
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void __RPC_FAR *pVTable)
{
    Printf(PREFIX "COMClassicVTableDestroyed(%#x, %#x-..., %#x)\n", wrappedClassId, implementedIID.Data1, pVTable);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::Enter(
    /* [in] */ FunctionID Function)
{
    FunctionTrace("Enter", Function);
    //Printf(PREFIX "Enter(%08x)\n", Function);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::Leave(
    /* [in] */ FunctionID Function)
{
    FunctionTrace("Leave", Function);
    //Printf(PREFIX "Leave(%08x)\n", Function);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::Tailcall(
    /* [in] */ FunctionID Function)
{
    FunctionTrace("Tailcall", Function);
    //Printf(PREFIX "Tailcall(%08x)\n", Function);
    return (E_NOTIMPL);
}

COM_METHOD ProfCallback::FunctionTrace(
    LPCSTR      pFormat,
    FunctionID  Function)
{
    mdToken     tkMethod;
    mdToken     tkClass;
    IMetaDataImport *pImp=0;
    HRESULT     hr;
    WCHAR       rName[MAX_CLASSNAME_LENGTH];
    WCHAR       rMethod[MAX_CLASSNAME_LENGTH];
    
    hr = m_pInfo->GetTokenAndMetaDataFromFunction(Function, IID_IMetaDataImport, (IUnknown **)&pImp, &tkMethod);
    
    hr = pImp->GetMethodProps(tkMethod, &tkClass, rMethod,sizeof(rMethod)/2,0, 0,0,0,0,0);
    hr = pImp->GetTypeDefProps(tkClass, rName,sizeof(rName)/2,0, 0,0);

    Printf(PREFIX "%s: %ls.%ls\n", pFormat, rName, rMethod);
    
    pImp->Release();
    
    return S_OK;
}
                                              
// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#ifdef SERVER_GC
#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORSVR.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime - Server\0"
#define VER_ORIGFILENAME_STR    "mscorsvr.dll\0"
#else
#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORWKS.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime - WorkStation\0"
#define VER_ORIGFILENAME_STR    "mscorwks.dll\0"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\classfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"
#include "ClassFactory.h"
#include "Profiler.h"
#include "UtilCode.h"  //@TODO: Remove dependency.
#include "Mscoree.h"

// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();


//********** Globals. *********************************************************

static const LPCWSTR g_szCoclassDesc    = L"Microsoft COM+ Runtime Profiler";
static const LPCWSTR g_szProgIDPrefix   = L"ComPlusProfile";
static const LPCWSTR g_szThreadingModel = L"Both";
const int            g_iVersion = 1; // Version of coclasses.
HINSTANCE            g_hInst;        // Instance handle to this piece of code.

// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
    &CLSID_Profiler,    L"CorProfiler",     ProfCallback::CreateObject,
    NULL,               NULL,               NULL
};


//********** Locals. **********************************************************

STDAPI DllUnregisterServer(void);

//********** Code. ************************************************************

//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.
//*****************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Save off the instance handle for later use.
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstance;
        DisableThreadLibraryCalls(hInstance);
    }
    return TRUE;
}

//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
STDAPI DllRegisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.
    HRESULT     hr = S_OK;

    // Initialize some variables so WszXXX will work
    OnUnicodeSystem();

    // Erase all doubt from old entries.
    DllUnregisterServer();

    // Get the filename for this module.
    if( !WszGetModuleFileName(GetModuleInst(), rcModule, NumItems(rcModule)) ) 
        return E_UNEXPECTED;
        
    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    IfFailGo(GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth));

    // For each item in the coclass list, register it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        // Register the class with default values.
        if (FAILED(hr = REGUTIL::RegisterCOMClass(
                *pCoClass->pClsid, 
                g_szCoclassDesc, 
                g_szProgIDPrefix,
                g_iVersion, 
                pCoClass->szProgID, 
                g_szThreadingModel, 
                rcModule,
                GetModuleInst(),
                NULL,
                rcVersion,
                true,
                false)))
            goto ErrExit;
    }

ErrExit:
    if (FAILED(hr))
        DllUnregisterServer();
    return (hr);
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
STDAPI DllUnregisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    // Initialize some variables so WszXXX will work
    OnUnicodeSystem();

    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
                    g_iVersion, pCoClass->szProgID, true);
    }
    return (S_OK);
}


//*****************************************************************************
// Called by COM to get a class factory for a given CLSID.  If it is one we
// support, instantiate a class factory object and prepare for create instance.
//*****************************************************************************
STDAPI DllGetClassObjectInternal(               // Return code.
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    CClassFactory *pClassFactory;       // To create class factory object.
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    // Scan for the right one.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        if (*pCoClass->pClsid == rclsid)
        {
            // Allocate the new factory object.
            pClassFactory = new CClassFactory(pCoClass);
            if (!pClassFactory)
                return (E_OUTOFMEMORY);
    
            // Pick the v-table based on the caller's request.
            hr = pClassFactory->QueryInterface(riid, ppv);
    
            // Always release the local reference, if QI failed it will be
            // the only one and the object gets freed.
            pClassFactory->Release();
            break;
        }
    }
    return (hr);
}



//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;
    
    // Avoid confusion.
    *ppvObject = NULL;
    
    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;
    
    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;
    
    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);
    
    // Aggregation is not supported by these objects.
    if (pUnkOuter)
        return (CLASS_E_NOAGGREGATION);
    
    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
    BOOL        fLock)
{
//@todo: hook up lock server logic.
    return (S_OK);
}





//*****************************************************************************
// This helper provides access to the instance handle of the loaded image.
//*****************************************************************************
HINSTANCE GetModuleInst()
{
    return g_hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmondll\psapiutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// PSAPIUtil.h - utility to wrap PSAPI.dll
//
//*****************************************************************************

#ifndef _PSAPIUTIL_H_
#define _PSAPIUTIL_H_


//-----------------------------------------------------------------------------
// Manage Connection to Dynamic Loading of PSAPI.dll
// Use this to protect our usage of the dll and manage the global namespace
//-----------------------------------------------------------------------------
class PSAPI_dll
{
public:
	PSAPI_dll();
	~PSAPI_dll();

	bool Load();
	void Free();

	bool IsLoaded();

// Wrap functions from GetProcAddress()
	BOOL WINAPI EnumProcesses(DWORD*, DWORD cb, DWORD*);
	BOOL WINAPI EnumProcessModules(HANDLE, HMODULE*, DWORD, DWORD*);
	DWORD WINAPI GetModuleBaseName(HANDLE, HMODULE, LPTSTR, DWORD nSize);

protected:
// Instance of the PsAPI.dll
	HINSTANCE	m_hInstPSAPI;

// Pointers to the functions we want
	BOOL		(WINAPI * m_pfEnumProcess)(DWORD*, DWORD cb, DWORD*);
	BOOL		(WINAPI * m_pfEnumModules)(HANDLE, HMODULE*, DWORD, DWORD*);
	DWORD		(WINAPI * m_pfGetModuleBaseName)(HANDLE, HMODULE, LPTSTR, DWORD nSize);

// Flag to let us know if it's FULLY loaded
	bool		m_fIsLoaded;

	void*		HelperGetProcAddress(const char * szFuncName);
};

//-----------------------------------------------------------------------------
// inline for function wrappers. Debug versions will assert if the wrapped 
// function pointer is NULL (such as if we can load the DLL, but GetProcAddress() fails).
//-----------------------------------------------------------------------------
inline BOOL WINAPI PSAPI_dll::EnumProcesses(DWORD* pArrayPid, DWORD cb, DWORD* lpcbNeeded)
{
	_ASSERTE(m_pfEnumProcess != NULL);
	return m_pfEnumProcess(pArrayPid, cb, lpcbNeeded);
}

inline BOOL WINAPI PSAPI_dll::EnumProcessModules(HANDLE hProcess, HMODULE* lphModule, DWORD cb, DWORD* lpcbNeeded)
{
	_ASSERTE(m_pfEnumModules != NULL);
	return m_pfEnumModules(hProcess, lphModule, cb, lpcbNeeded);
}

inline DWORD WINAPI PSAPI_dll::GetModuleBaseName(HANDLE hProcess, HMODULE hModule, LPTSTR lpBaseName, DWORD nSize)
{
	_ASSERTE(m_pfGetModuleBaseName != NULL);
    DWORD dwRet = m_pfGetModuleBaseName(hProcess, hModule, lpBaseName, nSize-1);
    _ASSERTE (dwRet <= nSize-1);
    DWORD _curLength = dwRet;
    *(lpBaseName + _curLength) = L'\0';
    while (_curLength)
    {
        _curLength--;
        if (*(lpBaseName+_curLength) == L'.')
        {
            if (((_curLength+1 < dwRet) && (*(lpBaseName+_curLength+1) != L'e')) ||
                ((_curLength+2 < dwRet) && (*(lpBaseName+_curLength+2) != L'x')) ||
                ((_curLength+3 < dwRet) && (*(lpBaseName+_curLength+3) != L'e')))
            {
                break;
            }
            *(lpBaseName+_curLength) = L'\0';
            dwRet = _curLength;
            break;
        }
    }
    return dwRet;
}



#endif // _PSAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmonhelp\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

// Headers for COM+ Perf Counters
#include <WinWrap.h>
#include <windows.h>
#include <stddef.h>
#include <process.h>
#include "UtilCode.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\perfmonhelp\perfmonsymbolsgen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include <stdio.h>
#include <string.h>

#define PERF_COUNTER_SYMBOLS_TABLE() \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Memory_OBJECT , .NET CLR Memory , Counters for CLR Garbage Collected heap.) \
PERF_COUNTER_GEN_FUNC(GEN0_COLLECTIONS_COUNTER , # Gen 0 Collections , This counter displays the number of times the generation 0 objects (youngest; most recently allocated) are garbage collected (Gen 0 GC) since the start of the application. Gen 0 GC occurs when the available memory in generation 0 is not sufficient to satisfy an allocation request. This counter is incremented at the end of a Gen 0 GC. Higher generation GCs include all lower generation GCs. This counter is explicitly incremented when a higher generation (Gen 1 or Gen 2) GC occurs. _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.) \
PERF_COUNTER_GEN_FUNC(GEN1_COLLECTIONS_COUNTER , # Gen 1 Collections , This counter displays the number of times the generation 1 objects are garbage collected since the start of the application. The counter is incremented at the end of a Gen 1 GC. Higher generation GCs include all lower generation GCs. This counter is explicitly incremented when a higher generation (Gen 2) GC occurs. _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.) \
PERF_COUNTER_GEN_FUNC(GEN2_COLLECTIONS_COUNTER , # Gen 2 Collections , This counter displays the number of times the generation 2 objects (older) are garbage collected since the start of the application. The counter is incremented at the end of a Gen 2 GC (also called full GC). _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.) \
PERF_COUNTER_GEN_FUNC(GEN0_BYTES_PROMOTED_COUNTER , Promoted Memory from Gen 0 , This counter displays the bytes of memory that survive garbage collection (GC) and are promoted from generation 0 to generation 1; objects that are promoted just because they are waiting to be finalized are not included in this counter. This counter displays the value observed at the end of the last GC; its not a cumulative counter.) \
PERF_COUNTER_GEN_FUNC(GEN1_BYTES_PROMOTED_COUNTER , Promoted Memory from Gen 1 , This counter displays the bytes of memory that survive garbage collection (GC) and are promoted from generation 1 to generation 2; objects that are promoted just because they are waiting to be finalized are not included in this counter. This counter displays the value observed at the end of the last GC; its not a cumulative counter. This counter is reset to 0 if the last GC was a Gen 0 GC only.) \
PERF_COUNTER_GEN_FUNC(GEN0_PROMOTION_RATE , Gen 0 Promoted Bytes/Sec , This counter displays the bytes per second that are promoted from generation 0 (youngest) to generation 1; objects that are promoted just because they are waiting to be finalized are not included in this counter. Memory is promoted when it survives a garbage collection. This counter was designed as an indicator of relatively long-lived objects being created per sec. This counter displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(GEN1_PROMOTION_RATE , Gen 1 Promoted Bytes/Sec , This counter displays the bytes per second that are promoted from generation 1 to generation 2 (oldest); objects that are promoted just because they are waiting to be finalized are not included in this counter. Memory is promoted when it survives a garbage collection. Nothing is promoted from generation 2 since it is the oldest. This counter was designed as an indicator of very long-lived objects being created per sec. This counter displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER , Promoted Finalization-Memory from Gen 0 , This counter displays the bytes of memory that are promoted from generation 0 to generation 1 just because they are waiting to be finalized. This counter displays the value observed at the end of the last GC; its not a cumulative counter.) \
PERF_COUNTER_GEN_FUNC(GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER , Promoted Finalization-Memory from Gen 1 , This counter displays the bytes of memory that are promoted from generation 1 to generation 2 just because they are waiting to be finalized. This counter displays the value observed at the end of the last GC; its not a cumulative counter. This counter is reset to 0 if the last GC was a Gen 0 GC only.) \
PERF_COUNTER_GEN_FUNC(GEN0_HEAP_SIZE_COUNTER , Gen 0 heap size , This counter displays the maximum bytes that can be allocated in generation 0 (Gen 0); its does not indicate the current number of bytes allocated in Gen 0. A Gen 0 GC is triggered when the allocations since the last GC exceed this size. The Gen 0 size is tuned by the Garbage Collector and can change during the execution of the application. At the end of a Gen 0 collection the size of the Gen 0 heap is infact 0 bytes; this counter displays the size (in bytes) of allocations that would trigger the next Gen 0 GC. This counter is updated at the end of a GC; its not updated on every allocation.) \
PERF_COUNTER_GEN_FUNC(GEN1_HEAP_SIZE_COUNTER , Gen 1 heap size , This counter displays the current number of bytes in generation 1 (Gen 1); this counter does not display the maximum size of Gen 1. Objects are not directly allocated in this generation; they are promoted from previous Gen 0 GCs. This counter is updated at the end of a GC; its not updated on every allocation.) \
PERF_COUNTER_GEN_FUNC(GEN2_HEAP_SIZE_COUNTER , Gen 2 heap size , This counter displays the current number of bytes in generation 2 (Gen 2). Objects are not directly allocated in this generation; they are promoted from Gen 1 during previous Gen 1 GCs. This counter is updated at the end of a GC; its not updated on every allocation.) \
PERF_COUNTER_GEN_FUNC(LARGE_OBJECT_SIZE_COUNTER , Large Object Heap size , This counter displays the current size of the Large Object Heap in bytes. Objects greater than 20 KBytes are treated as large objects by the Garbage Collector and are directly allocated in a special heap; they are not promoted through the generations. This counter is updated at the end of a GC; its not updated on every allocation.) \
PERF_COUNTER_GEN_FUNC(SURVIVE_FINALIZE_COUNTER , Finalization Survivors , This counter displays the number of garbage collected objects that survive a collection because they are waiting to be finalized. If these objects hold references to other objects then those objects also survive but are not counted by this counter; the "Promoted Finalization-Memory from Gen 0" and "Promoted Finalization-Memory from Gen 1" counters represent all the memory that survived due to finalization. This counter is not a cumulative counter; its updated at the end of every GC with count of the survivors during that particular GC only. This counter was designed to indicate the extra overhead that the application might incur because of finalization.) \
PERF_COUNTER_GEN_FUNC(NUM_HANDLES_COUNTER , # GC Handles , This counter displays the current number of GC Handles in use. GCHandles are handles to resources external to the CLR and the managed environment. Handles occupy small amounts of memory in the GCHeap but potentially expensive unmanaged resources.) \
PERF_COUNTER_GEN_FUNC(ALLOCATION_RATE_COUNTER , Allocated Bytes/sec , This counter displays the rate of bytes per second allocated on the GC Heap. This counter is updated at the end of every GC; not at each allocation. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(INDUCED_GC_COUNTER , # Induced GC , This counter displays the peak number of times a garbage collection was performed because of an explicit call to GC.Collect. Its a good practice to let the GC tune the frequency of its collections.) \
PERF_COUNTER_GEN_FUNC(PER_TIME_IN_GC_COUNTER , % Time in GC , % Time in GC is the percentage of elapsed time that was spent in performing a garbage collection (GC) since the last GC cycle. This counter is usually an indicator of the work done by the Garbage Collector on behalf of the application to collect and compact memory. This counter is updated only at the end of every GC and the counter value reflects the last observed value; its not an average.) \
PERF_COUNTER_GEN_FUNC(PER_TIME_IN_GC_COUNTER_BASE , Not Displayed , Not Displayed.) \
PERF_COUNTER_GEN_FUNC(TOTAL_HEAP_SIZE_COUNTER , # Bytes in all Heaps , This counter is the sum of four other counters; Gen 0 Heap Size; Gen 1 Heap Size; Gen 2 Heap Size and the Large Object Heap Size. This counter indicates the current memory allocated in bytes on the GC Heaps.) \
PERF_COUNTER_GEN_FUNC(TOTAL_COMMITTED_MEM_COUNTER , # Total committed Bytes , This counter displays the amount of virtual memory (in bytes) currently committed by the Garbage Collector. (Committed memory is the physical memory for which space has been reserved on the disk paging file). ) \
PERF_COUNTER_GEN_FUNC(TOTAL_RESERVED_MEM_COUNTER , # Total reserved Bytes , This counter displays the amount of virtual memory (in bytes) currently reserved by the Garbage Collector. (Reserved memory is the virtual memory space reserved for the application but no disk or main memory pages have been used.) ) \
PERF_COUNTER_GEN_FUNC(GC_PINNED_OBJECTS , # of Pinned Objects , This counter displays the number of pinned objects encountered in the last GC. This counter tracks the pinned objects only in the heaps that were garbage collected e.g. a Gen 0 GC would cause enumeration of pinned objects in the generation 0 heap only. A pinned object is one that the Garbage Collector cannot move in memory.) \
PERF_COUNTER_GEN_FUNC(GC_SINKBLOCKS , # of Sink Blocks in use , This counter displays the current number of sync blocks in use. Sync blocks are per-object data structures allocated for storing synchronization information. Sync blocks hold weak references to managed objects and need to be scanned by the Garbage Collector. Sync blocks are not limited to storing synchronization information and can also store COM interop metadata. This counter was designed to indicate performance problems with heavy use of synchronization primitives.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Loading_OBJECT , .NET CLR Loading , Statistics for CLR Class Loader.) \
PERF_COUNTER_GEN_FUNC(LOADING_CLASSES_TOTAL , Total Classes Loaded , This counter displays the cumulative number of classes loaded in all Assemblies since the start of this application.) \
PERF_COUNTER_GEN_FUNC(LOADING_TIME , % Time Loading , Reserved for future use.) \
PERF_COUNTER_GEN_FUNC(LOADING_ASMSEARCHLEN , Assembly Search Length , Reserved for future use.) \
PERF_COUNTER_GEN_FUNC(LOADING_LOADFAILURES_TOTAL , Total # of Load Failures , This counter displays the peak number of classes that have failed to load since the start of the application. These load failures could be due to many reasons like inadequate security or illegal format. Full details can be found in the profiling services help.) \
PERF_COUNTER_GEN_FUNC(LOADING_LOADFAILURES_INST , Rate of Load Failures , This counter displays the number of classes that failed to load per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval. These load failures could be due to many reasons like inadequate security or illegal format. Full details can be found in the profiling services help.) \
PERF_COUNTER_GEN_FUNC(LOADING_HEAPSIZE , Bytes in Loader Heap , This counter displays the current size (in bytes) of the memory committed by the class loader across all AppDomains. (Committed memory is the physical memory for which space has been reserved on the disk paging file.)) \
PERF_COUNTER_GEN_FUNC(LOADING_APPDOMAINS_UNLOADED_TOTAL , Total appdomains unloaded , This counter displays the total number of AppDomains unloaded since the start of the application. If an AppDomain is loaded and unloaded multiple times this counter would count each of those unloads as separate.) \
PERF_COUNTER_GEN_FUNC(LOADING_APPDOMAINS_UNLOADED_INST , Rate of appdomains unloaded ,  This counter displays the number of AppDomains unloaded per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(LOADING_CLASSES_CUR , Current Classes Loaded , This counter displays the current number of classes loaded in all Assemblies.) \
PERF_COUNTER_GEN_FUNC(LOADING_CLASSES_INST , Rate of Classes Loaded ,  This counter displays the number of classes loaded per second in all Assemblies. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(LOADING_APPDOMAINS_CUR , Current appdomains , This counter displays the current number of AppDomains loaded in this application. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process.) \
PERF_COUNTER_GEN_FUNC(LOADING_APPDOMAINS_TOTAL , Total Appdomains , This counter displays the peak number of AppDomains loaded since the start of this application. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process.) \
PERF_COUNTER_GEN_FUNC(LOADING_APPDOMAINS_INST , Rate of appdomains ,  This counter displays the number of AppDomains loaded per second. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(LOADING_ASSEMBLIES_CUR , Current Assemblies , This counter displays the current number of Assemblies loaded across all AppDomains in this application. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain.) \
PERF_COUNTER_GEN_FUNC(LOADING_ASSEMBLIES_TOTAL , Total Assemblies ,  This counter displays the total number of Assemblies loaded since the start of this application. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain.) \
PERF_COUNTER_GEN_FUNC(LOADING_ASSEMBLIES_INST , Rate of Assemblies ,  This counter displays the number of Assemblies loaded across all AppDomains per second. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Jit_OBJECT , .NET CLR Jit , Stats for CLR Jit.) \
PERF_COUNTER_GEN_FUNC(TOTAL_METHODS_JITTED , # of Methods Jitted  , This counter displays the total number of methods compiled Just-In-Time (JIT) by the CLR JIT compiler since the start of the application. This counter does not include the pre-jitted methods.) \
PERF_COUNTER_GEN_FUNC(JITTED_IL_CUR , # of IL Bytes Jitted , This counter displays the total IL bytes jitted since the start of the application. This counter is exactly equivalent to the "Total # of IL Bytes Jitted" counter.) \
PERF_COUNTER_GEN_FUNC(JITTED_IL_TOTAL , Total # of IL Bytes Jitted , This counter displays the total IL bytes jitted since the start of the application.  This counter is exactly equivalent to the "# of IL Bytes Jitted" counter.) \
PERF_COUNTER_GEN_FUNC(JITTED_IL_INST , IL Bytes Jitted / sec , This counter displays the rate at which IL bytes are jitted per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(JIT_FAILURES , Standard Jit Failures , This counter displays the peak number of methods the JIT compiler has failed to JIT since the start of the application. This failure can occur if the IL cannot be verified or if there was an internal error in the JIT compiler.) \
PERF_COUNTER_GEN_FUNC(TIME_IN_JIT , % Time in Jit , This counter displays the percentage of elapsed time spent in JIT compilation since the last JIT compilation phase. This counter is updated at the end of every JIT compilation phase. A JIT compilation phase is the phase when a method and its dependencies are being compiled.) \
PERF_COUNTER_GEN_FUNC(TIME_IN_JIT_BASE , Not Displayed , Not Displayed.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Interop_OBJECT , .NET CLR Interop , Stats for CLR interop.) \
PERF_COUNTER_GEN_FUNC(CURRENT_CCW , # of CCWs , This counter displays the current number of Com-Callable-Wrappers (CCWs). A CCW is a proxy for the .NET managed object being referenced from unmanaged COM client(s). This counter was designed to indicate the number of managed objects being referenced by unmanaged COM code.) \
PERF_COUNTER_GEN_FUNC(CURRENT_STUBS , # of Stubs , This counter displays the current number of stubs created by the CLR. Stubs are responsible for marshalling arguments and return values from managed to unmanaged code and vice versa; during a COM Interop call or PInvoke call.) \
PERF_COUNTER_GEN_FUNC(NUM_MARSHALLING , # of marshalling , This counter displays the total number of times arguments and return values have been marshaled from managed to unmanaged code and vice versa since the start of the application. This counter is not incremented if the stubs are inlined. (Stubs are responsible for marshalling arguments and return values). Stubs usually get inlined if the marshalling overhead is small.) \
PERF_COUNTER_GEN_FUNC(TOTAL_TLB_IMPORTS , # of TLB imports / sec , Reserved for future use.) \
PERF_COUNTER_GEN_FUNC(TOTAL_TLB_EXPORTS , # of TLB exports / sec , Reserved for future use.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_LocksAndThreads_OBJECT , .NET CLR LocksAndThreads , Stats for CLR Locks and Threads.) \
PERF_COUNTER_GEN_FUNC(CONTENTION_TOTAL , Total # of Contentions , This counter displays the total number of times threads in the CLR have attempted to acquire a managed lock unsuccessfully. Managed locks can be acquired in many ways; by the "lock" statement in C# or by calling System.Monitor.Enter or by using MethodImplOptions.Synchronized custom attribute.) \
PERF_COUNTER_GEN_FUNC(CONTENTION_INST , Contention Rate / sec, Rate at which threads in the runtime attempt to acquire a managed lock unsuccessfully. Managed locks can be acquired in many ways; by the "lock" statement in C# or by calling System.Monitor.Enter or by using MethodImplOptions.Synchronized custom attribute.) \
PERF_COUNTER_GEN_FUNC(QUEUE_LENGTH_CUR , Current Queue Length , This counter displays the total number of threads currently waiting to acquire some managed lock in the application. This counter is not an average over time; it displays the last observed value.) \
PERF_COUNTER_GEN_FUNC(QUEUE_LENGTH_TOTAL , Queue Length Peak, This counter displays the total number of threads that waited to acquire some managed lock since the start of the application.) \
PERF_COUNTER_GEN_FUNC(QUEUE_LENGTH_INST , Queue Length / sec , This counter displays the number of threads per second waiting to acquire some lock in the application. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(CURRENT_LOGICAL_THREADS , # of current logical Threads , This counter displays the number of current .NET thread objects in the application. A .NET thread object is created either by new System.Threading.Thread or when an unmanaged thread enters the managed environment. This counters maintains the count of both running and stopped threads. This counter is not an average over time; it just displays the last observed value.) \
PERF_COUNTER_GEN_FUNC(CURRENT_PHYSICAL_THREADS , # of current physical Threads , This counter displays the number of native OS threads created and owned by the CLR to act as underlying threads for .NET thread objects. This counters value does not include the threads used by the CLR in its internal operations; it is a subset of the threads in the OS process.) \
PERF_COUNTER_GEN_FUNC(RECOGNIZED_THREADS_CUR , # of current recognized threads , This counter displays the number of threads that are currently recognized by the CLR; they have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice.) \
PERF_COUNTER_GEN_FUNC(RECOGNIZED_THREADS_TOTAL , # of total recognized threads , This counter displays the total number of threads that have been recognized by the CLR since the start of this application; these threads have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice.) \
PERF_COUNTER_GEN_FUNC(RECOGNIZED_THREADS_INST , rate of recognized threads / sec , This counter displays the number of threads per second that have been recognized by the CLR; these threads have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Security_OBJECT , .NET CLR Security , Stats for CLR Security.) \
PERF_COUNTER_GEN_FUNC(SECURITY_TOTALRTCHECKS , Total Runtime Checks , This counter displays the total number of runtime Code Access Security (CAS) checks performed since the start of the application. Runtime CAS checks are performed when a caller makes a call to a callee demanding a particular permission; the runtime check is made on every call by the caller; the check is done by examining the current thread stack of the caller. This counter used together with "Stack Walk Depth" is indicative of performance penalty for security checks.) \
PERF_COUNTER_GEN_FUNC(SECURITY_TIMEAUTHORIZE , % Time Sig. Authenticating ,  Reserved for future use.) \
PERF_COUNTER_GEN_FUNC(SECURITY_LINKCHECKS , # Link Time Checks , This counter displays the total number of linktime Code Access Security (CAS) checks since the start of the application. Linktime CAS checks are performed when a caller makes a call to a callee demanding a particular permission at JIT compile time; linktime check is performed once per caller. This count is not indicative of serious performance issues; its indicative of the security system activity.) \
PERF_COUNTER_GEN_FUNC(SECURITY_TIMERTCHECKS , % Time in RT checks , This counter displays the percentage of elapsed time spent in performing runtime Code Access Security (CAS) checks since the last such check. CAS allows code to be trusted to varying degrees and enforces these varying levels of trust depending on code identity. This counter is updated at the end of a runtime security check; it represents the last observed value; its not an average.) \
PERF_COUNTER_GEN_FUNC(SECURITY_TIMERTCHECKS_BASE , Not Displayed , Not Displayed.) \
PERF_COUNTER_GEN_FUNC(SECURITY_DEPTHSECURITY , Stack Walk Depth , This counter displays the depth of the stack during that last runtime Code Access Security check. Runtime Code Access Security check is performed by crawling the stack. This counter is not an average; it just displays the last observed value.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Remoting_OBJECT , .NET CLR Remoting , Stats for CLR Remoting.) \
PERF_COUNTER_GEN_FUNC(CONTEXT_REMOTECALLS_INST , Remote Calls/sec , This counter displays the number of remote procedure calls invoked per second. A remote procedure call is a call on any object outside the caller;s AppDomain. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(CONTEXT_CHANNELS , Channels , This counter displays the total number of remoting channels registered across all AppDomains since the start of the application. Channels are used to transport messages to and from remote objects.) \
PERF_COUNTER_GEN_FUNC(CONTEXT_PROXIES , Context Proxies , This counter displays the total number of remoting proxy objects created in this process since the start of the process. Proxy object acts as a representative of the remote objects and ensures that all calls made on the proxy are forwarded to the correct remote object instance.) \
PERF_COUNTER_GEN_FUNC(CONTEXT_CLASSES , Context-Bound Classes Loaded , This counter displays the current number of context-bound classes loaded. Classes that can be bound to a context are called context-bound classes; context-bound classes are marked with Context Attributes which provide usage rules for synchronization; thread affinity; transactions etc. ) \
PERF_COUNTER_GEN_FUNC(CONTEXT_OBJALLOC , Context-Bound Objects Alloc / sec , This counter displays the number of context-bound objects allocated per second. Instances of classes that can be bound to a context are called context-bound objects; context-bound classes are marked with Context Attributes which provide usage rules for synchronization; thread affinity; transactions etc. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(CONTEXT_CONTEXTS , Contexts , This counter displays the current number of remoting contexts in the application. A context is a boundary containing a collection of objects with the same usage rules like synchronization; thread affinity; transactions etc.) \
PERF_COUNTER_GEN_FUNC(CONTEXT_REMOTECALLS_TOTAL , Total Remote Calls , This counter displays the total number of remote procedure calls invoked since the start of this application. A remote procedure call is a call on any object outside the caller;s AppDomain.) \
PERF_COUNTER_GEN_FUNC_OBJECT(DotNetCLR_Excep_OBJECT , .NET CLR Exceptions , Runtime statistics on CLR exception handling.) \
PERF_COUNTER_GEN_FUNC(EXCEP_THROWN_TOTAL , # of Exceps Thrown, This counter displays the total number of exceptions thrown since the start of the application. These include both .NET exceptions and unmanaged exceptions that get converted into .NET exceptions e.g. null pointer reference exception in unmanaged code would get re-thrown in managed code as a .NET System.NullReferenceException; this counter includes both handled and unhandled exceptions. Exceptions that are re-thrown would get counted again. Exceptions should only occur in rare situations and not in the normal control flow of the program.) \
PERF_COUNTER_GEN_FUNC(EXCEP_THROWN_INST , # of Exceps Thrown / sec , This counter displays the number of exceptions thrown per second. These include both .NET exceptions and unmanaged exceptions that get converted into .NET exceptions e.g. null pointer reference exception in unmanaged code would get re-thrown in managed code as a .NET System.NullReferenceException; this counter includes both handled and unhandled exceptions. Exceptions should only occur in rare situations and not in the normal control flow of the program; this counter was designed as an indicator of potential performance problems due to large (>100s) rate of exceptions thrown. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(TOTAL_EXCEP_FILTERS_RUN , # of Filters / sec , This counter displays the number of .NET exception filters executed per second. An exception filter evaluates whether an exception should be handled or not. This counter tracks the rate of exception filters evaluated; irrespective of whether the exception was handled or not. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(TOTAL_EXCEP_FINALLYS_RUN , # of Finallys / sec , This counter displays the number of finally blocks executed per second. A finally block is guaranteed to be executed regardless of how the try block was exited. Only the finally blocks that are executed for an exception are counted; finally blocks on normal code paths are not counted by this counter. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.) \
PERF_COUNTER_GEN_FUNC(EXCEPT_STACK_DEPTH , Throw To Catch Depth / sec , This counter displays the number of stack frames traversed from the frame that threw the .NET exception to the frame that handled the exception per second. This counter resets to 0 when an exception handler is entered; so nested exceptions would show the handler to handler stack depth. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.)

int g_CounterCount = 0;

void GenHeader(char *counter)
{
    printf("#define %-50s %d\n" , counter , g_CounterCount);
    g_CounterCount += 2;
}

void GenIni(char *language, char *counter , char *name , char *help)
{
    printf("%s_%s_NAME=%s\n" , counter, language, name);
    printf("%s_%s_HELP=%s\n" , counter, language, help);
    printf("\n");
}

void GenObjectName(char * language, char *counter , char *name , char *help)
{
    printf("%s_%s_NAME=%s\n" , counter , language, name);
}

void __cdecl main(int argc , char **argv)
{
    bool fGenIni = false;
    bool fGenHdr = false;

    if (argc != 2)
        goto Usage;

    if (strcmp (argv[1] , "ini") == 0)
        fGenIni = true;
    else if (strcmp (argv[1] , "h") == 0)
        fGenHdr = true;
    else
        goto Usage;
    
    if (fGenHdr)
    {
        printf("// ==++==\n");
        printf("// \n");
        printf("//   Copyright (c) Microsoft Corporation.  All rights reserved.\n");
        printf("// \n");
        printf("// ==--==\n");
        printf("//------------------------------------------------------------------------ \n");
        printf("// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING \n");
        printf("//\n");
        printf("//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp \n");
        printf("//\n");
        printf("// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING \n");
        printf("//------------------------------------------------------------------------ \n");
    
#undef PERF_COUNTER_GEN_FUNC
#define PERF_COUNTER_GEN_FUNC(counter , name , help) \
GenHeader(#counter);
#undef PERF_COUNTER_GEN_FUNC_OBJECT
#define PERF_COUNTER_GEN_FUNC_OBJECT(counter , name , help) \
GenHeader(#counter);
    
        PERF_COUNTER_SYMBOLS_TABLE();
    }

    if (fGenIni)
    {
        printf("; ==++==\n");
        printf("; \n");
        printf(";   Copyright (c) Microsoft Corporation.  All rights reserved.\n");
        printf("; \n");
        printf("; ==--==\n");
        printf("//------------------------------------------------------------------------ \n");
        printf("// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING \n");
        printf("//\n");
        printf("//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp \n");
        printf("//\n");
        printf("// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING \n");
        printf("//------------------------------------------------------------------------ \n");
    
        printf("\n");
        printf("// CORPerfMonSymbols.ini file\n");
        printf("[info]\n");
        printf("drivername=.NETFramework\n");
        printf("symbolfile=CORPerfMonSymbols.h\n");
        printf("\n");
        printf("[languages]\n");
        printf("009=English\n");
        printf("000=Neutral\n");
        printf("; 001=Arabic\n");
        printf("; 004=Chinese\n");
        printf("; 007=German\n");
        printf("; 00D=Hebrew\n");
        printf("; 011=Japanese\n");
        printf("; 012=Korean\n");
        printf("; 00A=Spanish\n");
        printf("; 00C=French\n");
        printf("; 010=Italian\n");
        printf("\n");
    
        printf("[objects]\n");

        // Generate object names for US English counters
#undef PERF_COUNTER_GEN_FUNC
#define PERF_COUNTER_GEN_FUNC(counter , name , help)

#undef PERF_COUNTER_GEN_FUNC_OBJECT
#define PERF_COUNTER_GEN_FUNC_OBJECT(counter , name , help) \
GenObjectName("009", #counter , #name , #help);

        PERF_COUNTER_SYMBOLS_TABLE();

        // Generate object names for Neutral counters
#undef PERF_COUNTER_GEN_FUNC
#define PERF_COUNTER_GEN_FUNC(counter , name , help)

#undef PERF_COUNTER_GEN_FUNC_OBJECT
#define PERF_COUNTER_GEN_FUNC_OBJECT(counter , name , help) \
GenObjectName("000", #counter , #name , #help);

        PERF_COUNTER_SYMBOLS_TABLE();
        
        printf("\n");
        
        printf("[text]\n");
    
        // Generate counter name and help text for US English counters
#undef PERF_COUNTER_GEN_FUNC
#define PERF_COUNTER_GEN_FUNC(counter , name , help) \
GenIni("009", #counter , #name , #help);
#undef PERF_COUNTER_GEN_FUNC_OBJECT
#define PERF_COUNTER_GEN_FUNC_OBJECT(counter , name , help) \
GenIni("009", #counter , #name , #help);
    
        PERF_COUNTER_SYMBOLS_TABLE();

        // Generate counter name and help text for Neutral counters
#undef PERF_COUNTER_GEN_FUNC
#define PERF_COUNTER_GEN_FUNC(counter , name , help) \
GenIni("000", #counter , #name , #help);
#undef PERF_COUNTER_GEN_FUNC_OBJECT
#define PERF_COUNTER_GEN_FUNC_OBJECT(counter , name , help) \
GenIni("000", #counter , #name , #help);
    
        PERF_COUNTER_SYMBOLS_TABLE();
    }

    return;

Usage:
    printf("Usage: %s [ini|h]\n" , argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\profiler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "StdAfx.h"
#include "Profiler.h"

//*****************************************************************************
// A printf method which can figure out where output goes.
//*****************************************************************************
int __cdecl Printf(						// cch
	const char *szFmt,					// Format control string.
	...)								// Data.
{
	static HANDLE hOutput = INVALID_HANDLE_VALUE;
    va_list     marker;                 // User text.
	char		rcMsg[1024];			// Buffer for format.

	// Get standard output handle.
	if (hOutput == INVALID_HANDLE_VALUE)
	{
		hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
		if (hOutput == INVALID_HANDLE_VALUE)
			return (-1);
	}

	// Format the error.
	va_start(marker, szFmt);
	_vsnprintf(rcMsg, sizeof(rcMsg), szFmt, marker);
	rcMsg[sizeof(rcMsg) - 1] = 0;
	va_end(marker);
	
	ULONG cb;
	int iLen = strlen(rcMsg);
	WriteFile(hOutput, rcMsg, iLen, &cb, 0);
	return (iLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdio.h>

#include <Windows.h>
#include <cor.h>
#include <CorError.h>
#include <crtdbg.h>

#include <utilcode.h>

#include "corprof.h"

#define COM_METHOD HRESULT STDMETHODCALLTYPE

#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\corbuffer.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorBuffer
//
// Implementation of COR MIME filter
//
//*****************************************************************************
#ifndef _CORBUFFER_H
#define _CORBUFFER_H

#include "CorPermE.h"

// this is a cheezy buffer manager that uses an inlined memory cache, it really
// should be based on VMalloc
#define CORFLTR_BLOCK  8096 

class CorBuffer 
{
private:
    PBYTE buffer;

    DWORD end;
    DWORD start;
    DWORD space;

public:
    CorBuffer() :
        buffer(NULL),
        end(0),
        start(0),
        space(0)
        {}

    ~CorBuffer() 
        {
            if(buffer) FreeM(buffer);
        }

    PBYTE GetEnd()
        {
            return buffer+end;
        }

    void AddToEnd(DWORD lgth)
        {
            _ASSERTE(space >= lgth);
            end += lgth;
            space -= lgth;
        }

    PBYTE GetBuffer()
        {
            return buffer;
        }

    DWORD GetAvailable()
        {
            return end - start;
        }

    DWORD GetSpace()
        {
            return space;
        }
    void Reset()
        {
            space = end + space;
            end = 0;
            start = 0;
        }

    HRESULT Expand(DWORD required)
        {
            if(space < required) {
                DWORD add = required <= CORFLTR_BLOCK ? CORFLTR_BLOCK : required + CORFLTR_BLOCK;
            
                PBYTE ptr = (PBYTE) MallocM(end + space + add);
                if(ptr == NULL) return E_OUTOFMEMORY;

                if(buffer) {
                    memcpy(ptr, buffer, end);
                    FreeM(buffer);
                }
                buffer = ptr;
                space += add;
            }
            return S_OK;
        }
                    
    HRESULT Write(PBYTE pString, DWORD lgth) 
        {
            HRESULT hr = Expand(lgth);
            if(FAILED(hr)) return hr;

            _ASSERTE(space >= lgth);
            memcpy(buffer+end, pString, lgth);
            end += lgth;
            _ASSERTE(lgth <= space);

            space -= lgth;
            _ASSERTE(space >= 0);

            return S_OK;
        }

    HRESULT Read(PBYTE pString, DWORD lgth, DWORD* pRead)
        {
            DWORD available = GetAvailable();
            DWORD count = lgth < available ? lgth : available;
            if(pRead == NULL) return E_INVALIDARG;

            memcpy(pString, buffer+start, count);
            start += count;
            _ASSERTE(start <= end);
            *pRead = count;
            return S_OK;
        }

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\coriesecurefactory.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorIESecureFactory
//
// Implementation of COR MIME filter
//
//*****************************************************************************
#ifndef _CORIESecureFactory_H
#define _CORIESecureFactory_H

#include "cunknown.h"
#include "IIEHost.h"


class CorIESecureFactory : public CUnknown,
                           public IClassFactory3
{
    class Crst
    {
        CRITICAL_SECTION cr;
    public:
        Crst(){InitializeCriticalSection(&cr);};
        ~Crst(){DeleteCriticalSection(&cr);};
        void Enter(){EnterCriticalSection(&cr);};
        void Leave(){LeaveCriticalSection(&cr);};
    };
public:
    // Declare the delegating IUnknown.
    DECLARE_IUNKNOWN

private:
    // Notify derived classes that we are releasing.
    virtual void FinalRelease() ;

    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE
        NondelegatingQueryInterface( const IID& iid, void** ppv) ;          

    HRESULT InitializeSecurityManager()
    {
        HRESULT hr = S_OK;
        if(m_pSecurityManager == NULL) {
            hr = CoInternetCreateSecurityManager(NULL,
                                                 &m_pSecurityManager,
                                                 0);
        }
        return hr;
    }

    HRESULT InitializeComplus(LPWSTR wszConfig);

    inline HRESULT DupWStr(LPWSTR& Dest,LPCWSTR Src)
    {
        if (Dest)
            delete[] Dest;
        Dest=NULL;
        if(Src)
        {
            Dest=new WCHAR[wcslen(Src)+1];
            if (!Dest)
                return E_OUTOFMEMORY;
            wcscpy(Dest,Src);
        }
        return S_OK;
    }



    HRESULT SetComplusFactory(ISecureIEFactory* punk)
    {
        if(m_pCorFactory != NULL) {
            m_pCorFactory->Release();
        }
        m_pCorFactory = punk;
        if(m_pCorFactory)
            m_pCorFactory->AddRef();

        return S_OK;
    }

    bool m_bNoRealObject;
    
public:

    HRESULT SetURLData (int dwIdentityFlags,
                        int dwZone,
                        LPWSTR lpSite,
                        LPWSTR pbSecurityId,
                        LPWSTR pbHash,
                        LPWSTR className,
                        LPWSTR fileName)
    {
        m_dwIdentityFlags = dwIdentityFlags;
        m_dwZone = dwZone;
        HRESULT hr = S_OK;
        hr= (FAILED(hr)) ? hr : DupWStr(m_wszSite, lpSite);
        hr= (FAILED(hr)) ? hr : DupWStr(m_wszSecurityId, pbSecurityId);
        hr= (FAILED(hr)) ? hr : DupWStr(m_wszHash, pbHash);
        hr= (FAILED(hr)) ? hr : DupWStr(m_wszClassName, className);
        hr= (FAILED(hr)) ? hr : DupWStr(m_wszFileName, fileName);
        return hr;
    }

    HRESULT DoNotCreateRealObject()
    {
        m_bNoRealObject=TRUE;
        return S_OK;
    }

    CorIESecureFactory(IUnknown* pUnknownOut = NULL) :
        CUnknown(pUnknownOut)
    {
        m_pSecurityManager = NULL;
        m_pCorFactory = NULL;
        m_dwIEHostUsed = 0;
        m_wszSite=NULL;
        m_wszSecurityId=NULL;
        m_wszHash = NULL;
        m_wszClassName=NULL;
        m_wszFileName=NULL;
        m_bNoRealObject=FALSE;
    }

    ~CorIESecureFactory()
    {
        SetURLData( 0, 0, NULL, NULL, NULL, NULL, NULL);
    }


#define ToHex(val) val <= 9 ? val + '0': val - 10 + 'A'
    static DWORD ConvertToHex(WCHAR* strForm, BYTE* byteForm, DWORD dwSize)
    {
        DWORD i = 0;
        DWORD j = 0;
        for(i = 0; i < dwSize; i++) {
            strForm[j++] =  ToHex((0xf & byteForm[i]));
            strForm[j++] =  ToHex((0xf & (byteForm[i] >> 4)));
        }
        strForm[j] = L'\0';
        return j;
    }

    static HRESULT GetHostSecurityManager(LPUNKNOWN punkContext, 
                                          IInternetHostSecurityManager **pihsm);

    virtual HRESULT STDMETHODCALLTYPE
    CreateInstanceWithContext(/* [in] */ IUnknown *punkContext, 
                              /* [in] */ IUnknown *punkOuter, 
                              /* [in] */ REFIID riid, 
                              /* [retval][out] */ IUnknown **ppv);
    
    virtual HRESULT STDMETHODCALLTYPE
    CreateInstance(/* [in, unique] */        IUnknown * pUnkOuter,
                   /* [in]         */        REFIID riid,
                   /* [out, iid_is(riid)] */ void **ppvObject)
    {
        *ppvObject = NULL;
        return E_NOTIMPL;
    }
    
    virtual HRESULT STDMETHODCALLTYPE
    LockServer(BOOL fLock)
    {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE
    RemoteCreateInstance(REFIID riid, IUnknown** ppvObject)
    {
        *ppvObject = NULL;
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE
    RemoteLockServer(BOOL fLock)
    {
        return E_NOTIMPL;
    }


    static HRESULT Create(IUnknown* punk, CorIESecureFactory** pHndler)
    {
        if(pHndler == NULL) return E_POINTER;

        HRESULT hr = NOERROR;
        *pHndler = new CorIESecureFactory(punk);
        if (*pHndler == NULL) {
            hr = E_OUTOFMEMORY;
        }
        
        return hr;
    }

private:    
    static IIEHostEx* m_pComplus;
    static Crst m_ComplusLock;
    DWORD  m_dwIEHostUsed;
    IInternetSecurityManager *m_pSecurityManager;
    ISecureIEFactory *m_pCorFactory;
    int m_dwIdentityFlags;
    int m_dwZone;
    LPWSTR m_wszSite;
    LPWSTR m_wszSecurityId;
    LPWSTR m_wszHash;
    LPWSTR m_wszClassName;
    LPWSTR m_wszFileName;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mscorprf.dll"
#define VER_FILEDESCRIPTION_STR "Common Language Runtime profiler dll\0"
#define VER_ORIGFILENAME_STR    "mscorprf.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\corfltr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       CorFltr.cpp
//
//  Contents:   Complus filter
//
//  Classes:
//
//  Functions: 
//
//  History:    
//
//----------------------------------------------------------------------------

#include "stdpch.h" 
#ifdef _DEBUG
#define LOGGING
#endif
#include "log.h"
#include "corfltr.h"
#include "CorPermE.h"
#include "util.h"
#include "coriesecurefactory.hpp"
#include "Shlwapi.h"

#define REG_BSCB_HOLDER  OLESTR("_BSCB_Holder_") // urlmon/inc/urlint.h
WCHAR g_wszApplicationComplus[] = L"application/x-complus";

static HRESULT GetObjectParam(IBindCtx *pbc, LPOLESTR pszKey, REFIID riid, IUnknown **ppUnk);


inline BOOL IE5()
{
    static int v=-1;
    if (v==-1)
    {
        HKEY hIE=NULL;
        if (WszRegOpenKeyEx(HKEY_LOCAL_MACHINE,L"SOFTWARE\\Microsoft\\Internet Explorer",0, KEY_READ,&hIE)==ERROR_SUCCESS)
        {
            WCHAR ver[32];
            DWORD L=sizeof(ver);
            DWORD type=REG_SZ;
            if (WszRegQueryValueEx(hIE,L"Version",0,
                &type,LPBYTE(ver),&L)==ERROR_SUCCESS)
            {
                v=_wtoi(ver);
            }
            RegCloseKey(hIE);
        }
    }
    return (v<=5);
}

static bool IsOldWay()
{
    static int w=-1;
    if (w==-1)
    {
        HKEY hMime;
        w=WszRegOpenKeyEx(HKEY_CLASSES_ROOT,L"MIME\\Database\\Content type\\application/x-complus",0,
                      KEY_READ,&hMime);
        if (w==ERROR_SUCCESS)
            RegCloseKey(hMime);
    }
    return (IE5()||w!=ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::NondelegatingQueryInterface
//
//  Arguments:  [riid] -- requested REFIID
//              [ppvObj] -- variable to return object
//
//  Returns:    requested interface
//
//  History: 
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::NondelegatingQueryInterface(REFIID riid, void **ppvObj)
{
    
    if(ppvObj == NULL)
        return E_INVALIDARG;

    _ASSERTE(this);

    HRESULT hr = S_OK;

    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::NondelegatingQueryInterface "));

    *ppvObj = NULL;

    if (riid == IID_IOInetProtocol) 
        hr = FinishQI((IOInetProtocol *) this, ppvObj);
    else if (riid == IID_IOInetProtocolSink)
        hr = FinishQI((IOInetProtocolSink *) this, ppvObj);
//     else if (riid == IID_IOInetProtocolSinkStackable)
//         hr = FinishQI((IOInetProtocolSinkStackable *) this, ppvObj);
    else if (riid == IID_IServiceProvider)
        hr = FinishQI((IServiceProvider *) this, ppvObj);
    else
        hr =  CUnknown::NondelegatingQueryInterface(riid, ppvObj) ;
    

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::NondelegatingQueryInterface\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CorFltr::FinalRelease
//
//  Synopsis: basically a destructor
//
//  Arguments: N/A
//
//  Returns: N/A
//
//  History: 
//
//  Notes: called by Release before it deletes the component
//
//----------------------------------------------------------------------------
void CorFltr::FinalRelease(void)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::FinalRelease "));
    _snif=S_FALSE;
    // Release our protocal sink
    SetProtocol(NULL);
    SetProtocolSink(NULL);
    SetIOInetBindInfo(NULL);
    SetServiceProvider(NULL);
    SetBindStatusCallback(NULL);
    SetBindCtx(NULL);
    SetCodeProcessor(NULL);

    // Increments ref to prevent recursion
    CUnknown::FinalRelease() ;

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::FinalRelease\n"));
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Start
//
//  Synopsis: basically a constructor
//
//  Arguments:  [pwzUrl] -- File requested
//              [pOInetProtSnk] -- Interface to potocol sink
//              [pOIBindInfo] -- interface to Bind info
//              [grfSTI] -- requested access to file
//              [dwReserved] -- just that
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Start(LPCWSTR pwzUrl, 
                            IOInetProtocolSink *pOInetProtSnk, 
                            IOInetBindInfo *pOIBindInfo,
                            DWORD grfSTI,
#ifdef _WIN64
                            HANDLE_PTR dwReserved)
#else // !_WIN64
                            DWORD dwReserved)
#endif // _WIN64
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Start "));
    _snif = S_FALSE;
    HRESULT hr = S_OK;

    _ASSERTE(pOIBindInfo && pOInetProtSnk && pwzUrl && dwReserved);

            
    // Save off the url, it will have our parameters if it is complus
    ULONG cEl = 0;
    ULONG cElFetched = 0;
    SetUrl(NULL);
    LPOLESTR __url=NULL; // should we release it and if yes, how?
    if (FAILED(pOIBindInfo->GetBindString(BINDSTRING_URL, &__url, cEl, &cElFetched)))
        __url=NULL;
    if (IsSafeURL(__url))
        SetUrl(__url);
    else
        SetUrl(NULL); //we don't want the file
    
    if (__url)
    {
        CoTaskMemFree(__url);
        __url=NULL;
    }
    // Save off the bind info, this can be passed on to a code processor.
    SetIOInetBindInfo(pOIBindInfo);

    // Get the bind context
    LPWSTR arg = NULL;
    pOIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT, &arg, cEl, &cElFetched);
    if(arg) {
        UINT_PTR sum = 0;
        LPWSTR ptr = arg;

        // The number returned from GetBindString() may be negative
        BOOL fNegative = FALSE;
        if (*ptr == L'-') {
            fNegative = TRUE;
            ptr++;
        }

        for(; *ptr; ptr++)
            sum = (sum * 10) + (*ptr - L'0');

        if(fNegative)
            sum *= -1;

        IBindCtx* pCtx = (IBindCtx*) sum;
        SetBindCtx(pCtx); 
        if(_pBindCtx) {
            // Release the reference added in GetBindString();
            _pBindCtx->Release();
                
            // Try to get an IBindStatusCallback  pointer from the bind context
            SetBindStatusCallback(NULL);
            if (FAILED(GetObjectParam(_pBindCtx, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&_pBSC)))
                _pBSC=NULL;
        }
        CoTaskMemFree(arg);
        arg = NULL;

    }

    if(SUCCEEDED(pOIBindInfo->GetBindString(BINDSTRING_FLAG_BIND_TO_OBJECT, &arg, cEl, &cElFetched)) && arg) {

        // If this is not a bind to object then we do not want to sniff it. Set _fSniffed
        // to true and we will pass all data through.
        if(wcscmp(FLAG_BTO_STR_TRUE, arg))
            _fObjectTag = FALSE;
        else 
        {
            IInternetHostSecurityManager* pTmp;
            HRESULT hr2=CorIESecureFactory::GetHostSecurityManager(_pBSC,&pTmp);
            if (SUCCEEDED(hr2)) //Trident is there
            {
               _fObjectTag = TRUE;
               pTmp->Release();

            }
        }
            
        CoTaskMemFree(arg);
    }

    SetProtocolSink(pOInetProtSnk);

    PROTOCOLFILTERDATA* FiltData = (PROTOCOLFILTERDATA*) dwReserved;
    if (FiltData)
        SetProtocol((IOInetProtocol*) FiltData->pProtocol);
    _ASSERTE(_pProt);

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Start  (%x)\n", hr));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Continue
//
//  Synopsis: Allows the pluggable protocol handler to continue processing data on the apartment 
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Continue(PROTOCOLDATA *pStateInfoIn)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Continue "));

    HRESULT hr = S_OK;

    if(_pProt) hr = _pProt->Continue(pStateInfoIn);

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Continue\n"));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Abort
//
//  Synopsis: Aborts an operation in progress
//
//  Arguments:  [hrReason] -- reason 
//              [dwOptions] -- sync/async
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Abort(HRESULT hrReason, DWORD dwOptions)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Abort "));
    HRESULT hr = S_OK;

    if(_pProt) hr = _pProt->Abort(hrReason, dwOptions);

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Abort\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Terminate
//
//  Synopsis: releases resources
//
//  Arguments:  [dwOptions] -- reserved
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Terminate(DWORD dwOptions)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Terminate "));
    HRESULT hr = S_OK;

    if(_pProt) _pProt->Terminate(dwOptions);

    // It seems to be dangerous to release our sink here. Instead we say
    // we are out of the loop and will release the protocal sink in our
    // final release.
    _fSniffed = TRUE;
                
//      SetProtocol(NULL);
//      SetProtocolSink(NULL);
//      SetIOInetBindInfo(NULL);
//      SetServiceProvider(NULL);
//      SetBindStatusCallback(NULL);
//      SetBindCtx(NULL);
    SetCodeProcessor(NULL); //because we a addref'ed by it

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Terminate\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Suspend
//
//  Synopsis: Not currently implemented. see IInternetProtocolRoot Interface
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Suspend()
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Suspend "));

    HRESULT hr = S_OK;

    if(_pProt) hr = _pProt->Suspend();

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Suspend\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Resume
//
//  Synopsis:   Not currently implemented. see IInternetProtocolRoot Interface
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Resume()
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Resume "));

    HRESULT hr = S_OK;

    if(_pProt) hr = _pProt->Resume();

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Resume\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Read
//
//  Synopsis:   reads data 
//
//  Arguments:  [void] -- Buffer for data
//              [ULONG] -- Buffer length
//              [pcbRead] -- amount of data read
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Read(void *pBuffer, ULONG cbBuffer, ULONG *pcbRead)
{
    if (_url==NULL && _pProt)
        return _pProt->Read(pBuffer,cbBuffer,pcbRead);

    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Read "));
    HRESULT hr = S_FALSE;
    *pcbRead=0;
    if(_pProt == NULL) return hr;

    if(!_fSniffInProgress ) 
    {
        if( !_fSniffed) 
        {
            _fSniffInProgress = TRUE;
        
            // Ensure there is the default amount of space left in our
            // buffer
            DWORD size = CORFLTR_BLOCK;

            // While we successfully read data added it to the buffer
            hr = S_OK;
            while(SUCCEEDED(_snif) && hr == S_OK) {
                if(_buffer.GetSpace() == 0)
                    _buffer.Expand(size);
            
                ULONG lgth;
                hr = _pProt->Read(_buffer.GetEnd(), _buffer.GetSpace(), &lgth);
                if (_snif == S_FALSE && (SUCCEEDED(hr) || hr == E_PENDING)) {
                    _buffer.AddToEnd(lgth);
                    _snif = CheckComPlus();
                }
            }

            // We either ran out of data in the packet, had and error,  or were able to determine
            // whether the content is complus. 
            if(_snif == S_OK && SUCCEEDED(hr)) { // It is a complus assembly
                _fComplus = TRUE;
                if (_pBindCtx == NULL) {
                    hr = E_FAIL;
                } else {
                    _fSniffed = TRUE;
                    HRESULT hrFilter = S_OK;
                    if (_fObjectTag || IsOldWay())
                    {
                        // Create the Code processor and defer processing to them. 
                        SetCodeProcessor(NULL);
                        hrFilter = CoCreateInstance(CLSID_CodeProcessor, 
                                                    NULL,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_ICodeProcess,
                                                    (void**) &_pCodeProcessor);
                        if(SUCCEEDED(hrFilter)) 
                        {
                            IInternetProtocol* pProt = NULL;
                            if(SUCCEEDED(this->QueryInterface(IID_IInternetProtocol, (void**) &pProt))) 
                            {
                                hrFilter = _pCodeProcessor->CodeUse(_pBSC,   
                                                                    _pBindCtx,
                                                                    _pBindInfo,
                                                                    _pProtSnk,
                                                                    pProt,
                                                                    _filename,               // Filename
                                                                    _url,                    // URL
                                                                    _mimetype,               // CodeBase
                                                                    _fObjectTag,             // Is it an object tag or an href
                                                                    0,                       // Context Flags
                                                                    0);                      // invoked directly
                                pProt->Release();
                                
                            }
                        }
                    }
                    // Report that the mime type has been validated
                    if(SUCCEEDED(hrFilter)) {
                        if (_pProtSnk && _url!=NULL && !UrlIsFileUrl(_url)) {
                            HRESULT Sinkhr = _pProtSnk->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE,
                                                                       g_wszApplicationComplus);
                            if(FAILED(Sinkhr)) hr = Sinkhr;
                        }
                    }
                    else {
                        _fSniffed = TRUE;
                        _fComplus = FALSE;
                    }
                }
            }
            else 
            { // It is not a complus assembly. S_FALSE here usually means non-PE executable
                if (_snif == E_FAIL || hr != E_PENDING)
                    _fSniffed = TRUE;
            }
            _fSniffInProgress = FALSE;
        }
    }
    else if(_fComplus) 
    {
       *pcbRead = 0; //frankly should never get here
       return S_OK;
    }
    
    if (SUCCEEDED(hr))
    {
        if(_fSniffed && (!_fComplus || _fFilterOverride || (!_fObjectTag && !IsOldWay() && _pProtSnk)))
        {
            
            DWORD read = 0;
            DWORD avail = _buffer.GetAvailable();
            if(avail) {
                hr = _buffer.Read((PBYTE) pBuffer, cbBuffer, &read);
                if(hr == S_OK && cbBuffer > read)
                    hr = _pProt->Read(LPBYTE(pBuffer)+read, cbBuffer-read, pcbRead);
                if(SUCCEEDED(hr) || hr==E_PENDING)
                    *pcbRead += read;
            }
            else {
                hr = _pProt->Read(pBuffer, cbBuffer, pcbRead);
            }
            
        } 
        else
        {
            MakeReport(_hrResult, _dwError, _wzResult); 
            _buffer.Reset();
            *pcbRead=0;
            hr=E_NOTIMPL;
        }
    }

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Read (%x)\n", hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Seek
//
//  Synopsis:   performs a Seek in file
//
//  Arguments:  [ULARGE_INTEGER] -- distance to move
//              [DWORD] --  Origin of distance
//              [plibNewPosition] -- resulting position
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Seek "));

    HRESULT hr = E_NOTIMPL;
    //HRESULT hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Seek\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::LockRequest
//
//  Synopsis:   Lock file
//
//  Arguments:  [dwOptions] -- reserved
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::LockRequest(DWORD dwOptions)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::LockRequest"));

    HRESULT hr = S_OK;

    if(_pProt) hr = _pProt->LockRequest(dwOptions);

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::LockRequest\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::UnlockRequest
//
//  Synopsis:   Unlock file
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::UnlockRequest()
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::UnlockRequest"));
    HRESULT hr = S_OK;

    if(_pProt) hr = _pProt->UnlockRequest();

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::UnlockRequest\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::Switch
//
//  Synopsis:   Passes data from an asynchronous pluggable 
//              protocol's worker thread intended for the same asynchronous 
//              pluggable protocol's apartment thread
//
//  Arguments:  [pStateInfo] -- data to pass
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::Switch(PROTOCOLDATA *pStateInfo)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::Switch"));
    HRESULT hr = S_OK;

    if(_pProtSnk) hr = _pProtSnk->Switch(pStateInfo);
   
    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::Switch\n"));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::ReportProgress
//
//  Synopsis:   Reports progress made during a state operation
//
//  Arguments:  [NotMsg] -- BINDSTATUS value
//              [szStatusText] -- text representation of status
//
//  Returns:
//
//  History:  
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::ReportProgress"));
    HRESULT hr = S_OK;

    switch (NotMsg)
    {
    case BINDSTATUS_CACHEFILENAMEAVAILABLE:
        hr = SetFilename(pwzStatusText);
        break;
    case BINDSTATUS_MIMETYPEAVAILABLE:
        hr = SetMimeType(pwzStatusText);
        break;
    default:
        break;
    } // end switch
    
    if(SUCCEEDED(hr) && _pProtSnk)
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText); // @TODO: should we pass all the messages on

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::ReportProgress\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//

//  Method:     CorFltr::DownLoadComplus
//
//  Synopsis:   Download entire assembly
//
//  Arguments:
//            
//            
//
//  Returns:
//
//  History:  
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::DownLoadComplus()
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::DownLoadComplus "));
    HRESULT hr = S_OK;
    // If we have not been overridden then read all the data to finish the
    // the download and do not report more data available to our client.
    // If were overridden then we expect our client to process the data.
    if(_fFilterOverride == FALSE) {
        _ASSERTE(_pProt!=NULL);
        while(hr == S_OK) {
            _buffer.Reset();
            ULONG lgth;
            hr = _pProt->Read(_buffer.GetEnd(), _buffer.GetSpace(), &lgth);
        }
    }
    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::DownLoadComplus (%x)\n", hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::ReportData
//
//  Synopsis:   Reports the amount of data that is available
//
//  Arguments:  [grfBSCF] -- type of report
//              [ULONG] -- amount done 
//              [ulProgressMax] -- total amount
//
//  Returns:
//
//  History:  
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorFltr::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    AddRef();  //there's a bug in IE which could release us inside this call
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::ReportData "));
    HRESULT hr = S_OK;

    if(_pProtSnk)
        hr = _pProtSnk->ReportData(grfBSCF, ulProgress, ulProgressMax);


    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::ReportData (%x)", hr));
    Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::ReportResult
//
//  Synopsis:   Reports the result of the operation 
//
//  Arguments:  [DWORD] -- status
//              [dwError] -- protocol specific error code
//              [wzResult] -- string description
//
//  Returns:
//
//  History:  
//
//  Notes:
//
//----------------------------------------------------------------------------

// Danpo suggestion @TODO
// ReportResult(): you only want to supress the report MIMETYPE call
//  from your _pProt since you are going to do sniff and change it to
//  VERIFIEDMIMETYPE.  For ALL the rest of notification, you will have to
//  pass along to your sink so they have a chance to listen to the
//  notification, also including the CACHEFILENAME (unless you want to
//  change the name, then you will supress it and report your own name to
//  your sink)

STDMETHODIMP CorFltr::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)

{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::ReportResult"));
    HRESULT hr = S_OK;

    if (_pProtSnk)
        hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);

    
    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::ReportResult"));
    return hr;
}

STDMETHODIMP CorFltr::MakeReport(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::MakeReport"));
    HRESULT hr = S_OK;
    if(_fComplus && !_fHasRun && !_fFilterOverride && _pCodeProcessor)
    {
        hr = _pCodeProcessor->LoadComplete(hrResult, dwError, wzResult);
        _fHasRun=true;
    }
    else
        if (_pProtSnk)
            hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
        
    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::MakeReport"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorFltr::QueryService
//
//  Synopsis:   return requested service
//
//  Arguments:  [punk] -- interface to delegate call
//              [rsid] -- service identifier
//              [riid] -- requested service
//              [ppvObj] -- return value
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_NOINTERFACE;
    if(ppvObj == NULL) return E_POINTER;

    *ppvObj = 0;

    if (punk)
    {
        IServiceProvider *pSrvPrv;
        hr = punk->QueryInterface(IID_IServiceProvider, (void **) &pSrvPrv);
        if (hr == NOERROR && pSrvPrv)
        {
            hr = pSrvPrv->QueryService(rsid,riid, ppvObj);
            pSrvPrv->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryService
//
//  Synopsis:   Calls QueryInfos on
//
//  Arguments:  [rsid] -- service identifier
//              [riid] -- requested service
//              [ppvObj] -- return value
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CorFltr::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorFltr::QueryService"));
    HRESULT     hr = S_OK;

    if(ppvObj == NULL) return E_POINTER;

    if (_pSrvPrv)
    {
        hr = _pSrvPrv->QueryService(rsid,riid, ppvObj);
    }
    else if (_pProtSnk)
        {
            hr = IUnknown_QueryService(_pProtSnk, rsid, riid, ppvObj);
        }
        else
            hr=E_FAIL;

    LOG((LF_SECURITY, LL_INFO100, "-CorFltr::QueryService"));
    return hr;
}


HRESULT CorFltr::CheckComPlus()
{

    if (UrlIsFileUrl(_url))
        return E_FAIL;
    IUnknown* pTmp;
    if(!_pCodeProcessor)
    {
        if (FAILED(CoCreateInstance(CLSID_CodeProcessor, 
                                                    NULL,
                                                        CLSCTX_INPROC_SERVER,
                                                        IID_IUnknown,
                                                        (void**) &pTmp)))
                    return E_FAIL;
        pTmp->Release();
    }
    // @TODO. Check to see if this is a valid PE (the entry point is correct).
    PIMAGE_DOS_HEADER  pdosHeader;
    PIMAGE_NT_HEADERS  pNT;
    DWORD nt_lgth = sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) + IMAGE_SIZEOF_NT_OPTIONAL_HEADER;

    pdosHeader = (PIMAGE_DOS_HEADER) _buffer.GetBuffer();
    if(!pdosHeader)
        return E_OUTOFMEMORY;
    DWORD lgth = _buffer.GetAvailable();
    WORD exeMagic = 0x5a4d;

    if(lgth > sizeof(IMAGE_DOS_HEADER)) {
        if(pdosHeader->e_magic != exeMagic)
            return E_FAIL;

        if ((pdosHeader->e_magic == IMAGE_DOS_SIGNATURE) &&
            (pdosHeader->e_lfanew != 0)) {
            if(lgth >= pdosHeader->e_lfanew + nt_lgth) {
                pNT = (PIMAGE_NT_HEADERS) (pdosHeader->e_lfanew + (DWORD) _buffer.GetBuffer());
                
                if ((pNT->Signature == IMAGE_NT_SIGNATURE) &&
                    (pNT->FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
                    (pNT->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC)) {
                    
                    if(pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != NULL) 
                        return S_OK;
                }
                return E_FAIL;
            }
        }
    }
    return S_FALSE;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetObjectParam from bind context
//
//  Synopsis:
//
//  Arguments:  [pbc] -- bind context
//              [pszKey] -- key
//              [riid] -- interface requested
//              [ppUnk] -- return value
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetObjectParam(IBindCtx *pbc, LPOLESTR pszKey, REFIID riid, IUnknown **ppUnk)
{
    LOG((LF_SECURITY, LL_INFO100, "+GetObjectParam (IBindCtx)"));
    HRESULT hr = E_FAIL;
    IUnknown *pUnk = NULL;

    if(ppUnk == NULL) return E_POINTER;

    // Try to get an IUnknown pointer from the bind context
    if (pbc)
    {
        _ASSERTE(pszKey);
        hr = pbc->GetObjectParam(pszKey, &pUnk);
    }
    if (FAILED(hr))
    {
        *ppUnk = NULL;
    }
    else
    {
        // Query for riid
        hr = pUnk->QueryInterface(riid, (void **)ppUnk);
        pUnk->Release();

        if (FAILED(hr))
        {
            *ppUnk = NULL;
        }
    }

    LOG((LF_SECURITY, LL_INFO100, "-GetObjectParam (IBindCtx)"));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\corfltr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorFltr
//
// Implementation of COR MIME filter
//
//*****************************************************************************
#ifndef _CORFLT_H
#define _CORFLT_H

#include "cunknown.h"
#include "corbuffer.h"
#include "codeproc.h"
#include "util.h"
#include "mscoree.h"

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {1E66F26B-79EE-11d2-8710-00C04F79ED0D}
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMimeFilter = 
{ 0x1e66f26b, 0x79ee, 0x11d2, { 0x87, 0x10, 0x0, 0xc0, 0x4f, 0x79, 0xed, 0xd } };

extern WCHAR g_wszApplicationComplus[];

#define FLAG_BTO_STR_LENGTH           6
#define FLAG_BTO_STR_TRUE             L"TRUE"
#define FLAG_BTO_STR_FALSE            L"FALSE"
#define MAX_DWORD_DIGITS              10       // 2^32 ~= 4.3E9

class CorFltr : public CUnknown,
                public IOInetProtocol,
                public IOInetProtocolSink,
                public IServiceProvider,
                public IOInetProtocolSinkStackable
{
private:
    // Declare the delegating IUnknown.
    DECLARE_IUNKNOWN

    // Notify derived classes that we are releasing.
    virtual void FinalRelease() ;

    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE
        NondelegatingQueryInterface( const IID& iid, void** ppv) ;          
    
public:
    //IOInetProtocol methods
    STDMETHODIMP Start(LPCWSTR szUrl,
                       IOInetProtocolSink *pProtSink,
                       IOInetBindInfo *pOIBindInfo,
                       DWORD grfSTI,
#ifdef _WIN64
                       HANDLE_PTR dwReserved);
#else // !_WIN64
                       DWORD dwReserved);
#endif // _WIN64

    STDMETHODIMP Continue(PROTOCOLDATA *pStateInfo);

    STDMETHODIMP Abort(HRESULT hrReason,DWORD dwOptions);

    STDMETHODIMP Terminate(DWORD dwOptions);

    STDMETHODIMP Suspend();

    STDMETHODIMP Resume();

    STDMETHODIMP Read(void *pv,ULONG cb,ULONG *pcbRead);

    STDMETHODIMP Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,
                        ULARGE_INTEGER *plibNewPosition);

    STDMETHODIMP LockRequest(DWORD dwOptions);

    STDMETHODIMP UnlockRequest();

    //
    // IOInetProtocolSink methods
    STDMETHODIMP Switch(PROTOCOLDATA *pStateInfo);

    STDMETHODIMP ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText);

    STDMETHODIMP ReportData( DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);

    STDMETHODIMP ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult);
    
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID rsid, REFIID iid, void ** ppvObj);


    static HRESULT Create(IUnknown* punk, CUnknown** pCorFltrHndler)
    {
        if(pCorFltrHndler == NULL) return E_POINTER;

        HRESULT hr = NOERROR;
        *pCorFltrHndler = new CorFltr(punk);
        if (*pCorFltrHndler == NULL) {
            hr = E_OUTOFMEMORY;
        }
        
        return hr;
    }

    // IOInetProtocolSinkStackable

    STDMETHODIMP SwitchSink(IInternetProtocolSink *pOIProtSink)
    {
        SetProtocolSink(pOIProtSink);
        _fFilterOverride = TRUE;
        return S_OK;
    }

    STDMETHODIMP RollbackSwitch()
    {
        return E_FAIL;
    }

    STDMETHODIMP CommitSwitch()
    {
        return S_OK;
    }

private:
    STDMETHODIMP MakeReport(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult);

    void SetBindStatusCallback(IBindStatusCallback *pBSC)
    {   
        if (pBSC)
        {
            pBSC->AddRef();
        }
        if (_pBSC)
        {
            _pBSC->Release();
        }
        _pBSC = pBSC;
    }

    void SetBindCtx(IBindCtx *pBindCtx)
    {   
        if (pBindCtx)
        {
            pBindCtx->AddRef();
        }
        if (_pBindCtx)
        {
            _pBindCtx->Release();
        }
        _pBindCtx = pBindCtx;
    }
    
    void SetCodeProcessor(ICodeProcess *pCodeProcessor)
    {   
        if (pCodeProcessor)
        {
            pCodeProcessor->AddRef();
        }
        if (_pCodeProcessor)
        {
            _pCodeProcessor->Release();
        }
        _pCodeProcessor = pCodeProcessor;
    }
    
    void SetServiceProvider(IServiceProvider *pSrvPrv)
    {   
        if (pSrvPrv)
        {
            pSrvPrv->AddRef();
        }
        if (_pSrvPrv)
        {
            _pSrvPrv->Release();
        }
        _pSrvPrv = pSrvPrv;
    }
    
    void SetProtocolSink(IOInetProtocolSink *pProtSnk)
    {   
        if (pProtSnk)
        {
            pProtSnk->AddRef();
        }
        if (_pProtSnk)
        {
            _pProtSnk->Release();
        }
        _pProtSnk = pProtSnk;
    }

    void SetProtocol(IOInetProtocol *pProt)
    {
        if (pProt)
        {
            pProt->AddRef();
        }
        if (_pProt)
        {
            _pProt->Release();
        }

        _pProt = pProt;
    }
    
    HRESULT GetProtocol( IOInetProtocol **ppProt)
    {   
        if(ppProt == NULL) return E_POINTER;

        if (_pProt)
        {
            _pProt->AddRef();
            *ppProt = _pProt;
        }
        
        return (_pProt) ? NOERROR : E_NOINTERFACE;
    }

    void SetIOInetBindInfo(IOInetBindInfo *pBindInfo)
    {   
        if (pBindInfo)
        {
            pBindInfo->AddRef();
        }
        if (_pBindInfo)
        {
            _pBindInfo->Release();
        }
        _pBindInfo = pBindInfo;
    }

    HRESULT SetUrl(LPCWSTR pName)
    {
        if(_url) 
			CoTaskMemFree(_url);
		_url=NULL;

        if(pName) {
            _url = (LPWSTR) OLEURLDuplicate(pName);
            if(!_url) 
                return E_OUTOFMEMORY;
        }
        else
            _url = NULL;
        return S_OK;
    }

    HRESULT SetFilename(LPCWSTR pName)
    {
        if(_filename) CoTaskMemFree(_filename);;
		_filename=NULL;
        if(pName) {
            _filename = (LPWSTR) OLESTRDuplicate(pName);
            if(!_filename) 
                return E_OUTOFMEMORY;
        }
        else
            _filename = NULL;
        return S_OK;
    }

    HRESULT SetMimeType(LPCWSTR pName)
    {
        if(_mimetype) CoTaskMemFree(_mimetype);
		_mimetype=NULL;
        if(pName) {
            _mimetype = (LPWSTR) OLESTRDuplicate(pName);
            if(!_mimetype) 
                return E_OUTOFMEMORY;
        }
        else
            _mimetype = NULL;
        return S_OK;
    }

    HRESULT SetDelayedResult(LPCWSTR wzResult)
    {
        if(_wzResult) 
			CoTaskMemFree(_wzResult);
		_wzResult=NULL;
        if(wzResult) {
            _wzResult = (LPWSTR) OLESTRDuplicate(wzResult);
            if(!_wzResult) return E_OUTOFMEMORY;
        }
        else 
            _wzResult = NULL;
        return S_OK;
    }

    CorFltr(IUnknown* pUnknownOut = NULL)
        : CUnknown(pUnknownOut)
    {
        _pProt = NULL;
        _pProtSnk = NULL;
        _pBindInfo = NULL;
        _pSrvPrv = NULL;
        _pBSC = NULL;
        _pBindCtx = NULL;
        _pCodeProcessor = NULL;

        _url = NULL;
        _filename = NULL;
        _mimetype = NULL;
        _snif=S_FALSE;
        _fSniffed = FALSE;
        _fSniffInProgress = FALSE;
        _fComplus = FALSE;
		_fHasRun = FALSE;
        _fObjectTag = FALSE;
        _fFilterOverride = FALSE;

        _hrResult = S_OK;
        _dwError  = 0;
        _wzResult = NULL;

    }
    
    // Sniffs for complus dll;s
    HRESULT CheckComPlus();
    STDMETHODIMP DownLoadComplus();

    ~CorFltr()
     {
         if(_url) CoTaskMemFree(_url); 
         if(_filename) CoTaskMemFree(_filename);
         if(_mimetype) CoTaskMemFree(_mimetype);
         if(_wzResult) CoTaskMemFree(_wzResult);
     }


    CorBuffer            _buffer;           // buffer for storing the data
    IOInetProtocol       *_pProt;            // the prot the filter reads from
    IOInetProtocolSink   *_pProtSnk;         // the prot report progress 
    IOInetBindInfo       *_pBindInfo;         // the prot report progress 
    IServiceProvider     *_pSrvPrv;
    IBindStatusCallback  *_pBSC;            // Final Clients status callback
    IBindCtx             *_pBindCtx;        // Final clinets bind context
    ICodeProcess         *_pCodeProcessor;  // Handler for Post IE 5.0 assemblies
         
    LPWSTR              _url;
    LPWSTR              _filename;
    LPWSTR              _mimetype;
    BOOL                _fSniffed         : 1;
    BOOL                _fSniffInProgress : 1;
    BOOL                _fComplus : 1;
    BOOL                _fObjectTag : 1;
    HRESULT             _snif;
    BOOL                _fFilterOverride;               // Code processor has taken over as filter
    // Delay reports while sniffing code
    BOOL                _fHasRun : 1;
    HRESULT             _hrResult;
    DWORD               _dwError;
    LPWSTR              _wzResult;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\coriesecurefactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       CorIESecureFactory.cpp
//
//  Contents:   Wraps a factory used to create managed objects using IClassFactory3
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------
#include "stdpch.h"
#include "UtilCode.h"
#include <shlwapi.h>

#ifdef _DEBUG
#define LOGGING
#endif
#include "log.h"
#include "mshtml.h"
#include "CorPermE.h"
#include "mscoree.h"
#include "util.h"

#include "CorIESecureFactory.hpp"
#include "GetConfig.h"

static WCHAR *szConfig = L"CONFIGURATION";
static WCHAR *szLicenses = L"LICENSES";

IIEHostEx* CorIESecureFactory::m_pComplus=NULL;
CorIESecureFactory::Crst CorIESecureFactory::m_ComplusLock;


//+---------------------------------------------------------------------------
//
//  Method:     CorIESecureFactory::NondelegatingQueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorIESecureFactory::NondelegatingQueryInterface(REFIID riid, void **ppvObj)
{
    
    if(ppvObj == NULL)
        return E_POINTER;

    _ASSERTE(this);

    HRESULT hr = S_OK;

    LOG((LF_SECURITY, LL_INFO100, "+CorIESecureFactory::NondelegatingQueryInterface "));

    *ppvObj = NULL;

    if (riid == IID_ICorIESecureFactory) 
        hr = FinishQI((IUnknown*) this, ppvObj);
    else if(riid == IID_IClassFactory3)
        hr = FinishQI((IUnknown*) this, ppvObj);
    else if(riid == IID_IClassFactory)
        hr = FinishQI((IUnknown*) this, ppvObj);
    else
        hr =  CUnknown::NondelegatingQueryInterface(riid, ppvObj) ;
    

    LOG((LF_SECURITY, LL_INFO100, "-CorIESecureFactory::NondelegatingQueryInterface\n"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CorIESecureFactory::FinalRelease
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History: 
//
//  Notes: called by Release before it deletes the component
//
//----------------------------------------------------------------------------
void CorIESecureFactory::FinalRelease(void)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorIESecureFactory::FinalRelease "));

    if (m_pComplus)
        m_pComplus->Release();
    m_dwIEHostUsed--;

    // Release the IE manager
    if(m_pSecurityManager) {
        m_pSecurityManager->Release();
        m_pSecurityManager = NULL;
    }

    // Release the managed type factory
    SetComplusFactory(NULL);

    // Increments ref to prevent recursion
    CUnknown::FinalRelease() ;

    LOG((LF_SECURITY, LL_INFO100, "-CorIESecureFactory::FinalRelease\n"));
}


//+---------------------------------------------------------------------------
//
//  Function:   GetHostSecurityManager
//
//  Synopsis:   Gets the security manager from the object or from the service.
//
//  Arguments:
//
//  Returns:
//
//  History: 
//
//  Notes: called by Release before it deletes the component
//
//----------------------------------------------------------------------------
HRESULT CorIESecureFactory::GetHostSecurityManager(LPUNKNOWN punkContext, IInternetHostSecurityManager **pihsm)
{
    IServiceProvider* pisp  = NULL;

    HRESULT hr = punkContext->QueryInterface(IID_IInternetHostSecurityManager,
                                             (LPVOID *)pihsm);
    
    if ( hr == S_OK )
        return S_OK;
        
        // ... otherwise get an IServiceProvider and attempt to
        // QueryService for the security manager interface.
        
    hr = punkContext->QueryInterface(IID_IServiceProvider,
                                     (LPVOID *)&pisp);
        
    if ( hr != S_OK )
        return hr;
        
    hr = pisp->QueryService(IID_IInternetHostSecurityManager,
                            IID_IInternetHostSecurityManager,
                            (LPVOID *)pihsm);
    pisp->Release();
    return hr;
        
}

static BOOL CheckDocumentUrl(IHTMLDocument2 *pDocument)
{

    // Security check the URL for possible spoofing
    IHTMLLocation *pLocation;
    BOOL bRet=FALSE;
    
    HRESULT hr = pDocument->get_location(&pLocation);
    if (SUCCEEDED(hr))
    {
         BSTR bHref = NULL;
         hr = pLocation->get_href(&bHref);
         if (SUCCEEDED(hr))
         {
              bRet = IsSafeURL((LPWSTR)bHref);
              SysFreeString(bHref);
         }
          pLocation->Release();
     }
    return bRet;        
 }

//+---------------------------------------------------------------------------
//
//  Function:   CorIESecureFactory::CreateInstanceWithContext
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History: 
//
//  Notes: 
//
//----------------------------------------------------------------------------
STDMETHODIMP CorIESecureFactory::CreateInstanceWithContext(/* [in] */ IUnknown *punkContext, 
                                                           /* [in] */ IUnknown *punkOuter, 
                                                           /* [in] */ REFIID riid, 
                                                           /* [out][retval] */ IUnknown **ppv)
{

    if(m_bNoRealObject)
        return E_NOINTERFACE;


    HRESULT hr=S_OK;

    IInternetHostSecurityManager *pihsm = NULL;
    IHTMLDocument2 *pDocument = NULL;


    if (ppv == NULL)
        return E_POINTER;

    hr = InitializeSecurityManager();
    if(FAILED(hr)) return hr;
    
    if ( punkContext != NULL )
    {
        hr = GetHostSecurityManager(punkContext, &pihsm);
        if(SUCCEEDED(hr)) {
            hr = pihsm->QueryInterface(IID_IHTMLDocument2, (void**) &pDocument);
            if(SUCCEEDED(hr)) 
            {
                BSTR bDocument = NULL;
                if (CheckDocumentUrl(pDocument))
                    pDocument->get_URL(&bDocument);
                else
                    hr=E_NOINTERFACE;
                
                // for IE v<=6 this function returns unescaped form
                // Escape it back
                if(bDocument)
                {
                    DWORD nlen=3*(wcslen(bDocument)+1);
                    BSTR bD2=SysAllocStringLen(NULL,nlen);
                    if (SUCCEEDED(UrlCanonicalize(bDocument,bD2,&nlen,URL_ESCAPE_UNSAFE|URL_ESCAPE_PERCENT)))
                    {
                        SysFreeString(bDocument);
                        bDocument=bD2;
                    };
                };                
                DWORD dwSize = MAX_SIZE_SECURITY_ID;
                DWORD dwZone;
                BYTE  uniqueID[MAX_SIZE_SECURITY_ID];
                DWORD flags = 0;
                if(bDocument != NULL) {
                    // The URL and ID represents the document base (where the object
                    // is being used.) This determines the identity of the AppDomain
                    // in which to create the object. All Objects that are from the same
                    // document base (site) are created in the same domain. Note: the 
                    // managed class factory itself is in a 'hosting' domain not a domain
                    // identified by a document base. The managed class factory reads the
                    // security information, creates a domain based on that information,
                    // creates an object of the correct type in the new domain and returns the
                    // object as an object handle. The handle needs to be unwrapped to get
                    // to the real object.
                    LPWSTR pURL = (LPWSTR) bDocument;
                    if (pURL)
                    {
                        LPWSTR pURL2=(LPWSTR)alloca((wcslen(pURL)+1)*sizeof(WCHAR));
                        wcscpy(pURL2,pURL);
                        DWORD dwStrLen=wcslen(pURL2);
                        for (DWORD i=0;i<dwStrLen;i++)
                            if(pURL2[i]==L'\\')
                                pURL2[i]=L'/';
                        pURL=pURL2;
                    }

                    hr = m_pSecurityManager->MapUrlToZone(pURL,
                                                          &dwZone,
                                                          flags);
                    if(SUCCEEDED(hr)) {
                        hr = m_pSecurityManager->GetSecurityId(pURL,
                                                               uniqueID,
                                                               &dwSize,
                                                               0);
                        if(SUCCEEDED(hr)) {
                            IUnknown *pUnknown;
                            _ASSERTE(MAX_SIZE_SECURITY_ID == 512);
                            
                            // Temporary hack to pass id's as strings.
                            WCHAR dummy[MAX_SIZE_SECURITY_ID * 2 + 1];
                            ConvertToHex(dummy, uniqueID, dwSize);

                            // Find out if there is a configuration file
                            DWORD dwConfig = 0;
                            LPWSTR pConfig = NULL;
                            hr = GetAppCfgURL(pDocument, NULL, &dwConfig, szConfig);
                            if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                                pConfig = (LPWSTR) alloca(dwConfig * sizeof(WCHAR));
                                hr = GetAppCfgURL(pDocument, pConfig, &dwConfig, szConfig);
                                if(FAILED(hr))
                                    pConfig = NULL;
                            }

                            // Find out if there is a license file
                            LPWSTR pLicenses = NULL;
                            DWORD  dwLicenses = 0;
                            hr = GetAppCfgURL(pDocument, NULL, &dwLicenses, szLicenses);
                            if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                                pLicenses = (LPWSTR) alloca(dwLicenses * sizeof(WCHAR));
                                hr = GetAppCfgURL(pDocument, pLicenses, &dwLicenses, szLicenses);
                                if(FAILED(hr))
                                    pLicenses = NULL;
                            }
                            
                            LPWSTR wszFullConfigName=NULL;
                            if (pConfig)
                            {
                                //make full path to config
                                wszFullConfigName=new WCHAR[wcslen(pConfig)+wcslen(pURL)+8];
                                if (wszFullConfigName!=NULL)
                                {
                                    if (wcsstr(pConfig,L"://")!=NULL) //with protocol
                                        wszFullConfigName[0]='\0';
                                    else
                                    {
                                        wcscpy(wszFullConfigName,pURL);
                                        if (pConfig[0]==L'/'||pConfig[0]==L'\\')
                                        {
                                            //cut by site
                                            LPWSTR wszAfterProtocol=wcsstr(wszFullConfigName,L"://");
                                            LPWSTR wszAfterSite=NULL;
                                            if (wszAfterProtocol)
                                                wszAfterSite=wcschr(wszAfterProtocol+3,L'/');

                                            if (wszAfterSite)
                                                wszAfterSite[0]=L'\0';

                                        }
                                        else
                                        {
                                            //cut by page
                                            LPWSTR wszLastSlash=wcsrchr(wszFullConfigName,L'/');
                                            if (wszLastSlash)
                                                wszLastSlash[1]=L'\0';
                                        }
                                    }
                                    wcscat(wszFullConfigName,pConfig);
                                }
                                else
                                    hr=E_OUTOFMEMORY;
                            }

                            if (wszFullConfigName && !IsSafeURL(wszFullConfigName))
                                hr=E_INVALIDARG;
                            
                            if (SUCCEEDED(hr))
                                hr = InitializeComplus(wszFullConfigName);

                            if (wszFullConfigName)
                                delete[]wszFullConfigName;

                            // Create the instance of the managed class  
                            if (SUCCEEDED(hr))
                                hr = m_pCorFactory->CreateInstanceWithSecurity(CORIESECURITY_ZONE |
                                                                               CORIESECURITY_SITE,
                                                                               dwZone,
                                                                               pURL,
                                                                               dummy,
                                                                               pConfig,
                                                                               pLicenses,
                                                                               &pUnknown);
                            if(SUCCEEDED(hr)) {
                                // We need to unwrap the objecthandbe to get to the
                                // real object inside
                                IObjectHandle* punwrap;
                                hr = pUnknown->QueryInterface(IID_IObjectHandle, (void**) &punwrap);
                                if(SUCCEEDED(hr)) {
                                    // Unwrap gets the object inside the handle which is the real
                                    // object. It is passed through from complus factory as a handle
                                    // so MarshalByValue objects are not instantiated in the
                                    // AppDomain containing the complus class factory only in the
                                    // domain created to house the object.
                                    VARIANT Var;
                                    VariantInit(&Var);
                                    hr = punwrap->Unwrap(&Var);
                                    if(SUCCEEDED(hr)) {
                                        if (Var.vt == VT_UNKNOWN || Var.vt == VT_DISPATCH) {
                                            // We got back a valid interface.
                                            hr = Var.punkVal->QueryInterface(riid, (void**) ppv);
                                        }
                                        else {
                                            // We got back a primitive type.
                                            hr = E_FAIL;
                                        }
                                    }
                                    VariantClear(&Var);
                                    punwrap->Release();
                                }
                                pUnknown->Release();
                            }
                            
                        }
                        
                    }
                    SysFreeString(bDocument);
                }
                else {
                    hr = E_FAIL;  // Need to return an appropriate error;
                }
                pDocument->Release();
            }       
            pihsm->Release();
        }
    }
    return hr;
}



HRESULT CorIESecureFactory::InitializeComplus(LPWSTR wszConfig)
{

    HRESULT hr = S_OK;
    try
    {
        m_ComplusLock.Enter();
		IIEHostEx* pComplus=NULL;
        if (wszConfig!=NULL)
        {
            IStream* pCfgStream=NULL;
            hr = URLOpenBlockingStreamW(NULL, wszConfig, &pCfgStream, 0, NULL);
            if (SUCCEEDED(hr))
                hr = CorBindToRuntimeByCfg(pCfgStream, 0, 0, CLSID_IEHost, IID_IIEHostEx, (void**)&pComplus);
            if (pCfgStream)
                pCfgStream->Release();

			if (SUCCEEDED(hr))
				if(m_pComplus == NULL) 
				{
					m_pComplus=pComplus;
					if(m_pComplus)
						m_pComplus->AddRef();
				}
		}
        else
			if(m_pComplus == NULL) 
		        hr = CoCreateInstance(CLSID_IEHost,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IIEHostEx,
                                      (void**) &m_pComplus);
        if (SUCCEEDED(hr))
            m_pComplus->AddRef();

		if(pComplus)
			pComplus->Release();
        m_dwIEHostUsed++;
    }
    catch(...)
    {
        hr=E_UNEXPECTED;
    }
    m_ComplusLock.Leave();

    if (FAILED(hr))
        return hr;

    ISecureIEFactory* ppv = NULL;

    hr = m_pComplus->GetSecuredClassFactory(m_dwIdentityFlags,
                                            m_dwZone,
                                            m_wszSite,
                                            m_wszSecurityId,
                                            m_wszHash,
                                            m_wszClassName,
                                            m_wszFileName,
                                            &ppv);
    if(FAILED(hr)) 
        return hr;

    hr = SetComplusFactory(ppv);
    ppv->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\profile\profiler\profiler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#ifndef __PROFILER_H__
#define __PROFILER_H__

#include "..\common\callbackbase.h"
#include "CorProf.h"


#define CONFIG_ENV_VAR       L"PROF_CONFIG"

// {0104AD6E-8A3A-11d2-9787-00C04F869706}
extern const GUID __declspec(selectany) CLSID_Profiler =
    {0x104ad6e, 0x8a3a, 0x11d2, {0x97, 0x87, 0x0, 0xc0, 0x4f, 0x86, 0x97, 0x6}};

// Forward declarations
class ThreadSampler;

/* ------------------------------------------------------------------------- *
 * ProfCallback is an implementation of ICorProfilerCallback
 * ------------------------------------------------------------------------- */

class ProfCallback : public ProfCallbackBase
{
public:
    ProfCallback();

    ~ProfCallback();

    /*********************************************************************
     * IUnknown Support
     */
    COM_METHOD QueryInterface(REFIID id, void **pInterface)
    {
    	if (id == IID_ICorProfilerCallback)
    		*pInterface = (ICorProfilerCallback *)this;
        else
            return ProfCallbackBase::QueryInterface(id, pInterface);
    
        AddRef();

    	return (S_OK);
    }

    /*********************************************************************
     * ICorProfilerCallback methods
     */
    COM_METHOD Initialize( 
        /* [in] */ IUnknown *pEventInfoUnk,
        /* [out] */ DWORD *pdwRequestedEvents);
    
    COM_METHOD ClassLoadStarted( 
        /* [in] */ ClassID classId);
    
    COM_METHOD ClassLoadFinished( 
        /* [in] */ ClassID classId,
		/* [in] */ HRESULT hrStatus);
    
    COM_METHOD ClassUnloadStarted( 
        /* [in] */ ClassID classId);
    
    COM_METHOD ClassUnloadFinished( 
        /* [in] */ ClassID classId,
		/* [in] */ HRESULT hrStatus);
    
    COM_METHOD ModuleLoadStarted( 
        /* [in] */ ModuleID moduleId);
    
    COM_METHOD ModuleLoadFinished( 
        /* [in] */ ModuleID moduleId,
		/* [in] */ HRESULT hrStatus);
     
    COM_METHOD ModuleUnloadStarted( 
        /* [in] */ ModuleID moduleId);
    
    COM_METHOD ModuleUnloadFinished( 
        /* [in] */ ModuleID moduleId,
		/* [in] */ HRESULT hrStatus);

    COM_METHOD ModuleAttachedToAssembly( 
        ModuleID    moduleId,
        AssemblyID  AssemblyId);

    COM_METHOD AppDomainCreationStarted( 
        AppDomainID appDomainId);
    
    COM_METHOD AppDomainCreationFinished( 
        AppDomainID appDomainId,
        HRESULT     hrStatus);
    
    COM_METHOD AppDomainShutdownStarted( 
        AppDomainID appDomainId);
    
    COM_METHOD AppDomainShutdownFinished( 
        AppDomainID appDomainId,
        HRESULT     hrStatus);
    
    COM_METHOD AssemblyLoadStarted( 
        AssemblyID  assemblyId);
    
    COM_METHOD AssemblyLoadFinished( 
        AssemblyID  assemblyId,
        HRESULT     hrStatus);
    
    COM_METHOD NotifyAssemblyUnLoadStarted( 
        AssemblyID  assemblyId);
    
    COM_METHOD NotifyAssemblyUnLoadFinished( 
        AssemblyID  assemblyId,
        HRESULT     hrStatus);

    COM_METHOD ExceptionOccurred(
        /* [in] */ ObjectID thrownObjectId);

    COM_METHOD ExceptionHandlerEnter(
        /* [in] */ FunctionID func);

    COM_METHOD ExceptionHandlerLeave(
        /* [in] */ FunctionID func);

    COM_METHOD ExceptionFilterEnter(
        /* [in] */ FunctionID func);

    COM_METHOD ExceptionFilterLeave();

    COM_METHOD ExceptionSearch(
        /* [in] */ FunctionID func);

    COM_METHOD ExceptionUnwind(
        /* [in] */ FunctionID func);

    COM_METHOD ExceptionHandled(
        /* [in] */ FunctionID func);

    COM_METHOD COMClassicVTableCreated( 
        /* [in] */ ClassID wrappedClassId,
        /* [in] */ REFGUID implementedIID,
        /* [in] */ void __RPC_FAR *pVTable,
        /* [in] */ ULONG cSlots);

    COM_METHOD COMClassicVTableDestroyed( 
        /* [in] */ ClassID wrappedClassId,
        /* [in] */ REFGUID implementedIID,
        /* [in] */ void __RPC_FAR *pVTable);

    COM_METHOD Enter(
        /* [in] */ FunctionID Function);

    COM_METHOD Leave(
        /* [in] */ FunctionID Function);

    COM_METHOD Tailcall(
        /* [in] */ FunctionID Function);

    COM_METHOD FunctionTrace(
        LPCSTR      pFormat,
        FunctionID  Function);
    
    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_ICorProfilerCallback)
            return (E_NOINTERFACE);

        ProfCallback *ppc = new ProfCallback();

        if (ppc == NULL)
            return (E_OUTOFMEMORY);

        ppc->AddRef();
        *object = (ICorProfilerCallback *)ppc;

        return (S_OK);
    }

private:

    /*
     * This is used to parse the configuration switches
     */
    HRESULT ParseConfig(WCHAR *wszConfig);

    ICorProfilerInfo *m_pInfo;
};


int __cdecl Printf(						// cch
	const char *szFmt,					// Format control string.
	...);								// Data.


#endif /* __PROFILER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\getconfig.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Get configration from IE
//
//*****************************************************************************

#ifndef _CORGETCONFIG_H_
#define _CORGETCONFIG_H_

extern HRESULT GetAppCfgURL(IHTMLDocument2 *pDoc, LPWSTR wzAppCfgURL, DWORD *pdwSize, LPWSTR szTag);
extern HRESULT GetCollectionItem(IHTMLElementCollection *pCollect, int iIndex,
                                 REFIID riid, LPVOID *ppvObj);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\makefile.inc ===
$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\IIEHost.tlb: IIEHost.tlb
        copy IIEHost.tlb $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\IIEHost.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\getconfig.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
#include "mshtml.h"
#include "GetConfig.h"

#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];

MAKEBSTR(c_bstr_LINK, 4, "LINK");
MAKEBSTR(c_bstr_HREF, 4, "HREF");
MAKEBSTR(c_bstr_REL, 3, "REL");

HRESULT GetAppCfgURL(IHTMLDocument2 *pDoc, LPWSTR wzAppCfgURL, DWORD *pdwSize, LPWSTR szTag)
{
    HRESULT                                  hr = S_OK;
    IDispatch                               *pDisp = NULL;
    IHTMLElementCollection                  *pLink = NULL;
    IHTMLElementCollection                  *pAll = NULL;
    IHTMLElement                            *pElem = NULL;
    VARIANT                                  vtTagName;
    VARIANT                                  vtAttrib;
    VARIANT                                  vtAttribHref;
    DWORD                                    dwLen = 0;
    int                                      i = 0;
    int                                      iLength = 0;

    VariantInit(&vtAttrib);
    VariantInit(&vtAttribHref);
    VariantInit(&vtTagName);

    if (!pDoc || !pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Get the "all" collection

    hr = pDoc->get_all(&pAll);
    if (FAILED(hr)) {
        goto Exit;
    }

    vtTagName.vt = VT_BSTR;
    vtTagName.bstrVal = c_bstr_LINK;

    // Find "link" collection from the "all" collection

    hr = pAll->tags(vtTagName, &pDisp);
    if (FAILED(hr)) {
        goto Exit;
    }

    _ASSERTE(pDisp);
        
    hr = pDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pLink);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Walk over the entire collection, trying to find the one with the
    // REL="CONFIGURATION" attribute.

    hr = pLink->get_length((LONG *)&iLength);
    if (FAILED(hr)) {
        goto Exit;
    }

    for (i = 0; i < iLength; i++) {
        hr = GetCollectionItem(pLink, i, IID_IHTMLElement, (void **)&pElem);

        if (SUCCEEDED(hr)) {
            _ASSERTE(pElem);

            hr = pElem->getAttribute(c_bstr_REL, 0, &vtAttrib);

            if (SUCCEEDED(hr)) {
                _ASSERTE(vtAttrib.vt == VT_BSTR);

                if (_wcsicmp((WCHAR *)vtAttrib.pbstrVal, szTag) == 0) {
                    // Found CONFIGURATION tag. Get the HREF.

                    hr = pElem->getAttribute(c_bstr_HREF, 0, &vtAttribHref);

                    if (SUCCEEDED(hr)) {
                        _ASSERTE(vtAttribHref.vt == VT_BSTR);

                        dwLen = wcslen((WCHAR *)vtAttribHref.pbstrVal) + 1;

                        if (*pdwSize < dwLen || !wzAppCfgURL) {
                            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                        }
                        else {
                            wcscpy(wzAppCfgURL, (WCHAR *)vtAttribHref.pbstrVal);
                        }

                        *pdwSize = dwLen;
                        VariantClear(&vtAttribHref);
                    }

                    pElem->Release();
                    pElem = NULL;

                    goto Exit;
                }
                VariantClear(&vtAttrib);
            }
             
            pElem->Release();
            pElem = NULL;
        }
    }

    // Couldn't find tag

    hr = S_FALSE;

Exit:
    VariantClear(&vtAttrib);

    if (pDisp) {
        pDisp->Release();
    }

    if (pLink) {
        pLink->Release();
    }

    if (pAll) {
        pAll->Release();
    }

    return hr;
}

HRESULT GetCollectionItem(IHTMLElementCollection *pCollect, int iIndex,
                          REFIID riid, LPVOID *ppvObj)
{
    HRESULT                            hr = E_FAIL;
    IDispatch                         *pDisp = NULL;
    VARIANTARG                         va1, va2;

    VariantInit(&va1);
    VariantInit(&va2);

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
    va1.lVal = iIndex;

    hr = pCollect->item(va1, va2, &pDisp);
    if (SUCCEEDED(hr)) {
        _ASSERTE(pDisp);

        hr = pDisp->QueryInterface(riid, ppvObj);
        pDisp->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\corload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       CorLoad.cpp
//
//  Contents:   Complus filter
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------
#include "stdpch.h"
#include <Shlobj.h>
#include <wininet.h>

#ifdef _DEBUG
#define LOGGING
#endif

#include "log.h"
#include "corload.h"
#include "CorPermE.h"
#include "CorPerm.h"
#include "util.h"
#include "utilcode.h"
#include "process.h"
#include "CorIESecureFactory.hpp"
#include "AssemblyFileHash.h"
#include "mscoree.h"

#define SZ_IUNKNOWN_PTR          OLESTR("IUnknown Pointer") // urlmon/inc/urlint.h

extern HINSTANCE GetModule();
extern BOOL ClearRecursiveDownLoad();
extern BOOL SetRecursiveDownLoad();
extern BOOL RecursiveDownLoad();

//+---------------------------------------------------------------------------
//
//  Function:   CorFltr::FinalRelease
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History: 
//
//  Notes: called by Release before it deletes the component
//
//----------------------------------------------------------------------------
#define IEEXECPARAM_URL     0
#define IEEXECPARAM_FILE    1
#define IEEXECPARAM_ZONE    2
#define IEEXECPARAM_SID     3
#define IEEXECPARAM_HASH    4

typedef HRESULT (WINAPI *SPAWNFN) (LPCWSTR wszIEExec, DWORD nParam, LPCWSTR* ppParam);

extern "C"
HRESULT WINAPI SpawnIEExecDefault(LPCWSTR wszIEExec, DWORD nParam, LPCWSTR* ppParam)
{
    if (nParam < 4)
        return E_INVALIDARG;
    MAKE_ANSIPTR_FROMWIDE(url, ppParam[IEEXECPARAM_URL]);
    MAKE_ANSIPTR_FROMWIDE(zone, ppParam[IEEXECPARAM_ZONE]);
    MAKE_ANSIPTR_FROMWIDE(site, ppParam[IEEXECPARAM_SID]);
    MAKE_ANSIPTR_FROMWIDE(buffer, wszIEExec);


    CHAR flags[33];
    DWORD dwFlags = CORIESECURITY_ZONE | CORIESECURITY_SITE;
    _itoa(dwFlags, flags, 10);
    
    LPSTR url2=(LPSTR)alloca(strlen(url)+3);
    url2[0]='"';
    strcpy(url2+1,url);
    strcat(url2,"\"");
    size_t i = _spawnl(_P_NOWAIT, buffer, buffer, url2, flags, zone, site, NULL);
    return S_OK;
}



extern "C"
HRESULT WINAPI SpawnIEExec(LPCWSTR wszIEExec, DWORD nParam, LPCWSTR* ppParam)
{
    if (nParam < 5)
        return E_INVALIDARG;
    // This string will only contain numeric values.
    MAKE_ANSIPTR_FROMWIDE(szHash, ppParam[IEEXECPARAM_HASH]);
    MAKE_ANSIPTR_FROMWIDE(url, ppParam[IEEXECPARAM_URL]);
    MAKE_ANSIPTR_FROMWIDE(buffer, wszIEExec);

    DWORD length = strlen(szHash);
        
    LPSTR url2=(LPSTR)alloca(strlen(url) + 4 + length + 100);
    url2[0]='"';
    strcpy(url2+1,url);
    strcat(url2,"#");
    strcat(url2,szHash);
    strcat(url2,"\"");

    size_t i = _spawnl(_P_NOWAIT, buffer, buffer, url2, NULL);
    return S_OK;    
};

void CorLoad::FinalRelease(void)
{
    LOG((LF_SECURITY, LL_INFO100, "+CorLoad::FinalRelease"));

    // Increments ref to prevent recursion
    CUnknown::FinalRelease() ;

    SetProtocol(NULL);
    SetProtocolSink(NULL);
    SetIOInetBindInfo(NULL);
    SetBindStatusCallback(NULL);
    SetBindCtx(NULL);

    
    if(_pSecurityManager) {
        _pSecurityManager->Release();
        _pSecurityManager = NULL;
    }
    
    if(_pZoneManager) {
        _pZoneManager->Release();
        _pZoneManager = NULL;
    }

    if (_pHostSecurityManager)
    {
        _pHostSecurityManager->Release();
        _pHostSecurityManager=NULL;
    }

    LOG((LF_SECURITY, LL_INFO100, "-CorLoad::FinalRelease"));
}

//+---------------------------------------------------------------------------
//
//  Method:     CorLoad::NondelegatingQueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorLoad::NondelegatingQueryInterface(REFIID riid, void **ppvObj)
{
    
    if(ppvObj == NULL)
        return E_INVALIDARG;

    _ASSERTE(this);

    HRESULT hr = S_OK;

    LOG((LF_SECURITY, LL_INFO100, "+CorLoad::NondelegatingQueryInterface"));

    *ppvObj = NULL;

    if (riid == IID_ICodeProcess) 
        hr = FinishQI((ICodeProcess *) this, ppvObj);
    else
        if (riid == IID_IOleObject) 
            hr = FinishQI((IOleObject *) this, ppvObj);
            else
                if (riid == IID_IPersistMoniker) 
                    hr = FinishQI((IPersistMoniker *) this, ppvObj);
                else
                    if (riid == IID_IBindStatusCallback) 
                        hr = FinishQI((IBindStatusCallback*) this, ppvObj);
                    else 
                        hr =  CUnknown::NondelegatingQueryInterface(riid, ppvObj) ;
    
    
    LOG((LF_SECURITY, LL_INFO100, "-CorLoad::NondelegatingQueryInterface"));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CorLoad::CodeUse
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CorLoad::CodeUse(IBindStatusCallback __RPC_FAR *pBSC,
                              IBindCtx __RPC_FAR *pBC,
                              IInternetBindInfo __RPC_FAR *pIBind,
                              IInternetProtocolSink __RPC_FAR *pSink,
                              IInternetProtocol __RPC_FAR *pClient,
                              LPCWSTR lpCacheName,
                              LPCWSTR lpRawURL,
                              LPCWSTR lpCodeBase,
                              BOOL    fObjectTag,
                              DWORD dwContextFlags,
                              DWORD bViaMIMEHandler)
{
    // Only when we are loading executables the old way
    // we check the recursive case;
    if(bViaMIMEHandler == 0  && fObjectTag == FALSE && RecursiveDownLoad())
        return E_FAIL;
                            
    SetRecursiveDownLoad();

    SetBindStatusCallback(pBSC);
    SetBindCtx(pBC);
    SetIOInetBindInfo(pIBind);
    SetProtocolSink(pSink);
    SetProtocol(pClient);  // We can QI for ICodeFilter if we want to act like a filter
    SetFilename(lpCacheName);
    SetUrl(lpRawURL);
    SetClass(NULL);
    _fObjectTag = fObjectTag;

    
    // Verify URL
    if(_url) {
        DWORD i;
        DWORD lgth = (DWORD)wcslen(_url);
        for(i = 0; i < lgth; i++) {
            if(_url[i] == L'#') break;
        }
        
        i++;
        if(i < lgth) { 
            SetClass(&(_url[i]));
            _url[--i] = L'\0';
        }    
        return S_OK;
    }
    return E_FAIL;
}

#ifdef _OLD_BIND
extern "C" 
// Temporary Functions to get a object based on a name
HRESULT STDMETHODCALLTYPE  EEDllGetClassObjectFromClass(LPCWSTR module,
                                                        LPCWSTR className,
                                                        REFIID riid,
                                                        LPVOID FAR *ppv);
#endif

STDMETHODIMP CorLoad::LoadComplete(HRESULT hrResult,
                                   DWORD   dwError,
                                   LPCWSTR wzResult)
{
    HRESULT hr;
    hr = LoadCompleteInternal(hrResult, dwError, wzResult);
    if (FAILED(hr))
        hr = FallBack(hr);
    else
        hr = hrResult;

    ClearRecursiveDownLoad();
    return hr;
}


STDMETHODIMP CorLoad::LoadCompleteInternal(HRESULT hrResult,
                                   DWORD   dwError,
                                   LPCWSTR wzResult)
{
    HRESULT hr = S_OK;
    AssemblyFileHash fileHash;
    PBYTE pbHash = NULL;
    DWORD cbHash = 0;

    if(hrResult == S_OK && dwError == 0) {
        CorIESecureFactory* pFactory = NULL;

        hr = InitializeSecurityManager();
        if(FAILED(hr)) return hr;

            
        DWORD dwSize = MAX_SIZE_SECURITY_ID;
        BYTE  uniqueID[MAX_SIZE_SECURITY_ID];
        DWORD dwZone;


        if(_url != NULL && IsSafeURL(_url)) {
            DWORD flags = 0;
            // We have a class name, return a class factory for it
            hr = _pSecurityManager->MapUrlToZone(_url,
                                                 &dwZone,
                                                 flags);
            if(FAILED(hr)) return hr;
            
            hr = _pSecurityManager->GetSecurityId(_url,
                                                  uniqueID,
                                                  &dwSize,
                                                  0);
            if(FAILED(hr)) return hr;
            
            // Use GetUrlCacheEntryInfo if the filename is not present
            LPCWSTR filename = _filename;
            if(filename == NULL) {
                INTERNET_CACHE_ENTRY_INFO info;
                DWORD size = sizeof(INTERNET_CACHE_ENTRY_INFO);
                memset(&info, 0, sizeof(INTERNET_CACHE_ENTRY_INFO));
                if(GetUrlCacheEntryInfo(_url,
                                       &info,
                                       &size) == FALSE) {
                    if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                        INTERNET_CACHE_ENTRY_INFO* pInfo = (INTERNET_CACHE_ENTRY_INFO*) alloca(size);
                        memset(pInfo, 0, size);
                        if(GetUrlCacheEntryInfo(_url, pInfo, &size)) {
                            filename = pInfo->lpszLocalFileName;
                        }
                    }
                }
            }
            
            if(filename != NULL) {
                DWORD dwSignedPolicy;
                DWORD dwUnsignedPolicy;
                DWORD cbPolicy = sizeof(DWORD);

                hr = _pSecurityManager->ProcessUrlAction(_url,
                                                         URLACTION_MANAGED_UNSIGNED,
                                                         (PBYTE) &dwUnsignedPolicy,
                                                         cbPolicy,
                                                         NULL,
                                                         0,
                                                         PUAF_NOUI,
                                                         0);
                if(FAILED(hr)) return hr;

                hr = _pSecurityManager->ProcessUrlAction(_url,
                                                         URLACTION_MANAGED_SIGNED,
                                                         (PBYTE) &dwSignedPolicy,
                                                         cbPolicy,
                                                         NULL,
                                                         0,
                                                         PUAF_NOUI,
                                                         0);
                if(FAILED(hr)) return hr;
                
                ZONEATTRIBUTES zoneInfo;
                memset(&zoneInfo, 0, sizeof(ZONEATTRIBUTES));
                
                _pZoneManager->GetZoneAttributes(dwZone,
                                                 &zoneInfo);


                hr = CheckManagedFileWithUser((LPWSTR) filename,
                                              _url,
                                              _pZoneManager,
                                              zoneInfo.szDisplayName,
                                              dwZone,
                                              dwSignedPolicy,
                                              dwUnsignedPolicy);
                if(FAILED(hr)) return hr;


                DWORD id = CALG_SHA1;

                IfFailRet(fileHash.SetFileName(filename));
                IfFailRet(fileHash.GenerateDigest());
                IfFailRet(fileHash.CalculateHash(id));

                pbHash = fileHash.GetHash();
                cbHash = fileHash.GetHashSize();

            }
            else 
                return E_FAIL;

            // ---
            // Getting the meta data to match up between the managed class
            // and unmanaged idl file seems to be broken. Will create a
            // string of hex and pass it in
            

            WCHAR wszSecurityID[MAX_SIZE_SECURITY_ID * 2 + 1];
            DWORD j = CorIESecureFactory::ConvertToHex(wszSecurityID, uniqueID, dwSize);

            WCHAR* wszHash = (WCHAR*) alloca((cbHash * 2 + 1) * sizeof(WCHAR));
            DWORD k = CorIESecureFactory::ConvertToHex(wszHash, pbHash, cbHash);

            BOOL fTrident = TRUE;
            if(_pBSC) {
                if (_pHostSecurityManager)
                    _pHostSecurityManager->Release();
                _pHostSecurityManager=NULL;
                hr = CorIESecureFactory::GetHostSecurityManager(_pBSC, &_pHostSecurityManager);
                if(SUCCEEDED(hr)) 
                {
                    DWORD dwPolicy;
                    hr = _pHostSecurityManager->ProcessUrlAction(URLACTION_SHELL_FILE_DOWNLOAD , 
                                                                 (BYTE *)&dwPolicy, 
                                                                 sizeof(dwPolicy), 
                                                                 (BYTE *)"", 0, 0, 0);
                    _pHostSecurityManager->Release();
                    _pHostSecurityManager=NULL;
                    if (hr!=S_OK)
                        return E_ACCESSDENIED;
                }
                else
                {
                    fTrident = FALSE;
                    if(hr==E_NOINTERFACE || hr==E_NOTIMPL) // nobody to ask
                        hr=S_FALSE;
                }
            }

            if(_fObjectTag == FALSE || fTrident == FALSE) {
                // If the class is null then we will try to execute it
                // as an executable.

                
                MAKE_ANSIPTR_FROMWIDE(url, _url);
                
                for (DWORD i=0;SUCCEEDED(hr) && i<strlen(url);i++)
                {
                   if (url[i]==' '||url[i]=='"'|| url[i]=='\'' || isspace(url[i]))
                   {
                       hr=E_INVALIDARG;
                       break;
                   }
                   if (url[i]>='a' && url[i]<='z')
                       continue;
                   if (url[i]>='A' && url[i]<='Z')
                       continue;
                   if (url[i]>='0' && url[i]<='9')
                       continue;
                   switch(url[i])
                   {
                   case '$':
                   case '-':
                   case '_':
                   case '@':
                   case '.':
                   case '&':
                   case '%':
                   case '!':
                   case '*':
                   case '(':
                   case ')':
                   case ',':
                   case '=':
                   case ';':
                   case '/':
                   case '?':
                   case ':': 
                       continue;
                   default : 
                   case '#':   // valid character but we do not allow it for href's executables
                       hr=E_INVALIDARG;  break;
                   }
                }

                const CHAR pExec[] = "IEExec";
                const WCHAR wpExec[] = L"IEExec";

                LPCWSTR wszIEExec=NULL;

                if(SUCCEEDED(hr))
                {
                    CHAR buffer[MAX_PATH];
                    buffer[0] = '\0';

                    
                    DWORD length = GetModuleFileNameA(GetModule(), buffer, MAX_PATH);
                    if(length) {
                        CHAR* path = strrchr(buffer, '\\');
                        if(path && ((path - buffer) + sizeof(pExec) < MAX_PATH)) {
                            path++;
                            strcpy(path, pExec);
                        }
                        else
                            hr=E_UNEXPECTED;
                    }
                    MAKE_WIDEPTR_FROMANSI(wszIEExec2,buffer);
                    wszIEExec=wszIEExec2;
                }

                SPAWNFN fSpawn=SpawnIEExecDefault;
                HMODULE hMod=NULL;

                if (SUCCEEDED(hr))
                {
                    WCHAR wszVer[MAX_PATH];
                    WCHAR* wszBuffer=(WCHAR*)alloca(MAX_PATH*sizeof(WCHAR));
                    DWORD dwBuf1,dwBuf2;
                    LPWSTR urlcfg=(LPWSTR)alloca((wcslen(_url) + 8)*sizeof(WCHAR));
                    wcscpy(urlcfg,_url);
                    wcscat(urlcfg,L".config");
                    UINT last = SetErrorMode(0);
                    SetErrorMode(last & ~SEM_FAILCRITICALERRORS);
                    hr=GetRequestedRuntimeInfo(filename,NULL,urlcfg,0,0,wszBuffer,MAX_PATH,&dwBuf1,wszVer,MAX_PATH,&dwBuf2);
                    SetErrorMode(last);
                    if (SUCCEEDED(hr))
                    {
                        if(wcslen(wszBuffer)+wcslen(wszVer)+sizeof(wpExec)/sizeof(wpExec[0])+3 >= MAX_PATH)
                            hr=HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                        else
                        {
                            wcscat(wszBuffer,L"\\");
                            wcscat(wszBuffer,wszVer);
                            wcscat(wszBuffer,L"\\");
                            wcscat(wszBuffer,wpExec);
                            wszIEExec=wszBuffer;
                        }
                        if (SUCCEEDED(LoadLibraryShim(L"mscorld.dll",wszVer,NULL,&hMod)))
                        {
                            FARPROC pr=GetProcAddress(hMod,"SpawnIEExec");
                            if (pr)
                                fSpawn=(SPAWNFN)pr; // otherwise we assume it's RTM
                            
                        }
                        else
                            hr=E_UNEXPECTED;
                    }

                }
                
                if(SUCCEEDED(hr))
                {
                    WCHAR wszZone[33];
                    _itow(dwZone, wszZone, 10);

                    LPCWSTR pParams[5]={0};
                    pParams[IEEXECPARAM_URL]=_url;
                    pParams[IEEXECPARAM_FILE]=filename;
                    pParams[IEEXECPARAM_ZONE]=wszZone;
                    pParams[IEEXECPARAM_SID]=wszSecurityID;
                    pParams[IEEXECPARAM_HASH]=wszHash;
                    hr=fSpawn?fSpawn(wszIEExec,5,pParams):E_UNEXPECTED;
                }
                if(hMod)
                    FreeLibrary(hMod);

            }
            else if (_class != NULL) {
                _ASSERTE(MAX_SIZE_SECURITY_ID == 512);
               
                // Create a class that services IClassFactory3 using the
                // complus factory just created. The factory must be in
                // native so the COMPLUS ObjectHandled can be QI'd for
                // the real object.

                hr = CorIESecureFactory::Create(NULL, 
                                                &pFactory);
                if(SUCCEEDED(hr)) 
                    hr = pFactory->SetURLData(CORIESECURITY_ZONE | 
                                              CORIESECURITY_SITE,
                                              dwZone,
                                              _url,
                                              wszSecurityID,
                                              wszHash,
                                              _filename,
                                              _class);

                // register the object with trident.
                if(SUCCEEDED(hr)) {
                    if (_pBindCtx)
                        hr = _pBindCtx->RegisterObjectParam(SZ_IUNKNOWN_PTR, pFactory);
                    else
                        hr = E_UNEXPECTED;
                    if(SUCCEEDED(hr)&&_pProtSnk) 
                        hr = _pProtSnk->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE,
                                                       NULL);
                }
                if (pFactory)
                    pFactory->Release();
            }
            if(SUCCEEDED(hr)&&_pProtSnk)
                hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
        }
    }
    return hr;
}

HRESULT CorLoad::SetClientSite(  IOleClientSite *pClientSite)
{
    if (pClientSite)
    {
        if (_pHostSecurityManager)
            _pHostSecurityManager->Release();
        _pHostSecurityManager=NULL;
        CorIESecureFactory::GetHostSecurityManager(pClientSite,&_pHostSecurityManager);
    }
    _fSetClientSite = TRUE;

    return S_OK;
};

HRESULT CorLoad::GetClientSite(  IOleClientSite **pClientSite)
{
   return E_NOTIMPL;
};

HRESULT CorLoad::SetHostNames(LPCOLESTR szContainerApp,LPCOLESTR szContainerObj)
{
   return E_NOTIMPL;
};

HRESULT CorLoad::Close(DWORD dwSaveOption)
{
   return E_NOTIMPL;
};

HRESULT CorLoad::SetMoniker(DWORD dwWhichMoniker,IMoniker *pmk)
{
   return E_NOTIMPL;
};
HRESULT CorLoad::GetMoniker(DWORD dwAssign,DWORD dwWhichMoniker,IMoniker **ppmk)
{
   return E_NOTIMPL;
};
HRESULT CorLoad::InitFromData(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved)
{
   return E_NOTIMPL;
};

HRESULT CorLoad::GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject)
{
   return E_NOTIMPL;
};

HRESULT CorLoad::ProcessAction()
{
    if(_fSetClientSite && _fActivated == FALSE) {
        if (_pHostSecurityManager)
        {
            DWORD dwPolicy;
            HRESULT hr = _pHostSecurityManager->ProcessUrlAction(
                                                                 URLACTION_SHELL_FILE_DOWNLOAD , (BYTE *)&dwPolicy, sizeof(dwPolicy), 
                                                                 (BYTE *)"", 0, 0, 0);
            if (hr!=S_OK)
                return E_ACCESSDENIED;
        }
        _fActivated = TRUE;
        return LoadComplete(S_OK, 0, NULL);
    }
    return S_OK;
}

HRESULT CorLoad::DoVerb(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect)
{
    if (iVerb==0) //OLEVERB_PRIMARY
    {
        _fSetClientSite = TRUE;
        if(_fFullyAvailable)
            return ProcessAction();
    }
    return S_OK;
}

HRESULT CorLoad::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    return E_NOTIMPL;
};


HRESULT CorLoad::Update()
{
    return E_NOTIMPL;
};

HRESULT CorLoad::IsUpToDate()
{
    return S_OK;
};

HRESULT CorLoad::GetUserClassID(CLSID *pClsid)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::GetUserType(DWORD dwFormOfType,LPOLESTR *pszUserType)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::SetExtent(DWORD dwDrawAspect,SIZEL  *psizel)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::GetExtent(DWORD dwDrawAspect,SIZEL  *psizel)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::Advise(IAdviseSink *pAdvSink,DWORD *pdwConnection)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::Unadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::GetMiscStatus(DWORD dwAspect,DWORD *pdwStatus)
{
    return E_NOTIMPL; 
};

HRESULT CorLoad::SetColorScheme(LOGPALETTE *pLogpal)
{
    return E_NOTIMPL;
};

HRESULT CorLoad::IsDirty(void)
{
    return S_FALSE;
};

HRESULT CorLoad::GetClassID(CLSID *pClassID)
{
    if (!pClassID)
        return E_INVALIDARG;
    *pClassID=CLSID_CorRemoteLoader;
    return S_OK;
};

HRESULT CorLoad::KeepMessagePumpAlive(BOOL fStart)
{
    HRESULT hr = S_OK;
    if (fStart)
    {
        IUnknown* punk = NULL;
        hr = SHGetInstanceExplorer(&punk);
        if(SUCCEEDED(hr)) {
            SetExplorer(punk);
            punk->Release();
        }
    }
    else {
        SetExplorer(NULL);
    }

    return hr;
};

HRESULT  CorLoad::Load(BOOL fFullyAvailable,IMoniker *pmkSrc,IBindCtx *pbc,DWORD grfMode)
{
    LPOLESTR ppszDisplayName;
    HRESULT hr=pmkSrc->GetDisplayName( pbc, NULL, &ppszDisplayName );
    if (FAILED(hr))
        return hr;
    if(SUCCEEDED(hr)) 
    {
        hr = CodeUse(NULL,   
                     pbc,
                     NULL,
                     NULL,
                     NULL,
                     NULL,               // Filename
                     ppszDisplayName,                    // URL
                     NULL,               // CodeBase
                     FALSE,              // Is it an object tag or an href
                     0,                       // Context Flags
                     1);                      // invoked via MIME handler
        IMalloc* pMem;
        if (ppszDisplayName!=NULL && SUCCEEDED(CoGetMalloc(1,&pMem)))
        {
            pMem->Free(ppszDisplayName);
            pMem->Release();
        }
        if (!fFullyAvailable)
        {
            _fFullyAvailable = FALSE;

            IBindCtx* pBindCtx=pbc;
            IBindStatusCallback* prev;
            hr = RegisterBindStatusCallback(pBindCtx,(IBindStatusCallback*)this,&prev,0);
            if (SUCCEEDED(hr))
            {
                hr = KeepMessagePumpAlive(TRUE);
                if(SUCCEEDED(hr)) {
                    IStream* pStream;
                    hr=pmkSrc->BindToStorage(pBindCtx,NULL,IID_IStream,(LPVOID*)&pStream);
                    if (SUCCEEDED(hr))
                    {                       
                        pStream->Release();
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CorLoad::Save(IMoniker *pmkDst,IBindCtx *pbc,BOOL fRemember)
{
    return S_OK;
};
HRESULT CorLoad::SaveCompleted(IMoniker *pmkNew,IBindCtx *pbc)
{
    return S_OK;
};
HRESULT CorLoad::GetCurMoniker(IMoniker **ppimkCur)
{
    return E_NOTIMPL;
};

STDMETHODIMP CorLoad::GetBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo)
{
    return S_OK;
};

STDMETHODIMP CorLoad::GetPriority(LONG *pnPriority)
{
    return E_NOTIMPL;
};

STDMETHODIMP CorLoad::OnDataAvailable(DWORD grfBSCF,DWORD dwSize,FORMATETC *pformatetc,STGMEDIUM *pstgmed)
{
    HRESULT hr = S_OK;
    if (pstgmed != NULL && pstgmed->tymed == TYMED_ISTREAM)
    {
        IStream* pStream = pstgmed->pstm;
        BYTE Buffer[4096];
        DWORD dwBufSize;
        if (pStream == NULL)
            hr = E_INVALIDARG;
        
        while(hr == S_OK)
        {
            dwBufSize = sizeof(Buffer);
            hr=pStream->Read(Buffer,dwBufSize,&dwBufSize);
        }

    }
    if (hr == E_PENDING || hr == S_FALSE)
        hr = S_OK;
    
    return hr;
};

STDMETHODIMP CorLoad::OnObjectAvailable(REFIID riid,IUnknown *punk)
{
    return S_OK;
};
STDMETHODIMP CorLoad::OnProgress(ULONG ulProgress,ULONG ulProgressMax,ULONG ulStatusCode,LPCWSTR szStatusText)
{
    return S_OK;
};
STDMETHODIMP CorLoad::OnStartBinding(DWORD dwReserved,IBinding *pib)
{
    return S_OK;
};

STDMETHODIMP CorLoad::OnStopBinding(HRESULT hresult,LPCWSTR szError)
{
    _fFullyAvailable = TRUE;
    HRESULT hr = KeepMessagePumpAlive(FALSE);
    _ASSERTE(SUCCEEDED(hr));  // should never fail but if it does ignore it.

    hr = ProcessAction();
    return hr;
};

STDMETHODIMP CorLoad::OnLowResource(DWORD dwReserved)
{
    return S_OK;
};



STDMETHODIMP CorLoad::FallBack(HRESULT hrCode)
{
    if(_fObjectTag == FALSE ) 
        return hrCode;

    CorIESecureFactory* pFactory = NULL;
    HRESULT hr = CorIESecureFactory::Create(NULL, 
                                    &pFactory);
    if(FAILED(hr))
        return hr;

    pFactory->DoNotCreateRealObject();

    if (_pBindCtx)
        hr = _pBindCtx->RegisterObjectParam(SZ_IUNKNOWN_PTR, pFactory);
    else
    {
        hr = E_UNEXPECTED;
        pFactory->Release();
    }
    if(SUCCEEDED(hr)&&_pProtSnk) 
        hr = _pProtSnk->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE,
                                       NULL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _STDPCH_H
#define _STDPCH_H
// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <CrtWrap.h>
#include <WinWrap.h>
#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <windef.h>
#include <limits.h>
#include <stdlib.h>
#include <objbase.h>
#include <float.h>

#include <urlmon.h>

#ifdef __cplusplus
extern "C" {
#endif

HINSTANCE GetModule();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\util.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
#include "UtilCode.h"
#include <shlwapi.h>
//+---------------------------------------------------------------------------
//
//  Function:   OLESTRDuplicate
//
//  Synopsis:
//
//  Arguments:  [ws] --
//
//  Returns:
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR OLESTRDuplicate(LPCWSTR ws)
{
    LPWSTR wsNew = NULL;

    if (ws)
    {
        wsNew = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(ws) + 1));
        if (wsNew)
        {
            wcscpy(wsNew, ws);
        }
    }

    return wsNew;
}

LPWSTR OLEURLDuplicate(LPCWSTR ws)
{
    LPWSTR wsNew = NULL;

    if (ws)
    {
		DWORD dwLen=(wcslen(ws) + 1)*3;
        wsNew = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR)*dwLen);
        if (wsNew)
        {
            UrlCanonicalize(ws,wsNew,&dwLen,0);
        }
    }

    return wsNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\corload.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorLoad
//
// Implementation of COR MIME filter
//
//*****************************************************************************
#ifndef _CORLOAD_H
#define _CORLOAD_H

#include "cunknown.h"
#include "corbuffer.h"
#include "codeproc.h"
#include "util.h"
#include "IIEHost.h"

//#define _OLD_BIND

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {1E66F26C-79EE-11d2-8710-00C04F79ED0D}
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorRemoteLoader = 
{ 0x1e66f26c, 0x79ee, 0x11d2, { 0x87, 0x10, 0x0, 0xc0, 0x4f, 0x79, 0xed, 0xd } };

class CorLoad : public CUnknown,
                public ICodeProcess,
                public IOleObject,
                public IPersistMoniker,
                public IBindStatusCallback
{
private:
    // Declare the delegating IUnknown.
    DECLARE_IUNKNOWN
    
    // Notify derived classes that we are releasing.
    virtual void FinalRelease() ;

    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE
        NondelegatingQueryInterface( const IID& iid, void** ppv) ;  
    
    // IOleObject
    STDMETHODIMP SetClientSite(  IOleClientSite *pClientSite);
    STDMETHODIMP GetClientSite(  IOleClientSite **pClientSite);
    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp,LPCOLESTR szContainerObj);
    STDMETHODIMP Close(DWORD dwSaveOption);
    STDMETHODIMP SetMoniker(DWORD dwWhichMoniker,IMoniker *pmk);
    STDMETHODIMP GetMoniker(DWORD dwAssign,DWORD dwWhichMoniker,IMoniker **ppmk);
    STDMETHODIMP InitFromData(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved);
    STDMETHODIMP GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject);
    STDMETHODIMP DoVerb(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect);
    STDMETHODIMP EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    STDMETHODIMP Update();
    STDMETHODIMP IsUpToDate();
    STDMETHODIMP GetUserClassID(CLSID *pClsid);
    STDMETHODIMP GetUserType(DWORD dwFormOfType,LPOLESTR *pszUserType);
    STDMETHODIMP SetExtent(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHODIMP GetExtent(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHODIMP Advise(IAdviseSink *pAdvSink,DWORD *pdwConnection);
    STDMETHODIMP Unadvise(DWORD dwConnection);
    STDMETHODIMP EnumAdvise(IEnumSTATDATA **ppenumAdvise);
    STDMETHODIMP GetMiscStatus(DWORD dwAspect,DWORD *pdwStatus);
    STDMETHODIMP SetColorScheme(LOGPALETTE *pLogpal);

    //IPersistMoniker
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP Load(BOOL fFullyAvailable,IMoniker *pmkSrc,IBindCtx *pbc,DWORD grfMode);
    STDMETHODIMP Save(IMoniker *pmkDst,IBindCtx *pbc,BOOL fRemember);
    STDMETHODIMP SaveCompleted(IMoniker *pmkNew,IBindCtx *pbc);
    STDMETHODIMP GetCurMoniker(IMoniker **ppimkCur);

    //IBindStatusCallback
    STDMETHOD(GetBindInfo)(DWORD *grfBINDF,BINDINFO *pbindinfo);
    STDMETHOD(GetPriority)(LONG *pnPriority);
    STDMETHOD(OnDataAvailable)(DWORD grfBSCF,DWORD dwSize,FORMATETC *pformatetc,STGMEDIUM *pstgmed);
    STDMETHOD(OnObjectAvailable)(REFIID riid,IUnknown *punk);
    STDMETHOD(OnProgress)(ULONG ulProgress,ULONG ulProgressMax,ULONG ulStatusCode,LPCWSTR szStatusText);
    STDMETHOD(OnStartBinding)(DWORD dwReserved,IBinding *pib);
    STDMETHOD(OnStopBinding)(HRESULT hresult,LPCWSTR szError);
    STDMETHOD(OnLowResource)(DWORD dwReserved);

 // IOleWindow Implementation
    STDMETHODIMP  GetWindow(HWND* phWnd);
    STDMETHODIMP  ContextSensitiveHelp(BOOL fEnterMode);

public:

    STDMETHODIMP CodeUse( 
            /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
            /* [in] */ IBindCtx __RPC_FAR *pBC,
            /* [in] */ IInternetBindInfo __RPC_FAR *pIBind,
            /* [in] */ IInternetProtocolSink __RPC_FAR *pSink,
            /* [in] */ IInternetProtocol __RPC_FAR *pClient,
            /* [in] */ LPCWSTR lpCacheName,
            /* [in] */ LPCWSTR lpRawURL,
            /* [in] */ LPCWSTR lpCodeBase,
            /* [in] */ BOOL  fObjectTag,
            /* [in] */ DWORD dwContextFlags,
            /* [in] */ DWORD bViaMIMEHandler);

    STDMETHODIMP LoadComplete(
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD   dwError,
            /* [in] */ LPCWSTR wzResult);

    STDMETHODIMP LoadCompleteInternal(
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD   dwError,
            /* [in] */ LPCWSTR wzResult);

    static HRESULT Create(IUnknown* punk, CUnknown** pCorLoadHndler)
    {
        HRESULT hr = NOERROR;

        if(pCorLoadHndler == NULL) return E_POINTER;

        *pCorLoadHndler = new CorLoad(punk);
        if (*pCorLoadHndler == NULL) {
            hr = E_OUTOFMEMORY;
        }
        
        return hr;
    }

    STDMETHODIMP FallBack(HRESULT hrCode);


private:

    void SetBindStatusCallback(IBindStatusCallback *pBSC)
    {   
        if (pBSC)
        {
            pBSC->AddRef();
        }
        if (_pBSC)
        {
            _pBSC->Release();
        }
        _pBSC = pBSC;
    }

    void SetBindCtx(IBindCtx *pBindCtx)
    {   
        if (pBindCtx)
        {
            pBindCtx->AddRef();
        }
        if (_pBindCtx)
        {
            _pBindCtx->Release();
        }
        _pBindCtx = pBindCtx;
    }
    
    void SetProtocolSink(IOInetProtocolSink *pProtSnk)
    {   
        if (pProtSnk)
        {
            pProtSnk->AddRef();
        }
        if (_pProtSnk)
        {
            _pProtSnk->Release();
        }
        _pProtSnk = pProtSnk;
    }

    void SetProtocol(IOInetProtocol *pProt)
    {
        if (pProt)
        {
            pProt->AddRef();
        }
        if (_pProt)
        {
            _pProt->Release();
        }

        _pProt = pProt;
    }
    
    HRESULT GetProtocol( IOInetProtocol **ppProt)
    {   
        if( ppProt == NULL) return E_POINTER;

        if (_pProt)
        {
            _pProt->AddRef();
            *ppProt = _pProt;
        }
        
        return (_pProt) ? NOERROR : E_NOINTERFACE;
    }

    void SetIOInetBindInfo(IOInetBindInfo *pBindInfo)
    {   
        if (pBindInfo)
        {
            pBindInfo->AddRef();
        }
        if (_pBindInfo)
        {
            _pBindInfo->Release();
        }
        _pBindInfo = pBindInfo;
    }

    HRESULT SetFilename(LPCWSTR pName)
    {
        if(_filename)
            CoTaskMemFree(_filename);
        _filename=NULL;

        if(pName) {
            _filename = (LPWSTR) OLESTRDuplicate(pName);
            if(!_filename) 
                return E_OUTOFMEMORY;
        }
        else
            _filename = NULL;
        return S_OK;
    }

    HRESULT SetMimeType(LPCWSTR pName)
    {
        if(_mimetype) 
            CoTaskMemFree(_mimetype);
        _mimetype=NULL;
        if(pName) {
            _mimetype = (LPWSTR) OLESTRDuplicate(pName);
            if(!_mimetype) 
                return E_OUTOFMEMORY;
        }
        else
            _mimetype = NULL;
        return S_OK;
    }

    HRESULT SetUrl(LPCWSTR pName)
    {
        if(_url) 
            CoTaskMemFree(_url);
        _url=NULL;
        if(pName) {
            _url = (LPWSTR) OLEURLDuplicate(pName);
            if(!_url) 
                return E_OUTOFMEMORY;
        }
        else
            _url = NULL;
        return S_OK;
    }

    HRESULT SetClass(LPCWSTR pName)
    {
        if(_class) 
            CoTaskMemFree(_class);
        if(pName) {
            _class = (LPWSTR) OLESTRDuplicate(pName);
            if(!_class) 
                return E_OUTOFMEMORY;
        }
        else
            _class = NULL;
        return S_OK;
    }

    HRESULT SetExplorer(IUnknown* pExplorer)
    {
        if (pExplorer)
        {
            pExplorer->AddRef();
        }
        if (_pExplorer)
        {
            _pExplorer->Release();
        }
        _pExplorer = pExplorer;
        return S_OK;
    }

    HRESULT InitializeSecurityManager()
    {
        HRESULT hr = S_OK;
        if(_pSecurityManager == NULL) {
            hr = CoInternetCreateSecurityManager(NULL,
                                                 &_pSecurityManager,
                                                 0);
            if(FAILED(hr)) return hr;
        }

        if(_pZoneManager == NULL) {
            hr = CoInternetCreateZoneManager(NULL,
                                             &_pZoneManager,
                                             0);
        }
        return hr;
    }
    
    HRESULT CorLoad::ProcessAction();
    HRESULT KeepMessagePumpAlive(BOOL bKeep);

    CorLoad(IUnknown* pUnknownOut = NULL)
        : CUnknown(pUnknownOut)
    {
        _pProt = NULL;
        _pProtSnk = NULL;
        _pBindInfo = NULL;
        _pBSC = NULL;
        _pBindCtx = NULL;
        _pExplorer = NULL;

        _url = NULL;
        _filename = NULL;
        _mimetype = NULL;

        _class = NULL;
        _pSecurityManager = NULL;
        _pZoneManager = NULL;
        _pHostSecurityManager = NULL;
        _fObjectTag = TRUE;
        
        _fSetClientSite = FALSE;
        _fActivated = FALSE;
        _fFullyAvailable = TRUE;
    }

    ~CorLoad()
    {
        SetBindStatusCallback(NULL);
        SetBindCtx(NULL);
        SetProtocolSink(NULL);
        SetProtocol(NULL);
        SetIOInetBindInfo(NULL);
        SetFilename(NULL);
        SetMimeType(NULL);
        SetUrl(NULL);
        SetClass(NULL);
        SetExplorer(NULL);
    };


private:    
    IOInetProtocol       *_pProt;            // the prot the filter reads from
    IOInetProtocolSink   *_pProtSnk;         // the prot report progress 
    IOInetBindInfo       *_pBindInfo;        // the prot report progress 
    IBindStatusCallback  *_pBSC;             // Final Clients status callback
    IBindCtx             *_pBindCtx;         // Final Clients bind context
    IUnknown             *_pExplorer; 

    BOOL                 _fObjectTag;        // Do we have an object tag
    BOOL                 _fSetClientSite;    // 
    BOOL                 _fActivated;        // 
    BOOL                 _fFullyAvailable;   //
    
    IInternetSecurityManager    *_pSecurityManager;
    IInternetZoneManager        *_pZoneManager;
    IInternetHostSecurityManager *_pHostSecurityManager;
    LPWSTR              _url;
    LPWSTR              _filename;
    LPWSTR              _mimetype;
    LPWSTR              _class;
};    



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corfltr\util.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorFltr
//
// Implementation of COR MIME filter
//
//*****************************************************************************
#ifndef _CORUTIL_H
#define _CORUTIL_H

extern LPWSTR OLESTRDuplicate(LPCWSTR ws);
extern LPWSTR OLEURLDuplicate(LPCWSTR ws);

inline BOOL IsSafeURL(LPCWSTR wszUrl)
{
       if (wszUrl == NULL)
       	return FALSE;
       	
	LPCWSTR wszAfterProt=wcsstr(wszUrl,L"://");
	if (wszAfterProt == NULL)
		return FALSE;

	wszAfterProt+=3;

	LPCWSTR wszAfterHost=wcschr(wszAfterProt,L'/');
	if (wszAfterHost == NULL)
		wszAfterHost=wszAfterProt+wcslen(wszAfterProt)+1;

	LPCWSTR wszTest=NULL;
	wszTest=wcschr(wszAfterProt,L'@');

	if (wszTest != NULL && wszTest < wszAfterHost)
		return FALSE;

	wszTest=wcschr(wszAfterProt,L'%');

	if (wszTest != NULL && wszTest < wszAfterHost)
		return FALSE;
	
	wszTest=wcschr(wszAfterProt,L'\\');

	if (wszTest != NULL && wszTest < wszAfterHost)
		return FALSE;

	return TRUE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\checkmanagedfilewithuser.cpp ===
#include "stdpch.h"
#include "corpolicyp.h"
#include "corperm.h"
#include "corperme.h"
#include "DebugMacros.h"
#include "mscoree.h"
#include "corhlpr.h"

// {7D9B5E0A-1219-4147-B2E5-6DFD40B7D90D}
#define CLRWVT_POLICY_PROVIDER \
{ 0x7d9b5e0a, 0x1219, 0x4147, { 0xb2, 0xe5, 0x6d, 0xfd, 0x40, 0xb7, 0xd9, 0xd } }

HRESULT STDMETHODCALLTYPE
CheckManagedFileWithUser(IN LPWSTR pwsFileName,
                         IN LPWSTR pwsURL,
                         IN IInternetZoneManager* pZoneManager,
                         IN LPCWSTR pZoneName,
                         IN DWORD  dwZoneIndex,
                         IN DWORD  dwSignedPolicy,
                         IN DWORD  dwUnsignedPolicy)
{
    HRESULT hr = S_OK;

    GUID gV2 = COREE_POLICY_PROVIDER;
    COR_POLICY_PROVIDER      sCorPolicy;

    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;

    // Set up the COR trust provider
    memset(&sCorPolicy, 0, sizeof(COR_POLICY_PROVIDER));
    sCorPolicy.cbSize = sizeof(COR_POLICY_PROVIDER);

    // Set up the winverify provider structures
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
    
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = NULL;
    sWTFI.pcwszFilePath = pwsURL;
    sWTFI.hFile         = WszCreateFile(pwsFileName,
                                        GENERIC_READ,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_READONLY,
                                        0);
    
    if(sWTFI.hFile) {
        sWTD.cbStruct       = sizeof(WINTRUST_DATA);
        sWTD.pPolicyCallbackData = &sCorPolicy;  // Add in the cor trust information!!
        sWTD.dwUIChoice     = WTD_UI_ALL;        // No bad UI is overridden in COR TRUST provider
        sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
        sWTD.pFile          = &sWTFI;
        
        sCorPolicy.pZoneManager = pZoneManager;
        sCorPolicy.pwszZone = pZoneName;
        sCorPolicy.dwActionID = dwSignedPolicy;
        sCorPolicy.dwUnsignedActionID = dwUnsignedPolicy;
        sCorPolicy.dwZoneIndex = dwZoneIndex;
        
#ifdef _RAID_15982

        // WinVerifyTrust will load SOFTPUB.DLL, which will fail on German version
        // of NT 4.0 SP 4.
        // This failure is caused by a dll address conflict between NTMARTA.DLL and
        // OLE32.DLL.
        // This failure is handled gracefully if we load ntmarta.dll and ole32.dll
        // ourself. The failure will cause a dialog box to popup if SOFTPUB.dll 
        // loads ole32.dll for the first time.
        
        // This work around needs to be removed once this issiue is resolved by
        // NT or OLE32.dll.
        
        HMODULE module = WszLoadLibrary(L"OLE32.DLL");
        
#endif
        WCHAR  pBuffer[_MAX_PATH];
        DWORD  size = 0;
        hr = GetCORSystemDirectory(pBuffer,
                                   _MAX_PATH,
                                   &size);
        if(SUCCEEDED(hr)) {
            WCHAR dllName[] = L"mscorsec.dll";
            CQuickString fileName;

            fileName.ReSize(size + sizeof(dllName)/sizeof(WCHAR) + 1);
            wcscpy(fileName.String(), pBuffer);
            wcscat(fileName.String(), dllName);

            HMODULE mscoree = WszLoadLibrary(fileName.String());
            if(mscoree) {
                // This calls the msclrwvt.dll to the policy check
                hr = WinVerifyTrust(GetFocus(), &gV2, &sWTD);
                
                if(sCorPolicy.pbCorTrust) {
                    FreeM(sCorPolicy.pbCorTrust);
                }

                FreeLibrary(mscoree);
            }
        }
        
#ifdef _RAID_15982

        if (module != NULL)
            FreeLibrary( module );

#endif

        CloseHandle(sWTFI.hFile);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\coree.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"

/*++

Module Name:

    cortest.cpp

Abstract:

    Corpolicy provides ActiveX policy for code download. This call
    back provides policies based on publishers instead of zones.

--*/

#include <wintrust.h>
#include <mssip.h>
#include <softpub.h>
#include <urlmon.h>
#include "CorPerm.h"
#include "CorPermE.h"
#include "CorPolicyP.h"
#include "PerfCounters.h"

COUNTER_ONLY(PERF_COUNTER_TIMER_PRECISION g_TimeInSignatureAuthenticating = 0);
COUNTER_ONLY(UINT32 g_NumSecurityChecks=0);

#define _RAID_15982


//
// PRIVATE METHOD. Loads the attribute information of a signer.
//
HRESULT 
GetSignerInfo(CorAlloc* pManager,                   // Memory Manager
              PCRYPT_PROVIDER_SGNR pSigner,         // Signer we are examining
              PCRYPT_PROVIDER_DATA pProviderData,   // Information about the WVT provider used
              PCOR_TRUST pTrust,                    // Collected information that is returned to caller
              BOOL* pfCertificate,                   // Is the certificate valid
              PCRYPT_ATTRIBUTE* ppCorAttr,           // The Cor Permissions
              PCRYPT_ATTRIBUTE* ppActiveXAttr)       // The Active X permissions
{
    HRESULT hr = S_OK;
    
    if(pManager == NULL ||
       pSigner == NULL ||
       pProviderData == NULL ||
       pTrust == NULL ||
       pfCertificate == NULL ||
       ppCorAttr == NULL ||
       ppActiveXAttr == NULL) 
        return E_INVALIDARG;

    BOOL fCertificate = FALSE;
    PCRYPT_ATTRIBUTE pCorAttr = NULL;
    PCRYPT_ATTRIBUTE pActiveXAttr = NULL;
    
    CORTRY {

        *pfCertificate = FALSE;
        *ppCorAttr = NULL;
        *ppActiveXAttr = NULL;

        // Clean up from last one
        CleanCorTrust(pManager,
                      pProviderData->dwEncoding,
                      pTrust);
        
        // Set the encoding type, Currently we only support ASN
        pTrust->dwEncodingType = (pProviderData->dwEncoding ? pProviderData->dwEncoding : CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING);
        
        if(pSigner->dwError == S_OK) { // No error on the signature
            // Check to see if we have a certificate (all certificates have auth. attr)
            _ASSERTE(pSigner->psSigner); // We should have a signer
            if(pSigner->psSigner->AuthAttrs.cAttr && 
               pSigner->psSigner->AuthAttrs.rgAttr) {
                
                // Note that we have the signer
                fCertificate = TRUE;
                
                // Set the signer information in the return structrure
                _ASSERTE(pSigner->csCertChain && pSigner->pasCertChain);
                CRYPT_PROVIDER_CERT* mySigner = WTHelperGetProvCertFromChain(pSigner,
                                                                             0);

                pTrust->pbSigner = mySigner->pCert->pbCertEncoded;
                pTrust->cbSigner = mySigner->pCert->cbCertEncoded;;

                // Determine if we have Cor Permissions or  ActiveX permissions
                pCorAttr = CertFindAttribute(COR_PERMISSIONS,
                                             pSigner->psSigner->AuthAttrs.cAttr,
                                             pSigner->psSigner->AuthAttrs.rgAttr);

                if(pCorAttr) {
                    DWORD dwEncoding = 0;
                    CryptEncodeObject(pTrust->dwEncodingType,
                                      PKCS_ATTRIBUTE,
                                      pCorAttr,
                                      NULL,
                                      &dwEncoding);
                    if(dwEncoding == 0) CORTHROW(Win32Error());
                
                    // Alloc a buffer to hold the raw binary permission
                    // data.
                    pTrust->pbCorPermissions = (PBYTE) pManager->jMalloc(dwEncoding); 
                    if(pTrust->pbCorPermissions == NULL) CORTHROW(E_OUTOFMEMORY);
                
                    if(!CryptEncodeObject(pTrust->dwEncodingType,
                                          PKCS_ATTRIBUTE,
                                          pCorAttr,
                                          pTrust->pbCorPermissions,
                                          &dwEncoding))
                        CORTHROW(Win32Error());
                    pTrust->cbCorPermissions = dwEncoding;
                }

                // Look for the encoded active x permission. If it is, then it will
                // ask for all permissions. There is no granularity on the permissions because
                // it is not possible to enforce the permissions.
                pActiveXAttr = CertFindAttribute(ACTIVEX_PERMISSIONS,
                                                 pSigner->psSigner->AuthAttrs.cAttr,
                                                 pSigner->psSigner->AuthAttrs.rgAttr);
                
            }
        }
        *pfCertificate = fCertificate;
        *ppCorAttr = pCorAttr;
        *ppActiveXAttr = pActiveXAttr;
    } 
    CORCATCH(err) {
        hr = err.corError;
    } COREND;

    return hr;
}


//
// PRIVATE FUNCTION. WVT allows access to providers by obtaining function pointers.
// The display function is used for the authenticode certificate.
//
HRESULT 
LoadWintrustFunctions(CRYPT_PROVIDER_FUNCTIONS* pFunctions)
{
    if(pFunctions == NULL) return E_INVALIDARG;

    GUID gV2      = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    pFunctions->cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);
    if(WintrustLoadFunctionPointers(&gV2,
                                    pFunctions))
        return S_OK;
    else
        return E_FAIL;
}

//
// Creates a return structure out of WVT. The caller of the 
// WVT function is responsible for freeing the data. It is allocated in a
// single block. The pointer to the structure is the only pointer that can be
// freed.
//
HRESULT BuildReturnStructure(IN PCorAlloc pManager,
                             IN PCOR_TRUST pSource,
                             OUT PCOR_TRUST* ppTrust,
                             OUT DWORD* pdwReturnLength)
{
    HRESULT hr = S_OK;
    PCOR_TRUST pTrust = NULL;
    DWORD dwReturnLength = 0;
    DWORD dwZoneLength = 0;

    if(pManager == NULL || 
       pSource == NULL ||
       ppTrust == NULL ||
       pdwReturnLength == NULL)
        return E_INVALIDARG;


    CORTRY {
        // Initialize the routines
        *pdwReturnLength = 0;
        *ppTrust = NULL;

        //////////////////////////////////////////////////////////////
        // Build up the response (we return it for failure or success)
        // Calculate the size of the returned data and allocate it
        // Get the zone length
        if(pSource->pwszZone)
            dwZoneLength = (lstrlenW(pSource->pwszZone)+1) * sizeof(WCHAR);
        
        // Calculate the total size
        dwReturnLength = sizeof(COR_TRUST) + 
            pSource->cbCorPermissions + 
            pSource->cbSigner +
            dwZoneLength;

        // Create the space
        pTrust = (PCOR_TRUST) pManager->jMalloc(dwReturnLength); // Needs to be CoTaskMemAlloc
        if(pTrust == NULL) CORTHROW(E_OUTOFMEMORY);
        ZeroMemory(pTrust, dwReturnLength);

        // Start pointer to structure
        PBYTE ptr = (PBYTE) pTrust;
        ptr += sizeof(COR_TRUST);

        // Roll the response
        pTrust->cbSize = sizeof(COR_TRUST);
        pTrust->flag = 0;
        pTrust->dwEncodingType = pSource->dwEncodingType;
        pTrust->hVerify = TRUST_E_FAIL;
        
        // Lay in the cor permissions
        if(pSource->pbCorPermissions) {
            pTrust->pbCorPermissions = ptr;
            pTrust->cbCorPermissions = pSource->cbCorPermissions;
            memcpy(ptr, pSource->pbCorPermissions, pSource->cbCorPermissions);
            ptr += pSource->cbCorPermissions;
        }

        // Lay in the signature
        if(pSource->pbSigner) {
            pTrust->pbSigner = ptr;
            pTrust->cbSigner = pSource->cbSigner;
            memcpy(ptr, pSource->pbSigner, pSource->cbSigner);
            ptr += pSource->cbSigner;
        }

        // Add in flags
        //pTrust->fIndividualCertificate = fIndividualCertificate;
        pTrust->fAllPermissions = pSource->fAllPermissions;
        pTrust->fAllActiveXPermissions = pSource->fAllActiveXPermissions;

        // Copy the zone information over
        if(pSource->pwszZone) {
            pTrust->pwszZone = (LPWSTR) ptr;
            pTrust->guidZone = pSource->guidZone;
            memcpy(ptr, pSource->pwszZone, dwZoneLength);
            ptr += dwZoneLength;
        }

        *ppTrust = pTrust;
        *pdwReturnLength = dwReturnLength;
    }
    CORCATCH(err) {
        hr = err.corError;
    } COREND;

    return hr;
}

//
// PRIVATE FUNCTION.  Cleans up information about a signer. 
//  
HRESULT 
CleanCorTrust(CorAlloc* pAlloc,
              DWORD dwEncodingType,
              PCOR_TRUST pTrust)
{
    if(pAlloc == NULL ||
       pTrust == NULL)
        return E_INVALIDARG;

    if(pTrust->pbCorPermissions)
        pAlloc->jFree(pTrust->pbCorPermissions);
    ZEROSTRUCT(*pTrust);
    pTrust->dwEncodingType = dwEncodingType;
    pTrust->cbSize = sizeof(COR_TRUST);
        
    return S_OK;
}

HRESULT UnsignedUI(PCRYPT_PROVIDER_DATA pProviderData,
                   PCOR_POLICY_PROVIDER pCor)
                   
{
    HRESULT hr = S_OK;

    switch(pCor->dwUnsignedActionID)
    {
    case URLPOLICY_QUERY:
        {
            DWORD dwState = COR_UNSIGNED_NO;
            LPCWSTR pURL = pProviderData->pWintrustData->pFile->pcwszFilePath;
            HWND hwnd = pProviderData->hWndParent ? pProviderData->hWndParent : GetFocus();
            hr = DisplayUnsignedRequestDialog(hwnd,
                                              pProviderData,
                                              pURL,
                                              pCor->pwszZone,
                                              &dwState);
            if(FAILED(hr) && hr != TRUST_E_SUBJECT_NOT_TRUSTED)
                dwState &= ~COR_UNSIGNED_ALWAYS;

            if(dwState & COR_UNSIGNED_ALWAYS) {
                DWORD cbPolicy = sizeof(DWORD);
                DWORD pbPolicy[1];
                if(dwState & COR_UNSIGNED_YES) 
                    pbPolicy[0] = URLPOLICY_ALLOW;
                else 
                    pbPolicy[0] = URLPOLICY_DISALLOW;

                // Reset the policy, if we fail then we are fail the download
                if(FAILED(((IInternetZoneManager*) 
                          (pCor->pZoneManager))->SetZoneActionPolicy(pCor->dwZoneIndex,
                                                                     URLACTION_MANAGED_UNSIGNED,                     
                                                                     (PBYTE) pbPolicy,
                                                                     cbPolicy,
                                                                     URLZONEREG_HKCU)))
                    hr = TRUST_E_SUBJECT_NOT_TRUSTED;
            }

            break;
        }
    case URLPOLICY_ALLOW:
        break;
    case URLPOLICY_DISALLOW:
        hr = TRUST_E_SUBJECT_NOT_TRUSTED;
        break;
    }
    return hr;
}

HRESULT 
CorUI(PCRYPT_PROVIDER_DATA pProviderData,          // WVT policy Data
      PCOR_POLICY_PROVIDER pCor,                   // Cor information
      PCOR_TRUST pTrust,                           // Cor information
      CRYPT_PROVIDER_FUNCTIONS* psFunctions);      // WVT function table

extern "C" 
HRESULT WINAPI 
CORPolicyEE(PCRYPT_PROVIDER_DATA pProviderData)
{
    HRESULT hr = S_OK;
    HRESULT fCoInitialized = -1;
 
    // Check to see if the information is available.
    _ASSERTE(pProviderData);
    _ASSERTE(pProviderData->pWintrustData);
    
    if(pProviderData->pWintrustData->pPolicyCallbackData == NULL)
        return E_INVALIDARG;

    PCOR_POLICY_PROVIDER pCor = (PCOR_POLICY_PROVIDER) pProviderData->pWintrustData->pPolicyCallbackData;
    
    // Returned in client data
    COR_TRUST  sTrust;
    ZEROSTRUCT(sTrust);

    // Used to build returned structure
    PCOR_TRUST pResult = NULL;
    DWORD dwReturnLength = 0;
    DWORD dwStatusFlag = S_OK;
    BOOL fCertificate = FALSE;   

    // Set up the memory model for the oss 
    CorAlloc sAlloc;
    sAlloc.jMalloc = MallocM;
    sAlloc.jFree = FreeM;
    
    // Get the standard provider functions
    CRYPT_PROVIDER_FUNCTIONS sFunctions;
    ZEROSTRUCT(sFunctions);

    CORTRY {
        // Initialize output
        pCor->pbCorTrust = NULL;
        pCor->cbCorTrust = 0;

        // If we failed then there is badness in the DLL's
        hr = LoadWintrustFunctions(&sFunctions);
        if(hr != S_OK) CORTHROW(S_OK);

        // Do we hava a file from which to retrieve the certificate and to do the download on?
        if(pProviderData->pPDSip == NULL) 
            CORTHROW(CRYPT_E_FILE_ERROR);

        dwStatusFlag = pProviderData->dwError;
        for(DWORD ii = TRUSTERROR_STEP_FINAL_WVTINIT; ii < pProviderData->cdwTrustStepErrors && dwStatusFlag == S_OK; ii++) 
            dwStatusFlag = pProviderData->padwTrustStepErrors[ii];

        DWORD fSuccess = FALSE;
        DWORD dwSigners = pProviderData->csSigners;

#if DBG
        if(dwSigners) _ASSERTE(pProviderData->pasSigners);
#endif

            // Cycle through all the signers until we have one that is successful.
        if(pProviderData->pasSigners) { // check againest incompatible DLL's
            for(DWORD i = 0; i < dwSigners && fSuccess == FALSE; i++) { 
                CRYPT_PROVIDER_SGNR* signer = WTHelperGetProvSignerFromChain(pProviderData,
                                                                             i,
                                                                             FALSE,
                                                                             0);

                PCRYPT_ATTRIBUTE pCorAttr = NULL;
                PCRYPT_ATTRIBUTE pActiveXAttr = NULL;

                // Go and the signer information, we are looking for the signer information
                // and whether there are CorEE or ActiveX authenticated attributes on the
                // signature
                hr = GetSignerInfo(&sAlloc,
                                   signer,
                                   pProviderData,
                                   &sTrust,
                                   &fCertificate,
                                   &pCorAttr,
                                   &pActiveXAttr);
                if(hr == S_OK) {
                    fSuccess = TRUE; // Found a certificate
                }
            }
        }           

        if(fSuccess == FALSE) {
            CleanCorTrust(&sAlloc,
                          pProviderData->dwEncoding,
                          &sTrust);

            if(pProviderData->pWintrustData->dwUIChoice != WTD_UI_NONE) {
                hr = UnsignedUI(pProviderData,
                                pCor);
            }
        }
        else {
            hr = CorUI(pProviderData,
                       pCor,
                       &sTrust,
                       &sFunctions);   // No text for now
        }
    }
    CORCATCH(err) {
        hr = err.corError;
    } COREND;
    
    // Build up the return information, this is allocated as 
    // a single block of memory using LocalAlloc().
    HRESULT hr2 = BuildReturnStructure(&sAlloc,
                                       &sTrust,
                                       &pResult,
                                       &dwReturnLength);
    if(SUCCEEDED(hr2)) {
        if(dwStatusFlag) 
            pResult->hVerify = dwStatusFlag;
        else {
            // If no error then set the return value to the
            // return code (S_OK or TRUST_E_SUBJECT_NOT_TRUSTED)
            if(sTrust.hVerify == S_OK)
                pResult->hVerify = hr;  
            else
                pResult->hVerify = sTrust.hVerify;
        }
    }
    else {
        hr = hr2;
    }

    pCor->pbCorTrust = pResult;
    pCor->cbCorTrust = dwReturnLength;
    
    // Free up com
    if(fCoInitialized == S_OK) CoUninitialize();

    // Free up encoded space
    if(sTrust.pbCorPermissions) FreeM(sTrust.pbCorPermissions);

    return hr;
}

HRESULT 
CorUI(PCRYPT_PROVIDER_DATA pProviderData,
      PCOR_POLICY_PROVIDER pCor,
      PCOR_TRUST pTrust,
      CRYPT_PROVIDER_FUNCTIONS* psFunctions)
{
    HRESULT hr = S_OK;
    BOOL fUIDisplayed = FALSE;
    DWORD dwUrlPolicy = URLPOLICY_DISALLOW;
    DWORD dwClientsChoice = pProviderData->pWintrustData->dwUIChoice;
    LPCWSTR pURL = pProviderData->pWintrustData->pFile->pcwszFilePath;

    if(pProviderData->pWintrustData->dwUIChoice != WTD_UI_NONE) {
        switch(pCor->dwActionID) {
        case URLPOLICY_QUERY:
            pProviderData->pWintrustData->dwUIChoice = WTD_UI_ALL | WTD_UI_NOBAD;
            fUIDisplayed = TRUE;
            break;
        case URLPOLICY_ALLOW:
        case URLPOLICY_DISALLOW:
            pProviderData->pWintrustData->dwUIChoice = WTD_UI_NONE;
            break;
        }
    }
    hr = psFunctions->pfnFinalPolicy(pProviderData);
    if(fUIDisplayed == FALSE) pTrust->flag |= COR_NOUI_DISPLAYED;

    // If we never wanted any UI then return.
    if(dwClientsChoice == WTD_UI_NONE)
        return hr;

    if(FAILED(hr) && hr != TRUST_E_SUBJECT_NOT_TRUSTED) {
        hr = UnsignedUI(pProviderData, 
                        pCor);
    }

    return hr;
}
    
HRESULT STDMETHODCALLTYPE
GetPublisher(IN LPWSTR pwsFileName,      // File name, this is required even with the handle
             IN HANDLE hFile,            // Optional file name
             IN DWORD  dwFlags,          // COR_NOUI or COR_NOPOLICY
             OUT PCOR_TRUST *pInfo,      // Returns a PCOR_TRUST (Use FreeM)
             OUT DWORD      *dwInfo)     // Size of pInfo.                           
{
    HRESULT hr = S_OK;

    // Perf Counter "%Time in Signature authenticating" support
    COUNTER_ONLY(PERF_COUNTER_TIMER_START());


    GUID gV2 = COREE_POLICY_PROVIDER;
    COR_POLICY_PROVIDER      sCorPolicy;

    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;

    // Set up the COR trust provider
    memset(&sCorPolicy, 0, sizeof(COR_POLICY_PROVIDER));
    sCorPolicy.cbSize = sizeof(COR_POLICY_PROVIDER);

    // Set up the winverify provider structures
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
    
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = hFile;
    sWTFI.pcwszFilePath = pwsFileName;
    

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.pPolicyCallbackData = &sCorPolicy; // Add in the cor trust information!!
    if(dwFlags & COR_NOUI)
        sWTD.dwUIChoice     = WTD_UI_NONE;        // No bad UI is overridden in COR TRUST provider
    else
        sWTD.dwUIChoice     = WTD_UI_ALL;        // No bad UI is overridden in COR TRUST provider
    sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
    sWTD.pFile          = &sWTFI;

    // Set the policies for the VM (we have stolen VMBased and use it like a flag)
    if(dwFlags) 
        sCorPolicy.VMBased = dwFlags;

    CoInitializeEE(COINITEE_DEFAULT);
    
#ifdef _RAID_15982

    // WinVerifyTrust will load SOFTPUB.DLL, which will fail on German version
    // of NT 4.0 SP 4.
    // This failure is caused by a dll address conflict between NTMARTA.DLL and
    // OLE32.DLL.
    // This failure is handled gracefully if we load ntmarta.dll and ole32.dll
    // ourself. The failure will cause a dialog box to popup if SOFTPUB.dll 
    // loads ole32.dll for the first time.

    // This work around needs to be removed once this issiue is resolved by
    // NT or OLE32.dll.

    HMODULE module = WszLoadLibrary(L"OLE32.DLL");

#endif

    // This calls the corpol.dll to the policy check
    hr = WinVerifyTrust(GetFocus(), &gV2, &sWTD);

    CoUninitializeEE(FALSE);

    *pInfo  = sCorPolicy.pbCorTrust;
    *dwInfo = sCorPolicy.cbCorTrust;

#if defined(ENABLE_PERF_COUNTERS)
    PERF_COUNTER_TIMER_STOP(g_TimeInSignatureAuthenticating);

    // Update the perfmon location only after NUM_OF_ITERATIONS
    if (g_NumSecurityChecks++ > PERF_COUNTER_NUM_OF_ITERATIONS)
    {
        GetGlobalPerfCounters().m_Security.timeAuthorize += g_TimeInSignatureAuthentication;
        GetPrivatePerfCounters().m_Security.timeAuthorize += g_TimeInSignatureAuthentication;
        g_TimeInSignatureAuthentication = 0;
        g_NumSecurityChecks = 0;
    }
#endif

#ifdef _RAID_15982

    if (module != NULL)
        FreeLibrary( module );

#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\registry.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//
// Registry.cpp
//
// This has temporary help functions for COM part of this module
//
//*****************************************************************************
#include "stdpch.h"

#include <objbase.h>
#include <assert.h>
#include "UtilCode.h"
#include "Registry.h"
#include "CorPermP.h"
#include "Mscoree.h"
#include <__file__.ver>

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       LPCWSTR wszFriendlyName, 
                       LPCWSTR wszProgID,       
                       LPCWSTR wszClassID,
                       HINSTANCE hInst,
                       int version)       
{
    HRESULT hr = S_OK;

    // Get server location.
    WCHAR wszModule[_MAX_PATH] ;
    DWORD dwResult =
        ::WszGetModuleFileName(hModule, 
                               wszModule,
                               ARRAYSIZE(wszModule)) ;

    if (dwResult== 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
	 if (SUCCEEDED(hr)) // GetLastError doesn't always do what we'd like
	     hr = E_FAIL;
	 return (hr);
    }
    
    // Get the version of the runtime
    if(SUCCEEDED(hr))
    {
        hr = REGUTIL::RegisterCOMClass(clsid,
                                       wszFriendlyName,
                                       wszProgID,
                                       version,
                                       wszClassID,
                                       L"Both",
                                       wszModule,
                                       hInst,
                                       NULL,
                                       VER_SBSFILEVERSION_WSTR,
                                       true,
                                       false);
    }
    return hr;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      LPCWSTR wszProgID,           // Programmatic
                      LPCWSTR wszClassID,          // Class
                      int version) 
{
    LONG hr = S_OK;

    // Get server location.
    // Convert the CLSID into a char.
    hr = REGUTIL::UnregisterCOMClass(clsid,
                                  wszProgID,
                                  version,
                                  wszClassID,
                                  true);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\cfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CFactory.cpp
//
// Base class for reusing a single class factory for
// all components in a DLL
//
//
//*****************************************************************************
#include "stdpch.h"

#include <objbase.h>

#include "Registry.h"
#include "CFactory.h"
#include "CorPermP.h"

///////////////////////////////////////////////////////////
//
// Static variables
//
LONG CFactory::s_cServerLocks = 0 ;    // Count of locks

///////////////////////////////////////////////////////////
//
// CFactory implementation
//

CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
    m_pFactoryData = pFactoryData ;
}


//
// IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{   
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        pI = this ; 
    }
    else
    {
       *ppv = NULL;
        return E_NOINTERFACE;
    }
    pI->AddRef() ;
    *ppv = pI ;
    return S_OK;
}

ULONG __stdcall CFactory::AddRef() 
{ 
    return ::InterlockedIncrement(&m_cRef) ; 
}

ULONG __stdcall CFactory::Release() 
{
    if (::InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this; 
        return 0 ;
    }   
    return m_cRef;
}

//
// IClassFactory implementation
//

HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{

    // Aggregate only if the requested IID is IID_IUnknown.
    if ((pUnknownOuter != NULL) && (iid != IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create the component.
    CUnknown* pNewComponent ;
    HRESULT hr = m_pFactoryData->CreateInstance(pUnknownOuter,
                                                &pNewComponent) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    // Initialize the component.
    hr = pNewComponent->Init();
    if (FAILED(hr))
    {
        // Initialization failed.  Release the component.
        pNewComponent->NondelegatingRelease() ;
        return hr ;
    }
    
    // Get the requested interface.
    hr = pNewComponent->NondelegatingQueryInterface(iid, ppv) ;

    // Release the reference held by the class factory.
    pNewComponent->NondelegatingRelease() ;
    return hr ;   
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
    if (bLock) 
    {
        ::InterlockedIncrement(&s_cServerLocks) ; 
    }
    else
    {
        ::InterlockedDecrement(&s_cServerLocks) ;
    }
    // If this is an out-of-proc server, check to see
    // whether we should shut down.
    CloseExe() ;  //@local

    return S_OK ;
}


///////////////////////////////////////////////////////////
//
// GetClassObject
//   - Create a class factory based on a CLSID.
//
HRESULT CFactory::GetClassObject(const CLSID& clsid, 
                                 const IID& iid, 
                                 void** ppv)
{
    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
    {
        return E_NOINTERFACE ;
    }

    // Traverse the array of data looking for this class ID.
    for (int i = 0; i < g_cFactoryDataEntries; i++)
    {
        const CFactoryData* pData = &g_FactoryDataArray[i] ;
        if (pData->IsClassID(clsid))
        {

            // Found the ClassID in the array of components we can
            // create. So create a class factory for this component.
            // Pass the CFactoryData structure to the class factory
            // so that it knows what kind of components to create.
            *ppv = (IUnknown*) new CFactory(pData) ;
            if (*ppv == NULL)
            {
                return E_OUTOFMEMORY ;
            }
            return NOERROR ;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE ;
}

//
// Determine if the component can be unloaded.
//
HRESULT CFactory::CanUnloadNow()
{
    if (CUnknown::ActiveComponents() || IsLocked())
    {
        return S_FALSE ;
    }
    else
    {
        return S_OK ;
    }
}

//
// Register all components.
//
HRESULT CFactory::RegisterAll(HINSTANCE hInst)
{
    for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
    {
        RegisterServer(GetModule(),
                       *(g_FactoryDataArray[i].m_pCLSID),
                       g_FactoryDataArray[i].m_RegistryName,
                       g_FactoryDataArray[i].m_wszProgID, 
                       g_FactoryDataArray[i].m_wszClassID,
                       hInst,
                       g_FactoryDataArray[i].m_version
                       ) ;
    }
    return S_OK ;
}   
    
HRESULT CFactory::UnregisterAll()
{
    for(int i = 0 ; i < g_cFactoryDataEntries ; i++)   
    {
        UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
                         g_FactoryDataArray[i].m_wszProgID, 
                         g_FactoryDataArray[i].m_wszClassID,
                         g_FactoryDataArray[i].m_version
                         ) ;
    }
    return S_OK ;
}

//
// Get class factory
//
STDAPI DllGetClassObjectInternal(const CLSID& clsid,
                                 const IID& iid,
                                 void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

HRESULT WINAPI
CorFactoryRegister(HINSTANCE hInst)
{
    return CFactory::RegisterAll(hInst);
}

HRESULT WINAPI
CorFactoryUnregister()
{
    return CFactory::UnregisterAll();
}

HRESULT WINAPI
CorFactoryCanUnloadNow()
{
    return CFactory::CanUnloadNow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\cunknown.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CUnknown.cpp 
//
// Implementation of IUnknown Base class
//
//*****************************************************************************
#include "stdpch.h"

#include "CUnknown.h"
#include "CFactory.h"

///////////////////////////////////////////////////////////
//
// Count of active objects
//   - Use to determine if we can unload the DLL.
//
long CUnknown::s_cActiveComponents = 0 ;


///////////////////////////////////////////////////////////
//
// Constructor
//
CUnknown::CUnknown(IUnknown* pUnknownOuter)
: m_cRef(1)
{
    // Set m_pUnknownOuter pointer.
    if (pUnknownOuter == NULL)
    {
        //trace("Not aggregating; delegate to nondelegating IUnknown.") ;
        m_pUnknownOuter = reinterpret_cast<IUnknown*>
                             (static_cast<INondelegatingUnknown*>
                             (this)) ;  // notice cast
    }
    else
    {
        //trace("Aggregating; delegate to outer IUnknown.") ;
        m_pUnknownOuter = pUnknownOuter ;
    }

    // Increment count of active components.
    ::InterlockedIncrement(&s_cActiveComponents) ;
}

//
// Destructor
//
CUnknown::~CUnknown()
{
    ::InterlockedDecrement(&s_cActiveComponents) ;

    // If this is an EXE server, shut it down.
    CFactory::CloseExe() ;
}

//
// FinalRelease - called by Release before it deletes the component
//
void CUnknown::FinalRelease()
{
    //trace("Increment reference count for final release.") ;
    m_cRef = 1 ;
}

//
// Nondelegating IUnknown
//   - Override to handle custom interfaces.
//
HRESULT __stdcall 
    CUnknown::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
    // CUnknown supports only IUnknown.
    if (iid == IID_IUnknown)
    {
        return FinishQI(reinterpret_cast<IUnknown*>
                           (static_cast<INondelegatingUnknown*>(this)),
                        ppv) ;
    }   
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
}

//
// AddRef
//
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

//
// Release
//
ULONG __stdcall CUnknown::NondelegatingRelease()
{
    InterlockedDecrement(&m_cRef) ;
    if (m_cRef == 0)
    {
        FinalRelease() ;
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

//
// FinishQI
//   - Helper function to simplify overriding
//     NondelegatingQueryInterface
//
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
    *ppv = pI ;
    pI->AddRef() ;
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\registry.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Registry.cpp
//
// Helper functions for registering my class
//
//*****************************************************************************

#ifndef __Registry_H
#define __Registry_H
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       LPCWSTR wszFriendlyName, 
                       LPCWSTR wszProgID,       
                       LPCWSTR wszClassID,
                       HINSTANCE hInst,
                       int version);

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      LPCWSTR wszProgID,           // Programmatic
                      LPCWSTR wszClassID,          // Class
                      int version);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\corsetup.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"

/*++

Module Name:

    cortest.cpp

Abstract:

    Corpolicy provides ActiveX policy for code download. This call
    back provides policies based on publishers instead of zones.

--*/

#include <wintrust.h>
#include <mssip.h>
#include <softpub.h>
#include <urlmon.h>
#include "CorPerm.h"
#include "CorPermP.h"
#include "CorPolicyP.h"

// Win2k defines a new policy provider that is not available on Win9x and NT4
// For now we'll use the old one.
#ifdef SP_POLICY_PROVIDER_DLL_NAME
#undef SP_POLICY_PROVIDER_DLL_NAME
#define SP_POLICY_PROVIDER_DLL_NAME L"SOFTPUB.DLL"
#endif

//
// Sets up the registration structure for WVT
//
void SetUpProvider(CRYPT_REGISTER_ACTIONID& sRegAID)
{
    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION;

    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;
}

STDAPI SetupCorEEPolicy(LPCWSTR pwsDLLName)
{
    GUID                            gV2 = COREE_POLICY_PROVIDER;
    CRYPT_REGISTER_ACTIONID         sRegAID;
    BOOL                            fRet;

    fRet = TRUE;


    SetUpProvider(sRegAID);
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = (LPWSTR) pwsDLLName;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = L"CORPolicyEE";

    //
    //  V2 Authenticode Verification Register Providers
    //
    fRet &= WintrustAddActionID(&gV2, 0, &sRegAID);
    if (fRet)
    {
        return(S_OK);
    }
    return(S_FALSE);
}

HRESULT WINAPI CorPermRegisterServer(LPCWSTR pwsDLLName)
{
    HRESULT hr;
    hr = SetupCorEEPolicy(pwsDLLName);
    return hr;
}

HRESULT WINAPI CorPermUnregisterServer(void)
{
    GUID    gV2Test = COREE_POLICY_PROVIDER;

    if (!(WintrustRemoveActionID(&gV2Test)))
    {
        return(S_FALSE);
    }
    
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\corsecc\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <CrtWrap.h>
#include <WinWrap.h>
#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <windef.h>
#include <limits.h>
#include <stdlib.h>
#include <objbase.h>
#include <float.h>

#include "cor.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)

#ifdef __cplusplus
extern "C" {
#endif

HINSTANCE GetModule();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\dochdrs\funchdr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Function:
//  
//  Synopsis:
//
//  Effects:
// 
//  Arguments:
//
//  Requires:
// 
//  Returns:
//
//  Signals:
//
//  Modifies:
// 
//  Derivation:
// 
//  Algorithm:
//
//  History:
// 
//  Notes:
// 
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\dochdrs\filehdr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  File:
//  
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\dochdrs\classhdr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  Class:
//
//  Purpose:
//
//  History:
//
//  Notes:
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\accountinginfostore.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Managing Accounting Information Store
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#define STRICT
#include "stdpch.h"
#include "AccountingInfoStore.h"

AccountingInfoStore::AccountingInfoStore(PersistedStore *ps)
    : m_ps(ps)
{
    memset(&m_aish, 0, sizeof(AIS_HEADER));
}

AccountingInfoStore::~AccountingInfoStore()
{
    if (m_ps)
    {
        m_ps->Close();
        delete m_ps;
    }
}

HRESULT AccountingInfoStore::Init()
{
    HRESULT     hr;
    PAIS_HEADER pAIS = NULL;
    PS_HANDLE   hAIS;

    LOCK(m_ps);

    hr = m_ps->Map();

    if (FAILED(hr))
        goto Exit;

    // Ignore hr
    m_ps->GetAppData(&hAIS);

    // Create Application Data
    if (hAIS == 0)
    {
        // Create the AIS_HEADER
        hr = m_ps->Alloc(sizeof(AIS_HEADER), (void **)&pAIS);

        if (FAILED(hr))
            goto Cleanup;

        hAIS = m_ps->PtrToHnd(pAIS);
		PS_DONE_USING_PTR(m_ps, pAIS);

        // Create Type table
        PSArrayTable tt(m_ps, 0);

        hr = tt.Create(
                AIS_TYPE_BUCKETS, 
                AIS_TYPE_RECS_IN_ROW,
                sizeof(AIS_TYPE),
                0);

        if (FAILED(hr))
            goto Cleanup;

        m_aish.hTypeTable = tt.GetHnd();

        // Create Accounting table
        PSGenericTable gt(m_ps, 0);

        hr = gt.Create(
                AIS_ROWS_IN_ACC_TABLE_BLOCK,
                sizeof(AIS_ACCOUNT),
                hAIS);

        if (FAILED(hr))
            goto Cleanup;

        m_aish.hAccounting = gt.GetHnd();

        // Create Type blob pool
        PSBlobPool bpt(m_ps, 0);

        hr = bpt.Create(
                AIS_TYPE_BLOB_POOL_SIZE,
                hAIS);

        if (FAILED(hr))
            goto Cleanup;

        m_aish.hTypeBlobPool = bpt.GetHnd();

        // Create instance blob pool
        PSBlobPool bpi(m_ps, 0);

        hr = bpi.Create(
                AIS_INST_BLOB_POOL_SIZE,
                hAIS);

        if (FAILED(hr))
            goto Cleanup;

        m_aish.hInstanceBlobPool = bpi.GetHnd();

        // Set the Application Data this store
        pAIS = (PAIS_HEADER) m_ps->HndToPtr(hAIS);

        memcpy(pAIS, &m_aish, sizeof(AIS_HEADER));
		PS_DONE_USING_PTR(m_ps, pAIS);

        m_ps->SetAppData(hAIS);
    }
    else
    {
        // Initialize the copy of the table offsets.
        pAIS = (PAIS_HEADER) m_ps->HndToPtr(hAIS);
        memcpy(&m_aish, pAIS, sizeof(AIS_HEADER));
		PS_DONE_USING_PTR(m_ps, pAIS);
    }

Cleanup:
    m_ps->Unmap();
    UNLOCK(m_ps);

Exit:
    return hr;
}

// Get the Type cookie and Instance table 
HRESULT AccountingInfoStore::GetType(
		PBYTE      pbType,      // Type Signature
		WORD       cbType,      // nBytes in Type Sig
		DWORD      dwHash,      // Hash of Type [Sig]
		DWORD     *pdwTypeID,   // [out] Type cookie
        PS_HANDLE *phInstTable) // [out] Instance table
{
    _ASSERTE(m_aish.hTypeTable);
    _ASSERTE(m_aish.hTypeBlobPool);

    HRESULT          hr = S_OK;
    WORD             wHash;
    DWORD            i;
    PS_HANDLE        hnd;
    PAIS_TYPE        pAIST;
    PPS_ARRAY_LIST   pAL;
    PPS_TABLE_HEADER pT;

    PSArrayTable tt(m_ps, m_aish.hTypeTable);   // Type table
    PSArrayTable it(m_ps, 0);                   // Instance table
    PSBlobPool   bp(m_ps, m_aish.hTypeBlobPool);// Type blob pool

    LOCK(m_ps);

    hr = m_ps->Map();

    if (FAILED(hr))
        goto Exit;

    pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_aish.hTypeTable);

    wHash = (WORD) (dwHash % pT->ArrayTable.wRows);

    hr = tt.HandleOfRow(wHash, &hnd); 

    if (FAILED(hr))
	{
		PS_DONE_USING_PTR(m_ps, pT);
        goto Cleanup;
	}

    pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hnd);

    _ASSERTE(pAL->dwValid <= pT->ArrayTable.wRecsInRow);

    do
    {
        pAIST = (PAIS_TYPE) &(pAL->bData);

        for (i=0; i<pAL->dwValid; ++i)
        {
#ifdef _DEBUG
            void *ptr = m_ps->HndToPtr(pAIST[i].hTypeBlob);
#endif

            if ((pAIST[i].wTypeBlobSize == cbType) && 
#ifdef _DEBUG
                (memcmp(ptr, pbType, cbType)
#else
                (memcmp(m_ps->HndToPtr(pAIST[i].hTypeBlob), pbType, cbType) 
#endif
                == 0))
            {
                *pdwTypeID = pAIST[i].dwTypeID;
				*phInstTable = pAIST[i].hInstanceTable;

			    PS_DONE_USING_PTR(m_ps, ptr);
			    PS_DONE_USING_PTR(m_ps, pAL);
			    PS_DONE_USING_PTR(m_ps, pT);

                goto Cleanup;
            }

            PS_DONE_USING_PTR(m_ps, ptr);
        }

        if (pAL->hNext != 0)
		{
			PS_DONE_USING_PTR_(m_ps, pAL);
            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(pAL->hNext);
		}
        else
            break;

    } while (1);

    PS_DONE_USING_PTR(m_ps, pAL);

    // Entry not found, create one.
    AIS_TYPE aist;

    memset(&aist, 0, sizeof(AIS_TYPE));
    aist.wTypeBlobSize = cbType;

    // pT is still valid.
    aist.dwTypeID = (DWORD) ++(pT->hAppData);    
	PS_DONE_USING_PTR(m_ps, pT);


    // Create the instance table
    it.Create(
        AIS_INST_BUCKETS,
        AIS_INST_RECS_IN_ROW,
        sizeof(AIS_INSTANCE),
        0);

    aist.hInstanceTable = it.GetHnd();

    // Add the type blob to the type blob table.
    bp.Insert(pbType, cbType, &aist.hTypeBlob);

    // Insert the type record to the type table
    tt.Insert(&aist, wHash);

    *pdwTypeID = aist.dwTypeID;
	*phInstTable = aist.hInstanceTable;

Cleanup:
    m_ps->Unmap();
    UNLOCK(m_ps);

Exit:
    return hr;
}

// Get the Instance cookie and Accounting record
HRESULT AccountingInfoStore::GetInstance(
		PS_HANDLE  hInstTable,  // Instance table
		PBYTE      pbInst,      // Instance Signature
		WORD       cbInst,      // nBytes in Instance Sig
		DWORD      dwHash,      // Hash of Instance [Sig]
		DWORD     *pdwInstID,   // [out] instance cookie
        PS_HANDLE *phAccRec)    // [out] Accounting Record
{
    _ASSERTE(hInstTable);
    _ASSERTE(m_aish.hAccounting);
    _ASSERTE(m_aish.hInstanceBlobPool);

    HRESULT          hr = S_OK;
    WORD             wHash;
    DWORD            i;
    PS_HANDLE        hnd;
    PAIS_INSTANCE    pAISI;
    PPS_TABLE_HEADER pT;
    PPS_ARRAY_LIST   pAL;

    PSArrayTable   it(m_ps, hInstTable);                // Instance table
    PSBlobPool     bp(m_ps, m_aish.hInstanceBlobPool);  // Instance blob pool
    PSGenericTable at(m_ps, m_aish.hAccounting);        // Accounting table


    LOCK(m_ps);

    hr = m_ps->Map();

    if (FAILED(hr))
        goto Exit;

    pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(hInstTable);

    wHash = (WORD) (dwHash % pT->ArrayTable.wRows);

    hr = it.HandleOfRow(wHash, &hnd); 

    if (FAILED(hr))
    {
		PS_DONE_USING_PTR(m_ps, pT);
        goto Cleanup;
    }

    pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hnd);


    _ASSERTE(pAL->dwValid <= pT->ArrayTable.wRecsInRow);

    do
    {
        pAISI = (PAIS_INSTANCE) &(pAL->bData);

        for (i=0; i<pAL->dwValid; ++i)
        {
#ifdef _DEBUG
            void *ptr = m_ps->HndToPtr(pAISI[i].hInstanceBlob);
#endif

            if ((pAISI[i].wInstanceBlobSize == cbInst) && 
#ifdef _DEBUG
                (memcmp(ptr, pbInst, cbInst)
#else
                (memcmp(m_ps->HndToPtr(pAISI[i].hInstanceBlob), pbInst, cbInst)
#endif
                == 0))
            {
                *pdwInstID = pAISI[i].dwInstanceID;
			    *phAccRec  = pAISI[i].hAccounting;

		        PS_DONE_USING_PTR(m_ps, ptr);
		        PS_DONE_USING_PTR(m_ps, pAL);
		        PS_DONE_USING_PTR(m_ps, pT);

                goto Cleanup;
            }

            PS_DONE_USING_PTR(m_ps, ptr);
        }

        if (pAL->hNext != 0)
        {
            PS_DONE_USING_PTR_(m_ps, pAL);
            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(pAL->hNext);
        }
        else
            break;

    } while (1);

    PS_DONE_USING_PTR(m_ps, pAL);

    // Entry not found, create one.
    AIS_INSTANCE aisi;
    AIS_ACCOUNT  aisa;

    memset(&aisi, 0, sizeof(AIS_INSTANCE));
    memset(&aisa, 0, sizeof(AIS_ACCOUNT));

    aisi.wInstanceBlobSize = cbInst;

    // pT is still valid.
    aisi.dwInstanceID = (DWORD) ++(pT->hAppData);   
    PS_DONE_USING_PTR(m_ps, pT);

    // Create an entry in the accounting table
    at.Insert(&aisa, &aisi.hAccounting);

    // Add the instance blob to the instance blob table.
    bp.Insert(pbInst, cbInst, &aisi.hInstanceBlob);

    // Insert the instance record to the instance table
    it.Insert(&aisi, wHash);

    *pdwInstID = aisi.dwInstanceID;
    *phAccRec  = aisi.hAccounting;

Cleanup:
    m_ps->Unmap();
    UNLOCK(m_ps);

Exit:
    return hr;
}

// Reserves space (Increments qwUsage)
// This method is synchrinized. If quota + request > limit, method fails
HRESULT AccountingInfoStore::Reserve(
    PS_HANDLE  hAccInfoRec, // Accounting info record    
    QWORD      qwLimit,     // The max allowed
    QWORD      qwRequest,   // reserve / free qwRequest
    BOOL       fFree)       // Reserve / Unreserve
{
    _ASSERTE(hAccInfoRec != 0);

    HRESULT      hr = S_OK;
    PAIS_ACCOUNT pA = NULL;

    LOCK(m_ps);

    hr = m_ps->Map();

    if (FAILED(hr))
        goto Exit;

    pA = (PAIS_ACCOUNT) m_ps->HndToPtr(hAccInfoRec);

    if (fFree)
    {
        if (pA->qwUsage > qwRequest)
            pA->qwUsage -= qwRequest;
        else
            pA->qwUsage = 0;
    }
    else
    {
        if ((pA->qwUsage + qwRequest) > qwLimit)
            hr = ISS_E_USAGE_WILL_EXCEED_QUOTA;
        else
            // Safe to increment quota.
            pA->qwUsage += qwRequest;
    }

    PS_DONE_USING_PTR(m_ps, pA);

    m_ps->Unmap();
    UNLOCK(m_ps);

Exit:
    return hr;
}

// Method is not synchronized. So the information may not be current.
// This implies "Pass if (Request + GetUsage() < Limit)" is an Error!
// Use Reserve() method instead.
HRESULT AccountingInfoStore::GetUsage(
    PS_HANDLE  hAccInfoRec, // Accounting info record    
    QWORD      *pqwUsage)   // Returns the amount of space / resource used
{
    _ASSERTE(hAccInfoRec != 0);

    HRESULT      hr = S_OK;
    PAIS_ACCOUNT pA = NULL;

    LOCK(m_ps);

    hr = m_ps->Map();

    if (FAILED(hr))
        goto Exit;

    pA = (PAIS_ACCOUNT) m_ps->HndToPtr(hAccInfoRec);
    *pqwUsage = pA->qwUsage;
    PS_DONE_USING_PTR(m_ps, pA);

    m_ps->Unmap();

    UNLOCK(m_ps);

Exit:
    return hr;
}

PersistedStore* AccountingInfoStore::GetPS()
{
    return m_ps;
}

// Given a Type & Instance ID, get the Instance blob and AccountingInfo
HRESULT AccountingInfoStore::ReverseLookup(
    DWORD       dwTypeID,   // Type cookie
    DWORD       dwInstID,   // Instance cookie
    PS_HANDLE   *phAccRec,  // [out] Accounting Record
    PS_HANDLE   *pInstance, // [out] Instance Sig
    WORD        *pcbInst)   // [out] nBytes in Instance Sig
{
    HRESULT hr = S_OK;
    PSArrayTable at(m_ps, m_aish.hTypeTable); // Array Table

    _ASSERTE(m_ps);

    if (m_aish.hTypeTable == 0)
	{
		hr = S_FALSE;
        goto Exit;
	}

    LOCK(m_ps);

    hr = m_ps->Map();

    if (FAILED(hr))
        goto Exit;

    // Do a reverse lookup for dwTypeID. This lookup will be slow.
    // The speed is not a problem here since this operation will be very rare.

    PPS_TABLE_HEADER pth;       // Table header
    PAIS_TYPE        pType;     // Type record
    PS_HANDLE        hAL;       // Handle to Array List
    PPS_ARRAY_LIST   pAL;       // Array List
    PS_HANDLE        hInstanceTable;

    pth = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_aish.hTypeTable);
    hInstanceTable = 0;

    // Type table is an array table. The spill over entries will
    // be in a generic table or a linked list of generic tables.
    // It is sufficient to traverse all the rows in this table.

    for (WORD i=0; i<pth->ArrayTable.wRows; ++i)
    {
        hr = at.HandleOfRow(i, &hAL);
        if (FAILED(hr))
            goto Cleanup;

        // Search the linked list that make up this array.
        while (hAL != 0)
        {
            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hAL);

            pType = (PAIS_TYPE) &(pAL->bData);

            // Each row in this table is an array of type records.
            for (DWORD j=0; j<pAL->dwValid; ++j)
            {
                if (pType[j].dwTypeID == dwTypeID)
                {
                    hInstanceTable = pType[j].hInstanceTable;
                    PS_DONE_USING_PTR(m_ps, pAL);
                    goto FoundInstance;
                }
            }

            hAL = pAL->hNext;
            PS_DONE_USING_PTR(m_ps, pAL);
        }
    }

FoundInstance:
    if (hInstanceTable == 0)
	{
		hr = S_FALSE;
        goto Cleanup;
	}

    at.SetHnd(hInstanceTable);  // Instance table
    PAIS_INSTANCE   pCurInst;   // Current Instance record

    pCurInst = NULL;

    PS_DONE_USING_PTR(m_ps, pth);
    pth = (PPS_TABLE_HEADER) m_ps->HndToPtr(hInstanceTable);

    // Instance table is an array table. The spill over entries will
    // be in a generic table or a linked list of generic tables.
    // It is sufficient to traverse all the rows in this table.

    for (i=0; i<pth->ArrayTable.wRows; ++i)
    {
        hr = at.HandleOfRow(i, &hAL);
        if (FAILED(hr))
            goto Cleanup;

        // Search the linked list that make up this array.
        while (hAL != 0)
        {
            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hAL);

            pCurInst = (PAIS_INSTANCE) &(pAL->bData);

            // Each row in this table is an array of type records.
            for (DWORD j=0; j<pAL->dwValid; ++j)
            {
                if (pCurInst[j].dwInstanceID == dwInstID)
                {
                    // Set the return values
                    *phAccRec  = pCurInst[j].hAccounting;
                    *pInstance = pCurInst[j].hInstanceBlob;
                    *pcbInst   = pCurInst[j].wInstanceBlobSize;

                    PS_DONE_USING_PTR(m_ps, pAL);
                    hr = S_OK;
                    goto Cleanup;
                }
            }

            hAL = pAL->hNext;
            PS_DONE_USING_PTR(m_ps, pAL);
        }
    }
	
	hr = S_FALSE;

Cleanup:
    PS_DONE_USING_PTR(m_ps, pth);

    m_ps->Unmap();

    UNLOCK(m_ps);

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\inc\cunknown.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __CUnknown_h__
#define __CUnknown_h__

#include <objbase.h>

///////////////////////////////////////////////////////////
//
// Nondelegating IUnknown interface
//   - Nondelegating version of IUnknown
//
interface INondelegatingUnknown
{
    virtual HRESULT __stdcall 
        NondelegatingQueryInterface(const IID& iid, void** ppv) = 0 ;
    virtual ULONG   __stdcall NondelegatingAddRef() = 0 ;
    virtual ULONG   __stdcall NondelegatingRelease() = 0 ;
} ;


///////////////////////////////////////////////////////////
//
// Declaration of CUnknown 
//   - Base class for implementing IUnknown
//

class CUnknown : public INondelegatingUnknown
{
public:
    // Nondelegating IUnknown implementation
    virtual HRESULT __stdcall NondelegatingQueryInterface(const IID&,
                                                          void**) ;
    virtual ULONG   __stdcall NondelegatingAddRef() ;
    virtual ULONG   __stdcall NondelegatingRelease() ;

    // Constructor
    CUnknown(IUnknown* pUnknownOuter) ;

    // Destructor
    virtual ~CUnknown() ;

    // Initialization (especially for aggregates)
    virtual HRESULT Init() { return S_OK ;}

    // Notification to derived classes that we are releasing
    virtual void FinalRelease() ;

    // Count of currently active components
    static long ActiveComponents() 
        { return s_cActiveComponents ;}
    
    // Helper function
    HRESULT FinishQI(IUnknown* pI, void** ppv) ;

protected:
    // Support for delegation
    IUnknown* GetOuterUnknown() const
        { return m_pUnknownOuter ;}

private:
    // Reference count for this object
    long m_cRef ;
    
    // Pointer to (external) outer IUnknown
    IUnknown* m_pUnknownOuter ;

    // Count of all active instances
    static long s_cActiveComponents ; 
} ;


///////////////////////////////////////////////////////////
//
// Delegating IUnknown
//   - Delegates to the nondelegating IUnknown, or to the
//     outer IUnknown if the component is aggregated.
//
#define DECLARE_IUNKNOWN                                     \
    virtual HRESULT __stdcall                                \
        QueryInterface(const IID& iid, void** ppv)           \
    {                                                        \
        return GetOuterUnknown()->QueryInterface(iid,ppv) ;  \
    } ;                                                      \
    virtual ULONG __stdcall AddRef()                         \
    {                                                        \
        return GetOuterUnknown()->AddRef() ;                 \
    } ;                                                      \
    virtual ULONG __stdcall Release()                        \
    {                                                        \
        return GetOuterUnknown()->Release() ;                \
    } ;


///////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\inc\cfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __CFactory_h__
#define __CFactory_h__

#include "CUnknown.h"
///////////////////////////////////////////////////////////

// Forward reference
class CFactoryData ;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

//////////////////////////////////////////////////////////
//
//  Component creation function
//
class CUnknown ;

typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**) ;

///////////////////////////////////////////////////////////
//
// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
//
class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* m_pCLSID ;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance ;

    // Name of the component to register in the registry
    LPCWSTR m_RegistryName ;

    // ProgID
    LPCWSTR m_wszProgID ;

    // Class id
    LPCWSTR m_wszClassID;
    
    // Version-independent ProgID
    int m_version ;

    // Helper function for finding the class ID
    BOOL IsClassID(const CLSID& clsid) const
        { return (*m_pCLSID == clsid) ;}

    //
    // Out of process server support
    //

    // Pointer to running class factory for this component
    IClassFactory* m_pIClassFactory ;

    // Magic cookie to identify running object
    DWORD m_dwRegister ;
} ;


///////////////////////////////////////////////////////////
//
// Class Factory
//
class CFactory : public IClassFactory
{
public:
    // IUnknown
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
    virtual ULONG   __stdcall AddRef() ;
    virtual ULONG   __stdcall Release() ;
    
    // IClassFactory
    virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
                                             const IID& iid,
                                             void** ppv) ;
    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

    // Constructor - Pass pointer to data of component to create.
    CFactory(const CFactoryData* pFactoryData) ;

    // Destructor
    ~CFactory() { }

    //
    // Static FactoryData support functions
    //

    // DllGetClassObject support
    static HRESULT GetClassObject(const CLSID& clsid, 
                                  const IID& iid, 
                                  void** ppv) ;

    // Helper function for DllCanUnloadNow 
    static BOOL IsLocked()
        { return (s_cServerLocks > 0) ;}

    // Functions to [un]register all components
    static HRESULT RegisterAll(HINSTANCE hInst) ;
    static HRESULT UnregisterAll() ;

    // Function to determine if component can be unloaded
    static HRESULT CanUnloadNow() ;

    // CloseExe doesn't do anything if we are in process.
    static void CloseExe() { /*Empty*/ } 

public:
    // Reference Count
    LONG m_cRef ;

    // Pointer to information about class this factory creates
    const CFactoryData* m_pFactoryData ;

    // Count of locks
    static LONG s_cServerLocks ;   

    // Module handle
    //static HMODULE s_hModule ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\inc\corpolicyp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CorPolicyP.H
//
// Private routines defined for WVT and Security dialogs
//
//*****************************************************************************
#ifndef _CORPOLICYP_H_
#define _CORPOLICYP_H_

#include <wincrypt.h>
#include <wintrust.h>

#include "CorPolicy.h"

//==========================================================================
// Signature and WVT helper functions 
//==========================================================================

// Attribute oids (information placed in the signatures) 
#define COR_PERMISSIONS          "1.3.6.1.4.1.311.15.1"
#define COR_PERMISSIONS_W       L"1.3.6.1.4.1.311.15.1"
#define ACTIVEX_PERMISSIONS      "1.3.6.1.4.1.311.15.2"
#define ACTIVEX_PERMISSIONS_W   L"1.3.6.1.4.1.311.15.2"

// COR policy states
#define TP_DENY   -1
#define TP_QUERY   0 
#define TP_ALLOW   1

// Certain security functions are memory independent, they rely
// on the caller to supply the alloc/free routines. This structure
// allows the caller to specify the memory model of choice
typedef LPVOID (WINAPI *CorCryptMalloc)(size_t p);
typedef void   (WINAPI *CorCryptFree)(void *p);

typedef struct _CorAlloc {
    CorCryptMalloc jMalloc;
    CorCryptFree   jFree;
} CorAlloc, *PCorAlloc;


// Retrieves the signer information from the signature block and
// places it in the trust structure. It also returns the attributes
// for ActiveX and Code Access permissions separately allowing the 
// caller to call custom crackers.
HRESULT 
GetSignerInfo(CorAlloc* pManager,                   // Memory Manager
              PCRYPT_PROVIDER_SGNR pSigner,         // Signer we are examining
              PCRYPT_PROVIDER_DATA pProviderData,   // Information about the WVT provider used
              PCOR_TRUST pTrust,                    // Collected information that is returned to caller
              BOOL* pfCertificate,                   // Is the certificate valid
              PCRYPT_ATTRIBUTE* ppCorAttr,           // The Cor Permissions
              PCRYPT_ATTRIBUTE* ppActiveXAttr);      // The Active X permissions


// Initializes the WVT call back functions
HRESULT 
LoadWintrustFunctions(CRYPT_PROVIDER_FUNCTIONS* pFunctions);

// Creates the signature information returned from the COR policy modules.
// This memory is allocated in a contiquous heap
HRESULT 
BuildReturnStructure(IN PCorAlloc pManager,         // Memory manager
                     IN PCOR_TRUST pSource,         // structure to copy
                     OUT PCOR_TRUST* pTrust,        // Returns the copied structure
                     OUT DWORD* dwReturnLength);    //    and the total length

// Initializes the return structure deleting any old references.
HRESULT 
CleanCorTrust(CorAlloc* pAlloc,
              DWORD dwEncodingType,
              PCOR_TRUST sTrust);


// Initializes the CAPI registration structure
void 
SetUpProvider(CRYPT_REGISTER_ACTIONID& sRegAID);


#define ZEROSTRUCT(arg)  memset( &arg, 0, sizeof(arg))
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\dochdrs\methhdr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:
//  
//  Synopsis:
//
//  Effects:
// 
//  Arguments:
//
//  Requires:
// 
//  Returns:
//
//  Signals:
//
//  Modifies:
// 
//  Derivation:
// 
//  Algorithm:
//
//  History:
// 
//  Notes:
// 
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\admin.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Declaration of the dump utils for dumping the 
 *          contents of the store.
 *
 * Author: Shajan Dasan
 * Date:  May 18, 2000
 *
 ===========================================================*/

#pragma once

#ifdef _NO_MAIN_
HRESULT Start(WCHAR *wszFileName);
void    DumpAll();
void    Stop();
#endif

void Dump(char *szFile);
void DumpMemBlocks(int indent);
void Dump(int indent, PPS_HEADER   pHdr);
void Dump(int indent, PPS_MEM_FREE pFree);
void Dump(int indent, PPS_TABLE_HEADER pTable);
void Dump(int indent, PAIS_HEADER pAIS);
void DumpAccountingTable(int i, PPS_TABLE_HEADER pTable);
void DumpTypeTable(int i, PPS_TABLE_HEADER pTable);
void DumpInstanceTable(int i, PPS_TABLE_HEADER pTable);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Common header file for Store
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#include "CorError.h"

#ifdef PS_STANDALONE
#define WszCreateFile           CreateFile
#define WszCreateMutex          CreateMutex
#define WszCreateFileMapping    CreateFileMapping
#define GetThreadId             GetCurrentThreadId
#pragma warning(disable:4127)  // for _ASSERTE.. while(0)
#pragma warning(disable:4100)  // for unused params.
#endif

#define ARRAY_SIZE(n) (sizeof(n)/sizeof(n[0]))

typedef unsigned __int64    QWORD;

#define LOCK(p)    hr = (p)->Lock(); if (SUCCEEDED(hr)) { __try {
#define UNLOCK(p)  } __finally { (p)->Unlock(); } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\admin.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Test program that dumps the contents of the store.
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#include <windows.h>
#include "Common.h"
#include "Utils.h"
#include "Log.h"
#include "PersistedStore.h"
#include "AccountingInfoStore.h"
#include "Admin.h"

#define ADM_ALL     0xFFFFFFFF
#define ADM_HDR     0x00000001
#define ADM_FREE    0x00000002
#define ADM_MEM     0x00000004
#define ADM_AHDR    0x00000008
#define ADM_TTAB    0x00000010
#define ADM_ATAB    0x00000020
#define ADM_ITAB    0x00000040
#define ADM_TTBP    0x00000080
#define ADM_ITBP    0x00000100
#define ADM_TB      0x00000200
#define ADM_IB      0x00000400
#define ADM_OFS     0x10000000
#define ADM_NUL		0x20000000
#define ADM_VERIFY  0x40000000

BYTE *g_pBase = NULL;
BYTE *g_pEOF = NULL;

DWORD g_dwFlags = ADM_ALL;

#ifdef _NO_MAIN_
HANDLE g_hMapping = NULL;
HANDLE g_hFile = INVALID_HANDLE_VALUE;
#endif

#define ADDRESS_OF(ofs) ((ofs) ? g_pBase + (ofs) : NULL)

#define DUMP_OFS(x)                         \
    if (x && (g_dwFlags & ADM_OFS)) {       \
        Log("[");                           \
        if (x)                              \
            Log((PBYTE)(x) - g_pBase);      \
        else                                \
            Log("NULL");                    \
        Log("]");                           \
    }

#define VER_ERROR()                 \
    {                               \
        Log("Verification Error !");\
        Log(__FILE__);              \
        Log(__LINE__);              \
        Log("\n");                  \
    }                               \

#ifndef _NO_MAIN_

void Usage()
{
    Log("Usage :\n\n");
    Log("admin <file-name> [options]\n");
    Log("options :\n");
    Log("\t[Hdr] [Free] [Mem]  [AHdr] [TTab] [ATab] [ITab]\n");
    Log("\t[TB]  [IB]   [TTBP] [ITBP]\n");
    Log("\t[ALL] [OFS]  [NUL]  [Verify]\n");
    Log("\ndefault is all options\n");
    Log("'-' will switch off an option\n");
}

void main(int argc, char **argv)
{
    if (argc == 1)
    {
        Usage();
        return;
    }
    else if (argc == 2)
        g_dwFlags = ADM_ALL;
    else
        g_dwFlags = 0;

#define QUOT(x) #x

#define DECL_PARAM(x)                                   \
        else if (stricmp(argv[i], #x) == 0) {           \
            g_dwFlags |= ADM_##x;                       \
        }                                               \
        else if (stricmp(argv[i], QUOT(-##x)) == 0) {   \
            g_dwFlags &= ~ADM_##x;                      \
        }                                               \

    for (int i=1; i<argc; ++i)
    {
        if ((stricmp(argv[i], "/?") == 0) || (stricmp(argv[i], "-?") == 0) ||
            (stricmp(argv[i], "/h") == 0) || (stricmp(argv[i], "-h") == 0) ||
            (stricmp(argv[i], "help") == 0))
        {
            Usage();
            return;
        }

        DECL_PARAM(ALL)
        DECL_PARAM(HDR)
        DECL_PARAM(FREE)
        DECL_PARAM(MEM)
        DECL_PARAM(AHDR)
        DECL_PARAM(TTAB)
        DECL_PARAM(ATAB)
        DECL_PARAM(ITAB)
        DECL_PARAM(TTBP)
        DECL_PARAM(ITBP)
        DECL_PARAM(TB)
        DECL_PARAM(IB)
        DECL_PARAM(OFS)
        DECL_PARAM(NUL)
        DECL_PARAM(VERIFY)
    }

    Dump(argv[1]);
}

#else // _NO_MAIN_

HRESULT Start(WCHAR *wszFileName)
{
    HRESULT hr          = S_OK;
    DWORD   dwLow       = 0;
    DWORD   dwHigh      = 0;

    g_hFile = WszCreateFile(
        wszFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_RANDOM_ACCESS,
        NULL);

    if (g_hFile == INVALID_HANDLE_VALUE)
    {
        Win32Message();
        hr = ISS_E_OPEN_STORE_FILE;
        goto Exit;
    }

    g_hMapping = WszCreateFileMapping(
        g_hFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL);

    if (g_hMapping == NULL)
    {
        Win32Message();
        hr = ISS_E_OPEN_FILE_MAPPING;
        goto Exit;
    }

    g_pBase = (PBYTE) MapViewOfFile(
        g_hMapping,
        FILE_MAP_READ,
        0,
        0,
        0);

    if (g_pBase == NULL)
    {
        Win32Message();
        hr = ISS_E_MAP_VIEW_OF_FILE;
        goto Exit;
    }

    dwLow = GetFileSize(g_hFile, &dwHigh);

    if ((dwLow == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
    {
        Win32Message();
        hr = ISS_E_GET_FILE_SIZE;
        goto Exit;
    }

    g_pEOF = g_pBase + (((QWORD)dwHigh << 32) | dwLow);

Exit:
    return hr;
}

void Stop()
{
    if (g_pBase != NULL)
    {
        UnmapViewOfFile(g_pBase);
        g_pBase = NULL;
    }

    if (g_hMapping != NULL)
    {
        CloseHandle(g_hMapping);
        g_hMapping = NULL;
    }

    if (g_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hFile);
        g_hFile = INVALID_HANDLE_VALUE;
    }

    g_pEOF = NULL;
}

void DumpAll()
{
    PPS_HEADER   ph;
    PPS_MEM_FREE pf;
    PAIS_HEADER pah;
    PPS_TABLE_HEADER ptt;
    PPS_TABLE_HEADER pat;
    PPS_TABLE_HEADER pbt;
    PPS_TABLE_HEADER pbi;

    ph = (PPS_HEADER) g_pBase;
    pf = (PPS_MEM_FREE)(ADDRESS_OF(ph->sFreeList.ofsNext));
    pah = (PAIS_HEADER)(ADDRESS_OF(ph->hAppData));

    if (pah) {
        ptt = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hTypeTable));
        pat = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hAccounting));
        pbt = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hTypeBlobPool));
        pbi = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hInstanceBlobPool));
    } else {
        ptt = NULL;
        pat = NULL;
        pbt = NULL;
        pbi = NULL;
    }

    if (g_dwFlags & ADM_HDR)
        Dump(0, ph);

    if (g_dwFlags & ADM_FREE)
        Dump(0, pf);

    if (g_dwFlags & ADM_MEM)
        DumpMemBlocks(0);

    if (g_dwFlags & ADM_AHDR)
        Dump(0, pah);

    if (g_dwFlags & ADM_TTAB)
        DumpTypeTable(0, ptt);

    if (g_dwFlags & ADM_ATAB)
        DumpAccountingTable(0, pat);

    if (g_dwFlags & ADM_TTBP)
        Dump(0, pbt);

    if (g_dwFlags & ADM_ITBP)
        Dump(0, pbi);
}

#endif // _NO_MAIN_

void Dump(char *szFile)
{
    HRESULT hr          = S_OK;
    DWORD   dwLow       = 0;
    DWORD   dwHigh      = 0;
    HANDLE  hFile       = INVALID_HANDLE_VALUE;
    HANDLE  hMapping    = NULL;
    WCHAR  *wszFileName = C2W(szFile);

    if (wszFileName == NULL)
    {
        hr = COR_E_OUTOFMEMORY;
        goto Exit;
    }

    hFile = WszCreateFile(
        wszFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_RANDOM_ACCESS,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        Win32Message();
        hr = ISS_E_OPEN_STORE_FILE;
        goto Exit;
    }

    hMapping = WszCreateFileMapping(
        hFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL);

    if (hMapping == NULL)
    {
        Win32Message();
        hr = ISS_E_OPEN_FILE_MAPPING;
        goto Exit;
    }

    g_pBase = (PBYTE) MapViewOfFile(
        hMapping,
        FILE_MAP_READ,
        0,
        0,
        0);

    if (g_pBase == NULL)
    {
        Win32Message();
        hr = ISS_E_MAP_VIEW_OF_FILE;
        goto Exit;
    }

    dwLow = GetFileSize(hFile, &dwHigh);

    if ((dwLow == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
    {
        Win32Message();
        hr = ISS_E_GET_FILE_SIZE;
        goto Exit;
    }

    g_pEOF = g_pBase + (((QWORD)dwHigh << 32) | dwLow);

    PPS_HEADER   ph;
    PPS_MEM_FREE pf;
    PAIS_HEADER pah;
    PPS_TABLE_HEADER ptt;
    PPS_TABLE_HEADER pat;
    PPS_TABLE_HEADER pbt;
    PPS_TABLE_HEADER pbi;

    ph = (PPS_HEADER) g_pBase;
    pf = (PPS_MEM_FREE)(ADDRESS_OF(ph->sFreeList.ofsNext));
    pah = (PAIS_HEADER)(ADDRESS_OF(ph->hAppData));

    if (pah) {
        ptt = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hTypeTable));
        pat = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hAccounting));
        pbt = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hTypeBlobPool));
        pbi = (PPS_TABLE_HEADER)(ADDRESS_OF(pah->hInstanceBlobPool));
    } else {
        ptt = NULL;
        pat = NULL;
        pbt = NULL;
        pbi = NULL;
    }

    if (g_dwFlags & ADM_HDR)
        Dump(0, ph);

    if (g_dwFlags & ADM_FREE)
        Dump(0, pf);

    if (g_dwFlags & ADM_MEM)
        DumpMemBlocks(0);

    if (g_dwFlags & ADM_AHDR)
        Dump(0, pah);

    if (g_dwFlags & ADM_TTAB)
        DumpTypeTable(0, ptt);

    if (g_dwFlags & ADM_ATAB)
        DumpAccountingTable(0, pat);

    if (g_dwFlags & ADM_TTBP)
        Dump(0, pbt);

    if (g_dwFlags & ADM_ITBP)
        Dump(0, pbi);
Exit:
    if (g_pBase != NULL)
        UnmapViewOfFile(g_pBase);

    if (hMapping != NULL)
        CloseHandle(hMapping);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    delete [] wszFileName;
}

void Dump(int i, PPS_HEADER pHdr)
{
#ifdef PS_LOG
/*

    QWORD       qwSignature;    // A fast check to reject bad streams
    DWORD       dwSystemFlag;   // Used by the system
    DWORD       dwPlatform;     // The platform on which this store was created
    DWORD       dwBlockSize;    // Allocation in multiples of BlockSize bytes
    WORD        wMajorVersion;  // A major version mismatch will reject file
    WORD        wMinorVersion;  // Minor version changes are not rejected
    PS_OFFSET   ofsHandleTable; // Offset to the handle table
    PS_HANDLE   hAppData;       // Set and used by applications
    PS_MEM_FREE sFreeList;      // Head node for doubly linked free blocks list
    WORD        wReserved[20];  // For future use, must be set to 0

    // System flags used in dwSystemFlag

    #define     PS_OFFSET_SIZE_8    1
    #define     PS_OFFSET_SIZE_16   2
    #define     PS_OFFSET_SIZE_32   3
    #define     PS_OFFSET_SIZE_64   4

    // Platform flags used in dwPlatform

    #define     PS_PLATFORM_X86     1
    #define     PS_PLATFORM_ALPHA   2
    #define     PS_PLATFORM_SHX     3
    #define     PS_PLATFORM_PPC     4

    #define     PS_PLATFORM_NT      (1<<4)
    #define     PS_PLATFORM_9x      (2<<4)
    #define     PS_PLATFORM_CE      (3<<4)

    #define     PS_PLATFORM_8       (1<<8)
    #define     PS_PLATFORM_16      (2<<8)
    #define     PS_PLATFORM_32      (3<<8)
    #define     PS_PLATFORM_64      (4<<8)
*/

    static ConstName s_nameSystem1[] = {
                CONST_NAME(PS_OFFSET_SIZE_8),
                CONST_NAME(PS_OFFSET_SIZE_16),
                CONST_NAME(PS_OFFSET_SIZE_32),
                CONST_NAME(PS_OFFSET_SIZE_64)};

    static ConstName s_namePlatform1[] = {
                CONST_NAME(PS_PLATFORM_X86),
                CONST_NAME(PS_PLATFORM_ALPHA),
                CONST_NAME(PS_PLATFORM_SHX),
                CONST_NAME(PS_PLATFORM_PPC)};

    static ConstName s_namePlatform2[] =  {
                CONST_NAME(PS_PLATFORM_NT),
                CONST_NAME(PS_PLATFORM_9x),
                CONST_NAME(PS_PLATFORM_CE)};

    static ConstName s_namePlatform3[] =  {
                CONST_NAME(PS_PLATFORM_8),
                CONST_NAME(PS_PLATFORM_16),
                CONST_NAME(PS_PLATFORM_32),
                CONST_NAME(PS_PLATFORM_64)};

    static LogConst s_System1(s_nameSystem1, ARRAY_SIZE(s_nameSystem1));
    static LogConst s_Platform1(s_namePlatform1, ARRAY_SIZE(s_namePlatform1));
    static LogConst s_Platform2(s_namePlatform2, ARRAY_SIZE(s_namePlatform2));
    static LogConst s_Platform3(s_namePlatform3, ARRAY_SIZE(s_namePlatform3));

    Indent(i++); Log("PS_HEADER\n");
    if (pHdr == NULL) { Indent(i); Log("NULL\n"); return; }

    Indent(i);  Log("qwSignature  : "); Log(pHdr->qwSignature);Log("\n");

    Indent(i);  Log("dwSystemFlag : "); Log(pHdr->dwSystemFlag);
                Log(" [ "); s_Platform1.Log(pHdr->dwSystemFlag & 0x0000000F);
                Log(" ]\n");

    Indent(i);  Log("dwPlatform   : "); Log(pHdr->dwPlatform);
                Log(" [ ");
                if (s_Platform1.Log(pHdr->dwPlatform & 0x0000000F)) Log(" ");
                if (s_Platform2.Log(pHdr->dwPlatform & 0x000000F0)) Log(" ");
                if (s_Platform3.Log(pHdr->dwPlatform & 0x00000F00)) Log(" ");
                Log("]\n");

    Indent(i);  Log("dwBlockSize  : "); Log(pHdr->dwBlockSize);   Log("\n");
    Indent(i);  Log("wMajorVersion: "); Log(pHdr->wMajorVersion); Log("\n");
    Indent(i);  Log("wMinorVersion: "); Log(pHdr->wMinorVersion); Log("\n");

    Indent(i);  Log("hAppData     : "); Log(pHdr->hAppData); Log("\n");

    Indent(i);  Log("sFreeList.sSize  : ");
                Log(PS_SIZE(&(pHdr->sFreeList)));
                PS_IS_USED(&(pHdr->sFreeList)) ? Log(" *\n") : Log(" .\n");

    Indent(i);  Log("sFreeList.ofsNext: "); Log(pHdr->sFreeList.ofsNext);
                Log("\n");
    Indent(i);  Log("sFreeList.ofsPrev: "); Log(pHdr->sFreeList.ofsPrev);
                Log("\n");


    Indent(i);  Log("wReserved    : "); 
                LogNonZero((PBYTE)&(pHdr->wReserved), 20 * sizeof(WORD));
                Log("\n");
#endif
}

void Dump(int i, PPS_MEM_FREE pFree)
{
#ifdef PS_LOG
/*
    PS_SIZE     sSize;          // Size includes size of this header
    PS_OFFSET ofsNext;          // Next in the sorted linked list
    PS_OFFSET ofsPrev;          // Previous node
*/

    Indent(i++); Log("PS_MEM_FREE\n");
    if (pFree == NULL) { Indent(i); Log("NULL\n"); return; }

    while (pFree)
    {
        Indent(i);
        Log((PBYTE)pFree - g_pBase);
        Log(" sSize : "); Log(PS_SIZE(pFree));
        if (PS_IS_USED(pFree)) Log(" * ");
        Log("\tofsNext : "); Log(pFree->ofsNext);
        Log("\tofsPrev : "); Log(pFree->ofsPrev); Log("\n");
        pFree = (PPS_MEM_FREE) ADDRESS_OF(pFree->ofsNext);
    }
#endif
}

void DumpMemBlocks(int i)
{
#ifdef PS_LOG

    PPS_MEM_HEADER  pHeader;
    PPS_MEM_FOOTER  pFooter;

    Indent(i++); Log("PS_MEM_BLOCKS\n");
    if (g_pBase == NULL) { Indent(i); Log("NULL\n"); return; }

    pFooter = (PPS_MEM_FOOTER)(g_pBase +
            PS_SIZE(&((PPS_HEADER)g_pBase)->sFreeList) - sizeof(PS_MEM_FOOTER));

    Indent(i);
    Log("[F of Header "); Log((PBYTE)pFooter - g_pBase);
    Log("] sSize : ");  Log(PS_SIZE(pFooter));
    PS_IS_USED(pFooter) ? Log(" *\n") : Log(" .\n");

    pHeader = (PPS_MEM_HEADER)(pFooter + 1);

    while (((PBYTE)pHeader + sizeof(PS_MEM_HEADER)) < g_pEOF)
    {
        Indent(i);
        Log("[H "); Log((PBYTE)pHeader - g_pBase);
        Log("] sSize : "); Log(PS_SIZE(pHeader));

        PS_IS_USED(pHeader) ? Log(" * ") : Log(" . ");

        pFooter = (PPS_MEM_FOOTER) ((PBYTE)pHeader +
                        PS_SIZE(pHeader) - sizeof(PS_MEM_FOOTER));
        Log("[F "); Log((PBYTE)pFooter - g_pBase);
        Log("] sSize : "); Log(PS_SIZE(pFooter));
        PS_IS_USED(pFooter) ?  Log(" * ") : Log(" . ");

        if (PS_IS_FREE(pHeader))
        {
            PPS_MEM_FREE pFree = (PPS_MEM_FREE) pHeader;
            Log("[ofsNext : "); Log(pFree->ofsNext);
            Log(", ofsPrev : "); Log(pFree->ofsPrev); Log("]");
        }

        Log("\n");

        pHeader = (PPS_MEM_HEADER)(pFooter + 1);
    }

#endif
}

void Dump(int i, PPS_TABLE_HEADER pT)
{
#ifdef PS_LOG
/*
    union {
        DWORD   dwSystemFlag;   // Set by the system unused flags are set to 0

        struct {
            unsigned long Version            : 4;   // Version Number
            unsigned long TableType          : 2;   // PS_HAS_KEY,
                                                    // PS_SORTED_BY_KEY,
                                                    // PS_HASH_TABLE...
            union {
                unsigned long KeyLength      : PS_SIZEOF_NUM_BITS;
                unsigned long SizeOfLength   : PS_SIZEOF_NUM_BITS;
                                                    // size of count field for
                                                    // blob pool
            };

            unsigned long fHasMinMax         : 1;

            unsigned long fHasUsedRowsBitmap : 1;   // UsedRowsBitmap follows
                                                    // HasMin (if present)
            // Add new fields here.. MSBs of the DWORD will get the new bits
        } Flags;
    };

    // SORTED_BY_KEY is a special case of HAS_KEY
    // HASH_TABLE is a special case of SORTED_BY_KEY

    #define PS_GENERIC_TABLE 1  // Generic table
    #define PS_HAS_KEY       2  // Each row has a unique key
    #define PS_SORTED_BY_KEY 3  // Key is unique and rows are sorted by key
    #define PS_HASH_TABLE    4  // Table represents a hash table
    #define PS_BLOB_POOL     5  // Table represents a blob pool
    #define PS_ARRAY_TABLE   6  // linked list of fixed sized arrays, each
                                // fixed size array being a row in the table


    PS_HANDLE  hNext;           // If the table does not fit in this block,
                                // follow this pointer to reach the next block.
                                // Set to 0 if no more blocks.

    PS_HANDLE  hAppData;        // Application defined data

    union {
        DWORD dwReserved[8];    // size of this union.. unused bits must be 0

        struct {

            // The wRows and wRowSize fields are shared between
            // ArrayTable and Table structures. Do not move these fields

            WORD  wRows;        // The number of rows in this block of the table
                                // including unused rows.
            WORD  wRowSize;     // Size of one row in bytes
            DWORD dwMin;        // min key / hash value
            DWORD dwMax;        // max key / hash value
                                // Min / Max are valid only if fHasMinMax is set
        } Table;

        // TableType is PS_BLOB_POOL
        struct {
            PS_SIZE   sFree;    // Free space available
            PS_HANDLE hFree;    // Next free block
        } BlobPool;

        // TableType is PS_ARRAY_TABLE
        struct {

            // The wRows and wRowSize fields are shared between
            // ArrayTable and Table structures. Do not move these fields

            WORD wRows;         // The number of rows in this block of the table
                                // including unused rows.
            WORD wRowSize;      // Size of one row in bytes
                                // (nRec * RecSize + sizeof(PS_HANDLE)
            WORD wRecsInRow;    // Number of records in one row
            WORD wRecSize;      // sizeof one record
        } ArrayTable;
    };

    // If fHasUsedRowsBitmap is set PS_USED_ROWS_BITMAP is put here
    // If fHasAppData is set PS_RAW_DATA is put here
    // Actual Rows Start here.
*/

    static ConstName s_nameTableType[] =  {
                CONST_NAME(PS_GENERIC_TABLE),
                CONST_NAME(PS_HAS_KEY),
                CONST_NAME(PS_SORTED_BY_KEY),
                CONST_NAME(PS_HASH_TABLE),
                CONST_NAME(PS_BLOB_POOL),
                CONST_NAME(PS_ARRAY_TABLE)};

    static LogConst s_TableType(s_nameTableType, ARRAY_SIZE(s_nameTableType));

    DUMP_OFS(pT);

    Indent(i++); Log("PS_TABLE_HEADER\n");
    if (pT == NULL) { Indent(i); Log("NULL\n"); return; }

    Indent(i);  Log("dwSystemFlag       : ");
                Log(pT->dwSystemFlag); Log("\n");
    Indent(i);  Log("Version            : ");
                Log(pT->Flags.Version); Log("\n");
    Indent(i);  Log("TableType          : ");
                s_TableType.Log(pT->Flags.TableType); Log("\n");

    if (pT->Flags.TableType == PS_BLOB_POOL) {
        Indent(i);
                Log("SizeOfLength       : ");
                Log(pT->Flags.SizeOfLength);Log("\n");
    } else {
        Indent(i);
                Log("KeyLength          : ");
                Log(pT->Flags.KeyLength); Log("\n");
    }

    Indent(i);  Log("fHasMinMax         : ");
                LogBool(pT->Flags.fHasMinMax); Log("\n");
    Indent(i);  Log("fHasUsedRowsBitmap : ");
                LogBool(pT->Flags.fHasUsedRowsBitmap); Log("\n");

    Indent(i);  Log("hNext              : "); Log(pT->hNext); Log("\n");
    Indent(i);  Log("hAppData           : "); Log(pT->hAppData); Log("\n");

    if (pT->Flags.TableType == PS_BLOB_POOL) {
        Indent(i);
                Log("sFree              : ");Log(pT->BlobPool.sFree); Log("\n");
        Indent(i);
                Log("hFree              : ");Log(pT->BlobPool.hFree); Log("\n");
    } else if (pT->Flags.TableType == PS_ARRAY_TABLE) {
        Indent(i);
                Log("wRows              : ");
                Log(pT->ArrayTable.wRows); Log("\n");
        Indent(i);
                Log("wRowSize           : ");
                Log(pT->ArrayTable.wRowSize); Log("\n");
        Indent(i);
                Log("wRecsInRow         : ");
                Log(pT->ArrayTable.wRecsInRow); Log("\n");
        Indent(i);
                Log("wRecSize           : ");
                Log(pT->ArrayTable.wRecSize); Log("\n");
    } else {
        Indent(i);
                Log("wRows              : "); Log(pT->Table.wRows); Log("\n");
        Indent(i);
                Log("wRowSize           : "); Log(pT->Table.wRowSize); Log("\n");
        Indent(i);
                Log("dwMin              : "); Log(pT->Table.dwMin); Log("\n");
        Indent(i);
                Log("dwMax              : "); Log(pT->Table.dwMax); Log("\n");
    }

    Indent(i);  Log("dwReserved[4]      : ");
                LogNonZero((PBYTE)&(pT->dwReserved[4]), 4 * sizeof(WORD));
                Log("\n");

    if ((pT->Table.wRows > 0) && (pT->Flags.fHasUsedRowsBitmap)) {
        Indent(i);
                Log("Used Rows          : ");
        DWORD *pdw = (DWORD*)(((PBYTE)pT) + sizeof(PS_TABLE_HEADER));
        for (int _i=0; _i<pT->Table.wRows; ++_i) {
            if (IS_SET_DWORD_BITMAP(pdw, _i))
                Log("x");
            else
                Log(".");
        }
        Log("\n");
    }
#endif
}

void Dump(int i, PPS_ARRAY_LIST pL)
{
#ifdef PS_LOG
/*
    PS_HANDLE hNext;        // Next in node in the list
    DWORD     dwValid;      // Number of valid entries in this array
    BYTE      bData[];      // The array
*/

    DUMP_OFS(pL);

    Indent(i++); Log("PS_ARRAY_LIST\n");
    if (pL == NULL) { Indent(i); Log("NULL\n"); return; }
    Indent(i);  Log("hNext   : "); Log(pL->hNext); Log("\n");
    Indent(i);  Log("dwValid : "); Log(pL->dwValid); Log("\n");
#endif
}

void Dump(int i, PAIS_HEADER pAH)
{
#ifdef PS_LOG
/*
    PS_HANDLE hTypeTable;       // The Type table
    PS_HANDLE hAccounting;      // The Accounting table
    PS_HANDLE hTypeBlobPool;    // Blob Pool for serialized type objects
    PS_HANDLE hInstanceBlobPool;// Blob Pool for serialized instances
    PS_HANDLE hAppData;         // Application Specific
    PS_HANDLE hReserved[10];    // Reserved for applications
*/

    DUMP_OFS(pAH);

    Indent(i++); Log("AIS_HEADER\n");
    if (pAH == NULL) { Indent(i); Log("NULL\n"); return; }
    Indent(i);  Log("hTypeTable        : "); Log(pAH->hTypeTable); Log("\n");
    Indent(i);  Log("hAccounting       : "); Log(pAH->hAccounting); Log("\n");
    Indent(i);  Log("hTypeBlobPool     : "); Log(pAH->hTypeBlobPool); Log("\n");
    Indent(i);  Log("hInstanceBlobPool : "); Log(pAH->hInstanceBlobPool); 
                Log("\n");
    Indent(i);  Log("hAppData          : "); Log(pAH->hAppData); Log("\n");
    Indent(i);  Log("hReserved         : ");
                LogNonZero((PBYTE)(pAH->hReserved), 10 * sizeof(PS_HANDLE));
                Log("\n");

#endif
}

void Dump(int i, PAIS_TYPE pT)
{
#ifdef PS_LOG
/*
    PS_HANDLE hTypeBlob;        // handle to the blob of serialized type
    PS_HANDLE hInstanceTable;   // handle to the instance table
    DWORD     dwTypeID;         // A unique id for the type
    WORD      wTypeBlobSize;    // Number of bytes in the type blob
    WORD      wReserved;        // Must be 0
*/

    DUMP_OFS(pT);

    Indent(i++); Log("AIS_TYPE\n");
    if (pT == NULL) { Indent(i); Log("NULL\n"); return; }
    Indent(i);  Log("hTypeBlob      : "); Log(pT->hTypeBlob); Log("\n");
    Indent(i);  Log("hInstanceTable : "); Log(pT->hInstanceTable); Log("\n");
    Indent(i);  Log("dwTypeID       : "); Log(pT->dwTypeID); Log("\n");
    Indent(i);  Log("wTypeBlobSize  : "); Log(pT->wTypeBlobSize); Log("\n");
    Indent(i);  Log("wReserved      : "); Log(pT->wReserved); Log("\n");
#endif
}

void Dump(int i, PAIS_INSTANCE pI)
{
#ifdef PS_LOG
/*
    PS_HANDLE hInstanceBlob;    // Serialized Instance
    PS_HANDLE hAccounting;      // Accounting information record
    DWORD     dwInstanceID;     // Unique in this table
    WORD      wInstanceBlobSize;// Size of the serialized instance
    WORD      wReserved;        // Must be 0
*/

    DUMP_OFS(pI);

    Indent(i++); Log("AIS_INSTANCE\n");
    if (pI == NULL) { Indent(i); Log("NULL\n"); return; }
    Indent(i);  Log("hInstanceBlob : "); Log(pI->hInstanceBlob); Log("\n");
    Indent(i);  Log("hAccounting   : "); Log(pI->hAccounting); Log("\n");
    Indent(i);  Log("dwInstanceID  : "); Log(pI->dwInstanceID); Log("\n");
    Indent(i);  Log("wReserved     : "); Log(pI->wReserved); Log("\n");
#endif
}

void Dump(int i, PAIS_ACCOUNT pA)
{
#ifdef PS_LOG
/*
    QWORD   qwQuota;            // The amount of resource used
    DWORD   dwLastUsed;         // Last time the entry was used
    DWORD   dwReserved[5];      // For future use, set to 0
*/

    DUMP_OFS(pA);

    Indent(i++); Log("AIS_ACCOUNT\n");
    if (pA == NULL) { Indent(i); Log("NULL\n"); return; }
    Indent(i);  Log("qwUsage    : "); Log(pA->qwUsage); Log("\n");
    Indent(i);  Log("dwLastUsed : "); Log(pA->dwLastUsed); Log("\n");
    Indent(i);  Log("dwReserved : ");
                LogNonZero((PBYTE)(pA->dwReserved), 5 * sizeof(PS_HANDLE));
                Log("\n");
#endif
}

void DumpAccountingTable(int i, PPS_TABLE_HEADER pT)
{
#ifdef PS_LOG

    DUMP_OFS(pT);

    Indent(i++); Log("AIS_HEADER.hAccounting\n");
    if (pT == NULL) { Indent(i); Log("NULL\n"); return; }
    
    while (pT)
    {
        Dump(i, pT);

        DWORD *pdw = (DWORD*)(((PBYTE)pT) + sizeof(PS_TABLE_HEADER));

        PAIS_ACCOUNT pA = (PAIS_ACCOUNT) (((PBYTE)pT) + 
            sizeof(PS_TABLE_HEADER) +
            NUM_DWORDS_IN_BITMAP(pT->Table.wRows) * sizeof(DWORD));

        for (int _i=0; _i<pT->Table.wRows; ++_i) {
            if (IS_SET_DWORD_BITMAP(pdw, _i)) {
                Dump(i+1, &pA[_i]);
            }
        }

        pT = (PPS_TABLE_HEADER)ADDRESS_OF(pT->hNext);
    }
#endif
}

void DumpInstanceTable(int i, PPS_TABLE_HEADER pT)
{
#ifdef PS_LOG

    DUMP_OFS(pT);

    Indent(i++); Log("AIS_HEADER.hInstanceTable\n");
    if (pT == NULL) { Indent(i); Log("NULL\n"); return; }

    if (g_dwFlags & ADM_VERIFY)
    {
        DWORD dwRecSize = sizeof(PS_ARRAY_LIST) + 
            (pT->ArrayTable.wRecsInRow * pT->ArrayTable.wRecSize);
    
        if (dwRecSize != pT->Table.wRowSize)
            VER_ERROR()
    }

    Dump(i, pT);

    PPS_ARRAY_LIST pL = (PPS_ARRAY_LIST) (((PBYTE)pT) +
        sizeof(PS_TABLE_HEADER));

    PPS_ARRAY_LIST pL1;

    for (WORD _i=0; _i<pT->Table.wRows; ++_i) {

        pL1 = (PPS_ARRAY_LIST)((PBYTE)pL + _i * pT->Table.wRowSize);

        while (pL1)
        {
            if (((g_dwFlags & ADM_NUL) == 0) && (pL1->dwValid == 0))
            {
                pL1 = (PPS_ARRAY_LIST) ADDRESS_OF(pL1->hNext);
                continue;
            }
            
            Dump(i, pL1);
    
            PAIS_INSTANCE pI = (PAIS_INSTANCE)(pL1->bData);
    
            for(DWORD _j=0; _j<pL1->dwValid; ++_j) {
                Dump(i+1, &pI[_j]);
            }

            pL1 = (PPS_ARRAY_LIST) ADDRESS_OF(pL1->hNext);
        }
    }
#endif
}

void DumpTypeTable(int i, PPS_TABLE_HEADER pT)
{
#ifdef PS_LOG

    DUMP_OFS(pT);

    Indent(i++); Log("AIS_HEADER.hTypeTable\n");
    if (pT == NULL) { Indent(i); Log("NULL\n"); return; }

    if (g_dwFlags & ADM_VERIFY)
    {
        DWORD dwRecSize = sizeof(PS_ARRAY_LIST) + 
            (pT->ArrayTable.wRecsInRow * pT->ArrayTable.wRecSize);
    
        if (dwRecSize != pT->Table.wRowSize)
            VER_ERROR()
    }

    Dump(i, pT);

    PPS_ARRAY_LIST pL = (PPS_ARRAY_LIST) (((PBYTE)pT) +
        sizeof(PS_TABLE_HEADER));

    PPS_ARRAY_LIST pL1;


    for (WORD _i=0; _i<pT->Table.wRows; ++_i) {

        pL1 = (PPS_ARRAY_LIST)((PBYTE)pL + _i * pT->Table.wRowSize);

        while (pL1)
        {
            if (((g_dwFlags & ADM_NUL) == 0) && (pL1->dwValid == 0))
            {
                pL1 = (PPS_ARRAY_LIST) ADDRESS_OF(pL1->hNext);
                continue;
            }
            
            Dump(i, pL1);
    
            PAIS_TYPE pT = (PAIS_TYPE)(pL1->bData);
    
            for (DWORD _j=0; _j<pL1->dwValid; ++_j) {

                Dump(i+1, &pT[_j]);

                if (g_dwFlags & ADM_ITAB)  
                {
                    DumpInstanceTable(i+1,
                        (PPS_TABLE_HEADER)ADDRESS_OF(pT->hInstanceTable));
                }
            }

            pL1 = (PPS_ARRAY_LIST) ADDRESS_OF(pL1->hNext);
        }
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\shell.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Shell for Persisted Store
 *
 * Author: Shajan Dasan
 * Date:  May 17, 2000
 *
 ===========================================================*/

#include <windows.h>
#include <iostream.h>
#include <stdio.h>
#include "Common.h"
#include "Log.h"
#include "PersistedStore.h"
#include "AccountingInfoStore.h"
#include "Admin.h"
#include "Shell.h"

const char* s_operation[] = { "Exit", "Alloc", "Free", "Dump" };

typedef enum
{
    eExit   = 0,
    eAlloc  = 1,
    eFree   = 2,
    eDump   = 3,
    eNumOps = 4
} operation;

DWORD PromptAndGetDW(char *msg)
{
    char buff[1024];
    DWORD dw = eExit;

    Log(msg);

    cin >> buff;
    
    for (int i=0; i<eNumOps; ++i)
    {
        if (strcmpi(buff, s_operation[i]) == 0)
        {
            dw = i;
            goto Exit;
        }
        else if (toupper(buff[0]) == toupper(s_operation[i][0]))
        {
            dw = i;
        }
    }

    if (dw == eExit)
        sscanf(buff, "%x", &dw);

Exit:
    return dw;
}

operation GetOperation(bool fQuiet)
{
    char buff[1024];
    char *p = buff;
    operation ret;
    DWORD dw;

    if (fQuiet)
    {
        p = "";
    }
    else
    {
        for (int i=0; i<eNumOps; ++i)
        {
            sprintf(p, "[%d] %s\n", i, s_operation[i]);
            p += strlen(p);
        }
    
        sprintf(p, "Option : ");
    }

    dw = PromptAndGetDW(buff);

    if (dw >= eNumOps)
        ret = eExit;
    else
        ret = (operation) dw;

    return ret;
}

void Shell(PersistedStore *ps, DWORD dwFlags)
{
    operation op;
    DWORD dw;
    PVOID pv;
    HRESULT hr;
    
    do {
        op = GetOperation(dwFlags & PS_SHELL_QUIET);

        switch (op)
        {

        case eAlloc :

            dw = PromptAndGetDW("Size : ");

            hr = ps->Alloc(dw, &pv);

            if (FAILED(hr))
            {
                LogHR(hr);
                break;
            }

            if (dwFlags & PS_SHELL_VERBOSE)
            {
                Log("Allocated ");
                Log(dw);
                Log(" bytes at offset ");
                Log((ps->PtrToHnd(pv) - sizeof(PS_MEM_HEADER)));
                Log("\n");
            }

            PS_DONE_USING_PTR(ps, pv);

            break;

        case eFree :

            dw = PromptAndGetDW("Offset : ");

            // Allow for the header.
            ps->Free((PS_HANDLE)dw + sizeof(PS_MEM_HEADER));

            if (dwFlags & PS_SHELL_VERBOSE)
            {
                Log("Freed block at offset ");
                Log(dw);
                Log("\n");
            }

            break;

        case eDump :

            hr = Start(ps->GetFileName());

            if (FAILED(hr))
            {
                Stop();
                LogHR(hr);
                break;
            }

            DumpAll();

            Stop();

            break;

        default :
            op = eExit;

        case eExit :
            break;

        }

    } while (op != eExit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\persistedstore.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Persised Store implementation
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#define STRICT
#include "stdpch.h"

#ifndef PS_STANDALONE
#include "winwrap.h"
#endif

#define RETURN_ERROR_IF_FILE_NOT_MAPPED() \
    if (m_pData == NULL) return ISS_E_FILE_NOT_MAPPED

// The bit location of the first zero bit in a nibble (0xF == no bits)
const BYTE g_FirstZeroBit[16] =
{
    1,  // 0000
    2,  // 0001
    1,  // 0010
    3,  // 0011
    1,  // 0100
    2,  // 0101
    1,  // 0110
    4,  // 0111
    1,  // 1000
    2,  // 1001
    1,  // 1010
    3,  // 1011
    1,  // 1100
    2,  // 1101
    1,  // 1110
    0   // 1111
};

// Given an array of DWORDs representing a bitmap of n bits,
// returns the number of the first bit that is not set.
static WORD GetFirstZeroBit(DWORD* pArray, WORD n)
{
    WORD  cArray = NUM_DWORDS_IN_BITMAP(n);
    WORD  i, index;
    DWORD elem;
    BYTE  firstZeroBit;

    // For each element in the array
    for (i=0; i<cArray; ++i)
    {
        elem = pArray[i];

        // Check if we have atleast one bit not set in this element

        if (elem != ~0)
        {
            // Atleast one bit is not set.

            index = i << 5;     // index is i * 32 + x

            // Skip bytes that are all ones
            while ((elem & 0xFF) == 0xFF)
            {
                elem >>= 8;
                index += 8;
            }

            do
            {
                // Find the first zero bit in the last 4 bytes
                firstZeroBit = g_FirstZeroBit[elem & 0xF];

                if (firstZeroBit != 0)
                {
                    // Found !

                    return ((index > n) ? 0 : (index + firstZeroBit));
                }

                // Skip these 4 bits
                elem >>= 4;
                index += 4;

            } while ((elem != ~0) && (index <= n));
        }
    }

    return 0;
}

PersistedStore::PersistedStore(WCHAR *wszFileName, WORD wFlags) :
        m_sSize(0),
        m_pData(NULL),
        m_pAlloc(NULL),
        m_dwBlockSize(PS_DEFAULT_BLOCK_SIZE),
        m_hFile(INVALID_HANDLE_VALUE),
        m_hMapping(NULL),
        m_hLock(NULL),
        m_wFlags(wFlags)
{
#ifdef _DEBUG
    m_dwNumLivePtrs = 0;
    m_dwNumLocks    = 0;
#endif

    m_pvMemHandle = (void*)this;
    SetName(wszFileName);
}

PersistedStore::PersistedStore(
                    WCHAR      *wszName,
                    BYTE       *pByte,
                    PS_SIZE     sSize,
                    PPS_ALLOC   pAlloc,
                    void       *pvMemHandle,
                    WORD        wFlags) :
        m_sSize(sSize),
        m_pData(pByte),
        m_pAlloc(pAlloc),
        m_pvMemHandle(pvMemHandle),
        m_dwBlockSize(PS_DEFAULT_BLOCK_SIZE),
        m_hFile(INVALID_HANDLE_VALUE),
        m_hMapping(NULL),
        m_hLock(NULL),
        m_wFlags(wFlags)

{
#ifdef _DEBUG
    m_dwNumLivePtrs = 0;
    m_dwNumLocks    = 0;
#endif
    _ASSERTE(pAlloc);
    SetName(wszName);
}

PersistedStore::~PersistedStore()
{
    if (m_pData)
        UnmapViewOfFile(m_pData);

    if (m_hMapping != NULL)
        CloseHandle(m_hMapping);

    if (m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    if (m_hLock != NULL)
        CloseHandle(m_hLock);

    if ((m_wFlags & PS_MAKE_COPY_OF_STRING) && m_wszFileName)
        delete [] m_wszFileName;

    if (m_wszName)
        delete [] m_wszName;
    
	_ASSERTE(m_dwNumLivePtrs == 0);
	_ASSERTE(m_dwNumLocks == 0);
}

HRESULT PersistedStore::Init()
{
    // This method (like all others) assumes that the caller synchronizes

    // global asserts

    _ASSERTE((m_dwBlockSize % PS_INNER_BLOCK_SIZE) == 0);
    _ASSERTE((PS_INNER_BLOCK_SIZE > sizeof(PS_MEM_FREE)+sizeof(PS_MEM_FOOTER)));

    HRESULT hr = S_OK;

    if ((m_wszName == NULL) || (m_wszFileName == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _ASSERTE(m_hLock == NULL);

    m_hLock = WszCreateMutex(NULL, FALSE /* Initially not owned */, m_wszName);

    if (m_hLock == NULL)
    {
        Win32Message();
        hr = ISS_E_CREATE_MUTEX;
        goto Exit;
    }

    if (m_pData != NULL)
        goto Exit;    // Nothing to do here

    _ASSERTE(m_hFile == INVALID_HANDLE_VALUE);
    m_hFile = WszCreateFile(
        m_wszFileName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_FLAG_RANDOM_ACCESS,
        NULL);

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        Win32Message();
        hr = ISS_E_OPEN_STORE_FILE;
        goto Exit;
    }

    if (m_wFlags & PS_CREATE_FILE_IF_NECESSARY)
        hr = Create();

Exit:
    return hr;
}

HRESULT PersistedStore::VerifyHeader()
{
    HRESULT hr = S_OK;

    // Verify version / signature

    if (m_pHdr->qwSignature != PS_SIGNATURE)
    {
        hr = ISS_E_CORRUPTED_STORE_FILE;
        goto Exit;
    }

    // Major version changes are not compatible.
    if (m_pHdr->wMajorVersion != PS_MAJOR_VERSION)
        hr = ISS_E_STORE_VERSION;

Exit:
    return hr;
}


HRESULT PersistedStore::Map()
{
	// Check if there are any live pointers to the old mapped file !
    _ASSERTE(m_dwNumLivePtrs == 0);

    HRESULT hr = S_OK;

    // Mapping will fail if filesize is 0
    if (m_hMapping == NULL)
    {
        m_hMapping = WszCreateFileMapping(
            m_hFile,
            NULL,
            (m_wFlags & PS_OPEN_WRITE) ? PAGE_READWRITE : PAGE_READONLY,
            0,
            0,
            NULL);

        if (m_hMapping == NULL)
        {
            Win32Message();
            hr = ISS_E_OPEN_FILE_MAPPING;
            goto Exit;
        }
    }

    _ASSERTE(m_pData == NULL);

    m_pData = (PBYTE) MapViewOfFile(
        m_hMapping,
        (m_wFlags & PS_OPEN_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ,
        0,
        0,
        0);

    if (m_pData == NULL)
    {
        Win32Message();
        hr = ISS_E_MAP_VIEW_OF_FILE;
        goto Exit;
    }

    if (m_wFlags & PS_VERIFY_STORE_HEADER)
    {
        hr = VerifyHeader();

        // Verify only the first time
        m_wFlags &= ~PS_VERIFY_STORE_HEADER;
    }

Exit:
    return hr;
}

void PersistedStore::Unmap()
{
    // Check if there are any live pointers to the mapped file !
    _ASSERTE(m_dwNumLivePtrs == 0);

    if (m_pData)
    {
        UnmapViewOfFile(m_pData);
        m_pData = NULL;
    }
}

void PersistedStore::Close()
{
    Unmap();

    if (m_hMapping != NULL)
    {
        CloseHandle(m_hMapping);
        m_hMapping = NULL;
    }

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }

    if (m_hLock != NULL)
    {
        CloseHandle(m_hLock);
        m_hLock = NULL;
    }

#ifdef _DEBUG
    _ASSERTE(m_dwNumLocks == 0);
#endif
}

HRESULT PersistedStore::SetAppData(PS_HANDLE hnd)
{
    RETURN_ERROR_IF_FILE_NOT_MAPPED();
    m_pHdr->hAppData = hnd;
    return S_OK;
}

HRESULT PersistedStore::GetAppData(PS_HANDLE *phnd)
{
    RETURN_ERROR_IF_FILE_NOT_MAPPED();
    *phnd = m_pHdr->hAppData;
    return S_OK;
}

HRESULT PersistedStore::Alloc(PS_SIZE sSize, void **ppv)
{
    // Check if there are any live pointers to the mapped file !
    // This function could potentially unmap the file.

    _ASSERTE(m_dwNumLivePtrs == 0);

    // Make sure that the Store was open for Writing.. or else, writing to
    // the store will AV at a later point in execution.
    _ASSERTE(m_wFlags & PS_OPEN_WRITE);

    RETURN_ERROR_IF_FILE_NOT_MAPPED();

    HRESULT        hr;
    PPS_MEM_FREE   pFree;
    PPS_MEM_FREE   pPrev;
    PPS_MEM_FOOTER pFooter;
    PS_OFFSET      ofsPrev;
    PS_SIZE        sStreamAllocSize;

    LOCK(this);

    // Allocate only at PS_BLOCK_ALLIGN boundaries
    // When allocated from physical file / stream, allocs are done at larger
    // block sizes

    sSize = RoundToMultipleOf(sSize +
        sizeof(PS_MEM_HEADER) + sizeof(PS_MEM_FOOTER), PS_INNER_BLOCK_SIZE);

    pFree = (PPS_MEM_FREE) OfsToPtr(m_pHdr->sFreeList.ofsNext);
    pPrev = &(m_pHdr->sFreeList);

    while (pFree)
    {
        // First fit
        if (PS_SIZE(pFree) >= sSize)
        {
UpdateHeaderAndFooter:
            _ASSERTE(PS_IS_FREE(pFree));

            PS_SIZE rem = PS_SIZE(pFree) - sSize;

            if (rem >= PS_INNER_BLOCK_SIZE)
            {
                // We have space for another block left in this bigger block

                // Update the size of the allocated block header
                pFree->sSize = sSize;
                PS_SET_USED(pFree);

                // Create footer for allocated mem
                pFooter = PS_HDR_TO_FTR(pFree);

                pFooter->sSize = sSize;
                PS_SET_USED(pFooter);

                // Create the new free block header.
                PPS_MEM_FREE pNewFree  = (PPS_MEM_FREE)(pFooter + 1);
                pNewFree->sSize = rem;

				// Update the new free block footer
                pFooter = PS_HDR_TO_FTR(pNewFree);
				pFooter->sSize = rem;

				// Update the doubly linked list of free nodes.
                pNewFree->ofsNext = pFree->ofsNext;
				pNewFree->ofsPrev = pFree->ofsPrev;
				pPrev->ofsNext = PtrToOfs((void*)pNewFree);

				// Update the back pointer of the item in front to point to
				// the new free node
				if (pNewFree->ofsNext)
				{
					((PPS_MEM_FREE) OfsToPtr(pFree->ofsNext))->ofsPrev =
						PtrToOfs((void*)pNewFree);
				}
            }
            else
            {
                // Allocate the whole block

                PS_SET_USED(pFree);
                pFooter = PS_HDR_TO_FTR(pFree);
                PS_SET_USED(pFooter);

				// Remove this from the doubly linked list of free nodes
				// Update the previous free node to point to the next one.
				pPrev->ofsNext = pFree->ofsNext;

				// Update the back pointer of the item in front to point to
				// the new free node
				if (pFree->ofsNext)
				{
					((PPS_MEM_FREE) OfsToPtr(pFree->ofsNext))->ofsPrev =
						pFree->ofsPrev;
				}
            }

            // Create the return value
            *ppv = (PBYTE)pFree + sizeof(PS_MEM_USED);

#ifdef _DEBUG
            ++m_dwNumLivePtrs;
#endif
            break;
        }

        pPrev = pFree;
        pFree = (PPS_MEM_FREE) OfsToPtr(pFree->ofsNext);
    }

    // Not enough space in the stream
    if (pFree == NULL)
    {
		ofsPrev = PtrToOfs(pPrev);
        sStreamAllocSize = RoundToMultipleOf(sSize, m_dwBlockSize);

        if (m_pAlloc)
        {
            hr = m_pAlloc((void*)this, (void **)&pFree, (void **)&m_pData,
                &m_sSize, sStreamAllocSize);
        }
        else
        {
            hr = AllocMemoryMappedFile(sStreamAllocSize, (void **)&pFree);
        }

        if (FAILED(hr))
            goto Exit;

        // Create header and footer
        pFree->sSize   = sStreamAllocSize;
        pFree->ofsNext = 0;
        pFooter        = PS_HDR_TO_FTR(pFree);
		pFooter->sSize = sStreamAllocSize;

		// Add this to the doubly linked list of free nodes
        pFree->ofsPrev = ofsPrev;
		pPrev		   = (PPS_MEM_FREE) OfsToPtr(ofsPrev);
		pPrev->ofsNext = PtrToOfs(pFree);

        goto UpdateHeaderAndFooter;
    }

    UNLOCK(this);

Exit:
    return hr;
}

void PersistedStore::Free(PS_HANDLE hnd)
{
    _ASSERTE(m_pData);

#ifdef _DEBUG
    void *pv = HndToPtr(hnd);
    Free(pv);
    PS_DONE_USING_PTR(this, pv);
#else
    Free(HndToPtr(hnd));
#endif
}

void PersistedStore::Free(void *pv)
{
    _ASSERTE(m_pData);
    _ASSERTE(pv > m_pData);

    PPS_MEM_FREE    pFree,   pNextH;
    PPS_MEM_FOOTER  pFooter, pPrevF;

    // All allocated blocks are preceeded by a mem header
    // Note that sizeof MEM_HEADER and MEM_FREE are different, but the
    // offset of sSize field in these structures are the same.

    // All allocated memory blocks are preceeded by a PS_MEM_HEADER
    // Note that the only valid field in pFree is sSize
    pFree = (PPS_MEM_FREE) ((PBYTE)pv - sizeof(PS_MEM_HEADER));

    pFooter = PS_HDR_TO_FTR(pFree);

    _ASSERTE(PS_IS_USED(pFree));
    _ASSERTE(PS_IS_USED(pFooter));
    _ASSERTE(pFree->sSize == pFooter->sSize);

    // Try to merge if adjacent blocks are also free

    pPrevF = (PPS_MEM_FOOTER)((PBYTE)pFree - sizeof(PS_MEM_FOOTER));
    pNextH = (PPS_MEM_FREE)(pFooter + 1);

    if (PS_IS_FREE(pPrevF))
    {
        // Memory above pFree is free.
        PPS_MEM_FREE pPrevH = (PPS_MEM_FREE) PS_FTR_TO_HDR(pPrevF);

        _ASSERTE(PS_IS_FREE(pPrevH));

        if (IsValidPtr(pNextH) && PS_IS_FREE(pNextH))
        {
            // Memory above and below pFree are free.
            // Merge the 3 memory blocks into one big block.

            // Remove Next from the linked list of free Memory
            ((PPS_MEM_FREE)OfsToPtr(pNextH->ofsPrev))->ofsNext =
                pNextH->ofsNext;

            if (pNextH->ofsNext)
            {
                ((PPS_MEM_FREE)OfsToPtr(pNextH->ofsNext))->ofsPrev
                    = pNextH->ofsPrev;
            }

            // Adjust the size of the Previous block in it's header & footer

            pPrevH->sSize += PS_SIZE(pFree) + PS_SIZE(pNextH);
            pFooter        = PS_HDR_TO_FTR(pPrevH);
            pFooter->sSize = pPrevH->sSize;
        }
        else
        {
            // Merge free and the one preceeding it
            // Adjust the size of the previous block in it's header & footer
            pPrevH->sSize += PS_SIZE(pFree);
            pFooter        = PS_HDR_TO_FTR(pPrevH);
            pFooter->sSize = pPrevH->sSize;
        }
    }
    else
    {
        if (IsValidPtr(pNextH) && PS_IS_FREE(pNextH))
        {
            // The next one is free. Merge free with next

            // Adjust the size of free.
            pFree->sSize  = PS_SIZE(pFree) + PS_SIZE(pNextH);
            pFooter       = PS_HDR_TO_FTR(pFree);
            pFooter->sSize= pFree->sSize;
            
			// Adjust the previous and next to point to this
            ((PPS_MEM_FREE)OfsToPtr(pNextH->ofsPrev))->ofsNext =
                    PtrToOfs((void*)pFree);

            if (pNextH->ofsNext)
            {
                ((PPS_MEM_FREE)OfsToPtr(pNextH->ofsNext))->ofsPrev
                    = PtrToOfs((void*)pFree);
            }
        }
        else
        {
            // No merge in this case.
            PS_SET_FREE(pFree);
            pFooter = PS_HDR_TO_FTR(pFree);
            PS_SET_FREE(pFooter);

			// Add free to the doubly linked list of free nodes
			pFree->ofsNext = m_pHdr->sFreeList.ofsNext;
			pFree->ofsPrev = PtrToOfs((void*)&(m_pHdr->sFreeList));
			
			// Update the back pointer for the next item.
			if (pFree->ofsNext)
			{
				((PPS_MEM_FREE)OfsToPtr(pFree->ofsNext))->ofsPrev
                    = PtrToOfs((void*)pFree);
			}
			m_pHdr->sFreeList.ofsNext = PtrToOfs((void*)pFree);
        }
    }
}

void* PersistedStore::OfsToPtr(PS_OFFSET ofs)
{
    _ASSERTE(m_pData);

    return (void*) (ofs) ? (m_pData + ofs) : NULL;
}

void* PersistedStore::HndToPtr(PS_HANDLE hnd)
{
    _ASSERTE(m_pData);
#ifdef _DEBUG
    ++m_dwNumLivePtrs;
#endif
    return (void*) (hnd) ? (m_pData + hnd) : NULL;
}

PS_OFFSET PersistedStore::PtrToOfs(void *pv)
{
    _ASSERTE(m_pData);
    _ASSERTE(pv >= m_pData);

    return ((PBYTE)pv - m_pData);
}

PS_HANDLE PersistedStore::PtrToHnd(void *pv)
{
    _ASSERTE(m_pData);
    _ASSERTE(pv >= m_pData);

    return ((PBYTE)pv - m_pData);
}

#ifdef _DEBUG

void PersistedStore::DoneUseOfPtr(void **pp, bool fInvalidate)
{
    --m_dwNumLivePtrs;
    if (fInvalidate)
        *pp = NULL;
}

void PersistedStore::AssertNoLivePtrs()
{
    _ASSERTE(m_dwNumLivePtrs == 0);
}

#endif

bool PersistedStore::IsValidPtr(void *pv)
{
    _ASSERTE(m_pData);
    return ((PS_SIZE)((PBYTE)pv - m_pData) < m_sSize);
}

bool PersistedStore::IsValidHnd(PS_HANDLE hnd)
{
    return (hnd < m_sSize);
}

HRESULT PersistedStore::Lock()
{
    // Like all other methods in this class, this is not thread safe, 
    // and it is not intended to be. The caller should synchronize.
    // Lock is intented to be used for inter process synchronization.

#ifdef _DEBUG
    _ASSERTE(m_hLock);

    Log("Lock TID ");
    Log(GetThreadId());
#endif

    DWORD dwRet = WaitForSingleObject(m_hLock, INFINITE);

#ifdef _DEBUG
    ++m_dwNumLocks;

    if (dwRet == WAIT_OBJECT_0)
    {
        Log(" WAIT_OBJECT_0 ");
    }
    else if (dwRet == WAIT_ABANDONED)
    {
        Log(" WAIT_ABANDONED ");
    }

    Log("Done\n");
#endif

    if ((dwRet == WAIT_OBJECT_0) || (dwRet == WAIT_ABANDONED))
        return S_OK;


    Win32Message();
    return ISS_E_LOCK_FAILED;
}

void PersistedStore::Unlock()
{
#ifdef _DEBUG
    _ASSERTE(m_hLock);
    _ASSERTE(m_dwNumLocks >= 1);

    Log("Unlock TID ");
    Log(GetThreadId());
#endif

    ReleaseMutex(m_hLock);

#ifdef _DEBUG
    --m_dwNumLocks;
    Log("Done\n");
#endif
}

void PersistedStore::SetName(WCHAR *wszName)
{
    int len = (int)wcslen(wszName);
    if (m_wFlags & PS_MAKE_COPY_OF_STRING)
    {
        m_wszFileName = new WCHAR[len + 1];

        // In the Init() method, check for null and
        // return E_OUTOFMEMORY

        if (m_wszFileName)
            memcpy(m_wszFileName, wszName, (len + 1) * sizeof(WCHAR));
    }
    else
    {
        m_wszFileName = wszName;
    }

    m_wszName = new WCHAR[len + 1];

    // In the Init() method, check for null and
    // return E_OUTOFMEMORY
    if (m_wszName)
    {
        memcpy(m_wszName, wszName, (len + 1) * sizeof(WCHAR));

        // Find and replace '\' with '-' (for creating sync objects)
        for (int i=0; i<len; ++i)
        {
            if (m_wszName[i] == L'\\')
                m_wszName[i] = L'-';
        }
    }
}


WCHAR* PersistedStore::GetName()
{
    return m_wszName;
}

WCHAR* PersistedStore::GetFileName()
{
    return m_wszFileName;
}


HRESULT PersistedStore::Create()
{
    HRESULT         hr = S_OK;
    BYTE           *pb;
    PPS_HEADER      pHdr;
    PPS_MEM_FREE	pFree;
    PPS_MEM_FOOTER  pFooter;
    PS_SIZE         sHeaderBlock;
    DWORD           dwBlockSize;
    DWORD           dwWrite;

    LOCK(this);

    hr = GetFileSize(NULL);

    if (FAILED(hr))
        goto Exit;

    if (m_sSize < sizeof(PS_HEADER))
    {
        dwBlockSize = (DWORD) RoundToMultipleOf
                    (sizeof(PS_HEADER) + sizeof(PS_MEM_FOOTER), m_dwBlockSize);
                        // Allocation is always done in blocks of m_dwBlockSize

        pb = new BYTE[dwBlockSize];

        if (pb == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        memset(pb, 0, dwBlockSize);

        pHdr = (PPS_HEADER) pb;

        pHdr->qwSignature   = PS_SIGNATURE;
        pHdr->dwSystemFlag  = PS_OFFSET_SIZE;
        pHdr->dwPlatform    = PS_PLATFORM_X86 | PS_PLATFORM_9x | PS_PLATFORM_32;
        pHdr->dwBlockSize   = PS_DEFAULT_BLOCK_SIZE;
        pHdr->wMajorVersion = PS_MAJOR_VERSION;
        pHdr->wMinorVersion = PS_MINOR_VERSION;

        // The first free block starts at the next allocation boundary.
        // The remaining part of the first block is not used.

        sHeaderBlock = RoundToMultipleOf(sizeof(PS_HEADER) +
                sizeof(PS_MEM_FOOTER), PS_INNER_BLOCK_SIZE);

        // Setup the free blocks list, head node
        pHdr->sFreeList.sSize = sHeaderBlock;
        PS_SET_USED(&(pHdr->sFreeList));
        pHdr->sFreeList.ofsPrev = 0;

        // Create the footer for PS_HEADER block
        pFooter = (PPS_MEM_FOOTER) (pb + sHeaderBlock - sizeof(PS_MEM_FOOTER));
        pFooter->sSize = sHeaderBlock;
        PS_SET_USED(pFooter);

        if (dwBlockSize > (sHeaderBlock + PS_INNER_BLOCK_SIZE))
        {
            // Setup the first free block
            pFree = (PPS_MEM_FREE) (pb + sHeaderBlock);

            pFree->sSize = dwBlockSize - sHeaderBlock;

			// Get the offset in structure PS_HEADER and make it the prev node
			pFree->ofsPrev = (PS_OFFSET) &((PPS_HEADER)0)->sFreeList;

            // Footer for first free block
            pFooter = (PPS_MEM_FOOTER)((PBYTE)pFree + PS_SIZE(pFree) -
                    sizeof(PS_MEM_FOOTER));

            pFooter->sSize = pFree->sSize;

            // Insert the free block to the header free block linked list
            // (this free block will be the only element in the list for now.
            pHdr->sFreeList.ofsNext = sHeaderBlock;
        }
		else
		{
			hr = ISS_E_BLOCK_SIZE_TOO_SMALL;
			goto Exit;
		}

        dwWrite = 0;

        if ((WriteFile(m_hFile, pb, dwBlockSize, &dwWrite, NULL)
            == 0) || (dwWrite != dwBlockSize))
        {
            Win32Message();
            hr = ISS_E_FILE_WRITE;
        }

        delete [] pb;

        hr = GetFileSize(NULL);
    }

    UNLOCK(this);

Exit:
    return hr;
}

HRESULT PersistedStore::GetFileSize(PS_SIZE *psSize)
{
    HRESULT hr = S_OK;
    DWORD   dwLow  = 0;
    DWORD   dwHigh = 0;

    dwLow = ::GetFileSize(m_hFile, &dwHigh);

    if ((dwLow == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
    {
        Win32Message();
        hr = ISS_E_GET_FILE_SIZE;
        goto Exit;
    }

    m_sSize = ((QWORD)dwHigh << 32) | dwLow;

    if (psSize)
        *psSize = m_sSize;
Exit:
    return hr;
}

HRESULT PersistedStore::AllocMemoryMappedFile(
                PS_SIZE sSizeRequested,
                void    **ppv)
{
    HRESULT  hr      = S_OK;
    BYTE    *pb      = NULL;
    DWORD    dwLow   = 0;
    DWORD    dwHigh  = 0;
    DWORD    dwWrite = 0;
    boolean  fMapOnExit = false;
    DWORD    dwSizeRequested = (DWORD) sSizeRequested;

    _ASSERTE(m_hFile);

    LOCK(this);

    // WriteFile() supports only MAX_DWORD number of bytes to be writen,
    // hence this check to see if we missed something on Q -> DWORD

    if (dwSizeRequested != sSizeRequested)
    {
        hr = ISS_E_ALLOC_TOO_LARGE;
        goto Cleanup;
    }

    if (m_pData)
    {
        UnmapViewOfFile(m_pData);
        m_pData = NULL;
        fMapOnExit = true;
    }

    if (m_hMapping != NULL)
    {
        CloseHandle(m_hMapping);
        m_hMapping = NULL;
        fMapOnExit= true;
    }

    pb = new BYTE[dwSizeRequested];

    if (pb == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    memset(pb, 0, dwSizeRequested);

    // SetFilePointer can return -1. The file size can be equals (DWORD)(-1),
    // hence the extra check using GetLastError()

    dwLow = SetFilePointer(m_hFile, dwLow, (PLONG)&dwHigh, FILE_END);

    if ((dwLow == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
    {
        Win32Message();
        hr = ISS_E_SET_FILE_POINTER;
        goto Cleanup;
    }

    if ((WriteFile(m_hFile, pb, dwSizeRequested, &dwWrite, NULL) == 0) ||
        (dwWrite != dwSizeRequested))
    {
        Win32Message();
        hr = ISS_E_FILE_WRITE;
        goto Cleanup;
    }

    hr = GetFileSize(NULL);

Cleanup:

    if (pb)
        delete [] pb;

    if (fMapOnExit)
    {
        HRESULT hrMap;
        hrMap = Map();

        if (FAILED(hrMap))
        {
            // We may already have a failed hr. If that is the case,
            // propagate the first error out of this function.

            Win32Message();
            if (SUCCEEDED(hr))
                hr = hrMap;
        }
        else if (SUCCEEDED(hr))
        {
            // Set the return value to OffsetOf old file length.
            *ppv = m_pData + (((QWORD)dwHigh << 32) | dwLow);
        }
    }

    UNLOCK(this);

    return hr;
}

HRESULT PSBlobPool::Create(PS_SIZE   sData,
                           PS_HANDLE hAppData)
{
    PS_REQUIRES_ALLOC(m_ps);
    _ASSERTE(m_hnd == 0);

    HRESULT hr = S_OK;

    PPS_TABLE_HEADER pT = NULL;

    // A table header is always present in all tables
    hr = m_ps->Alloc(sizeof(PS_TABLE_HEADER) + sData, (void **)&pT);

    if (FAILED(hr))
        goto Exit;

    memset(pT, 0, sizeof(PS_TABLE_HEADER));

    pT->Flags.Version    = PS_TABLE_VERSION;
    pT->Flags.TableType  = PS_BLOB_POOL;
    pT->hAppData         = hAppData;

    m_hnd = m_ps->PtrToHnd((void*)pT);

    pT->BlobPool.sFree = sData;
    pT->BlobPool.hFree = m_hnd + sizeof(PS_TABLE_HEADER);

    PS_DONE_USING_PTR(m_ps, pT);

Exit:
    return hr;
}

HRESULT PSBlobPool::Insert(PVOID pv, DWORD cb, PS_HANDLE *pHnd)
{
    PS_REQUIRES_ALLOC(m_ps);

    HRESULT          hr = S_OK;
    PBYTE            pbDest;
    PS_SIZE          sSize;
    PS_HANDLE        hT;
    PPS_MEM_HEADER   pMem;
    PPS_TABLE_HEADER pT;

    _ASSERTE(m_hnd != 0);

    LOCK(m_ps);

    pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);

    while (pT->BlobPool.sFree < cb)
    {
        if (pT->hNext == 0)
        {
            // End of the linked list and space is still not available.
            // Create a new node.
    
            PSBlobPool btNew(m_ps, 0);
            pMem = (PPS_MEM_HEADER) ((PBYTE)pT - sizeof(PS_MEM_HEADER));
    
            // Use atleast the size of the last node
            sSize = PS_SIZE(pMem) -
                (sizeof(PS_MEM_HEADER) + sizeof(PS_MEM_FOOTER));
    
            // The Create function calls Alloc() which could remap the file
            // in m_ps. So it is not safe to use the old pT after Create()

            hT = m_ps->PtrToHnd((void*)pT);
            PS_DONE_USING_PTR_(m_ps, pT);

            hr = btNew.Create((sSize > cb) ? sSize : cb, pT->hAppData);
    
            if (FAILED(hr))
            {
                m_ps->Unlock();
                goto Exit;
            }
    
            pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(hT);

            pT->hNext = btNew.m_hnd;
    
            PS_DONE_USING_PTR(m_ps, pT);
            pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(btNew.m_hnd);
    
            break;
        }

        PS_DONE_USING_PTR_(m_ps, pT);
        pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(pT->hNext);
    }

    pbDest = (PBYTE) m_ps->HndToPtr(pT->BlobPool.hFree);

    if (pHnd)
        *pHnd = pT->BlobPool.hFree;

    pT->BlobPool.sFree -= cb;
    pT->BlobPool.hFree += cb;

    PS_DONE_USING_PTR(m_ps, pT);

    memcpy(pbDest, pv, cb);
    PS_DONE_USING_PTR(m_ps, pbDest);

    UNLOCK(m_ps);

Exit:
    return hr;
}

HRESULT PSTable::HandleOfRow(WORD wRow, PS_HANDLE *pHnd)
{
    HRESULT hr = S_OK;
    PPS_TABLE_HEADER pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);

    WORD wBase = 0;

    while ((pT->Table.wRows + wBase) < wRow)
    {
        if (pT->hNext == 0)
        {
            PS_DONE_USING_PTR(m_ps, pT);
            hr = ISS_E_TABLE_ROW_NOT_FOUND;
            goto Exit;
        }

        wBase += pT->Table.wRows;
        PS_DONE_USING_PTR_(m_ps, pT);
        pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(pT->hNext);
    }

    *pHnd = m_ps->PtrToHnd(((PBYTE)pT) + SizeOfHeader() + 
				(pT->Table.wRowSize * (wRow - wBase)));

    PS_DONE_USING_PTR(m_ps, pT);

Exit:
    return hr;
}

PS_SIZE PSTable::SizeOfHeader()
{
#ifdef _DEBUG
    PPS_TABLE_HEADER pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);
    _ASSERTE(pT->Flags.fHasUsedRowsBitmap == 0);
    PS_DONE_USING_PTR(m_ps, pT);
#endif

    return sizeof(PS_TABLE_HEADER);
}

PS_SIZE PSGenericTable::SizeOfHeader()
{
    PPS_TABLE_HEADER pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);
    _ASSERTE(pT->Flags.fHasUsedRowsBitmap);
    PS_DONE_USING_PTR_(m_ps, pT);

    return sizeof(PS_TABLE_HEADER) + 
        (NUM_DWORDS_IN_BITMAP(pT->Table.wRows) * sizeof(DWORD));
}

HRESULT PSGenericTable::Create(WORD      wRows,     // Number of rows
                               WORD      wRowSize,  // Size of one record
                               PS_HANDLE hAppData)  // [in] can be 0
{
    PS_REQUIRES_ALLOC(m_ps);
    _ASSERTE(m_hnd == 0);

    HRESULT          hr = S_OK;
    PPS_TABLE_HEADER pT = NULL;
    PS_SIZE          sData;
    DWORD            dwHeaderSize;

    dwHeaderSize = sizeof(PS_TABLE_HEADER) + 
                    (NUM_DWORDS_IN_BITMAP(wRows) * sizeof(DWORD));

    sData = (wRows * wRowSize);

    // A table header is always present in all tables
    hr = m_ps->Alloc(dwHeaderSize + sData, (void **)&pT);

    if (FAILED(hr))
        goto Exit;

    memset(pT, 0, dwHeaderSize);

    pT->Flags.Version  = PS_TABLE_VERSION;
    pT->Flags.TableType= PS_GENERIC_TABLE;
    pT->Flags.fHasUsedRowsBitmap = 1;
    pT->hAppData       = hAppData;
    pT->Table.wRows    = wRows;
    pT->Table.wRowSize = wRowSize;

    m_hnd = m_ps->PtrToHnd((void*)pT);

    PS_DONE_USING_PTR(m_ps, pT);

Exit:
    return hr;
}

HRESULT PSGenericTable::Insert(PVOID pv, PS_HANDLE *pHnd)
{
    PS_REQUIRES_ALLOC(m_ps);

    HRESULT     hr = S_OK;
    PBYTE       pbDest;
    DWORD      *pdw;
    WORD        wRows;
    WORD        wRowSize;
    WORD        wFreeSlot;
    PS_HANDLE   hT;
    PPS_TABLE_HEADER pT;

    LOCK(m_ps);

    pT        = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);
    wRows     = pT->Table.wRows;
    wRowSize  = pT->Table.wRowSize;
    wFreeSlot = GetFirstZeroBit((DWORD*)
            ((PBYTE)pT + sizeof(PS_TABLE_HEADER)), wRows);

    while (wFreeSlot == 0)
    {
        if (pT->hNext == 0)
        {
            // End of the linked list and space is still not available.
            // Create a new node.
    
            PSGenericTable gtNew(m_ps, 0);
    
            // The Create function calls Alloc() which could remap the file
            // in m_ps. So it is not safe to use the old pT after Create()

            hT = m_ps->PtrToHnd((void*)pT);
            PS_DONE_USING_PTR_(m_ps, pT);

            hr = gtNew.Create(wRows, wRowSize, pT->hAppData);
    
            if (FAILED(hr))
            {
                m_ps->Unlock();
                goto Exit;
            }
    
            pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(hT);

            pT->hNext = gtNew.m_hnd;

            PS_DONE_USING_PTR(m_ps, pT);
            pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(gtNew.m_hnd);
            wFreeSlot = 1;
    
            break;
        }

        PS_DONE_USING_PTR_(m_ps, pT);
        pT = (PPS_TABLE_HEADER) m_ps->HndToPtr(pT->hNext);

        wFreeSlot =  GetFirstZeroBit((DWORD*)
            ((PBYTE)pT + sizeof(PS_TABLE_HEADER)), wRows);
    }

    pdw = (DWORD*)((PBYTE)pT + sizeof(PS_TABLE_HEADER)); 

    SET_DWORD_BITMAP(pdw, (wFreeSlot - 1));

    pbDest = (PBYTE)((PBYTE)pT + SizeOfHeader() + wRowSize * (wFreeSlot - 1));

    PS_DONE_USING_PTR(m_ps, pT);

    memcpy(pbDest, pv, wRowSize);

    *pHnd = m_ps->PtrToHnd(pbDest);

    UNLOCK(m_ps);

Exit:
    return hr;
}

HRESULT PSArrayTable::Create(WORD      wRows,     // Number of rows
                             WORD      wRecsInRow,// records in one row
                             WORD      wRecSize,  // Size of one record
                             PS_HANDLE hAppData)  // [in] can be 0
{
    PS_REQUIRES_ALLOC(m_ps);
    _ASSERTE(m_hnd == 0);

    HRESULT          hr = S_OK;
    PPS_TABLE_HEADER pT = NULL;
    PS_SIZE          sData;

    sData = wRows * (sizeof(PS_ARRAY_LIST) + wRecSize * wRecsInRow);

    // A table header is always present in all tables
    hr = m_ps->Alloc(sizeof(PS_TABLE_HEADER) + sData, (void **)&pT);

    if (FAILED(hr))
        goto Exit;

    memset(pT, 0, sizeof(PS_TABLE_HEADER));

    pT->Flags.Version    = PS_TABLE_VERSION;
    pT->Flags.TableType  = PS_ARRAY_TABLE;
    pT->hAppData         = hAppData;

    pT->ArrayTable.wRows     = wRows;
    pT->ArrayTable.wRowSize  = sizeof(PS_ARRAY_LIST) +  wRecSize * wRecsInRow;
    pT->ArrayTable.wRecsInRow= wRecsInRow;
    pT->ArrayTable.wRecSize  = wRecSize;

    m_hnd = m_ps->PtrToHnd((void*)pT);
    PS_DONE_USING_PTR(m_ps, pT);

Exit:
    return hr;
}

HRESULT PSArrayTable::Insert(PVOID pv, WORD wRow)
{
    PS_REQUIRES_ALLOC(m_ps);

    _ASSERTE(m_hnd != 0);

    HRESULT hr = S_OK;
    PBYTE   pbDest;
    WORD    wRecsInRow;
    WORD    wRecSize;
    WORD    wRowSize;

    PS_HANDLE        hRow, hNew;
    PPS_ARRAY_LIST   pAL;
    PPS_TABLE_HEADER pT;

    LOCK(m_ps);

    hr = HandleOfRow(wRow, &hRow);

    if (FAILED(hr))
        goto Exit;

    // Find the size of one Record and number of records per Row.
    pT        = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);
    wRecsInRow= pT->ArrayTable.wRecsInRow;
    wRecSize  = pT->ArrayTable.wRecSize;
    wRowSize  = pT->ArrayTable.wRowSize;
    pAL       = (PPS_ARRAY_LIST) m_ps->HndToPtr(hRow);

    if (pAL->dwValid < wRecsInRow)
    {
        PS_DONE_USING_PTR(m_ps, pT);

        // Space available for one more entry in the row.
        pbDest = pAL->bData + (pAL->dwValid * wRecSize);
        ++(pAL->dwValid);
        PS_DONE_USING_PTR(m_ps, pAL);

        memcpy(pbDest, pv, wRecSize);
    }
    else
    {
        PS_DONE_USING_PTR(m_ps, pAL);

        // Make a new node and copy this record into the new node.
        // The new node will be in a different PSBlock.
        // Add this one record to the row and make the copied node the
        // next node. This will make insertions fast.


        // The hNext field of the ArrayListTable is a GenericTable.

        if (pT->hNext == 0)
        {
            // Create a new PSBlock
            PSGenericTable gtNew(m_ps, 0);

            PS_DONE_USING_PTR_(m_ps, pT);
            hr = gtNew.Create(pT->ArrayTable.wRows, wRowSize, pT->hAppData);

            if (FAILED(hr))
                goto Exit;

            // Insert() could invalidate pAL, pass a copy into insert

            PBYTE pb = new BYTE[wRowSize];

            if (pb == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hRow);
            memcpy(pb, pAL, wRowSize);

            PS_DONE_USING_PTR(m_ps, pAL);

            hr = gtNew.Insert(pb, &hNew);

            delete [] pb;

            if (FAILED(hr))
                goto Exit;

            // Insert() could invalidate pAL, pT

            pT  = (PPS_TABLE_HEADER) m_ps->HndToPtr(m_hnd);
            pAL = (PPS_ARRAY_LIST)   m_ps->HndToPtr(hRow);

            // Add this as the first node in the GenericNode linked list.

            pT->hNext  = gtNew.GetHnd();
            PS_DONE_USING_PTR(m_ps, pT);

            pAL->hNext = hNew;
            memcpy(pAL->bData, pv, wRecSize);
            pAL->dwValid = 1;
            PS_DONE_USING_PTR(m_ps, pAL);
        }
        else
        {
            PSGenericTable gtNext(m_ps, pT->hNext);
            PS_DONE_USING_PTR(m_ps, pT);

            // Insert a copy of this row in the next node in the linked list
            PBYTE pb = new BYTE[wRowSize];

            if (pb == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hRow);
            memcpy(pb, pAL, wRowSize);

            PS_DONE_USING_PTR(m_ps, pAL);

            hr = gtNext.Insert(pb, &hNew);

            delete [] pb;

            if (FAILED(hr))
                goto Exit;

            // Insert() could invalidate pAL, pT

            pAL = (PPS_ARRAY_LIST) m_ps->HndToPtr(hRow);

            // Make this the first record in the list.
            pAL->hNext = hNew;
            memcpy(pAL->bData, pv, wRecSize);
            pAL->dwValid = 1;
            PS_DONE_USING_PTR(m_ps, pAL);
        }
    }

    UNLOCK(m_ps);

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\log.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Log / trace function.
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#ifdef PS_LOG
#include <windows.h>
#include <crtdbg.h>
#include <iostream.h>
#include <stdio.h>

#include "Common.h"
#include "log.h"

static void _print(CHAR *sz)
{
    cout << sz;
}

void Log(BYTE *pb, DWORD cb)
{
    CHAR szBuff[4];

    for (DWORD i=0; i<cb; ++i)
    {
        sprintf(szBuff, "%X ", pb[i]);
        _print(szBuff);
    }
}

void LogNonZero(BYTE *pb, DWORD cb)
{
    CHAR szBuff[8];

    for (DWORD i=0; i<cb; ++i)
    {
        if (pb[i]) 
        {
            sprintf(szBuff, "%X:%X ", i, pb[i]);
            _print(szBuff);
        }
    }
}

void Log(WCHAR *wsz)
{
    if (wsz == NULL)
        return;

#define MAX_MSG_LEN 8192
    CHAR szBuff[MAX_MSG_LEN];
    sprintf(szBuff, "%S", wsz);
    _print(szBuff);
}

void Log(CHAR *sz)
{
    if (sz == NULL)
        return;

    _print(sz);
}

void Log(QWORD qw)
{
    CHAR ch[20];
    sprintf(ch, "%I64X", qw);
    _print(ch);
}

void LogBool(BOOL f)
{
    if (f) Log(L"true"); else Log(L"false");
}

#define CASE_PRINT(x) case x : _print(#x); break

void LogHR(HRESULT hr)
{
    switch (hr)
    {
    CASE_PRINT(ISS_E_OPEN_STORE_FILE);
    CASE_PRINT(ISS_E_OPEN_FILE_MAPPING);
    CASE_PRINT(ISS_E_MAP_VIEW_OF_FILE);
    CASE_PRINT(ISS_E_GET_FILE_SIZE);
    CASE_PRINT(ISS_E_FILE_WRITE);
    CASE_PRINT(ISS_E_CORRUPTED_STORE_FILE);
    CASE_PRINT(ISS_E_STORE_VERSION);
	CASE_PRINT(ISS_E_BLOCK_SIZE_TOO_SMALL);
    CASE_PRINT(ISS_E_ALLOC_TOO_LARGE);
    CASE_PRINT(ISS_E_SET_FILE_POINTER);
    CASE_PRINT(ISS_E_TABLE_ROW_NOT_FOUND);
    CASE_PRINT(ISS_E_USAGE_WILL_EXCEED_QUOTA);
    CASE_PRINT(ISS_E_CREATE_MUTEX);

    default :
        _print("HRESULT "); 
        Log(hr);
        break;
    }

    _print("\n");
}

void Win32Message()
{
#define FORMAT_MESSAGE_BUFFER_LENGTH 1024

    WCHAR wszBuff[FORMAT_MESSAGE_BUFFER_LENGTH];

    DWORD res = FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            GetLastError(),
            0,
            wszBuff,
            FORMAT_MESSAGE_BUFFER_LENGTH-1,
            0);

    _print("Win32 : ");

    if (res == 0)
        _print("Unable to FormatMessage for Win32Error\n");
    else
        Log(wszBuff);
}

void Indent(int indent)
{
    for (int i=0; i<indent; ++i)
        _print("\t");
}

bool LogBitMask::Log(DWORD dw)
{
    bool fAtleastOne = false;

    for (int i=0; i<m_count; ++i)
    {
        if (dw & m_pName[i].m_dw)
        {
            if (fAtleastOne)
                _print(" ");
            _print(m_pName[i].m_psz);
            fAtleastOne = true;
        }
    }

    return fAtleastOne;
}

bool LogConst::Log(DWORD dw)
{
    bool fAtleastOne = false;

    for (int i=0; i<m_count; ++i)
    {
        if (dw == m_pName[i].m_dw)
        {
            if (fAtleastOne)
                _print(" ");
            _print(m_pName[i].m_psz);
            fAtleastOne = true;
        }
    }

    return fAtleastOne;
}

bool LogArray::Log(DWORD dw)
{
    bool fAtleastOne = false;

    if (dw < m_count)
    {
        _print(m_pName[dw].m_psz);
        fAtleastOne = true;
    }

    return fAtleastOne;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Precompiled header
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\shell.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Shell Declarations
 *
 * Author: Shajan Dasan
 * Date:  May 17, 2000
 *
 ===========================================================*/

#pragma once

#include "PersistedStore.h" 

#define PS_SHELL_VERBOSE 0x00000001
#define PS_SHELL_QUIET   0x00000002

void Shell(PersistedStore *ps, DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Precompiled header
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#include <windows.h>
#include <crtdbg.h>

#include "Common.h"
#include "Utils.h"
#include "Log.h"
#include "PersistedStore.h"
#ifndef PS_STANDALONE
#include "UtilCode.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\log.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Error and general logging / tracing
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#pragma once

#ifdef PS_LOG
#define LogLn(x) { Log(x); Log(L"\n"); }
void LogNonZero(BYTE *pb, DWORD cb);
void Log(BYTE *pb, DWORD cb);
void Log(CHAR *sz);
void Log(WCHAR *wsz);
void Log(QWORD qw);
void LogBool(BOOL f);
void LogHR(HRESULT hr);
void Win32Message();
void Indent(int indent);
#else
#define LogNonZero(x)
#define Log(x)
#define LogBool(x)
#define LogHR(hr)
#define Win32Message()
#define Indent(indent)
#endif

#ifdef PS_LOG

#define CONST_NAME(n) ConstName(#n, n)

class ConstName
{
public:
    ConstName(CHAR *psz, DWORD dw) 
        : m_psz(psz), m_dw(dw)
    {
    }

    CHAR *m_psz;
    DWORD m_dw;
};

class LogData
{
public:
    LogData(ConstName *pName, WORD count)
        : m_pName(pName), m_count(count)
    {
    }

    virtual bool Log(DWORD dw) = 0;

protected:
    ConstName *m_pName;
    WORD   m_count;
};

class LogBitMask : public LogData
{
public :
    LogBitMask(ConstName *pName, WORD count)
        : LogData(pName, count)
    {
    }

    virtual bool Log(DWORD dw);
};

class LogConst : public LogData
{
public :
    LogConst(ConstName *pName, WORD count)
        : LogData(pName, count)
    {
    }

    virtual bool Log(DWORD dw);
};

class LogArray : public LogData
{
public :
    LogArray(ConstName *pName, WORD count)
        : LogData(pName, count)
    {
    }

    virtual bool Log(DWORD dw);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\utils.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Utils for Store
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#pragma once

WCHAR* C2W(const CHAR *sz);     // Caller frees
CHAR*  W2C(const WCHAR *wsz);   // Caller frees

// Rounds up tNum so that it is a multiple of dwMultiple and >= tNum
template <class T>
T RoundToMultipleOf(T tNum, DWORD dwMultiple)
{
    if (tNum > dwMultiple)
    {
        DWORD dwRem = (DWORD)(tNum % dwMultiple);
    
        if (dwRem != 0)
            tNum += (dwMultiple - dwRem);
    }
    else
        return (T) dwMultiple;

    return tNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\utils.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Utils implementation
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#include <Windows.h>
#include <stdio.h>
#include "Common.h"
#include "Utils.h"

// Caller frees
WCHAR* C2W(const CHAR *sz)
{
    if (sz == NULL)
        return NULL;

    int len = strlen(sz) + 1;
    WCHAR *wsz = new WCHAR[len];
    MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, len);

    return wsz;
}

// Caller frees
CHAR* W2C(const WCHAR *wsz)
{
    if (wsz == NULL)
        return NULL;

    CHAR *sz = new CHAR[wcslen(wsz) + 1];
    sprintf(sz, "%S", wsz);

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\security\store\test.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Testing the store
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#include <windows.h>
#include <iostream.h>
#include <stdio.h>
#include "Common.h"
#include "Utils.h"
#include "Log.h"
#include "PersistedStore.h"
#include "AccountingInfoStore.h"
#include "Shell.h"

WCHAR *g_FileName = NULL;

bool g_fAlloc       = false;
int  g_nAlloc       = 1;
int  g_nAllocMul    = 1;
bool g_fFree        = false;
int  g_nFreeFreq    = 1;

bool g_fBlob        = false;
int  g_nBlob        = 1;
int  g_nBlobMul     = 1;
int  g_nBPSize      = 1000;
int  g_nBPAppData   = 2;

bool g_fArrayTable  = false;
int  g_nATRec       = 1;
int  g_nATArrays    = 1;
int  g_nATRecSize   = 1;
int  g_nATRowSize   = 1;
int  g_nATAppData   = 3;

bool g_fShell       = false;

void TestAlloc(PersistedStore *ps);
void TestBlob(PersistedStore *ps);
void TestArrayTable(PersistedStore *ps);

void Usage()
{
    Log("Usage :\n\n");
    Log("test <file-name> [options]\n");
    Log("options :\n");
    Log("\t[Alloc [n] [AllocMul n] [Free  [n]]]\n"); 
    Log("\t[Blob  [n] [BlobMul  n] [BPSize n] [BPAppData n]]\n"); 
    Log("\t[ATabl [n] [ATRec n] [ATRecSize n] [ATRowSize n] [ATAppData n]]\n");
    Log("\t[Shell]\n");
}

void GetParams(int argc, char **argv)
{
    for (int i=2; i<argc; ++i)
    {
        if (stricmp(argv[i], "Alloc") == 0)
        {
            g_fAlloc = true;
            if (i + 1 < argc)
                g_nAlloc = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "AllocMul") == 0) && (i + 1 < argc))
        {
            g_nAllocMul = atoi(argv[i + 1]);
        }
        else if (stricmp(argv[i], "Free") == 0)
        {
            g_fFree = true;
            if (i + 1 < argc)
                g_nFreeFreq = atoi(argv[i + 1]);
        }
        else if (stricmp(argv[i], "Blob") == 0)
        {
            g_fBlob = true;
            if (i + 1 < argc)
                g_nBlob = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "BlobMul") == 0) && (i + 1 < argc))
        {
            g_nBlobMul = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "BPSize") == 0) && (i + 1 < argc))
        {
            g_nBPSize = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "BPAppData") == 0) && (i + 1 < argc))
        {
            g_nBPAppData = atoi(argv[i + 1]);
        }
        else if (stricmp(argv[i], "ATabl") == 0)
        {
            g_fArrayTable = true;
            if (i + 1 < argc)
                g_nATArrays = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "ATRec") == 0) && (i + 1 < argc))
        {
            g_nATRec = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "ATRecSize") == 0) && (i + 1 < argc))
        {
            g_nATRecSize = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "ATRowSize") == 0) && (i + 1 < argc))
        {
            g_nATRowSize = atoi(argv[i + 1]);
        }
        else if ((stricmp(argv[i], "ATAppData") == 0) && (i + 1 < argc))
        {
            g_nATAppData = atoi(argv[i + 1]);
        }
        else if (stricmp(argv[i], "Shell") == 0)
        {
            g_fShell = true;
        }
    }
}

void main(int argc, char **argv)
{
    if (argc < 2)
    {
        Usage();
        return;
    }

    g_FileName = C2W(argv[1]);

    if (g_FileName == NULL)
    {
        LogHR(COR_E_OUTOFMEMORY);
        goto Exit;
    }

    GetParams(argc, argv);

    PersistedStore ps(g_FileName,
        PS_OPEN_WRITE | PS_CREATE_FILE_IF_NECESSARY | PS_VERIFY_STORE_HEADER);

    HRESULT hr = ps.Init();

    if (FAILED(hr))
    {
        LogHR(hr);
        goto Exit;
    }

    hr = ps.Map();

    if (FAILED(hr))
    {
        LogHR(hr);
        goto Exit;
    }

    if (g_fAlloc)
        TestAlloc(&ps);

    if (g_fBlob)
        TestBlob(&ps);

    if (g_fArrayTable)
        TestArrayTable(&ps);

    if (g_fShell)
        Shell(&ps, PS_SHELL_VERBOSE);

    ps.Unmap();

Exit:
    ps.Close();

    delete [] g_FileName;
}

void TestAlloc(PersistedStore *ps)
{
	HRESULT hr;
    void *pv;

    for (int i=0; i<g_nAlloc; ++i)
    {
        hr = ps->Alloc((i + 1) * g_nAllocMul, &pv);

        if (FAILED(hr))
            LogHR(hr);
        else if (g_fFree && (i % g_nFreeFreq) == 0)
            ps->Free(pv);
        
		PS_DONE_USING_PTR(ps, pv);
    }
}

void TestBlob(PersistedStore *ps)
{
	HRESULT hr;
    void    *pv;
    void    *pvStore;
    PS_HANDLE *phnd;

    PSBlobPool bp(ps, 0);

    hr = bp.Create(g_nBPSize, g_nBPAppData);

    if (FAILED(hr))
    {
        LogHR(hr);
        return;
    }

    pv = new BYTE[g_nBlob * g_nBlobMul];
    phnd = new PS_HANDLE[g_nBlob];

    for (int i=0; i<g_nBlob; ++i)
    {
        memset(pv, (i%26 + 'a'), (i + 1) * g_nBlobMul);

        hr = bp.Insert(pv, (i + 1) * g_nBlobMul, &phnd[i]);

        if (FAILED(hr))
            LogHR(hr);

    }

    for (i=0; i<g_nBlob; ++i)
    {
        memset(pv, (i%26 + 'a'), (i + 1) * g_nBlobMul);

        pvStore = ps->HndToPtr(phnd[i]);

        if (memcmp(pv, pvStore, (i + 1) * g_nBlobMul) != 0)
        {
            Log("Error : TestBlob()");
            Log(i);
            Log("\n");
        }

        PS_DONE_USING_PTR(ps, pvStore);
    }

    delete [] phnd;
    delete [] pv;
}

void TestArrayTable(PersistedStore *ps)
{
	HRESULT hr;
    void    *pv;

    PSArrayTable al(ps, 0);

    hr = al.Create((WORD)g_nATArrays, (WORD)g_nATRowSize, 
                (WORD)g_nATRecSize, (WORD)g_nATAppData);

    if (FAILED(hr))
    {
        LogHR(hr);
        return;
    }

    pv = new BYTE[g_nATRecSize];

    for (int i=0; i<g_nATRec; ++i)
    {
        memset(pv, (i%26 + 'a'), g_nATRecSize);

        hr = al.Insert(pv, (WORD)(i%g_nATArrays));

        if (FAILED(hr))
            LogHR(hr);
    }

    delete [] pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\shimload\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define STRICT
#include <windows.h>
#include <crtdbg.h>
#pragma hdrstop
#include <stdlib.h>
#include <malloc.h>
#include "delayImp.h"
#include "ShimLoad.h"
#include <mscoree.h>
#include <stdio.h>

//*****************************************************************************
// Sets/Gets the directory based on the location of the module. This routine
// is called at COR setup time. Set is called during EEStartup.
//*****************************************************************************
static DWORD g_dwSystemDirectory = 0;
static WCHAR g_pSystemDirectory[_MAX_PATH + 1];
WCHAR g_wszDelayLoadVersion[64] = {0};
HRESULT SetInternalSystemDirectory()
{
    HRESULT hr = S_OK;
    
    if(g_dwSystemDirectory == 0) {
        // This piece of code assumes that mscoree is loaded. We
        // do not want to do an explcite LoadLibrary/FreeLibrary here because 
        // this is in the code path of PROCESS_ATTACH and Win2k/Whistler 
        // folks do not guarantee error notifications for unsuccessful LoadLibrary's
        // @TODO: Use Wsz version of GetModuleHandle form winwrap.h
        HMODULE hmod = GetModuleHandle("mscoree.dll");

        // Assert now to catch anyone using this code without mscoree loaded.
        _ASSERTE (hmod && "mscoree.dll is not yet loaded");

        DWORD len;

        if(hmod == NULL)
            return HRESULT_FROM_WIN32(GetLastError());;
        
        GetCORSystemDirectoryFTN pfn;
        pfn = (GetCORSystemDirectoryFTN) ::GetProcAddress(hmod, 
                                                          "GetCORSystemDirectory");
        
        if(pfn == NULL)
            hr = E_FAIL;
        else
            hr = pfn(g_pSystemDirectory, _MAX_PATH+1, &len);

        if(FAILED(hr)) {
            g_pSystemDirectory[0] = L'\0';
            g_dwSystemDirectory = 1;
        }
        else{
            g_dwSystemDirectory = len;
        }
    }
    return hr;
}

static HRESULT LoadLibraryWithPolicyShim(LPCWSTR szDllName, LPCWSTR szVersion,  BOOL bSafeMode, HMODULE *phModDll)
{
	static LoadLibraryWithPolicyShimFTN pLLWPS=NULL;
	if (!pLLWPS)
	{
		HMODULE hmod = GetModuleHandle("mscoree.dll");

			// Assert now to catch anyone using this code without mscoree loaded.
		_ASSERTE (hmod && "mscoree.dll is not yet loaded");
		pLLWPS=(LoadLibraryWithPolicyShimFTN)::GetProcAddress(hmod, 
                                                          "LoadLibraryWithPolicyShim");
        
	}

    if (!pLLWPS)
        return E_POINTER;
	return pLLWPS(szDllName,szVersion,bSafeMode,phModDll);
}

HRESULT GetInternalSystemDirectory(LPWSTR buffer, DWORD* pdwLength)
{

    if (g_dwSystemDirectory == 0)
        SetInternalSystemDirectory();

    //We need to say <= for the case where the two lengths are exactly equal
    //this will leave us insufficient space to append the null.  Since some
    //of the callers (see AppDomain.cpp) assume the null, it's safest to have
    //it, even on a counted string.
    if(*pdwLength <= g_dwSystemDirectory) {
        *pdwLength = g_dwSystemDirectory;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    wcsncpy(buffer, g_pSystemDirectory, g_dwSystemDirectory);
    *pdwLength = g_dwSystemDirectory;
    return S_OK;
}


//*****************************************************************************
// This routine is our Delay Load Helper.  It will get called for every delay
// load event that occurs while the application is running.
//*****************************************************************************
FARPROC __stdcall ShimDelayLoadHook(     // Always 0.
    unsigned        dliNotify,          // What event has occured, dli* flag.
    DelayLoadInfo   *pdli)              // Description of the event.
{
    HMODULE result = NULL;
    switch(dliNotify) {
    case dliNotePreLoadLibrary:
        if(pdli->szDll)
		{
			WCHAR wszVersion[64];
	        if (g_wszDelayLoadVersion[0] == 0)
			    swprintf(wszVersion, L"v%d.%d.%d", CLR_MAJOR_VERSION, CLR_MINOR_VERSION, CLR_BUILD_VERSION );
            else
                wcscpy(wszVersion, g_wszDelayLoadVersion); 
                
			DWORD 	dwLen=MultiByteToWideChar(CP_ACP,0,pdli->szDll,strlen(pdli->szDll)+1,NULL,0);
			
			if (dwLen)
			{
				LPWSTR wszDll=(LPWSTR)alloca((dwLen)*sizeof(WCHAR));
				if(wszDll&&MultiByteToWideChar(CP_ACP,0,pdli->szDll,strlen(pdli->szDll)+1,wszDll,dwLen))
					if (FAILED(LoadLibraryWithPolicyShim(wszDll,wszVersion,FALSE,&result)))
						result=LoadLibrary(pdli->szDll);
			}
		}
        break;
    default:
        break;
    }
    
    return (FARPROC) result;
}

FARPROC __stdcall ShimSafeModeDelayLoadHook(     // Always 0.
    unsigned        dliNotify,          // What event has occured, dli* flag.
    DelayLoadInfo   *pdli)              // Description of the event.
{
    HMODULE result = NULL;
    switch(dliNotify) {
    case dliNotePreLoadLibrary:
        if(pdli->szDll)
		{
			WCHAR wszVersion[64];
	        if (g_wszDelayLoadVersion[0] == 0)
			    swprintf(wszVersion, L"v%d.%d.%d", CLR_MAJOR_VERSION, CLR_MINOR_VERSION, CLR_BUILD_VERSION );
            else
                wcscpy(wszVersion, g_wszDelayLoadVersion); 
			
			DWORD 	dwLen=MultiByteToWideChar(CP_ACP,0,pdli->szDll,strlen(pdli->szDll)+1,NULL,0);
			
			if (dwLen)
			{
				LPWSTR wszDll=(LPWSTR)alloca((dwLen)*sizeof(WCHAR));
				if(wszDll&&MultiByteToWideChar(CP_ACP,0,pdli->szDll,strlen(pdli->szDll)+1,wszDll,dwLen))
					if (FAILED(LoadLibraryWithPolicyShim(wszDll,wszVersion,TRUE,&result)))
						result=LoadLibrary(pdli->szDll);
			}
		}
        break;
    default:
        break;
    }
    
    return (FARPROC) result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\adepends.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Assembly Dependancies Lister
//
// Lists all Assemblies that an Assembly is dependant upon to load.
//

namespace ADepends
  {
  using System;
  using System.Collections; // ArrayList
  using System.Diagnostics; // Trace
  using System.Reflection;  // Module
  using System.Text;        // StringBuilder
  using System.Windows.Forms;    // Application
  using System.Runtime.InteropServices;   // StructLayout, etc.


  // Used when creating a new process.
  [StructLayout(LayoutKind.Sequential)]
    internal struct StartupInfo
    {
    // ``cb'' should be equal to 68 
    // (the result of ``printf ("%i\n", sizeof(STARTUPINFO));'' in C++)
    public UInt32 cb;
    public UInt32 lpReserved;
    public UInt32 lpDesktop;
    public UInt32 lpTitle;
    public UInt32 dwX;
    public UInt32 dwY;
    public UInt32 dwXSize;
    public UInt32 dwYSize;
    public UInt32 dwXCountChars;
    public UInt32 dwYCountChars;
    public UInt32 dwFillAttribute;
    public UInt32 dwFlags;
    public UInt16 wShowWindow;
    public UInt16 cbReserved2;
    public UInt32 lpReserved2;
    public UInt32 hStdInput;
    public UInt32 hStdOutput;
    public UInt32 hStdError;
    }


  // Flags that can be used in StartupInfo.dwFlags.
  [Flags()]
    internal enum StartFlags : uint
    {
    STARTF_USESHOWWINDOW    = 0x00000001,
    STARTF_USESIZE          = 0x00000002,
    STARTF_USEPOSITION      = 0x00000004,
    STARTF_USECOUNTCHARS    = 0x00000008,
    STARTF_USEFILLATTRIBUTE = 0x00000010,
    STARTF_RUNFULLSCREEN    = 0x00000020,  // ignored for non-x86 platforms
    STARTF_FORCEONFEEDBACK  = 0x00000040,
    STARTF_FORCEOFFFEEDBACK = 0x00000080,
    STARTF_USESTDHANDLES    = 0x00000100
    }

  // Flags that can be used in StartupInfo.wShowWindow
  [Flags()]
    internal enum ShowWindowFlags : ushort
    {
    SW_HIDE             = 0,
    SW_SHOWNORMAL       = 1,
    SW_NORMAL           = 1,
    SW_SHOWMINIMIZED    = 2,
    SW_SHOWMAXIMIZED    = 3,
    SW_MAXIMIZE         = 3,
    SW_SHOWNOACTIVATE   = 4,
    SW_SHOW             = 5,
    SW_MINIMIZE         = 6,
    SW_SHOWMINNOACTIVE  = 7,
    SW_SHOWNA           = 8,
    SW_RESTORE          = 9,
    SW_SHOWDEFAULT      = 10,
    SW_FORCEMINIMIZE    = 11,
    SW_MAX              = 11,
    }

  // Flags that can be used in CreateProcess.
  [Flags()]
    internal enum CreationFlags : uint
    {
    CREATE_BREAKAWAY_FROM_JOB   = 0x01000000,
    CREATE_DEFAULT_ERROR_MODE   = 0x04000000,
    CREATE_FORCE_DOS            = 0x00002000,
    CREATE_NEW_CONSOLE          = 0x00000010,
    CREATE_NEW_PROCESS_GROUP    = 0x00000200,
    CREATE_NO_WINDOW            = 0x08000000,
    CREATE_SEPARATE_WOW_VDM     = 0x00000800,
    CREATE_SHARED_WOW_VDM       = 0x00001000,
    CREATE_SUSPENDED            = 0x00000004,
    CREATE_UNICODE_ENVIRONMENT  = 0x00000400,
    DEBUG_PROCESS               = 0x00000001,
    DEBUG_ONLY_THIS_PROCESS     = 0x00000002,
    DETACHED_PROCESS            = 0x00000008,
    // --- Priority class stuff
    ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000,
    BELOW_NORMAL_PRIORITY_CLASS = 0x00004000,
    HIGH_PRIORITY_CLASS         = 0x00000080,
    IDLE_PRIORITY_CLASS         = 0x00000040,
    NORMAL_PRIORITY_CLASS       = 0x00000020,
    REALTIME_PRIORITY_CLASS     = 0x00000100
    }


  /** Information about a process created via CreateProcess(). */
  [StructLayout(LayoutKind.Sequential)]
    internal struct ProcessInfo
    {
    public UInt32 hProcess;
    public UInt32 hThread;
    public UInt32 dwProcessId;
    public UInt32 dwThreadId;
    }


  // The main program, responsible for checking arguments, creating
  // a GUI (if specified), and generating console output (if specified).
  public class MainProgram
    {
    /** How to load Assemblies... */
    private static LoadAssemblyInfo m_lai;

    /** App Config file? */
    private static string m_config;

    // Print the help message to the console output.
    private static void _print_help ()
      {Console.WriteLine (Localization.HELP_MESSAGE);}

    // Display ``string'' to the console, display the program help text,
    // and exit the program.
    private static void _exit (string reason)
      {
      Console.WriteLine (reason);
      Console.WriteLine (Localization.SHORT_HELP_MESSAGE);
      Environment.Exit (1);
      }

    /** How we create the GUI process. */
    [DllImport("kernel32", EntryPoint="CreateProcess")] 
      private static extern Boolean _nCreateProcess (
      string appName, string cmdLine, uint psaProcess, uint psaThread, 
      bool bInheritHandles, uint dwCreationFlags, uint pEnv, 
      string currentDir, ref StartupInfo si, out ProcessInfo pi);
   
    /** To close the handles that CreateProces() returns. */
    [DllImport("kernel32", EntryPoint="CloseHandle")] 
      private static extern bool _nCloseHandle(uint handle);

    // Create a new process (and thus a console) for the GUI to "hog".
    private static void _create_gui_process (string s)
      {
      try
        {
        StartupInfo si = new StartupInfo ();
        si.cb = 68;
        si.dwFlags = (uint) StartFlags.STARTF_USESHOWWINDOW;
        si.wShowWindow = (ushort) ShowWindowFlags.SW_NORMAL;
        ProcessInfo pi;

        StringBuilder sb = new StringBuilder ();

        // add the filename for this program so we're re-launched.
        sb.Append (Process.GetCurrentProcess().MainModule.FileName);

        // specify that the new process should use it's current environment.
        sb.Append (" " + Localization.USE_CURRENT_PROCESS[0] + " ");

        // the rest of the program arguments.
        sb.Append (s);

        Trace.WriteLine ("spawning: " + sb.ToString());

        if (_nCreateProcess (
            null,           // executable name
            sb.ToString(),  // command line
            0,              // process security attributes
            0,              // thread security attributes 
            false,          // inherit handles
            (uint) CreationFlags.DETACHED_PROCESS,  // creation flags
            0,              // new environment block
            null,           // current directory name
            ref si,         // startup information
            out pi))        // process information
          {
          // GUI process was created; clean up our resources.
          _nCloseHandle(pi.hProcess);
          _nCloseHandle(pi.hThread);
          }
        else
          throw new Exception(Localization.CP_FAIL);
        }
      catch (Exception e)
        {
        _exit (e.Message);
        }
      }

    // The main program; parses program arguments, and executes the 
    // (right) program.
    [STAThread]
    public static void Main (string[] args)
      {
      ParseOptions po = null;

      try
        {
        po = new ParseOptions (args);
        }
      catch (OptionException e)
        {
        _exit (e.Message);
        }

      if (po.Help)
        _print_help ();
      else if (po.Gui)
        {
        // if we've been asked to take over this process...
        if (po.TakeOverCurrentProcess)
          Application.Run (
            new DependenciesForm (po.Files, po.LoadAssemblyInfo));
        else
          // ...otherwise, spawn a new process.
          _create_gui_process (po.SerializeOptions());
        }
      else
        {
        // console output.
        m_lai = po.LoadAssemblyInfo;
        m_config = po.ConfigurationFile;
        _display_files (po.Files);
        }
      }

    // Display the dependencies for ``files''.
    private static void _display_files (IList files)
      {
      if (files.Count == 0)
        {
        // No files specified; display the help text.
        _print_help ();
        }
      else if (files.Count == 1)
        {
        _print_manifest ((String)files[0], true);
        }
      else
        {
        foreach (String name in files)
          {
          Console.WriteLine (Localization.MANIFEST + name);
          _print_manifest (name, false);
          Console.WriteLine ();
          }
        }
      }

    // Displays the contents of a manifest to the console window.
    //
    private static void _print_manifest (String manifest, bool prefix)
      {
      AssemblyDependencies ad = null;
      try
        {
        ad = new AssemblyDependencies (manifest, m_lai);
        }
      catch (System.ArgumentNullException e)
        {
        _error_message (Localization.INVALID_ASSEMBLY_MANIFEST, prefix);
        Trace.WriteLine ("Exception: " + e.ToString());
        return;
        }
      catch (System.Exception e)
        {
        _error_message (e.Message, prefix);
        Trace.WriteLine ("Exception: " + e.ToString());
        return;
        }

      ArrayList observed = new ArrayList ();
      _print_info (ad, ad.ManifestName, observed, prefix ? 0 : 1);

      if (m_config != null && m_config.Length > 0)
        AppConfig.SaveConfig (ad, m_config);
      ad.Dispose ();
      }


    // Prints the message ``message'' to the screen.
    //
    // If ``prefix'' is ``true'', then the program name is prefixed before
    // the error message (e.g. "adepends: Invalid Assembly Manifest Specified").
    // Otherwise, the output is indented by one spot, so the output remains
    // heirarchical.
    private static void _error_message (String message, bool prefix)
      {if (prefix)
        Console.Write (Localization.PROGRAM_NAME + ": ");
      else
        _indent (1);
      Console.WriteLine (message.Length > 0 
        ? message 
        : Localization.UNKNOWN_ERROR);}

    // Print ``Localization.INDENT'' ``s'' times from the current line
    // position.
    private static void _indent (int s)
      {
      for (int i = 0; i < s; i++)
        Console.Write (Localization.INDENT);
      }

    // Print the information associated with an Assembly, such as its dependant
    // assemblies and the files contained within it.
    private static void _print_info 
      (AssemblyDependencies ad, String name, ArrayList o, int level)
      {
      _indent (level);
      IAssemblyInfo ai = ad[name];
      Console.WriteLine (ai.Name);

      if (!o.Contains (name))
        {
        o.Add (name);
        _indent (level); Console.WriteLine (Localization.DEPENDANT_ASSEMBLIES);

        foreach (AssemblyName s in ai.ReferencedAssemblies)
          {
          _print_info (ad, s.FullName, o, level+2);
          }

        _indent (level);
        Console.WriteLine (Localization.DEPENDANT_FILES);

        foreach (ModuleInfo m in ai.ReferencedModules)
          {
          _indent (level+2);
          Console.WriteLine (m.Name);
          }
        }
      }
    } /* class MainProgram */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\appconfig.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Writes out the Application Configuration File from an 
// AssemblyDependencies listing.
//

namespace ADepends
  {
  using System;
  using System.Collections; // IComparer
  using System.Diagnostics; // Debug
  using System.Reflection;  // Assembly
  using System.Text;        // Encoding
  using System.Xml;         // XML stuff...

  // Writes out an template Application Configuration File for use during
  // the loading of the Application.
  //
  // It provides AssemblyIdentity rows for all Assemblies available from
  // an AssemblyDependencies object.
  //
  // All other rows (AppDomain, BindingMode, and BindingPolicy) are
  // either empty (BindingPolicy), guessed at (AppDomain & BindingMode), 
  // or have a commented out implementation for demo purposes (BindingPolicy).
  internal class AppConfig
    {
    // Save a configuration file that lists the Assemblies contained in
    // ``ad'', writing the contents to the file ``file''.
    public static void SaveConfig (AssemblyDependencies ad, string file)
      {
      if (ad == null)
        Debug.Assert (false, "Invalid AssemblyDependencies Object");
      if (file == null)
        Debug.Assert (false, "Invalid file name");

      XmlDocument d = new XmlDocument ();
      XmlElement root = d.CreateElement (Localization.ACF_CONFIGURATION);

      XmlElement runtime = d.CreateElement (Localization.ACF_RUNTIME);
      root.AppendChild (runtime);

      XmlElement asmBind = d.CreateElement (Localization.ACF_ASSEMBLYBINDING);
      asmBind.Attributes.Append (_attribute (d, 
          Localization.ACF_XMLNS, Localization.ACF_XMLURN));
      runtime.AppendChild (asmBind);
      

      _probing (d, asmBind);
      _binding_redir (d, asmBind);
      _assemblies(d, asmBind, ad);

      d.AppendChild (root);

      XmlTextWriter w = new XmlTextWriter (file, Encoding.UTF8);
      w.Formatting = Formatting.Indented;
      w.WriteStartDocument ();
      d.Save (w);
      w.Close ();
      }

    // Generate a template AppDomain XML Node.
    private static void _probing (XmlDocument d, XmlNode parent)
      {
      XmlElement ad = d.CreateElement (Localization.ACF_PROBING);
      ad.Attributes.Append (_attribute (d, 
          Localization.ACF_ATTR_PRIVATE_PATH, ""));
      parent.AppendChild (ad);
      }

    // Generate a template BindingMode XML Node.
    private static void _binding_mode (XmlDocument d, XmlNode parent)
      {
      XmlElement bm = d.CreateElement (Localization.ACF_BINDING_MODE);
      XmlElement abm = d.CreateElement (Localization.ACF_APP_BINDING_MODE);
      bm.AppendChild (abm);
      abm.Attributes.Append (_attribute (d, Localization.ACF_ATTR_MODE, 
          Localization.ACF_ATTR_MODE_GUESS));
      parent.AppendChild (bm);
      }

    // Generate a template BindingRedir row.
    private static void _binding_redir (XmlDocument d, XmlNode parent)
      {
      XmlNode n = d.CreateComment (Localization.ACF_BINDING_REDIR_HELP);
      parent.AppendChild (n);

      XmlElement br = d.CreateElement (Localization.ACF_BINDING_REDIR);
      br.Attributes.Append (_attribute (d, Localization.ACF_ATTR_NAME, 
          Localization.ACF_ATTR_NAME_GUESS));
      br.Attributes.Append (_attribute (d, Localization.ACF_ATTR_PUBLIC_KEY_TOKEN, 
          Localization.ACF_ATTR_PUBLIC_KEY_TOKEN_GUESS));
      br.Attributes.Append (_attribute (d, Localization.ACF_ATTR_VERSION, 
          Localization.ACF_ATTR_VERSION_GUESS));
      br.Attributes.Append (_attribute (d, Localization.ACF_ATTR_VERSION_NEW, 
          Localization.ACF_ATTR_VERSION_NEW_GUESS));
      br.Attributes.Append (_attribute (d, Localization.ACF_ATTR_USE_LATEST, 
          Localization.ACF_ATTR_USE_LATEST_GUESS));

      /*
       * We want the XML available so people can see the format, but we
       * don't actually have anything to specify, so it's wrapped in a 
       * comment.
       */
      parent.AppendChild (d.CreateComment (br.OuterXml));
      }

    // Used to sort IAssemblyInfo objects according to the name they expose.
    private class AsmInfoComparer : IComparer
      {
      public int Compare (object x, object y)
        {
        IAssemblyInfo ax = (IAssemblyInfo) x;
        IAssemblyInfo ay = (IAssemblyInfo) y;

        return String.Compare (ax.Name, ay.Name);
        }
      }

    // Generate an Assemblies XML Element consisting of AssemblyIdentity
    // elements for all the Assemblies we loaded.
    private static void _assemblies (XmlDocument d, XmlNode parent,
      AssemblyDependencies ad)
      {
      XmlElement assemblies = d.CreateElement (Localization.ACF_DEPENDENTASSEMBLY);

      ArrayList l = new ArrayList (ad.Assemblies);
      object[] asminfo = l.ToArray ();
      Array.Sort (asminfo, new AsmInfoComparer());

      /*
       * Due to obscurities of the dependency search & store process,
       * the same assembly may be loaded multiple times.
       * (This may happen if different AssemblyName's are loaded for
       * what is, eventually, the same Assembly.)
       *
       * We would prefer to minimize duplicate lines, so ``o'' keeps
       * track of what we've printed out, to keep from displaying
       * it multiple times.
       */
      ArrayList o = new ArrayList ();
      foreach (IAssemblyInfo ai in asminfo)
        {
        if (!o.Contains (ai.Name))
          {
          Trace.WriteLine ("Saving Assembly: ``" + ai.Name + "''");
          assemblies.AppendChild (_assembly_identity (d, ai));
          o.Add (ai.Name);
          }
        }

      parent.AppendChild (assemblies);
      }

    // Generate the AssemblyIdentity information for an Assembly.
    private static XmlNode _assembly_identity (XmlDocument d, IAssemblyInfo ai)
      {
      AssemblyRef a = ai.GetAssembly ();
      if (a == null)
        return _bad_assembly (d, ai);

      XmlElement cb = d.CreateElement (Localization.ACF_ASSEMBLYIDENTITY);

      cb.Attributes.Append (_attribute (d, Localization.ACF_ATTR_NAME, 
          a.GetName().Name));
      cb.Attributes.Append (_attribute (d, Localization.ACF_ATTR_PUBLIC_KEY_TOKEN, 
          _public_key_token(a)));
      cb.Attributes.Append (_attribute (d, Localization.ACF_ATTR_CULTURE, 
          a.GetName().CultureInfo.Name));
      cb.Attributes.Append (_attribute (d, Localization.ACF_ATTR_VERSION,
          a.GetName().Version.ToString()));
      cb.Attributes.Append (_attribute (d, Localization.ACF_ATTR_CODE_BASE, 
          a.CodeBase));

      return cb;
      }

    // The XML Node for an Assembly that couldn't be loaded: insert it
    // as a comment, mentioning the reason for the error.
    private static XmlNode _bad_assembly (XmlDocument d, IAssemblyInfo ai)
      {
      String s = String.Format (Localization.FMT_NOLOAD_ASSEMBLY,
        ai.Name, ai.Error.Message);
      return d.CreateComment (s);
      }

    // Create an XmlAttribute with name ``name'' and value ``value''.
    private static XmlAttribute _attribute (XmlDocument d, 
      string name, string value)
      {
      XmlAttribute n = d.CreateAttribute (name);
      n.Value = value;
      return n;
      }

    // Convert the public key token of an Assembly into a string
    // (as strings are used in the XML).
    //
    private static string _public_key_token (AssemblyRef a)
      {
      byte[] ab = a.GetName().GetPublicKeyToken ();
      StringBuilder sb = new StringBuilder ();

      if (ab != null)
        foreach (byte b in ab)
          sb.Append (b.ToString("x2"));
      return sb.ToString();
      }
    } /* class AppConfig */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\assemblyloadas.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The ways that an Assembly can be loaded.
//

namespace ADepends
  {
  // The technique to use when loading an Assembly from an AssemblyName.
  internal enum AssemblyLoadAs
    {
    // Use AssemblyName.GetAssemblyName to create AssemblyNames, and
    // use Assembly.Load to load the Assembly.  This causes the
    // assembly to be loaded into the Current AppDomain.
    Default,

    // Load AssemblyNames via AssemblyName.GetAssemblyName, and
    // create a new AppDomain to load the Assembly into.  This offers
    // the advantage that the custom paths can be used in creating the
    // new AppDomain, which may facilitate loading the Assembly.  The
    // paths that can change are the Application Base Path and the
    // Relative Search Path.
    Custom,

    // For testing /only/ (it's not exposed through the GUI);
    // Load AssemblyNames by setting the AssemblyName.CodeBase property.
    // Load Assemblies in a custom AppDomain.
    CustomGet

    } /* enum AssemblyLoadAs */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\assemblyexceptioninfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Assembly-loading Exception information.
//

namespace ADepends
  {
  using System;
  using System.Collections;
  using System.Reflection;

  // If an exception was thrown trying to load an AssemblyName, the 
  // IAssemblyInfo object returned for an Assembly Name is of this type.
  internal class AssemblyExceptionInfo : IAssemblyInfo
    {
    private string m_name;
    private Exception m_excep;

    public AssemblyExceptionInfo (String name, System.Exception e)
      {m_name = name;
      m_excep = e;}

    public AssemblyRef GetAssembly ()
      {return null;}

    public Exception Error
      {get {return m_excep;}}

    public String Name
      {get {return m_name;}}

    public ICollection ReferencedAssemblies
      {get {return new AssemblyName[0];}}

    public ICollection ReferencedModules
      {get {return new ModuleInfo[0];}}

    } /* class AssemblyExceptionInfo */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Information about Assembly Manifests.
//

namespace ADepends
  {
  using System;
  using System.Collections;
  using System.Reflection;
  using System.Diagnostics;


  // Contains (read-only) information about an Assembly, such as a list of the
  // Full Assembly Names of Assemblies it's dependant on, Modules that it
  // contains, it's name, and anything else useful.
  internal class AssemblyInfo : IAssemblyInfo
    {
    // list<AssemblyName>
    private ArrayList  m_dependencies = new ArrayList ();

    // list<ModuleInfo>
    private ArrayList  m_modules = new ArrayList ();

    private string      m_name;

    private AssemblyRef m_assembly;

    // Determines the Assembly information.
    //
    public AssemblyInfo (AssemblyRef assembly, IList next)
      {
      m_name = assembly.FullName;
      m_assembly = assembly;

      _dependencies (assembly, next);
      _modules (assembly);
      }

    // Records all the modules that the Assembly contains.
    private void _modules (AssemblyRef a)
      {
      foreach (ModuleInfo m in a.GetModules())
        {
        m_modules.Add (m);
        }
      }

    // Records all the Assemblies that the Assembly references (uses).
    private void _dependencies (AssemblyRef a, IList next)
      {
      AssemblyName[] aan = a.GetReferencedAssemblies ();

      Trace.WriteLine ("Assembly dependencies: ");
      foreach (AssemblyName an in aan)
        {
        Trace.WriteLine ("  " + an.FullName);
        m_dependencies.Add (an);
        next.Add (an);
        }
      }

    /** Get the assembly this object is providing information for. */
    public AssemblyRef GetAssembly ()
      {return m_assembly;}

    // The full name of this Assembly.
    //
    public String Name
      {
      get
        {return m_name;}
      }

    // The error that occurred.
    //
    // If this object is actually created, then no error occurred.
    public Exception Error
      {
      get
        {return null;}
      }

    // The assemblies that this Assembly is dependant on.
    public ICollection ReferencedAssemblies
      {
      get
        {return m_dependencies;}
      }

    // The Modules contained in this Assembly.
    public ICollection ReferencedModules
      {
      get
        {return m_modules;}
      }
    }

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\assemblyref.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cross-AppDomain Assembly References.
//

namespace ADepends
  {
  using System;
  using System.Reflection;
  using System.Diagnostics;

  // A "reference" to an Assembly loaded into another AppDomain.
  //
  // This class must be a MarshalByRefObject, as attempting to pass an
  // Assembly between AppDomains causes "File not found" exceptions.
  //
  // This should attempt to mimic the interface exposed by the
  // System.Reflection.Assembly class as much as is feasable.
  internal class AssemblyRef : MarshalByRefObject
    {
    /** The Assembly we're interested in. */
    private Assembly m_a;

    /** Load the Assembly referred to by ``an'' into the current AppDomain. */
    public void Load (AssemblyName an)
      {
      Trace.WriteLine ("AR: Loading Assembly: " + an.FullName);
      m_a = Assembly.Load (an);
      }

    // Return an array of ModuleInfo objects, which provide information
    // for each Module loaded into the wrapped Assembly.
    public ModuleInfo[] GetModules ()
      {Module[] m = m_a.GetModules ();
      ModuleInfo[] r = new ModuleInfo[m.Length];
      for (int i = 0; i < m.Length; i++)
        r[i] = new ModuleInfo(m[i]);
      return r;}

    /** Get the AssemblyName of the wrapped Assembly. */
    public AssemblyName GetName ()
      {return m_a.GetName();}

    /** Get the AssemblyName's that the wrapped Assembly is dependant on. */
    public AssemblyName[] GetReferencedAssemblies ()
      {return m_a.GetReferencedAssemblies ();}

    /** Where the Assembly is located. */
    public string CodeBase
      {get {return m_a.CodeBase;}}

    /** The Full Name of the Assembly. */
    public string FullName
      {get {return m_a.FullName;}}

    } /* class AssemblyRef */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\assemblydependencies.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Contains the Assembly dependency information.
//

namespace ADepends
  {
  using System;
  using System.Collections;
  using System.Reflection;
  using System.Diagnostics;


  /** Maps a Full Assembly Name to an AssemblyInfo object */
  using AssemblyMap = System.Collections.Hashtable;


  // Creates a list of AssemblyInfo objects, each accessible by the name of the
  // Assembly.
  //
  // The name of the Assembly manifest is available through the ManifestName
  // property.
  //
  // The array-index operator can be used on a manifest name to get the
  // AssemblyInfo object for the requested Assembly.
  internal class AssemblyDependencies
    {
    // map<string, AssemblyName>
    private AssemblyMap m_map = new AssemblyMap ();

    /** The name of the "root" Assembly of our dependency list */
    private string m_name;

    LoadAssembly m_load;

    // Builds the list of Dependencies for the Assembly Manifest located in the
    // file ``name''.
    //
    // If ``name'' couldn't be loaded, an exception is thrown as the manifest
    // file doesn't exist or is invalid.  If one of ``names'' dependency's
    // can't be loaded, an exception is not thrown; instead, the
    // IAssemblyInfo object returned will hold exception information.
    //
    public AssemblyDependencies (string name, LoadAssemblyInfo cai)
      {
      AssemblyRef ar= null;
      m_load = LoadAssembly.CreateLoader (cai);
      try
        {
        Trace.WriteLine ("Name: " + name);

        AssemblyName an = m_load.GetAssemblyName (name);

        Trace.WriteLine ("assembly name: " + an.Name);
        Trace.WriteLine ("assembly full name: " + an.FullName);

        ar = m_load.LoadAssemblyName (an);

        Trace.WriteLine ("Successfully loaded assembly.");
        }
      catch (Exception e)
        {
        Trace.WriteLine ("m_load.LoadAssemblyName threw an exception:\n  " + 
          e.ToString());
        Trace.WriteLine ("\tStackTrace: " + e.StackTrace);
        /* 
         * If ``m_load.LoadAssemblyName'' throws an exception, we want
         * our caller to get the exception.  However, since this is 
         * the constructor, we need to clean up any allocated resources --
         * in this case, the resouces of the LoadAssembly object.
         */
        m_load.Dispose ();
        throw e;
        }

      m_name = ar.FullName;

      IList search = new ArrayList ();

      // Add the top-level object, the Assembly containing the manifest.
      // ``search'' will contain any Assemblies that the added object
      // references.
      m_map.Add (m_name, new AssemblyInfo (ar, search));

      // Get all referenced Assemblies.
      _traverse (search);
      }

    // Overloading that specifies shared loading of Assemblies for the
    // file ``name''.
    public AssemblyDependencies (String name)
      : this (name, new LoadAssemblyInfo ())
      {
      }

    // For each of the elements in l, if the Assembly name that it
    // references hasn't been followed, then we create an AssemblyInfo
    // object for it, and add it to m_map.
    private void _traverse (IList l)
      {
      while (l.Count != 0)
        {
        Object o = l[0];
        l.Remove (o);
        AssemblyName an = (AssemblyName) o;

        IAssemblyInfo ai;
        try
          {
          AssemblyRef assembly = m_load.LoadAssemblyName (an);
          ai = new AssemblyInfo (assembly, l);
          }
        catch (System.Exception e)
          {
          Trace.WriteLine ("Exception while loading dependency:\n  " +
            e.ToString());
          ai = new AssemblyExceptionInfo (an.FullName, e);
          }

        m_map.Add (an.FullName, ai);

        l = _minimize (l);
        }
      }

    // Returns a new list of Assembly names consisting of names that
    // haven't already been visited (i.e., they aren't present in the
    // database).
    private IList _minimize (IList l)
      {
      IList r = new ArrayList ();
      foreach (AssemblyName an in l)
        {
        if (!m_map.Contains (an.FullName))
          r.Add (an);
        }
      return r;
      }

    // The name of the Assembly containing the Manifest File.
    public String ManifestName
      {
      get
        {return m_name;}
      }
    
    // Accessor to access the AssemblyInfo object associated with 
    // an AssemblyName.
    public IAssemblyInfo this[String name]
      {
      get
        {return (IAssemblyInfo) m_map[name];}
      }

    // Clean up all resources allocated to determine the dependencies.
    public void Dispose ()
      {
      m_load.Dispose ();
      }

    // A collection of IAssemblyInfo objects for all the Assemblies
    // Loaded.
    internal ICollection Assemblies
      {
      get
        {
        Trace.WriteLine ("current map contents:");
        foreach (DictionaryEntry de in m_map)
          Trace.WriteLine ("  " + de.Key + ", " + de.Value);
        return m_map.Values;}
      }

    } /* class AssemblyDependencies */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)
	echo This is needed to avoid a syntax error when processing this file. :-(


!if "$(TARGETCOMPLUS)" != ""
# Copy the files to the target COM+ directory
	copy $(COOL_TARGET) $(TARGETCOMPLUS)
!endif

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\iassemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Information about Assembly Manifests.
//

namespace ADepends
  {
  using System;
  using System.Collections;

  // Makes information about an Assembly available.
  //
  // Exists because we needed to expose "invalid" assemblies. For example,
  // a valid (could be loaded) assembly could reference an invalid (can't 
  // be loaded) assembly.  Instead of aborting the entire operation, it
  // would be preferrable to accept the "invalid" assembly, and continue.
  //
  // Doing this requires at least two implementations--one for valid a
  // assemblies and one for invalid assemblies.  Inheritence could have
  // been used, but it didn't make sense to have the 
  // AssemblyExceptionInfo class inherit from the AssemblyInfo class.
  // The use of an interface made more sense, so this is what's being used.
  internal interface IAssemblyInfo
    {
    AssemblyRef GetAssembly ();

    /** @return The full name of the assembly. */
    String Name
      {get;}

    Exception Error
      {get;}

    // Makes available the full names (as String objects) of all assemblies
    // that the Assembly returned by GetAssembly() is dependant on.
    ICollection ReferencedAssemblies
      {get;}

    // Makes available the Modules (as Module objects) of all modules
    // that the Assembly returned by GetAssembly() contains.
    ICollection ReferencedModules
      {get;}

    } /* interface IAssemblyInfo */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\loadassembly.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Assembly loading.
//

namespace ADepends
  {
  using System;
  using System.Collections;
  using System.Reflection;
  using System.Diagnostics;
  using System.Runtime.Remoting;  // ObjectHandle
  using System.Globalization;

  // Defines:
  //  - The common interface for objects that create Assembly and 
  //    AssemblyName objects.
  //  - A way to create these objects based on the LoadAssemblyInfo object.
  internal abstract class LoadAssembly : IDisposable
    {
    /** Creates an object derived from LoadAssembly. */
    private delegate LoadAssembly _creator (LoadAssemblyInfo cai);

    // map<AssemblyLoadAs, _creator>
    private static IDictionary m_tbl;

    // Static class constructor which creates the map for use
    // in CreateLoader().
    static LoadAssembly ()
      {
      m_tbl = new Hashtable ();
      m_tbl.Add (AssemblyLoadAs.Default, new _creator(_create_default));
      m_tbl.Add (AssemblyLoadAs.Custom, new _creator(_create_custom));
      m_tbl.Add (AssemblyLoadAs.CustomGet, new _creator(_create_custom_get));
      }

    private static LoadAssembly _create_default (LoadAssemblyInfo cai)
      {return new LoadDefaultAssembly ();}

    private static LoadAssembly _create_custom (LoadAssemblyInfo cai)
      {return new LoadCustomAssembly (cai);}

    private static LoadAssembly _create_custom_get (LoadAssemblyInfo cai)
      {return new LoadCustomGetAssembly (cai);}

    // Create the Assembly referred to by ``an''.
    public abstract AssemblyRef LoadAssemblyName (AssemblyName an);

    // Create an AssemblyName for the file-name ``name''.
    public abstract AssemblyName GetAssemblyName (string name);

    // Close/cleanup any resources created for all calls to LoadAssembly
    // & LoadAssemblyName.
    public abstract void Dispose ();

    // Create a LoadAssembly object based on ``i''.
    //
    // If ``i.LoadAs()'' doesn't return a value from the AssemblyLoadAs
    // enumeration, then an exception is thrown.
    public static LoadAssembly CreateLoader (LoadAssemblyInfo i)
      {
      Trace.WriteLine ("Creating Assembly Loader for:");
      Trace.WriteLine ("  LoadAs: " + i.LoadAs().ToString());
      Trace.WriteLine ("  AppBasePath: " + i.AppPath());
      Trace.WriteLine ("  RelativeSearchPath: " + i.RelPath());

      _creator c = (_creator) m_tbl[i.LoadAs()];

      if (c==null)
        throw 
          new Exception ("Internal error: Invalid AssemblyLoadAs specified");

      return c (i);
      }

    // Create a new AppDomain to load the assembly ``an''.
    protected static AppDomain CreateAppDomain (AssemblyName an, 
      LoadAssemblyInfo info)
      {
      Trace.WriteLine ("Loading a custom assembly for: " + an.FullName);
      String fname = String.Format (Localization.FMT_APPDOMAIN_NAME, 
        an.FullName);
      Trace.WriteLine ("  -- Friendly Name of new AppDomain: " + fname);

      Debug.Assert (an.CodeBase != null, 
        "The AssemblyName CodeBase must be set!");

      /*
       * The Application Base Path used to create the domain should be the
       * directory that the Assembly is located in.  If AppPath() is null,
       * then we should consult use the AssemblyName's CodeBase as the App
       * Base Path.
       */
      String appbase = info.AppPath();
      if (appbase == null)
        appbase = _furi_to_dir (an.CodeBase);

      AppDomain ad = AppDomain.CreateDomain (
        fname,                // friendlyName
        null,                 // securityInfo
        appbase,              // appBasePath
        info.RelPath(),       // relativeSearchPath
        false                 // shadowCopyFiles
        );
      Trace.WriteLine ("  -- created AppDomain");

      return ad;
      }
      
    // Convert a (possibly) ``file://'' URI into a full directory name.
    // The URI-parts and the filename are dropped.
    //
    // For example, ``file:///d:/tmp/an.exe'' would become ``d:/tmp''.
    //
    private static string _furi_to_dir(string uri)
      {
      string path = null;

      int i = uri.LastIndexOf('/');
      if (i == -1)
        path = uri;
      else
        {
        path = uri.Substring(0, i);
        if (String.Compare("file://", 0, path, 0, 7, false, CultureInfo.InvariantCulture) == 0)
          {
          if (path[7] == '/')
            path = path.Substring(8);
          else
            path = path.Substring(7);                  
          }
        }
      return path;
      }
    }


  // Loads Assemblies into the current AppDomain.
  //
  // Corresponds to AssemblyLoadAs.Default.
  internal class LoadDefaultAssembly : LoadAssembly
    {
    /** Load the Assembly into the current AppDomain. */
    public override AssemblyRef LoadAssemblyName (AssemblyName an)
      {
      Trace.WriteLine ("Loading a default assembly: " + an.FullName);
      AssemblyRef a = new AssemblyRef ();
      a.Load (an);
      return a;
      }

    /** Read the AssemblyName information from the file ``name''. */
    public override AssemblyName GetAssemblyName (string name)
      {
      Trace.WriteLine ("Creating Shared AssemblyName");
      return AssemblyName.GetAssemblyName (name);
      }

    /** Don't do anything, as we never allocated any resources. */
    public override void Dispose ()
      {}
    }


  // Loads Assemblies into their own AppDomain, using the paths
  // specified in the LoadAssemblyInfo object passed in the constructor.
  //
  // Corresponds to AssemblyLoadAs.Custom.
  internal class LoadCustomAssembly : LoadAssembly
    {
    private LoadAssemblyInfo m_info;

    private AppDomain m_ad;

    internal LoadCustomAssembly (LoadAssemblyInfo i)
      {m_info = i;}

    // Load the Assembly ``an'' into the AppDomain ``m_ad''.
    // Return information regarding the assembly.
    public override AssemblyRef LoadAssemblyName (AssemblyName an)
      {
      Type t = typeof (AssemblyRef);
      string aname = Process.GetCurrentProcess().MainModule.FileName;
      Trace.WriteLine ("Assembly containing AssemblyRef: " + aname);
      Trace.WriteLine ("Type full name: " + t.FullName);
      Trace.WriteLine ("Type name: " + t.Name);

      AssemblyRef ar = 
        (AssemblyRef) m_ad.CreateInstanceFromAndUnwrap (aname, t.FullName);
      
      ar.Load (an);
      return ar;
      }

    // Create an AssemblyName obect. 
    //
    // We also create the AppDomain that LoadAssemblyName will later use.
    public override AssemblyName GetAssemblyName (string name)
      {
      Trace.WriteLine ("Creating Shared AssemblyName");
      AssemblyName an = AssemblyName.GetAssemblyName (name);
      m_ad = CreateAppDomain (an, m_info);
      return an;
      }

    /** Clean up any created resources */
    public override void Dispose ()
      {
      }
    }


  // Loads Assemblies into their own AppDomain, but uses
  // AssemblyName.GetAssemblyName to read a file to get the AssemblyName.
  //
  // Corresponds to AssemblyLoadAs.CustomGet.
  internal class LoadCustomGetAssembly : LoadCustomAssembly
    {
    internal LoadCustomGetAssembly (LoadAssemblyInfo i)
      : base (i)
      {}

    /** Create an AssemblyName obect. */
    public override AssemblyName GetAssemblyName (string name)
      {
      Trace.WriteLine ("Creating Custom AssemblyName");
      AssemblyName an = new AssemblyName ();
      an.CodeBase = name;
      return an;
      }
    } /* class LoadCustomGetAssembly */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\loadassemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Information about how Assemblies should be loaded.
//

namespace ADepends
  {
  using System;

  // The information to use when creating an Assembly or AssemblyName object.
  //
  // This provides the union of all data needed for each style of loading
  // an Assembly.  See AssemblyLoadAs.
  //
  // Multiple properties can be specified at the same time, if desired.
  // This is why Properties aren't used, and why each ``Set'' method returns
  // a LoadAssemblyInfo object.  This allows such things as:
  //
  //    LoadAssemblyInfo i = new LoadAssemblyInfo().SetAppPath ("D:\tmp");
  //
  // This is also useful in constructor base lists, which require that 
  // their parameters be done as one statement.
  internal class LoadAssemblyInfo
    {
    /** How to create Assembly & AssemblyName objects. */
    private AssemblyLoadAs m_load = AssemblyLoadAs.Custom;

    /** Paths to use when creating a new AppDomain. */
    private string  m_abp = null;
    private string  m_rsp = null;

    public LoadAssemblyInfo ()
      {}

    /** Specify how Assemblies should be loaded. */
    public LoadAssemblyInfo LoadAs (AssemblyLoadAs a)
      {m_load = a;
      return this;}

    /** How should Assemblies be loaded? */
    public AssemblyLoadAs LoadAs ()
      {return m_load;}

    /** Specify the Application Base Path when creating an AppDomain. */
    public LoadAssemblyInfo AppPath (string s)
      {m_abp = s;
      return this;}

    /** The Application Base Path for creating an AppDomain. */
    public string AppPath ()
      {return m_abp;}

    /** Specify the Relative Search Path when creating an AppDomain. */
    public LoadAssemblyInfo RelPath (string s)
      {m_rsp = s;
      return this;}

    /** The Relative Search Path for creating an AppDomain. */
    public string RelPath ()
      {return m_rsp;}

    } /* class LoadAssemblyInfo */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\localization.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Centralized String repository, for localization.
//

namespace ADepends
  {
  using Shortcut = System.Windows.Forms.Shortcut;

  // Contains the strings that might need to be localized in the program.
  internal class Localization
    {

    //
    // Common Strings
    //

    internal static readonly string VERSION = "0.86";
    internal static readonly string LAST_UPDATE = "May 21, 2001";

    // The program output when an invalid assembly file is specified.
    internal static readonly string INVALID_ASSEMBLY_MANIFEST = 
      "Invalid assembly manifest";

    // Text prefixed before an Assembly name in the output.
    internal static readonly string ASSEMBLY = "Assembly: ";

    // Text prefixed before a Manifest name in the output.
    internal static readonly string MANIFEST = "Manifest: ";

    // Text of a "node" under which additional assemblies are listed.
    internal static readonly string REFERENCED_ASSEMBLIES = 
      "Referenced Assemblies:";

    // Text of a "node" under which additional modules are listed.
    internal static readonly string CONTAINED_MODULES = "Contained Modules:";

    // The "template" name for an AppDomain.
    internal static readonly string FMT_APPDOMAIN_NAME = "To Load: {0}";

    //
    // XML Strings
    //
    internal static readonly string ACF_CONFIGURATION = "Configuration";
    internal static readonly string ACF_RUNTIME = "Runtime";
    internal static readonly string ACF_ASSEMBLYBINDING = "AssemblyBinding";
    internal static readonly string ACF_XMLNS = "XMLNS";
    internal static readonly string ACF_XMLURN = "URN:schemas-microsoft-com:asm.v1";
    internal static readonly string ACF_PROBING = "Probing";
    internal static readonly string ACF_PUBLISHERPOLICY = "PublisherPolicy";
    internal static readonly string ACF_APPLY = "Apply";
    internal static readonly string ACF_ATTR_PRIVATE_PATH = "PrivatePath";
    internal static readonly string ACF_BINDING_MODE = "BindingMode";
    internal static readonly string ACF_APP_BINDING_MODE = "AppBindingMode";
    internal static readonly string ACF_ATTR_MODE = "Mode";
    internal static readonly string ACF_ATTR_MODE_GUESS = "normal";
    internal static readonly string ACF_BINDING_REDIR = "BindingRedirect";
    internal static readonly string ACF_BINDING_REDIR_HELP = 
      "A sample BindingRedirect row";
    internal static readonly string ACF_ATTR_NAME = "Name";
    internal static readonly string ACF_ATTR_NAME_GUESS = "[name]";
    internal static readonly string ACF_ATTR_PUBLIC_KEY_TOKEN = "PublicKeyToken";
    internal static readonly string ACF_ATTR_PUBLIC_KEY_TOKEN_GUESS = "[pubkey]";
    internal static readonly string ACF_ATTR_CULTURE = "Culture";
    internal static readonly string ACF_ATTR_VERSION = "Version";
    internal static readonly string ACF_ATTR_VERSION_GUESS = "[ver|*]";
    internal static readonly string ACF_ATTR_VERSION_NEW = "NewVersion";
    internal static readonly string ACF_ATTR_VERSION_NEW_GUESS = "[ver]";
    internal static readonly string ACF_ATTR_USE_LATEST = 
      "UseLatestBuildRevision";
    internal static readonly string ACF_ATTR_USE_LATEST_GUESS = "[yes|no]";
    internal static readonly string ACF_DEPENDENTASSEMBLY = "DependentAssembly";
    internal static readonly string ACF_ASSEMBLYIDENTITY = "AssemblyIdentity";
    internal static readonly string ACF_ATTR_CODE_BASE = "CodeBase";
    internal static readonly string ACF_HREF = "HREF";
    internal static readonly string FMT_NOLOAD_ASSEMBLY = 
      "Could not load assembly \"{0}\": {1}";

    //
    // Console Strings
    //

    /** The program name (to be used in error messages) */
    internal static readonly string PROGRAM_NAME = "adepends";

    // The error message displayed if an option taking an argument is
    // missing the argument (e.g. -A, -R, -S).
    internal static readonly string FMT_MISSING_PARAMETER = 
      PROGRAM_NAME + ": missing parameter for option: {0}";

    // The error message displayed if a parameter is invalid.
    // (Currently used for parameters for ``--load'', of which
    // only ``custom'' is supported.)
    internal static readonly string FMT_BAD_PARAMETER = 
      PROGRAM_NAME + ": invalid parameter for option ``{0}'': {1}";

    // For the "tree-like" console output, the number of spaces each line 
    // should be indented.
    internal static readonly string INDENT = "  ";

    // The program help text, normally accessible via ``/?''
    //
    // The ``--load'' option is not displayed as the ``custom'' loading
    // works for all cases that ``default'' works for.  However, for
    // command-line testing, it can still be specified.
    //
    // See previous versions of this file for more information about
    // this option.
    internal static readonly string HELP_MESSAGE = 
"Microsoft (R) CLR Assembly Manifest Dependencies Checker Version " + 
  VERSION + "\n" +
"Copyright (C) Microsoft Corp. 2000-2002.  All rights reserved.\n\n" +
"Usage:\n" +
"\t" + PROGRAM_NAME + " [ option | file ]... \n\n" +
"Options:\n" +
"\t--console, -C  Send output to standard output\n" +
"\t--gui, -G      Create a Windows program for output (default)\n" +
"\t--appbase, -A  Interpret the next argument as the Application Base Path\n" + 
"\t                to use when loading Assemblies.\n" +
"\t--relative,-R  Interpret the next argument as the Relative Search Path\n"+
"\t                to use when loading Assemblies.\n" +
"\t--config, -O   Interpret the next argument as the filename of the\n" +
"\t                Application Configuration File to generate.\n" +
"\t--help         Display this message and exit\n" +
"\t--             Disable interpretation of options.  This allows\n" +
"\t                opening an Assembly Manifest with the same name as\n"+
"\t                a program option.\n" +
"\tfile           A file that contains an Assembly Manifest.\n";

    /** String to display when an invalid argument (etc.) is given. */
    internal static readonly string SHORT_HELP_MESSAGE = 
      "Try `adepends --help' for more information.";

    // The program arguments that can be used to access the help message.
    internal static readonly string[] HELP_ARGUMENTS = 
      {"/?", "-?", "/h", "-h", "/help", "-help", "--help"};

    /** The program arguments that can be used to specify console output. */
    internal static readonly string[] CONSOLE_OUTPUT = 
      {"-C", "-c", "/C", "/c", "--console"};

    /** The program arguments that specify GUI output. */
    internal static readonly string[] GUI_OUTPUT = 
      {"-G", "-g", "/G", "/g", "--gui"};

    // The program arguments that specify hostile takeover of the
    // spawning shell (for GUI use, anyway).
    internal static readonly string[] USE_CURRENT_PROCESS = 
      {"-U", "--use-current-process"};

    // The program arguments that specify the Application Base Path to
    // use when creating AppDomains.
    internal static readonly string[] APP_BASE_PATH = 
      {"-A", "-a", "/A", "/a", "--appbase"};

    // The program arguments that specify the Relative Search Path to
    // use when creating AppDomains.
    internal static readonly string[] RELATIVE_SEARCH_PATH = 
      {"-R", "-r", "/R", "/r", "--relative"};

    // Program arguments that specify how Assemblies should be loaded.
    internal static readonly string[] LOAD_ASSEMBLY = 
      {"-L", "-l", "/L", "/l", "--load"};

    // Program arguments that specify the name of an Application 
    // COnfiguration File to generate.
    internal static readonly string[] CREATE_CONFIG_FILE =
      {"-O", "-o", "/O", "/o", "--config"};

    // Header printed before Dependant Assemblies in the output.
    internal static readonly string DEPENDANT_ASSEMBLIES = 
      INDENT + "Dependant Assemblies:";

    // Header printed before Dependant Files in the output.
    internal static readonly string DEPENDANT_FILES = 
      INDENT + "Dependant Files:";

    /** What to say when CreateProcess fails. */
    internal static readonly string CP_FAIL = "Unable to spawn GUI.";

    // Error message displayed if the reason for the error is unknown.
    internal static readonly string UNKNOWN_ERROR = "Unknown error.";


    //
    // GUI Strings
    //

    // The name of the program that can be passed to
    // System.Diagnostics.Process.Start().
    internal static readonly string PROGRAM_EXE = "adepends.exe";

    // The name of the GUI program that can be passed to
    // System.Diagnostics.Process.Start().
    internal static readonly string PROGRAM_WINEXE = "adependsw.exe";

    /** The text to display in the title bars of the GUI app. */
    internal static readonly string GUI_WINDOW_TITLE = 
      "Assembly Manifest Dependencies";

    internal static readonly string OPEN_WINDOW_TITLE = "Open";

    internal static readonly string OPEN_MANIFEST_HELP =
      "Type in the name of an Assembly Manifest to load.";

    internal static readonly string ASSEMBLY_PATHS_WINDOW_TITLE = 
      "Assembly Paths";

    internal static readonly string BUTTON_OK = "OK";
    internal static readonly string BUTTON_CANCEL = "Cancel";

    // The text shown in the "Files of type" drop-down in the File->Save
    // Application Configuration dialog.
    //
    // See Meteor Catalog Explorer/System.Winforms.SaveFileDialog.Filter
    // for additional information.
    internal static readonly string SAVE_AS_FILTER = 
      "Application Configuration Files (*.cfg)|*.cfg|"+
      "All Files (*.*)|*.*";

    // The text shown in the "Files of type" drop-down in the File->Open
    // dialog.
    //
    // See Meteor Catalog Explorer/System.Winforms.SaveFileDialog.Filter
    // for additional information.
    internal static readonly string OPEN_FILTER = 
      "CLR Manifest Files (*.exe;*.dll;*.mcl)|*.exe;*.dll;*.mcl|" +
      "All Files (*.*)|*.*";

    // The introductory text to display in the Info pane of
    // the GUI app when no Assembly has been loaded.
    internal static readonly string GUI_INTRO_TEXT = 
      "Drag a file on top of this application.  If it contains an " +
      "Assembly manifest, it will be displayed in the left-hand pane.";

    /** The initial text the Status bar displays. */
    internal static readonly string GUI_NO_ASSEMBLY_SELECTED = 
      "No Assembly Selected";

    /** End-of-line string for use in multi-line GUI panels */
    internal static readonly string LINE_ENDING = "\r\n";

      //
      // Error Messages
      //
    internal static readonly string INVALID_DATA_FORMAT = 
      "Invalid Data Format";

    internal static readonly string UNOPENED_FILES = 
      "The following file(s) couldn't be opened";

    internal static readonly string UNSUPPORTED_DATA_FORMAT = 
      "Unsupported Data Format";

    internal static readonly string FMT_INVALID_MANIFEST = 
      "{0}: {1}" + LINE_ENDING;

    internal static readonly string FMT_INVALID_FILE_LIST = 
      "{0}:" + LINE_ENDING + "{1}";

      //
      // Menu Information
      //
    internal static readonly string MENU_FILE = "&File";
    internal static readonly string MENU_FILE_OPEN = "&Open...";
    internal static readonly string MENU_FILE_OPEN_MANIFEST = 
      "Open &Manifest...";
    internal static readonly string MENU_FILE_SAVE_CONFIG = 
      "Save &Application Configuration...";
    internal static readonly Shortcut MENU_FILE_OPEN_SHORTCUT = Shortcut.CtrlO;
    internal static readonly string MENU_FILE_CLOSE = "&Close";
    internal static readonly Shortcut MENU_FILE_CLOSE_SHORTCUT = Shortcut.CtrlW;

    internal static readonly string MENU_VIEW = "&View";
    internal static readonly string MENU_VIEW_TREE = "&Tree";
    internal static readonly string MENU_VIEW_INFO = "&Information";
    internal static readonly string MENU_VIEW_SB = "&Status Bar";
    internal static readonly string MENU_VIEW_REFRESH = "&Refresh";
    internal static readonly Shortcut MENU_VIEW_REFRESH_SHORTCUT = Shortcut.F5;

    internal static readonly string MENU_TOOLS = "&Tools";
    internal static readonly string MENU_TOOLS_CUSTOM = 
      "&Custom AppDomain Loading";
    internal static readonly string MENU_TOOLS_PATHS = 
      "&Assembly Loading Paths...";

    internal static readonly string MENU_HELP = "&Help";
    internal static readonly string MENU_HELP_ABOUT 
      = "&About Assembly Dependencies";

    // Context Menu: Copy the contents of the selected object to the
    // clipboard.
    internal static readonly string CTXM_COPY = "&Copy";

    // Context Menu: Select the node underneath the mouse.
    internal static readonly string CTXM_SELECT = "&Select";

      //
      // Help->About Information
      //
    internal static readonly string ABOUT_BOX_TITLE = 
      "About Assembly Dependencies";
    internal static readonly string ABOUT_BOX_TEXT =
      "Microsoft (R) Assembly Manifest Viewer" + LINE_ENDING +
      "Version " + VERSION + LINE_ENDING +
      "Copyright (C) 2000-2002 Microsoft Corp." + LINE_ENDING +
      VERSION + " - " + LAST_UPDATE;

      //
      // Tools->Assembly Paths information
      //
    internal static readonly string REF_ASSEMBLIES_DESC = 
      "The Assemblies the current Assembly is dependant upon:";
    internal static readonly string REF_MODULES_DESC = 
      "The Modules contained within the current Assembly:";
    internal static readonly string APP_BASE_PATH_DESC = 
      "&Application Base Path:";
    internal static readonly string RELATIVE_SEARCH_PATH_DESC = 
      "&Relative Search Path:";

      //
      // Information Panels
      //

        //
        // Strings used for descriptions of AssemblyName fields.
        //
    internal static readonly string INFO_FULL_NAME = "F&ull Name:";
    internal static readonly string INFO_NAME = "&Name:";
    internal static readonly string INFO_PUBLIC_KEY_TOKEN = 
      "Public K&ey Token:";
    internal static readonly string INFO_PUBLIC_KEY = "Publi&c Key:";
    internal static readonly string INFO_VERSION = "Ve&rsion:";
    internal static readonly string INFO_VERSION_COMPATIBILITY = 
      "Ver&sion Compatibility:";
    internal static readonly string INFO_CODE_BASE = "Code &Base:";
    internal static readonly string INFO_PROCESSOR = "&Processor:";
    internal static readonly string INFO_CULTURE_INFORMATION = 
      "Culture &Information:";
    internal static readonly string INFO_FLAGS = "Fla&gs:";
    internal static readonly string INFO_HASH_ALGORITHM = "Hash A&lgorithm:";
    internal static readonly string INFO_KEY_PAIR = "&Key Pair Public Key:";

    /** The Name column displayed by the ListView. */
    internal static readonly string LV_COLUMN_NAME = "Name";
    internal static readonly string LV_COLUMN_ASSEMBLY_NAME = "Assembly Name";
    internal static readonly string LV_COLUMN_MODULE_NAME = "Module Name";
    internal static readonly string LV_COLUMN_PLATFORM = "Platform";
    internal static readonly string LV_COLUMN_VERSION = "Version";
    internal static readonly string LV_COLUMN_CSD = 
      "Corrected Service Diskette";

    /** Name of Error information panel group box. */
    internal static readonly string INVALID_ASSEMBLY = "Invalid Assembly";

    /** For AssemblyName tab of information panel. */
    internal static readonly string ASSEMBLY_NAME_INFORMATION = 
      "AssemblyName";

    internal static readonly string REF_ASSEMBLIES = "Assemblies";
    internal static readonly string REF_MODULES = "Modules";

    /** For referneced assemblies & modules tab of information panel. */
    internal static readonly string REF_ASM_AND_MODULES = 
      "Referenced Assemblies and Modules";
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\moduleinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cross-AppDomain information about Modules.
//

namespace ADepends
  {
  using System;
  using System.Reflection;

  // Information about a Module loaded into an Assembly.
  //
  // The underlying Module may be loaded into a different AppDomain
  // than where the "interested party" is located.
  //
  // Additionally, it isn't possible to pass a System.Reflection.Module
  // between AppDomains (as the new AppDomain might be on a different 
  // machine which doesn't have the Module available).  Even in the
  // same process, trying to load Modules across AppDomains often generates
  // exceptions saying "File [file name] not found."
  //
  // Thus, there are two possible ways to get the information pertaining
  // to a module from one AppDomain to another:
  //
  //  1) Wrap the Module in an object that derives from 
  //    MarshalByRefObject.  This would prevent a copy of the Module
  //    from being introduced into new AppDomains, preventing the 
  //    "File [file name] not found" message.
  //
  //  2) Don't wrap the Module.  Instead, create a new class which would
  //    save the "interesting" Module properties (such as Name, etc.) as 
  //    strings, and pass this new class between AppDomains.  The new
  //    class /would not/ derive from MarshalByRefObject.
  //
  // Ideally, (1) would be used.  This could minimize the size of the
  // object that needs to be passed between AppDomains, and would
  // allow simply forwarding the method calls to the wrapped Module object.
  //
  // (1) can't be used, however, without seriously contorting other design
  // aspects.  The reason is BugID 41400: a SerializationException is
  // generated if we attempt to pass an array of objects derived from
  // MarshalByRefObject.
  //
  // Since an Assembly may contain multiple Modules, we want to either
  // support returning an array of the Modules (or ModuleRef wrapper
  // classes, as the case may be), or an IEnumerable interface.
  // The alternative would be to do something "hacky", like:
  //
  //    int GetNUmberOfModules ();
  //    ModuleRef GetModule (int idx);
  //
  //    // ...
  //    for (int i = 0; i < foo.GetNumberOfModules(); i++)
  //      Console.WriteLine (foo.GetModule(i).Name);
  //
  // This just seems inelegant.
  //
  // This would leave the use of an IEnumerable object, which would allow
  // enumeration over all the ModuleRef's, just like an Array would allow.
  // This isn't possible either, due to BugID 41357: when an object 
  // exposing the IEnumerable interface is transferred between AppDomains,
  // we go through COM Interop via a Transparent Proxy.  However, the
  // interop code doesn't check for a Transparent Proxy, and instead asserts
  // that we're a COM object...which we're not.  The ASSERT fires, and 
  // we die a horrible death.
  //
  // All of this leaves (2).
  //
  // The only good news about (2) is that all of the "interesting" 
  // information about the Module would be stored as Strings and passed
  // "by value" between AppDomains.  This might result in a performance
  // improvement (due to fewer AppDomain crossings) at the cost of a
  // possible memory increase (due to needing strings for each "interesting"
  // property).
  //
  // Additionally, (2) will actually work in the presence of Bugs 41357 &
  // 41400.
  [Serializable()]
  internal class ModuleInfo
    {
    private string m_name;

    public ModuleInfo (Module m)
      {m_name = m.Name;}

    /** The name of the underlying Module. */
    public string Name
      {get {return m_name;}}

    } /* class ModuleInfo */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "ADEPENDS.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft CLR Assembly Dependancies Utility\0"
#define VER_ORIGFILENAME_STR    "ADEPENDS.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\about.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The Help->About dialog box.
//

namespace ADepends
  {
  using System;
  using System.Drawing;
  using System.Windows.Forms;
  using ADepends;

  // Display an "About" dialog box.
  internal class HelpAboutForm : Form
    {
    Button m_ok = new Button ();

    // Layout the dialog box.
    private HelpAboutForm ()
      {
      Text = Localization.ABOUT_BOX_TITLE;
      FormBorderStyle = FormBorderStyle.FixedDialog;
      MaximizeBox = false;
      MinimizeBox = false;
      ControlBox = false;
      Size = new Size (350, 150);

      /*
       * Label contains program information.
       * It's offset from the right to make room for an image (if desired).
       * It leaves enough room at the bottom to let the "OK" button exist,
       * with 10 px of space between the button and the form edge.
       */
      Label l = new Label ();
      l.Location = new Point (75, 10);
      l.Height -= m_ok.Height + 10;
      l.Text = Localization.ABOUT_BOX_TEXT;
      l.Size = new Size (
        ClientSize.Width - l.Location.X,
        ClientSize.Height - l.Location.Y - m_ok.Height - 10);

      Controls.Add (l);

      /*
       * The "OK" button is in the lower-right corner of the dialog,
       * flush against the label.
       */
      m_ok.Text = "OK";
      m_ok.Top = l.Bottom;
      m_ok.Left = l.Right - m_ok.Width - 10;
      m_ok.Click += new EventHandler (_on_ok_clicked);

      Controls.Add (m_ok);

      AcceptButton = m_ok;
      CancelButton = m_ok;
      StartPosition = FormStartPosition.CenterParent;
      }

    // Layout the dialog & set the application icon to ``icon''
    public HelpAboutForm (Icon icon)
      : this ()
      {
      _set_icon (icon);
      }

    /** Position an application icon to the left of the "about" text. */
    private void _set_icon (Icon icon)
      {
      // An image representing the Application.
      PictureBox pb = new PictureBox ();
      pb.Location = new Point (21, 15);
      pb.Size = new Size (32, 32);
      pb.Image = icon.ToBitmap ();
      Controls.Add (pb);
      }

    /** Closes the dialog box. */
    private void _on_ok_clicked (Object sender, EventArgs e)
      {
      Close ();
      }

    // For testing. 
    //
    // Compile with:
    //
    //  csc /r:System.Dll /r:System.Drawing.Dll /r:System.Windows.Forms.Dll  \
    //    /r:Microsoft.Win32.Interop.Dll about.cs ..\localization.cs
    public static void Main ()
      {
      HelpAboutForm haf = new HelpAboutForm ();
      haf._set_icon (haf.Icon);
      Application.Run (haf);
      }
    } /* class HelpAboutForm */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\parseopts.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Parse program options
//

namespace ADepends
  {
  using System;
  using System.Collections; // ArrayList
  using System.Text;        // StringBuilder
  using System.Diagnostics; // Trace

  // A subclass of this is thrown if there is an error parsing
  // the command line.
  internal class OptionException : Exception
    {
    internal OptionException (string s)
      : base (s)
      {
      }
    }


  // This is thrown if an insufficient number of parameters is present.
  //
  // For example, the ``-A'' option takes a string as an argument.
  // If there isn't an argument for the ``-A'' exception then a 
  // MissingParameter exception is thrown.
  internal class MissingParameterException : OptionException
    {
    internal MissingParameterException (string s)
      : base (s)
      {}
    }


  // This type is thrown if a parameter is invalid.  Currently, this
  // only happens with the ``-L'' option, which takes a single 
  // parameter of "default" or "custom".  If the next parameter is
  // neither one of these, then an exception of this type is thrown.
  internal class BadParameterException : OptionException
    {
    internal BadParameterException (string s)
      : base (s)
      {}
    }

  // Parse the command line passed in the constructor.  The supported
  // options are made available as properties.
  internal class ParseOptions
    {
    private bool m_gui = true;
    private bool m_help = false;
    private bool m_cur = false;
    private IList m_files = new ArrayList ();
    private LoadAssemblyInfo  m_lai = new LoadAssemblyInfo ();
    private string m_config;

    // Parse the command line given by ``args''.
    public ParseOptions (string[] args)
      {
      /* 
       * if someone actually wants to list the dependancies of a file named
       * "--help", they don't want ``--help'' to be interpreted as a program
       * argument.  To disable parsing of program arguments, use ``--'', e.g.
       *    adepends -- --help
       */
      bool parse_opts = true;

      for (int i = 0; i < args.Length; i++)
        {
        string arg = args[i];

        if (parse_opts)
          {
          if (_help_message (arg))
            {m_help = true;}
          else if (_use_console (arg))
            {m_gui = false;}
          else if (_use_gui (arg))
            {m_gui = true;}
          else if (_use_current_process (arg))
            {m_cur = true;}
          else if (_load (arg))
            {
            string s = _next (args, ref i, arg);
            try
              {
              m_lai.LoadAs ((AssemblyLoadAs) Enum.Parse (
                  typeof(AssemblyLoadAs), s, true));
              }
            catch
              {
              throw new BadParameterException (
                String.Format (Localization.FMT_BAD_PARAMETER, arg, s));
              }
            }
          else if (_app_base (arg))
            m_lai.AppPath (_next (args, ref i, arg));
          else if (_rels (arg))
            m_lai.RelPath (_next (args, ref i, arg));
          else if (_config (arg))
            m_config = _next (args, ref i, arg);
          else if (arg == "--")
            {parse_opts = false;}
          else
            m_files.Add (arg);
          }
        else
          m_files.Add (arg);
        }
      }

    // Serialize out the options so they can be used by another process.
    public string SerializeOptions ()
      {
      StringBuilder newargs = new StringBuilder ();

      if (m_cur)
        newargs.Append (Localization.USE_CURRENT_PROCESS[0] + " ");


      // all other important options originally passed to us.
      _add_option (m_lai.AppPath(), Localization.APP_BASE_PATH[0], 
        true, newargs);
      _add_option (m_lai.RelPath(), Localization.RELATIVE_SEARCH_PATH[0], 
        true, newargs);
      _add_option (m_lai.LoadAs().ToString(), Localization.LOAD_ASSEMBLY[0], 
        false, newargs);
      _add_option (m_config, Localization.CREATE_CONFIG_FILE[0], true, newargs);

      // we already handled any interpretation of arguments
      // (e.g. ``--help'', so the new process doesn't need to
      // bother; it should accept all remaining arguments as files.
      newargs.Append (" -- ");

      /* add all the files we were asked to display */
      foreach (String s in m_files)
        {
        // we enclose the name in quotes in case the name has spaces.
        newargs.Append ("\"");
        newargs.Append (s);
        newargs.Append ("\" ");
        }

      string args = newargs.ToString();
      Trace.WriteLine ("Serialized Arguments: " + args);
      return args;
      }

    // Does the user want GUI output, or Console output?
    public bool Gui
      {get {return m_gui;}}

    // Should the current process (and possibly console) be taken over
    // to spawn the GUI?
    public bool TakeOverCurrentProcess
      {get {return m_cur;}}

    // The files that the program should open.
    public IList Files
      {get {return m_files;}}

    // Should a help message be displayed to the user?
    public bool Help
      {get {return m_help;}}

    // The name of the Application Configuration File to generate.
    public string ConfigurationFile
      {get {return m_config;}}

    // Information to use when Loading Assemblies.
    public LoadAssemblyInfo LoadAssemblyInfo
      {get {return m_lai;}}


    /** Returns true if ``s'' is contained in ``args'' */
    private static bool _is_specified (string s, string[] args)
      {foreach (string m in args)
        {
        if (m == s)
          return true;
        }
      return false;}

    // Returns true if ``s'' is one of the recognized help arguments
    // (requiring that the help message be displayed).
    //
    // Otherwise, false is returned.
    private static bool _help_message (string s)
      {return _is_specified (s, Localization.HELP_ARGUMENTS);}

    /** Returns true if ``s'' is a flag used to specify console output */
    private static bool _use_console (String s)
      {return _is_specified (s, Localization.CONSOLE_OUTPUT);}

    /** Returns true if ``s'' is a flag used to specify GUI output */
    private static bool _use_gui (String s)
      {return _is_specified (s, Localization.GUI_OUTPUT);}

    // Returns true if we're supposed to "take over" the current console
    // for program output.
    private static bool _use_current_process (String s)
      {return _is_specified (s, Localization.USE_CURRENT_PROCESS);}

    // Returns true if we should interpret the next parameter as the
    // way to load Assemblies.
    private static bool _load (string s)
      {return _is_specified (s, Localization.LOAD_ASSEMBLY);}

    // Returns true if we should interpret the next parameter as the 
    // Application Base Path when loading Assemblies.
    private static bool _app_base (string s)
      {return _is_specified (s, Localization.APP_BASE_PATH);}

    // Returns true if we should interpret the next parameter as the 
    // Relative Search Path when loading Assemblies.
    private static bool _rels (string s)
      {return _is_specified (s, Localization.RELATIVE_SEARCH_PATH);}

    // Returns true if we should interpret the next parameter as the 
    // name of an Application Configuration File to generate.
    private static bool _config (string s)
      {return _is_specified (s, Localization.CREATE_CONFIG_FILE);}

    // If ``s'' is non-null, then append ``o'' and ``s'' to ``a''.
    //
    // If ``quote'' is true, then enclose ``s'' in quotes (so it'll be 
    // properly quoted for parsing in the new process).
    private static void _add_option (string s, string o, 
      bool quote, StringBuilder a)
      {
      if (s != null)
        {
        a.Append (o);
        a.Append (" ");
        if (quote)
          a.Append ("\"");
        a.Append (s);
        if (quote)
          a.Append ("\"");
        a.Append (" ");
        }
      }

    // Retrieve the item after ``cur'' from array ``args''.  If there is
    // no such element, exit the program.
    private static string _next (string[] args, ref int cur, string desc)
      {
      if ((cur+1) >= args.Length)
        throw new MissingParameterException (String.Format (
            Localization.FMT_MISSING_PARAMETER, desc));
      cur++;
      return args[cur];
      }
    } /* class ParseOptions */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\paths.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Display a dialog box that allows the user to specify the paths
// that are used when loading up new Assemblies.
//

namespace ADepends
  {
  using System;
  using System.Collections;
  using System.Drawing;
  using System.Diagnostics;
  using System.Windows.Forms;

  // Display a dialog box that allows the user to type in the
  // name of a manifest to load.
  internal class AssemblyPathsDialog : ResizeableForm
    {
    private Button m_ok = new Button ();
    private Button m_cancel = new Button ();

    private TextBox m_app_base = new TextBox ();
    private TextBox m_rel_search = new TextBox ();

    private const int div = 10;

    private void _add_control (
      Control c, 
      Control above, 
      int dabove, 
      int width)
      {
      c.Top = above.Bottom + dabove;
      c.Left = div;
      c.Width = width;
      c.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;

      Controls.Add (c);
      }

    // Layout the dialog box.
    public AssemblyPathsDialog (string abp, string rsp)
      : base (Localization.ASSEMBLY_PATHS_WINDOW_TITLE)
      {
      // default string values...
      m_app_base.Text = abp;
      m_rel_search.Text = rsp;

      int width = ClientSize.Width - 2*div;

      Label l = new Label ();
      l.Text = Localization.APP_BASE_PATH_DESC;
      l.Location = new Point (div, div);
      l.Width = width;
      l.AutoSize = true;
      Controls.Add (l);
      _add_control (m_app_base, l, div/2, width);

      l = new Label ();
      l.Text = Localization.RELATIVE_SEARCH_PATH_DESC;
      l.AutoSize = true;
      _add_control (l, m_app_base, div, width);
      _add_control (m_rel_search, l, div/2, width);

      m_cancel.Text = Localization.BUTTON_CANCEL;
      m_cancel.Top = ClientSize.Height - m_cancel.Height - div;
      m_cancel.Left = ClientSize.Width - m_cancel.Width - div;
      m_cancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
      m_cancel.Click += new EventHandler (_on_cancel_clicked);

      Controls.Add (m_cancel);

      m_ok.Text = Localization.BUTTON_OK;
      m_ok.Top = m_cancel.Top;
      m_ok.Left = m_cancel.Left - m_ok.Width - div;
      m_ok.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
      m_ok.Click += new EventHandler (_on_ok_clicked);

      Controls.Add (m_ok);

      MinimumSize = new Size (
        ((m_cancel.Right + div) - (m_ok.Left - div)) + div,
        ((m_cancel.Bottom + div) - (Controls[0].Top - div)) + 2*div);

      AcceptButton = m_ok;
      CancelButton = m_cancel;
      StartPosition = FormStartPosition.CenterParent;
      }

    // Closes the dialog box, specifying that the dialog completed
    // succesfully.
    private void _on_ok_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.OK;
      }

    // Closes the dialog box, specifying that the dialog was cancelled.
    private void _on_cancel_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.Cancel;
      }

    // If "OK" was pressed, the AppBase Path to use when loading Assemblies.
    public String AppBasePath
      {
      get 
        {return m_app_base.Text;}
      }

    // If "OK" was pressed, the Relative Search Path to use when loading 
    // Assemblies.
    public String RelativeSearchPath
      {
      get 
        {return m_rel_search.Text;}
      }
    } /* class AssemblyPathsDialog */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\explorer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// An Explorer-like Form.
//

namespace ADepends
  {
  using System;
  using System.Drawing;
  using System.Windows.Forms;

  // The "classic" two-pane explorer view, with a tree view in the left
  // pane and something in the right pane.  In this case, we don't want
  // a ListView in the right; we just want an information panel.
  internal class ExplorerForm : Form
    {
    private TreeView  m_tree = new TreeView ();
    private StatusBar m_sb = new StatusBar ();
    private Splitter  m_divider = new Splitter();
    private Control m_info = new Panel ();

    public TreeView TreeView
      {get {return m_tree;}}

    public StatusBar  StatusBar
      {get {return m_sb;}}

    public Control InfoPane
      {get {return m_info;}}

    // Initialize the form, creating and placing the major elements into
    // their appropriate positions (TreeView in left pane, Splitter bar
    // adjacent to TreeView, etc.).
    public ExplorerForm ()
      {
      InitializeComponent ();
      }

    /** Initialize the Window... */
    private void InitializeComponent ()
      {
      SuspendLayout ();

      Size = new Size (600, 400);

      // Tree View
      m_tree.Name = "Tree View";
      m_tree.TabIndex = 0;

      // Divider
      m_divider.Name = "Tree View Splitter";
      m_divider.TabIndex = 1;
      m_divider.TabStop = false;
      m_divider.Width = 5;

      // InfoPane
      m_info.Name = "Information Panel";
      m_info.ControlAdded += new ControlEventHandler (_on_control_added);
      m_tree.TabIndex = 2;

      // General
      Name = "ExplorerForm";
      _split_sizes ();

      /*
       * Controls MUST be added in reverse order.  If the tree is added before
       * the splitter, the splitter winds up on the wrong side of the tree,
       * making everything look wrong!
       *
       * AddRange() is akin to calling Add() on each element in the array, in
       * the same order of the elements in the array.
       */
      Controls.AddRange (new Control[]
        {
        m_info,
        m_divider,
        m_tree,
        m_sb
        });

      ResumeLayout ();
      }

    // Split up the client area of the window so that the Tree and the
    // InfoPane get (roughly) equivalent screen area.
    private void _split_sizes ()
      {
      Size cs = ClientSize;
      cs.Width /= 2;

      // TreeView
      m_tree.Location = new Point (0, 0);
      m_tree.Dock = DockStyle.Left;
      m_tree.Size = cs;

      // Divider
      m_divider.Left = m_tree.Right;
      m_divider.Location = new Point (m_tree.Right, 0);

      // InfoPane
      m_info.Width = cs.Width - m_divider.Width;
      m_info.Dock = DockStyle.Fill;
      m_info.Height = cs.Height;
      m_info.Location = new Point (m_divider.Right, 0);
      }

    // When a control is added to the info pane, make it the same size as
    // the info pane and (if possible) anchor it to the edges of the pane
    // so it resizes properly.
    private void _on_control_added (Object sender, ControlEventArgs e)
      {
      e.Control.Location = new Point (0, 0);
      e.Control.Size = InfoPane.ClientSize;
      Control rc = (Control) e.Control;
      rc.Dock = DockStyle.Fill;
      }

    // Does this form current contain (show/display) ``ctl''?
    private bool _contains (Control ctl)
      {
      return Controls.GetChildIndex (ctl, false) >= 0;
      }

    // Insert the divider into the current form.  It should only
    // be displayed if *both* the TreeView and the InfoPane are
    // currently displayed; otherwise, the splitter bar is useless.
    //
    // If the TreeView is the only pane displayed, then it's 
    // changed to fill the entire form.
    private void _show_divider ()
      {
      if (_contains(TreeView))
        {
        if (_contains(InfoPane))
          {
          SuspendLayout ();
          /*
           * Ugly stuff lies ahead...
           *
           * In order for the divider to be displayed correctly, it must be
           * added before the tree.
           *
           * In order for the status bar to span the entire window bottom, it
           * must be added last.
           *
           * To ensure that the divider is added before the tree, we need to
           * clear out the current contents and re-add everything.  Since
           * we're clearing out everything, we need to know if the status bar
           * should be displayed.
           *
           * Augh.
           */
          bool showsb = Controls.Contains (m_sb);

          // We have to clear the controls so that the divider is added
          // *before* the Tree.
          Controls.Clear ();
          _split_sizes ();
          Controls.AddRange (new Control[]
            {
            m_info,
            m_divider,
            m_tree,
            });

          if (showsb)
            ShowStatusBar();

          ResumeLayout ();
          }
        else
          {
          m_tree.Size = ClientSize;
          m_tree.Dock = DockStyle.Fill;
          }
        }
      }

    // Hide the divider (because either the InfoPane or the TreeView
    // was hidden).
    //
    // If the TreeView is left, it's modified to fill the entire form.
    private void _hide_divider ()
      {
      Controls.Remove (m_divider);
      if (_contains (TreeView))
        {
        m_tree.Size = ClientSize;
        m_tree.Dock = DockStyle.Fill;
        }
      // don't need to worry about InfoPane, since its DockStyle is always
      // set to ``Fill''.
      }

    // Hide the information pane.  The TreeView (if present) will expand 
    // to fill the window.
    public void HideInfoPane ()
      {Controls.Remove (m_info);
      _hide_divider ();}

    /** Show the information pane. */
    public void ShowInfoPane ()
      {Controls.Add (m_info);
      _show_divider ();}

    /** Remove the Status Bar from the form. */
    public void HideStatusBar ()
      {Controls.Remove (m_sb);}

    /** Add the status bar to the form. */ 
    public void ShowStatusBar ()
      {Controls.Add (m_sb);}

    /** Remove the TreeView from the form. */
    public void HideTreeView ()
      {Controls.Remove (m_tree);
      _hide_divider ();}

    /** Add the TreeView to the form. */ 
    public void ShowTreeView ()
      {Controls.Add (m_tree);
      _show_divider ();}


    // For testing. 
    //
    // Compile with:
    //
    //  csc /r:System.Dll /r:System.Drawing.Dll /r:System.Windows.Forms.Dll  \
    //    explorer.cs 
    public static void Main ()
      {
      ExplorerForm f = new ExplorerForm ();
      f.TreeView.Nodes.Add (new TreeNode ("TreeView"));
      Label l = new Label ();
      l.Text = "InfoPane Window";
      f.InfoPane.Controls.Add (l);
      f.Text = "Explorer Test Program";
      f.StatusBar.Text = "Insert Sample Text here...";
      Application.Run (f);
      }
    } /* class ExplorerForm */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\infopanels.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The Assembly information panels displayed in the GUI application.
//

namespace ADepends
  {
  using System;
  using System.Configuration.Assemblies;  // ProcessorID
  using System.Collections;     // IDictionary, ...
  using System.Drawing;         // Size, ...
  using System.Windows.Forms;        // Everything.
  using System.Reflection;      // AssemblyName
  using System.Text;            // StringBuilder
  using System.Diagnostics;     // Trace
  using Windows.FormsUtils;          // InformationPanel
  using ADepends;
  using System.ComponentModel;

  // Exposed by "information panels" that display the information contained 
  // in an IAssemblyInfo object.
  internal interface IAssemblyInfoPanel
    {
    // Update the form with the information contained in ``ai''.
    void Display (IAssemblyInfo ai);
    }


  // For valid assemblies (see IAssemblyInfo), displays information about
  // the Assembly, such as all of properties made available by the 
  // AssemblyName class, in addition to all referenced Assemblies and
  // contained modules.
  internal class AssemblyInformationPanel : InformationPanel, IAssemblyInfoPanel
    {
    //
    // delegates for each of the properties exposed by AssemblyName.
    //
    private static String _code_base (object an)
      {return ((AssemblyName)an).CodeBase;}
    private static String _culture_info (object an)
      {return ((AssemblyName)an).CultureInfo.ToString();}
    private static String _flags (object an)
      {return ((AssemblyName)an).Flags.ToString();}
    private static String _full_name (object an)
      {return ((AssemblyName)an).FullName;}
    private static String _hash_algorithm (object an)
      {return ((AssemblyName)an).HashAlgorithm.ToString();}
    private static String _key_pair_public_key (object o)
      {AssemblyName an = (AssemblyName) o;
      return an.KeyPair == null ? "" : _batos (an.KeyPair.PublicKey);}
    private static String _name (object an)
      {return ((AssemblyName)an).Name;}
    private static String _version (object an)
      {return ((AssemblyName)an).Version.ToString();}
    private static String _version_compatibility (object an)
      {return ((AssemblyName)an).VersionCompatibility.ToString();}
    private static string _public_key (object an)
      {return _batos (((AssemblyName)an).GetPublicKey());}
    private static string _public_key_token (object an)
      {return _batos (((AssemblyName)an).GetPublicKeyToken());}

    // Binary Array To String:
    //
    // Convert the array of bytes into a string, such that each individual
    // byte is converted into two hexadecimal characters.  For example,
    // the value ``42'' is converted to ``2A''.
    //
    // A space is inserted between each octet generated in this fashion.
    private static string _batos (byte[] ab)
      {
      if ((ab == null) || (ab.Length == 0))
        return "";
      Trace.WriteLine ("array length: " + ab.Length);
      StringBuilder sb = new StringBuilder ();
      sb.Append (ab[0].ToString("x2"));
      for (int i = 1; i < ab.Length; i++) {
          sb.Append(' ');
          sb.Append(ab[i].ToString("x2"));
      }
      return sb.ToString();
      }

    // List of property display names & their associated delegates.
    //
    // This can't be shared between InfoPanels because the NameValueInfo
    // object holds a Label and a TextBox.  Graphical elements (such as 
    // these) can only have one parent, which prevents them from being
    // shown in multiple windows at the same time.
    private NameValueInfo[] s_di = 
      {
      new NameValueInfo (
        Localization.INFO_FULL_NAME, 
        new UpdateProperty (_full_name)),
      new NameValueInfo(
        Localization.INFO_NAME, 
        new UpdateProperty(_name)),
      new NameValueInfo (
        Localization.INFO_PUBLIC_KEY_TOKEN,
        new UpdateProperty (_public_key_token)),
      new NameValueInfo (
        Localization.INFO_PUBLIC_KEY,
        new UpdateProperty (_public_key)),
      new NameValueInfo(
        Localization.INFO_VERSION, 
        new UpdateProperty(_version)), 
      new NameValueInfo(
        Localization.INFO_VERSION_COMPATIBILITY, 
        new UpdateProperty(_version_compatibility)), 
      new NameValueInfo(
        Localization.INFO_CODE_BASE, 
        new UpdateProperty(_code_base)),
      new NameValueInfo(
        Localization.INFO_CULTURE_INFORMATION, 
        new UpdateProperty(_culture_info)),
      new NameValueInfo(
        Localization.INFO_FLAGS, 
        new UpdateProperty(_flags)),
      new NameValueInfo(
        Localization.INFO_HASH_ALGORITHM, 
        new UpdateProperty(_hash_algorithm)),
      new NameValueInfo(
        Localization.INFO_KEY_PAIR, 
        new UpdateProperty(_key_pair_public_key))
      };

    /** Holds referenced assemblies, one assembly per line. */
    private ListView m_refasm;

    /** Holds referenced modules, one modules per line. */
    private ListView m_modules;

    /** Delegate for when a module or Assembly is double clicked. */
    public delegate void ItemActivateEventHandler (String name);

    /** Who to call for double click events on the referenced asssemblies. */
    private event ItemActivateEventHandler m_refassem;

    /** Basic initialization...  */
    internal AssemblyInformationPanel ()
      {
      m_refasm = CreateListView (
        new string[]{Localization.LV_COLUMN_ASSEMBLY_NAME});
      m_modules = CreateListView (
        new string[]{Localization.LV_COLUMN_MODULE_NAME});

      m_refasm.ItemActivate += new EventHandler (_on_assembly_activate);

      TabControl tabs = CreateTabControl ();
      tabs.Layout += new LayoutEventHandler (_on_layout);

      TabPage an = CreateTabPage (Localization.ASSEMBLY_NAME_INFORMATION);
      an.Controls.Add (CreateNameValuePanel (s_di));
      tabs.TabPages.Add (an);

      tabs.TabPages.Add (_create_page (Localization.REF_ASSEMBLIES,
          Localization.REF_ASSEMBLIES_DESC, m_refasm));

      tabs.TabPages.Add (_create_page (Localization.REF_MODULES,
          Localization.REF_MODULES_DESC, m_modules));

      Controls.Add (tabs);
      }

    // If a TabPage is made visible, we want to resize the affected
    // ListViews so that they use all available space.
    private void _on_layout (object sender, LayoutEventArgs e)
      {
      /*
       * Alas, I can't think of an easy way to update only the
       * page that was shown, without searching through the
       * entire Control collection of the TabPage (e.AffectedControl).
       *
       * Consequently, we resize everything.
       */
      if (e.AffectedProperty == "Visible")
        _update_widths ();
      }

    // Helper to create a TabPage containing a ListView.
    private TabPage _create_page (string tab, string label, ListView lv)
      {
      TabPage p = CreateTabPage (tab);
      p.Controls.Add (CreateLabelWithListView (label, lv));
      return p;
      }

    // Update the contents of the property panel to reflect the contents
    // of ``ai''.
    public void Display (IAssemblyInfo ai)
      {
      Debug.Assert (ai.GetAssembly()!=null, 
        "This infopanel doens't display error information.");
      AssemblyName an = ai.GetAssembly().GetName();

      _update_assembly_name (an);
      _update_ref_assemblies (ai);
      _update_modules (ai);
      }

    // Resize the columns in the ListViews so that the columns are as wide as
    // possible.  Helps to minimize the annoying behavior where a column is
    // 100px wide for a string that's 3x wider...
    private void _update_widths ()
      {
      int w = m_refasm.ClientSize.Width;

      _set_col_width (m_refasm, w);
      _set_col_width (m_modules, w);
      }

    /** Set the width of the first column in ``lv'' to ``w''. */
    private void _set_col_width (ListView lv, int w)
      {lv.Columns[0].Width = w;}

    // Update the contents of the AssemblyName tab page.
    private void _update_assembly_name (AssemblyName an)
      {
      Trace.WriteLine ("Updating AssemblyName Information.");

      foreach (NameValueInfo nv in s_di)
        {
        nv.Value.Text = nv.Update (an);

        // make text left-aligned in the textbox.
        if (nv.Value is TextBoxBase)
          ((TextBoxBase)nv.Value).SelectionLength = 0;
        }
      }

    // Update the contents of the Assemblies tab page.
    private void _update_ref_assemblies (IAssemblyInfo ai)
      {
      Trace.WriteLine ("Updating Assembly Information.");
      m_refasm.Items.Clear ();
      foreach (AssemblyName an in ai.ReferencedAssemblies)
        {
        string s = an.FullName;
        Trace.WriteLine ("  Assembly: " + s);
        m_refasm.Items.Add (new ListViewItem (s));
        }
      }

    // Update the contents of the Modules tab page.
    private void _update_modules (IAssemblyInfo ai)
      {
      Trace.WriteLine ("Updating Module Information.");
      m_modules.Items.Clear ();
      foreach (ModuleInfo m in ai.ReferencedModules)
        {
        Trace.WriteLine ("  Module: " + m.Name);
        m_modules.Items.Add (new ListViewItem(m.Name));
        }
      }

    // Allow access to the event handler that will be invoked when the user 
    // double-clicks on an Assembly name in the Property pane.
    public event ItemActivateEventHandler AssemblyActivated
      {remove {m_refassem -= value;}
      add {m_refassem += value;}}


    // Alert all registered delegates for the AssemblyActivated event.
    protected void OnAssemblyActivated (String s)
      {
      if (m_refassem != null)
        m_refassem (s);
      }

    // Invoke any handlers when the user "activates" (double-clicks, etc.)
    // an Assembly name.
    private void _on_assembly_activate (Object sender, EventArgs e)
      {
      if (m_refasm.SelectedItems.Count > 0)
        OnAssemblyActivated (m_refasm.SelectedItems[0].Text);
      }

    } /* class AssemblyInformationPanel */


  // Display a panel for an Assembly that couldn't be loaded.
  internal class AssemblyInfoExceptionPanel : GroupBox, IAssemblyInfoPanel
    {
    Label m_reason;

    internal AssemblyInfoExceptionPanel ()
      {
      Text = Localization.INVALID_ASSEMBLY;
      m_reason = new Label ();
      m_reason.Location = new Point (20, 20);
      m_reason.Dock = DockStyle.Fill;
      Controls.Add (m_reason);
      }

    // The text of the panel is the error message -- why the
    // Assembly couldn't be loaded.
    public void Display (IAssemblyInfo ai)
      {
      Debug.Assert (ai.Error!=null, 
        "No error information available for error panel.");
      AssemblyExceptionInfo aei = (AssemblyExceptionInfo) ai;
      m_reason.Text = aei.Error.Message;
      }

    } /* class AssemblyInfoExceptionPanel */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\menu.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The GUI Menu.
//

namespace ADepends
  {
  using System.Windows.Forms;

  // Maintains/initializes information about the programs main menu.
  internal class DependencyMenu
    {
    private MenuItem  m_file;
    private MenuItem  m_FileOpen;
    private MenuItem  m_FileOpenManifest;
    private MenuItem  m_FileSaveConfig;
    private MenuItem  m_FileClose;
    private MenuItem  m_view;
    private MenuItem  m_ViewStatusBar;
    private MenuItem  m_ViewInformation;
    private MenuItem  m_ViewRefresh;
    private MenuItem  m_tools;
    private MenuItem  m_ToolsCustom;
    private MenuItem  m_ToolsPaths;
    private MenuItem  m_help;
    private MenuItem  m_HelpAbout;
    private MenuItem  m_ViewTree;
    private MainMenu  m_menu;

    // Create the menu.  
    //
    // For reasons I can't fathom, attempting to do this in a constructor
    // disables Drag-and-drop support.  Hence the special-purpose Construct()
    // method.
    public void Construct ()
      {
      m_file = new MenuItem ();
      m_FileOpen = new MenuItem ();
      m_FileOpenManifest = new MenuItem ();
      m_FileSaveConfig = new MenuItem ();
      m_FileClose = new MenuItem ();
      m_view = new MenuItem ();
      m_ViewStatusBar = new MenuItem ();
      m_ViewInformation = new MenuItem ();
      m_ViewTree = new MenuItem ();
      m_ViewRefresh = new MenuItem ();
      m_tools = new MenuItem ();
      m_ToolsCustom = new MenuItem ();
      m_ToolsPaths = new MenuItem ();
      m_help = new MenuItem ();
      m_HelpAbout = new MenuItem ();

      MenuItem div = new MenuItem ("-");

      m_file.Text = Localization.MENU_FILE;

      m_FileOpen.Text = Localization.MENU_FILE_OPEN;
      m_FileOpen.ShowShortcut = true;
      m_FileOpen.Shortcut = Localization.MENU_FILE_OPEN_SHORTCUT;

      m_FileOpenManifest.Text = Localization.MENU_FILE_OPEN_MANIFEST;

      m_FileSaveConfig.Text = Localization.MENU_FILE_SAVE_CONFIG;

      m_FileClose.Text = Localization.MENU_FILE_CLOSE;
      m_FileClose.ShowShortcut = true;
      m_FileClose.Shortcut = Localization.MENU_FILE_CLOSE_SHORTCUT;

      m_file.MenuItems.AddRange( 
        new MenuItem[]{m_FileOpen, m_FileOpenManifest, 
          div.CloneMenu(), m_FileSaveConfig, div.CloneMenu(), m_FileClose});

      m_view.Text = Localization.MENU_VIEW;

      m_ViewStatusBar.Text = Localization.MENU_VIEW_SB;

      m_ViewInformation.Text = Localization.MENU_VIEW_INFO;

      m_ViewTree.Text = Localization.MENU_VIEW_TREE;

      m_ViewRefresh.Text = Localization.MENU_VIEW_REFRESH;
      m_ViewRefresh.ShowShortcut = true;
      m_ViewRefresh.Shortcut = Localization.MENU_VIEW_REFRESH_SHORTCUT;

      m_view.MenuItems.AddRange(new MenuItem[]{m_ViewStatusBar, 
        m_ViewInformation, m_ViewTree, div.CloneMenu(), m_ViewRefresh});

      m_tools.Text = Localization.MENU_TOOLS;

      m_ToolsCustom.Text = Localization.MENU_TOOLS_CUSTOM;
      m_ToolsCustom.RadioCheck = true;
      m_ToolsCustom.Visible = false;

      MenuItem tdiv = div.CloneMenu ();
      tdiv.Visible = false;

      m_ToolsPaths.Text = Localization.MENU_TOOLS_PATHS;

      m_tools.MenuItems.AddRange( new MenuItem[]{
        m_ToolsCustom, tdiv, m_ToolsPaths});

      m_help.Text = Localization.MENU_HELP;

      m_HelpAbout.Text = Localization.MENU_HELP_ABOUT;

      m_help.MenuItems.AddRange(new MenuItem[]{m_HelpAbout});

      m_menu = new MainMenu (new MenuItem[]{m_file, m_view, m_tools, m_help});;
      }

    /** Return the menu to attach to the form. */
    public MainMenu MainMenu
      {get {return m_menu;}}

    public MenuItem  FileOpen
      {get {return m_FileOpen;}}

    public MenuItem  FileOpenManifest
      {get {return m_FileOpenManifest;}}

    public MenuItem  FileSaveConfig
      {get {return m_FileSaveConfig;}}

    public MenuItem  FileClose
      {get {return m_FileClose;}}

    public MenuItem  ViewStatusBar
      {get {return m_ViewStatusBar;}}

    public MenuItem  ViewInformation
      {get {return m_ViewInformation;}}

    public MenuItem  ViewTree
      {get {return m_ViewTree;}}

    public MenuItem  ViewRefresh
      {get {return m_ViewRefresh;}}

    public MenuItem  ToolsCustom
      {get {return m_ToolsCustom;}}

    public MenuItem  ToolsPaths
      {get {return m_ToolsPaths;}}

    public MenuItem  HelpAbout
      {get {return m_HelpAbout;}}

    } /* class Dependency Menu */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\openmanifest.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Display a dialog box that allows the user to manually type in a 
// Manifest name.
//

namespace ADepends
  {
  using System;
  using System.Drawing;
  using System.Windows.Forms;
  using ADepends;

  // Display a dialog box that allows the user to type in the
  // name of a manifest to load.
  internal class OpenManifestDialog : Form
    {
    Button m_ok = new Button ();
    Button m_cancel = new Button ();
    Label  m_open = new Label ();
    Label  m_help = new Label ();
    TextBox m_text = new TextBox ();

    // Layout the dialog box.
    public OpenManifestDialog ()
      {
      Text = Localization.OPEN_WINDOW_TITLE;
      FormBorderStyle = FormBorderStyle.FixedDialog;
      MaximizeBox = false;
      MinimizeBox = false;
      ControlBox = false;
      Size = new Size (300, 120);

      m_help.Text = Localization.OPEN_MANIFEST_HELP;
      m_help.Location = new Point (50, 5);
      m_help.Width = ClientSize.Width - m_help.Left;
      m_help.Height = 30;

      Controls.Add (m_help);

      const int div = 5;

      m_open.Location = new Point (10, m_help.Bottom + div);
      m_open.Text = "&Open:";
      m_open.AutoSize = true;

      Controls.Add (m_open);

      m_text.Left = m_open.Right + div;
      m_text.Top = m_help.Bottom + div;
      m_text.Width = ClientSize.Width - m_text.Left - 10;
      m_text.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;

      Controls.Add (m_text);

      /*
       * The "OK" button is in the lower-right corner of the dialog,
       * flush against the label.
       */
      m_cancel.Text = "Cancel";
      m_cancel.Top = m_text.Bottom + div;
      m_cancel.Left = m_text.Right - m_cancel.Width;
      m_cancel.Click += new EventHandler (_on_cancel_clicked);

      Controls.Add (m_cancel);

      m_ok.Text = "OK";
      m_ok.Top = m_text.Bottom + div;
      m_ok.Left = m_cancel.Left - m_ok.Width - div;
      m_ok.Click += new EventHandler (_on_ok_clicked);

      Controls.Add (m_ok);

      AcceptButton = m_ok;
      CancelButton = m_cancel;
      StartPosition = FormStartPosition.CenterParent;
      }

    // Closes the dialog box, specifying that the dialog completed
    // succesfully.
    private void _on_ok_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.OK;
      }

    // Closes the dialog box, specifying that the dialog was cancelled.
    private void _on_cancel_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.Cancel;
      }

    // If "OK" was pressed, the name of the entered text.
    public string ManifestName
      {
      get 
        {return m_text.Text;}
      }

    /** For testing. */
    public static void Main ()
      {
      Application.Run (new OpenManifestDialog ());
      }

    } /* class OpenManifestDialog */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\gui.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The GUI Application:
//  - Main Form
//  - Program Logic
//  - Drag and Drop suppport
//  - Etc.
//

namespace ADepends
  {
  using System;
  using System.Collections;     // IDictionary, ...
  using System.ComponentModel;  // CancelEventArgs
  using System.Drawing;         // Size, ...
  using System.Windows.Forms;        // Everything.
  using System.Reflection;      // AssemblyName
  using System.Text;            // StringBuilder
  using System.Diagnostics;     // Trace
  using System.IO;              // File
  using ADepends;
  using Windows.FormsUtils;          // TreeContextMenu


  // Associates an IAssemblyInfo object with a tree node, so that it
  // can be viewed when a TreeNode is selected.
  internal class DependencyNode : TreeNode
    {
    private IAssemblyInfo m_info;

    // Create a Dependency Node.
    //
    // If ``d'' is an AssemblyExceptionInfo, then the font color is 
    // set to Red (as the Assembly couldn't be loaded).
    //
    public DependencyNode (String name, IAssemblyInfo d)
      : base (name)
      {
      m_info = d;
      if (d.Error != null)
        ForeColor = Color.Red;
      }

    // Allows access to the wrapped IAssemblyInfo object.
    public IAssemblyInfo Data
      {
      get
        {return m_info;}
      }
    }


  // The main GUI program, this displays a tree view of the 
  // Assembly Dependencies in the left pane, and information about
  // a selected Assembly in the right pane.
  internal class DependenciesForm : ExplorerForm
    {
    /** The application menu. */
    private DependencyMenu m_menu = new DependencyMenu ();

    /** The information panel to display for "good" assemblies. */
    private AssemblyInformationPanel m_infop = new AssemblyInformationPanel ();

    /** The information panel to display for "bad" assemblies. */
    private IAssemblyInfoPanel m_excep = new AssemblyInfoExceptionPanel ();

    /** The initial "information panel", containing the help text. */
    private Label m_help = new Label ();

    /** The assemblies dependency list for the current manifest. */
    private AssemblyDependencies m_ad;

    /** How assemblies should be loaded. */
    private LoadAssemblyInfo m_lai;

    /** The file that we're viewing -- used for Refresh. */
    private string m_file;

    // This shouldn't be needed.
    //
    // When multiple windows are displayed, closing one of them shouldn't
    // quit the entire program, it should close the window.
    //
    // Evidently, this isn't the case.  (Invoking Form.Close quits the
    // entire program, no matter how many forms are open.)
    //
    // Thus, we'll count how many windows there are, and when we hit 0, 
    // close the program.
    private static int m_instances = 0;

    // Create the window.  No assemblies will be displayed.
    public DependenciesForm (LoadAssemblyInfo lai)
      {
      m_lai = new LoadAssemblyInfo ();
      m_lai.LoadAs (lai.LoadAs());
      m_lai.AppPath (lai.AppPath());
      m_lai.RelPath (lai.RelPath());

      InitializeComponent ();
      }

    // Creates the window with a tree view of dependant assemblies/files.
    public DependenciesForm (ICollection names, LoadAssemblyInfo cai)
      {
      m_lai = cai;

      InitializeComponent ();
      if (names.Count > 0)
        {_create_manifest (names);}
      }

    // Used to clean up resources in a .NET Framework Application.
        protected override void Dispose(bool disposing) {
            if (disposing) {
                m_infop.Dispose ();
                if (m_ad != null)
                    m_ad.Dispose ();
            }
            base.Dispose(disposing);
        }

        

    // Setup the main window for display.
    private void InitializeComponent ()
      {
      // increment the # of open windows; this is decremented in
      // _on_file_close_click
      ++m_instances;

      Text = Localization.GUI_WINDOW_TITLE;

      m_infop.AssemblyActivated += 
        new AssemblyInformationPanel.ItemActivateEventHandler (
          _on_assembly_activated);

      // enable OLE drag and drop.
      AllowDrop = true;

      _init_menu ();

      // hide the info pane.
      _on_view_info_click (this, null);

      // The type of assembly loading is dependant on m_lai.
      _set_assembly_load (m_lai.LoadAs());

      // setup viewing of information panel when a tree node is selected.
      TreeView.AfterSelect += new TreeViewEventHandler (_on_tree_node_select);
      TreeView.ContextMenu = new TreeContextMenu (TreeView);

      m_help.Text = Localization.GUI_INTRO_TEXT;
      InfoPane.Controls.Add (m_help);

      _reset_interface ();
      }

    // Set the current information panel to ``c''
    private void _set_infopanel (Control c)
      {
      if (InfoPane.Controls[0] != c)
        {
        InfoPane.Controls.Clear ();
        InfoPane.Controls.Add (c);
        }
      }

    // Check to see if ``d'' is a File (we don't currently understand any other 
    // clipboard formats.
    private static bool _is_file_drop (IDataObject d)
      {foreach (String s in d.GetFormats())
        {if (s == DataFormats.FileDrop)
          return true;}
      return false;}

    /** Display a useful cursor for whatever the user is hovering over us. */
    protected override void OnDragOver (DragEventArgs e)
      {base.OnDragOver (e);
      e.Effect = _is_file_drop (e.Data) 
        ? DragDropEffects.All
        : DragDropEffects.None;}

    /** Display whatever files were dropped on us. */
    protected override void OnDragDrop (DragEventArgs e)
      {
      base.OnDragDrop (e);

      if (_is_file_drop (e.Data))
        {
        try
          {String[] files = (String[]) e.Data.GetData (DataFormats.FileDrop);;
          _create_manifest (files);}
        catch (Exception ex)
          {Trace.WriteLine ("OnDragDrop: exception: " + ex.ToString());
          MessageBox.Show (Localization.GUI_WINDOW_TITLE, 
            Localization.INVALID_DATA_FORMAT);}
        }
      else
        MessageBox.Show (Localization.GUI_WINDOW_TITLE, 
          Localization.UNSUPPORTED_DATA_FORMAT);
      }

    // Creates the menu shown in the window.
    private void _init_menu ()
      {
      m_menu.Construct ();

      Menu = m_menu.MainMenu;

      m_menu.FileOpen.Click += new EventHandler (_on_file_open_click);
      m_menu.FileOpenManifest.Click += 
        new EventHandler (_on_file_open_manifest_click);
      m_menu.FileSaveConfig.Click += new EventHandler (_on_file_save_click);
      m_menu.FileSaveConfig.Enabled = false;
      m_menu.FileClose.Click += new EventHandler (_on_file_close_click);
      m_menu.ViewStatusBar.Checked = true;
      m_menu.ViewStatusBar.Click += new EventHandler (_on_view_sb_click);
      m_menu.ViewInformation.Click += new EventHandler (_on_view_info_click);
      m_menu.ViewInformation.Checked = true;
      m_menu.ViewTree.Checked = true;
      m_menu.ViewTree.Click += new EventHandler (_on_view_tree_click);
      m_menu.ViewRefresh.Click += new EventHandler (_on_view_refresh_click);
      m_menu.ViewRefresh.Enabled = false;
      m_menu.ToolsCustom.Click += new EventHandler (_on_tools_custom_click);
      m_menu.ToolsPaths.Click += new EventHandler (_on_tools_paths_click);
      m_menu.HelpAbout.Click += new EventHandler (_on_help_about_click);
      }

    // Set's the Assembly Dependencies that this window will be displaying
    // and populates the TreeView with the appropriate elements.
    private void _set_dependencies (AssemblyDependencies ad)
      {
      if (m_ad != null)
        throw new Exception (
          "adepends internal error: only one dependency list per window");
      m_ad = ad;
      ArrayList observed = new ArrayList ();
      TreeNode root = _create_info (m_ad, m_ad.ManifestName, observed);
      root.ExpandAll ();
      TreeView.Nodes.Add (root);
      }


    // For the given manifest, build a tree of its dependant assembiles/
    // modules, and display them in the TreeView.
    private void _create_manifest (ICollection manifests)
      {
      Trace.WriteLine ("Loading up manifests...");
      Trace.WriteLine ("  LoadAs: " + m_lai.LoadAs().ToString());
      Trace.WriteLine ("  AppP: " + m_lai.AppPath());
      Trace.WriteLine ("  RelP: " + m_lai.RelPath());

      StringBuilder sb = new StringBuilder ();
      foreach (String manifest in manifests)
        {
        try
          {
          Trace.WriteLine ("  manifest: " + manifest);

          AssemblyDependencies ad = new AssemblyDependencies (manifest, m_lai);

          DependenciesForm f = this;

          // if this window already contains a dependency list, create
          // a new window.
          if (f.m_ad != null)
            {f = new DependenciesForm (m_lai);
            f.Size = Size;

            f._set_assembly_load (f.m_lai.LoadAs());

            f.BringToFront ();
            f.Show ();}

          f._set_dependencies (ad);

          f.m_file = manifest;
          f.m_menu.ViewRefresh.Enabled = true;
          f.m_menu.FileSaveConfig.Enabled = true;

          // set the infopanel to the root node.
          f.TreeView.SelectedNode = f.TreeView.Nodes[0];
          }
        catch (System.ArgumentNullException e)
          {Trace.WriteLine ("_create_manifest: arg null exception: " + 
            e.ToString());
          sb.Append(String.Format (Localization.FMT_INVALID_MANIFEST,
            manifest, Localization.INVALID_ASSEMBLY_MANIFEST));
          _reset_interface ();}
        catch (System.Exception e)
          {Trace.WriteLine ("_create_manifest: exception: " + e.ToString());
          sb.Append(String.Format (Localization.FMT_INVALID_MANIFEST,
            manifest, e.Message));
          _reset_interface ();}
        }
      if (sb.Length > 0)
        {
        // some of the files couldn't be opened; alert the user.
        MessageBox.Show (this, 
          String.Format (Localization.FMT_INVALID_FILE_LIST,
            Localization.UNOPENED_FILES, sb.ToString()),
          Localization.GUI_WINDOW_TITLE,
          MessageBoxButtons.OK);
        }
      }

    // Creates a TreeNode for the Assembly given by ``name'' and all of
    // its dependant assemblies and modules.
    //
    // If a dependant assembly hasn't been displayed yet, add a new sub-tree
    // to the current tree describing the dependancy.
    //
    private TreeNode _create_info 
      (AssemblyDependencies ad, String name, ArrayList o)
      {
      IAssemblyInfo ai = ad[name];
      DependencyNode root = new DependencyNode (ai.Name, ai);

      if (!o.Contains (name))
        {
        o.Add (name);
        TreeNode referenced = new TreeNode (Localization.REFERENCED_ASSEMBLIES);
        TreeNode files = new TreeNode (Localization.CONTAINED_MODULES);
        root.Nodes.Add (referenced);
        root.Nodes.Add (files);

        foreach (AssemblyName s in ai.ReferencedAssemblies)
          {
          referenced.Nodes.Add(_create_info (ad, s.FullName, o));
          }

        foreach (ModuleInfo m in ai.ReferencedModules)
          {
          DependencyNode d = new DependencyNode (m.Name, ai);
          files.Nodes.Add (d);
          }
        }
      return root;
      }

    // Does the node ``tn'' (or any of its sub-nodes) contain the 
    // string ``name''?
    //
    // If so, then the current selected node in the TreeView is set to
    // the node that has ``name'' as its text, and we return true.
    //
    // Otherwise, false is returned.
    private bool _node_contains (TreeNode tn, String name)
      {
      if (tn == null)
        return false;
      // Console.WriteLine ("Checking Node: " + tn);
      if (tn.Text == name)
        {
        TreeView.SelectedNode = tn;
        return true;
        }
      else
        {
        foreach (TreeNode n in tn.Nodes)
          {
          if (_node_contains(n, name))
            return true;
          }
        }
      return false;
      }

    // When an Assembly in the Information Pane is activated (double-clicked,
    // etc.), we want to make the selected Assembly the current assembly,
    // displaying its information pane.
    //
    // This is done so that the user doesn't need to hunt around in the 
    // TreeView to find a dependent assembly.
    //
    private void _on_assembly_activated (String name)
      {
      foreach (TreeNode tn in TreeView.Nodes)
        {
        if (_node_contains(tn, name))
          break;
        }
      }

    // If no information is displayed, make sure that:
    //  - The introductory help text is displayed.
    //  - The StatusBar shows an appropriate message
    //  - The Refresh command is disabled.
    private void _reset_interface ()
      {
      if (m_ad == null)
        {
        _set_infopanel (m_help);
        m_menu.ViewRefresh.Enabled = false;
        m_menu.FileSaveConfig.Enabled = false;
        StatusBar.Text = Localization.GUI_NO_ASSEMBLY_SELECTED;
        }
      }

    // This event is fired when the user clicks the `X' in the upper-right
    // corner of the main window.
    //
    // The default action is to quit the program.  As the program may have 
    // several windows open, this is a Bad Thing--the program should quit
    // only after all the windows have been closed.
    //
    // Thus, we cancel the OnClosing event, and call our file->exit handler
    // (which will do the right thing and quit the program when all windows
    // have been closed).
    protected override void OnClosing (CancelEventArgs e)
      {
      base.OnClosing (e);
      e.Cancel = true;
      _close_window (true);
      }

    // End the lifetime of a window.
    private void _close_window ()
      {
      Hide ();
      Dispose ();
      }

    // Close the current window.
    private void _close_window (bool force)
      {
      if (m_instances > 1)
        {
        // there are other windows open, so just close this one.
        --m_instances;
        _close_window ();
        }
      else if (m_ad != null && !force)
        {
        // this is the last window, so clear the TreeView.
        m_ad = null;
        TreeView.Nodes.Clear ();
        _reset_interface ();
        }
      else
        {
        // this is the last window; exit the program.
        _close_window ();
        Application.Exit ();
        }
      }

    // File->Close handler; Close the current Assembly.
    private void _on_file_close_click (object sender, System.EventArgs e)
      {
      _close_window (false);
      }

    // File->Open handler; Display a dialog box to view a new Assembly.
    //
    // Take any selected files and open them up (if appropriate).
    private void _on_file_open_click (Object sender, System.EventArgs e)
      {
      OpenFileDialog ofd = new OpenFileDialog ();
      ofd.Filter = Localization.OPEN_FILTER;
      ofd.Multiselect = true;
      ofd.CheckFileExists = true;
      ofd.CheckPathExists = true;
      if (ofd.ShowDialog () == DialogResult.OK)
        {
        _create_manifest (ofd.FileNames);
        }
      }

    // File->Open Manifest handler; Display a dialog box to let the user
    // specify a manifest to load.
    //
    // Take any selected files and open them up (if appropriate).
    private void _on_file_open_manifest_click(Object sender, System.EventArgs e)
      {
      OpenManifestDialog omd = new OpenManifestDialog ();
      if (omd.ShowDialog () == DialogResult.OK)
        {
        _create_manifest (new string[]{omd.ManifestName});
        }
      }

    // Generate an Application Configuration File for the currently
    // loaded Assemblies.
    private void _on_file_save_click (Object sender, System.EventArgs e)
      {
      SaveFileDialog sfd = new SaveFileDialog ();
      sfd.Filter = Localization.SAVE_AS_FILTER;

      // Replace the file extension with .cfg (e.g. "foo.exe" -> "foo.cfg")
      string f = m_file;

      string ext = Path.GetExtension (m_file);
      if (ext.Length > 0)
        {int eb = m_file.LastIndexOf (ext);
        f = m_file.Substring (0, eb);}
      sfd.FileName = f + ".cfg";

      if (sfd.ShowDialog () == DialogResult.OK)
        {
        AppConfig.SaveConfig (m_ad, sfd.FileName);
        }
      }

    /** Enable/disable the information pane. */
    private void _on_view_info_click (Object sender, System.EventArgs e)
      {
      if (_reverse_menu_check (m_menu.ViewInformation)) 
        ShowInfoPane ();
      else
        HideInfoPane ();
      }

    /** Enable/disable the status bar */
    private void _on_view_sb_click (Object sender, System.EventArgs e)
      {
      if (_reverse_menu_check (m_menu.ViewStatusBar))
        ShowStatusBar ();
      else
        HideStatusBar ();
      }

    /** Enable/Disable the tree view. */
    private void _on_view_tree_click (Object sender, System.EventArgs e)
      {
      if (_reverse_menu_check (m_menu.ViewTree))
        ShowTreeView ();
      else
        HideTreeView ();
      }

    /** Reload the current file. */
    private void _on_view_refresh_click (Object sender, System.EventArgs e)
      {
      // use the current window for loading.
      m_ad = null;
      TreeView.Nodes.Clear ();

      // re-populate the tree view.
      _create_manifest (new string[]{m_file});
      }

    // Reverse the checked status of the menu item, and return the
    // current checked state.
    private bool _reverse_menu_check (MenuItem mi)
      {
      mi.Checked = mi.Checked ? false : true;
      return mi.Checked;
      }

    // Called whenever the user selects a node in the tree.  If the
    // node contains any useful information, we display it in the
    // Info Pane.
    private void _on_tree_node_select (Object sender, TreeViewEventArgs e)
      {
      Trace.WriteLine ("Node Selected: " + e.Node.Text);
      _update_infopanel (e.Node);
      }

    private void _update_infopanel (TreeNode tn)
      {
      if (tn is DependencyNode)
        {
        DependencyNode dn = (DependencyNode) tn;
        IAssemblyInfoPanel c;
        if (dn.Data.GetAssembly()==null)
          c = m_excep;
        else
          c = m_infop;
        c.Display (dn.Data);
        _set_infopanel ((Control)c);
        StatusBar.Text = Localization.ASSEMBLY + dn.Data.Name;
        }
      }

    // Set up the Tools menu so that the menu corresponding to ``a'' is
    // selected.
    private void _set_assembly_load (AssemblyLoadAs a)
      {
      switch (a)
        {
      case AssemblyLoadAs.Custom:
        _set_assembly_load (m_menu.ToolsCustom);
        break;
      default:
        throw new Exception ("Internal Error: invalid AssemblyLoadAs value.");
        }
      }

    // Specify the way that Assemblies should be loaded, updating the
    // Tools menu accordingly.
    private void _set_assembly_load (MenuItem mi)
      {
        m_menu.ToolsCustom.Checked = true;
        m_menu.ToolsPaths.Enabled = true;
        m_lai.LoadAs (AssemblyLoadAs.Custom);
      }

    /** Specify that Custom Assembly loading should be used. */
    private void _on_tools_custom_click (object sender, EventArgs e)
      {
      _set_assembly_load (m_menu.ToolsCustom);
      }

    // We want to use null for the default search paths, so if the string
    // doesn't contain anything, we return null.
    private static string _path (string s)
      {return s.Length > 0 ? s : null;}

    // Display a dialog allowing the user to modify the paths used
    // when Loading an Assembly.
    private void _on_tools_paths_click (Object sender, EventArgs e)
      {
      AssemblyPathsDialog apd = new AssemblyPathsDialog (
        m_lai.AppPath(), m_lai.RelPath());

      if (apd.ShowDialog (this) == DialogResult.OK)
        {
        m_lai.AppPath (_path (apd.AppBasePath));
        m_lai.RelPath (_path (apd.RelativeSearchPath));
        }
      }

    /** Display a dialog box giving information about this program. */
    private void _on_help_about_click (Object sender, EventArgs e)
      {new HelpAboutForm(Icon).ShowDialog (this);}

    } /* class DependenciesForm */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\createprocess.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Display a dialog box that allows the user to specify arguments on
// a new process to create & debug.
//

namespace AdProfiler
  {
  using System;
  using System.Collections;
  using System.Drawing;
  using System.Diagnostics;
  using System.Windows.Forms;
  using AdProfiler;

  // Display a dialog box that allows the user to type in the
  // name of a manifest to load.
  internal class CreateProcessDialog : ResizeableForm
    {
    private Button m_ok = new Button ();
    private Button m_cancel = new Button ();

    private TextBox m_executable = new TextBox ();
    private TextBox m_workdir = new TextBox ();
    private TextBox m_arguments = new TextBox ();

    private const int div = 10;

    private void _add_control (
      Control c, 
      Control above, 
      int dabove, 
      int width)
      {
      c.Top = above.Bottom + dabove;
      c.Left = div;
      c.Width = width;
      c.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;

      Controls.Add (c);
      }

    // Layout the dialog box.
    public CreateProcessDialog ()
      : base (Localization.CREATE_PROCESS_WINDOW_TITLE)
      {
      int width = ClientSize.Width - 2*div;

      Label l = new Label ();
      l.Text = Localization.CREATE_PROCESS_EXECUTABLE;
      l.Location = new Point (div, div);
      l.Width = width;
      l.AutoSize = true;
      Controls.Add (l);
      _add_control (m_executable, l, div/2, width);

      m_executable.TextChanged += new EventHandler (_on_text_changed);

      l = new Label ();
      l.Text = Localization.CREATE_PROCESS_ARGUMENTS;
      l.AutoSize = true;
      _add_control (l, m_executable, div, width);
      _add_control (m_arguments, l, div/2, width);

      m_arguments.TextChanged += new EventHandler (_on_text_changed);

      l = new Label ();
      l.Text = Localization.CREATE_PROCESS_DIRECTORY;
      l.AutoSize = true;
      _add_control (l, m_arguments, div, width);
      _add_control (m_workdir, l, div/2, width);

      m_cancel.Text = Localization.BUTTON_CANCEL;
      m_cancel.Top = ClientSize.Height - m_cancel.Height - div;
      m_cancel.Left = ClientSize.Width - m_cancel.Width - div;
      m_cancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
      m_cancel.Click += new EventHandler (_on_cancel_clicked);

      Controls.Add (m_cancel);

      m_ok.Text = Localization.BUTTON_OK;
      m_ok.Enabled = false;
      m_ok.Top = m_cancel.Top;
      m_ok.Left = m_cancel.Left - m_ok.Width - div;
      m_ok.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
      m_ok.Click += new EventHandler (_on_ok_clicked);

      Controls.Add (m_ok);

      MinimumSize = new Size (
        ((m_cancel.Right + div) - (m_ok.Left - div)) + div,
        ((m_cancel.Bottom + div) - (Controls[0].Top - div)) + 2*div);

      AcceptButton = m_ok;
      CancelButton = m_cancel;
      StartPosition = FormStartPosition.CenterParent;
      }

    // If there's text in m_executable or m_arguments, then enable [OK].
    private void _on_text_changed (Object sender, EventArgs e)
      {
      if (m_executable.Text.Length > 0 || m_arguments.Text.Length > 0)
        m_ok.Enabled = true;
      else
        m_ok.Enabled = false;
      }

    // Closes the dialog box, specifying that the dialog completed
    // succesfully.
    private void _on_ok_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.OK;
      }

    // Closes the dialog box, specifying that the dialog was cancelled.
    private void _on_cancel_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.Cancel;
      }

    // If "OK" was pressed, the name of the Program to create.
    public String ApplicationName
      {
      get 
        {return m_executable.Text;}
      }

    // If "OK" was pressed, the program command line to use.
    public String CommandLine
      {
      get 
        {return m_arguments.Text;}
      }

    // If "OK" was pressed, the name of the Working directory for the 
    // new program.
    public String WorkingDirectory
      {
      get 
        {return (m_workdir.Text.Length != 0) ? m_workdir.Text : ".";}
      }

    /** For testing. */
    public static void Main ()
      {
      Application.Run (new CreateProcessDialog ());
      }

    } /* class CreateProcessDialog */

  } /* namespace AdProfiler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\adprofiler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Assembly Dependancies Lister
//
// Lists all Assemblies that an Assembly is dependant upon to load.
//

namespace AdProfiler
  {
  using System.Windows.Forms;
  using AdProfiler;

  public class MainProgram
    {
    public static void Main ()
      {
      Application.Run (new AppDomainProfilerForm());
      }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\about.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The Help->About dialog box.
//

namespace AdProfiler
  {
  using System;
  using System.Drawing;
  using System.Windows.Forms;
  using AdProfiler;

  // Display an "About" dialog box.
  internal class HelpAboutForm : Form
    {
    Button m_ok = new Button ();

    public HelpAboutForm ()
      {
      Text = Localization.ABOUT_BOX_TITLE;
      FormBorderStyle = FormBorderStyle.FixedDialog;
      MaximizeBox = false;
      MinimizeBox = false;
      ControlBox = false;
      Size = new Size (350, 150);

      /*
       * Label contains program information.
       * It's offset from the right to make room for an image (if desired).
       * It leaves enough room at the bottom to let the "OK" button exist,
       * with 10 px of space between the button and the form edge.
       */
      Label l = new Label ();
      l.Location = new Point (75, 10);
      l.Height -= m_ok.Height + 10;
      l.Text = Localization.ABOUT_BOX_TEXT;
      l.Size = new Size (
        ClientSize.Width - l.Location.X,
        ClientSize.Height - l.Location.Y - m_ok.Height - 10);

      Controls.Add (l);

      /*
       * The "OK" button is in the lower-right corner of the dialog,
       * flush against the label.
       */
      m_ok.Text = "OK";
      m_ok.Top = l.Bottom;
      m_ok.Left = l.Right - m_ok.Width - 10;
      m_ok.Click += new EventHandler (_on_ok_clicked);

      Controls.Add (m_ok);

      AcceptButton = m_ok;
      CancelButton = m_ok;
      StartPosition = FormStartPosition.CenterParent;
      }

    /** Layout the dialog & set the application icon to ``icon''. */
    public HelpAboutForm (Icon icon)
      : this ()
      {
      _set_icon (icon);
      }

    /** Position an application icon to the left of the "about" text. */
    private void _set_icon (Icon icon)
      {
      // An image representing the Application.
      PictureBox pb = new PictureBox ();
      pb.Location = new Point (21, 15);
      pb.Size = new Size (32, 32);
      pb.Image = icon.ToBitmap ();
      Controls.Add (pb);
      }

    /** Closes the dialog box. */
    private void _on_ok_clicked (Object sender, EventArgs e)
      {
      Close ();
      }

    // For testing. 
    //
    // Compile with:
    //
    //  csc /r:System.Dll /r:System.Drawing.Dll /r:System.Windows.Forms.Dll  \
    //    /r:Microsoft.Win32.Interop.Dll about.cs ..\localization.cs
    public static void Main ()
      {
      HelpAboutForm haf = new HelpAboutForm ();
      haf._set_icon (haf.Icon);
      Application.Run (haf);
      }
    } /* class HelpAboutForm */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\explorer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// An Explorer-like Form.
//

namespace AdProfiler
  {
  using System;
  using System.Drawing;
  using System.Windows.Forms;

  // The "classic" two-pane explorer view, with a tree view in the left
  // pane and something in the right pane.  In this case, we don't want
  // a ListView in the right; we just want an information panel.
  internal class ExplorerForm : Form
    {
    private TreeView  m_tree = new TreeView ();
    private StatusBar m_sb = new StatusBar ();
    private Splitter  m_divider = new Splitter();
    private Control m_info = new Panel ();

    public TreeView TreeView
      {get {return m_tree;}}

    public StatusBar  StatusBar
      {get {return m_sb;}}

    public Control InfoPane
      {get {return m_info;}}

    // Initialize the form, creating and placing the major elements into
    // their appropriate positions (TreeView in left pane, Splitter bar
    // adjacent to TreeView, etc.).
    public ExplorerForm ()
      {
      Size = new Size (600, 400);

      Size cs = ClientSize;
      cs.Width /= 2;
      cs.Height -= m_sb.Height;
      
      m_tree.Size = cs;
      m_tree.Dock = DockStyle.Left;

      m_divider.Text = "Tree View Splitter";
      m_divider.Dock = DockStyle.Left;
      m_divider.Left = m_tree.Right;

      m_info.Text = "Information Panel";
      m_info.Left = m_divider.Right;
      m_info.Width = cs.Width - m_divider.Width;
      m_info.Height = cs.Height;
      m_info.Dock = DockStyle.Fill;
      m_info.ControlAdded += new ControlEventHandler (_on_control_added);

      Controls.Add (m_tree);
      Controls.Add (m_divider);
      Controls.Add (m_info);
      Controls.Add (m_sb);
      }

    // When a control is added to the info pane, make it the same size as
    // the info pane and (if possible) anchor it to the edges of the pane
    // so it resizes properly.
    private void _on_control_added (Object sender, ControlEventArgs e)
      {
      e.Control.Location = new Point (0, 0);
      e.Control.Size = InfoPane.ClientSize;
      e.Control.Dock = DockStyle.Fill;
      }

    // Does this form current contain (show/display) ``ctl''?
    private bool _contains (Control ctl)
      {
      return Controls.GetChildIndex (ctl, false) >= 0;
      }

    // Insert the divider into the current form.  It should only
    // be displayed if *both* the TreeView and the InfoPane are
    // currently displayed; otherwise, the splitter bar is useless.
    //
    // If the TreeView is the only pane displayed, then it's 
    // changed to fill the entire form.
    private void _show_divider ()
      {
      if (_contains(TreeView))
        {
        if (_contains(InfoPane))
          {
          m_tree.Dock = DockStyle.Left;
          m_divider.Left = m_tree.Right;
          Controls.Add (m_divider);
          }
        else
          {
          m_tree.Size = ClientSize;
          m_tree.Dock = DockStyle.Fill;
          }
        }
      }

    // Hide the divider (because either the InfoPane or the TreeView
    // was hidden).
    //
    // If the TreeView is left, it's modified to fill the entire form.
    private void _hide_divider ()
      {
      Controls.Remove (m_divider);
      if (_contains (TreeView))
        {
        m_tree.Size = ClientSize;
        m_tree.Dock = DockStyle.Fill;
        }
      }

    // Hide the information pane.  The TreeView (if present) will expand 
    // to fill the window.
    public void HideInfoPane ()
      {Controls.Remove (m_info);
      _hide_divider ();}

    /** Show the information pane. */
    public void ShowInfoPane ()
      {Controls.Add (m_info);
      _show_divider ();}

    /** Remove the Status Bar from the form. */
    public void HideStatusBar ()
      {Controls.Remove (m_sb);}

    /** Add the status bar to the form. */ 
    public void ShowStatusBar ()
      {Controls.Add (m_sb);}

    /** Remove the TreeView from the form. */
    public void HideTreeView ()
      {Controls.Remove (m_tree);
      _hide_divider ();}

    /** Add the TreeView to the form. */ 
    public void ShowTreeView ()
      {Controls.Add (m_tree);
      _show_divider ();}

    } /* class ExplorerForm */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)
	echo This is needed to avoid a syntax error when processing this file. :-(


!if "$(TARGETCOMPLUS)" != ""
# Copy the files to the target COM+ directory
	copy $(COOL_TARGET) $(TARGETCOMPLUS)
!endif

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\resizeableform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Helper class to create a basic "sizeable form" -- the lower-right
// corner has the "Gripper" widget, no minimize/maximize boxes, and
// it isn't shown in the task bar.
//
// In short, it's good for Dialog boxes, but not much else.
//

namespace ADepends
  {
  using System;
  using System.Collections;
  using System.Drawing;
  using System.Diagnostics;
  using System.Windows.Forms;

  // Basics for a dialog box which has the following properties:
  //  - no minimize button
  //  - no maximize button
  //  - Gripper bar in lower-right corner
  //  - not displayed in task bar
  //  - basic size of 300x225 px.
  internal class ResizeableForm : Form
    {
    // Layout the dialog box.
    public ResizeableForm (string titleText)
      {
      Text = titleText;
      // BorderStyle = FormBorderStyle.FixedDialog;
      MaximizeBox = false;
      MinimizeBox = false;
      ControlBox = false;
      ShowInTaskbar = false;
      SizeGripStyle = SizeGripStyle.Show;
      Size = new Size (300, 225);
      }
    } /* class ResizeableForm */
  } /* namespace AdProfiler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\history.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Display a dialog box that shows the history of all prior events in
// the program.
//

namespace AdProfiler
  {
  using System;
  using System.Collections;
  using System.Drawing;
  using System.Diagnostics;
  using System.Windows.Forms;
  using AdProfiler;

  // Displays a window containing the text of all previous events.
  internal class HistoryDialog : ResizeableForm
    {
    Button m_close = new Button ();
    Button m_clear = new Button ();
    TextBox m_text = new TextBox ();

    // Layout the dialog box.
    public HistoryDialog ()
      : base (Localization.HISTORY_WINDOW_TITLE)
      {
      Size = new Size (450, 300);

      const int div = 10;

      m_close.Text = Localization.BUTTON_CLOSE;
      m_close.Top = ClientSize.Height - m_close.Height - div;
      m_close.Left = ClientSize.Width - m_close.Width - div;
      m_close.Anchor = AnchorStyles.Right | AnchorStyles.Bottom;
      m_close.Click += new EventHandler (_on_close_clicked);

      Controls.Add (m_close);

      m_clear.Text = Localization.BUTTON_CLEAR;
      m_clear.Top = m_close.Top;
      m_clear.Left = m_close.Left - m_clear.Width - div;
      m_clear.Anchor = m_close.Anchor;
      m_clear.Click += new EventHandler (_on_clear_clicked);

      Controls.Add (m_clear);

      m_text.Multiline = true;
      m_text.ReadOnly = true;
      m_text.ScrollBars = ScrollBars.Vertical;

      m_text.Location = new Point (div, div);
      m_text.Width = ClientSize.Width - 2*div;
      m_text.Height = m_close.Top - m_text.Top - div;
      m_text.Anchor = AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom;;
      
      Controls.Add (m_text);

      AcceptButton = m_close;
      CancelButton = m_close;
      StartPosition = FormStartPosition.CenterParent;
      }

    // The text of the history window is the text of the textbox.
    public void AddMessage (String message)
      {
      /*
       * Use of AppendText should be more efficient (since we're only
       * appending text), but its use tends to break the program.
       *
       * More specifically, if we use AppendText, when the Debuggee
       * quits, the call to AppendText never appears to return.
       */
      // m_text.AppendText (message + Localization.LINE_ENDING);
      m_text.Text += message + Localization.LINE_ENDING;
      m_text.SelectionLength = 0;
      }

    // Closes the dialog box, specifying that the dialog completed
    // succesfully.
    private void _on_close_clicked (Object sender, EventArgs e)
      {
      Hide ();
      }

    // Clear out the contents of the textbox.
    private void _on_clear_clicked (Object sender, EventArgs e)
      {
      m_text.Text = "";
      }

    private static void _test_string (HistoryDialog hd)
      {
      String s = "This is a long message.";
      for (int i = 0; i < 100; i++)
        hd.AddMessage (s);
      }

    /** For testing. */
    public static void Main ()
      {
      HistoryDialog hd = new HistoryDialog ();
      _test_string (hd);
      Application.Run (hd);
      }

    } /* class SelectProcessDialog */
  } /* namespace AdProfiler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adepends\gui\wfutils.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Utility code for Windows.Forms Programs.
//

namespace Windows.FormsUtils
  {
  using System;
  using System.Diagnostics; // Debug
  using System.Drawing;     // Graphics
  using System.Collections; // IComparer
  using System.Windows.Forms;    // Everything
  using System.Text;        // StringBuilder
  using ADepends;           // Localization
  using System.Globalization; // InvariantCulture


  // The context menu displayed for the ListViews; it just allows
  // the user to copy the name(s) of selected items to the clipboard.
  internal class ListContextMenu : ContextMenu
    {
    private ListView  m_lv;

    // Provide a context menu for the ListView ``lv''.
    public ListContextMenu (ListView lv)
      {
      m_lv = lv;
      MenuItem copy = new MenuItem ();
      copy.Text = Localization.CTXM_COPY;
      copy.Click += new EventHandler (_on_copy_clicked);
      MenuItems.Add (copy);
      }

    // Copy the names of selected items to the clipboard.
    private void _on_copy_clicked (Object sender, EventArgs e)
      {
      StringBuilder sb = new StringBuilder ();
      foreach (ListViewItem li in m_lv.SelectedItems)
        {
        sb.Append (li.Text + Localization.LINE_ENDING);
        }
      if (sb.Length > 0)
        Clipboard.SetDataObject (sb.ToString(), true);
      }
    } /* class ListContextMenu */


  // The context menu that gets displayed when the user right-clicks
  // inside the TreeView.
  //
  // If the TreeView is empty (e.g. when the program is first launched),
  // there shouldn't be a context menu; otherwise, a context menu
  // specific to the node the mouse is over should be displayed.
  //
  // In this case, all nodes get the same context menu; however, it's
  // still necessary to determine which node the cursor is over.
  //
  // In order to do this, we read the MousePosition property of the
  // TreeView in the OnPopup handler.
  internal class TreeContextMenu : ContextMenu
    {
    /** The TreeView we're interacting with. */
    TreeView m_tv;

    /** The current context menu to display. */
    MenuItem[] m_items;

    /** The mouse position when the dialog box is displayed. */
    Point m_pt;

    // Create a ContextMenu for the TreeView ``tv''.
    public TreeContextMenu (TreeView tv)
      {
      m_tv = tv;

      MenuItem select = new MenuItem ();
      select.Text = Localization.CTXM_SELECT;
      select.Click += new EventHandler (_on_select_clicked);

      MenuItem copy = new MenuItem ();
      copy.Text = Localization.CTXM_COPY;
      copy.Click += new EventHandler (_on_copy_clicked);

      m_items = new MenuItem[]{select, copy};
      }

    // Store the position the mouse is in when the mouse is clicked.
    // This position is needed for the Selet & Click handlers, otherwise
    // the wrong node is selected (as the mouse will be in a different
    // position).
    private void _store_mouse_position ()
      {
      m_pt = m_tv.PointToClient (Control.MousePosition);
      }

    // Returns the node underneath the current mouse position.
    private TreeNode _get_node ()
      {return m_tv.GetNodeAt (m_pt);}

    // Modify the menu items to be displayed.
    //
    // If no TreeNode is under the cursor, no menu should be displayed.
    protected override void OnPopup (EventArgs e)
      {
      _store_mouse_position ();
      TreeNode over = _get_node ();
      if (over == null)
        MenuItems.Clear ();
      else
        {
        // only add items if they're not already present.
        if (MenuItems.Count == 0)
          MenuItems.AddRange(m_items);
        }
      }

    // Make the node under the cursor the "Selected Node" of the TreeView.
    private void _on_select_clicked (Object sender, EventArgs e)
      {m_tv.SelectedNode = _get_node ();}

    // Copy the text of the current node to the Windows Clipboard.
    private void _on_copy_clicked (Object sender, EventArgs e)
      {Clipboard.SetDataObject (_get_node().Text, true);}

    } /* class TreeContextMenu */


  // Compares the items in a column of a ListView; used to sort them
  // with System.Array.Sort.
  internal class ListItemComparer : IComparer
    {
    /** the column to sort */
    private int m_column;

    /** sort A..Z (true) or Z..A (false) ?*/
    private bool m_dir;

    // Create the comparison helper.
    //
    public ListItemComparer (int column, bool dir)
      {m_column = column;
      m_dir = dir;}

    // Compare the objects ``x'' and ``y''.
    //
    // If ``x'' and ``y'' aren't ListItems, an exception will be thrown.
    public int Compare (Object x, Object y)
      {
      ListViewItem lix = (ListViewItem) x;
      ListViewItem liy = (ListViewItem) y;

      String sx;
      String sy;

      // Column 0 corresponds to the label of the items.
      // other columns are subitems.
      if (m_column == 0)
        {
        sx = lix.Text;
        sy = liy.Text;
        }
      else
        {
        sx = lix.SubItems[m_column-1].Text;
        sy = liy.SubItems[m_column-1].Text;
        }

      if (m_dir)
        return string.Compare(sx, sy, false, CultureInfo.InvariantCulture);
      return string.Compare(sy, sx, false, CultureInfo.InvariantCulture);
      }
    } /* class ListItemComparer */


  // Helper class which provides creation services for derived classes
  internal class InformationPanel : Panel
    {
    // This is intended to be invoked by derived classes in order to update
    // the name/value pairs in some of their information panels.
    //
    protected delegate string UpdateProperty (Object o);

    // The output will consist of the following format:
    //
    //    [Property name (Label)] [Property value (TextBox)]
    //
    // This class just makes it easier to deal with displaying each
    // "line" of the displayed window.
    //
    // The ``Update'' member is used to update ``Value'', when appropriate.
    protected class NameValueInfo
      {
      public Label Name;
      public Control Value;
      public UpdateProperty Update;

      public NameValueInfo (Label l, TextBox v, UpdateProperty u)
        {Name = l; Value = v; Update = u;}

      public NameValueInfo ()
        {Name = null; Value = null; Update = null;}

      public NameValueInfo (String s, UpdateProperty u)
        {Name = new Label (s); Value = new TextBox (); Update = u;}
      } /* class NameValueInfo */

    // A helper class to turn creation of a Label from 2 statements
    // into one statement.  (Yes, I'm that lazy a typer.)
    protected class Label : System.Windows.Forms.Label
      {
      public Label (String s)
        {
        Text = s;
        }
      }

    /** Used to determine how long a string will be on the current display. */
    private Graphics m_g;

    public InformationPanel ()
      {
      m_g = CreateGraphics ();
      }

    protected Graphics GetGraphics ()
      {return m_g;}


    // Insert the Name/Value pairs into the form in the order that they're
    // present in the array.
    //
    // Each NameValueInfo will be vertically aligned.
    protected Panel CreateNameValuePanel (NameValueInfo[] values)
      {
      SizeF maxf = new SizeF(0, 0);

      Panel p = new Panel ();
      p.AutoScroll = true;
      p.Dock = DockStyle.Fill;

      // Create the labels for each property, and record the maximum width of
      // the name.
      foreach (NameValueInfo nv in values)
        {
        SizeF cs = m_g.MeasureString (nv.Name.Text, Font);
        nv.Name.AutoSize = true;

        if (cs.Width > maxf.Width)
          maxf.Width = cs.Width;
        if (cs.Height > maxf.Height)
          maxf.Height = cs.Height;
        if (nv.Value is TextBoxBase)
          ((TextBoxBase)nv.Value).ReadOnly = true;
        }

      int tbh = _textbox_height ();

      // max height of a "row" in the property page
      int maxh = Math.Max (tbh,  ((int)(maxf.Height+0.5)));

      // max dimension for a property label
      Size max = new Size ((int)(maxf.Width + 0.5), maxh);

      // location of upper-left corner of a property label.
      Point loc = new Point (0, 5);

      // the # of pixels that separate "lines" of output.
      const int div = 2;

      // name width
      int nw = max.Width;

      // value width
      int vw = p.ClientSize.Width - nw - div;

      /* 
       * Resize each control, and place into position on the panel.
       */
      foreach (NameValueInfo nv in values)
        {
        nv.Name.Location = new Point (nw - nv.Name.Width, loc.Y);

        nv.Value.Location = new Point (nw + div, loc.Y);
        nv.Value.Height = max.Height;
        nv.Value.Width = vw;
        nv.Value.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;

        _center_label (nv.Name, maxh);

        p.Controls.Add (nv.Name);
        p.Controls.Add (nv.Value);

        loc.Y += max.Height + div;
        }
      return p;
      }

    // Create a TabControl, with its dock style set to Fill.
    protected TabControl CreateTabControl ()
      {
      TabControl tabs = new TabControl ();
      tabs.Dock = DockStyle.Fill;
      return tabs;
      }

    // Creates a TabPage, setting common options.
    protected TabPage CreateTabPage (string title)
      {
      TabPage tp = new TabPage (title);
      tp.AutoScroll = true;
      tp.Dock = DockStyle.Fill;
      return tp;
      }

    // Setting the Anchor style and adding a TextBox to a container changes
    // the height of the control.  (I don't know why).  This is the height
    // we want (as it corresponds to the height for a single line of text, 
    // plus the TextBox border).
    //
    // So, we take a TextBox, set its Anchor style, add it to a container,
    // remove the TextBox, and see what its new height is.
    //
    private int _textbox_height ()
      {
      Control c = new TextBox ();
      c.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
      Controls.Add (c);
      int tbh = c.Height;
      Controls.Remove (c);
      return tbh;
      }

    // Vertically center a label within ``maxh'', so that it looks
    // correct next to it's value.
    private void _center_label (Label l, int maxh)
      {
      int top = l.Top;
      // l.AutoSize = true;
      if (maxh > l.Height)
        {
        // text box is taller than label; center the label
        int diff = maxh - l.Height;
        diff = (int)((((float)diff)/2F)+0.5);
        l.Top = top + diff;
        }
      }

    // Create a listview with ``headers'' being all of the column headers
    // that the listview displays.
    //
    // The returned ListView will be:
    //  - set in Report view
    //  - Have a default context menu with "Copy" as a ContextMenu item.
    protected ListView CreateListView (String[] headers)
      {
      ListView lv = new ListView ();
      lv.Dock = DockStyle.Fill;

      foreach (String s in headers)
        {
        ColumnHeader ch = new ColumnHeader ();
        ch.Text = s;
        lv.Columns.Add (ch);
        }

      lv.View = View.Details;
      lv.AllowColumnReorder = true;
      lv.FullRowSelect = true;
      lv.MultiSelect = true;
      lv.ContextMenu = new ListContextMenu (lv);
      lv.ColumnClick += new ColumnClickEventHandler (_on_lv_column_click);

      return lv;
      }

    // Creates a Panel with the following layout:
    //  
    //  +-------------------------+
    //  | Label                   |
    //  +-------------------------+
    //  | +---------------------+ |
    //  | | ListView            | |
    //  | |                     | |
    //  | +---------------------+ |
    //  +-------------------------+
    //
    // The label will be resized to be as large as is necessary to display
    // the text, and the ListView will be flush agains the bottom of the
    // label.
    //
    protected Panel CreateLabelWithListView (String s, ListView lv)
      {
      Panel p = new Panel ();
      p.Dock = DockStyle.Fill;

      SizeF cs = m_g.MeasureString (s, Font);

      const int div = 5;

      Label l = new Label (s);
      l.Size = new Size ( (int)(cs.Width+0.5), (int)(cs.Height + 0.5));
      l.Location = new Point (0, div);
      p.Controls.Add (l);

      Panel plv = new Panel ();
      plv.Top = l.Bottom + div;
      plv.Left = 0;
      plv.Width = p.ClientSize.Width;
      plv.Height = p.ClientSize.Height - plv.Top;
      plv.Controls.Add (lv);
      plv.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;

      p.Controls.Add (plv);

      return p;
      }

    // Invoked when the user clicks a column header of a ListView.
    //
    // Sort the contents of the selected column.
    private void _on_lv_column_click (object sender, ColumnClickEventArgs e)
      {
      ListView lv = sender as ListView;

      /* 
       * this "shouldn't happen", as this class is the only one with
       * access to this method, and we shouldn't add this handler to
       * an object that isn't a ListView.
       */
      Debug.Assert (lv != null, "Need a ListView for sorting!");

      switch (lv.Sorting)
        {
        case SortOrder.Ascending:
          lv.Sorting = SortOrder.Descending;
          break;
        case SortOrder.Descending:
          goto case SortOrder.None;
        case SortOrder.None:
          lv.Sorting = SortOrder.Ascending;
          break;
        }
      }
    } /* class InformationPanel */
  } /* namespace Windows.FormsUtils */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\gui.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The GUI Application:
//  - Main Form
//  - Program Logic
//  - Drag and Drop suppport
//  - Etc.
//

namespace AdProfiler
  {
  using System;
  using System.Collections;     // IDictionary, ...
  using System.ComponentModel;  // CancelEventArgs
  using System.Drawing;         // Size, ...
  using System.Windows.Forms;        // Everything.
  using System.Reflection;      // AssemblyName
  using System.Text;            // StringBuilder
  using AdProfiler;
  using Debugging;
  using System.Diagnostics;

  // Various functions useful for searching nodes in a TreeNode.
  internal class TreeNodeUtils
    {
    // Get the subnode of ``tn'' having the Text value ``s''.
    public static TreeNode GetNode (TreeNode tn, String s)
      {
      if (tn == null)
        return null;

      foreach (TreeNode t in tn.Nodes)
        if (t.Text == s)
          return t;

      return null;
      }
    }


  // Associates an IDebuggeeInformationPanel with a TreeNode;
  // useful for knowing which information panel to display
  // when a node is selected.
  internal class DisplayableNode : TreeNode
    {
    private IDebuggeeInformationPanel m_info;

    private void _invariants ()
      {
      Debug.Assert (!(m_info is Control),
        "DisplayableNode invariant: panel isn't a control!");
      }

    public DisplayableNode (IDebuggeeInformationPanel p)
      {m_info = p;
      _invariants();}

    public DisplayableNode (IDebuggeeInformationPanel p, String s)
      : base (s)
      {m_info = p;
      _invariants();}

    // Display this form inside of the associated panel.
    //
    // Returns the panel used.
    public Control Display ()
      {m_info.Display (this);
      return (Control) m_info;}
    }


  // Associates information about a DebuggedAssembly with a Node.
  // This information will be used in the information panel.
  internal class AssemblyNode : DisplayableNode
    {
    private DebuggedAssembly m_asm;

    public AssemblyNode (IDebuggeeInformationPanel p, DebuggedAssembly da)
      : base (p, da.Name)
      {
      m_asm = da;
      }

    /** The Assembly we're debugging. */
    public DebuggedAssembly Assembly
      {get {return m_asm;}}
    }


  // Associates information about a DebuggedAppDomain with a Node.
  // This information will be used in the information panel.
  internal class AppDomainNode : DisplayableNode
    {
    private DebuggedAppDomain m_ad;

    public AppDomainNode (IDebuggeeInformationPanel p, DebuggedAppDomain ad)
      : base (p, ad.Name)
      {
      m_ad = ad;
      }

    // Add an AssemblyNode underneath this node in the TreeView.
    public AssemblyNode Add (AssemblyNode a)
      {
      AssemblyNode an = Get (a.Assembly, false);
      if (an == null)
        {
        an = a;
        Nodes.Add (an);
        }
      return an;
      }

    // Get the subnode corresponding to ``a''.
    public AssemblyNode Get (DebuggedAssembly a)
      {
      return Get (a, true);
      }

    // Get the subnode corresponding to ``a''.
    public AssemblyNode Get (DebuggedAssembly a, bool thro)
      {
      AssemblyNode an = (AssemblyNode) TreeNodeUtils.GetNode (this, a.Name);
      if (an == null && thro)
        throw new NoSuchAssembly ();
      return an;
      }

    /** The Assembly we're debugging. */
    public DebuggedAppDomain AppDomain
      {get {return m_ad;}}
    }


  // Associates information about a DebuggedAppDomain with a Node.
  // This information will be used in the information panel.
  internal class ProcessNode : DisplayableNode
    {
    // map<int, AppDomainNode>
    private IDictionary m_adm = new Hashtable ();

    private DebuggedProcess m_dproc;

    private String m_proc;

    private static string _proc_name (Process p)
      {return _proc_name (p.ProcessName, p.Id);}

    private static string _proc_name (string p, int id)
      {return p + " (" + id + ")";}


    public ProcessNode (IDebuggeeInformationPanel i, Process p)
      : base (i, _proc_name(p))
      {
      SetProcess (p);
      }

    public ProcessNode (IDebuggeeInformationPanel i)
      : base (i, "insert name here; the user should NOT see this!")
      {
      }

    // Add an AppDomainNode underneath this node in the TreeView.
    public AppDomainNode Add (AppDomainNode ad)
      {
      AppDomainNode t = Get (ad.AppDomain, false);
      if (t==null)
        {
        t = ad;
        Nodes.Add (t);
        m_adm.Add (t.AppDomain.Id, t);
        }
      return t;
      }

    public void Remove (AppDomainNode ad)
      {
      ad.Remove ();
      m_adm.Remove (ad.AppDomain.Id);
      }

    public AppDomainNode Get (DebuggedAppDomain ad)
      {return Get (ad, true);}

    // Get the appropriate AppDomainNodeNode that matches the
    // name of the DebuggedAppDomain.
    public AppDomainNode Get (DebuggedAppDomain ad, bool thro)
      {
      AppDomainNode adn = (AppDomainNode) m_adm[ad.Id];
      if (adn == null && thro)
        throw new NoSuchAppDomain();
      return adn;
      }

    // Add an AssemblyNode underneath the appropriate AppDomain.
    public AssemblyNode Add (AssemblyNode a)
      {
      AppDomainNode adn = Get (a.Assembly.AppDomain);
      return adn.Add (a);
      }

    public AssemblyNode Get (DebuggedAssembly a)
      {
      return Get (a.AppDomain).Get (a);
      }

    internal void SetProcess (DebuggedProcess dp)
      {m_dproc = dp;
      if (m_proc==null)
        m_proc = _proc_name (ProcessName, dp.Id);}

    internal void SetProcess (Process p)
      {m_proc = _proc_name (p);
      Text = m_proc;}

    /** The Process we're debugging. */
    public DebuggedProcess Process
      {get {return m_dproc;}}

    public String ProcessName
      {get {return m_proc!=null ? m_proc : Localization.UNKNOWN_PROCESS;}}
    }


  // Thrown when attempting to add an AppDomain/Assembly for which the
  // process containing the it hasn't been registered.
  internal class NoSuchProcess : Exception
    {
    }

  // Thrown when attempting to add an Assembly when the AppDomain it's
  // located in hasn't been registered.
  internal class NoSuchAppDomain : Exception
    {
    }

  // Thrown when attempting to get an Assembly and it hasn't been
  // added to its containing AppDomain.
  internal class NoSuchAssembly : Exception
    {
    }

  // The main GUI program, this displays a tree view of the 
  // Assembly Dependencies in the left pane, and information about
  // a selected Assembly in the right pane.
  //
  // In order for the tree view to be correctly updated, any 
  // "higher" nodes in the tree must already be present before
  // "lower" nodes are added.  For example, in order for an 
  // Assembly to be displayed, both the Process & AppDomain that
  // the Assembly is inside of must *already* be present.
  //
  // This is why a ProcessNode is added to the TreeView before
  // we attach to/create a process: immediately after the 
  // attach or create, we'll begin to get event notifications,
  // and these may arrive before the ProcessNode would otherwise
  // be added to the TreeView.  This would result in a "corrupt"
  // display, hence the two-step process.
  //
  // See also: _create_process, _on_process_attach, 
  //    _on_file_attach_click, _on_file_create_click
  internal class AppDomainProfilerForm : ExplorerForm
    {
    // The context menu that gets displayed when the user right-clicks
    // inside the TreeView.
    //
    // If the TreeView is empty (e.g. when the program is first launched),
    // there shouldn't be a context menu; otherwise, a context menu
    // specific to the node the mouse is over should be displayed.
    //
    // In this case, all nodes get the same context menu; however, it's
    // still necessary to determine which node the cursor is over.
    //
    // In order to do this, we read the MousePosition property of the
    // TreeView in the OnPopup handler.
    private class TreeContextMenu : ContextMenu
      {
      /** The TreeView we're interacting with. */
      TreeView m_tv;

      /** The current context menu to display. */
      MenuItem[] m_items;

      /** The mouse position when the dialog box is displayed. */
      Point m_pt;

      // Create a ContextMenu for the TreeView ``tv''.
      public TreeContextMenu (TreeView tv)
        {
        m_tv = tv;

        MenuItem select = new MenuItem ();
        select.Text = Localization.CTXM_SELECT;
        select.Click += new EventHandler (_on_select_clicked);

        MenuItem copy = new MenuItem ();
        copy.Text = Localization.CTXM_COPY;
        copy.Click += new EventHandler (_on_copy_clicked);

        m_items = new MenuItem[]{select, copy};
        }

      // Store the position the mouse is in when the mouse is clicked.
      // This position is needed for the Selet & Click handlers, otherwise
      // the wrong node is selected (as the mouse will be in a different
      // position).
      private void _store_mouse_position ()
        {
        m_pt = m_tv.PointToClient (Control.MousePosition);
        }

      // Returns the node underneath the current mouse position.
      private TreeNode _get_node ()
        {return m_tv.GetNodeAt (m_pt);}

      // Modify the menu items to be displayed.
      //
      // If no TreeNode is under the cursor, no menu should be displayed.
      protected override void OnPopup (EventArgs e)
        {
        _store_mouse_position ();
        TreeNode over = _get_node ();
        if (over == null)
          MenuItems.Clear ();
        else
          {
          // only add items if they're not already present.
          if (MenuItems.Count == 0)
            MenuItems.AddRange(m_items);
          }
        }

      // Make the node under the cursor the "Selected Node" of the TreeView.
      private void _on_select_clicked (Object sender, EventArgs e)
        {m_tv.SelectedNode = _get_node ();}

      // Copy the text of the current node to the Windows Clipboard.
      private void _on_copy_clicked (Object sender, EventArgs e)
        {Clipboard.SetDataObject (_get_node().Text, true);}

      } /* class TreeContextMenu */

    /** The application menu. */
    private AdProfilerMenu m_menu = new AdProfilerMenu ();

    private HistoryDialog m_history = new HistoryDialog ();

    private static ManagedEvents   m_events = new ManagedEvents ();

    private ProcessNode m_procn;

    private IDebuggeeInformationPanel m_iproc = new ProcessInformationPanel ();
    private IDebuggeeInformationPanel m_iad = new AppDomainInformationPanel ();
    private IDebuggeeInformationPanel m_iasm = new AssemblyInformationPanel ();
    private Control m_dmesg = new Label ();

    // This shouldn't be needed.
    //
    // When multiple windows are displayed, closing one of them shouldn't
    // quit the entire program, it should close the window.
    //
    // Evidently, this isn't the case.  (Invoking Form.Close quits the
    // entire program, no matter how many forms are open.)
    //
    // Thus, we'll count how many windows there are, and when we hit 0, 
    // close the program.
    private static int m_instances = 0;

    // Create the window.  No assemblies will be displayed.
    public AppDomainProfilerForm ()
      {
      InitializeComponent ();
      }

    // Creates the window with a tree view of AppDomains & their Assemblies.
    public AppDomainProfilerForm (ICollection names)
      {
      InitializeComponent ();
      if (names.Count > 0)
        {}
      }

    // Used to clean up resources in a WFC Application.
    protected override void Dispose(bool disposing) {
        if (disposing) {
            m_events.Close();
        }
        base.Dispose(disposing);
    }

    // Setup the main window for display.
    private void InitializeComponent ()
      {
      // increment the # of open windows; this is decremented in
      // _close_window (bool)
      ++m_instances;

      // set up events...
      m_events.CreateProcess += 
        new DebuggedProcessEventHandler (_on_create_process);
      m_events.ProcessExit += 
        new DebuggedProcessEventHandler (_on_process_exit);
      m_events.ModuleLoad += new DebuggedModuleEventHandler (_on_module_load);
      m_events.ModuleUnload += 
        new DebuggedModuleEventHandler (_on_module_unload);
      m_events.CreateAppDomain += 
        new DebuggedAppDomainEventHandler (_on_create_appdomain);
      m_events.AppDomainExit += 
        new DebuggedAppDomainEventHandler (_on_appdomain_exit);
      m_events.AssemblyLoad += 
        new DebuggedAssemblyEventHandler (_on_assembly_load);
      m_events.AssemblyUnload += 
        new DebuggedAssemblyEventHandler (_on_assembly_unload);
      m_events.NameChange += new DebuggedThreadEventHandler (_on_name_change);

      Text = Localization.GUI_WINDOW_TITLE;

      _init_menu ();

      // hide the info pane.
      _on_view_info_click (this, null);

      // setup viewing of information panel when a tree node is selected.
      TreeView.AfterSelect += new TreeViewEventHandler (_on_tree_node_select);
      TreeView.ContextMenu = new TreeContextMenu (TreeView);

      m_dmesg.Text = "Hello, world!";
      InfoPane.Controls.Add (m_dmesg);

      _reset_interface ();
      }

    // Creates the menu shown in the window.
    private void _init_menu ()
      {
      m_menu.Construct ();

      Menu = m_menu.MainMenu;

      m_menu.FileClose.Click += new EventHandler (_on_file_close_click);
      m_menu.FileAttachToProcess.Click += 
        new EventHandler (_on_file_attach_click);
      m_menu.FileCreateProcess.Click +=
        new EventHandler (_on_file_create_click);
      m_menu.ViewStatusBar.Checked = true;
      m_menu.ViewStatusBar.Click += new EventHandler (_on_view_sb_click);
      m_menu.ViewInformation.Click += new EventHandler (_on_view_info_click);
      m_menu.ViewInformation.Checked = true;
      m_menu.ViewTree.Checked = true;
      m_menu.ViewTree.Click += new EventHandler (_on_view_tree_click);
      m_menu.ViewHistory.Click += new EventHandler (_on_view_history_click);
      m_menu.HelpAbout.Click += new EventHandler (_on_help_about_click);
      }

    // Update the text located in the history buffer with ``message''.
    private void _history (String message)
      {
      Trace.WriteLine (message);
      m_history.AddMessage (message);
      }

    private void _set_process (DebuggedProcess dp)
      {
      m_procn.SetProcess (dp);
      // dp.Continue (false);
      }

    private void _on_create_process (Object sender, DebuggedProcessEventArgs e)
      {
      _set_process (e.Process);
      _history ("Create Process: " + m_procn.ProcessName);
      }

    // What to do after attaching to a process to debug.
    private void _on_process_attach (DebuggedProcess dp)
      {
      _history ("Process Attach: " + m_procn.ProcessName);
      _set_process (dp);
      }

    private ProcessNode _create_process (Process p)
      {
      return _create_process (new ProcessNode (m_iproc, p));
      }

    private ProcessNode _create_process (ProcessNode pn)
      {
      Debug.Assert (m_procn != null, "You did something stupid.");
      m_procn = pn;
      TreeView.Nodes.Add (m_procn);
      return m_procn;
      }

    // Remove the process ``e.Process'' from the TreeView.
    private void _on_process_exit (Object sender, DebuggedProcessEventArgs e)
      {
      ProcessNode dp = m_procn;
      m_procn = null;
      _history ("Process Exit: " + dp.ProcessName);
      _history ("--------");
      dp.Remove ();
      _set_infopanel (m_dmesg);
      Trace.WriteLine ("Current # nodes in tree: " + TreeView.Nodes.Count);
      }

    private void _on_module_load (Object sender, DebuggedModuleEventArgs e)
      {
      // TreeView.Nodes.Add (new TreeNode ("module load: " + e.Module.Name));
      }

    private void _on_module_unload (Object sender, DebuggedModuleEventArgs e)
      {
      // TreeView.Nodes.Add (new TreeNode ("module unload: " + e.Module.Name));
      }

    // Create the textual representation of an AppDomain for use in the
    // History window.
    private static string _appdomain_name (DebuggedAppDomain a)
      {return a.Name + " (" + a.Id + ")";}

    // Add the AppDomain ``e.AppDomain'' to the TreeView, underneath the
    // correct process.
    //
    // Attach to the AppDomain so that we receive Module/Assembly Load/Unload
    // events in the future.
    private void _on_create_appdomain (Object sender, 
      DebuggedAppDomainEventArgs e)
      {
      _history ("Created AppDomain: " + _appdomain_name (e.AppDomain));

      e.AppDomain.Attach ();

      m_procn.Add (new AppDomainNode (m_iad, e.AppDomain));
      }

    // Remove the AppDomain ``e.AppDomain'' from the TreeView
    private void _on_appdomain_exit (Object sender,
      DebuggedAppDomainEventArgs e)
      {
      _history ("AppDomain Exit: " + e.AppDomain.Name);
      AppDomainNode ad = m_procn.Get (e.AppDomain);
      m_procn.Remove (ad);
      }

    // Add the Assembly ``e.Assembly'' to the TreeView, underneath the
    // correct AppDomain.
    private void _on_assembly_load (Object sender, DebuggedAssemblyEventArgs e)
      {
      _history ("Assembly Load: " + e.Assembly.Name);
      AssemblyNode an = m_procn.Add (new AssemblyNode (m_iasm, e.Assembly));
      }

    // Remove the Assembly ``e.Assembly'' from the TreeView
    private void _on_assembly_unload (Object sender, 
      DebuggedAssemblyEventArgs e)
      {
      _history ("Assembly Unload: " + e.Assembly.Name);
      AssemblyNode an = m_procn.Get (e.Assembly);
      an.Remove ();
      }

    // The names of AppDomains may change through the life of the program,
    // so we do that here.
    private void _on_name_change (Object sender, DebuggedThreadEventArgs e)
      {
      AppDomainNode adn = m_procn.Get (e.AppDomain);
      _history ("AppDomain Name Change; AppDomain (" + e.AppDomain.Id + 
        ") now known as: " + _appdomain_name (e.AppDomain));
      adn.Text = e.AppDomain.Name;
      }

    // Get an "empty" window for an operation, such as process
    // creation or process attach.
    //
    // An "empty" window is a window that isn't currently debugging
    // a process (m_procn==null).
    private AppDomainProfilerForm _get_form ()
      {
      AppDomainProfilerForm f = this;

      if (f.m_procn != null)
        {
        f = new AppDomainProfilerForm ();
        f.Size = Size;
        f.BringToFront ();
        f.Show ();
        }

      return f;
      }

    // File->AttachToProcess handler; display a dialog box allowing the
    // user to select a process to attach to.
    private void _on_file_attach_click (Object sender, System.EventArgs e)
      {
      SelectProcessDialog spd = new SelectProcessDialog ();

      if (spd.ShowDialog (this) == DialogResult.OK)
        {
        foreach (Process p in spd.Processes)
          {
          AppDomainProfilerForm f = _get_form ();
          f._create_process (p);
          f._on_process_attach (m_events.AttachToProcess (p.Id));
          }
        }
      }

    // File->Create Process handler; display a dialog box allow the 
    // user to create a new process and view its activities.
    private void _on_file_create_click (Object sender, System.EventArgs e)
      {
      CreateProcessDialog cpd = new CreateProcessDialog ();

      if (cpd.ShowDialog (this) == DialogResult.OK)
        {
        try
          {
          // if "appName" is null, then "commandLine" is used to determine
          // the process to create.  This simplifies process creation.
          DebuggedProcess dp = m_events.GetDebugger().CreateProcess (
            cpd.ApplicationName.Length > 0 ? cpd.ApplicationName : null,
            cpd.CommandLine,
            cpd.WorkingDirectory);

          AppDomainProfilerForm f = _get_form ();
          f._create_process (new ProcessNode (m_iproc));

          Process p = Process.GetProcessById (dp.Id);
          f.m_procn.SetProcess (p);
          // f._on_process_attach (dp);
          }
        catch (Exception ex)
          {
          MessageBox.Show (ex.Message, Localization.GUI_WINDOW_TITLE);
          }
        }
      }

    // If no information is displayed, make sure that:
    //  - The introductory help text is displayed.
    //  - The StatusBar shows an appropriate message
    //  - The Refresh command is disabled.
    private void _reset_interface ()
      {
      if (m_procn == null)
        {
        _set_infopanel (m_dmesg);
        StatusBar.Text = "This space for rent.";
        }
      }

    // This event is fired when the user clicks the `X' in the upper-right
    // corner of the main window.
    //
    // The default action is to quit the program.  As the program may have 
    // several windows open, this is a Bad Thing--the program should quit
    // only after all the windows have been closed.
    //
    // Thus, we cancel the OnClosing event, and call our file->exit handler
    // (which will do the right thing and quit the program when all windows
    // have been closed).
    protected override void OnClosing (CancelEventArgs e)
      {
      base.OnClosing (e);
      e.Cancel = true;
      _close_window (true);
      }

    // End the lifetime of a window.
    private void _close_window ()
      {
      Hide ();
      Dispose ();
      }

    // Close the current window.
    private void _close_window (bool force)
      {
      if (m_instances > 1)
        {
        // there are other windows open, so just close this one.
        --m_instances;
        _close_window ();
        }
      else if (m_procn != null && !force)
        {
        // this is the last window, so clear the TreeView
        m_procn = null;
        TreeView.Nodes.Clear ();
        _reset_interface ();
        }
      else
        {
        // this is the last window; exit the program.
        _close_window ();
        Application.Exit ();
        }
      }

    // File->Close handler; Closes the current window.
    // If all windows have been closed, then the applcation is exited.
    private void _on_file_close_click (Object sender, System.EventArgs e)
      {
      _close_window (false);
      }


    /** Enable/disable the information pane. */
    private void _on_view_info_click (Object sender, System.EventArgs e)
      {
      if (_reverse_menu_check (m_menu.ViewInformation)) 
        ShowInfoPane ();
      else
        HideInfoPane ();
      }

    /** Enable/disable the status bar */
    private void _on_view_sb_click (Object sender, System.EventArgs e)
      {
      if (_reverse_menu_check (m_menu.ViewStatusBar))
        ShowStatusBar ();
      else
        HideStatusBar ();
      }

    /** Enable/Disable the tree view. */
    private void _on_view_tree_click (Object sender, System.EventArgs e)
      {
      if (_reverse_menu_check (m_menu.ViewTree))
        ShowTreeView ();
      else
        HideTreeView ();
      }

    /** Show the history window. */
    private void _on_view_history_click (Object sender, EventArgs e)
      {
      m_history.Show ();
      }

    // Reverse the checked status of the menu item, and return the
    // current checked state.
    private bool _reverse_menu_check (MenuItem mi)
      {
      mi.Checked = mi.Checked ? false : true;
      return mi.Checked;
      }

    // Called whenever the user selects a node in the tree.  If the
    // node contains any useful information, we display it in the
    // Info Pane.
    private void _on_tree_node_select (Object sender, TreeViewEventArgs e)
      {
      if (e.Node is DisplayableNode)
        {
        DisplayableNode dn = (DisplayableNode) e.Node;
        Control c = dn.Display ();
        _set_infopanel (c);
        }
      }

    // Set the information panel to ``c''
    private void _set_infopanel (Control c)
      {
      if (InfoPane.Controls[0] != c)
        {
        InfoPane.Controls.Clear ();
        InfoPane.Controls.Add (c);
        }
      }

    /** Display a dialog box giving information about this program. */
    private void _on_help_about_click (Object sender, EventArgs e)
      {new HelpAboutForm(Icon).ShowDialog (this);}

    } /* class AppDomainProfilerForm */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\menu.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The GUI Menu.
//

namespace AdProfiler
  {
  using System.Windows.Forms;

  // Maintains/initializes information about the programs main menu.
  internal class AdProfilerMenu
    {
    private MenuItem  m_file;
    private MenuItem  m_FileAttachToProcess;
    private MenuItem  m_FileCreateProcess;
    private MenuItem  m_FileClose;
    private MenuItem  m_view;
    private MenuItem  m_ViewStatusBar;
    private MenuItem  m_ViewInformation;
    private MenuItem  m_ViewHistory;
    private MenuItem  m_help;
    private MenuItem  m_HelpAbout;
    private MenuItem  m_ViewTree;
    private MainMenu  m_menu;

    // Create the menu.  
    //
    // For reasons I can't fathom, attempting to do this in a constructor
    // disables Drag-and-drop support.  Hence the special-purpose Construct()
    // method.
    public void Construct ()
      {
      m_file = new MenuItem ();
      m_FileAttachToProcess = new MenuItem ();
      m_FileCreateProcess = new MenuItem ();
      m_FileClose = new MenuItem ();
      m_view = new MenuItem ();
      m_ViewStatusBar = new MenuItem ();
      m_ViewInformation = new MenuItem ();
      m_ViewTree = new MenuItem ();
      m_ViewHistory = new MenuItem ();
      m_help = new MenuItem ();
      m_HelpAbout = new MenuItem ();

      MenuItem div = new MenuItem ("-");

      m_file.Text = Localization.MENU_FILE;

      m_FileAttachToProcess.Text = Localization.MENU_FILE_ATTACH;
      m_FileAttachToProcess.ShowShortcut = true;
      m_FileAttachToProcess.Shortcut = Localization.MENU_FILE_ATTACH_SHORTCUT;

      m_FileCreateProcess.Text = Localization.MENU_FILE_CREATE_PROCESS;
      m_FileCreateProcess.ShowShortcut = true;
      m_FileCreateProcess.Shortcut = 
        Localization.MENU_FILE_CREATE_PROCESS_SHORTCUT;

      m_FileClose.Text = Localization.MENU_FILE_CLOSE;
      m_FileClose.ShowShortcut = true;
      m_FileClose.Shortcut = Localization.MENU_FILE_CLOSE_SHORTCUT;

      m_file.MenuItems.AddRange( 
        new MenuItem[]{m_FileAttachToProcess, m_FileCreateProcess, 
          div.CloneMenu(), m_FileClose});

      m_view.Text = Localization.MENU_VIEW;

      m_ViewStatusBar.Text = Localization.MENU_VIEW_SB;

      m_ViewInformation.Text = Localization.MENU_VIEW_INFO;

      m_ViewTree.Text = Localization.MENU_VIEW_TREE;

      m_ViewHistory.Text = Localization.MENU_VIEW_HISTORY;

      m_view.MenuItems.AddRange(new MenuItem[]{m_ViewStatusBar, 
        m_ViewInformation, m_ViewTree, div.CloneMenu(), m_ViewHistory});

      m_help.Text = Localization.MENU_HELP;

      m_HelpAbout.Text = Localization.MENU_HELP_ABOUT;

      m_help.MenuItems.AddRange(new MenuItem[]{m_HelpAbout});

      m_menu = new MainMenu (new MenuItem[]{m_file, m_view, m_help});;
      }

    /** Return the menu to attach to the form. */
    public MainMenu MainMenu
      {get {return m_menu;}}

    public MenuItem  FileAttachToProcess
      {get {return m_FileAttachToProcess;}}

    public MenuItem  FileCreateProcess
      {get {return m_FileCreateProcess;}}

    public MenuItem  FileClose
      {get {return m_FileClose;}}

    public MenuItem  ViewStatusBar
      {get {return m_ViewStatusBar;}}

    public MenuItem  ViewInformation
      {get {return m_ViewInformation;}}

    public MenuItem  ViewTree
      {get {return m_ViewTree;}}

    public MenuItem  ViewHistory
      {get {return m_ViewHistory;}}

    public MenuItem  HelpAbout
      {get {return m_HelpAbout;}}

    } /* class Dependency Menu */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\resizeableform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Helper class to create a basic "sizeable form" -- the lower-right
// corner has the "Gripper" widget, no minimize/maximize boxes, and
// it isn't shown in the task bar.
//
// In short, it's good for Dialog boxes, but not much else.
//

namespace AdProfiler
  {
  using System;
  using System.Collections;
  using System.Drawing;
  using System.Diagnostics;
  using System.Windows.Forms;
  using AdProfiler;

  // Basics for a dialog box which has the following properties:
  //  - no minimize button
  //  - no maximize button
  //  - Gripper bar in lower-right corner
  //  - not displayed in task bar
  //  - basic size of 300x225 px.
  internal class ResizeableForm : Form
    {
    // Layout the dialog box.
    public ResizeableForm (string titleText)
      {
      Text = titleText;
      // BorderStyle = FormBorderStyle.FixedDialog;
      MaximizeBox = false;
      MinimizeBox = false;
      ControlBox = false;
      ShowInTaskbar = false;
      SizeGripStyle = SizeGripStyle.Show;
      Size = new Size (300, 225);
      }
    } /* class ResizeableForm */
  } /* namespace AdProfiler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\infopanels.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The Assembly information panels displayed in the GUI application.
//

namespace AdProfiler
  {
  using System;
  using System.Collections;     // IDictionary, ...
  using System.Drawing;         // Size, ...
  using System.Windows.Forms;        // Everything.
  using System.Reflection;      // AssemblyName
  using System.Text;            // StringBuilder
  using AdProfiler;
  using Debugging;
  using Windows.FormsUtils;

  // Exposed by "information panels" that display the information contained 
  // in an DisplayableNode object.
  internal interface IDebuggeeInformationPanel
    {
    void Display (DisplayableNode tn);
    }


  // Information panel which displays information about the Process being
  // debugged.
  internal class ProcessInformationPanel 
    : InformationPanel, IDebuggeeInformationPanel
    {
    private static string _id (object o)
      {return ((ProcessNode)o).Process.Id.ToString();}
    private static string _handle(object o)
      {return ((ProcessNode)o).Process.Handle.ToString();}

    private static readonly NameValueInfo[] s_values = 
      {
      new NameValueInfo ("ID:", new UpdateProperty (_id)),
      new NameValueInfo ("Handle:", new UpdateProperty (_handle)),
      };

    private static readonly string[] s_module_headers = {"Name"};

    private ListView m_appdomains;
    private ListView m_objects;

    // Layout the panel information...
    public ProcessInformationPanel ()
      {
      m_appdomains = CreateListView (s_module_headers);
      m_objects = CreateListView (s_module_headers);

      TabControl tabs = CreateTabControl ();

      TabPage info = CreateTabPage ("Information");
      info.Controls.Add (CreateNameValuePanel(s_values));
      tabs.TabPages.Add (info);

      TabPage tp = CreateTabPage ("AppDomains");
      tp.Controls.Add (
        CreateLabelWithListView (
          "All of the AppDomains currently loaded within the process.",
          m_appdomains));
      tabs.TabPages.Add (tp);

      tp = CreateTabPage ("Objects");
      tp.Controls.Add (
        CreateLabelWithListView (
          "All of the Objects currently loaded within the process.",
          m_objects));
      tabs.TabPages.Add (tp);

      Controls.Add (tabs);
      }

    // Update the display with information retrieved from ``dn''.
    public void Display (DisplayableNode dn)
      {
      if (!(dn is ProcessNode))
        throw new Exception ("internal error: expected ProcessNode");
      ProcessNode pn = (ProcessNode) dn;

      try
        {
        // process needs to be synchronized in order to view modules
        pn.Process.Stop (5000);
        foreach (NameValueInfo nv in s_values)
          {
          nv.Value.Text = nv.Update (dn);

          // make text left-aligned in the textbox.
          if (nv.Value is TextBoxBase)
            ((TextBoxBase)nv.Value).SelectionLength = 0;
          }

        _update_appdomains (pn.Process);
        _update_objects (pn.Process);

        pn.Process.Continue (false);
        }
      catch
        {
        if (!pn.Process.IsRunning())
          pn.Process.Continue(false);
        }
      }

    // Update the list of AppDomains located within a process.
    private void _update_appdomains (DebuggedProcess dp)
      {
      m_appdomains.Items.Clear ();
      try
        {
        foreach (DebuggedAppDomain da in dp.AppDomains)
          {
          m_appdomains.Items.Add (new ListViewItem (da.Name));
          }
        }
      catch (Exception e)
        {
        m_appdomains.Items.Add (
          new ListViewItem ("error viewing appdomain: " + e.Message));
        throw e;
        }

      m_appdomains.Columns[0].Width = m_appdomains.ClientSize.Width;
      }

    // Update the list of Objects located within a process.
    private void _update_objects (DebuggedProcess dp)
      {
      m_objects.Items.Clear ();
      try
        {
        foreach (object o in dp.Objects)
          {
          m_objects.Items.Add ("breakpoint information..." + 
            o.ToString());
          }
        dp.Continue (false);
        }
      catch (Exception e)
        {
        m_objects.Items.Add (
          new ListViewItem ("error viewing object: " + e.Message));
        throw e;
        }

      m_objects.Columns[0].Width = m_objects.ClientSize.Width;
      }
    } /* class ProcessInformationPanel */


  // Information panel which displays information about the AppDomain being
  // debugged.
  internal class AppDomainInformationPanel 
    : InformationPanel, IDebuggeeInformationPanel
    {
    private static string _name (object o)
      {return ((AppDomainNode)o).AppDomain.Name;}
    private static string _id (object o)
      {return ((AppDomainNode)o).AppDomain.Id.ToString();}
    private static string _attached (object o)
      {return ((AppDomainNode)o).AppDomain.IsAttached().ToString();}
    private static string _process (object o)
      {return ((AppDomainNode)o).AppDomain.Process.Id.ToString();}

    private static readonly NameValueInfo[] s_values = 
      {
      new NameValueInfo ("Name:", new UpdateProperty(_name)),
      new NameValueInfo ("ID:", new UpdateProperty (_id)),
      new NameValueInfo ("Is Attached:", new UpdateProperty (_attached)),
      new NameValueInfo ("Process:", new UpdateProperty (_process))
      };

    private static readonly string[] s_module_headers = {"Name"};

    private ListView m_assemblies;
    private ListView m_breakpoints;
    private ListView m_steppers;

    // Layout the Panel...
    public AppDomainInformationPanel ()
      {
      m_assemblies = CreateListView (s_module_headers);
      m_breakpoints = CreateListView (s_module_headers);
      m_steppers = CreateListView (s_module_headers);

      TabControl tabs = CreateTabControl ();

      TabPage info = CreateTabPage ("Information");
      info.Controls.Add (CreateNameValuePanel(s_values));
      tabs.TabPages.Add (info);
      TabPage tp = CreateTabPage ("Assemblies");
      tp.Controls.Add (
        CreateLabelWithListView (
          "All of the Assemblies currently loaded within the AppDomain.",
          m_assemblies));
      tabs.TabPages.Add (tp);

      tp = CreateTabPage ("Breakpoints");
      tp.Controls.Add (
        CreateLabelWithListView (
          "All of the Breakpoints currently loaded within the AppDomain.",
          m_breakpoints));
      tabs.TabPages.Add (tp);

      tp = CreateTabPage ("Steppers");
      tp.Controls.Add (
        CreateLabelWithListView (
          "All of Steppers Breakpoints currently loaded within the AppDomain.",
          m_steppers));
      tabs.TabPages.Add (tp);

      Controls.Add (tabs);
      }

    // Update the display with information retrieved from ``dn''.
    public void Display (DisplayableNode dn)
      {
      if (!(dn is AppDomainNode))
        throw new Exception ("internal error: expected AppDomainNode");
      AppDomainNode an = (AppDomainNode) dn;

      try
        {
        // process needs to be synchronized in order to view modules
        an.AppDomain.Stop (5000);

        foreach (NameValueInfo nv in s_values)
          {
          nv.Value.Text = nv.Update (an);

          // make text left-aligned in the textbox.
          if (nv.Value is TextBoxBase)
            ((TextBoxBase)nv.Value).SelectionLength = 0;
          }

        _update_assemblies (an.AppDomain);
        _update_breakpoints (an.AppDomain);
        _update_steppers (an.AppDomain);

        an.AppDomain.Continue (false);
        }
      catch
        {
        if (!an.AppDomain.IsRunning())
          an.AppDomain.Continue(false);
        }

      }

    // Update the list of Assemblies located within a process.
    private void _update_assemblies (DebuggedAppDomain dad)
      {
      m_assemblies.Items.Clear ();
      try
        {
        foreach (DebuggedAssembly da in dad.Assemblies)
          {
          m_assemblies.Items.Add (new ListViewItem (da.Name));
          }
        }
      catch (Exception e)
        {
        m_assemblies.Items.Add (
          new ListViewItem ("error viewing assembly: " + e.Message));
        throw e;
        }

      m_assemblies.Columns[0].Width = m_assemblies.ClientSize.Width;
      }

    // Update the list of Breakpoints located within a process.
    private void _update_breakpoints (DebuggedAppDomain dad)
      {
      m_breakpoints.Items.Clear ();
      try
        {
        foreach (Breakpoint br in dad.Breakpoints)
          {
          m_breakpoints.Items.Add ("breakpoint information..." + 
            br.ToString());
          }
        }
      catch (Exception e)
        {
        m_breakpoints.Items.Add (
          new ListViewItem ("error viewing breakpoint: " + e.Message));
        throw e;
        }

      m_breakpoints.Columns[0].Width = m_breakpoints.ClientSize.Width;
      }

    // Update the list of Steppers located within a process.
    private void _update_steppers (DebuggedAppDomain dad)
      {
      m_steppers.Items.Clear ();
      try
        {
        foreach (Stepper s in dad.Steppers)
          {
          m_steppers.Items.Add (new ListViewItem ("stepper information..."
              + s.ToString()));
          }
        }
      catch
        {
        m_steppers.Items.Add (new ListViewItem ("error viewing stepper"));
        }

      m_steppers.Columns[0].Width = m_steppers.ClientSize.Width;
      }
    } /* class AppDomainInformationPanel */


  // Information panel which displays information about the Assembly being
  // debugged.
  internal class AssemblyInformationPanel 
    : InformationPanel, IDebuggeeInformationPanel
    {
    private static string _name (object o)
      {return ((AssemblyNode)o).Assembly.Name;}
    private static string _code_base (object o)
      {
      try
        {return ((AssemblyNode)o).Assembly.CodeBase;}
      catch (System.Exception e)
        {return "<error: unable to retrieve property: " + e.Message + ">";}
      }
    private static string _process (object o)
      {return ((AssemblyNode)o).Assembly.Process.Id.ToString();}
    private static string _appdomain (object o)
      {return ((AssemblyNode)o).Assembly.AppDomain.Name;}

    private static readonly NameValueInfo[] s_values = 
      {
      new NameValueInfo ("Name:", new UpdateProperty(_name)),
      new NameValueInfo ("Code Base:", new UpdateProperty (_code_base)),
      new NameValueInfo ("Process:", new UpdateProperty (_process)),
      new NameValueInfo ("AppDomain:", new UpdateProperty (_appdomain))
      };

    private static readonly string[] s_module_headers = {"Name"};

    private ListView  m_modules;

    // Layout the form to display...
    public AssemblyInformationPanel ()
      {
      m_modules = CreateListView (s_module_headers);

      TabControl tabs = CreateTabControl ();

      TabPage info = CreateTabPage ("Information");
      info.Controls.Add (CreateNameValuePanel(s_values));
      tabs.TabPages.Add (info);
      TabPage modules = CreateTabPage ("Modules");
      modules.Controls.Add (
        CreateLabelWithListView (
          "All of the Modules currently loaded within the Assembly.",
          m_modules));
      tabs.TabPages.Add (modules);
      Controls.Add (tabs);
      }

    // Update the display with information retrieved from ``dn''.
    public void Display (DisplayableNode dn)
      {
      if (!(dn is AssemblyNode))
        throw new Exception ("internal error: expected AssemblyNode");
      AssemblyNode an = (AssemblyNode) dn;

      m_modules.Items.Clear ();

      try
        {
        an.Assembly.AppDomain.Stop (5000);

        foreach (NameValueInfo nv in s_values)
          {
          nv.Value.Text = nv.Update (an);

          // make text left-aligned in the textbox.
          if (nv.Value is TextBoxBase)
            ((TextBoxBase)nv.Value).SelectionLength = 0;
          }

        foreach (DebuggedModule dm in an.Assembly.Modules)
          {
          m_modules.Items.Add (new ListViewItem (dm.Name));
          }

        an.Assembly.AppDomain.Continue (false);
        }
      catch
        {
        m_modules.Items.Add (new ListViewItem ("error viewing module"));
        if (!an.Assembly.AppDomain.IsRunning())
          an.Assembly.AppDomain.Continue(false);
        }

      m_modules.Columns[0].Width = m_modules.ClientSize.Width;
      }
    } /* class AssemblyInformationPanel */
  } /* namespace AdProfiler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\selectprocess.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Display a dialog box that allows the user to select the process
// containing the appdomains/assemblies they want to view.
//

namespace AdProfiler
  {
  using System;
  using System.Collections;
  using System.Drawing;
  using System.Diagnostics;
  using System.Windows.Forms;
  using AdProfiler;
  using Windows.FormsUtils;

  // Display a dialog box that allows the user to type in the
  // name of a manifest to load.
  internal class SelectProcessDialog : ResizeableForm
    {
    // Helper class which:
    //    - associates a Process with a ListItem,
    //    - Sets the process name as the default text
    //    - adds subitems for the process id and the main window title.
    private class ProcessItem : ListViewItem
      {
      private Process m_p;

          public ProcessItem (Process p) : base (p.ProcessName) {
              m_p = p;
              this.SubItems[0].Text = m_p.Id.ToString();
              this.SubItems[1].Text = m_p.MainWindowTitle;
          }

      public Process Process
        {get {return m_p;}}
      }

    Button m_ok = new Button ();
    Button m_cancel = new Button ();
    ListView  m_list = new ListView ();

    // Layout the dialog box.
    public SelectProcessDialog ()
      : base (Localization.SELECT_PROCESS_WINDOW_TITLE)
      {
			_layout ();

      foreach (Process proc in Process.GetProcesses())
        {
            m_list.Items.Add (new ProcessItem (proc));
        }

      AcceptButton = m_ok;
      CancelButton = m_cancel;
      StartPosition = FormStartPosition.CenterParent;
      }

		// Layout the controls on the form.
		private void _layout ()
			{
      Size = new Size (450, 300);

      const int div = 10;

      m_ok.Text = Localization.BUTTON_OK;
      m_ok.Enabled = false;
      m_ok.Top = div;
      m_ok.Left = ClientSize.Width - m_ok.Width - div;
      m_ok.Anchor = AnchorStyles.Top | AnchorStyles.Right;
      m_ok.Click += new EventHandler (_on_ok_clicked);

      Controls.Add (m_ok);

      m_cancel.Text = Localization.BUTTON_CANCEL;
      m_cancel.Top = m_ok.Bottom + div;
      m_cancel.Left = m_ok.Left;
      m_cancel.Anchor = AnchorStyles.Top | AnchorStyles.Right;
      m_cancel.Click += new EventHandler (_on_cancel_clicked);

      Controls.Add (m_cancel);

      m_list.Top = div;
      m_list.Left = div;
      m_list.Width = m_ok.Left - div - m_list.Left;
      m_list.Height = ClientSize.Height - div - div;
      m_list.Anchor = AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom;
      m_list.AllowColumnReorder = true;
      m_list.FullRowSelect = true;
      m_list.MultiSelect = true;
      m_list.Click += new EventHandler (_on_selection_changed);
      m_list.ItemActivate += new EventHandler(_on_ok_clicked);

      Controls.Add (m_list);

      Graphics g = CreateGraphics ();

      ColumnHeader p = new ColumnHeader ();
      p.Text = Localization.COLUMN_PROCESS;
      p.Width = m_list.ClientSize.Width / 4;
      m_list.Columns.Add (p);
      ColumnHeader pid = new ColumnHeader ();
      pid.Text = Localization.COLUMN_PID;
      pid.Width = (int)(g.MeasureString (pid.Text, Font).Width + 0.5) + div;
      pid.TextAlign = HorizontalAlignment.Right;
      m_list.Columns.Add (pid);
      ColumnHeader title = new ColumnHeader ();
      title.Text = Localization.COLUMN_TITLE;
      title.Width = m_list.ClientSize.Width - p.Width - pid.Width - 2*div;
      m_list.Columns.Add (title);

      m_list.ColumnClick += new ColumnClickEventHandler (_on_lv_column_click);
      m_list.View = View.Details;
			}

    // Only enable [OK] if a process is selected.
    private void _on_selection_changed (object s, EventArgs e)
      {
      if (m_list.SelectedItems.Count > 0)
        m_ok.Enabled = true;
      else
        m_ok.Enabled = false;
      }

    // Sort the selected column...
    private void _on_lv_column_click (object sender, ColumnClickEventArgs e)
      {
      ListView lv = sender as ListView;

      /* 
       * this "shouldn't happen", as this class is the only one with
       * access to this method, and we shouldn't add this handler to
       * an object that isn't a ListView.
       */
      Debug.Assert (lv != null, "Need a ListView for sorting!");

      switch (lv.Sorting)
        {
        case SortOrder.Ascending:
          lv.Sorting = SortOrder.Descending;
          break;
        case SortOrder.Descending:
          goto case SortOrder.None;
        case SortOrder.None:
          lv.Sorting = SortOrder.Ascending;
          break;
        }
      }

    // Closes the dialog box, specifying that the dialog completed
    // succesfully.
    private void _on_ok_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.OK;
      }

    // Closes the dialog box, specifying that the dialog was cancelled.
    private void _on_cancel_clicked (Object sender, EventArgs e)
      {
      Close ();
      DialogResult = DialogResult.Cancel;
      }

    // If "OK" was pressed, the name of the entered text.
    public Process[] Processes
      {
      get 
        {
        Process[] p = new Process[m_list.SelectedItems.Count];
        for (int i = 0; i < p.Length; i++)
          {
          p[i] = ((ProcessItem)m_list.SelectedItems[i]).Process;
          }
        return p;
        }
      }

    // For testing dialog layout, functionality.
    //
    // Compile with:
    //    csc /r:System.Windows.Forms.Dll /r:System.Dll /r:System.Drawing.Dll  \
    //      /r:System.Diagnostics.Dll /r:Microsoft.Win32.Interop.Dll \
    //      selectprocess.cs Localization.cs wfutils.cs
    public static void Main ()
      {
      SelectProcessDialog spd = new SelectProcessDialog ();

      Console.WriteLine ("Select some processes.");

      if (spd.ShowDialog() == DialogResult.OK)
        {
        Console.WriteLine ("Selected Processes:");
        _processes (spd.Processes);
        }
      else
        Console.WriteLine ("Action Cancelled.");
      }

		// Display all processes in the enumerator ``e''.
    private static void _processes (IEnumerable e)
      {
      foreach (Process p in e)
        {
        Console.WriteLine ("  {0}, {1}, {2}", p.ProcessName, p.Id, 
          p.MainWindowTitle);
        }
      }
    } /* class SelectProcessDialog */
  } /* namespace AdProfiler */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "AdProfiler.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft CLR AppDomain Profiler Utility\0"
#define VER_ORIGFILENAME_STR    "AdProfiler.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\localization.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Centralized String repository, for localization.
//

namespace AdProfiler
  {
  using Shortcut = System.Windows.Forms.Shortcut;

  // Contains the strings that might need to be localized in the program.
  internal class Localization
    {

    //
    // Common Strings
    //

    internal static readonly string VERSION = "0.4";
    internal static readonly string LAST_UPDATE = "August 8 2000";

    // Text prefixed before an Assembly name in the output.
    internal static readonly string ASSEMBLY = "Assembly: ";

    // The program arguments that can be used to access the help message.
    internal static readonly string[] HELP_ARGUMENTS = 
      {"/?", "-?", "/h", "-h", "/help", "-help", "--help"};

    //
    // GUI Strings
    //

    /** The text to display in the title bars of the GUI app. */
    internal static readonly string GUI_WINDOW_TITLE = 
      "AppDomain Profiler";

    internal static readonly string OPEN_WINDOW_TITLE = "Open";

    internal static readonly string SELECT_PROCESS_WINDOW_TITLE = 
      "Attach To Process";

    internal static readonly string CREATE_PROCESS_WINDOW_TITLE = 
      "Create New Process";

    internal static readonly string HISTORY_WINDOW_TITLE = 
      "Event History";

    internal static readonly string BUTTON_OK = "OK";

    internal static readonly string BUTTON_CANCEL = "Cancel";

    internal static readonly string UNKNOWN_PROCESS = "Unknown Process";

    // The introductory text to display in the Info pane of
    // the GUI app when no Assembly has been loaded.
    internal static readonly string GUI_INTRO_TEXT = 
      "Do Something.";

    /** End-of-line string for use in multi-line GUI panels */
    internal static readonly string LINE_ENDING = "\r\n";

      //
      // Error Messages
      //

      //
      // Menu Information
      //
    internal static readonly string MENU_FILE = "&File";
    internal static readonly string MENU_FILE_ATTACH = "Attach to Pr&ocess...";
    internal static readonly Shortcut MENU_FILE_ATTACH_SHORTCUT = 
      Shortcut.CtrlO;
    internal static readonly string MENU_FILE_CREATE_PROCESS = 
      "Create &New Process...";
    internal static readonly Shortcut MENU_FILE_CREATE_PROCESS_SHORTCUT = 
      Shortcut.CtrlN;
    internal static readonly string MENU_FILE_CLOSE = "&Close";
    internal static readonly Shortcut MENU_FILE_CLOSE_SHORTCUT = Shortcut.CtrlW;

    internal static readonly string MENU_VIEW = "&View";
    internal static readonly string MENU_VIEW_TREE = "&Tree";
    internal static readonly string MENU_VIEW_INFO = "&Information";
    internal static readonly string MENU_VIEW_SB = "&Status Bar";
    internal static readonly string MENU_VIEW_HISTORY = "&History";

    internal static readonly string MENU_HELP = "&Help";
    internal static readonly string MENU_HELP_ABOUT 
      = "&About AppDomain Profiler";

    // Context Menu: Copy the contents of the selected object to the
    // clipboard.
    internal static readonly string CTXM_COPY = "&Copy";

    // Context Menu: Select the node underneath the mouse.
    internal static readonly string CTXM_SELECT = "&Select";

      //
      // Help->About Information
      //
    internal static readonly string ABOUT_BOX_TITLE = 
      "About AppDomain Profiler";
    internal static readonly string ABOUT_BOX_TEXT =
      "Microsoft (R) AppDomain Profiler" + LINE_ENDING +
      "Version " + VERSION + LINE_ENDING +
      "Copyright (C) 2000 Microsoft Corp." + LINE_ENDING +
      VERSION + " - " + LAST_UPDATE + " By Jonathan Pryor";

      //
      // File->Create New Process information
      //
    internal static readonly string CREATE_PROCESS_EXECUTABLE = 
      "&Executable for Debug Session:";

    internal static readonly string CREATE_PROCESS_ARGUMENTS = 
      "Program Arg&uments:";

    internal static readonly string CREATE_PROCESS_DIRECTORY = 
      "&Working Directory:";

      //
      // File->Create New Process information
      //
    internal static readonly string COLUMN_PROCESS = "Process";

    internal static readonly string COLUMN_PID = "Process ID";

    internal static readonly string COLUMN_TITLE = "Title";

      //
      // View->History information
      //
    internal static readonly string BUTTON_CLOSE = "&Close";

    internal static readonly string BUTTON_CLEAR = "C&lear";

      //
      // Information Panels
      //

        //
        // Strings used for descriptions of AssemblyName fields.
        //
    internal static readonly string INFO_FULL_NAME = "F&ull Name:";
    internal static readonly string INFO_NAME = "&Name:";
    internal static readonly string INFO_VERSION = "V&ersion:";
    internal static readonly string INFO_VERSION_COMPATIBILITY = 
      "Ve&rsion Compatibility:";
    internal static readonly string INFO_CODE_BASE = "Code &Base:";
    internal static readonly string INFO_PROCESSOR = "&Processor:";
    internal static readonly string INFO_CULTURE_INFORMATION = 
      "Culture &Information:";
    internal static readonly string INFO_FLAGS = "Fla&gs:";
    internal static readonly string INFO_HASH_ALGORITHM = "Hash &Algorithm:";
    internal static readonly string INFO_KEY_PAIR = "&Key Pair:";

    /** The Name column displayed by the ListView. */
    internal static readonly string LV_COLUMN_NAME = "Name";
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\adprofiler\wfutils.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Utility code for Windows.Forms Programs.
//

namespace Windows.FormsUtils
  {
  using System;
  using System.Diagnostics; // Debug
  using System.Drawing;     // Graphics
  using System.Collections; // IComparer
  using System.Windows.Forms;    // Everything
  using System.Text;        // StringBuilder
  using AdProfiler;         // Localization
  using System.Globalization; // InvariantCulture


  // The context menu displayed for the ListViews; it just allows
  // the user to copy the name(s) of selected items to the clipboard.
  internal class ListContextMenu : ContextMenu
    {
    private ListView  m_lv;

    // Provide a context menu for the ListView ``lv''.
    public ListContextMenu (ListView lv)
      {
      m_lv = lv;
      MenuItem copy = new MenuItem ();
      copy.Text = Localization.CTXM_COPY;
      copy.Click += new EventHandler (_on_copy_clicked);
      MenuItems.Add (copy);
      }

    // Copy the names of selected items to the clipboard.
    private void _on_copy_clicked (Object sender, EventArgs e)
      {
      StringBuilder sb = new StringBuilder ();
      foreach (ListViewItem li in m_lv.SelectedItems)
        {
        sb.Append (li.Text + Localization.LINE_ENDING);
        }
      if (sb.Length > 0)
        Clipboard.SetDataObject (sb.ToString(), true);
      }
    } /* class ListContextMenu */


  // The context menu that gets displayed when the user right-clicks
  // inside the TreeView.
  //
  // If the TreeView is empty (e.g. when the program is first launched),
  // there shouldn't be a context menu; otherwise, a context menu
  // specific to the node the mouse is over should be displayed.
  //
  // In this case, all nodes get the same context menu; however, it's
  // still necessary to determine which node the cursor is over.
  //
  // In order to do this, we read the MousePosition property of the
  // TreeView in the OnPopup handler.
  internal class TreeContextMenu : ContextMenu
    {
    /** The TreeView we're interacting with. */
    TreeView m_tv;

    /** The current context menu to display. */
    MenuItem[] m_items;

    /** The mouse position when the dialog box is displayed. */
    Point m_pt;

    // Create a ContextMenu for the TreeView ``tv''.
    public TreeContextMenu (TreeView tv)
      {
      m_tv = tv;

      MenuItem select = new MenuItem ();
      select.Text = Localization.CTXM_SELECT;
      select.Click += new EventHandler (_on_select_clicked);

      MenuItem copy = new MenuItem ();
      copy.Text = Localization.CTXM_COPY;
      copy.Click += new EventHandler (_on_copy_clicked);

      m_items = new MenuItem[]{select, copy};
      }

    // Store the position the mouse is in when the mouse is clicked.
    // This position is needed for the Selet & Click handlers, otherwise
    // the wrong node is selected (as the mouse will be in a different
    // position).
    private void _store_mouse_position ()
      {
      m_pt = m_tv.PointToClient (Control.MousePosition);
      }

    // Returns the node underneath the current mouse position.
    private TreeNode _get_node ()
      {return m_tv.GetNodeAt (m_pt);}

    // Modify the menu items to be displayed.
    //
    // If no TreeNode is under the cursor, no menu should be displayed.
    protected override void OnPopup (EventArgs e)
      {
      _store_mouse_position ();
      TreeNode over = _get_node ();
      if (over == null)
        MenuItems.Clear ();
      else
        {
        // only add items if they're not already present.
        if (MenuItems.Count == 0)
          MenuItems.AddRange(m_items);
        }
      }

    // Make the node under the cursor the "Selected Node" of the TreeView.
    private void _on_select_clicked (Object sender, EventArgs e)
      {m_tv.SelectedNode = _get_node ();}

    // Copy the text of the current node to the Windows Clipboard.
    private void _on_copy_clicked (Object sender, EventArgs e)
      {Clipboard.SetDataObject (_get_node().Text, true);}

    } /* class TreeContextMenu */


  // Compares the items in a column of a ListView; used to sort them
  // with System.Array.Sort.
  internal class ListItemComparer : IComparer
    {
    /** the column to sort */
    private int m_column;

    /** sort A..Z (true) or Z..A (false) ?*/
    private bool m_dir;

    // Create the comparison helper.
    //
    public ListItemComparer (int column, bool dir)
      {m_column = column;
      m_dir = dir;}

    // Compare the objects ``x'' and ``y''.
    //
    // If ``x'' and ``y'' aren't ListItems, an exception will be thrown.
    public int Compare (Object x, Object y)
      {
      ListViewItem lix = (ListViewItem) x;
      ListViewItem liy = (ListViewItem) y;

      String sx;
      String sy;

      // Column 0 corresponds to the label of the items.
      // other columns are subitems.
      if (m_column == 0)
        {
        sx = lix.Text;
        sy = liy.Text;
        }
      else
        {
        sx = lix.SubItems[m_column-1].Text;
        sy = liy.SubItems[m_column-1].Text;
        }

      if (m_dir)
        return string.Compare(sx, sy, false, CultureInfo.InvariantCulture);
      return string.Compare(sy, sx, false, CultureInfo.InvariantCulture);
      }
    } /* class ListItemComparer */


  // Helper class which provides creation services for derived classes
  internal class InformationPanel : Panel
    {
    // This is intended to be invoked by derived classes in order to update
    // the name/value pairs in some of their information panels.
    //
    protected delegate string UpdateProperty (Object o);

    // The output will consist of the following format:
    //
    //    [Property name (Label)] [Property value (TextBox)]
    //
    // This class just makes it easier to deal with displaying each
    // "line" of the displayed window.
    //
    // The ``Update'' member is used to update ``Value'', when appropriate.
    protected class NameValueInfo
      {
      public Label Name;
      public Control Value;
      public UpdateProperty Update;

      public NameValueInfo (Label l, TextBox v, UpdateProperty u)
        {Name = l; Value = v; Update = u;}

      public NameValueInfo ()
        {Name = null; Value = null; Update = null;}

      public NameValueInfo (String s, UpdateProperty u)
        {Name = new Label (s); Value = new TextBox (); Update = u;}
      } /* class NameValueInfo */

    // A helper class to turn creation of a Label from 2 statements
    // into one statement.  (Yes, I'm that lazy a typer.)
    protected class Label : System.Windows.Forms.Label
      {
      public Label (String s)
        {
        Text = s;
        }
      }

    /** Used to determine how long a string will be on the current display. */
    private Graphics m_g;

    public InformationPanel ()
      {
      m_g = CreateGraphics ();
      }

    protected Graphics GetGraphics ()
      {return m_g;}


    // Insert the Name/Value pairs into the form in the order that they're
    // present in the array.
    //
    // Each NameValueInfo will be vertically aligned.
    protected Panel CreateNameValuePanel (NameValueInfo[] values)
      {
      SizeF maxf = new SizeF(0, 0);

      Panel p = new Panel ();
      p.AutoScroll = true;
      p.Dock = DockStyle.Fill;

      // Create the labels for each property, and record the maximum width of
      // the name.
      foreach (NameValueInfo nv in values)
        {
        SizeF cs = m_g.MeasureString (nv.Name.Text, Font);
        nv.Name.AutoSize = true;

        if (cs.Width > maxf.Width)
          maxf.Width = cs.Width;
        if (cs.Height > maxf.Height)
          maxf.Height = cs.Height;
        if (nv.Value is TextBoxBase)
          ((TextBoxBase)nv.Value).ReadOnly = true;
        }

      int tbh = _textbox_height ();

      // max height of a "row" in the property page
      int maxh = Math.Max (tbh,  ((int)(maxf.Height+0.5)));

      // max dimension for a property label
      Size max = new Size ((int)(maxf.Width + 0.5), maxh);

      // location of upper-left corner of a property label.
      Point loc = new Point (0, 5);

      // the # of pixels that separate "lines" of output.
      const int div = 2;

      // name width
      int nw = max.Width;

      // value width
      int vw = p.ClientSize.Width - nw - div;

      /* 
       * Resize each control, and place into position on the panel.
       */
      foreach (NameValueInfo nv in values)
        {
        nv.Name.Location = new Point (nw - nv.Name.Width, loc.Y);

        nv.Value.Location = new Point (nw + div, loc.Y);
        nv.Value.Height = max.Height;
        nv.Value.Width = vw;
        nv.Value.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;

        _center_label (nv.Name, maxh);

        p.Controls.Add (nv.Name);
        p.Controls.Add (nv.Value);

        loc.Y += max.Height + div;
        }
      return p;
      }

    // Create a TabControl, with its dock style set to Fill.
    protected TabControl CreateTabControl ()
      {
      TabControl tabs = new TabControl ();
      tabs.Dock = DockStyle.Fill;
      return tabs;
      }

    // Creates a TabPage, setting common options.
    protected TabPage CreateTabPage (string title)
      {
      TabPage tp = new TabPage (title);
      tp.AutoScroll = true;
      tp.Dock = DockStyle.Fill;
      return tp;
      }

    // Setting the Anchor style and adding a TextBox to a container changes
    // the height of the control.  (I don't know why).  This is the height
    // we want (as it corresponds to the height for a single line of text, 
    // plus the TextBox border).
    //
    // So, we take a TextBox, set its Anchor style, add it to a container,
    // remove the TextBox, and see what its new height is.
    //
    private int _textbox_height ()
      {
      Control c = new TextBox ();
      c.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
      Controls.Add (c);
      int tbh = c.Height;
      Controls.Remove (c);
      return tbh;
      }

    // Vertically center a label within ``maxh'', so that it looks
    // correct next to it's value.
    private void _center_label (Label l, int maxh)
      {
      int top = l.Top;
      // l.AutoSize = true;
      if (maxh > l.Height)
        {
        // text box is taller than label; center the label
        int diff = maxh - l.Height;
        diff = (int)((((float)diff)/2F)+0.5);
        l.Top = top + diff;
        }
      }

    // Create a listview with ``headers'' being all of the column headers
    // that the listview displays.
    //
    // The returned ListView will be:
    //  - set in Report view
    //  - Have a default context menu with "Copy" as a ContextMenu item.
    protected ListView CreateListView (String[] headers)
      {
      ListView lv = new ListView ();
      lv.Dock = DockStyle.Fill;

      foreach (String s in headers)
        {
        ColumnHeader ch = new ColumnHeader ();
        ch.Text = s;
        lv.Columns.Add (ch);
        }

      lv.View = View.Details;
      lv.AllowColumnReorder = true;
      lv.FullRowSelect = true;
      lv.MultiSelect = true;
      lv.ContextMenu = new ListContextMenu (lv);
      lv.ColumnClick += new ColumnClickEventHandler (_on_lv_column_click);

      return lv;
      }

    // Creates a Panel with the following layout:
    //  
    //  +-------------------------+
    //  | Label                   |
    //  +-------------------------+
    //  | +---------------------+ |
    //  | | ListView            | |
    //  | |                     | |
    //  | +---------------------+ |
    //  +-------------------------+
    //
    // The label will be resized to be as large as is necessary to display
    // the text, and the ListView will be flush agains the bottom of the
    // label.
    //
    protected Panel CreateLabelWithListView (String s, ListView lv)
      {
      Panel p = new Panel ();
      p.Dock = DockStyle.Fill;

      SizeF cs = m_g.MeasureString (s, Font);

      const int div = 5;

      Label l = new Label (s);
      l.Size = new Size ( (int)(cs.Width+0.5), (int)(cs.Height + 0.5));
      l.Location = new Point (0, div);
      p.Controls.Add (l);

      Panel plv = new Panel ();
      plv.Top = l.Bottom + div;
      plv.Left = 0;
      plv.Width = p.ClientSize.Width;
      plv.Height = p.ClientSize.Height - plv.Top;
      plv.Controls.Add (lv);
      plv.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;

      p.Controls.Add (plv);

      return p;
      }

    // Invoked when the user clicks a column header of a ListView.
    //
    // Sort the contents of the selected column.
    private void _on_lv_column_click (object sender, ColumnClickEventArgs e)
      {
      ListView lv = sender as ListView;

      /* 
       * this "shouldn't happen", as this class is the only one with
       * access to this method, and we shouldn't add this handler to
       * an object that isn't a ListView.
       */
      Debug.Assert (lv != null, "Need a ListView for sorting!");

      switch (lv.Sorting)
        {
        case SortOrder.Ascending:
          lv.Sorting = SortOrder.Descending;
          break;
        case SortOrder.Descending:
          goto case SortOrder.None;
        case SortOrder.None:
          lv.Sorting = SortOrder.Ascending;
          break;
        }
      }
    } /* class InformationPanel */
  } /* namespace Windows.FormsUtils */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\edge.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace AllocationProfiler
{
    using System;
	using System.Drawing;

    /// <summary>
    ///    Summary description for Edge.
    /// </summary>
    public class Edge : IComparable
    {
		Vertex fromVertex;
		Vertex toVertex;
		internal bool selected;
		internal Brush brush;
		internal Pen pen;
		internal Vertex ToVertex 
		{
			get
			{
				return toVertex;
			}
		}
		internal Vertex FromVertex 
		{
			get
			{
				return fromVertex;
			}
			set
			{
				fromVertex = value;
			}
		}
		internal int weight;
		internal int width;
		internal Point fromPoint, toPoint;
		public int CompareTo(Object o)
		{
			Edge e = (Edge)o;
			return e.weight - this.weight;
		}
        public Edge(Vertex fromVertex, Vertex toVertex)
        {
			this.fromVertex = fromVertex;
			this.toVertex = toVertex;
			this.weight = 0;
        }

		public void AddWeight(int weight)
		{
			this.weight += weight;
			this.fromVertex.outgoingWeight += weight;
			this.toVertex.incomingWeight += weight;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\form2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for Form2.
	/// </summary>
	public class Form2 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ProgressBar progressBar;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form2()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			progressBar.Minimum = 0;
			progressBar.Maximum = 100;
		}

		public void setProgress(int value)
		{
			progressBar.Value = value;
		}

		public void setMaximum(int value)
		{
			progressBar.Maximum = value;
		}
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if(components != null)	
                    components.Dispose();
            }
            base.Dispose(disposing);
        }

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.progressBar = new System.Windows.Forms.ProgressBar();
			this.SuspendLayout();
			// 
			// progressBar
			// 
			this.progressBar.Location = new System.Drawing.Point(16, 16);
			this.progressBar.Name = "progressBar";
			this.progressBar.Size = new System.Drawing.Size(560, 16);
			this.progressBar.TabIndex = 0;
			// 
			// Form2
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(592, 53);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {this.progressBar});
			this.Name = "Form2";
			this.Text = "Progress";
			this.TopMost = true;
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\filterform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Globalization;

namespace AllocationProfiler
{
	internal enum InterestLevel
	{
		Ignore              = 0,
		Display             = 1<<0,
		Interesting         = 1<<1,
		Parents             = 1<<2,
		Children            = 1<<3,
		InterestingParents  = Interesting | Parents,
		InterestingChildren = Interesting | Children,
		ParentsChildren     = Parents | Children,
	}

	/// <summary>
	/// Summary description for FilterForm.
	/// </summary>
	public class FilterForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.Button cancelButton;
		private System.Windows.Forms.Label label1;
		internal System.Windows.Forms.TextBox typeFilterTextBox;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.CheckBox parentsCheckBox;
		private System.Windows.Forms.CheckBox childrenCheckBox;
		private System.Windows.Forms.CheckBox caseInsensitiveCheckBox;
		internal System.Windows.Forms.TextBox methodFilterTextBox;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		internal static string typeFilter = "";
		private static string[] typeFilters = new string[0];
		internal static string methodFilter = "";
		private static string[] methodFilters = new string[0];
		private static bool showChildren = true;
		private static bool showParents = true;
		private static bool caseInsensitive = true;
		internal static int filterVersion = 0;

		internal static InterestLevel InterestLevelOfName(string name, string[] typeFilters)
		{
			if (name == "<root>" || typeFilters.Length == 0)
				return InterestLevel.Interesting;
			string bestFilter = "";
			InterestLevel bestLevel = InterestLevel.Ignore;
			foreach (string filter in typeFilters)
			{
				InterestLevel level = InterestLevel.Interesting;
				string realFilter = filter.Trim();
				if (realFilter.Length > 0 && (realFilter[0] == '~' || realFilter[0] == '!'))
				{
					level = InterestLevel.Ignore;
					realFilter = realFilter.Substring(1).Trim();
				}
				if (showParents)
					level |= InterestLevel.Parents;
				if (showChildren)
					level |= InterestLevel.Children;

				// Check if the filter is a prefix of the name
				if (string.Compare(name, 0, realFilter, 0, realFilter.Length, caseInsensitive, CultureInfo.InvariantCulture) == 0)
				{
					// This filter matches the type name
					// Let's see if it's the most specific (i.e. LONGEST) one so far.
					if (realFilter.Length > bestFilter.Length)
					{
						bestFilter = realFilter;
						bestLevel = level;
					}
				}
			}
			return bestLevel;
		}

		internal static InterestLevel InterestLevelOfTypeName(string typeName)
		{
			return InterestLevelOfName(typeName, typeFilters);
		}

		internal static InterestLevel InterestLevelOfMethodName(string methodName)
		{
			return InterestLevelOfName(methodName, methodFilters);
		}

		public FilterForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			typeFilterTextBox.Text = typeFilter;
			methodFilterTextBox.Text = methodFilter;
			parentsCheckBox.Checked = showParents;
			childrenCheckBox.Checked = showChildren;
			caseInsensitiveCheckBox.Checked = caseInsensitive;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.okButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.typeFilterTextBox = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.methodFilterTextBox = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.parentsCheckBox = new System.Windows.Forms.CheckBox();
			this.childrenCheckBox = new System.Windows.Forms.CheckBox();
			this.caseInsensitiveCheckBox = new System.Windows.Forms.CheckBox();
			this.SuspendLayout();
			// 
			// okButton
			// 
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(488, 24);
			this.okButton.Name = "okButton";
			this.okButton.TabIndex = 0;
			this.okButton.Text = "OK";
			this.okButton.Click += new System.EventHandler(this.okButton_Click);
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(488, 72);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.TabIndex = 1;
			this.cancelButton.Text = "Cancel";
			// 
			// typeFilterTextBox
			// 
			this.typeFilterTextBox.Location = new System.Drawing.Point(48, 48);
			this.typeFilterTextBox.Name = "typeFilterTextBox";
			this.typeFilterTextBox.Size = new System.Drawing.Size(392, 20);
			this.typeFilterTextBox.TabIndex = 2;
			this.typeFilterTextBox.Text = "";
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(40, 24);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(368, 23);
			this.label1.TabIndex = 3;
			this.label1.Text = "Show Types starting with (separate multiple entries with \";\"):";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(40, 96);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(328, 16);
			this.label2.TabIndex = 4;
			this.label2.Text = "Show Methods starting with (separate multiple entries with \";\"):";
			// 
			// methodFilterTextBox
			// 
			this.methodFilterTextBox.Location = new System.Drawing.Point(48, 120);
			this.methodFilterTextBox.Name = "methodFilterTextBox";
			this.methodFilterTextBox.Size = new System.Drawing.Size(392, 20);
			this.methodFilterTextBox.TabIndex = 5;
			this.methodFilterTextBox.Text = "";
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(40, 168);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(48, 16);
			this.label3.TabIndex = 6;
			this.label3.Text = "Options:";
			// 
			// parentsCheckBox
			// 
			this.parentsCheckBox.Location = new System.Drawing.Point(104, 168);
			this.parentsCheckBox.Name = "parentsCheckBox";
			this.parentsCheckBox.Size = new System.Drawing.Size(208, 16);
			this.parentsCheckBox.TabIndex = 7;
			this.parentsCheckBox.Text = "Show Callers/Referencing Objects";
			// 
			// childrenCheckBox
			// 
			this.childrenCheckBox.Location = new System.Drawing.Point(104, 200);
			this.childrenCheckBox.Name = "childrenCheckBox";
			this.childrenCheckBox.Size = new System.Drawing.Size(216, 24);
			this.childrenCheckBox.TabIndex = 8;
			this.childrenCheckBox.Text = "Show Callees/Referenced Objects";
			// 
			// caseInsensitiveCheckBox
			// 
			this.caseInsensitiveCheckBox.Location = new System.Drawing.Point(104, 232);
			this.caseInsensitiveCheckBox.Name = "caseInsensitiveCheckBox";
			this.caseInsensitiveCheckBox.Size = new System.Drawing.Size(168, 24);
			this.caseInsensitiveCheckBox.TabIndex = 9;
			this.caseInsensitiveCheckBox.Text = "Ignore Case";
			// 
			// FilterForm
			// 
			this.AcceptButton = this.okButton;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(584, 285);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.caseInsensitiveCheckBox,
																		  this.childrenCheckBox,
																		  this.parentsCheckBox,
																		  this.label3,
																		  this.methodFilterTextBox,
																		  this.label2,
																		  this.label1,
																		  this.typeFilterTextBox,
																		  this.cancelButton,
																		  this.okButton});
			this.Name = "FilterForm";
			this.Text = "Set Filters for Types and Methods";
			this.ResumeLayout(false);

		}
		#endregion

		private void okButton_Click(object sender, System.EventArgs e)
		{
			typeFilter = typeFilterTextBox.Text.Trim();
			if (typeFilter == "")
				typeFilters = new String[0];
			else
				typeFilters = typeFilter.Split(';');
			methodFilter = methodFilterTextBox.Text.Trim();
			if (methodFilter == "")
				methodFilters = new String[0];
			else
				methodFilters = methodFilter.Split(';');
			showParents = parentsCheckBox.Checked;
			showChildren = childrenCheckBox.Checked;
			caseInsensitive = caseInsensitiveCheckBox.Checked;
			filterVersion++;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\form3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for Form3.
	/// </summary>
	public class Form3 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.Button cancelButton;
		internal System.Windows.Forms.TextBox commandLineTextBox;
		internal System.Windows.Forms.TextBox workingDirectoryTextBox;
		private System.Windows.Forms.Label label2;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form3()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if(components != null)	
                    components.Dispose();
            }
            base.Dispose(disposing);
        }

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.commandLineTextBox = new System.Windows.Forms.TextBox();
			this.okButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.workingDirectoryTextBox = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(24, 24);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(144, 16);
			this.label1.TabIndex = 0;
			this.label1.Text = "Enter Command Line:";
			// 
			// commandLineTextBox
			// 
			this.commandLineTextBox.Location = new System.Drawing.Point(24, 48);
			this.commandLineTextBox.Name = "commandLineTextBox";
			this.commandLineTextBox.Size = new System.Drawing.Size(424, 20);
			this.commandLineTextBox.TabIndex = 1;
			this.commandLineTextBox.Text = "";
			// 
			// okButton
			// 
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(488, 24);
			this.okButton.Name = "okButton";
			this.okButton.TabIndex = 2;
			this.okButton.Text = "OK";
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(488, 72);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.TabIndex = 3;
			this.cancelButton.Text = "Cancel";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(24, 96);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(136, 16);
			this.label2.TabIndex = 4;
			this.label2.Text = "Enter Working Directory";
			// 
			// workingDirectoryTextBox
			// 
			this.workingDirectoryTextBox.Location = new System.Drawing.Point(24, 120);
			this.workingDirectoryTextBox.Name = "workingDirectoryTextBox";
			this.workingDirectoryTextBox.Size = new System.Drawing.Size(424, 20);
			this.workingDirectoryTextBox.TabIndex = 5;
			this.workingDirectoryTextBox.Text = "";
			// 
			// Form3
			// 
			this.AcceptButton = this.okButton;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(592, 197);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.workingDirectoryTextBox,
																		  this.label2,
																		  this.cancelButton,
																		  this.okButton,
																		  this.commandLineTextBox,
																		  this.label1});
			this.Name = "Form3";
			this.Text = "Command Line and Working Directory";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\form1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Threading;
using System.Runtime.InteropServices;
using System.Globalization;

namespace AllocationProfiler
{

	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MainMenu mainMenu;
		private System.Windows.Forms.MenuItem exitMenuItem;
		private System.ComponentModel.IContainer components;

		private System.Windows.Forms.OpenFileDialog openFileDialog;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.MenuItem fontMenuItem;
		private System.Windows.Forms.MenuItem logFileOpenMenuItem;
		private System.Windows.Forms.MenuItem profileApplicationMenuItem;
		private System.Windows.Forms.Button startApplicationButton;
		private System.Windows.Forms.CheckBox profilingActiveCheckBox;
		private System.Windows.Forms.Button killApplicationButton;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.RadioButton callsRadioButton;
		private System.Windows.Forms.RadioButton allocationsRadioButton;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Timer checkProcessTimer;
		private System.Windows.Forms.MenuItem setCommandLineMenuItem;
		private System.Windows.Forms.FontDialog fontDialog;

		private Graph heapGraph;
		internal Font font;
		private Process profiledProcess;
		private string processFileName;
        private string serviceName;
        private string serviceStartCommand;
        private string serviceStopCommand;
		private string logFileName;
		private long logFileStartOffset;
		private long logFileEndOffset;
		private ReadNewLog log;
		internal ReadLogResult lastLogResult;
		private NamedManualResetEvent loggingActiveEvent;
		private NamedManualResetEvent forceGcEvent;
		private NamedManualResetEvent loggingActiveCompletedEvent;
		private NamedManualResetEvent forceGcCompletedEvent;
		private NamedManualResetEvent callGraphActiveEvent;
		private NamedManualResetEvent callGraphActiveCompletedEvent;
		private System.Windows.Forms.Button showHeapButton;
		private string commandLine = "";
		private string workingDirectory = "";
		private IntPtr pipeHandle;
		private System.Windows.Forms.MenuItem menuItem8;
		private System.Windows.Forms.MenuItem viewTimeLineMenuItem;
		private FileStream pipe;
		private System.Windows.Forms.SaveFileDialog saveFileDialog;
		internal static Form1 instance;
		private System.Windows.Forms.MenuItem saveAsMenuItem;
		private System.Windows.Forms.MenuItem viewHistogramAllocatedMenuItem;
		private System.Windows.Forms.MenuItem viewHistogramRelocatedMenuItem;
		private System.Windows.Forms.MenuItem viewHeapGraphMenuItem;
		private System.Windows.Forms.MenuItem viewCallGraphMenuItem;
		private System.Windows.Forms.MenuItem viewAllocationGraphMenuItem;
		private System.Windows.Forms.MenuItem viewObjectsByAddressMenuItem;
		private System.Windows.Forms.MenuItem viewHistogramByAgeMenuItem;
		private System.Windows.Forms.MenuItem profileASP_NETmenuItem;
        private System.Windows.Forms.MenuItem profileServiceMenuItem;
		private bool saveNever;

		public Form1()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			font = new Font("Arial", 10);

			CreatePipe(true);

			instance = this;

			EnableDisableViewMenuItems();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose(bool disposing) 
		{
			if (disposing) 
			{
				if(components != null)	
					components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.components = new System.ComponentModel.Container();
            this.profilingActiveCheckBox = new System.Windows.Forms.CheckBox();
            this.openFileDialog = new System.Windows.Forms.OpenFileDialog();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.allocationsRadioButton = new System.Windows.Forms.RadioButton();
            this.callsRadioButton = new System.Windows.Forms.RadioButton();
            this.logFileOpenMenuItem = new System.Windows.Forms.MenuItem();
            this.setCommandLineMenuItem = new System.Windows.Forms.MenuItem();
            this.profileApplicationMenuItem = new System.Windows.Forms.MenuItem();
            this.profileASP_NETmenuItem = new System.Windows.Forms.MenuItem();
            this.killApplicationButton = new System.Windows.Forms.Button();
            this.startApplicationButton = new System.Windows.Forms.Button();
            this.checkProcessTimer = new System.Windows.Forms.Timer(this.components);
            this.fontMenuItem = new System.Windows.Forms.MenuItem();
            this.label1 = new System.Windows.Forms.Label();
            this.mainMenu = new System.Windows.Forms.MainMenu();
            this.menuItem1 = new System.Windows.Forms.MenuItem();
            this.saveAsMenuItem = new System.Windows.Forms.MenuItem();
            this.menuItem3 = new System.Windows.Forms.MenuItem();
            this.exitMenuItem = new System.Windows.Forms.MenuItem();
            this.menuItem5 = new System.Windows.Forms.MenuItem();
            this.menuItem8 = new System.Windows.Forms.MenuItem();
            this.viewHistogramAllocatedMenuItem = new System.Windows.Forms.MenuItem();
            this.viewHistogramRelocatedMenuItem = new System.Windows.Forms.MenuItem();
            this.viewObjectsByAddressMenuItem = new System.Windows.Forms.MenuItem();
            this.viewHistogramByAgeMenuItem = new System.Windows.Forms.MenuItem();
            this.viewAllocationGraphMenuItem = new System.Windows.Forms.MenuItem();
            this.viewHeapGraphMenuItem = new System.Windows.Forms.MenuItem();
            this.viewCallGraphMenuItem = new System.Windows.Forms.MenuItem();
            this.viewTimeLineMenuItem = new System.Windows.Forms.MenuItem();
            this.showHeapButton = new System.Windows.Forms.Button();
            this.fontDialog = new System.Windows.Forms.FontDialog();
            this.saveFileDialog = new System.Windows.Forms.SaveFileDialog();
            this.profileServiceMenuItem = new System.Windows.Forms.MenuItem();
            this.groupBox1.SuspendLayout();
            this.SuspendLayout();
            // 
            // profilingActiveCheckBox
            // 
            this.profilingActiveCheckBox.Checked = true;
            this.profilingActiveCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.profilingActiveCheckBox.Location = new System.Drawing.Point(168, 8);
            this.profilingActiveCheckBox.Name = "profilingActiveCheckBox";
            this.profilingActiveCheckBox.TabIndex = 8;
            this.profilingActiveCheckBox.Text = "Profiling active";
            this.profilingActiveCheckBox.CheckedChanged += new System.EventHandler(this.profilingActiveCheckBox_CheckedChanged);
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                    this.allocationsRadioButton,
                                                                                    this.callsRadioButton});
            this.groupBox1.Location = new System.Drawing.Point(584, 0);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(152, 30);
            this.groupBox1.TabIndex = 5;
            this.groupBox1.TabStop = false;
            // 
            // allocationsRadioButton
            // 
            this.allocationsRadioButton.Checked = true;
            this.allocationsRadioButton.Location = new System.Drawing.Point(8, 10);
            this.allocationsRadioButton.Name = "allocationsRadioButton";
            this.allocationsRadioButton.Size = new System.Drawing.Size(80, 16);
            this.allocationsRadioButton.TabIndex = 2;
            this.allocationsRadioButton.TabStop = true;
            this.allocationsRadioButton.Text = "Allocations";
            // 
            // callsRadioButton
            // 
            this.callsRadioButton.Location = new System.Drawing.Point(96, 10);
            this.callsRadioButton.Name = "callsRadioButton";
            this.callsRadioButton.Size = new System.Drawing.Size(48, 16);
            this.callsRadioButton.TabIndex = 1;
            this.callsRadioButton.Text = "Calls";
            // 
            // logFileOpenMenuItem
            // 
            this.logFileOpenMenuItem.Index = 0;
            this.logFileOpenMenuItem.Shortcut = System.Windows.Forms.Shortcut.CtrlO;
            this.logFileOpenMenuItem.Text = "Open Log File...";
            this.logFileOpenMenuItem.Click += new System.EventHandler(this.fileOpenMenuItem_Click);
            // 
            // setCommandLineMenuItem
            // 
            this.setCommandLineMenuItem.Index = 5;
            this.setCommandLineMenuItem.Text = "Set Parameters...";
            this.setCommandLineMenuItem.Click += new System.EventHandler(this.setCommandLineMenuItem_Click);
            // 
            // profileApplicationMenuItem
            // 
            this.profileApplicationMenuItem.Index = 1;
            this.profileApplicationMenuItem.Text = "Profile Application...";
            this.profileApplicationMenuItem.Click += new System.EventHandler(this.profileApplicationMenuItem_Click);
            // 
            // profileASP_NETmenuItem
            // 
            this.profileASP_NETmenuItem.Index = 2;
            this.profileASP_NETmenuItem.Text = "Profile ASP.NET";
            this.profileASP_NETmenuItem.Click += new System.EventHandler(this.profileASP_NETmenuItem_Click);
            // 
            // killApplicationButton
            // 
            this.killApplicationButton.Location = new System.Drawing.Point(408, 8);
            this.killApplicationButton.Name = "killApplicationButton";
            this.killApplicationButton.Size = new System.Drawing.Size(120, 23);
            this.killApplicationButton.TabIndex = 4;
            this.killApplicationButton.Text = "Kill Application";
            this.killApplicationButton.Click += new System.EventHandler(this.killApplicationButton_Click);
            // 
            // startApplicationButton
            // 
            this.startApplicationButton.Location = new System.Drawing.Point(8, 8);
            this.startApplicationButton.Name = "startApplicationButton";
            this.startApplicationButton.Size = new System.Drawing.Size(144, 23);
            this.startApplicationButton.TabIndex = 1;
            this.startApplicationButton.Text = "Start Application...";
            this.startApplicationButton.Click += new System.EventHandler(this.startApplicationButton_Click);
            // 
            // checkProcessTimer
            // 
            this.checkProcessTimer.Enabled = true;
            this.checkProcessTimer.Tick += new System.EventHandler(this.checkProcessTimer_Tick);
            // 
            // fontMenuItem
            // 
            this.fontMenuItem.Index = 0;
            this.fontMenuItem.Text = "Font...";
            this.fontMenuItem.Click += new System.EventHandler(this.fontMenuItem_Click);
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(552, 10);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(40, 16);
            this.label1.TabIndex = 6;
            this.label1.Text = "Profile:";
            // 
            // mainMenu
            // 
            this.mainMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                                     this.menuItem1,
                                                                                     this.menuItem5,
                                                                                     this.menuItem8});
            // 
            // menuItem1
            // 
            this.menuItem1.Index = 0;
            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                                      this.logFileOpenMenuItem,
                                                                                      this.profileApplicationMenuItem,
                                                                                      this.profileASP_NETmenuItem,
                                                                                      this.profileServiceMenuItem,
                                                                                      this.saveAsMenuItem,
                                                                                      this.setCommandLineMenuItem,
                                                                                      this.menuItem3,
                                                                                      this.exitMenuItem});
            this.menuItem1.Text = "File";
            // 
            // saveAsMenuItem
            // 
            this.saveAsMenuItem.Enabled = false;
            this.saveAsMenuItem.Index = 4;
            this.saveAsMenuItem.Shortcut = System.Windows.Forms.Shortcut.CtrlS;
            this.saveAsMenuItem.Text = "Save Profile As...";
            this.saveAsMenuItem.Click += new System.EventHandler(this.saveAsMenuItem_Click);
            // 
            // menuItem3
            // 
            this.menuItem3.Index = 6;
            this.menuItem3.Text = "-";
            // 
            // exitMenuItem
            // 
            this.exitMenuItem.Index = 7;
            this.exitMenuItem.Text = "Exit";
            this.exitMenuItem.Click += new System.EventHandler(this.exitMenuItem_Click);
            // 
            // menuItem5
            // 
            this.menuItem5.Index = 1;
            this.menuItem5.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                                      this.fontMenuItem});
            this.menuItem5.Text = "Edit";
            // 
            // menuItem8
            // 
            this.menuItem8.Index = 2;
            this.menuItem8.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                                      this.viewHistogramAllocatedMenuItem,
                                                                                      this.viewHistogramRelocatedMenuItem,
                                                                                      this.viewObjectsByAddressMenuItem,
                                                                                      this.viewHistogramByAgeMenuItem,
                                                                                      this.viewAllocationGraphMenuItem,
                                                                                      this.viewHeapGraphMenuItem,
                                                                                      this.viewCallGraphMenuItem,
                                                                                      this.viewTimeLineMenuItem});
            this.menuItem8.Text = "View";
            // 
            // viewHistogramAllocatedMenuItem
            // 
            this.viewHistogramAllocatedMenuItem.Index = 0;
            this.viewHistogramAllocatedMenuItem.Text = "Histogram Allocated Types";
            this.viewHistogramAllocatedMenuItem.Click += new System.EventHandler(this.viewHistogram_Click);
            // 
            // viewHistogramRelocatedMenuItem
            // 
            this.viewHistogramRelocatedMenuItem.Index = 1;
            this.viewHistogramRelocatedMenuItem.Text = "Histogram Relocated Types";
            this.viewHistogramRelocatedMenuItem.Click += new System.EventHandler(this.viewHistogramRelocatedMenuItem_Click);
            // 
            // viewObjectsByAddressMenuItem
            // 
            this.viewObjectsByAddressMenuItem.Index = 2;
            this.viewObjectsByAddressMenuItem.Text = "Objects by Address";
            this.viewObjectsByAddressMenuItem.Click += new System.EventHandler(this.viewByAddressMenuItem_Click);
            // 
            // viewHistogramByAgeMenuItem
            // 
            this.viewHistogramByAgeMenuItem.Index = 3;
            this.viewHistogramByAgeMenuItem.Text = "Histogram by Age";
            this.viewHistogramByAgeMenuItem.Click += new System.EventHandler(this.viewAgeHistogram_Click);
            // 
            // viewAllocationGraphMenuItem
            // 
            this.viewAllocationGraphMenuItem.Index = 4;
            this.viewAllocationGraphMenuItem.Text = "Allocation Graph";
            this.viewAllocationGraphMenuItem.Click += new System.EventHandler(this.viewAllocationGraphmenuItem_Click);
            // 
            // viewHeapGraphMenuItem
            // 
            this.viewHeapGraphMenuItem.Index = 5;
            this.viewHeapGraphMenuItem.Text = "Heap Graph";
            this.viewHeapGraphMenuItem.Click += new System.EventHandler(this.viewHeapGraphMenuItem_Click);
            // 
            // viewCallGraphMenuItem
            // 
            this.viewCallGraphMenuItem.Index = 6;
            this.viewCallGraphMenuItem.Text = "Call Graph";
            this.viewCallGraphMenuItem.Click += new System.EventHandler(this.viewCallGraphMenuItem_Click);
            // 
            // viewTimeLineMenuItem
            // 
            this.viewTimeLineMenuItem.Index = 7;
            this.viewTimeLineMenuItem.Text = "Time Line";
            this.viewTimeLineMenuItem.Click += new System.EventHandler(this.viewTimeLineMenuItem_Click);
            // 
            // showHeapButton
            // 
            this.showHeapButton.Location = new System.Drawing.Point(288, 8);
            this.showHeapButton.Name = "showHeapButton";
            this.showHeapButton.Size = new System.Drawing.Size(96, 23);
            this.showHeapButton.TabIndex = 9;
            this.showHeapButton.Text = "Show Heap now";
            this.showHeapButton.Click += new System.EventHandler(this.showHeapButton_Click);
            // 
            // saveFileDialog
            // 
            this.saveFileDialog.FileName = "doc1";
            // 
            // profileServiceMenuItem
            // 
            this.profileServiceMenuItem.Index = 3;
            this.profileServiceMenuItem.Text = "Profile Service...";
            this.profileServiceMenuItem.Click += new System.EventHandler(this.profileServiceMenuItem_Click);
            // 
            // Form1
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(752, 41);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this.showHeapButton,
                                                                          this.profilingActiveCheckBox,
                                                                          this.label1,
                                                                          this.groupBox1,
                                                                          this.killApplicationButton,
                                                                          this.startApplicationButton});
            this.Menu = this.mainMenu;
            this.Name = "Form1";
            this.Text = "AllocationProfiler";
            this.Closing += new System.ComponentModel.CancelEventHandler(this.Form1_Closing);
            this.groupBox1.ResumeLayout(false);
            this.ResumeLayout(false);

        }
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new Form1());
		}

		private void ViewGraph(ReadLogResult logResult, string exeName, Graph.GraphType graphType)
		{
			string fileName = log.fileName;
			if (exeName != null)
				fileName = exeName;
			Graph graph = null;
			string title = "";
			switch (graphType)
			{
				case	Graph.GraphType.CallGraph:
					graph = logResult.callstackHistogram.BuildCallGraph();
					graph.graphType = Graph.GraphType.CallGraph;
					title = "Call Graph for: ";
					break;

				case	Graph.GraphType.AllocationGraph:
					graph = logResult.allocatedHistogram.BuildAllocationGraph();
					graph.graphType = Graph.GraphType.AllocationGraph;
					title = "Allocation Graph for: ";
					break;

				case	Graph.GraphType.HeapGraph:
					if (heapGraph == null)
					{
						heapGraph = logResult.objectGraph.BuildTypeGraph();
						heapGraph.graphType = Graph.GraphType.HeapGraph;
					}
					graph = heapGraph;
					title = "Heap Graph for: ";
					break;

				default:
					Debug.Assert(false);
					break;
			}
			title += fileName + " " + commandLine;
			GraphViewForm graphViewForm = new GraphViewForm(graph, title);
			graphViewForm.Visible = true;
		}

		private void readLogFile(ReadNewLog log, ReadLogResult logResult, string exeName, Graph.GraphType graphType)
		{
			log.ReadFile(logFileStartOffset, logFileEndOffset, logResult);
			ViewGraph(logResult, exeName, graphType);
		}

		private void EnableDisableViewMenuItems()
		{
			if (lastLogResult == null)
			{
				viewAllocationGraphMenuItem.Enabled = false;
				viewCallGraphMenuItem.Enabled = false;
				viewHeapGraphMenuItem.Enabled = false;
				viewHistogramAllocatedMenuItem.Enabled = false;
				viewHistogramRelocatedMenuItem.Enabled = false;
				viewHistogramByAgeMenuItem.Enabled = false;
				viewObjectsByAddressMenuItem.Enabled = false;
				viewTimeLineMenuItem.Enabled = false;
			}
			else
			{
				viewAllocationGraphMenuItem.Enabled = !lastLogResult.allocatedHistogram.Empty;
				viewCallGraphMenuItem.Enabled = !lastLogResult.callstackHistogram.Empty;
				viewHeapGraphMenuItem.Enabled = lastLogResult.objectGraph.idToObject.Count != 0;
				viewHistogramAllocatedMenuItem.Enabled = !lastLogResult.allocatedHistogram.Empty;
				viewHistogramRelocatedMenuItem.Enabled = !lastLogResult.relocatedHistogram.Empty;
				viewHistogramByAgeMenuItem.Enabled = lastLogResult.liveObjectTable != null;
				viewObjectsByAddressMenuItem.Enabled = lastLogResult.liveObjectTable != null;
				viewTimeLineMenuItem.Enabled = lastLogResult.sampleObjectTable != null;

			}
		}

		private void fileOpenMenuItem_Click(object sender, System.EventArgs e)
		{
			if (!CheckProcessTerminate() || !CheckFileSave())
				return;

			saveAsMenuItem.Enabled = false;

			openFileDialog.FileName = "*.log";
			openFileDialog.Filter = "Allocation Logs | *.log";
			if (   openFileDialog.ShowDialog() == DialogResult.OK
				&& openFileDialog.CheckFileExists)
			{
				logFileName = openFileDialog.FileName;
				logFileStartOffset = 0;
				logFileEndOffset = long.MaxValue;
				
				processFileName = null;

				log = new ReadNewLog(logFileName);
				lastLogResult = null;
				ReadLogResult readLogResult = GetLogResult();
				readLogFile(log, readLogResult, null, Graph.GraphType.AllocationGraph);
				lastLogResult = readLogResult;
				Text = "Analyzing " + logFileName;
				EnableDisableViewMenuItems();
/*
				bool emptyGraph = true;
				foreach (Vertex v in graph.vertices.Values)
				{
					if (v.incomingWeight != 0 || v.outgoingWeight != 0)
					{
						emptyGraph = false;
						break;
					}
				}
				if (emptyGraph)
				{
					string message = allocationsRadioButton.Checked
						             ? "No allocation information found - look for call information instead?"
									 : "No call information found - look for allocation information instead?";
					if (MessageBox.Show(message, "No information found", MessageBoxButtons.OKCancel) == DialogResult.OK)
					{
						if (allocationsRadioButton.Checked)
						{
							callsRadioButton.Checked = true;
							ViewGraph(lastLogResult, processFileName, Graph.GraphType.CallGraph);
						}
						else
						{
							allocationsRadioButton.Checked = true;
							ViewGraph(lastLogResult, processFileName, Graph.GraphType.AllocationGraph);
						}
					}
				}
*/			}
		}

		private void SaveFile()
		{
			string baseName = Path.GetFileNameWithoutExtension(processFileName);
			string fileName = Path.ChangeExtension(processFileName, ".log");
			int count = 0;
			while (File.Exists(fileName))
			{
				count++;
				fileName = string.Format("{0}_{1}.log", baseName, count);
			}
			saveFileDialog.FileName = fileName;
			saveFileDialog.Filter = "Allocation Logs | *.log";
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				if (File.Exists(saveFileDialog.FileName) && saveFileDialog.FileName != logFileName)
					File.Delete(saveFileDialog.FileName);
				File.Move(logFileName, saveFileDialog.FileName);
				saveAsMenuItem.Enabled = false;
				if (log != null)
					log.fileName = saveFileDialog.FileName;
			}
		}

		private bool CheckFileSave()
		{
			if (saveAsMenuItem.Enabled)
			{
				if (saveNever)
				{
					File.Delete(logFileName);
				}
				else
				{
					SaveFileForm saveFileForm = new SaveFileForm();
					saveFileForm.processFileNameLabel.Text = processFileName;
					switch (saveFileForm.ShowDialog())
					{
						case	DialogResult.Yes:
							SaveFile();
							break;

						case	DialogResult.No:
							File.Delete(logFileName);
							saveAsMenuItem.Enabled = false;
							break;

						case	DialogResult.Cancel:
							return false;

						case	DialogResult.Retry:
							saveNever = true;
							break;
					}
				}
			}
			return true;
		}

		private bool CheckProcessTerminate()
		{
			if (killApplicationButton.Enabled)
			{
				KillProcessForm killProcessForm = new KillProcessForm();
				killProcessForm.processFileNameLabel.Text = processFileName;
				switch (killProcessForm.ShowDialog())
				{
					case	DialogResult.Yes:
						if (profiledProcess != null)
						{
							killApplicationButton_Click(null, null);
							saveAsMenuItem.Enabled = true;
						}
						break;

					case	DialogResult.No:
						profiledProcess = null;
						break;

					case	DialogResult.Cancel:
						return false;
				}
			}
			return true;
		}

		private void exitMenuItem_Click(object sender, System.EventArgs e)
		{
			if (CheckProcessTerminate() && CheckFileSave())
				Application.Exit();
		}

		private void fontMenuItem_Click(object sender, System.EventArgs e)
		{
			if (fontDialog.ShowDialog() == DialogResult.OK)
			{
				font = fontDialog.Font;
			}
		}

		private void profileApplicationMenuItem_Click(object sender, System.EventArgs e)
		{
			if (!CheckProcessTerminate() || !CheckFileSave())
				return;

			openFileDialog.FileName = "*.exe";
			openFileDialog.Filter = "Applications | *.exe";
			if (   openFileDialog.ShowDialog() == DialogResult.OK
				&& openFileDialog.CheckFileExists)
			{
				processFileName = openFileDialog.FileName;
				Text = "Profiling: " + processFileName + " " + commandLine;
				startApplicationButton.Text = "Start Application";
				killApplicationButton.Text = "Kill Application";
                serviceName = null;
				startApplicationButton_Click(null, null);
			}
		}

        private void StopIIS()
        {
            // stop IIS
            Text = "Stopping IIS ";
            ProcessStartInfo processStartInfo = new ProcessStartInfo("cmd.exe");
            processStartInfo.Arguments = "/c net stop iisadmin /y";
            Process process = Process.Start(processStartInfo);
            while (!process.HasExited)
            {
                Text += ".";
                Thread.Sleep(1000);
            }
            if (process.ExitCode != 0)
            {
                Text += string.Format(" Error {0} occurred", process.ExitCode);
            }
            else
                Text = "IIS stopped";			
        }

        private bool StartIIS()
        {
            Text = "Starting IIS ";
            ProcessStartInfo processStartInfo = new ProcessStartInfo("cmd.exe");
            processStartInfo.Arguments = "/c net start w3svc";
            Process process = Process.Start(processStartInfo);
            while (!process.HasExited)
            {
                Text += ".";
                Thread.Sleep(1000);
            }
            if (process.ExitCode != 0)
            {
                Text += string.Format(" Error {0} occurred", process.ExitCode);
                return false;
            }
            Text = "IIS running";
            return true;
        }

        private void StopService(string serviceName, string stopCommand)
        {
            // stop service
            Text = "Stopping " + serviceName + " ";
            ProcessStartInfo processStartInfo = new ProcessStartInfo("cmd.exe");
            processStartInfo.Arguments = "/c " + stopCommand;
            Process process = Process.Start(processStartInfo);
            while (!process.HasExited)
            {
                Text += ".";
                Thread.Sleep(1000);
            }
            if (process.ExitCode != 0)
            {
                Text += string.Format(" Error {0} occurred", process.ExitCode);
            }
            else
                Text = serviceName + " stopped";
        }

        private Process StartService(string serviceName, string startCommand)
        {
            Text = "Starting " + serviceName + " ";
            ProcessStartInfo processStartInfo = new ProcessStartInfo("cmd.exe");
            processStartInfo.Arguments = "/c " + startCommand;
            Process process = Process.Start(processStartInfo);
            return process;
        }

        private string[] GetServicesEnvironment()
		{
			Process[] servicesProcesses = Process.GetProcessesByName("services");
			if (servicesProcesses == null || servicesProcesses.Length != 1)
			{
				servicesProcesses = Process.GetProcessesByName("services.exe");
				if (servicesProcesses == null || servicesProcesses.Length != 1)
					return new string[0];
			}
			Process servicesProcess = servicesProcesses[0];
			System.Collections.Specialized.StringDictionary environment = servicesProcess.StartInfo.EnvironmentVariables;
			string[] envStrings = new string[environment.Count];
			int i = 0;
			foreach (DictionaryEntry d in environment)
			{
				envStrings[i++] = (string)d.Key + "=" + (string)d.Value;
			}

			return envStrings;
		}

		private string[] CombineEnvironmentVariables(string[] a, string[] b)
		{
			string[] c = new string[a.Length + b.Length];
			int i = 0;
			foreach (string s in a)
				c[i++] = s;
			foreach (string s in b)
				c[i++] = s;
			return c;
		}

		private Microsoft.Win32.RegistryKey GetServiceKey(string serviceName)
		{
			Microsoft.Win32.RegistryKey localMachine = Microsoft.Win32.Registry.LocalMachine;
			Microsoft.Win32.RegistryKey key = localMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\" + serviceName, true);
			return key;
		}

		private void SetEnvironmentVariables(string serviceName, string[] environment)
		{
			Microsoft.Win32.RegistryKey key = GetServiceKey(serviceName);
			if (key != null)
				key.SetValue("Environment", environment);
		}

		private void DeleteEnvironmentVariables(string serviceName)
		{
			Microsoft.Win32.RegistryKey key = GetServiceKey(serviceName);
			if (key != null)
				key.DeleteValue("Environment");
		}

        private void ProfileService()
        {
            if (!CheckProcessTerminate() || !CheckFileSave())
                return;

            RegisterDLL.Register();

            StopService(serviceName, serviceStopCommand);

            // set environment variables

            string[] baseEnvironment = GetServicesEnvironment();

            string tempDir = GetTempDir();

            string[] profilerEnvironment = new string[7]
            { 
                "Cor_Enable_Profiling=0x1",
                "COR_PROFILER={8C29BC4E-1F57-461a-9B51-1200C32E6F1F}",
                "OMV_SKIP=0",
                "OMV_STACK=1",
                "OMV_DynamicObjectTracking=0x1",
                "OMV_PATH=" + tempDir,
                "OMV_USAGE=" + (callsRadioButton.Checked ? "trace" : "objects")
            };

            string[] combinedEnvironment = CombineEnvironmentVariables(baseEnvironment, profilerEnvironment);
            SetEnvironmentVariables(serviceName, combinedEnvironment);

            Process cmdProcess = StartService(serviceName, serviceStartCommand);

            // wait for service to start up and connect
            Text = string.Format("Waiting for {0} to start up", serviceName);

            Thread.Sleep(1000);
            int pid = WaitForProcessToConnect(tempDir);
            profiledProcess = Process.GetProcessById(pid);

            Text = "Profiling: " + serviceName;
            startApplicationButton.Text = "Start " + serviceName;
            killApplicationButton.Text = "Kill " + serviceName;
            processFileName = serviceName;
        }

        private void profileASP_NETmenuItem_Click(object sender, System.EventArgs e)
		{
			if (!CheckProcessTerminate() || !CheckFileSave())
				return;

			RegisterDLL.Register();

			StopIIS();

			// set environment variables

			string[] baseEnvironment = GetServicesEnvironment();

			string tempDir = GetTempDir();

			string[] profilerEnvironment = new string[7]
			{ 
				"Cor_Enable_Profiling=0x1",
				"COR_PROFILER={8C29BC4E-1F57-461a-9B51-1200C32E6F1F}",
				"OMV_SKIP=0",
				"OMV_STACK=1",
				"OMV_DynamicObjectTracking=0x1",
				"OMV_PATH=" + tempDir,
				"OMV_USAGE=" + (callsRadioButton.Checked ? "trace" : "objects")
			};

			string[] combinedEnvironment = CombineEnvironmentVariables(baseEnvironment, profilerEnvironment);
			SetEnvironmentVariables("IISADMIN", combinedEnvironment);
			SetEnvironmentVariables("W3SVC", combinedEnvironment);

			if (!StartIIS())
				return;

			// wait for worker process to start up and connect
			Text = "Waiting for ASP.NET worker process to start up";
			
			Thread.Sleep(1000);
			int pid = WaitForProcessToConnect(tempDir);
			profiledProcess = Process.GetProcessById(pid);

			Text = "Profiling: ASP.NET";
			startApplicationButton.Text = "Start ASP.NET";
			killApplicationButton.Text = "Kill ASP.NET";
			processFileName = "ASP.NET";
            serviceName = null;
		}

		[DllImport("Kernel32.dll", CharSet=CharSet.Auto)]
		private static extern IntPtr CreateNamedPipe(
			string lpName,         // pointer to pipe name
			uint dwOpenMode,       // pipe open mode
			uint dwPipeMode,       // pipe-specific modes
			uint nMaxInstances,    // maximum number of instances
			uint nOutBufferSize,   // output buffer size, in bytes
			uint nInBufferSize,    // input buffer size, in bytes
			uint nDefaultTimeOut,  // time-out time, in milliseconds
			IntPtr lpSecurityAttributes  // pointer to security attributes
			);

		[DllImport("Kernel32.dll")]
		private static extern bool ConnectNamedPipe(
			IntPtr hNamedPipe,          // handle to named pipe to connect
			IntPtr lpOverlapped			// pointer to overlapped structure
			);

		[DllImport("Kernel32.dll")]
		private static extern bool DisconnectNamedPipe(
			IntPtr hNamedPipe   // handle to named pipe
			);

		[DllImport("Kernel32.dll")]
		private static extern int GetLastError();

		[DllImport("Kernel32.dll")]
		private static extern bool ReadFile(
			IntPtr hFile,                // handle of file to read
			byte[] lpBuffer,             // pointer to buffer that receives data
			uint nNumberOfBytesToRead,  // number of bytes to read
			out uint lpNumberOfBytesRead, // pointer to number of bytes read
			IntPtr lpOverlapped    // pointer to structure for data
			);

		private bool CreatePipe(bool blockingPipe)
		{
			uint flags = 4 | 2 | 0;
			if (!blockingPipe)
				flags |= 1;
			pipeHandle = CreateNamedPipe(@"\\.\pipe\OMV_PIPE", 3, flags, 1, 512, 512, 1000, IntPtr.Zero);
			if (pipeHandle == (IntPtr)(-1))
				return false;
			pipe = new FileStream(pipeHandle, FileAccess.ReadWrite, true, 512, false);
			return true;
		}

		private void ClosePipe()
		{
			pipe.Close();
			pipe = null;
			pipeHandle = IntPtr.Zero;
		}

		private NamedManualResetEvent CreateEvent(string baseName, int pid)
		{
			string eventName = string.Format("{0}_{1:x8}", baseName, pid);
			return new NamedManualResetEvent(eventName, false);
		}

		private void CreateEvents(int pid)
		{
			try
			{
				loggingActiveEvent = CreateEvent("Global\\OMV_TriggerObjects", pid);
				forceGcEvent = CreateEvent("Global\\OMV_ForceGC", pid);
				loggingActiveCompletedEvent = CreateEvent("Global\\OMV_TriggerObjects_Completed", pid);
				forceGcCompletedEvent = CreateEvent("Global\\OMV_ForceGC_Completed", pid);
				callGraphActiveEvent = CreateEvent("Global\\OMV_Callgraph", pid);
				callGraphActiveCompletedEvent = CreateEvent("Global\\OMV_Callgraph_Completed", pid);
			}
			catch
			{
				MessageBox.Show("Could not create events - in case you are profiling a service, " +
					"start the profiler BEFORE starting the service");
				throw;
			}
		}

		private void ClearEvents()
		{
			loggingActiveEvent = null;
			forceGcEvent = null;
			loggingActiveCompletedEvent = null;
			forceGcCompletedEvent = null;
			callGraphActiveEvent = null;
			callGraphActiveCompletedEvent = null;
		}

		private string GetTempDir()
		{
			string tempDir = null;
			tempDir = Environment.GetEnvironmentVariable("TEMP");
			if (tempDir == null)
			{
				tempDir = Environment.GetEnvironmentVariable("TMP");
				if (tempDir == null)
					tempDir = @"C:\TEMP";
			}
			return	tempDir;
		}

		private int WaitForProcessToConnect(string tempDir)
		{
			ConnectNamedPipe(pipeHandle, IntPtr.Zero);

			NamedManualResetEvent completedEvent = null;

			int pid = 0;

			byte[] buffer = new byte[9];
			int readBytes = 0;
			readBytes += pipe.Read(buffer, 0, 9);
			if (readBytes == 9)
			{
				char[] charBuffer = new char[9];
				for (int i = 0; i < buffer.Length; i++)
					charBuffer[i] = Convert.ToChar(buffer[i]);
				pid = Int32.Parse(new String(charBuffer, 0, 9), NumberStyles.HexNumber);

				CreateEvents(pid);

				if (profilingActiveCheckBox.Checked && allocationsRadioButton.Checked)
				{
					loggingActiveEvent.Set();
					completedEvent = loggingActiveCompletedEvent;
				}
				else if (!profilingActiveCheckBox.Checked && callsRadioButton.Checked)
				{
					callGraphActiveEvent.Set();
					completedEvent = callGraphActiveCompletedEvent;
				}

				string fileName = string.Format("PIPE_{0}.LOG", pid);
				byte[] fileNameBuffer = new Byte[fileName.Length+1];
				for (int i = 0; i < fileName.Length; i++)
					fileNameBuffer[i] = (byte)fileName[i];
				fileNameBuffer[fileName.Length] = 0;
				pipe.Write(fileNameBuffer, 0, fileNameBuffer.Length);
				pipe.Flush();
				logFileName = tempDir + @"\" + fileName;
				log = new ReadNewLog(logFileName);
				lastLogResult = null;
				EnableDisableViewMenuItems();
				while (true)
				{
					if (pipe.Read(buffer, 0, 1) == 0 && GetLastError() == 109/*ERROR_BROKEN_PIPE*/)
					{
						DisconnectNamedPipe(pipeHandle);
						break;
					}
				}
			}
			else
			{
				string error = string.Format("Error {0} occurred", GetLastError());
				MessageBox.Show(error);
			}

			if (completedEvent != null)
			{
				if (completedEvent.Wait(10*1000))
					completedEvent.Reset();
				else
					MessageBox.Show("There was no response from the application");
			}

			killApplicationButton.Enabled = true;
			showHeapButton.Enabled = true;

			logFileStartOffset = 0;
			logFileEndOffset = long.MaxValue;

			return pid;
		}

		private void startApplicationButton_Click(object sender, System.EventArgs e)
		{
			if (!CheckProcessTerminate() || !CheckFileSave())
				return;

            if (processFileName == null)
            {
                profileApplicationMenuItem_Click(null, null);
            }
            else if (processFileName == "ASP.NET")
            {
                profileASP_NETmenuItem_Click(null, null);
                return;
            }
            else if (serviceName != null)
            {
                ProfileService();
                return;
            }

			RegisterDLL.Register();

			if (processFileName == null)
				return;

			if (profiledProcess == null || profiledProcess.HasExited)
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(processFileName);
				processStartInfo.EnvironmentVariables["Cor_Enable_Profiling"] = "0x1";
				processStartInfo.EnvironmentVariables["COR_PROFILER"] = "{8C29BC4E-1F57-461a-9B51-1200C32E6F1F}";
				if (callsRadioButton.Checked)
					processStartInfo.EnvironmentVariables["OMV_USAGE"] = "trace";
				else
					processStartInfo.EnvironmentVariables["OMV_USAGE"] = "objects";

				processStartInfo.EnvironmentVariables["OMV_SKIP"] = "0";
				string tempDir = GetTempDir();
				processStartInfo.EnvironmentVariables["OMV_PATH"] = tempDir;
				processStartInfo.EnvironmentVariables["OMV_STACK"] = "1";
				processStartInfo.EnvironmentVariables["OMV_DynamicObjectTracking"] = "0x1";

				if (commandLine != null)
					processStartInfo.Arguments = commandLine;

				if (workingDirectory != null)
					processStartInfo.WorkingDirectory = workingDirectory;

				processStartInfo.UseShellExecute = false;

				profiledProcess = Process.Start(processStartInfo);

				WaitForProcessToConnect(tempDir);
			}
		}

		private ReadLogResult GetLogResult()
		{
			ReadLogResult readLogResult = lastLogResult;
			if (readLogResult == null)
			{
				readLogResult = new ReadLogResult();
				readLogResult.liveObjectTable = new LiveObjectTable(log);
				readLogResult.sampleObjectTable = new SampleObjectTable(log);
			}						

			readLogResult.allocatedHistogram = new Histogram(log);
			readLogResult.callstackHistogram = new Histogram(log);
			readLogResult.relocatedHistogram = new Histogram(log);
			readLogResult.objectGraph = new ObjectGraph();
			
			return readLogResult;
		}

		private void profilingActiveCheckBox_CheckedChanged(object sender, System.EventArgs e)
		{
			NamedManualResetEvent toggleEvent = null;
			NamedManualResetEvent toggleEventCompleted = null;
			if (allocationsRadioButton.Checked)
			{
				toggleEvent = loggingActiveEvent;
				toggleEventCompleted = loggingActiveCompletedEvent;
			}
			else if (callsRadioButton.Checked)
			{
				toggleEvent = callGraphActiveEvent;
				toggleEventCompleted = callGraphActiveCompletedEvent;
			}

			if (profiledProcess != null && !profiledProcess.HasExited || logFileName != null)
			{
				if (toggleEvent != null)
				{
					toggleEvent.Set();
					if (toggleEventCompleted.Wait(10*1000))
						toggleEventCompleted.Reset();
					else
						MessageBox.Show("There was no response from the application");
				}
				Stream s = new FileStream(logFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
				long offset = s.Length;
				s.Close();
				if (profilingActiveCheckBox.Checked)
					logFileStartOffset = offset;
				else
				{
					logFileEndOffset = offset;
					if (logFileStartOffset >= logFileEndOffset)
						MessageBox.Show("No new data found", "",
							MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				}
				if (!profilingActiveCheckBox.Checked && logFileStartOffset < logFileEndOffset && logFileName != null)
				{
					ReadLogResult readLogResult = GetLogResult();					
					readLogFile(log, readLogResult, processFileName, callsRadioButton.Checked ? Graph.GraphType.CallGraph : Graph.GraphType.AllocationGraph);
					lastLogResult = readLogResult;
					EnableDisableViewMenuItems();
				}
			}
		}

		private void CheckPipe()
		{
			if (ConnectNamedPipe(pipeHandle, IntPtr.Zero))
			{
				NamedManualResetEvent completedEvent = null;

				byte[] buffer = new byte[9];
				int readBytes = pipe.Read(buffer, 0, 9);
				if (readBytes == 9)
				{
					char[] charBuffer = new char[9];
					for (int i = 0; i < buffer.Length; i++)
						charBuffer[i] = Convert.ToChar(buffer[i]);
					int pid = Int32.Parse(new String(charBuffer, 0, 9), NumberStyles.HexNumber);

					MessageBox.Show(pid.ToString());

					CreateEvents(pid);

					if (profilingActiveCheckBox.Checked && allocationsRadioButton.Checked)
					{
						loggingActiveEvent.Set();
						completedEvent = loggingActiveCompletedEvent;
					}
					else if (!profilingActiveCheckBox.Checked && callsRadioButton.Checked)
					{
						callGraphActiveEvent.Set();
						completedEvent = callGraphActiveCompletedEvent;
					}

					string fileName = string.Format("PIPE_{0}.LOG", pid);
					byte[] fileNameBuffer = new Byte[fileName.Length+1];
					for (int i = 0; i < fileName.Length; i++)
						fileNameBuffer[i] = (byte)fileName[i];
					fileNameBuffer[fileName.Length] = 0;
					pipe.Write(fileNameBuffer, 0, fileNameBuffer.Length);
					pipe.Flush();
					logFileName = GetTempDir() + @"\" + fileName;
					while (true)
					{
						if (pipe.Read(buffer, 0, 1) == 0 && GetLastError() == 109/*ERROR_BROKEN_PIPE*/)
						{
							DisconnectNamedPipe(pipeHandle);
							break;
						}
					}
				}
				else
				{
					string error = string.Format("Error {0} occurred", GetLastError());
					MessageBox.Show(error);
				}
			}
		}

		private void checkProcessTimer_Tick(object sender, System.EventArgs e)
		{
			bool processRunning = profiledProcess != null && !profiledProcess.HasExited;

			killApplicationButton.Enabled = processRunning;
			showHeapButton.Enabled = processRunning;

			allocationsRadioButton.Enabled = !processRunning;
			callsRadioButton.Enabled = !processRunning;

			if (profiledProcess != null && profiledProcess.HasExited)
			{
				profiledProcess = null;
				logFileEndOffset = int.MaxValue;
				ReadLogResult readLogResult = GetLogResult();
				readLogFile(log, readLogResult, processFileName, callsRadioButton.Checked ? Graph.GraphType.CallGraph : Graph.GraphType.AllocationGraph);
				lastLogResult = readLogResult;
				EnableDisableViewMenuItems();
				ClearEvents();
				saveAsMenuItem.Enabled = true;
			}
		}

		private void killApplicationButton_Click(object sender, System.EventArgs e)
		{
			if (profiledProcess != null)
			{
                if (killApplicationButton.Text == "Kill ASP.NET")
                {
                    StopIIS();
                    DeleteEnvironmentVariables("IISADMIN");
                    DeleteEnvironmentVariables("W3SVC");
                    StartIIS();
                }
                else if (serviceName != null)
                {
                    StopService(serviceName, serviceStopCommand);
                }
                else
                {
                    profiledProcess.Kill();
                }
			}
		}

		private void setCommandLineMenuItem_Click(object sender, System.EventArgs e)
		{
			Form3 setCommandLineForm = new Form3();
			setCommandLineForm.commandLineTextBox.Text = commandLine;
			setCommandLineForm.workingDirectoryTextBox.Text = workingDirectory;
			if (setCommandLineForm.ShowDialog() == DialogResult.OK)
			{
				commandLine = setCommandLineForm.commandLineTextBox.Text;
				workingDirectory = setCommandLineForm.workingDirectoryTextBox.Text;
			}
		}

		private long logFileOffset()
		{
			Stream s = new FileStream(logFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
			long offset = s.Length;
			s.Close();

			return offset;
		}

		private void showHeapButton_Click(object sender, System.EventArgs e)
		{
			forceGcCompletedEvent.Wait(1);
			forceGcCompletedEvent.Reset();
			long startOffset = logFileOffset();
			forceGcEvent.Set();
			if (forceGcCompletedEvent.Wait(10*1000))
			{
				forceGcCompletedEvent.Reset();
				long saveLogFileStartOffset = logFileStartOffset;
				logFileStartOffset = startOffset;
				logFileEndOffset = logFileOffset();
				ReadLogResult logResult = GetLogResult();
				heapGraph = null;
				readLogFile(log, logResult, processFileName, Graph.GraphType.HeapGraph);
				lastLogResult = logResult;
				EnableDisableViewMenuItems();
				logFileStartOffset = saveLogFileStartOffset;
			}
			else
			{
				MessageBox.Show("There was no response from the application");
			}
		}

		private void viewByAddressMenuItem_Click(object sender, System.EventArgs e)
		{
			ViewByAddressForm viewByAddressForm = new ViewByAddressForm();
			viewByAddressForm.Visible = true;
		}

		private void viewTimeLineMenuItem_Click(object sender, System.EventArgs e)
		{
			TimeLineViewForm timeLineViewForm = new TimeLineViewForm();
			timeLineViewForm.Visible = true;
		}

		private void viewHistogram_Click(object sender, System.EventArgs e)
		{
			HistogramViewForm histogramViewForm = new HistogramViewForm();
			histogramViewForm.Visible = true;		
		}

		private void saveAsMenuItem_Click(object sender, System.EventArgs e)
		{
			SaveFile();
		}

		private void Form1_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			e.Cancel = !CheckProcessTerminate() || !CheckFileSave();
		}

		private void viewHistogramRelocatedMenuItem_Click(object sender, System.EventArgs e)
		{
			if (lastLogResult != null)
			{
				string title = "Histogram by Size for Relocated Objects";
				HistogramViewForm histogramViewForm = new HistogramViewForm(lastLogResult.relocatedHistogram, title);
				histogramViewForm.Show();
			}
		}

		private void viewAgeHistogram_Click(object sender, System.EventArgs e)
		{
			if (lastLogResult != null)
			{
				string title = "Histogram by Age for Live Objects";
				AgeHistogram ageHistogram = new AgeHistogram(lastLogResult.liveObjectTable, title);
				ageHistogram.Show();
			}
		}

		private void viewAllocationGraphmenuItem_Click(object sender, System.EventArgs e)
		{
			if (lastLogResult != null)
				ViewGraph(lastLogResult, processFileName, Graph.GraphType.AllocationGraph);
		}

		private void viewHeapGraphMenuItem_Click(object sender, System.EventArgs e)
		{
			if (lastLogResult != null)
				ViewGraph(lastLogResult, processFileName, Graph.GraphType.HeapGraph);		
		}

		private void viewCallGraphMenuItem_Click(object sender, System.EventArgs e)
		{
			if (lastLogResult != null)
				ViewGraph(lastLogResult, processFileName, Graph.GraphType.CallGraph);
		}

		private void contextMenu_Popup(object sender, System.EventArgs e)
		{
		
		}
		
		private void Form1_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
		{
			if (e.KeyCode == Keys.F5)
			{
				startApplicationButton_Click(null, null);
			}
		}

        private void profileServiceMenuItem_Click(object sender, System.EventArgs e)
        {
            ProfileServiceForm profileServiceForm = new ProfileServiceForm();
            if (profileServiceForm.ShowDialog() == DialogResult.OK)
            {
                serviceName         = profileServiceForm.serviceNameTextBox.Text;
                serviceStartCommand = profileServiceForm.startCommandTextBox.Text;
                serviceStopCommand  = profileServiceForm.stopCommandTextBox.Text;

                ProfileService();
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\form5.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for Form5.
	/// </summary>
	public class Form5 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		internal System.Windows.Forms.TextBox nameTextBox;
		private System.Windows.Forms.Label label2;
		internal System.Windows.Forms.TextBox signatureTextBox;
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.Button cancelButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form5()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if(components != null)	
                    components.Dispose();
            }
            base.Dispose(disposing);
        }

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.cancelButton = new System.Windows.Forms.Button();
			this.label1 = new System.Windows.Forms.Label();
			this.nameTextBox = new System.Windows.Forms.TextBox();
			this.okButton = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.signatureTextBox = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(594, 69);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.Size = new System.Drawing.Size(96, 28);
			this.cancelButton.TabIndex = 5;
			this.cancelButton.Text = "Cancel";
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(31, 20);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(225, 19);
			this.label1.TabIndex = 0;
			this.label1.Text = "Name of routine or type to find";
			// 
			// nameTextBox
			// 
			this.nameTextBox.Location = new System.Drawing.Point(41, 39);
			this.nameTextBox.Name = "nameTextBox";
			this.nameTextBox.Size = new System.Drawing.Size(491, 22);
			this.nameTextBox.TabIndex = 1;
			this.nameTextBox.Text = "";
			// 
			// okButton
			// 
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(594, 20);
			this.okButton.Name = "okButton";
			this.okButton.Size = new System.Drawing.Size(96, 28);
			this.okButton.TabIndex = 4;
			this.okButton.Text = "OK";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(31, 89);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(205, 20);
			this.label2.TabIndex = 2;
			this.label2.Text = "Signature of routine to find";
			// 
			// signatureTextBox
			// 
			this.signatureTextBox.Location = new System.Drawing.Point(41, 109);
			this.signatureTextBox.Name = "signatureTextBox";
			this.signatureTextBox.Size = new System.Drawing.Size(491, 22);
			this.signatureTextBox.TabIndex = 3;
			this.signatureTextBox.Text = "";
			// 
			// Form5
			// 
			this.AcceptButton = this.okButton;
			this.AutoScaleBaseSize = new System.Drawing.Size(6, 15);
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(716, 164);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.cancelButton,
																		  this.okButton,
																		  this.signatureTextBox,
																		  this.label2,
																		  this.nameTextBox,
																		  this.label1});
			this.Name = "Form5";
			this.Text = "Find Routine";
			this.ResumeLayout(false);

		}
		#endregion

		private void okButton_Click(object sender, System.EventArgs e)
		{
			Close();
		}

		private void cancelButton_Click(object sender, System.EventArgs e)
		{
			Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\agehistogram.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for AgeHistogram.
	/// </summary>
	public class AgeHistogram : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Splitter splitter1;
		private System.Windows.Forms.GroupBox verticalScaleGroupBox;
		private System.Windows.Forms.Panel graphOuterPanel;
		private System.Windows.Forms.Panel typeLegendOuterPanel;
		private System.Windows.Forms.Panel graphPanel;
		private System.Windows.Forms.Panel typeLegendPanel;
		private System.Windows.Forms.RadioButton radioButton1;
		private System.Windows.Forms.RadioButton radioButton2;
		private System.Windows.Forms.RadioButton radioButton3;
		private System.Windows.Forms.RadioButton radioButton4;
		private System.Windows.Forms.RadioButton radioButton5;
		private System.Windows.Forms.RadioButton radioButton6;
		private System.Windows.Forms.RadioButton radioButton7;
		private System.Windows.Forms.RadioButton radioButton8;
		private System.Windows.Forms.RadioButton radioButton9;
		private System.Windows.Forms.RadioButton radioButton10;
		private System.Windows.Forms.RadioButton radioButton11;
		private System.Windows.Forms.RadioButton radioButton12;
		private System.Windows.Forms.RadioButton radioButton13;
		private System.Windows.Forms.RadioButton radioButton14;
		private System.Windows.Forms.RadioButton radioButton15;
		private System.Windows.Forms.RadioButton radioButton16;
		private System.Windows.Forms.RadioButton radioButton17;
		private System.Windows.Forms.RadioButton radioButton18;
		private System.Windows.Forms.RadioButton radioButton19;
		private System.Windows.Forms.RadioButton radioButton20;
		private System.Windows.Forms.GroupBox timeScaleGroupBox;
		private System.ComponentModel.IContainer components;
		private System.Windows.Forms.ContextMenu contextMenu;
		private System.Windows.Forms.MenuItem showWhoAllocatedMenuItem;
		private System.Windows.Forms.MenuItem exportDataMenuItem;
		private System.Windows.Forms.SaveFileDialog exportSaveFileDialog;
		private System.Windows.Forms.Timer versionTimer;

		private Font font;

		internal AgeHistogram()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			toolTip = new ToolTip();
			toolTip.Active = false;
			toolTip.ShowAlways = true;

			autoUpdate = true;
		
			Form1 form1 = Form1.instance;
			if (form1.lastLogResult != null)
				liveObjectTable = Form1.instance.lastLogResult.liveObjectTable;

			font = form1.font;
		}

		internal AgeHistogram(LiveObjectTable liveObjectTable, string title) : this()
		{
			this.liveObjectTable = liveObjectTable;
			this.Text = title;
			autoUpdate = false;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			versionTimer.Stop();
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.panel1 = new System.Windows.Forms.Panel();
			this.timeScaleGroupBox = new System.Windows.Forms.GroupBox();
			this.radioButton20 = new System.Windows.Forms.RadioButton();
			this.radioButton19 = new System.Windows.Forms.RadioButton();
			this.radioButton18 = new System.Windows.Forms.RadioButton();
			this.radioButton17 = new System.Windows.Forms.RadioButton();
			this.radioButton16 = new System.Windows.Forms.RadioButton();
			this.radioButton15 = new System.Windows.Forms.RadioButton();
			this.radioButton14 = new System.Windows.Forms.RadioButton();
			this.radioButton13 = new System.Windows.Forms.RadioButton();
			this.radioButton12 = new System.Windows.Forms.RadioButton();
			this.radioButton11 = new System.Windows.Forms.RadioButton();
			this.verticalScaleGroupBox = new System.Windows.Forms.GroupBox();
			this.radioButton10 = new System.Windows.Forms.RadioButton();
			this.radioButton9 = new System.Windows.Forms.RadioButton();
			this.radioButton8 = new System.Windows.Forms.RadioButton();
			this.radioButton7 = new System.Windows.Forms.RadioButton();
			this.radioButton6 = new System.Windows.Forms.RadioButton();
			this.radioButton5 = new System.Windows.Forms.RadioButton();
			this.radioButton4 = new System.Windows.Forms.RadioButton();
			this.radioButton3 = new System.Windows.Forms.RadioButton();
			this.radioButton2 = new System.Windows.Forms.RadioButton();
			this.radioButton1 = new System.Windows.Forms.RadioButton();
			this.graphOuterPanel = new System.Windows.Forms.Panel();
			this.graphPanel = new System.Windows.Forms.Panel();
			this.splitter1 = new System.Windows.Forms.Splitter();
			this.typeLegendOuterPanel = new System.Windows.Forms.Panel();
			this.typeLegendPanel = new System.Windows.Forms.Panel();
			this.contextMenu = new System.Windows.Forms.ContextMenu();
			this.showWhoAllocatedMenuItem = new System.Windows.Forms.MenuItem();
			this.exportDataMenuItem = new System.Windows.Forms.MenuItem();
			this.exportSaveFileDialog = new System.Windows.Forms.SaveFileDialog();
			this.versionTimer = new System.Windows.Forms.Timer(this.components);
			this.panel1.SuspendLayout();
			this.timeScaleGroupBox.SuspendLayout();
			this.verticalScaleGroupBox.SuspendLayout();
			this.graphOuterPanel.SuspendLayout();
			this.typeLegendOuterPanel.SuspendLayout();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.timeScaleGroupBox,
																				 this.verticalScaleGroupBox});
			this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(952, 100);
			this.panel1.TabIndex = 0;
			// 
			// timeScaleGroupBox
			// 
			this.timeScaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																							this.radioButton20,
																							this.radioButton19,
																							this.radioButton18,
																							this.radioButton17,
																							this.radioButton16,
																							this.radioButton15,
																							this.radioButton14,
																							this.radioButton13,
																							this.radioButton12,
																							this.radioButton11});
			this.timeScaleGroupBox.Location = new System.Drawing.Point(512, 16);
			this.timeScaleGroupBox.Name = "timeScaleGroupBox";
			this.timeScaleGroupBox.Size = new System.Drawing.Size(408, 64);
			this.timeScaleGroupBox.TabIndex = 1;
			this.timeScaleGroupBox.TabStop = false;
			this.timeScaleGroupBox.Text = "Time Scale: Seconds/Bar";
			// 
			// radioButton20
			// 
			this.radioButton20.Location = new System.Drawing.Point(16, 24);
			this.radioButton20.Name = "radioButton20";
			this.radioButton20.Size = new System.Drawing.Size(48, 24);
			this.radioButton20.TabIndex = 10;
			this.radioButton20.Text = "0.05";
			this.radioButton20.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton19
			// 
			this.radioButton19.Location = new System.Drawing.Point(360, 24);
			this.radioButton19.Name = "radioButton19";
			this.radioButton19.Size = new System.Drawing.Size(40, 24);
			this.radioButton19.TabIndex = 9;
			this.radioButton19.Text = "50";
			this.radioButton19.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton18
			// 
			this.radioButton18.Location = new System.Drawing.Point(320, 24);
			this.radioButton18.Name = "radioButton18";
			this.radioButton18.Size = new System.Drawing.Size(40, 24);
			this.radioButton18.TabIndex = 8;
			this.radioButton18.Text = "20";
			this.radioButton18.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton17
			// 
			this.radioButton17.Location = new System.Drawing.Point(280, 24);
			this.radioButton17.Name = "radioButton17";
			this.radioButton17.Size = new System.Drawing.Size(40, 24);
			this.radioButton17.TabIndex = 7;
			this.radioButton17.Text = "10";
			this.radioButton17.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton16
			// 
			this.radioButton16.Location = new System.Drawing.Point(104, 24);
			this.radioButton16.Name = "radioButton16";
			this.radioButton16.Size = new System.Drawing.Size(40, 24);
			this.radioButton16.TabIndex = 6;
			this.radioButton16.Text = "0.2";
			this.radioButton16.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton15
			// 
			this.radioButton15.Location = new System.Drawing.Point(144, 24);
			this.radioButton15.Name = "radioButton15";
			this.radioButton15.Size = new System.Drawing.Size(40, 24);
			this.radioButton15.TabIndex = 5;
			this.radioButton15.Text = "0.5";
			this.radioButton15.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton14
			// 
			this.radioButton14.Location = new System.Drawing.Point(248, 24);
			this.radioButton14.Name = "radioButton14";
			this.radioButton14.Size = new System.Drawing.Size(32, 24);
			this.radioButton14.TabIndex = 4;
			this.radioButton14.Text = "5";
			this.radioButton14.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton13
			// 
			this.radioButton13.Location = new System.Drawing.Point(216, 24);
			this.radioButton13.Name = "radioButton13";
			this.radioButton13.Size = new System.Drawing.Size(32, 24);
			this.radioButton13.TabIndex = 3;
			this.radioButton13.Text = "2";
			this.radioButton13.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton12
			// 
			this.radioButton12.Location = new System.Drawing.Point(184, 24);
			this.radioButton12.Name = "radioButton12";
			this.radioButton12.Size = new System.Drawing.Size(32, 24);
			this.radioButton12.TabIndex = 2;
			this.radioButton12.Text = "1";
			this.radioButton12.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton11
			// 
			this.radioButton11.Location = new System.Drawing.Point(64, 24);
			this.radioButton11.Name = "radioButton11";
			this.radioButton11.Size = new System.Drawing.Size(40, 24);
			this.radioButton11.TabIndex = 1;
			this.radioButton11.Text = "0.1";
			this.radioButton11.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// verticalScaleGroupBox
			// 
			this.verticalScaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																								this.radioButton10,
																								this.radioButton9,
																								this.radioButton8,
																								this.radioButton7,
																								this.radioButton6,
																								this.radioButton5,
																								this.radioButton4,
																								this.radioButton3,
																								this.radioButton2,
																								this.radioButton1});
			this.verticalScaleGroupBox.Location = new System.Drawing.Point(24, 16);
			this.verticalScaleGroupBox.Name = "verticalScaleGroupBox";
			this.verticalScaleGroupBox.Size = new System.Drawing.Size(464, 64);
			this.verticalScaleGroupBox.TabIndex = 0;
			this.verticalScaleGroupBox.TabStop = false;
			this.verticalScaleGroupBox.Text = "Vertical Scale: KB/Pixel";
			// 
			// radioButton10
			// 
			this.radioButton10.Location = new System.Drawing.Point(400, 24);
			this.radioButton10.Name = "radioButton10";
			this.radioButton10.Size = new System.Drawing.Size(48, 24);
			this.radioButton10.TabIndex = 9;
			this.radioButton10.Text = "1000";
			this.radioButton10.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton9
			// 
			this.radioButton9.Location = new System.Drawing.Point(352, 24);
			this.radioButton9.Name = "radioButton9";
			this.radioButton9.Size = new System.Drawing.Size(48, 24);
			this.radioButton9.TabIndex = 8;
			this.radioButton9.Text = "500";
			this.radioButton9.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton8
			// 
			this.radioButton8.Location = new System.Drawing.Point(304, 24);
			this.radioButton8.Name = "radioButton8";
			this.radioButton8.Size = new System.Drawing.Size(48, 24);
			this.radioButton8.TabIndex = 7;
			this.radioButton8.Text = "200";
			this.radioButton8.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton7
			// 
			this.radioButton7.Location = new System.Drawing.Point(216, 24);
			this.radioButton7.Name = "radioButton7";
			this.radioButton7.Size = new System.Drawing.Size(40, 24);
			this.radioButton7.TabIndex = 6;
			this.radioButton7.Text = "50";
			this.radioButton7.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton6
			// 
			this.radioButton6.Location = new System.Drawing.Point(136, 24);
			this.radioButton6.Name = "radioButton6";
			this.radioButton6.Size = new System.Drawing.Size(40, 24);
			this.radioButton6.TabIndex = 5;
			this.radioButton6.Text = "10";
			this.radioButton6.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton5
			// 
			this.radioButton5.Location = new System.Drawing.Point(256, 24);
			this.radioButton5.Name = "radioButton5";
			this.radioButton5.Size = new System.Drawing.Size(48, 24);
			this.radioButton5.TabIndex = 4;
			this.radioButton5.Text = "100";
			this.radioButton5.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton4
			// 
			this.radioButton4.Location = new System.Drawing.Point(176, 24);
			this.radioButton4.Name = "radioButton4";
			this.radioButton4.Size = new System.Drawing.Size(40, 24);
			this.radioButton4.TabIndex = 3;
			this.radioButton4.Text = "20";
			this.radioButton4.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton3
			// 
			this.radioButton3.Location = new System.Drawing.Point(96, 24);
			this.radioButton3.Name = "radioButton3";
			this.radioButton3.Size = new System.Drawing.Size(32, 24);
			this.radioButton3.TabIndex = 2;
			this.radioButton3.Text = "5";
			this.radioButton3.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton2
			// 
			this.radioButton2.Location = new System.Drawing.Point(56, 24);
			this.radioButton2.Name = "radioButton2";
			this.radioButton2.Size = new System.Drawing.Size(32, 24);
			this.radioButton2.TabIndex = 1;
			this.radioButton2.Text = "2";
			this.radioButton2.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// radioButton1
			// 
			this.radioButton1.Location = new System.Drawing.Point(16, 24);
			this.radioButton1.Name = "radioButton1";
			this.radioButton1.Size = new System.Drawing.Size(32, 24);
			this.radioButton1.TabIndex = 0;
			this.radioButton1.Text = "1";
			this.radioButton1.CheckedChanged += new System.EventHandler(this.CheckedChanged);
			// 
			// graphOuterPanel
			// 
			this.graphOuterPanel.AutoScroll = true;
			this.graphOuterPanel.BackColor = System.Drawing.SystemColors.Control;
			this.graphOuterPanel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.graphOuterPanel.Controls.AddRange(new System.Windows.Forms.Control[] {
																						  this.graphPanel});
			this.graphOuterPanel.Dock = System.Windows.Forms.DockStyle.Left;
			this.graphOuterPanel.Location = new System.Drawing.Point(0, 100);
			this.graphOuterPanel.Name = "graphOuterPanel";
			this.graphOuterPanel.Size = new System.Drawing.Size(496, 537);
			this.graphOuterPanel.TabIndex = 1;
			// 
			// graphPanel
			// 
			this.graphPanel.BackColor = System.Drawing.SystemColors.Control;
			this.graphPanel.Name = "graphPanel";
			this.graphPanel.Size = new System.Drawing.Size(488, 528);
			this.graphPanel.TabIndex = 0;
			this.graphPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.graphPanel_Paint);
			this.graphPanel.MouseMove += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseMove);
			this.graphPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseDown);
			// 
			// splitter1
			// 
			this.splitter1.Location = new System.Drawing.Point(496, 100);
			this.splitter1.Name = "splitter1";
			this.splitter1.Size = new System.Drawing.Size(8, 537);
			this.splitter1.TabIndex = 2;
			this.splitter1.TabStop = false;
			// 
			// typeLegendOuterPanel
			// 
			this.typeLegendOuterPanel.AutoScroll = true;
			this.typeLegendOuterPanel.BackColor = System.Drawing.SystemColors.Control;
			this.typeLegendOuterPanel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.typeLegendOuterPanel.Controls.AddRange(new System.Windows.Forms.Control[] {
																							   this.typeLegendPanel});
			this.typeLegendOuterPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			this.typeLegendOuterPanel.Location = new System.Drawing.Point(504, 100);
			this.typeLegendOuterPanel.Name = "typeLegendOuterPanel";
			this.typeLegendOuterPanel.Size = new System.Drawing.Size(448, 537);
			this.typeLegendOuterPanel.TabIndex = 3;
			// 
			// typeLegendPanel
			// 
			this.typeLegendPanel.BackColor = System.Drawing.SystemColors.Control;
			this.typeLegendPanel.Name = "typeLegendPanel";
			this.typeLegendPanel.Size = new System.Drawing.Size(440, 528);
			this.typeLegendPanel.TabIndex = 0;
			this.typeLegendPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.typeLegendPanel_Paint);
			this.typeLegendPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.typeLegendPanel_MouseDown);
			// 
			// contextMenu
			// 
			this.contextMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																						this.showWhoAllocatedMenuItem,
																						this.exportDataMenuItem});
			// 
			// showWhoAllocatedMenuItem
			// 
			this.showWhoAllocatedMenuItem.Index = 0;
			this.showWhoAllocatedMenuItem.Text = "Show Who Allocated";
			this.showWhoAllocatedMenuItem.Click += new System.EventHandler(this.showWhoAllocatedMenuItem_Click);
			// 
			// exportDataMenuItem
			// 
			this.exportDataMenuItem.Index = 1;
			this.exportDataMenuItem.Text = "Export Data to File...";
			this.exportDataMenuItem.Click += new System.EventHandler(this.exportMenuItem_Click);
			// 
			// exportSaveFileDialog
			// 
			this.exportSaveFileDialog.FileName = "doc1";
			// 
			// versionTimer
			// 
			this.versionTimer.Enabled = true;
			this.versionTimer.Tick += new System.EventHandler(this.versionTimer_Tick);
			// 
			// AgeHistogram
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(952, 637);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.typeLegendOuterPanel,
																		  this.splitter1,
																		  this.graphOuterPanel,
																		  this.panel1});
			this.Name = "AgeHistogram";
			this.Text = "Histogram by Age for Live Objects";
			this.panel1.ResumeLayout(false);
			this.timeScaleGroupBox.ResumeLayout(false);
			this.verticalScaleGroupBox.ResumeLayout(false);
			this.graphOuterPanel.ResumeLayout(false);
			this.typeLegendOuterPanel.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		LiveObjectTable liveObjectTable;

		const int leftMargin = 30;
		int bottomMargin = 50;
		const int gap = 20;
		int bucketWidth = 50;
		const int topMargin = 30;
		const int rightMargin = 30;
		const int minHeight = 400;

		double timeScale;
		int verticalScale;

		private double GetTimeScale(double suggestedScale)
		{
			// If a radio button is already checked, return its scale
			foreach (RadioButton rb in timeScaleGroupBox.Controls)
			{
				if (rb.Checked)
				{
					return double.Parse(rb.Text);
				}
			}

			// Otherwise, try to find the lowest scale that is still at least as
			// large as the suggested scale. If there's no such thing, return the highest scale.
			double bestHigherScale = double.PositiveInfinity;
			RadioButton bestHigherRadioButton = null;
			double bestLowerScale = 0.0;
			RadioButton bestLowerRadioButton = null;

			foreach (RadioButton rb in timeScaleGroupBox.Controls)
			{
				double scale = double.Parse(rb.Text);
				if (scale >= suggestedScale)
				{
					if (scale < bestHigherScale)
					{
						bestHigherScale = scale;
						bestHigherRadioButton = rb;
					}
				}
				else
				{
					if (scale > bestLowerScale)
					{
						bestLowerScale = scale;
						bestLowerRadioButton = rb;
					}
				}
			}

			if (bestHigherRadioButton != null)
			{
				bestHigherRadioButton.Checked = true;
				return bestHigherScale;
			}
			else
			{
				Debug.Assert(bestLowerRadioButton != null);
				bestLowerRadioButton.Checked = true;
				return bestLowerScale;
			}
		}

		class TypeDesc : IComparable
		{
			internal string	typeName;
			internal int totalSize;
			internal Color color;
			internal Brush brush;
			internal Pen pen;
			internal bool selected;
			internal Rectangle rect;

			internal TypeDesc(string typeName)
			{
				this.typeName = typeName;
			}

			public int CompareTo(Object o)
			{
				TypeDesc t = (TypeDesc)o;
				return t.totalSize - this.totalSize;
			}
		}

		TypeDesc[] typeIndexToTypeDesc;

		struct Bucket
		{
			internal int totalSize;
			internal Hashtable typeDescToSizeCount;
			internal bool selected;
		}

		private class SizeCount
		{
			internal int size;
			internal int count;
		}

		private Bucket[] bucketTable;

		private ArrayList sortedTypeTable;
		int totalSize;

		private int BuildBuckets(double timeScale, double maxAge)
		{
			int bucketCount = (int)Math.Ceiling(maxAge/timeScale);
			if (bucketTable == null || bucketTable.Length != bucketCount)
			{
				bucketTable = new Bucket[bucketCount];
				for (int i = 0; i < bucketTable.Length; i++)
				{
					bucketTable[i].totalSize = 0;
					bucketTable[i].typeDescToSizeCount = new Hashtable();
				}

				if (typeIndexToTypeDesc == null || typeIndexToTypeDesc.Length < liveObjectTable.readNewLog.typeName.Length)
					typeIndexToTypeDesc = new TypeDesc[liveObjectTable.readNewLog.typeName.Length];
				else
				{
					foreach (TypeDesc t in typeIndexToTypeDesc)
					{
						if (t != null)
							t.totalSize = 0;
					}
				}
				double nowTime = liveObjectTable.readNewLog.TickIndexToTime(liveObjectTable.lastTickIndex);
				LiveObjectTable.LiveObject o;
				for (liveObjectTable.GetNextObject(0, int.MaxValue, out o); o.id < int.MaxValue; liveObjectTable.GetNextObject(o.id + o.size, int.MaxValue, out o))
				{
					double allocTime = liveObjectTable.readNewLog.TickIndexToTime(o.allocTickIndex);
					double age = nowTime - allocTime;
					int bucketIndex = (int)(age/timeScale);
					bucketTable[bucketIndex].totalSize += o.size;
					TypeDesc t = typeIndexToTypeDesc[o.typeIndex];
					if (t == null)
					{
						t = new TypeDesc(liveObjectTable.readNewLog.typeName[o.typeIndex]);
						typeIndexToTypeDesc[o.typeIndex] = t;
					}
					t.totalSize += o.size;
					SizeCount sizeCount = (SizeCount)bucketTable[bucketIndex].typeDescToSizeCount[t];
					if (sizeCount == null)
					{
						sizeCount = new SizeCount();
						bucketTable[bucketIndex].typeDescToSizeCount[t] = sizeCount;
					}
					sizeCount.size += o.size;
					sizeCount.count += 1;
				}
			}

			int maxBucketSize = 0;
			foreach (Bucket b in bucketTable)
			{
				if (maxBucketSize < b.totalSize)
					maxBucketSize = b.totalSize;
			}

			totalSize = 0;
			sortedTypeTable = new ArrayList();
			foreach (TypeDesc t in typeIndexToTypeDesc)
			{
				if (t != null)
				{
					sortedTypeTable.Add(t);
					totalSize += t.totalSize;
				}
			}

			sortedTypeTable.Sort();

			return maxBucketSize;
		}

		int GetScale(GroupBox groupBox, int pixelsAvailable, int rangeNeeded)
		{
			foreach (RadioButton rb in groupBox.Controls)
			{
				if (rb.Checked)
					return Int32.Parse(rb.Text);
			}
			// No radio button was checked - let's come up with a suitable default
			RadioButton maxLowScaleRB = null;
			int maxLowRange = 0;
			RadioButton minHighScaleRB = null;
			int minHighRange = Int32.MaxValue;
			foreach (RadioButton rb in groupBox.Controls)
			{
				int range = pixelsAvailable*Int32.Parse(rb.Text);
				if (range < rangeNeeded)
				{
					if (maxLowRange < range)
					{
						maxLowRange = range;
						maxLowScaleRB = rb;
					}
				}
				else
				{
					if (minHighRange > range)
					{
						minHighRange = range;
						minHighScaleRB = rb;
					}
				}
			}
			if (minHighScaleRB != null)
			{
				minHighScaleRB.Checked = true;
				return Int32.Parse(minHighScaleRB.Text);
			}
			else
			{
				maxLowScaleRB.Checked = true;
				return Int32.Parse(maxLowScaleRB.Text);
			}
		}

		int GetVerticalScale(int pixelsAvailable, int rangeNeeded)
		{
			return GetScale(verticalScaleGroupBox, pixelsAvailable, rangeNeeded);
		}
		static Color[] firstColors =
		{
			Color.Red,
			Color.Yellow,
			Color.Green,
			Color.Cyan,
			Color.Blue,
			Color.Magenta,
		};

		static Color[] colors = new Color[16];

		Color MixColor(Color a, Color b)
		{
			int R = (a.R + b.R)/2;
			int G = (a.G + b.G)/2;
			int B = (a.B + b.B)/2;

			return Color.FromArgb(R, G, B);
		}

		static void GrowColors()
		{
			Color[] newColors = new Color[2*colors.Length];
			for (int i = 0; i < colors.Length; i++)
				newColors[i] = colors[i];
			colors = newColors;
		}

		private TypeDesc FindSelectedType()
		{
			foreach (TypeDesc t in sortedTypeTable)
				if (t.selected)
					return t;
			return null;
		}

		private void ColorTypes()
		{
			int count = 0;

			bool anyTypeSelected = FindSelectedType() != null;

			foreach (TypeDesc t in sortedTypeTable)
			{
				if (count >= colors.Length)
					GrowColors();
				if (count < firstColors.Length)
					colors[count] = firstColors[count];
				else
					colors[count] = MixColor(colors[count - firstColors.Length], colors[count - firstColors.Length + 1]);
				t.color = colors[count];
				if (anyTypeSelected)
					t.color = MixColor(colors[count], Color.White);
				t.brush = new SolidBrush(t.color);
				t.pen = new Pen(t.brush);
				count++;
			}
		}

		string FormatSize(int size)
		{
			double w = size;
			string byteString = "bytes";
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "kB";
			}
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "MB";
			}
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "GB";
			}
			string format = "{0:f0} {1}";
			if (w < 10)
				format = "{0:f1} {1}";
			return string.Format(format, w, byteString);
		}

		private string FormatTime(double time)
		{
			if (timeScale < 0.1)
				return string.Format("{0:f2}", time);
			else if (timeScale < 1.0)
				return string.Format("{0:f1}", time);
			else
				return string.Format("{0:f0}", time);
		}

		private void DrawBuckets(Graphics g)
		{
			bool noBucketSelected = true;
			foreach (Bucket b in bucketTable)
			{
				if (b.selected)
				{
					noBucketSelected = false;
					break;
				}
			}
			int x = leftMargin;
			double time = 0;
			Brush blackBrush = new SolidBrush(Color.Black);
			foreach (Bucket b in bucketTable)
			{
				int y = graphPanel.Height - bottomMargin;
				time += timeScale;
				string s = string.Format("< {0} sec", FormatTime(time));
				g.DrawString(s, font, blackBrush, x, y);
				s = FormatSize(b.totalSize);
				g.DrawString(s, font, blackBrush, x, y + font.Height);

				foreach (DictionaryEntry d in b.typeDescToSizeCount)
				{
					TypeDesc t = (TypeDesc)d.Key;
					SizeCount sizeCount = (SizeCount)d.Value;
					int height = sizeCount.size/verticalScale;
					y -= height;
					Brush brush = t.brush;
					if (t.selected && (b.selected || noBucketSelected))
						brush = blackBrush;
					g.FillRectangle(brush, x, y, bucketWidth, height);
				}

				x += bucketWidth + gap;
			}
		}

		private int BucketWidth(Graphics g)
		{
			int width1 = (int)g.MeasureString("< 999 sec", font).Width;
			int width2 = (int)g.MeasureString("999 MB", font).Width;
			width1 = Math.Max(width1, width2);
			return Math.Max(width1, bucketWidth);
		}

		private int BottomMargin()
		{
			return font.Height*2 + 10;
		}

		private int Init(Graphics g)
		{
			bucketWidth = BucketWidth(g);
			bottomMargin = BottomMargin();
			double maxAge = liveObjectTable.readNewLog.TickIndexToTime(liveObjectTable.lastTickIndex);
			int barsVisible = (graphOuterPanel.Width - leftMargin - rightMargin)/(bucketWidth + gap);
			timeScale = maxAge/barsVisible;

			timeScale = GetTimeScale(timeScale);

			int maxBucketSize = BuildBuckets(timeScale, maxAge);
			
			ColorTypes();

			return maxBucketSize;
		}

		private bool initialized;

		private void graphPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			initialized = false;

			if (liveObjectTable == null)
				return;

			Graphics g = e.Graphics;

			int maxBucketSize = Init(g);

			int pixelsForBars = graphOuterPanel.Height - topMargin - bottomMargin;

			verticalScale = GetVerticalScale(pixelsForBars, maxBucketSize/1024)*1024;

			int bucketCount = bucketTable.Length;
			int width = leftMargin + bucketWidth*bucketCount + gap*(bucketCount-1) + rightMargin;
			graphPanel.Width = width;

			int height = topMargin + maxBucketSize/verticalScale + bottomMargin;
			graphPanel.Height = height;

			DrawBuckets(g);

			initialized = true;
		}

		const int typeLegendSpacing = 3;
		int dotSize = 8;

		private void DrawTypeLegend(Graphics g)
		{
			dotSize = (int)g.MeasureString("0", font).Width;
			int maxWidth = 0;
			int x = leftMargin;
			int y = topMargin;
			foreach (TypeDesc t in sortedTypeTable)
			{
				int typeNameWidth = (int)g.MeasureString(t.typeName, font).Width;
				int sizeWidth = (int)g.MeasureString(" (999,999,999 bytes, 100.00%)", font).Width;
				t.rect = new Rectangle(x, y, Math.Max(typeNameWidth, sizeWidth)+dotSize*2, font.Height*2);
				if (maxWidth < t.rect.Width)
					maxWidth = t.rect.Width;
				y = t.rect.Bottom + typeLegendSpacing;
			}
			int height = y + bottomMargin;
			typeLegendPanel.Height = height;

			int width = leftMargin + maxWidth + rightMargin;
			typeLegendPanel.Width = width;

			x = leftMargin;
			y = topMargin;

			Brush blackBrush = new SolidBrush(Color.Black);

			int dotOffset = (font.Height - dotSize)/2;
			foreach (TypeDesc t in sortedTypeTable)
			{
				Brush brush = t.brush;
				if (t.selected)
					brush = blackBrush;
				g.FillRectangle(brush, t.rect.Left, t.rect.Top+dotOffset, dotSize, dotSize);
				g.DrawString(t.typeName, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top);
				string s = string.Format(" ({0:n0} bytes, {1:f2}%)", t.totalSize, (double)t.totalSize/totalSize*100.0);
				g.DrawString(s, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top + font.Height);
				y = t.rect.Bottom + typeLegendSpacing;
			}
		}

		private void typeLegendPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			initialized = false;

			if (liveObjectTable == null)
				return;

			Init(e.Graphics);

			DrawTypeLegend(e.Graphics);
		}

		private void CheckedChanged(object sender, System.EventArgs e)
		{
			graphPanel.Invalidate();
		}

		private void typeLegendPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (!initialized)
				return;

			if ((e.Button & MouseButtons.Left) != MouseButtons.None)
			{
				for (int i = 0; i < bucketTable.Length; i++)
				{
					if (bucketTable[i].selected)
					{
						graphPanel.Invalidate();
						typeLegendPanel.Invalidate();
						bucketTable[i].selected = false;
					}
				}
				if (sortedTypeTable != null)
				{
					foreach (TypeDesc t in sortedTypeTable)
					{
						if (t.rect.Contains(e.X, e.Y) != t.selected)
						{
							t.selected = !t.selected;
							graphPanel.Invalidate();
							typeLegendPanel.Invalidate();
						}
					}
				}
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(typeLegendPanel, p);
			}
		}

		private void graphPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (!initialized)
				return;

			if ((e.Button & MouseButtons.Left) != MouseButtons.None)
			{
				if (sortedTypeTable != null)
				{
					foreach (TypeDesc t in sortedTypeTable)
						t.selected = false;
				}

				int x = leftMargin;
				for (int i = 0; i < bucketTable.Length; i++)
				{
					bucketTable[i].selected = false;
					int y = graphPanel.Height - bottomMargin;
					foreach (TypeDesc t in bucketTable[i].typeDescToSizeCount.Keys)
					{
						SizeCount sizeCount = (SizeCount)bucketTable[i].typeDescToSizeCount[t];
						int size = sizeCount.size;
						int height = size / verticalScale;

						y -= height;

						Rectangle r = new Rectangle(x, y, bucketWidth, height);
						if (r.Contains(e.X, e.Y))
						{
							t.selected = true;
							bucketTable[i].selected = true;
						}
					}

					x += bucketWidth + gap;
				}		
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(graphPanel, p);
			}
		}

		private ToolTip toolTip;

		private void graphPanel_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (!initialized)
				return;

			int x = leftMargin;
			foreach (Bucket b in bucketTable)
			{
				int y = graphPanel.Height - bottomMargin;
				foreach (DictionaryEntry d in b.typeDescToSizeCount)
				{
					TypeDesc t = (TypeDesc)d.Key;
					SizeCount sizeCount = (SizeCount)d.Value;
					int size = sizeCount.size;
					int height = size / verticalScale;

					y -= height;

					Rectangle bucketRect = new Rectangle(x, y, bucketWidth, height);
					if (bucketRect.Contains(e.X, e.Y))
					{
						string caption = string.Format("{0} {1} ({2:f2}%) - {3:n0} instances, {4} average size", t.typeName, FormatSize(size), 100.0*size/totalSize, sizeCount.count, FormatSize(sizeCount.size/sizeCount.count));
						toolTip.Active = true;
						toolTip.SetToolTip(graphPanel, caption);
						return;
					}
				}
				x += bucketWidth + gap;
			}
			toolTip.Active = false;
			toolTip.SetToolTip(graphPanel, "");
		}

		private bool autoUpdate;

		private void versionTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			ReadLogResult readLogResult = Form1.instance.lastLogResult;

			if (autoUpdate && readLogResult != null && readLogResult.liveObjectTable != liveObjectTable)
			{
				liveObjectTable = readLogResult.liveObjectTable;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}		
		}

		private void exportMenuItem_Click(object sender, System.EventArgs e)
		{
			exportSaveFileDialog.FileName = "HistogramByAge.csv";
			exportSaveFileDialog.Filter = "Comma separated files | *.csv";
			if (exportSaveFileDialog.ShowDialog() == DialogResult.OK)
			{
				StreamWriter w = new StreamWriter(exportSaveFileDialog.FileName);

				TypeDesc selectedType = FindSelectedType();

				string title = "Histogram by Age";
				if (selectedType != null)
					title += " of " + selectedType.typeName + " objects";

				w.WriteLine(title);
				w.WriteLine();

				w.WriteLine("{0},{1},{2},{3},{4}", "Min Age", "Max Age", "# Instances", "Total Size", "Type");

				bool noBucketSelected = true;
				foreach (Bucket b in bucketTable)
					if (b.selected)
						noBucketSelected = false;
				double age = 0.0;
				foreach (Bucket b in bucketTable)
				{
					if (noBucketSelected || b.selected)
					{
						foreach (DictionaryEntry d in b.typeDescToSizeCount)
						{
							TypeDesc t = (TypeDesc)d.Key;
							SizeCount sizeCount = (SizeCount)d.Value;

							if (selectedType == null || t == selectedType)
								w.WriteLine("{0},{1},{2},{3},{4}", FormatTime(age), FormatTime(age + timeScale), sizeCount.count, sizeCount.size, t.typeName);
						}
					}
					age += timeScale;
				}

				w.Close();
			}
		}

		private void showWhoAllocatedMenuItem_Click(object sender, System.EventArgs e)
		{
			Histogram selectedHistogram;
			string title;
			TypeDesc selectedType = FindSelectedType();
			double minAge = 0;
			double maxAge = double.PositiveInfinity;
			double age = 0;
			foreach (Bucket b in bucketTable)
			{
				if (b.selected)
				{
					minAge = age;
					maxAge = age + timeScale;
				}
				age += timeScale;
			}
			title = "Allocation Graph for objects";
			if (selectedType != null)
				title = string.Format("Allocation Graph for {0} objects", selectedType.typeName);
			if (minAge > 0.0)
				title += string.Format(" of age between {0} and {1} seconds", FormatTime(minAge), FormatTime(maxAge));
			selectedHistogram = new Histogram(liveObjectTable.readNewLog);
			LiveObjectTable.LiveObject o;
			double nowTime = liveObjectTable.readNewLog.TickIndexToTime(liveObjectTable.lastTickIndex);
			for (liveObjectTable.GetNextObject(0, int.MaxValue, out o); o.id < int.MaxValue; liveObjectTable.GetNextObject(o.id + o.size, int.MaxValue, out o))
			{
				age = nowTime - liveObjectTable.readNewLog.TickIndexToTime(o.allocTickIndex);
				if (minAge <= age && age < maxAge)
				{
					TypeDesc t = (TypeDesc)typeIndexToTypeDesc[o.typeIndex];
				
					if (selectedType == null || t == selectedType)
					{
						selectedHistogram.AddObject(o.typeSizeStacktraceIndex, 1);
					}
				}
			}

			Graph graph = selectedHistogram.BuildAllocationGraph();

			GraphViewForm graphViewForm = new GraphViewForm(graph, title);
			graphViewForm.Visible = true;
		}

		private void versionTimer_Tick(object sender, System.EventArgs e)
		{
			if (font != Form1.instance.font)
			{
				font = Form1.instance.font;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\graph.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//#define whatever
namespace AllocationProfiler
{
    using System;
	using System.Collections;
	using System.Diagnostics;

    /// <summary>
    ///    Summary description for Graph.
    /// </summary>
    public class Graph
    {
		internal object graphSource;
		internal Hashtable vertices;
		Vertex topVertex;
		Vertex bottomVertex;
		internal enum GraphType
		{
			AllocationGraph,
			CallGraph,
			HeapGraph,
		};
		internal GraphType graphType;
		internal Vertex TopVertex
		{
			get
			{
				return topVertex;
			}
		}

		internal Vertex BottomVertex
		{
			get
			{
				return bottomVertex;
			}
		}

        public Graph(object graphSource)
        {
			this.graphSource = graphSource;
			vertices = new Hashtable();
			topVertex = FindOrCreateVertex("<root>", null);
			bottomVertex = FindOrCreateVertex("<bottom>", null);
        }

		public Vertex FindOrCreateVertex(string name, string signature)
		{
			string nameAndSignature = name;
			if (signature != null)
                nameAndSignature += signature;
			Vertex vertex = (Vertex)vertices[nameAndSignature];
			if (vertex == null)
			{
				vertex = new Vertex(name, signature);
				vertices[nameAndSignature] = vertex;
			}
			return vertex;
		}

		public Edge FindOrCreateEdge(Vertex fromVertex, Vertex toVertex)
		{
			Debug.Assert(fromVertex != topVertex || toVertex != bottomVertex);
			return fromVertex.FindOrCreateOutgoingEdge(toVertex);
		}
#if whatever
		public void AssignLevelsToVertices()
		{
			foreach (Vertex v in vertices.Values)
			{
				v.level = Int32.MaxValue;
				if (   v != topVertex
					&& v != bottomVertex
					&& v.incomingEdges.Count == 0
					&& v.outgoingEdges.Count != 0)
					topVertex.FindOrCreateOutgoingEdge(v);
			}
			topVertex.AssignLevel(0);
			int maxLevel = 0;
			foreach (Vertex v in vertices.Values)
			{
				if (v.level != Int32.MaxValue && maxLevel < v.level)
				{
					maxLevel = v.level;
				}
			}

			bottomVertex.level = maxLevel + 1;

			if (!this.isCallGraph)
			{
				// line up all the class names in one level
				foreach (Edge e in bottomVertex.incomingEdges.Values)
				{
					e.FromVertex.level = maxLevel;
				}

				// this pass optimizes the layout somewhat
				// so we have fewer back edges
				// the idea is to move vertices to the left, if doing so creates no
				// new back edges, but possibly removes some
				bool change;
				do
				{
					change = false;
					foreach (Vertex v in vertices.Values)
					{
						int minOutgoingLevel = Int32.MaxValue;
						foreach (Edge e in v.outgoingEdges.Values)
						{
							if (minOutgoingLevel > e.ToVertex.level)
								minOutgoingLevel = e.ToVertex.level;
						}
						if (minOutgoingLevel < Int32.MaxValue && minOutgoingLevel - 1 > v.level)
						{
							v.level = minOutgoingLevel - 1;
							change = true;
						}
					}
				}
				while (change);
			}
		}	
#else
		public void AssignLevelsToVertices()
		{
			const int UNASSIGNED_LEVEL = Int32.MaxValue/2;
			foreach (Vertex v in vertices.Values)
			{
				v.level = UNASSIGNED_LEVEL;
				if (   v != topVertex
					&& v != bottomVertex)
				{
					if (   v.incomingEdges.Count == 0
						&& v.outgoingEdges.Count != 0)
						topVertex.FindOrCreateOutgoingEdge(v);
					else if (v.incomingEdges.Count != 0
						&& v.outgoingEdges.Count == 0)
						v.FindOrCreateOutgoingEdge(bottomVertex);
				}
			}
			topVertex.level = 0;
			bottomVertex.level = Int32.MaxValue;

			while (true)
			{
				int assignedVertexCount = 0;
				foreach (Vertex v in vertices.Values)
				{
					// If the vertex already has a level, we're done
					if (v.level != UNASSIGNED_LEVEL)
						continue;

					// It the vertex is only called by vertices
					// that have a level, we assign this vertex
					// one more than the max of the callers.
					int maxIncomingLevel = 0;
					foreach (Edge e in v.incomingEdges.Values)
					{
						if (maxIncomingLevel < e.FromVertex.level)
							maxIncomingLevel = e.FromVertex.level;
					}
					if (maxIncomingLevel < UNASSIGNED_LEVEL)
					{
						v.level = maxIncomingLevel + 1;
						assignedVertexCount++;
						continue;
					}

					// If the callees all have levels assigned,
					// we assign this vertex one less than
					// the min of the callees.
					int minOutgoingLevel = Int32.MaxValue;
					foreach (Edge e in v.outgoingEdges.Values)
					{
						if (minOutgoingLevel > e.ToVertex.level)
							minOutgoingLevel = e.ToVertex.level;
					}
					if (minOutgoingLevel > UNASSIGNED_LEVEL)
					{
						v.level = minOutgoingLevel - 1;
						assignedVertexCount++;
						continue;
					}
				}
				
				// If we made progress, continue.
				if (assignedVertexCount > 0)
					continue;

				// There are no more easy vertices.
				// Among the ones remaining (if any), choose one
				// with dependencies on assigned vertices,
				// with minimum input dependencies, and among those
				// the one with maximum output dependencies.
				// This minimizes the number of back edges for this
				// vertex and maximizes the number of unblocked vertices.

				Vertex bestVertex = null;
				int minInputCount = Int32.MaxValue;
				int maxOutputCount = 0;
				foreach (Vertex v in vertices.Values)
				{
					if (v.level != UNASSIGNED_LEVEL)
						continue;
					int assignedInputCount = 0;
					int unAssignedInputCount = 0;
					foreach (Edge e in v.incomingEdges.Values)
					{
						if (e.FromVertex.level == UNASSIGNED_LEVEL)
							unAssignedInputCount++;
						else
							assignedInputCount++;
					}
					if (assignedInputCount == 0)
						continue;
					int unAssignedOutputCount = 0;
					foreach (Edge e in v.outgoingEdges.Values)
					{
						if (e.ToVertex.level == UNASSIGNED_LEVEL)
							unAssignedOutputCount++;
					}
					if (   unAssignedInputCount <  minInputCount
						|| unAssignedInputCount == minInputCount && unAssignedOutputCount > maxOutputCount)
					{
						bestVertex = v;
						minInputCount = unAssignedInputCount;
						maxOutputCount = unAssignedOutputCount;
					}
				}
				// If we couldn't find a vertex, we are done.
				if (bestVertex == null)
					break;
				int maxInputLevel = 0;
				foreach (Edge e in bestVertex.incomingEdges.Values)
				{
					if (   e.FromVertex.level != UNASSIGNED_LEVEL
						&& e.FromVertex.level > maxInputLevel)
						maxInputLevel = e.FromVertex.level;
				}
				bestVertex.level = maxInputLevel + 1;
			}
			// Now every vertex should have a level.
			// Reassign the high vertices.
			int reassignedVertexCount;
			int notReassignableVertexCount;
			do
			{
				reassignedVertexCount = 0;
				notReassignableVertexCount = 0;
				foreach (Vertex v in vertices.Values)
				{
					if (v.level < UNASSIGNED_LEVEL)
						continue;
					int maxInputLevel = 0;
					foreach (Edge e in v.incomingEdges.Values)
					{
						if (maxInputLevel < e.FromVertex.level)
							maxInputLevel = e.FromVertex.level;
					}
					if (maxInputLevel < UNASSIGNED_LEVEL)
					{
						v.level = maxInputLevel + 1;
						reassignedVertexCount++;
					}
					else
					{
						notReassignableVertexCount++;
					}
				}
			}
			while (reassignedVertexCount > 0);
			Debug.Assert(notReassignableVertexCount == 0);

			int maxLevel = 0;
			foreach (Vertex v in vertices.Values)
			{
				if (v != bottomVertex)
				{
					if (maxLevel < v.level)
						maxLevel = v.level;
				}
			}

			bottomVertex.level = maxLevel + 1;

			// line up all the leaf nodes in one level
			foreach (Edge e in bottomVertex.incomingEdges.Values)
			{
				Vertex v = e.FromVertex;
				if (v.outgoingEdges.Count == 1)
					e.FromVertex.level = maxLevel;
			}
		}
#endif
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\killprocessform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for KillProcessForm.
	/// </summary>
	public class KillProcessForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label3;
		internal System.Windows.Forms.Label processFileNameLabel;
		private System.Windows.Forms.Button yesButton;
		private System.Windows.Forms.Button noButton;
		private System.Windows.Forms.Button cancelButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public KillProcessForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.processFileNameLabel = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.yesButton = new System.Windows.Forms.Button();
			this.noButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Arial", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(40, 32);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(264, 23);
			this.label1.TabIndex = 0;
			this.label1.Text = "The process you are profiling is still running:";
			// 
			// processFileNameLabel
			// 
			this.processFileNameLabel.Font = new System.Drawing.Font("Arial", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.processFileNameLabel.Location = new System.Drawing.Point(48, 64);
			this.processFileNameLabel.Name = "processFileNameLabel";
			this.processFileNameLabel.Size = new System.Drawing.Size(368, 32);
			this.processFileNameLabel.TabIndex = 1;
			this.processFileNameLabel.Text = "<profiled process>";
			// 
			// label3
			// 
			this.label3.Font = new System.Drawing.Font("Arial", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(48, 112);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(328, 23);
			this.label3.TabIndex = 2;
			this.label3.Text = "Do you want to terminate it and optionally save the profile?";
			// 
			// yesButton
			// 
			this.yesButton.DialogResult = System.Windows.Forms.DialogResult.Yes;
			this.yesButton.Location = new System.Drawing.Point(48, 152);
			this.yesButton.Name = "yesButton";
			this.yesButton.Size = new System.Drawing.Size(88, 23);
			this.yesButton.TabIndex = 3;
			this.yesButton.Text = "Yes";
			// 
			// noButton
			// 
			this.noButton.DialogResult = System.Windows.Forms.DialogResult.No;
			this.noButton.Location = new System.Drawing.Point(192, 152);
			this.noButton.Name = "noButton";
			this.noButton.TabIndex = 4;
			this.noButton.Text = "No";
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(320, 152);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.TabIndex = 5;
			this.cancelButton.Text = "Cancel";
			// 
			// KillProcessForm
			// 
			this.AcceptButton = this.yesButton;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(456, 205);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.cancelButton,
																		  this.noButton,
																		  this.yesButton,
																		  this.label3,
																		  this.processFileNameLabel,
																		  this.label1});
			this.Name = "KillProcessForm";
			this.Text = "Kill Process?";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)
	echo This is needed to avoid a syntax error when processing this file. :-(


!if "$(TARGETCOMPLUS)" != ""
# Copy the files to the target COM+ directory
	copy $(COOL_TARGET) $(TARGETCOMPLUS)\int_tools
!endif

$(O)\Version.cs: Version.pp $(CORBASE)\src\inc\version\__file__.ver
	cl /EP /C $(COOL_EXTRA_PREPROCESS_FLAGS) /DCOOL_INCLUDE Version.pp > $(O)\Version.cs

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.exe=.pdb)
MANAGED_PDB_DESTINATION=$(TARGETCOMPLUS)\int_tools
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\graphviewform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using System.Globalization;
using System.Text;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for GraphViewForm.
	/// </summary>
	public class GraphViewForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Panel graphPanel;
		private System.Windows.Forms.RadioButton radioButton1;
		private System.Windows.Forms.GroupBox scaleGroupBox;
		private System.Windows.Forms.RadioButton radioButton2;
		private System.Windows.Forms.RadioButton radioButton3;
		private System.Windows.Forms.RadioButton radioButton4;
		private System.Windows.Forms.RadioButton radioButton5;
		private System.Windows.Forms.RadioButton radioButton6;
		private System.Windows.Forms.RadioButton radioButton7;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.RadioButton radioButton8;
		private System.Windows.Forms.RadioButton radioButton9;
		private System.Windows.Forms.RadioButton radioButton10;
		private System.Windows.Forms.RadioButton radioButton11;
		private System.Windows.Forms.RadioButton radioButton12;
		private System.Windows.Forms.RadioButton radioButton13;
		private System.Windows.Forms.RadioButton radioButton14;
		private System.Windows.Forms.RadioButton radioButton15;
		private System.Windows.Forms.RadioButton radioButton16;
		private System.Windows.Forms.ContextMenu contextMenu;
		private System.Windows.Forms.MenuItem pruneContextMenuItem;
		private System.Windows.Forms.MenuItem selectRecursiveMenuItem;
		private System.Windows.Forms.MenuItem copyContextMenuItem;
		private System.Windows.Forms.Timer versionTimer;
		private System.ComponentModel.IContainer components;

		private Graph graph;
		private Font font;
		private int fontHeight;
		private float scale = 1.0f;
		private bool placeVertices = true;
		private bool placeEdges = true;
		private Point lastMouseDownPoint;
		private Point lastMousePoint;
		private ArrayList levelList;
		private int totalWeight;
		private Vertex selectedVertex;
		private System.Windows.Forms.Panel outerPanel;
		private System.Windows.Forms.MenuItem filterMenuItem;
		private System.Windows.Forms.MenuItem selectAllMenuItem;
		private System.Windows.Forms.MenuItem findMenuItem;
		private ToolTip toolTip;

		public GraphViewForm(Graph graph, string title)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			toolTip = new ToolTip();
			toolTip.Active = false;
			toolTip.ShowAlways = true;
			toolTip.InitialDelay = 1;
			toolTip.ReshowDelay = 1;

			this.graph = graph;

			font = Form1.instance.font;
			fontHeight = font.Height;

			Text = title;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.panel1 = new System.Windows.Forms.Panel();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.radioButton16 = new System.Windows.Forms.RadioButton();
			this.radioButton15 = new System.Windows.Forms.RadioButton();
			this.radioButton14 = new System.Windows.Forms.RadioButton();
			this.radioButton13 = new System.Windows.Forms.RadioButton();
			this.radioButton12 = new System.Windows.Forms.RadioButton();
			this.radioButton11 = new System.Windows.Forms.RadioButton();
			this.radioButton10 = new System.Windows.Forms.RadioButton();
			this.radioButton9 = new System.Windows.Forms.RadioButton();
			this.radioButton8 = new System.Windows.Forms.RadioButton();
			this.scaleGroupBox = new System.Windows.Forms.GroupBox();
			this.radioButton7 = new System.Windows.Forms.RadioButton();
			this.radioButton6 = new System.Windows.Forms.RadioButton();
			this.radioButton5 = new System.Windows.Forms.RadioButton();
			this.radioButton4 = new System.Windows.Forms.RadioButton();
			this.radioButton3 = new System.Windows.Forms.RadioButton();
			this.radioButton2 = new System.Windows.Forms.RadioButton();
			this.radioButton1 = new System.Windows.Forms.RadioButton();
			this.outerPanel = new System.Windows.Forms.Panel();
			this.graphPanel = new System.Windows.Forms.Panel();
			this.contextMenu = new System.Windows.Forms.ContextMenu();
			this.pruneContextMenuItem = new System.Windows.Forms.MenuItem();
			this.selectRecursiveMenuItem = new System.Windows.Forms.MenuItem();
			this.selectAllMenuItem = new System.Windows.Forms.MenuItem();
			this.copyContextMenuItem = new System.Windows.Forms.MenuItem();
			this.filterMenuItem = new System.Windows.Forms.MenuItem();
			this.findMenuItem = new System.Windows.Forms.MenuItem();
			this.versionTimer = new System.Windows.Forms.Timer(this.components);
			this.panel1.SuspendLayout();
			this.groupBox1.SuspendLayout();
			this.scaleGroupBox.SuspendLayout();
			this.outerPanel.SuspendLayout();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.groupBox1,
																				 this.scaleGroupBox});
			this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(896, 80);
			this.panel1.TabIndex = 0;
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					this.radioButton16,
																					this.radioButton15,
																					this.radioButton14,
																					this.radioButton13,
																					this.radioButton12,
																					this.radioButton11,
																					this.radioButton10,
																					this.radioButton9,
																					this.radioButton8});
			this.groupBox1.Location = new System.Drawing.Point(432, 16);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(448, 48);
			this.groupBox1.TabIndex = 2;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Detail";
			// 
			// radioButton16
			// 
			this.radioButton16.Location = new System.Drawing.Point(360, 16);
			this.radioButton16.Name = "radioButton16";
			this.radioButton16.Size = new System.Drawing.Size(80, 24);
			this.radioButton16.TabIndex = 8;
			this.radioButton16.Text = "20 (coarse)";
			this.radioButton16.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton15
			// 
			this.radioButton15.Location = new System.Drawing.Point(320, 16);
			this.radioButton15.Name = "radioButton15";
			this.radioButton15.Size = new System.Drawing.Size(40, 24);
			this.radioButton15.TabIndex = 7;
			this.radioButton15.Text = "10";
			this.radioButton15.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton14
			// 
			this.radioButton14.Location = new System.Drawing.Point(288, 16);
			this.radioButton14.Name = "radioButton14";
			this.radioButton14.Size = new System.Drawing.Size(32, 24);
			this.radioButton14.TabIndex = 6;
			this.radioButton14.Text = "5";
			this.radioButton14.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton13
			// 
			this.radioButton13.Location = new System.Drawing.Point(256, 16);
			this.radioButton13.Name = "radioButton13";
			this.radioButton13.Size = new System.Drawing.Size(32, 24);
			this.radioButton13.TabIndex = 5;
			this.radioButton13.Text = "2";
			this.radioButton13.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton12
			// 
			this.radioButton12.Checked = true;
			this.radioButton12.Location = new System.Drawing.Point(224, 16);
			this.radioButton12.Name = "radioButton12";
			this.radioButton12.Size = new System.Drawing.Size(24, 24);
			this.radioButton12.TabIndex = 4;
			this.radioButton12.TabStop = true;
			this.radioButton12.Text = "1";
			this.radioButton12.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton11
			// 
			this.radioButton11.Location = new System.Drawing.Point(184, 16);
			this.radioButton11.Name = "radioButton11";
			this.radioButton11.Size = new System.Drawing.Size(40, 24);
			this.radioButton11.TabIndex = 3;
			this.radioButton11.Text = "0.5";
			this.radioButton11.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton10
			// 
			this.radioButton10.Location = new System.Drawing.Point(144, 16);
			this.radioButton10.Name = "radioButton10";
			this.radioButton10.Size = new System.Drawing.Size(40, 24);
			this.radioButton10.TabIndex = 2;
			this.radioButton10.Text = "0.2";
			this.radioButton10.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton9
			// 
			this.radioButton9.Location = new System.Drawing.Point(104, 16);
			this.radioButton9.Name = "radioButton9";
			this.radioButton9.Size = new System.Drawing.Size(40, 24);
			this.radioButton9.TabIndex = 1;
			this.radioButton9.Text = "0.1";
			this.radioButton9.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// radioButton8
			// 
			this.radioButton8.Location = new System.Drawing.Point(8, 16);
			this.radioButton8.Name = "radioButton8";
			this.radioButton8.Size = new System.Drawing.Size(96, 24);
			this.radioButton8.TabIndex = 0;
			this.radioButton8.Text = "0 (everything)";
			this.radioButton8.CheckedChanged += new System.EventHandler(this.detailRadioButton_Click);
			// 
			// scaleGroupBox
			// 
			this.scaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																						this.radioButton7,
																						this.radioButton6,
																						this.radioButton5,
																						this.radioButton4,
																						this.radioButton3,
																						this.radioButton2,
																						this.radioButton1});
			this.scaleGroupBox.Location = new System.Drawing.Point(16, 16);
			this.scaleGroupBox.Name = "scaleGroupBox";
			this.scaleGroupBox.Size = new System.Drawing.Size(400, 48);
			this.scaleGroupBox.TabIndex = 1;
			this.scaleGroupBox.TabStop = false;
			this.scaleGroupBox.Text = "Scale";
			// 
			// radioButton7
			// 
			this.radioButton7.Location = new System.Drawing.Point(304, 16);
			this.radioButton7.Name = "radioButton7";
			this.radioButton7.Size = new System.Drawing.Size(88, 24);
			this.radioButton7.TabIndex = 6;
			this.radioButton7.Text = "1000 (huge)";
			this.radioButton7.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// radioButton6
			// 
			this.radioButton6.Location = new System.Drawing.Point(256, 16);
			this.radioButton6.Name = "radioButton6";
			this.radioButton6.Size = new System.Drawing.Size(44, 24);
			this.radioButton6.TabIndex = 5;
			this.radioButton6.Text = "500";
			this.radioButton6.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// radioButton5
			// 
			this.radioButton5.Location = new System.Drawing.Point(208, 16);
			this.radioButton5.Name = "radioButton5";
			this.radioButton5.Size = new System.Drawing.Size(44, 24);
			this.radioButton5.TabIndex = 4;
			this.radioButton5.Text = "200";
			this.radioButton5.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// radioButton4
			// 
			this.radioButton4.Checked = true;
			this.radioButton4.Location = new System.Drawing.Point(160, 16);
			this.radioButton4.Name = "radioButton4";
			this.radioButton4.Size = new System.Drawing.Size(44, 24);
			this.radioButton4.TabIndex = 3;
			this.radioButton4.TabStop = true;
			this.radioButton4.Text = "100";
			this.radioButton4.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// radioButton3
			// 
			this.radioButton3.Location = new System.Drawing.Point(120, 16);
			this.radioButton3.Name = "radioButton3";
			this.radioButton3.Size = new System.Drawing.Size(40, 24);
			this.radioButton3.TabIndex = 2;
			this.radioButton3.Text = "50";
			this.radioButton3.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// radioButton2
			// 
			this.radioButton2.Location = new System.Drawing.Point(80, 16);
			this.radioButton2.Name = "radioButton2";
			this.radioButton2.Size = new System.Drawing.Size(40, 24);
			this.radioButton2.TabIndex = 1;
			this.radioButton2.Text = "20";
			this.radioButton2.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// radioButton1
			// 
			this.radioButton1.Location = new System.Drawing.Point(16, 16);
			this.radioButton1.Name = "radioButton1";
			this.radioButton1.Size = new System.Drawing.Size(64, 24);
			this.radioButton1.TabIndex = 0;
			this.radioButton1.Text = "10 (tiny)";
			this.radioButton1.CheckedChanged += new System.EventHandler(this.scaleRadioButton_Click);
			// 
			// outerPanel
			// 
			this.outerPanel.BackColor = System.Drawing.Color.White;
			this.outerPanel.Controls.AddRange(new System.Windows.Forms.Control[] {
																					 this.graphPanel});
			this.outerPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			this.outerPanel.Location = new System.Drawing.Point(0, 80);
			this.outerPanel.Name = "outerPanel";
			this.outerPanel.Size = new System.Drawing.Size(896, 565);
			this.outerPanel.TabIndex = 1;
			// 
			// graphPanel
			// 
			this.graphPanel.Name = "graphPanel";
			this.graphPanel.Size = new System.Drawing.Size(864, 528);
			this.graphPanel.TabIndex = 0;
			this.graphPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.graphPanel_Paint);
			this.graphPanel.MouseMove += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseMove);
			this.graphPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseDown);
			// 
			// contextMenu
			// 
			this.contextMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																						this.pruneContextMenuItem,
																						this.selectRecursiveMenuItem,
																						this.selectAllMenuItem,
																						this.copyContextMenuItem,
																						this.filterMenuItem,
																						this.findMenuItem});
			// 
			// pruneContextMenuItem
			// 
			this.pruneContextMenuItem.Index = 0;
			this.pruneContextMenuItem.Text = "Prune to callers && callees";
			this.pruneContextMenuItem.Click += new System.EventHandler(this.pruneMenuItem_Click);
			// 
			// selectRecursiveMenuItem
			// 
			this.selectRecursiveMenuItem.Index = 1;
			this.selectRecursiveMenuItem.Text = "Select callers && callees";
			this.selectRecursiveMenuItem.Click += new System.EventHandler(this.selectRecursiveMenuItem_Click);
			// 
			// selectAllMenuItem
			// 
			this.selectAllMenuItem.Index = 2;
			this.selectAllMenuItem.Shortcut = System.Windows.Forms.Shortcut.CtrlA;
			this.selectAllMenuItem.Text = "Select All";
			this.selectAllMenuItem.Click += new System.EventHandler(this.selectAllMenuItem_Click);
			// 
			// copyContextMenuItem
			// 
			this.copyContextMenuItem.Index = 3;
			this.copyContextMenuItem.Shortcut = System.Windows.Forms.Shortcut.CtrlC;
			this.copyContextMenuItem.Text = "Copy as text to clipboard";
			this.copyContextMenuItem.Click += new System.EventHandler(this.copyMenuItem_Click);
			// 
			// filterMenuItem
			// 
			this.filterMenuItem.Index = 4;
			this.filterMenuItem.Text = "Filter...";
			this.filterMenuItem.Click += new System.EventHandler(this.filterMenuItem_Click);
			// 
			// findMenuItem
			// 
			this.findMenuItem.Index = 5;
			this.findMenuItem.Shortcut = System.Windows.Forms.Shortcut.CtrlF;
			this.findMenuItem.Text = "Find routine...";
			this.findMenuItem.Click += new System.EventHandler(this.findMenuItem_Click);
			// 
			// versionTimer
			// 
			this.versionTimer.Enabled = true;
			this.versionTimer.Tick += new System.EventHandler(this.versionTimer_Tick);
			// 
			// GraphViewForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(896, 645);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.outerPanel,
																		  this.panel1});
			this.Name = "GraphViewForm";
			this.Text = "GraphViewForm";
			this.panel1.ResumeLayout(false);
			this.groupBox1.ResumeLayout(false);
			this.scaleGroupBox.ResumeLayout(false);
			this.outerPanel.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		void PaintVertex(Vertex v, Graphics g, Brush penBrush, Pen pen)
		{
			Rectangle r = v.rectangle;
			v.selectionRectangle = r;
			g.DrawRectangle(pen, r);
			if (v.selected)
			{
				using (SolidBrush selectBrush = new SolidBrush(Color.Aqua))
					g.FillRectangle(selectBrush, r);
			}

			RectangleF stringRect;
			int lineCount = 2;
			if (v.signature != null)
				lineCount = 3;
			if (r.Height > fontHeight*lineCount)
				stringRect = new RectangleF(r.X,r.Y,r.Width,fontHeight);
			else
			{
				stringRect = new RectangleF(r.X,r.Y+r.Height+3,r.Width,fontHeight);
				v.selectionRectangle = new Rectangle(r.X, r.Y, r.Width, r.Height + 3 + fontHeight*lineCount);
			}

			if (v.weightHistory != null)
			{
				int alpha = 200;
				int previousHeight = r.Height;
				for (int i = 0; i < v.weightHistory.Length; i++)
				{
					alpha = alpha*2/3;
					int weight = v.weightHistory[i];
					int height = (int)((float)r.Height/v.weight*weight);
					if (height < previousHeight)
					{
						Color color = Color.FromArgb(alpha, Color.Red);
						using (Brush brush = new SolidBrush(color))
						{
							g.FillRectangle(brush, r.X, r.Y+height, r.Width, previousHeight - height);
						}
					}
					else
					{
						Color color = Color.FromArgb(alpha, Color.Green);
						using (Brush brush = new SolidBrush(color))
						{
							g.FillRectangle(brush, r.X, r.Y+previousHeight, r.Width, height - previousHeight);
						}
					}
					previousHeight = height;
				}
			}

			g.DrawString(v.basicName, font, penBrush, stringRect);
			stringRect.Y += fontHeight;
			if (v.signature != null)
			{
				g.DrawString(v.basicSignature, font, penBrush, stringRect);
				stringRect.Y += fontHeight;
				int width = (int)g.MeasureString(v.basicSignature, font).Width;
				if (stringRect.Width < width)
					v.signatureCurtated = true;
			}

			g.DrawString(v.weightString, font, penBrush, stringRect);
		}

		ArrayList BuildLevels(Graph g)
		{
			ArrayList al = new ArrayList();
			for (int level = 0; level <= g.BottomVertex.level; level++)
			{
				al.Add(new ArrayList());
			}
			foreach (Vertex v in g.vertices.Values)
			{
				if (v.level <= g.BottomVertex.level)
				{
					ArrayList all = (ArrayList)al[v.level];
					all.Add(v);
				}
				else
				{
					Debug.Assert(v.level == int.MaxValue);
				}
			}
			foreach (ArrayList all in al)
			{
				all.Sort();
			}
			return al;
		}

		void PlaceEdges(ICollection edgeCollection, bool isIncoming, int x, int y, float scale)
		{
			ArrayList edgeList = new ArrayList(edgeCollection);
			edgeList.Sort();
			float fy = y;
			foreach (Edge e in edgeList)
			{
				float fwidth = e.weight*scale;
				Point p = new Point(x, (int)(fy + fwidth/2));
				if (isIncoming)
				{
					e.toPoint = p;
				}
				else
				{
					e.fromPoint = p;
				}
				fy += fwidth;
			}
		}

		void PlaceEdges(float scale)
		{
			foreach (Vertex v in graph.vertices.Values)
			{
				PlaceEdges(v.incomingEdges.Values, true, v.rectangle.X, v.rectangle.Y, scale);
				int y = v.rectangle.Y + (int)(v.basicWeight*scale);
				PlaceEdges(v.outgoingEdges.Values, false, v.rectangle.X + v.rectangle.Width, y, scale);
			}
		}

		int totalHeight = 100;
		const int boxWidth = 300;
		int gapWidth = 100;
		float minHeight = 1.0f;
		float minWidth = 1.0f;

		void DrawEdges(Graphics g, float scale)
		{
			Random r = new Random(0);
			Point[] points = new Point[4];
			foreach (Vertex v in graph.vertices.Values)
			{
				foreach (Edge e in v.outgoingEdges.Values)
				{
					if (e.ToVertex != graph.BottomVertex
						&& !e.fromPoint.IsEmpty && !e.toPoint.IsEmpty)
					{
						int colorInt = r.Next(255*256*256);
						int red = (colorInt >> 16) & 255;
						int green = (colorInt >> 8) & 255;
						int blue = colorInt & 255;
						Brush brush = null;
						if (e.selected)
						{
							Color foreColor = Color.FromArgb(150, 0, 255, 0);
							Color backColor = Color.FromArgb(150, 255, 0, 0);
							brush = new HatchBrush(HatchStyle.DiagonalCross, foreColor, backColor);
						}
						else if (e.brush != null)
						{
							brush = e.brush;
						}
						else
						{
							if (red <= green && red <= blue)
								red = 0;
							else if (green <= blue && green <= red)
								green = 0;
							else if (blue <= red && blue <= green)
								blue = 0;
							Color color = Color.FromArgb(100, red, green, blue);
							Debug.Assert(!color.IsEmpty);
							brush = new SolidBrush(color);
							e.brush = brush;
						}
						Debug.Assert(brush != null);
						float fWidth = e.weight*scale;
						if (fWidth > minWidth && e.FromVertex.active && e.ToVertex.active)
						{
							int iWidth = (int)fWidth;
							if (iWidth < 1)
								iWidth = 1;
							e.width = iWidth;
							Pen pen = e.pen;
							if (pen == null || pen.Width != iWidth || e.selected)
							{
								pen = new Pen(brush, iWidth);
								if (!e.selected)
									e.pen = pen;
							}
							Debug.Assert(pen != null);
							int deltaX = e.toPoint.X - e.fromPoint.X;
							int deltaY = e.toPoint.Y - e.fromPoint.Y;
							deltaX = deltaX/4;
							deltaY = deltaY/9;
							int deltaY1 =   deltaY;
							int deltaY2 = - deltaY;
							if (deltaX < 0)
							{
								deltaX = 20;
								if (Math.Abs(deltaY)*5 < iWidth*2)
								{
									deltaY1 = deltaY2 = iWidth*2;
									deltaX = iWidth;
								}
							}
							points[0] = e.fromPoint;
							points[1] = new Point(e.fromPoint.X + deltaX, e.fromPoint.Y + deltaY1);
							points[2] = new Point(e.  toPoint.X - deltaX, e.  toPoint.Y + deltaY2);
							points[3] = e.toPoint;
							g.DrawCurve(pen, points);
							//						g.DrawLine(pen, e.fromPoint, e.toPoint);
							red = (red + 17) % 256;
							green = (green + 101) % 256;
							blue = (blue + 29) % 256;
						}
					}
				}
			}
		}

		string formatWeight(int weight)
		{
			if (graph.graphType == Graph.GraphType.CallGraph)
			{
				if (weight == 1)
					return "1 call";
				else
					return string.Format("{0} calls", weight);
			}
			else
			{
				double w = weight;
				string byteString = "bytes";
				if (w >= 1024)
				{
					w /= 1024;
					byteString = "kB   ";
				}
				if (w >= 1024)
				{
					w /= 1024;
					byteString = "MB   ";
				}
				if (w >= 1024)
				{
					w /= 1024;
					byteString = "GB   ";
				}
				string format = "{0,4:f0} {1} ({2:f2}%)";
				if (w < 10)
					format = "{0,4:f1} {1} ({2:f2}%)";
				return string.Format(format, w, byteString, weight*100.0/totalWeight);
			}
		}

		void PlaceVertices(Graphics g)
		{
			graph.AssignLevelsToVertices();
			totalWeight = 0;
			foreach (Vertex v in graph.vertices.Values)
			{
				v.weight = v.incomingWeight;
				if (v.weight < v.outgoingWeight)
					v.weight = v.outgoingWeight;
				if (graph.graphType == Graph.GraphType.CallGraph)
				{
					if (totalWeight < v.weight)
						totalWeight = v.weight;
				}
			}
			if (graph.graphType != Graph.GraphType.CallGraph)
				totalWeight = graph.TopVertex.weight;
			if (totalWeight == 0)
			{
				totalWeight = 1;
			}

			ArrayList al = levelList = BuildLevels(graph);
			scale = (float)totalHeight/totalWeight;
			if (placeVertices)
			{
				int x = 10;
				int maxY = 0;
				for (int level = graph.TopVertex.level;
					level <= graph.BottomVertex.level;
					level++)
				{
					ArrayList all = (ArrayList)al[level];
					int drawnVertexCount = 0;
					int maxWidth = 0;
					foreach (Vertex v in all)
					{
						if (graph.graphType == Graph.GraphType.CallGraph)
						{
							v.basicWeight = v.incomingWeight - v.outgoingWeight;
							if (v.basicWeight < 0)
								v.basicWeight = 0;
							v.weightString = string.Format("Gets {0}, causes {1}",
								formatWeight(v.basicWeight),
								formatWeight(v.outgoingWeight));
						}
						else
						{
							if (v.count == 0)
								v.weightString = formatWeight(v.weight);
							else if (v.count == 1)
								v.weightString = string.Format("{0}  (1 object, {1})", formatWeight(v.weight), formatWeight(v.basicWeight));
							else
								v.weightString = string.Format("{0}  ({1} objects, {2})", formatWeight(v.weight), v.count, formatWeight(v.basicWeight));
						}
						if (v.weight*scale > minHeight)
						{
							int width = (int)g.MeasureString(v.basicName, font).Width;
							if (maxWidth < width)
								maxWidth = width;

							width = (int)g.MeasureString(v.weightString, font).Width;
							if (maxWidth < width)
								maxWidth = width;
						}
					}
					int y = 10;
					int levelWeight = 0;
					foreach (Vertex v in all)
						levelWeight += v.weight;
					float levelHeight = levelWeight*scale;
					if (levelHeight < totalHeight*0.5)
						y+= (int)((totalHeight - levelHeight)*2);
					foreach (Vertex v in all)
					{
						// For the in-between vertices, sometimes it's good
						// to shift them down a little to line them up with
						// whatever is going into them. Unless of course
						// we would need to shift too much...
						if (v.level < graph.BottomVertex.level-1)
						{
							int highestWeight = 0;
							int bestY = 0;
							foreach (Edge e in v.incomingEdges.Values)
							{
								if (e.weight > highestWeight && e.FromVertex.level < level)
								{
									highestWeight = e.weight;
									bestY = e.fromPoint.Y - (int)(e.weight*scale*0.5);
								}
							}
							if (y < bestY && bestY < totalHeight*5)
								y = bestY;
						}
						float fHeight = v.weight*scale;
						int iHeight = (int)fHeight;
						if (iHeight < 1)
							iHeight = 1;
						v.rectangle = new Rectangle(x, y, maxWidth+5, iHeight);
						if (placeEdges)
							PlaceEdges(v.outgoingEdges.Values, false, v.rectangle.X + v.rectangle.Width, v.rectangle.Y, scale);
						if (fHeight <= minHeight || !v.active)
						{
							v.visible = false;
							v.rectangle = v.selectionRectangle = new Rectangle(0,0,0,0);
						}
						else
						{
							v.visible = true;
							y += iHeight;
							int lines = 2;
							if (v.signature != null)
								lines = 3;
							if (iHeight <= fontHeight*lines)
								y += fontHeight*lines + 3;
							y += 30;
							drawnVertexCount++;
						}
					}
					if (drawnVertexCount > 0)
					{
						x += maxWidth + gapWidth;
						if (maxY < y)
							maxY = y;
					}
				}
				if (x < Size.Width)
					x = Size.Width;
				if (maxY < Size.Height)
					maxY = Size.Height;
				graphPanel.Size = new System.Drawing.Size (x, maxY);
			}
			if (placeEdges)
				PlaceEdges(scale);
		}

		private void graphPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			outerPanel.AutoScroll = true;
			Graphics g = e.Graphics;
			if (placeVertices || placeEdges)
			{
				PlaceVertices(g);
				placeVertices = placeEdges = false;
			}
			//			Brush brush = new SolidBrush(Color.Gray);
			//			g.FillRectangle(brush, graphPanel.ClientRectangle);
			using (SolidBrush penBrush = new SolidBrush(Color.Blue))
			{
				using (Pen pen = new Pen(penBrush, 1))
				{
					foreach (Vertex v in graph.vertices.Values)
					{
						if (v.visible)
							PaintVertex(v, g, penBrush, pen);
					}
				}
			}
			DrawEdges(g, scale);
		}

		private void scaleRadioButton_Click(object sender, System.EventArgs e)
		{
			RadioButton clickedRadioButton = (RadioButton)sender;
			string scaleString = clickedRadioButton.Text.Split(' ')[0];
			totalHeight = gapWidth = Convert.ToInt32(scaleString);
			placeVertices = placeEdges = true;
			graphPanel.Invalidate();
		}

		private void detailRadioButton_Click(object sender, System.EventArgs e)
		{
			RadioButton clickedRadioButton = (RadioButton)sender;
			string detailString = clickedRadioButton.Text.Split(' ')[0];
			minWidth = minHeight = Convert.ToSingle(detailString, CultureInfo.InvariantCulture);
			placeVertices = placeEdges = true;
			graphPanel.Invalidate();
		}

		private void selectVertex(Vertex v, bool nowSelected)
		{
			v.selected = nowSelected;
			graphPanel.Invalidate();
		}

		private void selectEdges()
		{
			foreach (Vertex v in graph.vertices.Values)
				foreach (Edge e in v.outgoingEdges.Values)
					e.selected = false;

			foreach (Vertex v in graph.vertices.Values)
			{
				if (v.selected)
				{
					foreach (Edge e in v.outgoingEdges.Values)
						e.selected = true;
					foreach (Edge e in v.incomingEdges.Values)
						e.selected = true;
				}
			}
		}

		private void selectLevel(Vertex v)
		{
			// Simple semantics for now - select/delect whole level
			bool nowSelected = !v.selected;
			foreach (Vertex vv in graph.vertices.Values)
			{
				if (vv.level == v.level)
				{
					if (nowSelected != vv.selected)
						selectVertex(vv, nowSelected);
				}
			}
		}

		private void selectIncoming(Vertex v)
		{
			if (v.selected)
				return;
			v.selected = true;
			foreach (Edge e in v.incomingEdges.Values)
			{
				e.selected = true;
				selectIncoming(e.FromVertex);
			}
		}

		private void selectOutgoing(Vertex v)
		{
			if (v.selected)
				return;
			v.selected = true;
			foreach (Edge e in v.outgoingEdges.Values)
			{
				e.selected = true;
				selectOutgoing(e.ToVertex);
			}
		}

		private void selectRecursive(Vertex v)
		{
			foreach (Vertex vv in graph.vertices.Values)
			{
				vv.selected = false;
				foreach (Edge e in vv.incomingEdges.Values)
					e.selected = false;
				foreach (Edge e in vv.outgoingEdges.Values)
					e.selected = false;
			}

			v.selected = true;
			
			foreach (Edge e in v.incomingEdges.Values)
			{
				e.selected = true;
				selectIncoming(e.FromVertex);
			}
			foreach (Edge e in v.outgoingEdges.Values)
			{
				e.selected = true;
				selectOutgoing(e.ToVertex);
			}
		}

		private void graphPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			Point p = new Point(e.X, e.Y);
			lastMouseDownPoint = p;
			if ((e.Button & MouseButtons.Left) != 0)
			{
				foreach (Vertex v in graph.vertices.Values)
				{
					bool nowSelected;
					if ((Control.ModifierKeys & Keys.Control) != 0)
					{
						if ((Control.ModifierKeys & Keys.Shift) != 0)
						{
							if (v.selectionRectangle.Contains(p))
							{
								selectRecursive(v);
								graphPanel.Invalidate();
								return;
							}
							else
								continue;
						}
						else
							nowSelected = v.selected != v.selectionRectangle.Contains(p);
					}
					else if ((Control.ModifierKeys & Keys.Shift) != 0)
					{
						if (v.selectionRectangle.Contains(p))
						{
							selectLevel(v);
							break;
						}
						else
							nowSelected = v.selected;
					}
					else
						nowSelected = v.selectionRectangle.Contains(p);
					if (nowSelected != v.selected)
						selectVertex(v, nowSelected);
				}
				selectEdges();
			}
			else if ((e.Button & MouseButtons.Right) != 0)
			{
				selectedVertex = null;
				foreach (Vertex v in graph.vertices.Values)
				{
					if (v.selectionRectangle.Contains(p))
					{
						selectedVertex = v;
						break;
					}
				}
				contextMenu.Show(graphPanel, p);
			}
		}

		private void graphPanel_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			Point p = new Point(e.X, e.Y);
			if (distance(p, lastMousePoint) >= 10)
			{
				toolTip.Active = false;
			}
			lastMousePoint = p;
			if ((e.Button & MouseButtons.Left) != 0)
			{
				foreach (Vertex v in graph.vertices.Values)
				{
					if (v.selected)
					{
						v.rectangle.X += p.X - lastMouseDownPoint.X;
						v.rectangle.Y += p.Y - lastMouseDownPoint.Y;
						lastMouseDownPoint = p;
						placeEdges = true;
						graphPanel.Invalidate();
					}
				}
			}
			else if (e.Button == MouseButtons.None)
			{
				foreach (Vertex v in graph.vertices.Values)
				{
					if (v.selectionRectangle.Contains(lastMousePoint))
					{
						string caption;
						if (v.signatureCurtated)
							caption = v.signature;
						else
							caption = v.name;
						if (caption != v.basicName)
						{
							toolTip.Active = true;
							toolTip.SetToolTip(graphPanel, caption);
						}
						break;
					}
					foreach (Edge edge in v.incomingEdges.Values)
					{
						if (distance(lastMousePoint, edge.toPoint) < edge.width)
						{
							edgePopup(edge, false);
							return;
						}
					}

					foreach (Edge edge in v.outgoingEdges.Values)
					{
						if (distance(lastMousePoint, edge.fromPoint) < edge.width)
						{
							edgePopup(edge, true);
							return;
						}
					}
				}
			}
		}

		private void copyMenuItem_Click(object sender, System.EventArgs e)
		{
			StringBuilder sb = new StringBuilder();
			int selectedCount = 0;
			Vertex selectedVertex = null;
			foreach (Vertex v in graph.vertices.Values)
			{
				if (v.selected)
				{
					selectedCount++;
					selectedVertex = v;
				}
			}

			if (selectedCount == 1)
			{
				Vertex v = selectedVertex;
				string signature = v.signature != null ? v.signature : "";
				sb.AppendFormat("{0} {1}:\t{2}\r\n", v.name, signature, v.weightString);

				if (graph.graphType == Graph.GraphType.HeapGraph)
					sb.Append("\r\nReferred to by:\r\n");
				else
					sb.Append("\r\nContributions from callers:\r\n");

				ArrayList callers = new ArrayList();
				foreach (Edge edge in v.incomingEdges.Values)
					callers.Add(edge);
				callers.Sort();
				foreach (Edge edge in callers)
				{
					Vertex vv = edge.FromVertex;
					string signature1 = vv.signature != null ? vv.signature : "";
					string explain = "from";
					if (graph.graphType == Graph.GraphType.CallGraph)
						explain = "caused by";
					sb.AppendFormat("\t{0} {1}\t{2}\t{3}\r\n", formatWeight(edge.weight), explain, vv.name, signature1);
				}

				if (graph.graphType == Graph.GraphType.HeapGraph)
					sb.Append("\r\nReferring to:\r\n");
				else
					sb.Append("\r\nContributions to callees:\r\n");

				ArrayList callees = new ArrayList();
				foreach (Edge edge in v.outgoingEdges.Values)
					callees.Add(edge);
				callees.Sort();
				foreach (Edge edge in callees)
				{
					Vertex vv = edge.ToVertex;
					string signature2 = vv.signature != null ? vv.signature : "";
					string explain = "to";
					if (graph.graphType == Graph.GraphType.CallGraph)
						explain = "caused by";
					sb.AppendFormat("\t{0} {1}\t{2}\t{3}\r\n", formatWeight(edge.weight), explain, vv.name, signature2);
				}
			}
			else
			{
				foreach (ArrayList al in levelList)
				{
					foreach (Vertex v in al)
					{
						if (v.selected)
						{
							for (int i = 0; i < v.level; i++)
								sb.Append(" ");
							sb.AppendFormat("{0}:\t{1}\r\n", v.name, v.weightString);
						}
					}
				}
			}
			Clipboard.SetDataObject(sb.ToString());
		}

		private void selectAllMenuItem_Click(object sender, System.EventArgs e)
		{
			foreach (Vertex v in graph.vertices.Values)
			{
				if (!v.selected)
				{
					graphPanel.Invalidate(v.rectangle);
					v.selected = true;
				}
			}
		}
		private double distance(Point p1, Point p2)
		{
			int deltaX = p1.X - p2.X;
			int deltaY = p1.Y - p2.Y;
			return Math.Sqrt(deltaX*deltaX + 4.0*deltaY*deltaY);
		}

		private void edgePopup(Edge e, bool isOutgoingEdge)
		{
			Vertex v;
			Point p;
			if (isOutgoingEdge)
			{
				p = e.fromPoint;
				v = e.ToVertex;
			}
			else
			{
				p = e.toPoint;
				v = e.FromVertex;
			}
			string caption = v.basicName + ": " + formatWeight(e.weight);
			Rectangle r = new Rectangle(p.X, p.Y, 1, 1);
			r = graphPanel.RectangleToScreen(r);
			Point screenPoint = new Point(r.X, r.Y-20);
			toolTip.Active = true;
			toolTip.SetToolTip(graphPanel, caption);
		}

		private void activateIncoming(Vertex v)
		{
			if (v.active)
				return;
			v.active = true;
			foreach (Edge e in v.incomingEdges.Values)
				activateIncoming(e.FromVertex);
		}

		private void activateOutgoing(Vertex v)
		{
			if (v.active)
				return;
			v.active = true;
			foreach (Edge e in v.outgoingEdges.Values)
				activateOutgoing(e.ToVertex);
		}

		private void prune()
		{
			int selectedVerticesCount = 0;
			foreach (Vertex v in graph.vertices.Values)
				if (v.selected)
					selectedVerticesCount += 1;

			if (selectedVerticesCount == 0)
				return;

			foreach (Vertex v in graph.vertices.Values)
				v.active = false;

			foreach (Vertex v in graph.vertices.Values)
			{
				if (v.selected && !v.active)
				{
					v.active = true;
					foreach (Edge edge in v.incomingEdges.Values)
						activateIncoming(edge.FromVertex);
					foreach (Edge edge in v.outgoingEdges.Values)
						activateOutgoing(edge.ToVertex);
				}
			}
			graph.BottomVertex.active = false;
			graphPanel.Invalidate();
			placeVertices = placeEdges = true;
		}

		private void pruneMenuItem_Click(object sender, System.EventArgs e)
		{
			prune();
		}

		private void filterMenuItem_Click(object sender, System.EventArgs e)
		{
			FilterForm filterForm = new FilterForm();
			if (filterForm.ShowDialog() == DialogResult.OK)
			{
				switch (graph.graphType)
				{
				case	Graph.GraphType.CallGraph:
					graph = ((Histogram)graph.graphSource).BuildCallGraph();
					graph.graphType = Graph.GraphType.CallGraph;
					break;

				case	Graph.GraphType.AllocationGraph:
					graph = ((Histogram)graph.graphSource).BuildAllocationGraph();
					graph.graphType = Graph.GraphType.AllocationGraph;
					break;

				case	Graph.GraphType.HeapGraph:
					graph = ((ObjectGraph)graph.graphSource).BuildTypeGraph();
					graph.graphType = Graph.GraphType.HeapGraph;
					break;
				}
				placeVertices = placeEdges = true;
				graphPanel.Invalidate();
			}
		}

		private void pruneContextMenuItem_Click(object sender, System.EventArgs e)
		{
			if (selectedVertex != null)
			{
				selectedVertex.selected = true;
				prune();
				graphPanel.Invalidate();
			}
		}

		private void selectRecursiveMenuItem_Click(object sender, System.EventArgs e)
		{
			if (selectedVertex != null)
			{
				selectRecursive(selectedVertex);
				graphPanel.Invalidate();
			}
		}

		private void findMenuItem_Click(object sender, System.EventArgs e)
		{
			Form5 findForm = new Form5();
			if (findForm.ShowDialog() == DialogResult.OK)
			{
				Vertex foundVertex = null;
				foreach (Vertex v in graph.vertices.Values)
				{
					if (  v.basicName.IndexOf(findForm.nameTextBox.Text) >= 0
						&&  (v.basicSignature == null
						|| v.basicSignature.IndexOf(findForm.signatureTextBox.Text) >= 0))
					{
						if (v.visible)
						{
							foundVertex = v;
							break;
						}
						if (foundVertex == null)
							foundVertex = v;
					}
				}
				if (foundVertex != null)
				{
					if (foundVertex.visible)
					{
						foreach (Vertex v in graph.vertices.Values)
						{
							v.selected = false;
						}
						foundVertex.selected = true;
						outerPanel.AutoScrollPosition = new Point(foundVertex.rectangle.X - 100, foundVertex.rectangle.Y - 100);
						graphPanel.Invalidate();
					}
					else
					{
						MessageBox.Show("Routine found but not visible with current settings");
					}
				}
				else
				{
					MessageBox.Show("No Routine found");
				}
			}		
		}

		private void versionTimer_Tick(object sender, System.EventArgs e)
		{
			if (font != Form1.instance.font)
			{
				font = Form1.instance.font;
				fontHeight = font.Height;
				placeVertices = placeEdges = true;
				graphPanel.Invalidate();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\namedmanualresetevent.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Runtime.InteropServices;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for NamedManualResetEvent.
	/// </summary>
	public class NamedManualResetEvent
	{
		private IntPtr eventHandle;

		public NamedManualResetEvent(string eventName, bool initialState)
		{
			eventHandle = CreateEvent(IntPtr.Zero, true, initialState, eventName);
			if (eventHandle == IntPtr.Zero)
			{
				eventHandle = OpenEvent(0x00100002, false, eventName);
				if (eventHandle == IntPtr.Zero)
					throw new Exception(string.Format("Couldn't create or open event {0}", eventName));
			}
		}

		~NamedManualResetEvent()
		{
			CloseHandle(eventHandle);
		}

		public bool Reset()
		{
			return ResetEvent(eventHandle);
		}

		public bool Set()
		{
			return SetEvent(eventHandle);
		}

		public bool Wait(int timeOut)
		{
			return WaitForSingleObject(eventHandle, timeOut) == 0;
		}

		[DllImport("Kernel32.dll", CharSet=CharSet.Auto)]
		private static extern IntPtr CreateEvent(IntPtr eventAttributes, bool manualReset, bool initialState, string eventName);

		[DllImport("Kernel32.dll", CharSet=CharSet.Auto)]
		private static extern IntPtr OpenEvent(uint desiredAccess, bool inheritHandle, string eventName);

		[DllImport("Kernel32.dll")]
		private static extern bool ResetEvent(IntPtr eventHandle);

		[DllImport("Kernel32.dll")]
		private static extern bool SetEvent(IntPtr eventHandle);

		[DllImport("Kernel32.dll")]
		private static extern bool CloseHandle(IntPtr eventHandle);

		[DllImport("Kernel32.dll")]
		private static extern int WaitForSingleObject(IntPtr handle, int milliseconds);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\readlog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace AllocationProfiler
{
    using System;
	using System.IO;
	using System.Collections;

    /// <summary>
    ///    Summary description for ReadLog.
    /// </summary>
    public class ReadLog
    {
		Graph	graph;
        public ReadLog(Graph graph)
        {
			this.graph = graph;
        }

		static bool IsStackTraceLine(String s)
		{
			int inx = s.IndexOf("    ");
			return inx >= 8 && inx <= 12;
		}

		public void Readfile(String filename)
		{
			StreamReader r = new StreamReader(filename);
			String curLine;
			ArrayList traceList = new ArrayList();
			curLine = r.ReadLine();
			while	(curLine != null)
			{
				if	(curLine.IndexOf("Allocated") >= 0)
				{
					// Remove stuff we don't want from the allocated line
					curLine = curLine.Substring(curLine.IndexOf("Allocated") + "Allocated".Length);
					String [] curItems = curLine.Split(null);

					// first squeeze out any empty items generated by multiple separators
					int i;
					int itemCount = 0;
					for (i = 0; i < curItems.Length; i++)
					{
						if (curItems[i].Length > 0)
						{
							curItems[itemCount++] = curItems[i];
						}
					}
					for (i = itemCount; i < curItems.Length; i++)
					{
						curItems[i] = null;
					}

					int size = 0;
					i = 0;

					// if there's "REF_TYPE", skip it
					if (curItems[i] == "REF_TYPE")
					{
						i++;
					}

					// if there's the hex address of the object, skip it
					if (   curItems[i].Length >= 2
						&& curItems[i][0] == '0'
						&& curItems[i][1] == 'x')
					{
						i++;
					}

					if (curItems[i].Length > 0 && System.Char.IsDigit(curItems[i][0]))
					{
						size = Int32.Parse(curItems[i]);
						i++;
					}

					if (curItems[i] == "bytes")
					{
						i++;
					}

					if (curItems[i] == "for")
					{
						i++;
					}
					
					traceList.Clear();

					traceList.Add(curItems[i]);

					// Read the stack trace lines and append them to the trace list
					while	((curLine = r.ReadLine()) != null)
					{
						if (curLine.Equals(""))
							continue;
						if (curLine.IndexOf("EE Frame") >= 0)
							continue;
						if (curLine.IndexOf("Allocated") >= 0)
							break;
						int indentInx = curLine.IndexOf("     ");
						if (indentInx < 0 || indentInx > 12)
							break;
						curLine = curLine.Substring(indentInx + 5);
						curLine = curLine.Split(null, 2)[0];
						traceList.Add(curLine);
					}

					AddTrace(traceList, size);
				}
				else
					curLine = r.ReadLine();
			}
		}

		public void AddTrace(ArrayList trace, int weight)
		{
			for (int i = trace.Count; i >= 0; i--)
			{
				string fromVertex = i < trace.Count ? (string)trace[i] : "<root>";
				string toVertex   = i - 1 >= 0 ? (string)trace[i - 1 ] : "<bottom>";
				AddEdge(fromVertex, toVertex, weight);
			}
		}

		public void AddEdge(string fromVertexString, string toVertexString, int weight)
		{
			Vertex fromVertex = graph.FindOrCreateVertex(fromVertexString, null);
			Vertex toVertex = graph.FindOrCreateVertex(toVertexString, null);
			Edge edge = graph.FindOrCreateEdge(fromVertex, toVertex);
			edge.AddWeight(weight);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\histogramviewform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for HistogramViewForm.
	/// </summary>
	public class HistogramViewForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Splitter splitter1;
		private System.Windows.Forms.Panel panel3;
		private System.Windows.Forms.RadioButton radioButton1;
		private System.Windows.Forms.RadioButton radioButton2;
		private System.Windows.Forms.RadioButton radioButton3;
		private System.Windows.Forms.RadioButton radioButton4;
		private System.Windows.Forms.RadioButton radioButton5;
		private System.Windows.Forms.RadioButton radioButton6;
		private System.Windows.Forms.RadioButton radioButton7;
		private System.Windows.Forms.RadioButton radioButton8;
		private System.Windows.Forms.RadioButton radioButton9;
		private System.Windows.Forms.RadioButton radioButton10;
		private System.Windows.Forms.Panel graphPanel;
		private System.Windows.Forms.Panel typeLegendPanel;
		private System.Windows.Forms.GroupBox verticalScaleGroupBox;
		private System.Timers.Timer versionTimer;
		private System.Windows.Forms.GroupBox horizontalScaleGroupBox;
		private System.Windows.Forms.RadioButton coarseRadioButton;
		private System.Windows.Forms.RadioButton veryFineRadioButton;
		private System.Windows.Forms.RadioButton mediumRadioButton;
		private System.Windows.Forms.RadioButton fineRadioButton;
		private System.Windows.Forms.ContextMenu contextMenu;
		private System.Windows.Forms.MenuItem exportMenuItem;
		private System.Windows.Forms.SaveFileDialog exportSaveFileDialog;
		private System.Windows.Forms.MenuItem showWhoAllocatedMenuItem;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		ReadLogResult lastLogResult;

		private Font font;

		public HistogramViewForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			toolTip = new ToolTip();
			toolTip.Active = false;
			toolTip.ShowAlways = true;

			autoUpdate = true;
			lastLogResult = Form1.instance.lastLogResult;

			if (lastLogResult != null)
			{
				histogram = lastLogResult.allocatedHistogram;
				typeName = histogram.readNewLog.typeName;
			}
			Text = "Histogram by Size for Allocated Objects";
			font = Form1.instance.font;
		}

		internal HistogramViewForm(Histogram histogram, string title) : this()
		{
			this.histogram = histogram;
			autoUpdate = false;
			Text = title;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			versionTimer.Stop();
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.panel1 = new System.Windows.Forms.Panel();
			this.horizontalScaleGroupBox = new System.Windows.Forms.GroupBox();
			this.veryFineRadioButton = new System.Windows.Forms.RadioButton();
			this.fineRadioButton = new System.Windows.Forms.RadioButton();
			this.mediumRadioButton = new System.Windows.Forms.RadioButton();
			this.coarseRadioButton = new System.Windows.Forms.RadioButton();
			this.verticalScaleGroupBox = new System.Windows.Forms.GroupBox();
			this.radioButton10 = new System.Windows.Forms.RadioButton();
			this.radioButton9 = new System.Windows.Forms.RadioButton();
			this.radioButton8 = new System.Windows.Forms.RadioButton();
			this.radioButton7 = new System.Windows.Forms.RadioButton();
			this.radioButton6 = new System.Windows.Forms.RadioButton();
			this.radioButton5 = new System.Windows.Forms.RadioButton();
			this.radioButton4 = new System.Windows.Forms.RadioButton();
			this.radioButton3 = new System.Windows.Forms.RadioButton();
			this.radioButton2 = new System.Windows.Forms.RadioButton();
			this.radioButton1 = new System.Windows.Forms.RadioButton();
			this.panel2 = new System.Windows.Forms.Panel();
			this.graphPanel = new System.Windows.Forms.Panel();
			this.splitter1 = new System.Windows.Forms.Splitter();
			this.panel3 = new System.Windows.Forms.Panel();
			this.typeLegendPanel = new System.Windows.Forms.Panel();
			this.versionTimer = new System.Timers.Timer();
			this.contextMenu = new System.Windows.Forms.ContextMenu();
			this.showWhoAllocatedMenuItem = new System.Windows.Forms.MenuItem();
			this.exportMenuItem = new System.Windows.Forms.MenuItem();
			this.exportSaveFileDialog = new System.Windows.Forms.SaveFileDialog();
			this.panel1.SuspendLayout();
			this.horizontalScaleGroupBox.SuspendLayout();
			this.verticalScaleGroupBox.SuspendLayout();
			this.panel2.SuspendLayout();
			this.panel3.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.versionTimer)).BeginInit();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.horizontalScaleGroupBox,
																				 this.verticalScaleGroupBox});
			this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(816, 72);
			this.panel1.TabIndex = 0;
			// 
			// horizontalScaleGroupBox
			// 
			this.horizontalScaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																								  this.veryFineRadioButton,
																								  this.fineRadioButton,
																								  this.mediumRadioButton,
																								  this.coarseRadioButton});
			this.horizontalScaleGroupBox.Location = new System.Drawing.Point(480, 8);
			this.horizontalScaleGroupBox.Name = "horizontalScaleGroupBox";
			this.horizontalScaleGroupBox.Size = new System.Drawing.Size(312, 48);
			this.horizontalScaleGroupBox.TabIndex = 1;
			this.horizontalScaleGroupBox.TabStop = false;
			this.horizontalScaleGroupBox.Text = "Horizontal Scale";
			// 
			// veryFineRadioButton
			// 
			this.veryFineRadioButton.Location = new System.Drawing.Point(232, 16);
			this.veryFineRadioButton.Name = "veryFineRadioButton";
			this.veryFineRadioButton.Size = new System.Drawing.Size(72, 24);
			this.veryFineRadioButton.TabIndex = 3;
			this.veryFineRadioButton.Text = "Very Fine";
			this.veryFineRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fineRadioButton
			// 
			this.fineRadioButton.Location = new System.Drawing.Point(168, 16);
			this.fineRadioButton.Name = "fineRadioButton";
			this.fineRadioButton.Size = new System.Drawing.Size(48, 24);
			this.fineRadioButton.TabIndex = 2;
			this.fineRadioButton.Text = "Fine";
			this.fineRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// mediumRadioButton
			// 
			this.mediumRadioButton.Location = new System.Drawing.Point(88, 16);
			this.mediumRadioButton.Name = "mediumRadioButton";
			this.mediumRadioButton.Size = new System.Drawing.Size(64, 24);
			this.mediumRadioButton.TabIndex = 1;
			this.mediumRadioButton.Text = "Medium";
			this.mediumRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// coarseRadioButton
			// 
			this.coarseRadioButton.Checked = true;
			this.coarseRadioButton.Location = new System.Drawing.Point(16, 16);
			this.coarseRadioButton.Name = "coarseRadioButton";
			this.coarseRadioButton.Size = new System.Drawing.Size(64, 24);
			this.coarseRadioButton.TabIndex = 0;
			this.coarseRadioButton.TabStop = true;
			this.coarseRadioButton.Text = "Coarse";
			this.coarseRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// verticalScaleGroupBox
			// 
			this.verticalScaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																								this.radioButton10,
																								this.radioButton9,
																								this.radioButton8,
																								this.radioButton7,
																								this.radioButton6,
																								this.radioButton5,
																								this.radioButton4,
																								this.radioButton3,
																								this.radioButton2,
																								this.radioButton1});
			this.verticalScaleGroupBox.Location = new System.Drawing.Point(16, 8);
			this.verticalScaleGroupBox.Name = "verticalScaleGroupBox";
			this.verticalScaleGroupBox.Size = new System.Drawing.Size(432, 48);
			this.verticalScaleGroupBox.TabIndex = 0;
			this.verticalScaleGroupBox.TabStop = false;
			this.verticalScaleGroupBox.Text = "Vertical Scale: Kilobytes/Pixel";
			// 
			// radioButton10
			// 
			this.radioButton10.Location = new System.Drawing.Point(376, 16);
			this.radioButton10.Name = "radioButton10";
			this.radioButton10.Size = new System.Drawing.Size(48, 24);
			this.radioButton10.TabIndex = 9;
			this.radioButton10.Text = "1000";
			this.radioButton10.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton9
			// 
			this.radioButton9.Location = new System.Drawing.Point(328, 16);
			this.radioButton9.Name = "radioButton9";
			this.radioButton9.Size = new System.Drawing.Size(48, 24);
			this.radioButton9.TabIndex = 8;
			this.radioButton9.Text = "500";
			this.radioButton9.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton8
			// 
			this.radioButton8.Location = new System.Drawing.Point(280, 16);
			this.radioButton8.Name = "radioButton8";
			this.radioButton8.Size = new System.Drawing.Size(48, 24);
			this.radioButton8.TabIndex = 7;
			this.radioButton8.Text = "200";
			this.radioButton8.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton7
			// 
			this.radioButton7.Location = new System.Drawing.Point(232, 16);
			this.radioButton7.Name = "radioButton7";
			this.radioButton7.Size = new System.Drawing.Size(48, 24);
			this.radioButton7.TabIndex = 6;
			this.radioButton7.Text = "100";
			this.radioButton7.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton6
			// 
			this.radioButton6.Location = new System.Drawing.Point(192, 16);
			this.radioButton6.Name = "radioButton6";
			this.radioButton6.Size = new System.Drawing.Size(40, 24);
			this.radioButton6.TabIndex = 5;
			this.radioButton6.Text = "50";
			this.radioButton6.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton5
			// 
			this.radioButton5.Location = new System.Drawing.Point(152, 16);
			this.radioButton5.Name = "radioButton5";
			this.radioButton5.Size = new System.Drawing.Size(40, 24);
			this.radioButton5.TabIndex = 4;
			this.radioButton5.Text = "20";
			this.radioButton5.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton4
			// 
			this.radioButton4.Location = new System.Drawing.Point(112, 16);
			this.radioButton4.Name = "radioButton4";
			this.radioButton4.Size = new System.Drawing.Size(40, 24);
			this.radioButton4.TabIndex = 3;
			this.radioButton4.Text = "10";
			this.radioButton4.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton3
			// 
			this.radioButton3.Location = new System.Drawing.Point(80, 16);
			this.radioButton3.Name = "radioButton3";
			this.radioButton3.Size = new System.Drawing.Size(32, 24);
			this.radioButton3.TabIndex = 2;
			this.radioButton3.Text = "5";
			this.radioButton3.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton2
			// 
			this.radioButton2.Location = new System.Drawing.Point(48, 16);
			this.radioButton2.Name = "radioButton2";
			this.radioButton2.Size = new System.Drawing.Size(32, 24);
			this.radioButton2.TabIndex = 1;
			this.radioButton2.Text = "2";
			this.radioButton2.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// radioButton1
			// 
			this.radioButton1.Location = new System.Drawing.Point(16, 16);
			this.radioButton1.Name = "radioButton1";
			this.radioButton1.Size = new System.Drawing.Size(24, 24);
			this.radioButton1.TabIndex = 0;
			this.radioButton1.Text = "1";
			this.radioButton1.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// panel2
			// 
			this.panel2.AutoScroll = true;
			this.panel2.BackColor = System.Drawing.SystemColors.Control;
			this.panel2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.panel2.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.graphPanel});
			this.panel2.Dock = System.Windows.Forms.DockStyle.Left;
			this.panel2.Location = new System.Drawing.Point(0, 72);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(592, 501);
			this.panel2.TabIndex = 1;
			// 
			// graphPanel
			// 
			this.graphPanel.BackColor = System.Drawing.SystemColors.Control;
			this.graphPanel.Name = "graphPanel";
			this.graphPanel.Size = new System.Drawing.Size(584, 488);
			this.graphPanel.TabIndex = 0;
			this.graphPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.graphPanel_Paint);
			this.graphPanel.MouseMove += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseMove);
			this.graphPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseDown);
			// 
			// splitter1
			// 
			this.splitter1.Location = new System.Drawing.Point(592, 72);
			this.splitter1.Name = "splitter1";
			this.splitter1.Size = new System.Drawing.Size(3, 501);
			this.splitter1.TabIndex = 2;
			this.splitter1.TabStop = false;
			// 
			// panel3
			// 
			this.panel3.AutoScroll = true;
			this.panel3.BackColor = System.Drawing.SystemColors.Control;
			this.panel3.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.panel3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.typeLegendPanel});
			this.panel3.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel3.Location = new System.Drawing.Point(595, 72);
			this.panel3.Name = "panel3";
			this.panel3.Size = new System.Drawing.Size(221, 501);
			this.panel3.TabIndex = 3;
			// 
			// typeLegendPanel
			// 
			this.typeLegendPanel.BackColor = System.Drawing.SystemColors.Control;
			this.typeLegendPanel.Name = "typeLegendPanel";
			this.typeLegendPanel.Size = new System.Drawing.Size(208, 488);
			this.typeLegendPanel.TabIndex = 0;
			this.typeLegendPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.typeLegendPanel_Paint);
			this.typeLegendPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.typeLegendPanel_MouseDown);
			// 
			// versionTimer
			// 
			this.versionTimer.Enabled = true;
			this.versionTimer.SynchronizingObject = this;
			this.versionTimer.Elapsed += new System.Timers.ElapsedEventHandler(this.versionTimer_Elapsed);
			// 
			// contextMenu
			// 
			this.contextMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																						this.showWhoAllocatedMenuItem,
																						this.exportMenuItem});
			// 
			// showWhoAllocatedMenuItem
			// 
			this.showWhoAllocatedMenuItem.Index = 0;
			this.showWhoAllocatedMenuItem.Text = "Show Who Allocated";
			this.showWhoAllocatedMenuItem.Click += new System.EventHandler(this.showWhoAllocatedMenuItem_Click);
			// 
			// exportMenuItem
			// 
			this.exportMenuItem.Index = 1;
			this.exportMenuItem.Text = "Export Data to File...";
			this.exportMenuItem.Click += new System.EventHandler(this.exportMenuItem_Click);
			// 
			// exportSaveFileDialog
			// 
			this.exportSaveFileDialog.FileName = "doc1";
			// 
			// HistogramViewForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(816, 573);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.panel3,
																		  this.splitter1,
																		  this.panel2,
																		  this.panel1});
			this.Name = "HistogramViewForm";
			this.Text = "HistogramViewForm";
			this.panel1.ResumeLayout(false);
			this.horizontalScaleGroupBox.ResumeLayout(false);
			this.verticalScaleGroupBox.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			this.panel3.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.versionTimer)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		class TypeDesc : IComparable
		{
			internal string	typeName;
			internal int totalSize;
			internal Color color;
			internal Brush brush;
			internal Pen pen;
			internal bool selected;
			internal Rectangle rect;

			internal TypeDesc(string typeName)
			{
				this.typeName = typeName;
			}

			public int CompareTo(Object o)
			{
				TypeDesc t = (TypeDesc)o;
				return t.totalSize - this.totalSize;
			}
		}

		TypeDesc[] typeIndexToTypeDesc;

		ArrayList sortedTypeTable;

		struct Bucket
		{
			internal int minSize;
			internal int maxSize;
			internal int totalSize;
			internal Hashtable typeDescToSizeCount;
			internal bool selected;
		};

		Bucket[] buckets;
		double currentScaleFactor;

		void BuildBuckets()
		{
			double scaleFactor = 2.0;
			if (coarseRadioButton.Checked)
				scaleFactor = 2.0;
			else if (mediumRadioButton.Checked)
				scaleFactor = Math.Sqrt(2.0);
			else if (fineRadioButton.Checked)
				scaleFactor = Math.Pow(2.0, 0.25);
			else if (veryFineRadioButton.Checked)
				scaleFactor = Math.Pow(2.0, 0.125);

			if (currentScaleFactor == scaleFactor)
			{
				for (int i = 0; i < buckets.Length; i++)
				{
					buckets[i].typeDescToSizeCount = new Hashtable();
					buckets[i].totalSize = 0;
				}
				return;
			}

			currentScaleFactor = scaleFactor;

			int count = 0;
			int startSize = 8;
			double minSize;
			for (minSize = startSize; minSize < int.MaxValue; minSize *= scaleFactor)
				count++;

			buckets = new Bucket[count-1];
			minSize = startSize;
			for (int i = 0; i < buckets.Length; i++)
			{
				buckets[i].minSize = (int)Math.Round(minSize);
				minSize *= scaleFactor;
				buckets[i].maxSize = (int)Math.Round(minSize)-1;
				buckets[i].typeDescToSizeCount = new Hashtable();
				buckets[i].selected = false;
			}
		}

		private class SizeCount
		{
			internal int size;
			internal int count;
		}

		void AddToBuckets(TypeDesc t, int size, int count)
		{
			for (int i = 0; i < buckets.Length; i++)
			{
				if (buckets[i].minSize <= size && size <= buckets[i].maxSize)
				{
					int totalSize = size*count;
					buckets[i].totalSize += totalSize;
					SizeCount sizeCount = (SizeCount)buckets[i].typeDescToSizeCount[t];
					if (sizeCount == null)
					{
						sizeCount = new SizeCount();
						buckets[i].typeDescToSizeCount[t] = sizeCount;
					}
					sizeCount.size += totalSize;
					sizeCount.count += count;
					break;
				}
			}
		}

		void TrimEmptyBuckets()
		{
			int lo = 0;
			for (int i = 0; i < buckets.Length-1; i++)
			{
				if (buckets[i].totalSize != 0 || buckets[i+1].totalSize != 0)
					break;
				lo++;
			}
			int hi = buckets.Length-1;
			for (int i = buckets.Length-1; i >= 0; i--)
			{
				if (buckets[i].totalSize != 0)
					break;
				hi--;
			}
			if (lo <= hi)
			{
				Bucket[] newBuckets = new Bucket[hi-lo+1];
				for (int i = lo; i <= hi; i++)
					newBuckets[i-lo] = buckets[i];
				buckets = newBuckets;
			}
		}

		int totalSize;

		void BuildSizeRangesAndTypeTable(int[] typeSizeStacktraceToCount)
		{
			BuildBuckets();

			totalSize = 0;

			if (typeIndexToTypeDesc == null)
				typeIndexToTypeDesc = new TypeDesc[histogram.readNewLog.typeName.Length];
			else
			{
				foreach (TypeDesc t in typeIndexToTypeDesc)
				{
					if (t != null)
						t.totalSize = 0;
				}
			}

			for (int i = 0; i < typeSizeStacktraceToCount.Length; i++)
			{
				int count = typeSizeStacktraceToCount[i];
				if (count == 0)
					continue;

				int[] stacktrace = histogram.readNewLog.stacktraceTable.IndexToStacktrace(i);
				int typeIndex = stacktrace[0];
				int size = stacktrace[1];

				TypeDesc t = (TypeDesc)typeIndexToTypeDesc[typeIndex];
				if (t == null)
				{
					t = new TypeDesc(typeName[typeIndex]);
					typeIndexToTypeDesc[typeIndex] = t;
				}
				t.totalSize += size*count;

				totalSize += size*count;

				AddToBuckets(t, size, count);
			}

			if (totalSize == 0)
				totalSize = 1;

			TrimEmptyBuckets();

			sortedTypeTable = new ArrayList();
			foreach (TypeDesc t in typeIndexToTypeDesc)
				if (t != null)
					sortedTypeTable.Add(t);
			sortedTypeTable.Sort();
		}

		static Color[] firstColors =
		{
			Color.Red,
			Color.Yellow,
			Color.Green,
			Color.Cyan,
			Color.Blue,
			Color.Magenta,
		};

		static Color[] colors = new Color[16];

		Color MixColor(Color a, Color b)
		{
			int R = (a.R + b.R)/2;
			int G = (a.G + b.G)/2;
			int B = (a.B + b.B)/2;

			return Color.FromArgb(R, G, B);
		}

		static void GrowColors()
		{
			Color[] newColors = new Color[2*colors.Length];
			for (int i = 0; i < colors.Length; i++)
				newColors[i] = colors[i];
			colors = newColors;
		}

		private TypeDesc FindSelectedType()
		{
			foreach (TypeDesc t in sortedTypeTable)
				if (t.selected)
					return t;
			return null;
		}

		private void ColorTypes()
		{
			int count = 0;

			bool anyTypeSelected = FindSelectedType() != null;

			foreach (TypeDesc t in sortedTypeTable)
			{
				if (count >= colors.Length)
					GrowColors();
				if (count < firstColors.Length)
					colors[count] = firstColors[count];
				else
					colors[count] = MixColor(colors[count - firstColors.Length], colors[count - firstColors.Length + 1]);
				t.color = colors[count];
				if (anyTypeSelected)
					t.color = MixColor(colors[count], Color.White);
				t.brush = new SolidBrush(t.color);
				t.pen = new Pen(t.brush);
				count++;
			}
		}

		int Scale(GroupBox groupBox, int pixelsAvailable, int rangeNeeded)
		{
			foreach (RadioButton rb in groupBox.Controls)
			{
				if (rb.Checked)
					return Int32.Parse(rb.Text);
			}
			// No radio button was checked - let's come up with a suitable default
			RadioButton maxLowScaleRB = null;
			int maxLowRange = 0;
			RadioButton minHighScaleRB = null;
			int minHighRange = Int32.MaxValue;
			foreach (RadioButton rb in groupBox.Controls)
			{
				int range = pixelsAvailable*Int32.Parse(rb.Text);
				if (range < rangeNeeded)
				{
					if (maxLowRange < range)
					{
						maxLowRange = range;
						maxLowScaleRB = rb;
					}
				}
				else
				{
					if (minHighRange > range)
					{
						minHighRange = range;
						minHighScaleRB = rb;
					}
				}
			}
			if (minHighScaleRB != null)
			{
				minHighScaleRB.Checked = true;
				return Int32.Parse(minHighScaleRB.Text);
			}
			else
			{
				maxLowScaleRB.Checked = true;
				return Int32.Parse(maxLowScaleRB.Text);
			}
		}

		int verticalScale;

		int VerticalScale(int pixelsAvailable, int rangeNeeded)
		{
			return Scale(verticalScaleGroupBox, pixelsAvailable, rangeNeeded/1024)*1024;
		}

		const int leftMargin = 30;
		int bottomMargin = 50;
		const int gap = 20;
		int bucketWidth = 50;
		const int topMargin = 30;
		const int rightMargin = 30;
		const int minHeight = 400;
		int dotSize = 8;

		string FormatSize(int size)
		{
			double w = size;
			string byteString = "bytes";
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "kB";
			}
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "MB";
			}
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "GB";
			}
			string format = "{0:f0} {1}";
			if (w < 10)
				format = "{0:f1} {1}";
			return string.Format(format, w, byteString);
		}

		private void DrawBuckets(Graphics g)
		{
			bool noBucketSelected = true;
			foreach (Bucket b in buckets)
			{
				if (b.selected)
				{
					noBucketSelected = false;
					break;
				}
			}

            using (Brush blackBrush = new SolidBrush(Color.Black))
			{
				int x = leftMargin;
				foreach (Bucket b in buckets)
				{
					string s = "< " + FormatSize(b.maxSize+1);
					int y = graphPanel.Height - bottomMargin;
					g.DrawString(s, font, blackBrush, x, y + 3);
					s = FormatSize(b.totalSize);
					g.DrawString(s, font, blackBrush, x, y + 3 + font.Height);
					s = string.Format("({0:f2}%)", 100.0*b.totalSize/totalSize);
					g.DrawString(s, font, blackBrush, x, y + 3 + font.Height*2);
					foreach (DictionaryEntry d in b.typeDescToSizeCount)
					{
						TypeDesc t = (TypeDesc)d.Key;
						SizeCount sizeCount = (SizeCount)d.Value;
						int size = sizeCount.size;
						int height = size / verticalScale;

						y -= height;

						Brush brush = t.brush;
						if (t.selected && (b.selected || noBucketSelected))
							brush = blackBrush;
						g.FillRectangle(brush, x, y, bucketWidth, height);
					}

					x += bucketWidth + gap;
				}
			}
		}

		const int typeLegendSpacing = 3;

		private void DrawTypeLegend(Graphics g)
		{
			dotSize = (int)g.MeasureString("0", font).Width;
			int maxWidth = 0;
			int x = leftMargin;
			int y = topMargin;
			foreach (TypeDesc t in sortedTypeTable)
			{
				int typeNameWidth = (int)g.MeasureString(t.typeName, font).Width;
				int sizeWidth = (int)g.MeasureString(" (999,999,999 bytes, 100.00%)", font).Width;
				t.rect = new Rectangle(x, y, Math.Max(typeNameWidth, sizeWidth)+dotSize*2, font.Height*2);
				if (maxWidth < t.rect.Width)
					maxWidth = t.rect.Width;
				y = t.rect.Bottom + typeLegendSpacing;
			}
			int height = y + bottomMargin;
			typeLegendPanel.Height = height;

			int width = leftMargin + maxWidth + rightMargin;
			typeLegendPanel.Width = width;

			x = leftMargin;
			y = topMargin;

			Brush blackBrush = new SolidBrush(Color.Black);

			int dotOffset = (font.Height - dotSize)/2;
			foreach (TypeDesc t in sortedTypeTable)
			{
				Brush brush = t.brush;
				if (t.selected)
					brush = blackBrush;
				g.FillRectangle(brush, t.rect.Left, t.rect.Top+dotOffset, dotSize, dotSize);
				g.DrawString(t.typeName, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top);
				string s = string.Format(" ({0:n0} bytes, {1:f2}%)", t.totalSize, (double)t.totalSize/totalSize*100.0);
				g.DrawString(s, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top + font.Height);
				y = t.rect.Bottom + typeLegendSpacing;
			}
		}

		bool initialized = false;

		private Histogram histogram;
		private string[] typeName;

		private int BucketWidth(Graphics g)
		{
			
			int width1 = (int)g.MeasureString("< 999.9 sec", font).Width;
			int width2 = (int)g.MeasureString("999 MB", font).Width;
			width1 = Math.Max(width1, width2);
			return Math.Max(width1, bucketWidth);
		}

		private int BottomMargin()
		{
			return font.Height*3 + 10;
		}

		private void graphPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			initialized = false;

			if (histogram == null || typeName == null)
				return;

			Graphics g = e.Graphics;

			bucketWidth = BucketWidth(g);
			bottomMargin = BottomMargin();

			BuildSizeRangesAndTypeTable(histogram.typeSizeStacktraceToCount);
			ColorTypes();

			int maxTotalSize = 0;
			foreach (Bucket b in buckets)
			{
				if (maxTotalSize < b.totalSize)
					maxTotalSize = b.totalSize;
			}

			verticalScale = VerticalScale(graphPanel.Height - topMargin - bottomMargin, maxTotalSize);

			int maxBucketHeight = maxTotalSize/verticalScale;
			int height = topMargin + maxBucketHeight + bottomMargin;
			if (height < minHeight)
				height = minHeight;

			graphPanel.Height = height;
			
			int width = leftMargin + buckets.Length*bucketWidth + (buckets.Length-1)*gap + rightMargin;
			graphPanel.Width = width;

			DrawBuckets(g);

			initialized = true;
		}

		private void typeLegendPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			initialized = false;

			if (histogram == null || typeName == null)
				return;

			BuildSizeRangesAndTypeTable(histogram.typeSizeStacktraceToCount);
			ColorTypes();

			Graphics g = e.Graphics;

			DrawTypeLegend(g);		
		}

		private void Refresh(object sender, System.EventArgs e)
		{
			graphPanel.Invalidate();
		}

		private void typeLegendPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != MouseButtons.None)
			{
				for (int i = 0; i < buckets.Length; i++)
				{
					if (buckets[i].selected)
					{
						graphPanel.Invalidate();
						typeLegendPanel.Invalidate();
						buckets[i].selected = false;
					}
				}
				if (sortedTypeTable != null)
				{
					foreach (TypeDesc t in sortedTypeTable)
					{
						if (t.rect.Contains(e.X, e.Y) != t.selected)
						{
							t.selected = !t.selected;
							graphPanel.Invalidate();
							typeLegendPanel.Invalidate();
						}
					}
				}
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(typeLegendPanel, p);
			}
		}

		private void graphPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != MouseButtons.None)
			{
				if (sortedTypeTable != null)
				{
					foreach (TypeDesc t in sortedTypeTable)
						t.selected = false;
				}

				int x = leftMargin;
				for (int i = 0; i < buckets.Length; i++)
				{
					buckets[i].selected = false;
					int y = graphPanel.Height - bottomMargin;
					foreach (TypeDesc t in buckets[i].typeDescToSizeCount.Keys)
					{
						SizeCount sizeCount = (SizeCount)buckets[i].typeDescToSizeCount[t];
						int size = sizeCount.size;
						int height = size / verticalScale;

						y -= height;

						Rectangle r = new Rectangle(x, y, bucketWidth, height);
						if (r.Contains(e.X, e.Y))
						{
							t.selected = true;
							buckets[i].selected = true;
						}
					}

					x += bucketWidth + gap;
				}		
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(graphPanel, p);
			}
		}

		private ToolTip toolTip;

		private void graphPanel_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (!initialized)
				return;

			int x = leftMargin;
			foreach (Bucket b in buckets)
			{
				int y = graphPanel.Height - bottomMargin;
				foreach (DictionaryEntry d in b.typeDescToSizeCount)
				{
					TypeDesc t = (TypeDesc)d.Key;
					SizeCount sizeCount = (SizeCount)d.Value;
					int size = sizeCount.size;
					int height = size / verticalScale;

					y -= height;

					Rectangle bucketRect = new Rectangle(x, y, bucketWidth, height);
					if (bucketRect.Contains(e.X, e.Y))
					{
						string caption = string.Format("{0} {1} ({2:f2}%) - {3:n0} instances, {4} average size", t.typeName, FormatSize(size), 100.0*size/totalSize, sizeCount.count, FormatSize(sizeCount.size/sizeCount.count));
						toolTip.Active = true;
						toolTip.SetToolTip(graphPanel, caption);
						return;
					}
				}
				x += bucketWidth + gap;
			}
			toolTip.Active = false;
			toolTip.SetToolTip(graphPanel, "");
		}

		private bool autoUpdate;

		private void versionTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			if (font != Form1.instance.font)
			{
				font = Form1.instance.font;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}

			ReadLogResult readLogResult = Form1.instance.lastLogResult;

			if (autoUpdate && readLogResult != null && readLogResult.allocatedHistogram != histogram)
			{
				histogram = readLogResult.allocatedHistogram;
				typeName = histogram.readNewLog.typeName;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}		
		}

		private void exportMenuItem_Click(object sender, System.EventArgs e)
		{
			exportSaveFileDialog.FileName = "HistogramBySize.csv";
			exportSaveFileDialog.Filter = "Comma separated files | *.csv";
			if (exportSaveFileDialog.ShowDialog() == DialogResult.OK)
			{
				StreamWriter w = new StreamWriter(exportSaveFileDialog.FileName);

				TypeDesc selectedType = FindSelectedType();

				string title = "Histogram by Size";
				if (selectedType != null)
					title += " of " + selectedType.typeName + " objects";

				w.WriteLine(title);
				w.WriteLine();

				w.WriteLine("{0},{1},{2},{3},{4}", "Min Size", "Max Size", "# Instances", "Total Size", "Type");

				bool noBucketSelected = true;
				int minSize = 0;
				int maxSize = int.MaxValue;
				foreach (Bucket b in buckets)
				{
					if (b.selected)
					{
						noBucketSelected = false;
						minSize = b.minSize;
						maxSize = b.maxSize;
					}
				}
				foreach (Bucket b in buckets)
				{
					if (noBucketSelected || b.selected)
					{
						foreach (DictionaryEntry d in b.typeDescToSizeCount)
						{
							TypeDesc t = (TypeDesc)d.Key;
							SizeCount sizeCount = (SizeCount)d.Value;

							if (selectedType == null || t == selectedType)
								w.WriteLine("{0},{1},{2},{3},{4}", b.minSize, b.maxSize, sizeCount.count, sizeCount.size, t.typeName);
						}
					}
				}

				w.WriteLine();
				w.WriteLine();
				w.WriteLine("Raw data:");
				w.WriteLine();

				w.WriteLine("{0},{1},{2},{3}", "Instance Size", "# Instances", "Total Size", "Type");
				for (int i = 0; i < histogram.typeSizeStacktraceToCount.Length; i++)
				{
					int count = histogram.typeSizeStacktraceToCount[i];
					int[] stacktrace = histogram.readNewLog.stacktraceTable.IndexToStacktrace(i);
					int typeIndex = stacktrace[0];
					int size = stacktrace[1];
					
					if (minSize <= size && size <= maxSize)
					{
						TypeDesc t = (TypeDesc)typeIndexToTypeDesc[typeIndex];
				
						if (selectedType == null || t == selectedType)
						{
							w.WriteLine("{0},{1},{2},{3}", size, count, size*count, t.typeName);
						}
					}
				}

				w.Close();
			}
		}

		private void showWhoAllocatedMenuItem_Click(object sender, System.EventArgs e)
		{
			Histogram selectedHistogram;
			string title;
			TypeDesc selectedType = FindSelectedType();
			if (selectedType == null)
			{
				title = "Allocation Graph";
				selectedHistogram = histogram;
			}
			else
			{
				int minSize = 0;
				int maxSize = int.MaxValue;
				foreach (Bucket b in buckets)
				{
					if (b.selected)
					{
						minSize = b.minSize;
						maxSize = b.maxSize;
					}
				}
				title = string.Format("Allocation Graph for {0} objects", selectedType.typeName);
				if (minSize > 0)
					title += string.Format(" of size between {0:n0} and {1:n0} bytes", minSize, maxSize);
				selectedHistogram = new Histogram(histogram.readNewLog);
				for (int i = 0; i < histogram.typeSizeStacktraceToCount.Length; i++)
				{
					int count = histogram.typeSizeStacktraceToCount[i];
					if (count > 0)
					{
						int[] stacktrace = histogram.readNewLog.stacktraceTable.IndexToStacktrace(i);
						int typeIndex = stacktrace[0];
						int size = stacktrace[1];

						if (minSize <= size && size <= maxSize)
						{
							TypeDesc t = (TypeDesc)typeIndexToTypeDesc[typeIndex];
						
							if (t == selectedType)
							{
								selectedHistogram.AddObject(i, count);
							}
						}
					}
				}
			}

			Graph graph = selectedHistogram.BuildAllocationGraph();

			GraphViewForm graphViewForm = new GraphViewForm(graph, title);
			graphViewForm.Visible = true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\profileserviceform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for ProfileServiceForm.
	/// </summary>
	public class ProfileServiceForm : System.Windows.Forms.Form
	{
        private System.Windows.Forms.Label label1;
        internal System.Windows.Forms.TextBox serviceNameTextBox;
        private System.Windows.Forms.Label label2;
        internal System.Windows.Forms.TextBox startCommandTextBox;
        private System.Windows.Forms.Label label3;
        internal System.Windows.Forms.TextBox stopCommandTextBox;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProfileServiceForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.label1 = new System.Windows.Forms.Label();
            this.serviceNameTextBox = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.startCommandTextBox = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.stopCommandTextBox = new System.Windows.Forms.TextBox();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.176471F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label1.Location = new System.Drawing.Point(40, 24);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(240, 16);
            this.label1.TabIndex = 0;
            this.label1.Text = "Name of service to profile:";
            // 
            // serviceNameTextBox
            // 
            this.serviceNameTextBox.Location = new System.Drawing.Point(40, 48);
            this.serviceNameTextBox.Name = "serviceNameTextBox";
            this.serviceNameTextBox.Size = new System.Drawing.Size(368, 20);
            this.serviceNameTextBox.TabIndex = 1;
            this.serviceNameTextBox.Text = "";
            this.serviceNameTextBox.TextChanged += new System.EventHandler(this.serviceNameTextBox_TextChanged);
            // 
            // label2
            // 
            this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.176471F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label2.Location = new System.Drawing.Point(40, 88);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(232, 16);
            this.label2.TabIndex = 2;
            this.label2.Text = "Command to start the service:";
            // 
            // startCommandTextBox
            // 
            this.startCommandTextBox.Location = new System.Drawing.Point(40, 112);
            this.startCommandTextBox.Name = "startCommandTextBox";
            this.startCommandTextBox.Size = new System.Drawing.Size(368, 20);
            this.startCommandTextBox.TabIndex = 3;
            this.startCommandTextBox.Text = "";
            // 
            // label3
            // 
            this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.176471F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label3.Location = new System.Drawing.Point(40, 152);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(240, 16);
            this.label3.TabIndex = 4;
            this.label3.Text = "Command to stop the service:";
            // 
            // stopCommandTextBox
            // 
            this.stopCommandTextBox.Location = new System.Drawing.Point(40, 176);
            this.stopCommandTextBox.Name = "stopCommandTextBox";
            this.stopCommandTextBox.Size = new System.Drawing.Size(368, 20);
            this.stopCommandTextBox.TabIndex = 5;
            this.stopCommandTextBox.Text = "";
            // 
            // okButton
            // 
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.okButton.Location = new System.Drawing.Point(464, 48);
            this.okButton.Name = "okButton";
            this.okButton.TabIndex = 6;
            this.okButton.Text = "OK";
            // 
            // cancelButton
            // 
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(464, 112);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.TabIndex = 7;
            this.cancelButton.Text = "Cancel";
            // 
            // ProfileServiceForm
            // 
            this.AcceptButton = this.okButton;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(568, 220);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this.cancelButton,
                                                                          this.okButton,
                                                                          this.stopCommandTextBox,
                                                                          this.label3,
                                                                          this.startCommandTextBox,
                                                                          this.label2,
                                                                          this.serviceNameTextBox,
                                                                          this.label1});
            this.Name = "ProfileServiceForm";
            this.Text = "Profile Service ...";
            this.ResumeLayout(false);

        }
		#endregion

        private void serviceNameTextBox_TextChanged(object sender, System.EventArgs e)
        {
            startCommandTextBox.Text = "net start " + serviceNameTextBox.Text;
            stopCommandTextBox .Text = "net stop "  + serviceNameTextBox.Text;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\registerdll.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Runtime.InteropServices;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for RegisterDLL.
	/// </summary>
	public class RegisterDLL
	{
		public RegisterDLL()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		private static bool initialized = false;

		internal static bool Register()
		{
			if (!initialized)
			{
				if (DllRegisterServer() == 0)
					initialized = true;
				else
					throw new Exception("Couldn't register profilerOBJ.dll");
			}
			return initialized;
		}

		[DllImport("profilerOBJ.dll")]
		private static extern int DllRegisterServer();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\objectgraph.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Text;
using System.Diagnostics;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for ObjectGraph.
	/// </summary>
	public class ObjectGraph
	{
		internal ObjectGraph()
		{
			//
			// TODO: Add constructor logic here
			//
			idToObject = new Hashtable();
			typeNameToGcType = new Hashtable();
			hintTable = new GcObject[10];
			unknownType = GetOrCreateGcType("<unknown type>");			
		}

		internal class GcObject
		{
			internal GcObject(int id)
			{
				this.id = id;
			}

			internal GcObject(int id, int size, GcObject refernces)
			{
				this.id = id;
				this.size = size;
				this.references = references;
			}

			internal int size;			// Size of this object
			internal int treeSize;		// Size including everything pointed at directly or indirectly
			internal int id;			// The object's id (i.e. really its address)
			internal GcType type;
			internal int hint;
			internal int level;
			internal GcObject parent;
			internal Vertex vertex;
			internal GcObject[] references;
			internal InterestLevel interestLevel;
		}

		internal class GcType : IComparable
		{
			internal GcType(string name)
			{
				this.name = name;
			}
			internal string name;
			internal int cumulativeSize;			// Size for all the instances of that type

			internal int index;

			internal InterestLevel interestLevel;

			public int CompareTo(Object o)
			{
				GcType t = (GcType)o;
				return t.cumulativeSize - this.cumulativeSize;
			}

		}

		internal Hashtable	idToObject;
		internal Hashtable	typeNameToGcType;
		internal GcType	unknownType;

		internal GcObject[]	roots;

		internal GcObject GetOrCreateObject(int objectID)
		{
			GcObject o = (GcObject)idToObject[objectID];
			if (o == null)
			{
				o = new GcObject(objectID);
				idToObject[objectID] = o;
				o.type = unknownType;

			}
			return o;
		}

		internal GcType GetOrCreateGcType(string typeName)
		{
			Debug.Assert(typeName != null);
			GcType t = (GcType)typeNameToGcType[typeName];
			if (t == null)
			{
				t = new GcType(typeName);
				typeNameToGcType[typeName] = t;
			}
			return t;
		}

		internal GcObject[] LookupReferences(int count, int[] refIDs)
		{
			if (count == 0)
				return null;
			GcObject[] result = new GcObject[count];
			for (int i = 0; i < count; i++)
				result[i] = GetOrCreateObject(refIDs[i]);
			return result;
		}

		internal GcObject[] hintTable;
		internal int nextHintIndex;

		private GcObject[] GrowHintTable(GcObject[] hintTable)
		{
			GcObject[] newHintTable = new GcObject[hintTable.Length*2];
			for (int i = 0; i < hintTable.Length; i++)
				newHintTable[i] = hintTable[i];
			return newHintTable;
		}

		private void MarkObject(GcObject o)
		{
			if (o.hint < nextHintIndex && hintTable[o.hint] == o)
				return;
			if (nextHintIndex >= hintTable.Length)
				hintTable = GrowHintTable(hintTable);
			o.hint = nextHintIndex++;
			hintTable[o.hint] = o;
			if (o.references != null)
			{
				foreach (GcObject refObject in o.references)
					MarkObject(refObject);
			}
		}

		internal void CalculateTreeSize(GcObject rootObject)
		{
			nextHintIndex = 0;
			MarkObject(rootObject);
			rootObject.treeSize = 0;
			for (int i = 0; i < nextHintIndex; i++)
				rootObject.treeSize += hintTable[i].size;
		}

		internal void ObjectGraphStatistics()
		{
			ArrayList gcTypes = new ArrayList();
			foreach (GcType gcType in typeNameToGcType.Values)
			{
				gcTypes.Add(gcType);
			}

			gcTypes.Sort();

			int totalSize = 0;
			foreach (GcType gcType in gcTypes)
			{
				totalSize += gcType.cumulativeSize;
			}
		}

		private void CalculateWeightsTransitive(Graph graph)
		{
			int index = 0;
			foreach (GcType gcType in typeNameToGcType.Values)
			{
				gcType.index = index++;
			}

			ArrayList[] objectsOfTypeIndex = new ArrayList[index];

			foreach (GcObject gcObject in idToObject.Values)
			{
				if (objectsOfTypeIndex[gcObject.type.index] == null)
					objectsOfTypeIndex[gcObject.type.index] = new ArrayList();
				objectsOfTypeIndex[gcObject.type.index].Add(gcObject);
			}

			foreach (GcType gcType in typeNameToGcType.Values)
			{
				nextHintIndex = 0;
				foreach (GcObject gcObject in objectsOfTypeIndex[gcType.index])
				{
					MarkObject(gcObject);
				}
				int totalSize = 0;
				for (int i = 0; i < nextHintIndex; i++)
					totalSize += hintTable[i].size;

				Vertex v = graph.FindOrCreateVertex(gcType.name, null);
				v.weight = v.outgoingWeight = v.incomingWeight = totalSize;

				ArrayList[] objectsOfTypeIndexPointedAt = new ArrayList[index];
				foreach (GcObject gcObject in objectsOfTypeIndex[gcType.index])
				{
					if (gcObject.references != null)
					{
						foreach (GcObject toObject in gcObject.references)
						{
							if (objectsOfTypeIndexPointedAt[toObject.type.index] == null)
								objectsOfTypeIndexPointedAt[toObject.type.index] = new ArrayList();
							objectsOfTypeIndexPointedAt[toObject.type.index].Add(toObject);
						}
					}
				}

				foreach (GcType toType in typeNameToGcType.Values)
				{
					if (objectsOfTypeIndexPointedAt[toType.index] != null)
					{
						nextHintIndex = 0;
						foreach (GcObject toObject in objectsOfTypeIndexPointedAt[toType.index])
						{
							MarkObject(toObject);
						}
						Vertex toVertex = graph.FindOrCreateVertex(toType.name, null);
						Edge e = v.FindOrCreateOutgoingEdge(toVertex);
						totalSize = 0;
						for (int i = 0; i < nextHintIndex; i++)
							totalSize += hintTable[i].size;
						e.weight = totalSize;
					}
				}
			}
		}
		private void CalculateWeightsNonTransitive(Graph graph)
		{
			int index = 0;
			foreach (GcType gcType in typeNameToGcType.Values)
			{
				gcType.index = index++;
			}

			ArrayList[] objectsOfTypeIndex = new ArrayList[index];

			foreach (GcObject gcObject in idToObject.Values)
			{
				if (objectsOfTypeIndex[gcObject.type.index] == null)
					objectsOfTypeIndex[gcObject.type.index] = new ArrayList();
				objectsOfTypeIndex[gcObject.type.index].Add(gcObject);
			}

			foreach (GcType gcType in typeNameToGcType.Values)
			{
				int totalSize = 0;
				foreach (GcObject gcObject in objectsOfTypeIndex[gcType.index])
				{
					totalSize += gcObject.size;
				}

				Vertex v = graph.FindOrCreateVertex(gcType.name, null);
				v.weight = v.outgoingWeight = v.incomingWeight = totalSize;

				ArrayList[] objectsOfTypeIndexPointedAt = new ArrayList[index];
				foreach (GcObject gcObject in objectsOfTypeIndex[gcType.index])
				{
					if (gcObject.references != null)
					{
						foreach (GcObject toObject in gcObject.references)
						{
							if (objectsOfTypeIndexPointedAt[toObject.type.index] == null)
								objectsOfTypeIndexPointedAt[toObject.type.index] = new ArrayList();
							objectsOfTypeIndexPointedAt[toObject.type.index].Add(toObject);
						}
					}
				}

				foreach (GcType toType in typeNameToGcType.Values)
				{
					if (objectsOfTypeIndexPointedAt[toType.index] != null)
					{
						totalSize = 0;
						foreach (GcObject toObject in objectsOfTypeIndexPointedAt[toType.index])
						{
							totalSize += toObject.size;
						}
						Vertex toVertex = graph.FindOrCreateVertex(toType.name, null);
						Edge e = v.FindOrCreateOutgoingEdge(toVertex);
						e.weight = totalSize;
					}
				}
			}
		}

		internal Graph BuildTypeGraph1()
		{
			Graph graph = new Graph(this);
			graph.graphType = Graph.GraphType.HeapGraph;

			GcType rootType = GetOrCreateGcType("<root>");
			GcObject rootObject = GetOrCreateObject(0);
			rootObject.type = rootType;
			rootObject.references = roots;

			foreach (GcObject gcObject in idToObject.Values)
			{
				rootObject.size += gcObject.size;
				if (gcObject.references != null)
				{
					Vertex fromVertex = graph.FindOrCreateVertex(gcObject.type.name, null);

					foreach (GcObject toObject in gcObject.references)
					{
						Vertex toVertex = graph.FindOrCreateVertex(toObject.type.name, null);
						graph.FindOrCreateEdge(fromVertex, toVertex);
					}
				}
			}

			CalculateWeightsNonTransitive(graph);

			foreach (Vertex v in graph.vertices.Values)
				v.active = true;
			graph.BottomVertex.active = false;

			return graph;
		}

		void AssignLevel(GcObject parent, GcObject thisObject, int level)
		{
			if (thisObject.level > level)
			{
				thisObject.level = level;
				thisObject.parent = parent;
				if (thisObject.references != null)
				{
					foreach (GcObject refObject in thisObject.references)
					{
						AssignLevel(thisObject, refObject, level+1);
					}
				}
			}
		}

		int[] typeHintTable;

		private Vertex FindVertex(GcObject gcObject, Graph graph)
		{
			if (gcObject.vertex != null)
				return gcObject.vertex;
			string signature = null;
			if (gcObject.parent != null)
			{
				StringBuilder sb = new StringBuilder();
				sb.Append(gcObject.parent.type.name);
				sb.Append("->");
				sb.Append(gcObject.type.name);
				if (gcObject.references != null)
				{
					sb.Append("->(");

					ArrayList al = new ArrayList();
					string separator = "";
					const int MAXREFTYPECOUNT = 3;
					int refTypeCount = 0;
					for	(int i = 0; i < gcObject.references.Length; i++)
					{
						GcObject refObject = gcObject.references[i];
						GcType refType = refObject.type;
						if (typeHintTable[refType.index] < i && gcObject.references[typeHintTable[refType.index]].type == refType)
						{
							;	// we already found this type - ignore further occurrences
						}
						else
						{
							typeHintTable[refType.index] = i;
							refTypeCount++;
							if (refTypeCount <= MAXREFTYPECOUNT)
							{
								al.Add(refType.name);
							}
							else
							{
								break;
							}
						}
					}
					al.Sort();
					foreach (string typeName in al)
					{
						sb.Append(separator);
						separator = ",";
						sb.Append(typeName);
					}

					if (refTypeCount > MAXREFTYPECOUNT)
						sb.Append(",...");

					sb.Append(")");

					signature = sb.ToString();
				}
			}

			gcObject.vertex = graph.FindOrCreateVertex(gcObject.type.name, signature);

			return gcObject.vertex;
		}

		private static Graph graph;
		private static int graphFilterVersion;

		const int historyDepth = 3;

		// Check whether we have a parent object interested in this one
		private bool CheckForParentMarkingDescendant(GcObject gcObject)
		{
			GcObject parentObject = gcObject.parent;
			if (parentObject == null)
				return false;
			switch (parentObject.interestLevel & InterestLevel.InterestingChildren)
			{
				// Parent says it wants to show children
				case	InterestLevel.InterestingChildren:
					gcObject.interestLevel |= InterestLevel.Display;
					return true;

				// Parent is not interesting - check its parent
				case	InterestLevel.Ignore:
					if (CheckForParentMarkingDescendant(parentObject))
					{
						gcObject.interestLevel |= InterestLevel.Display;
						return true;
					}
					else
						return false;

				default:
					return false;
			}
		}

		private void AssignInterestLevels()
		{
			foreach (GcType gcType in typeNameToGcType.Values)
			{
				// Otherwise figure which the interesting types are.
				gcType.interestLevel = FilterForm.InterestLevelOfTypeName(gcType.name);
			}

			foreach (GcObject gcObject in idToObject.Values)
			{
				// The initial interest level in objects is the one of their type
				gcObject.interestLevel = gcObject.type.interestLevel;
			}

			foreach (GcObject gcObject in idToObject.Values)
			{
				// Check if this is an interesting object, and we are supposed to mark its ancestors
				if ((gcObject.interestLevel & InterestLevel.InterestingParents) == InterestLevel.InterestingParents)
				{
					for (GcObject parentObject = gcObject.parent; parentObject != null; parentObject = parentObject.parent)
					{
						// As long as we find uninteresting object, mark them for display
						// When we find an interesting object, we stop, because either it
						// will itself mark its parents, or it isn't interested in them (and we
						// respect that despite the interest of the current object, somewhat arbitrarily).
						if ((parentObject.interestLevel & InterestLevel.InterestingParents) == InterestLevel.Ignore)
							parentObject.interestLevel |= InterestLevel.Display;
						else
							break;
					}
				}
				// Check if this object should be displayed because one of its ancestors
				// is interesting, and it says its descendents are interesting as well
				if ((gcObject.interestLevel & (InterestLevel.Interesting|InterestLevel.Display)) == InterestLevel.Ignore)
				{
					CheckForParentMarkingDescendant(gcObject);
				}
			}
		}

		internal Graph BuildTypeGraph()
		{
			if (graph == null || FilterForm.filterVersion != graphFilterVersion)
			{
				graph = new Graph(this);
				graph.graphType = Graph.GraphType.HeapGraph;
				graphFilterVersion = FilterForm.filterVersion;
			}
			else
			{
				foreach (Vertex v in graph.vertices.Values)
				{
					if (v.weightHistory == null)
						v.weightHistory = new int[1];
					else
					{
						int[] weightHistory = v.weightHistory;
						if (weightHistory.Length < historyDepth)
							v.weightHistory = new int[weightHistory.Length+1];
						for (int i = v.weightHistory.Length-1; i > 0; i--)
							v.weightHistory[i] = weightHistory[i-1];
					}
					v.weightHistory[0] = v.weight;
					v.weight = v.incomingWeight = v.outgoingWeight = v.basicWeight = v.count = 0;
					foreach (Edge e in v.outgoingEdges.Values)
						e.weight = 0;
				}
			}

			GcType rootType = GetOrCreateGcType("<root>");
			GcObject rootObject = GetOrCreateObject(0);
			rootObject.type = rootType;
			rootObject.references = roots;

			foreach (GcObject gcObject in idToObject.Values)
			{
				gcObject.level = int.MaxValue;
				gcObject.vertex = null;
			}

			AssignLevel(null, rootObject, 0);

			AssignInterestLevels();

			int index = 0;
			foreach (GcType gcType in typeNameToGcType.Values)
			{
				gcType.index = index++;
			}
			GcType[] gcTypes = new GcType[index];
			typeHintTable = new int[index];

			foreach (GcType gcType in typeNameToGcType.Values)
			{
				gcTypes[gcType.index] = gcType;
			}

			Vertex[] pathFromRoot = new Vertex[32];
			foreach (GcObject gcObject in idToObject.Values)
			{
				if (   gcObject.level == int.MaxValue
					|| (gcObject.interestLevel & (InterestLevel.Interesting|InterestLevel.Display)) == InterestLevel.Ignore)
					continue;

				while (pathFromRoot.Length < gcObject.level+1)
				{
					pathFromRoot = new Vertex[pathFromRoot.Length*2];
				}

				for (GcObject pathObject = gcObject; pathObject != null; pathObject = pathObject.parent)
				{
					if ((pathObject.interestLevel & (InterestLevel.Interesting|InterestLevel.Display)) == InterestLevel.Ignore)
						pathFromRoot[pathObject.level] = null;
					else
						pathFromRoot[pathObject.level] = FindVertex(pathObject, graph);
				}

				int levels = 0;
				for (int i = 0; i <= gcObject.level; i++)
				{
					if (pathFromRoot[i] != null)
						pathFromRoot[levels++] = pathFromRoot[i];
				}

				levels = Vertex.SqueezeOutRepetitions(pathFromRoot, levels);

				for (int i = 0; i < levels-1; i++)
				{
					Vertex fromVertex = pathFromRoot[i];
					Vertex toVertex = pathFromRoot[i+1];
					Edge edge = graph.FindOrCreateEdge(fromVertex, toVertex);
					edge.AddWeight(gcObject.size);
				}

				Vertex thisVertex = pathFromRoot[levels-1];
				thisVertex.basicWeight += gcObject.size;
				thisVertex.count += 1;
			}

			foreach (Vertex v in graph.vertices.Values)
			{
				if (v.weight < v.outgoingWeight)
					v.weight = v.outgoingWeight;
				if (v.weight < v.incomingWeight)
					v.weight = v.incomingWeight;
				if (v.weightHistory == null)
					v.weightHistory = new int[1];
			}
			
			foreach (Vertex v in graph.vertices.Values)
				v.active = true;
			graph.BottomVertex.active = false;

			return graph;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\vertex.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace AllocationProfiler
{
    using System;
	using System.Drawing;
	using System.Collections;
	using System.Text;

    /// <summary>
    ///    Summary description for Vertex.
    /// </summary>
    public class Vertex : IComparable
    {
		internal string name;
		internal string signature;
		internal string weightString;
		internal Hashtable incomingEdges;
		internal Hashtable outgoingEdges;
		internal int level;
		internal int weight;
		internal int incomingWeight;
		internal int outgoingWeight;
		internal Rectangle rectangle;
		internal Rectangle selectionRectangle;
		internal bool selected;
		internal bool visible;
		internal string nameSpace;
		internal string basicName;
		internal string basicSignature;
		internal bool signatureCurtated;
		internal bool active;
        private  Edge cachedOutgoingEdge;
		internal int[] weightHistory;
		private int hint;
		internal int basicWeight;
		internal int count;
		internal InterestLevel interestLevel;

		string nameSpaceOf(string name, out string basicName)
		{
			int prevSeparatorPos = -1;
			int thisSeparatorPos = -1;
			while (true)
			{
				int nextSeparatorPos = name.IndexOf('.', thisSeparatorPos+1);
				if (nextSeparatorPos < 0)
					nextSeparatorPos = name.IndexOf("::", thisSeparatorPos+1);
				if (nextSeparatorPos < 0)
					break;
				prevSeparatorPos = thisSeparatorPos;
				thisSeparatorPos = nextSeparatorPos;
			}
			if (prevSeparatorPos >= 0)
			{
				basicName = name.Substring(prevSeparatorPos+1);
				return name.Substring(0, prevSeparatorPos+1);
			}
			else
			{
				basicName = name;
				return "";
			}
		}

        public Vertex(string name, string signature)
        {
			this.signature = signature;
			this.incomingEdges = new Hashtable();
			this.outgoingEdges = new Hashtable();
			this.level = Int32.MaxValue;
			this.weight = 0;

			nameSpace = nameSpaceOf(name, out basicName);
			this.name = name;
			basicSignature = signature;
			if (nameSpace.Length > 0 && signature != null)
			{
				int index;
				while ((index = basicSignature.IndexOf(nameSpace)) >= 0)
				{
					basicSignature = basicSignature.Remove(index, nameSpace.Length);
				}
			}
        }

		public Edge FindOrCreateOutgoingEdge(Vertex toVertex)
		{
			Edge edge = cachedOutgoingEdge;
            if (edge != null && edge.ToVertex == toVertex)
                return edge;
            edge = (Edge)outgoingEdges[toVertex];
			if (edge == null)
			{
				edge = new Edge(this, toVertex);
				this.outgoingEdges[toVertex] = edge;
       			toVertex.incomingEdges[this] = edge;
			}
            cachedOutgoingEdge = edge;

			return edge;
		}

		public void AssignLevel(int level)
		{
			if (this.level > level)
			{
				this.level = level;
				foreach (Edge outgoingEdge in outgoingEdges.Values)
				{
					outgoingEdge.ToVertex.AssignLevel(level + 1);
				}
			}
		}

		public int CompareTo(Object o)
		{
			Vertex v = (Vertex)o;
			return v.weight - this.weight;
		}

		static bool IdenticalSequence(Vertex[] path, int i, int j, int length)
		{
			for (int k = 0; k < length; k++)
				if (path[i+k] != path[j+k])
					return false;
			return true;
		}

		static int LargestRepetition(Vertex[] path, int i, int j, int length)
		{
			int len = i;
			if (len > length - j)
				len = length - j;
			for ( ; len > 0; len--)
			{
				int repLen = 0;
				while (j + repLen + len <= length && IdenticalSequence(path, i - len, j + repLen, len))
					repLen += len;
				if (repLen > 0)
					return repLen;
			}
			return 0;
		}

		static bool RepeatedElementsPresent(Vertex[] path, int length)
		{
			for (int i = 0; i < length; i++)
			{
				Vertex element = path[i];
				int hint = element.hint;
				if (hint < i && path[hint] == element)
					return true;
				element.hint = i;
			}
			return false;
		}

		public static int SqueezeOutRepetitions(Vertex[] path, int length)
		{
			if (!RepeatedElementsPresent(path, length))
				return length;

			int k = 0;
			int l = 0;
			while (l < length)
			{
				int repetitionLength = LargestRepetition(path, k, l, length);
				if (repetitionLength == 0)
					path[k++] = path[l++];
				else
					l += repetitionLength;
			}
			return k;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\readnewlog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.Collections;

namespace AllocationProfiler
{
	internal class Histogram
	{
		internal int[] typeSizeStacktraceToCount;
		internal ReadNewLog readNewLog;

		internal Histogram(ReadNewLog readNewLog)
		{
			typeSizeStacktraceToCount = new int[10];
			this.readNewLog = readNewLog;
		}

		internal void AddObject(int typeSizeStacktraceIndex, int count)
		{
			while (typeSizeStacktraceIndex >= typeSizeStacktraceToCount.Length)
				typeSizeStacktraceToCount = ReadNewLog.GrowIntVector(typeSizeStacktraceToCount);
			typeSizeStacktraceToCount[typeSizeStacktraceIndex] += count;
		}

		internal bool Empty
		{
			get
			{
				foreach (int count in typeSizeStacktraceToCount)
					if (count != 0)
						return false;
				return true;
			}
		}

		internal int BuildVertexStack(int stackTraceIndex, Vertex[] funcVertex, ref Vertex[] vertexStack, int skipCount)
		{
			int[] stackTrace = readNewLog.stacktraceTable.IndexToStacktrace(stackTraceIndex);
				
			while (vertexStack.Length < stackTrace.Length+1)
				vertexStack = new Vertex[vertexStack.Length*2];

			for (int i = skipCount; i < stackTrace.Length; i++)
				vertexStack[i-skipCount] = funcVertex[stackTrace[i]];

			return stackTrace.Length - skipCount;
		}

		internal void BuildAllocationTrace(Graph graph, int stackTraceIndex, int typeIndex, int size, Vertex[] typeVertex, Vertex[] funcVertex, ref Vertex[] vertexStack)
		{
			int stackPtr = BuildVertexStack(stackTraceIndex, funcVertex, ref vertexStack, 2);

			Vertex toVertex = graph.TopVertex;
			Vertex fromVertex;
			Edge edge;
			if ((typeVertex[typeIndex].interestLevel & InterestLevel.Interesting) == InterestLevel.Interesting
				&& ReadNewLog.InterestingCallStack(vertexStack, stackPtr))
			{
				vertexStack[stackPtr] = typeVertex[typeIndex];
				stackPtr++;
				stackPtr = ReadNewLog.FilterVertices(vertexStack, stackPtr);
				stackPtr = Vertex.SqueezeOutRepetitions(vertexStack, stackPtr);
				for (int i = 0; i < stackPtr; i++)
				{
					fromVertex = toVertex;
					toVertex = vertexStack[i];
					edge = graph.FindOrCreateEdge(fromVertex, toVertex);
					edge.AddWeight(size);
				}
				fromVertex = toVertex;
				toVertex = graph.BottomVertex;
				edge = graph.FindOrCreateEdge(fromVertex, toVertex);
				edge.AddWeight(size);
			}
		}

		internal void BuildCallTrace(Graph graph, int stackTraceIndex, Vertex[] funcVertex, ref Vertex[] vertexStack, int count)
		{
			int stackPtr = BuildVertexStack(stackTraceIndex, funcVertex, ref vertexStack, 0);

			Vertex toVertex = graph.TopVertex;
			Vertex fromVertex;
			Edge edge;
			if (ReadNewLog.InterestingCallStack(vertexStack, stackPtr))
			{
				stackPtr = ReadNewLog.FilterVertices(vertexStack, stackPtr);
				stackPtr = Vertex.SqueezeOutRepetitions(vertexStack, stackPtr);
				for (int i = 0; i < stackPtr; i++)
				{
					fromVertex = toVertex;
					toVertex = vertexStack[i];
					edge = graph.FindOrCreateEdge(fromVertex, toVertex);
					edge.AddWeight(count);
				}
			}
		}

		internal void BuildTypeVertices(Graph graph, ref Vertex[] typeVertex)
		{
			for (int i = 0; i < readNewLog.typeName.Length; i++)
			{
				string typeName = readNewLog.typeName[i];
				if (typeName != null)
					readNewLog.AddTypeVertex(i, typeName, graph, ref typeVertex);
			}
		}

		internal void BuildFuncVertices(Graph graph, ref Vertex[] funcVertex)
		{
			for (int i = 0; i < readNewLog.funcName.Length; i++)
			{
				string name = readNewLog.funcName[i];
				string signature = readNewLog.funcSignature[i];
				if (name != null && signature != null)
					readNewLog.AddFunctionVertex(i, name, signature, graph, ref funcVertex);
			}
		}

		internal Graph BuildAllocationGraph()
		{
			Vertex[] typeVertex = new Vertex[1];
			Vertex[] funcVertex = new Vertex[1];
			Vertex[] vertexStack = new Vertex[1];

			Graph graph = new Graph(this);
			graph.graphType = Graph.GraphType.AllocationGraph;

			BuildTypeVertices(graph, ref typeVertex);
			BuildFuncVertices(graph, ref funcVertex);

			for (int i = 0; i < typeSizeStacktraceToCount.Length; i++)
			{
				if (typeSizeStacktraceToCount[i] > 0)
				{
					int[] stacktrace = readNewLog.stacktraceTable.IndexToStacktrace(i);

					int typeIndex = stacktrace[0];
					int size = stacktrace[1]*typeSizeStacktraceToCount[i];

					BuildAllocationTrace(graph, i, typeIndex, size, typeVertex, funcVertex, ref vertexStack);
				}
			}

			foreach (Vertex v in graph.vertices.Values)
				v.active = true;
			graph.BottomVertex.active = false;

			return graph;
		}
		internal Graph BuildCallGraph()
		{
			Vertex[] funcVertex = new Vertex[1];
			Vertex[] vertexStack = new Vertex[1];

			Graph graph = new Graph(this);
			graph.graphType = Graph.GraphType.CallGraph;

			BuildFuncVertices(graph, ref funcVertex);

			for (int i = 0; i < typeSizeStacktraceToCount.Length; i++)
			{
				if (typeSizeStacktraceToCount[i] > 0)
				{
					int[] stacktrace = readNewLog.stacktraceTable.IndexToStacktrace(i);

					BuildCallTrace(graph, i, funcVertex, ref vertexStack, typeSizeStacktraceToCount[i]);
				}
			}

			foreach (Vertex v in graph.vertices.Values)
				v.active = true;
			graph.BottomVertex.active = false;

			return graph;
		}
	}

	internal class SampleObjectTable
	{
		internal class SampleObject
		{
			internal int typeIndex;
			internal int allocTickIndex;
			internal SampleObject prev;

			internal SampleObject(int typeIndex, int allocTickIndex, SampleObject prev)
			{
				this.typeIndex = typeIndex;
				this.allocTickIndex = allocTickIndex;
				this.prev = prev;
			}
		}

		internal SampleObject[][] masterTable;
		internal ReadNewLog readNewLog;

		internal const int firstLevelShift = 20;
		internal const int firstLevelLength = 1<<(31-firstLevelShift);
		internal const int secondLevelShift = 10;
		internal const int secondLevelLength = 1<<(firstLevelShift-secondLevelShift);
		internal const int sampleGrain = 1<<secondLevelShift;
		internal int lastTickIndex;
		internal SampleObject gcTickList;

		internal SampleObjectTable(ReadNewLog readNewLog)
		{
			masterTable = new SampleObject[firstLevelLength][];
			this.readNewLog = readNewLog;
			lastTickIndex = 0;
			gcTickList = null;
		}
			
		bool IsGoodSample(int start, int end)
		{
			// We want it as a sample if and only if it crosses a boundary
			return (start >> secondLevelShift) != (end >> secondLevelShift);
		}

		internal void RecordChange(int start, int end, int tickIndex, int typeIndex)
		{
			lastTickIndex = tickIndex;
			for (int id = start; id < end; id += sampleGrain)
			{
				int index = id >> firstLevelShift;
				SampleObject[] so = masterTable[index];
				if (so == null)
				{
					so = new SampleObject[secondLevelLength];
					masterTable[index] = so;
				}
				index = (id >> secondLevelShift) & (secondLevelLength-1);
				Debug.Assert(so[index] == null || so[index].allocTickIndex <= tickIndex);
				so[index] = new SampleObject(typeIndex, tickIndex, so[index]);
			}
		}

		internal void Insert(int start, int end, int tick, int typeIndex)
		{
			if (IsGoodSample(start, end))
				RecordChange(start, end, tick, typeIndex);
		}

		internal void Delete(int start, int end, int tick)
		{
			if (IsGoodSample(start, end))
				RecordChange(start, end, tick, 0);
		}

		internal void AddGcTick(int tickIndex, int gen)
		{
			lastTickIndex = tickIndex;

			gcTickList = new SampleObject(gen, tickIndex, gcTickList);
		}
	}

	internal class LiveObjectTable
	{
		internal struct LiveObject
		{
			internal int id;
			internal int size;
			internal int typeIndex;
			internal int typeSizeStacktraceIndex;
			internal int allocTickIndex;
		}

		class IntervalTable
		{
			class Interval
			{
				internal int loAddr;
				internal int hiAddr;
				internal Interval next;
				internal bool hadRelocations;
				internal bool justHadGc;

				internal Interval(int loAddr, int hiAddr, Interval next)
				{
					this.loAddr = loAddr;
					this.hiAddr = hiAddr;
					this.next = next;
				}
			}

			const int allowableGap = 1024*1024;

			Interval root;
			LiveObjectTable liveObjectTable;

			internal IntervalTable(LiveObjectTable liveObjectTable)
			{
				root = null;
				this.liveObjectTable = liveObjectTable;
			}

			internal bool AddObject(int id, int size, int allocTickIndex, SampleObjectTable sampleObjectTable)
			{
				size = (size + 3) & ~3;
				Interval prevInterval = null;
				bool emptySpace = false;
				for (Interval i = root; i != null; i = i.next)
				{
					if (i.loAddr <= id && id <= i.hiAddr + allowableGap)
					{
						if (id < i.hiAddr)
						{
							if (i.hadRelocations && i.justHadGc)
							{
								// Interval gets shortened
								liveObjectTable.RemoveObjectRange(id, i.hiAddr - id, allocTickIndex, sampleObjectTable);
								i.hiAddr = id + size;
								i.justHadGc = false;
							}
						}
						else
						{
							i.hiAddr = id + size;
							emptySpace = true;
						}
						if (prevInterval != null)
						{
							// Move to front to speed up future searches.
							prevInterval.next = i.next;
							i.next = root;
							root = i;
						}
						return emptySpace;
					}
					prevInterval = i;
				}
				root = new Interval(id, id + size, root);
				return emptySpace;
			}

			internal void Relocate(int oldId, int newId, int length)
			{
				for (Interval i = root; i != null; i = i.next)
				{
					if (i.loAddr <= oldId && oldId < i.hiAddr)
						i.hadRelocations = true;
				}
				for (Interval i = root; i != null; i = i.next)
				{
					if (i.loAddr <= newId + length && newId <= i.hiAddr + allowableGap)
					{
						if (i.hiAddr < newId + length)
							i.hiAddr = newId + length;
						if (i.loAddr > newId)
							i.loAddr = newId;
						return;
					}
				}
				root = new Interval(newId, newId + length, root);
			}

			internal void RecordGc()
			{
				for (Interval i = root; i != null; i = i.next)
					i.justHadGc = true;
			}
		}

		IntervalTable intervalTable;
		internal ReadNewLog readNewLog;
		internal int lastTickIndex;
		private long lastPos;

		const int alignShift = 2;
		const int firstLevelShift = 15;
		const int firstLevelLength = 1<<(32-alignShift-firstLevelShift);
		const int secondLevelLength = 1<<firstLevelShift;
		const int secondLevelMask = secondLevelLength-1;

		ushort[][] firstLevelTable;

		internal LiveObjectTable(ReadNewLog readNewLog)
		{
			firstLevelTable = new ushort[firstLevelLength][];
			intervalTable = new IntervalTable(this);
			this.readNewLog = readNewLog;
			lastGcGen0Count = 0;
			lastGcGen1Count = 0;
			lastGcGen2Count = 0;
			lastTickIndex = 0;
			lastPos = 0;
		}

		internal int FindObjectBackward(int id)
		{
			id >>= alignShift;
			int i = id >> firstLevelShift;
			int j = id & secondLevelMask;
			while (i >= 0)
			{
				ushort[] secondLevelTable = firstLevelTable[i];
				if (secondLevelTable != null)
				{
					while (j >= 0)
					{
						if ((secondLevelTable[j] & 0x8000) != 0)
							break;
						j--;
					}
					if (j >= 0)
						break;
				}
				j = secondLevelLength - 1;
				i--;
			}
			if (i < 0)
				return 0;
			else
				return ((i<<firstLevelShift) + j) << alignShift;
		}

		int FindObjectForward(int startId, int endId)
		{
			startId >>= alignShift;
			endId >>= alignShift;
			int i = startId >> firstLevelShift;
			int iEnd = endId >> firstLevelShift;
			int j = startId & secondLevelMask;
			int jEnd = endId & secondLevelMask;
			while (i <= iEnd)
			{
				ushort[] secondLevelTable = firstLevelTable[i];
				if (secondLevelTable != null)
				{
					while (j < secondLevelLength && (j <= jEnd || i <= iEnd))
					{
						if ((secondLevelTable[j] & 0x8000) != 0)
							break;
						j++;
					}
					if (j < secondLevelLength)
						break;
				}
				j = 0;
				i++;
			}
			if (i > iEnd)
				return int.MaxValue;
			else
				return ((i<<firstLevelShift) + j) << alignShift;
		}

		internal void GetNextObject(int startId, int endId, out LiveObject o)
		{
			int id = FindObjectForward(startId, endId);
			o.id = id;
			id >>= alignShift;
			int i = id >> firstLevelShift;
			int j = id & secondLevelMask;
			ushort[] secondLevelTable = firstLevelTable[i];
			if (secondLevelTable != null)
			{
				ushort u1 = secondLevelTable[j];
				if ((u1 & 0x8000) != 0)
				{
					j++;
					if (j >= secondLevelLength)
					{
						j = 0;
						i++;
						secondLevelTable = firstLevelTable[i];
					}
					ushort u2 = secondLevelTable[j];
					j++;
					if (j >= secondLevelLength)
					{
						j = 0;
						i++;
						secondLevelTable = firstLevelTable[i];
					}
					ushort u3 = secondLevelTable[j];

					o.allocTickIndex = (u2 >> 7) + (u3 << 8);

					o.typeSizeStacktraceIndex = (u1 & 0x7fff) + ((u2 & 0x7f) << 15);

					int[] stacktrace = readNewLog.stacktraceTable.IndexToStacktrace(o.typeSizeStacktraceIndex);

					o.typeIndex = stacktrace[0];
					o.size = stacktrace[1];

					return;
				}
			}
			o.size = o.allocTickIndex = o.typeIndex = o.typeSizeStacktraceIndex = 0;
		}

		void Write3WordsAt(int id, ushort u1, ushort u2, ushort u3)
		{
			id >>= alignShift;
			int i = id >> firstLevelShift;
			int j = id & secondLevelMask;
			ushort[] secondLevelTable = firstLevelTable[i];
			if (secondLevelTable == null)
			{
				secondLevelTable = new ushort[secondLevelLength];
				firstLevelTable[i] = secondLevelTable;
			}
			secondLevelTable[j] = u1;
			j++;
			if (j >= secondLevelLength)
			{
				j = 0;
				i++;
				secondLevelTable = firstLevelTable[i];
				if (secondLevelTable == null)
				{
					secondLevelTable = new ushort[secondLevelLength];
					firstLevelTable[i] = secondLevelTable;
				}
			}
			secondLevelTable[j] = u2;
			j++;
			if (j >= secondLevelLength)
			{
				j = 0;
				i++;
				secondLevelTable = firstLevelTable[i];
				if (secondLevelTable == null)
				{
					secondLevelTable = new ushort[secondLevelLength];
					firstLevelTable[i] = secondLevelTable;
				}
			}
			secondLevelTable[j] = u3;
		}

		internal void Zero(int id, int size)
		{
			int count = ((size + 3) & ~3)/4;
			id >>= alignShift;
			int i = id >> firstLevelShift;
			int j = id & secondLevelMask;
			ushort[] secondLevelTable = firstLevelTable[i];
			if (secondLevelTable == null)
			{
				secondLevelTable = new ushort[secondLevelLength];
				firstLevelTable[i] = secondLevelTable;
			}
			while (count > 0)
			{
				if (j + count <= secondLevelLength)
				{
					while (count > 0)
					{
						secondLevelTable[j] = 0;
						count--;
						j++;
					}
				}
				else
				{
					while (j < secondLevelLength)
					{
						secondLevelTable[j] = 0;
						count--;
						j++;
					}
					j = 0;
					i++;
					secondLevelTable = firstLevelTable[i];
					if (secondLevelTable == null)
					{
						secondLevelTable = new ushort[secondLevelLength];
						firstLevelTable[i] = secondLevelTable;
					}
				}
			}
		}

		internal bool CanReadObjectBackCorrectly(int id, int size, int typeSizeStacktraceIndex, int allocTickIndex)
		{
			LiveObject o;
			GetNextObject(id, id + size, out o);
			return o.id == id && o.typeSizeStacktraceIndex == typeSizeStacktraceIndex && o.allocTickIndex == allocTickIndex;
		}

		internal void InsertObject(int id, int typeSizeStacktraceIndex, int allocTickIndex, int nowTickIndex, bool newAlloc, SampleObjectTable sampleObjectTable)
		{
			if (lastPos >= readNewLog.pos && newAlloc)
				return;
			lastPos = readNewLog.pos;

			lastTickIndex = nowTickIndex;
			int[] stacktrace = readNewLog.stacktraceTable.IndexToStacktrace(typeSizeStacktraceIndex);
			int typeIndex = stacktrace[0];
			int size = stacktrace[1];
			bool emptySpace = false;
			if (newAlloc)
				emptySpace = intervalTable.AddObject(id, size, allocTickIndex, sampleObjectTable);
			if (!emptySpace)
			{
				int prevId = FindObjectBackward(id-4);
				LiveObject o;
				GetNextObject(prevId, id, out o);
				if (o.id < id && o.id + o.size > id)
				{
					Zero(o.id, id - o.id);
				}
			}
			if (size >= 12)
			{
				ushort u1 = (ushort)(typeSizeStacktraceIndex | 0x8000);
				ushort u2 = (ushort)((typeSizeStacktraceIndex >> 15) | ((allocTickIndex & 0xff) << 7));
				ushort u3 = (ushort)(allocTickIndex >> 8);
				Write3WordsAt(id, u1, u2, u3);
				if (!emptySpace)
					Zero(id + 12, size - 12);
				Debug.Assert(CanReadObjectBackCorrectly(id, size, typeSizeStacktraceIndex, allocTickIndex));
			}
			if (sampleObjectTable != null)
				sampleObjectTable.Insert(id, id + size, nowTickIndex, typeIndex);
		}

		void RemoveObjectRange(int firstId, int length, int tickIndex, SampleObjectTable sampleObjectTable)
		{
			int lastId = firstId + length;

			if (sampleObjectTable != null)
				sampleObjectTable.Delete(firstId, lastId, tickIndex);

			Zero(firstId, length);
		}

		internal void UpdateObjects(Histogram relocatedHistogram, int oldId, int newId, int length, int tickIndex, SampleObjectTable sampleObjectTable)
		{
			if (lastPos >= readNewLog.pos)
				return;
			lastPos = readNewLog.pos;

			lastTickIndex = tickIndex;
			intervalTable.Relocate(oldId, newId, length);

			if (oldId == newId)
				return;
			int nextId;
			int lastId = oldId + length;
			LiveObject o;
			for (GetNextObject(oldId, lastId, out o); o.id < lastId; GetNextObject(nextId, lastId, out o))
			{
				nextId = o.id + o.size;
				int offset = o.id - oldId;
				if (sampleObjectTable != null)
					sampleObjectTable.Insert(o.id, o.id + o.size, tickIndex, 0);
				Zero(o.id, o.size);
				InsertObject(newId + offset, o.typeSizeStacktraceIndex, o.allocTickIndex, tickIndex, false, sampleObjectTable);
				if (relocatedHistogram != null)
					relocatedHistogram.AddObject(o.typeSizeStacktraceIndex, 1);
			}
		}

		private int lastGcGen0Count;
		private int lastGcGen1Count;
		private int lastGcGen2Count;

		internal int gen1LimitTickIndex;
		internal int gen2LimitTickIndex;

		internal void RecordGc(int tickIndex, int gcGen0Count, int gcGen1Count, int gcGen2Count, SampleObjectTable sampleObjectTable)
		{
			lastTickIndex = tickIndex;

			int gen = 0;
			if (gcGen2Count != lastGcGen2Count)
				gen = 2;
			else if (gcGen1Count != lastGcGen1Count)
				gen = 1;

			if (sampleObjectTable != null)
				sampleObjectTable.AddGcTick(tickIndex, gen);
	
			intervalTable.RecordGc();

			if (gen >= 1)
				gen2LimitTickIndex = gen1LimitTickIndex;
			gen1LimitTickIndex = tickIndex;

			lastGcGen0Count = gcGen0Count;
			lastGcGen1Count = gcGen1Count;
			lastGcGen2Count = gcGen2Count;
		}
	}

	internal class StacktraceTable
	{
		private int[][] stacktraceTable;

		internal StacktraceTable()
		{
			stacktraceTable = new int[1000][];
			stacktraceTable[0] = new int[0];
		}

		internal void Add(int id, int[] stack, int length)
		{
			while (stacktraceTable.Length <= id)
			{
				int[][] newStacktraceTable = new int[stacktraceTable.Length*2][];
				for (int i = 0; i < stacktraceTable.Length; i++)
					newStacktraceTable[i] = stacktraceTable[i];
				stacktraceTable = newStacktraceTable;
			}

			int[] stacktrace = new int[length];
			for (int i = 0; i < stacktrace.Length; i++)
				stacktrace[i] = stack[i];

			stacktraceTable[id] = stacktrace;
		}

		internal int[] IndexToStacktrace(int index)
		{
			return stacktraceTable[index];
		}
	}

	internal struct TimePos
	{
		internal double time;
		internal long pos;

		internal TimePos(double time, long pos)
		{
			this.time = time;
			this.pos = pos;
		}
	}

	public class ReadLogResult
	{
		internal Histogram allocatedHistogram;
		internal Histogram relocatedHistogram;
		internal Histogram callstackHistogram;
		internal LiveObjectTable liveObjectTable;
		internal SampleObjectTable sampleObjectTable;
		internal ObjectGraph objectGraph;
	}

	public class ReadNewLog
	{
		public ReadNewLog(string fileName)
		{
			//
			// TODO: Add constructor logic here
			//
			typeName = new string[1000];
			funcName = new string[1000];
			funcSignature = new string[1000];

			this.fileName = fileName;
		}

		internal StacktraceTable stacktraceTable;
		internal string fileName;

		StreamReader r;
		byte[] buffer;
		int bufPos;
		int bufLevel;
		int c;
		int line;
		internal long pos;
		long lastLineStartPos;
		internal string[] typeName;
		internal string[] funcName;
		internal string[] funcSignature;

		void EnsureVertexCapacity(int id, ref Vertex[] vertexArray)
		{
			Debug.Assert(id >= 0);
			if (id < vertexArray.Length)
				return;
			int newLength = vertexArray.Length*2;
			if (newLength <= id)
				newLength = id + 1;
			Vertex[] newVertexArray = new Vertex[newLength];
			Array.Copy(vertexArray, 0, newVertexArray, 0, vertexArray.Length);
			vertexArray = newVertexArray;
		}

		void EnsureStringCapacity(int id, ref string[] stringArray)
		{
			Debug.Assert(id >= 0);
			if (id < stringArray.Length)
				return;
			int newLength = stringArray.Length*2;
			if (newLength <= id)
				newLength = id + 1;
			string[] newStringArray = new string[newLength];
			Array.Copy(stringArray, 0, newStringArray, 0, stringArray.Length);
			stringArray = newStringArray;
		}

		internal void AddTypeVertex(int typeId, string typeName, Graph graph, ref Vertex[] typeVertex)
		{
			EnsureVertexCapacity(typeId, ref typeVertex);
			typeVertex[typeId] = graph.FindOrCreateVertex(typeName, null);
			typeVertex[typeId].interestLevel = FilterForm.InterestLevelOfTypeName(typeName);
		}

		internal void AddFunctionVertex(int funcId, string functionName, string signature, Graph graph, ref Vertex[] funcVertex)
		{
			EnsureVertexCapacity(funcId, ref funcVertex);
			funcVertex[funcId] = graph.FindOrCreateVertex(functionName, signature);
			funcVertex[funcId].interestLevel = FilterForm.InterestLevelOfMethodName(functionName);
		}

		void AddTypeName(int typeId, string typeName)
		{
			EnsureStringCapacity(typeId, ref this.typeName);
			this.typeName[typeId] = typeName;
		}

		int FillBuffer()
		{
			bufPos = 0;
			bufLevel = r.BaseStream.Read(buffer, 0, buffer.Length);
			if (bufPos < bufLevel)
				return buffer[bufPos++];
			else
				return -1;
		}

		int ReadChar()
		{
			pos++;
			if (bufPos < bufLevel)
				return buffer[bufPos++];
			else
				return FillBuffer();
		}

		int ReadHex()
		{
			int value = 0;
			while (true)
			{
				c = ReadChar();
				int digit = c;
				if (digit >= '0' && digit <= '9')
					digit -= '0';
				else if (digit >= 'a' && digit <= 'f')
					digit -= 'a' - 10;
				else if (digit >= 'A' && digit <= 'F')
					digit -= 'A' - 10;
				else
					return value;
				value = value*16 + digit;
			}
		}

		int ReadInt()
		{
			while (c == ' ' || c == '\t')
				c = ReadChar();
			bool negative = false;
			if (c == '-')
			{
				negative = true;
				c = ReadChar();
			}
			if (c >= '0' && c <= '9')
			{
				int value = 0;
				if (c == '0')
				{
					c = ReadChar();
					if (c == 'x' || c == 'X')
						value = ReadHex();
				}
				while (c >= '0' && c <= '9')
				{
					value = value*10 + c - '0';
					c = ReadChar();
				}

				if (negative)
					value = -value;
				return value;
			}
			else
			{
				return Int32.MinValue;
			}
		}

		int ForcePosInt()
		{
			int value = ReadInt();
			if (value >= 0)
				return value;
			else
				throw new Exception(string.Format("Bad format in log file {0} line {1}", fileName, line));
		}

		internal static int[] GrowIntVector(int[] vector)
		{
			int[] newVector = new int[vector.Length*2];
			for (int i = 0; i < vector.Length; i++)
				newVector[i] = vector[i];
			return newVector;
		}

		internal static bool InterestingCallStack(Vertex[] vertexStack, int stackPtr)
		{
			if (stackPtr == 0)
				return FilterForm.methodFilter == "";
			if ((vertexStack[stackPtr-1].interestLevel & InterestLevel.Interesting) == InterestLevel.Interesting)
				return true;
			for (int i = stackPtr-2; i >= 0; i--)
			{
				switch (vertexStack[i].interestLevel & InterestLevel.InterestingChildren)
				{
					case	InterestLevel.Ignore:
						break;

					case	InterestLevel.InterestingChildren:
						return true;

					default:
						return false;
				}
			}
			return false;
		}

		internal static int FilterVertices(Vertex[] vertexStack, int stackPtr)
		{
			bool display = false;
			for (int i = 0; i < stackPtr; i++)
			{
				Vertex vertex = vertexStack[i];
				switch (vertex.interestLevel & InterestLevel.InterestingChildren)
				{
					case	InterestLevel.Ignore:
						if (display)
							vertex.interestLevel |= InterestLevel.Display;
						break;

					case	InterestLevel.InterestingChildren:
						display = true;
						break;

					default:
						display = false;
						break;
				}
			}
			display = false;
			for	(int i = stackPtr-1; i >= 0; i--)
			{
				Vertex vertex = vertexStack[i];
				switch (vertex.interestLevel & InterestLevel.InterestingParents)
				{
					case	InterestLevel.Ignore:
						if (display)
							vertex.interestLevel |= InterestLevel.Display;
						break;

					case	InterestLevel.InterestingParents:
						display = true;
						break;

					default:
						display = false;
						break;
				}
			}
			int newStackPtr = 0;
			for (int i = 0; i < stackPtr; i++)
			{
				Vertex vertex = vertexStack[i];
				if ((vertex.interestLevel & (InterestLevel.Display|InterestLevel.Interesting)) != InterestLevel.Ignore)
				{
					vertexStack[newStackPtr++] = vertex;
					vertex.interestLevel &= ~InterestLevel.Display;
				}
			}
			return newStackPtr;
		}

		TimePos[] timePos;
		int timePosCount, timePosIndex;
		const int maxTimePosCount = (1<<23)-1; // ~8,000,000 entries

		void GrowTimePos()
		{
			TimePos[] newTimePos = new TimePos[2*timePos.Length];
			for (int i = 0; i < timePos.Length; i++)
				newTimePos[i] = timePos[i];
			timePos = newTimePos;
		}

		int AddTimePos(int tick, long pos)
		{
			double time = tick*0.001;
			if (timePosIndex < timePosCount)
			{
				Debug.Assert(timePos[timePosIndex].time == time && timePos[timePosIndex].pos == pos);
				return timePosIndex++;
			}
			while (timePosCount >= timePos.Length)
				GrowTimePos();
			while (timePosCount > 0 && time < timePos[timePosCount-1].time)
			{
				// correct possible wraparound
				time += (1L<<32)*0.001;
			}
			// we have only 23 bits to encode allocation time.
			// to avoid running out for long running measurements, we decrease time resolution
			// as we chew up slots. below algorithm uses 1 millisecond resolution for the first
			// million slots, 2 milliseconds for the second million etc. this gives about
			// 2 million seconds time range or 23 days.
			double minimumTimeInc = 0.000999*(1<<timePosCount/(maxTimePosCount/8));
			if (timePosCount < maxTimePosCount && (time - timePos[timePosCount-1].time >= minimumTimeInc))
			{
				timePos[timePosCount] = new TimePos(time, pos);
				timePosIndex++;
				return timePosCount++;
			}
			else
				return timePosCount;
		}

		internal double TickIndexToTime(int tickIndex)
		{
			return timePos[tickIndex].time;
		}

		internal long TickIndexToPos(int tickIndex)
		{
			return timePos[tickIndex].pos;
		}

		internal int TimeToTickIndex(double time)
		{
			int l = 0;
			int r = timePosCount-1;
			if (time < timePos[l].time)
				return l;
			if (timePos[r].time <= time)
				return r;

			// binary search - loop invariant is timePos[l].time <= time && time < timePos[r].time
			// loop terminates because loop condition implies l < m < r and so the interval
			// shrinks on each iteration
			while (l + 1 < r)
			{
				int m = (l + r) / 2;
				if (time < timePos[m].time)
				{
					r = m;
				}
				else
				{
					l = m;
				}
			}

			// we still have the loop invariant timePos[l].time <= time && time < timePos[r].time
			// now we just return the index that gives the closer match.
			if (time - timePos[l].time < timePos[r].time - time)
				return l;
			else
				return r;
		}

		internal void ReadFile(long startFileOffset, long endFileOffset, ReadLogResult readLogResult)
		{
			Form2 progressForm = new Form2();
			progressForm.Text = string.Format("Progress loading {0}", fileName);
			progressForm.Visible = true;
			progressForm.setProgress(0);
			if (stacktraceTable == null)
				stacktraceTable = new StacktraceTable();
			if (timePos == null)
				timePos = new TimePos[1000];
			AddTypeName(0, "Free Space");
			try
			{
				Stream s = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
				r = new StreamReader(s);
				for (timePosIndex = timePosCount; timePosIndex > 0; timePosIndex--)
					if (timePos[timePosIndex-1].pos <= startFileOffset)
						break;
				if (timePosIndex <= 1)
				{
					pos = 0;
					timePosIndex = 1;
				}
				else
				{
					timePosIndex--;
					pos = timePos[timePosIndex].pos;
				}
				if (timePosCount == 0)
				{
					timePos[0] = new TimePos(0.0, 0);
					timePosCount = timePosIndex = 1;
				}
				s.Position = pos;
				buffer = new byte[4096];
				bufPos = 0;
				bufLevel = 0;
				int maxProgress = (int)(r.BaseStream.Length/1024);
				progressForm.setMaximum(maxProgress);
				this.fileName = fileName;
				line = 1;
				StringBuilder sb = new StringBuilder();
				int[] intStack = new int[1000];
				int stackPtr = 0;
				c = ReadChar();
				bool thisIsR = false, previousWasR;
				int lastTickIndex = 0;
				while (c != -1)
				{
					if (pos > endFileOffset)
						break;
					if ((line % 1024) == 0)
					{
						int currentProgress = (int)(pos/1024);
						if (currentProgress <= maxProgress)
							progressForm.setProgress(currentProgress);
					}
					lastLineStartPos = pos-1;
					previousWasR = thisIsR;
					thisIsR = false;
					switch (c)
					{
						case	-1:
							break;

						case	'F':
						case	'f':
						{
							c = ReadChar();
							int funcIndex = ReadInt();
							while (c == ' ' || c == '\t')
								c = ReadChar();
							sb.Length = 0;
							while (c > ' ')
							{
								sb.Append((char)c);
								c = ReadChar();
							}
							string name = sb.ToString();
							while (c == ' ' || c == '\t')
								c = ReadChar();
							sb.Length = 0;
							bool foundRightParenthesis = false;
							while (c > '\r')
							{
								if (!foundRightParenthesis)
									sb.Append((char)c);
								if (c == ')')
									foundRightParenthesis = true;
								c = ReadChar();
							}
							string signature = sb.ToString();
							if (c != -1)
							{
								EnsureStringCapacity(funcIndex, ref funcName);
								funcName[funcIndex] = name;
								EnsureStringCapacity(funcIndex, ref funcSignature);
								funcSignature[funcIndex] = signature;
							}
							break;
						}

						case	'T':
						case	't':
						{
							c = ReadChar();
							int typeIndex = ReadInt();
							while (c == ' ' || c == '\t')
								c = ReadChar();
							sb.Length = 0;
							while (c > '\r')
							{
								sb.Append((char)c);
								c = ReadChar();
							}
							string typeName = sb.ToString();
							if (c != -1)
							{
								AddTypeName(typeIndex, typeName);
							}
							break;
						}

						case	'A':
						case	'a':
						{
							c = ReadChar();
							int id = ReadInt();
							int typeSizeStackTraceIndex = ReadInt();
							if (c != -1)
							{
								if (readLogResult.liveObjectTable != null)
									readLogResult.liveObjectTable.InsertObject(id, typeSizeStackTraceIndex, lastTickIndex, lastTickIndex, true, readLogResult.sampleObjectTable);
								if (pos >= startFileOffset && pos < endFileOffset && readLogResult.allocatedHistogram != null)
									readLogResult.allocatedHistogram.AddObject(typeSizeStackTraceIndex, 1);
							}
							break;
						}

						case	'C':
						case	'c':
						{
							c = ReadChar();
							if (pos <  startFileOffset || pos >= endFileOffset)
							{
								while (c >= ' ')
									c = ReadChar();
								break;
							}
							int threadIndex = ReadInt();
							int stackTraceIndex = ReadInt();
							if (c != -1)
							{
								if (readLogResult.callstackHistogram != null)
									readLogResult.callstackHistogram.AddObject(stackTraceIndex, 1);
							}
							break;
						}

						case	'R':
						case	'r':
						{
							c = ReadChar();
							if (pos <  startFileOffset || pos >= endFileOffset)
							{
								while (c >= ' ')
									c = ReadChar();
								break;
							}
							thisIsR = true;
							if (!previousWasR)
							{
								if (readLogResult.objectGraph != null && readLogResult.objectGraph.idToObject.Count != 0)
									readLogResult.objectGraph.BuildTypeGraph();
								readLogResult.objectGraph = new ObjectGraph();
							}
							stackPtr = 0;
							int objectID;
							while ((objectID = ReadInt()) >= 0)
							{
								if (objectID > 0)
								{
									intStack[stackPtr] = objectID;
									stackPtr++;
									if (stackPtr >= intStack.Length)
										intStack = GrowIntVector(intStack);
								}
							}
							if (c != -1)
							{
								if (readLogResult.objectGraph != null)
									readLogResult.objectGraph.roots = readLogResult.objectGraph.LookupReferences(stackPtr, intStack);
							}
							break;
						}

						case	'O':
						case	'o':
						{
							c = ReadChar();
							if (pos <  startFileOffset || pos >= endFileOffset || readLogResult.objectGraph == null)
							{
								while (c >= ' ')
									c = ReadChar();
								break;
							}
							int objectId = ReadInt();
							int typeIndex = ReadInt();
							int size = ReadInt();
							stackPtr = 0;
							int objectID;
							while ((objectID = ReadInt()) >= 0)
							{
								if (objectID > 0)
								{
									intStack[stackPtr] = objectID;
									stackPtr++;
									if (stackPtr >= intStack.Length)
										intStack = GrowIntVector(intStack);
								}
							}
							if (c != -1)
							{
								ObjectGraph objectGraph = readLogResult.objectGraph;
								ObjectGraph.GcType gcType = objectGraph.GetOrCreateGcType(typeName[typeIndex]);
								ObjectGraph.GcObject gcObject = objectGraph.GetOrCreateObject(objectId);
								gcObject.size = size;
								gcObject.type = gcType;
								gcType.cumulativeSize += size;
								gcObject.references = objectGraph.LookupReferences(stackPtr, intStack);
							}
							break;
						}

						case	'M':
						case	'm':
							while (c >= ' ')
								c = ReadChar();
							break;

						case	'U':
						case	'u':
							c = ReadChar();
							int oldId = ReadInt();
							int newId = ReadInt();
							int length = ReadInt();
							Histogram reloHist = null;
							if (pos >= startFileOffset && pos < endFileOffset)
								reloHist = readLogResult.relocatedHistogram;
							if (readLogResult.liveObjectTable != null)
								readLogResult.liveObjectTable.UpdateObjects(reloHist, oldId, newId, length, lastTickIndex, readLogResult.sampleObjectTable);
							break;

						case	'I':
						case	'i':
							c = ReadChar();
							lastTickIndex = AddTimePos(ReadInt(), lastLineStartPos);
							break;

						case	'G':
						case	'g':
							c = ReadChar();
							int gcGen0Count = ReadInt();
							int gcGen1Count = ReadInt();
							int gcGen2Count = ReadInt();
							if (readLogResult.liveObjectTable != null)
								readLogResult.liveObjectTable.RecordGc(lastTickIndex, gcGen0Count, gcGen1Count, gcGen2Count, readLogResult.sampleObjectTable);
							break;

						case	'S':
						case	's':
						{
							c = ReadChar();
							int stackTraceIndex = ReadInt();
							int funcIndex;
							stackPtr = 0;
							while ((funcIndex = ReadInt()) >= 0)
							{
								intStack[stackPtr] = funcIndex;
								stackPtr++;
								if (stackPtr >= intStack.Length)
									intStack = GrowIntVector(intStack);
							}
							if (c != -1)
							{
								stacktraceTable.Add(stackTraceIndex, intStack, stackPtr);
							}
							break;
						}

						default:
							throw new Exception(string.Format("Bad format in log file {0} line {1}", fileName, line));
					}
					while (c == ' ' || c == '\t')
						c = ReadChar();
					if (c == '\r')
						c = ReadChar();
					if (c == '\n')
					{
						c = ReadChar();
						line++;
					}
				}
			}
/*			catch (Exception)
			{
				throw new Exception(string.Format("Bad format in log file {0} line {1}", fileName, line));
			}
*/
			finally
			{
				progressForm.Visible = false;
				progressForm.Dispose();
				if (r != null)
					r.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\caspol\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif

cool_compile_resource: CasPol.cs resources.txt
        internalresgen resources.txt caspol.resources

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(COOL_TARGET:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\savefileform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for SaveFileForm.
	/// </summary>
	public class SaveFileForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		internal System.Windows.Forms.Label processFileNameLabel;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Button yesButton;
		private System.Windows.Forms.Button noButton;
		private System.Windows.Forms.Button alwaysNoButton;
		private System.Windows.Forms.Button cancelButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public SaveFileForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.processFileNameLabel = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.yesButton = new System.Windows.Forms.Button();
			this.noButton = new System.Windows.Forms.Button();
			this.alwaysNoButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Arial", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(32, 32);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(248, 23);
			this.label1.TabIndex = 0;
			this.label1.Text = "You still have a profile for:";
			// 
			// processFileNameLabel
			// 
			this.processFileNameLabel.Font = new System.Drawing.Font("Arial", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.processFileNameLabel.Location = new System.Drawing.Point(40, 56);
			this.processFileNameLabel.Name = "processFileNameLabel";
			this.processFileNameLabel.Size = new System.Drawing.Size(384, 32);
			this.processFileNameLabel.TabIndex = 1;
			this.processFileNameLabel.Text = "label2";
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Arial", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(40, 96);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(232, 23);
			this.label2.TabIndex = 2;
			this.label2.Text = "Do want to save it?";
			// 
			// yesButton
			// 
			this.yesButton.DialogResult = System.Windows.Forms.DialogResult.Yes;
			this.yesButton.Location = new System.Drawing.Point(40, 128);
			this.yesButton.Name = "yesButton";
			this.yesButton.TabIndex = 3;
			this.yesButton.Text = "Yes";
			// 
			// noButton
			// 
			this.noButton.DialogResult = System.Windows.Forms.DialogResult.No;
			this.noButton.Location = new System.Drawing.Point(144, 128);
			this.noButton.Name = "noButton";
			this.noButton.TabIndex = 4;
			this.noButton.Text = "No";
			// 
			// alwaysNoButton
			// 
			this.alwaysNoButton.DialogResult = System.Windows.Forms.DialogResult.Retry;
			this.alwaysNoButton.Location = new System.Drawing.Point(248, 128);
			this.alwaysNoButton.Name = "alwaysNoButton";
			this.alwaysNoButton.TabIndex = 5;
			this.alwaysNoButton.Text = "Always No";
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(352, 128);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.TabIndex = 6;
			this.cancelButton.Text = "Cancel";
			// 
			// SaveFileForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(456, 181);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.cancelButton,
																		  this.alwaysNoButton,
																		  this.noButton,
																		  this.yesButton,
																		  this.label2,
																		  this.processFileNameLabel,
																		  this.label1});
			this.Name = "SaveFileForm";
			this.Text = "Save Profile?";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\timelineviewform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for TimeLineViewForm.
	/// </summary>
	public class TimeLineViewForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Splitter splitter1;
		private System.Windows.Forms.RadioButton twoKradioButton;
		private System.Windows.Forms.RadioButton oneKradioButton;
		private System.Windows.Forms.RadioButton oneMSradioButton;
		private System.Windows.Forms.RadioButton twoMSradioButton;
		private System.Windows.Forms.RadioButton fiveMSradioButton;
		private System.Windows.Forms.RadioButton tenMSradioButton;
		private System.Windows.Forms.RadioButton twentyMSradioButton;
		private System.Windows.Forms.RadioButton fiftyMSradioButton;
		private System.Windows.Forms.RadioButton oneHundredMSradioButton;
		private System.Windows.Forms.RadioButton twoHundredMSradioButton;
		private System.Windows.Forms.RadioButton fiveHundredMSradioButton;
		private System.Windows.Forms.RadioButton oneThousandMSradioButton;
		private System.Windows.Forms.RadioButton oneHundredKradioButton;
		private System.Windows.Forms.RadioButton fiftyKradioButton;
		private System.Windows.Forms.RadioButton tenKradioButton;
		private System.Windows.Forms.RadioButton fiveKradioButton;
		private System.Windows.Forms.RadioButton twoHundredKradioButton;
		private System.Windows.Forms.RadioButton fiveHundredKradioButton;
		private System.Windows.Forms.Panel graphOuterPanel;
		private System.Windows.Forms.Panel legendOuterPanel;
		private System.Windows.Forms.Panel graphPanel;
		private System.Windows.Forms.RadioButton twentyKradioButton;
		private System.Windows.Forms.GroupBox horizontalScaleGroupBox;
		private System.Windows.Forms.GroupBox verticalScaleGroupBox;
		private System.Windows.Forms.Panel typeLegendPanel;
		private System.Timers.Timer versionTimer;
		private System.Windows.Forms.MenuItem whoAllocatedMenuItem;
		private System.Windows.Forms.MenuItem showHistogramMenuItem;
		private System.Windows.Forms.MenuItem showObjectsMenuItem;
		private System.Windows.Forms.ContextMenu contextMenu;
		private System.Windows.Forms.MenuItem showRelocatedMenuItem;
		private System.Windows.Forms.MenuItem showAgeHistogramMenuItem;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		Font font;

		public TimeLineViewForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			toolTip = new ToolTip();
			toolTip.Active = false;
			toolTip.ShowAlways = true;

			font = Form1.instance.font;

			sampleObjectTable = Form1.instance.lastLogResult.sampleObjectTable;
			lastLog = sampleObjectTable.readNewLog;
			typeName = lastLog.typeName;
			lastTickIndex = sampleObjectTable.lastTickIndex;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			versionTimer.Stop();
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.panel1 = new System.Windows.Forms.Panel();
			this.horizontalScaleGroupBox = new System.Windows.Forms.GroupBox();
			this.oneThousandMSradioButton = new System.Windows.Forms.RadioButton();
			this.fiveHundredMSradioButton = new System.Windows.Forms.RadioButton();
			this.twoHundredMSradioButton = new System.Windows.Forms.RadioButton();
			this.oneHundredMSradioButton = new System.Windows.Forms.RadioButton();
			this.fiftyMSradioButton = new System.Windows.Forms.RadioButton();
			this.twentyMSradioButton = new System.Windows.Forms.RadioButton();
			this.tenMSradioButton = new System.Windows.Forms.RadioButton();
			this.fiveMSradioButton = new System.Windows.Forms.RadioButton();
			this.twoMSradioButton = new System.Windows.Forms.RadioButton();
			this.oneMSradioButton = new System.Windows.Forms.RadioButton();
			this.verticalScaleGroupBox = new System.Windows.Forms.GroupBox();
			this.fiveHundredKradioButton = new System.Windows.Forms.RadioButton();
			this.twoHundredKradioButton = new System.Windows.Forms.RadioButton();
			this.oneHundredKradioButton = new System.Windows.Forms.RadioButton();
			this.fiftyKradioButton = new System.Windows.Forms.RadioButton();
			this.twentyKradioButton = new System.Windows.Forms.RadioButton();
			this.tenKradioButton = new System.Windows.Forms.RadioButton();
			this.fiveKradioButton = new System.Windows.Forms.RadioButton();
			this.twoKradioButton = new System.Windows.Forms.RadioButton();
			this.oneKradioButton = new System.Windows.Forms.RadioButton();
			this.graphOuterPanel = new System.Windows.Forms.Panel();
			this.graphPanel = new System.Windows.Forms.Panel();
			this.splitter1 = new System.Windows.Forms.Splitter();
			this.legendOuterPanel = new System.Windows.Forms.Panel();
			this.typeLegendPanel = new System.Windows.Forms.Panel();
			this.versionTimer = new System.Timers.Timer();
			this.contextMenu = new System.Windows.Forms.ContextMenu();
			this.whoAllocatedMenuItem = new System.Windows.Forms.MenuItem();
			this.showObjectsMenuItem = new System.Windows.Forms.MenuItem();
			this.showHistogramMenuItem = new System.Windows.Forms.MenuItem();
			this.showRelocatedMenuItem = new System.Windows.Forms.MenuItem();
			this.showAgeHistogramMenuItem = new System.Windows.Forms.MenuItem();
			this.panel1.SuspendLayout();
			this.horizontalScaleGroupBox.SuspendLayout();
			this.verticalScaleGroupBox.SuspendLayout();
			this.graphOuterPanel.SuspendLayout();
			this.legendOuterPanel.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.versionTimer)).BeginInit();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.horizontalScaleGroupBox,
																				 this.verticalScaleGroupBox});
			this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(904, 88);
			this.panel1.TabIndex = 0;
			// 
			// horizontalScaleGroupBox
			// 
			this.horizontalScaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																								  this.oneThousandMSradioButton,
																								  this.fiveHundredMSradioButton,
																								  this.twoHundredMSradioButton,
																								  this.oneHundredMSradioButton,
																								  this.fiftyMSradioButton,
																								  this.twentyMSradioButton,
																								  this.tenMSradioButton,
																								  this.fiveMSradioButton,
																								  this.twoMSradioButton,
																								  this.oneMSradioButton});
			this.horizontalScaleGroupBox.Location = new System.Drawing.Point(424, 8);
			this.horizontalScaleGroupBox.Name = "horizontalScaleGroupBox";
			this.horizontalScaleGroupBox.Size = new System.Drawing.Size(424, 64);
			this.horizontalScaleGroupBox.TabIndex = 1;
			this.horizontalScaleGroupBox.TabStop = false;
			this.horizontalScaleGroupBox.Text = "Horizontal Scale: Milliseconds/Pixel";
			// 
			// oneThousandMSradioButton
			// 
			this.oneThousandMSradioButton.Location = new System.Drawing.Point(368, 24);
			this.oneThousandMSradioButton.Name = "oneThousandMSradioButton";
			this.oneThousandMSradioButton.Size = new System.Drawing.Size(48, 24);
			this.oneThousandMSradioButton.TabIndex = 9;
			this.oneThousandMSradioButton.Text = "1000";
			this.oneThousandMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fiveHundredMSradioButton
			// 
			this.fiveHundredMSradioButton.Location = new System.Drawing.Point(320, 24);
			this.fiveHundredMSradioButton.Name = "fiveHundredMSradioButton";
			this.fiveHundredMSradioButton.Size = new System.Drawing.Size(48, 24);
			this.fiveHundredMSradioButton.TabIndex = 8;
			this.fiveHundredMSradioButton.Text = "500";
			this.fiveHundredMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twoHundredMSradioButton
			// 
			this.twoHundredMSradioButton.Location = new System.Drawing.Point(272, 24);
			this.twoHundredMSradioButton.Name = "twoHundredMSradioButton";
			this.twoHundredMSradioButton.Size = new System.Drawing.Size(48, 24);
			this.twoHundredMSradioButton.TabIndex = 7;
			this.twoHundredMSradioButton.Text = "200";
			this.twoHundredMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// oneHundredMSradioButton
			// 
			this.oneHundredMSradioButton.Location = new System.Drawing.Point(224, 24);
			this.oneHundredMSradioButton.Name = "oneHundredMSradioButton";
			this.oneHundredMSradioButton.Size = new System.Drawing.Size(48, 24);
			this.oneHundredMSradioButton.TabIndex = 6;
			this.oneHundredMSradioButton.Text = "100";
			this.oneHundredMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fiftyMSradioButton
			// 
			this.fiftyMSradioButton.Location = new System.Drawing.Point(184, 24);
			this.fiftyMSradioButton.Name = "fiftyMSradioButton";
			this.fiftyMSradioButton.Size = new System.Drawing.Size(40, 24);
			this.fiftyMSradioButton.TabIndex = 5;
			this.fiftyMSradioButton.Text = "50";
			this.fiftyMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twentyMSradioButton
			// 
			this.twentyMSradioButton.Location = new System.Drawing.Point(144, 24);
			this.twentyMSradioButton.Name = "twentyMSradioButton";
			this.twentyMSradioButton.Size = new System.Drawing.Size(40, 24);
			this.twentyMSradioButton.TabIndex = 4;
			this.twentyMSradioButton.Text = "20";
			this.twentyMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// tenMSradioButton
			// 
			this.tenMSradioButton.Location = new System.Drawing.Point(104, 24);
			this.tenMSradioButton.Name = "tenMSradioButton";
			this.tenMSradioButton.Size = new System.Drawing.Size(40, 24);
			this.tenMSradioButton.TabIndex = 3;
			this.tenMSradioButton.Text = "10";
			this.tenMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fiveMSradioButton
			// 
			this.fiveMSradioButton.Location = new System.Drawing.Point(72, 24);
			this.fiveMSradioButton.Name = "fiveMSradioButton";
			this.fiveMSradioButton.Size = new System.Drawing.Size(32, 24);
			this.fiveMSradioButton.TabIndex = 2;
			this.fiveMSradioButton.Text = "5";
			this.fiveMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twoMSradioButton
			// 
			this.twoMSradioButton.Location = new System.Drawing.Point(40, 24);
			this.twoMSradioButton.Name = "twoMSradioButton";
			this.twoMSradioButton.Size = new System.Drawing.Size(32, 24);
			this.twoMSradioButton.TabIndex = 1;
			this.twoMSradioButton.Text = "2";
			this.twoMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// oneMSradioButton
			// 
			this.oneMSradioButton.Location = new System.Drawing.Point(8, 24);
			this.oneMSradioButton.Name = "oneMSradioButton";
			this.oneMSradioButton.Size = new System.Drawing.Size(24, 24);
			this.oneMSradioButton.TabIndex = 0;
			this.oneMSradioButton.Text = "1";
			this.oneMSradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// verticalScaleGroupBox
			// 
			this.verticalScaleGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																								this.fiveHundredKradioButton,
																								this.twoHundredKradioButton,
																								this.oneHundredKradioButton,
																								this.fiftyKradioButton,
																								this.twentyKradioButton,
																								this.tenKradioButton,
																								this.fiveKradioButton,
																								this.twoKradioButton,
																								this.oneKradioButton});
			this.verticalScaleGroupBox.Location = new System.Drawing.Point(16, 8);
			this.verticalScaleGroupBox.Name = "verticalScaleGroupBox";
			this.verticalScaleGroupBox.Size = new System.Drawing.Size(376, 64);
			this.verticalScaleGroupBox.TabIndex = 0;
			this.verticalScaleGroupBox.TabStop = false;
			this.verticalScaleGroupBox.Text = "Vertical Scale: Kilobytes/Pixel";
			// 
			// fiveHundredKradioButton
			// 
			this.fiveHundredKradioButton.Location = new System.Drawing.Point(320, 24);
			this.fiveHundredKradioButton.Name = "fiveHundredKradioButton";
			this.fiveHundredKradioButton.Size = new System.Drawing.Size(48, 24);
			this.fiveHundredKradioButton.TabIndex = 8;
			this.fiveHundredKradioButton.Text = "500";
			this.fiveHundredKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twoHundredKradioButton
			// 
			this.twoHundredKradioButton.Location = new System.Drawing.Point(272, 24);
			this.twoHundredKradioButton.Name = "twoHundredKradioButton";
			this.twoHundredKradioButton.Size = new System.Drawing.Size(48, 24);
			this.twoHundredKradioButton.TabIndex = 7;
			this.twoHundredKradioButton.Text = "200";
			this.twoHundredKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// oneHundredKradioButton
			// 
			this.oneHundredKradioButton.Location = new System.Drawing.Point(224, 24);
			this.oneHundredKradioButton.Name = "oneHundredKradioButton";
			this.oneHundredKradioButton.Size = new System.Drawing.Size(48, 24);
			this.oneHundredKradioButton.TabIndex = 6;
			this.oneHundredKradioButton.Text = "100";
			this.oneHundredKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fiftyKradioButton
			// 
			this.fiftyKradioButton.Location = new System.Drawing.Point(184, 24);
			this.fiftyKradioButton.Name = "fiftyKradioButton";
			this.fiftyKradioButton.Size = new System.Drawing.Size(40, 24);
			this.fiftyKradioButton.TabIndex = 5;
			this.fiftyKradioButton.Text = "50";
			this.fiftyKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twentyKradioButton
			// 
			this.twentyKradioButton.Location = new System.Drawing.Point(144, 24);
			this.twentyKradioButton.Name = "twentyKradioButton";
			this.twentyKradioButton.Size = new System.Drawing.Size(40, 24);
			this.twentyKradioButton.TabIndex = 4;
			this.twentyKradioButton.Text = "20";
			this.twentyKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// tenKradioButton
			// 
			this.tenKradioButton.Location = new System.Drawing.Point(104, 24);
			this.tenKradioButton.Name = "tenKradioButton";
			this.tenKradioButton.Size = new System.Drawing.Size(40, 24);
			this.tenKradioButton.TabIndex = 3;
			this.tenKradioButton.Text = "10";
			this.tenKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fiveKradioButton
			// 
			this.fiveKradioButton.Location = new System.Drawing.Point(72, 24);
			this.fiveKradioButton.Name = "fiveKradioButton";
			this.fiveKradioButton.Size = new System.Drawing.Size(32, 24);
			this.fiveKradioButton.TabIndex = 2;
			this.fiveKradioButton.Text = "5";
			this.fiveKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twoKradioButton
			// 
			this.twoKradioButton.Location = new System.Drawing.Point(40, 24);
			this.twoKradioButton.Name = "twoKradioButton";
			this.twoKradioButton.Size = new System.Drawing.Size(32, 24);
			this.twoKradioButton.TabIndex = 1;
			this.twoKradioButton.Text = "2";
			this.twoKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// oneKradioButton
			// 
			this.oneKradioButton.Location = new System.Drawing.Point(8, 24);
			this.oneKradioButton.Name = "oneKradioButton";
			this.oneKradioButton.Size = new System.Drawing.Size(32, 24);
			this.oneKradioButton.TabIndex = 0;
			this.oneKradioButton.Text = "1";
			this.oneKradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// graphOuterPanel
			// 
			this.graphOuterPanel.AutoScroll = true;
			this.graphOuterPanel.BackColor = System.Drawing.SystemColors.Control;
			this.graphOuterPanel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.graphOuterPanel.Controls.AddRange(new System.Windows.Forms.Control[] {
																						  this.graphPanel});
			this.graphOuterPanel.Dock = System.Windows.Forms.DockStyle.Left;
			this.graphOuterPanel.Location = new System.Drawing.Point(0, 88);
			this.graphOuterPanel.Name = "graphOuterPanel";
			this.graphOuterPanel.Size = new System.Drawing.Size(592, 501);
			this.graphOuterPanel.TabIndex = 1;
			this.graphOuterPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.graphOuterPanel_MouseDown);
			// 
			// graphPanel
			// 
			this.graphPanel.BackColor = System.Drawing.SystemColors.Control;
			this.graphPanel.Name = "graphPanel";
			this.graphPanel.Size = new System.Drawing.Size(576, 480);
			this.graphPanel.TabIndex = 0;
			this.graphPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.graphPanel_Paint);
			this.graphPanel.MouseMove += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseMove);
			this.graphPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseDown);
			// 
			// splitter1
			// 
			this.splitter1.Location = new System.Drawing.Point(592, 88);
			this.splitter1.Name = "splitter1";
			this.splitter1.Size = new System.Drawing.Size(3, 501);
			this.splitter1.TabIndex = 2;
			this.splitter1.TabStop = false;
			// 
			// legendOuterPanel
			// 
			this.legendOuterPanel.AutoScroll = true;
			this.legendOuterPanel.BackColor = System.Drawing.SystemColors.Control;
			this.legendOuterPanel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.legendOuterPanel.Controls.AddRange(new System.Windows.Forms.Control[] {
																						   this.typeLegendPanel});
			this.legendOuterPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			this.legendOuterPanel.Location = new System.Drawing.Point(595, 88);
			this.legendOuterPanel.Name = "legendOuterPanel";
			this.legendOuterPanel.Size = new System.Drawing.Size(309, 501);
			this.legendOuterPanel.TabIndex = 3;
			// 
			// typeLegendPanel
			// 
			this.typeLegendPanel.BackColor = System.Drawing.SystemColors.Control;
			this.typeLegendPanel.Name = "typeLegendPanel";
			this.typeLegendPanel.Size = new System.Drawing.Size(296, 480);
			this.typeLegendPanel.TabIndex = 0;
			this.typeLegendPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.typeLegendPanel_Paint);
			this.typeLegendPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.typeLegendPanel_MouseDown);
			// 
			// versionTimer
			// 
			this.versionTimer.Enabled = true;
			this.versionTimer.SynchronizingObject = this;
			this.versionTimer.Elapsed += new System.Timers.ElapsedEventHandler(this.versionTimer_Elapsed);
			// 
			// contextMenu
			// 
			this.contextMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																						this.whoAllocatedMenuItem,
																						this.showObjectsMenuItem,
																						this.showHistogramMenuItem,
																						this.showRelocatedMenuItem,
																						this.showAgeHistogramMenuItem});
			// 
			// whoAllocatedMenuItem
			// 
			this.whoAllocatedMenuItem.Index = 0;
			this.whoAllocatedMenuItem.Text = "Show Who Allocated";
			this.whoAllocatedMenuItem.Click += new System.EventHandler(this.whoAllocatedMenuItem_Click);
			// 
			// showObjectsMenuItem
			// 
			this.showObjectsMenuItem.Index = 1;
			this.showObjectsMenuItem.Text = "Show Objects by Address";
			this.showObjectsMenuItem.Click += new System.EventHandler(this.showObjectsMenuItem_Click);
			// 
			// showHistogramMenuItem
			// 
			this.showHistogramMenuItem.Index = 2;
			this.showHistogramMenuItem.Text = "Show Histogram Allocated Types";
			this.showHistogramMenuItem.Click += new System.EventHandler(this.showHistogramMenuItem_Click);
			// 
			// showRelocatedMenuItem
			// 
			this.showRelocatedMenuItem.Index = 3;
			this.showRelocatedMenuItem.Text = "Show Histogram Relocated Types";
			this.showRelocatedMenuItem.Click += new System.EventHandler(this.showRelocatedMenuItem_Click);
			// 
			// showAgeHistogramMenuItem
			// 
			this.showAgeHistogramMenuItem.Index = 4;
			this.showAgeHistogramMenuItem.Text = "Show Histogram By Age";
			this.showAgeHistogramMenuItem.Click += new System.EventHandler(this.showAgeHistogramMenuItem_Click);
			// 
			// TimeLineViewForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(904, 589);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.legendOuterPanel,
																		  this.splitter1,
																		  this.graphOuterPanel,
																		  this.panel1});
			this.Name = "TimeLineViewForm";
			this.Text = "View Time Line";
			this.panel1.ResumeLayout(false);
			this.horizontalScaleGroupBox.ResumeLayout(false);
			this.verticalScaleGroupBox.ResumeLayout(false);
			this.graphOuterPanel.ResumeLayout(false);
			this.legendOuterPanel.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.versionTimer)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		class AddressRange
		{
			internal int	loAddr;
			internal int hiAddr;
			internal AddressRange next;
			internal int index;

			internal AddressRange(int loAddr, int hiAddr, AddressRange next, int index)
			{
				this.loAddr = loAddr;
				this.hiAddr = hiAddr;
				this.next = next;
				this.index = index;
			}
		}

		const int allowableGap = 64*1024-1;

		AddressRange rangeList = null;
		int rangeCount = 0;

		string[] typeName;

		private void AddAddress(int addr)
		{
			if (rangeList != null && addr - rangeList.hiAddr <= allowableGap)
			{
				Debug.Assert(addr >= rangeList.hiAddr);
				rangeList.hiAddr = addr;
			}
			else
			{
				rangeList = new AddressRange(addr, addr, rangeList, rangeCount++);
			}

		}

		class TypeDesc : IComparable
		{
			internal string	typeName;
			internal long totalSize;
			internal Color color;
			internal Brush brush;
			internal Pen pen;
			internal bool selected;
			internal Rectangle rect;

			internal TypeDesc(string typeName)
			{
				this.typeName = typeName;
			}

			public int CompareTo(Object o)
			{
				TypeDesc t = (TypeDesc)o;
				if (t.totalSize < this.totalSize)
					return -1;
				else if (t.totalSize > this.totalSize)
					return 1;
				else
					return 0;
			}
		}

		TypeDesc[] typeIndexToTypeDesc;

		ArrayList sortedTypeTable;

		private void AddToTypeTable(int typeIndex, int lifeTime)
		{
			TypeDesc t = typeIndexToTypeDesc[typeIndex];
			if (t == null)
			{
				t = new TypeDesc(typeName[typeIndex]);
				typeIndexToTypeDesc[typeIndex] = t;
			}
			t.totalSize += lifeTime;
		}

		private void ProcessChangeList(SampleObjectTable.SampleObject so)
		{
			int lastTickIndex = sampleObjectTable.lastTickIndex;
			for ( ; so != null; so = so.prev)
			{
				AddToTypeTable(so.typeIndex, lastTickIndex - so.allocTickIndex);
				lastTickIndex = so.allocTickIndex;
			}
		}

		private void BuildAddressRangesTypeTable(SampleObjectTable.SampleObject[][] masterTable)
		{
			rangeList = null;
			rangeCount = 0;

			if (typeIndexToTypeDesc == null || typeIndexToTypeDesc.Length < typeName.Length)
				typeIndexToTypeDesc = new TypeDesc[typeName.Length];
			else
			{
				foreach (TypeDesc t in typeIndexToTypeDesc)
				{
					if (t != null)
						t.totalSize = 0;
				}
			}

			for (int i = 0; i < masterTable.Length; i++)
			{
				SampleObjectTable.SampleObject[] soa = masterTable[i];
				if (soa != null)
				{
					for (int j = 0; j < soa.Length; j++)
					{
						SampleObjectTable.SampleObject so = soa[j];
						if (so != null)
						{
							AddAddress((i<<SampleObjectTable.firstLevelShift)
								     + (j<<SampleObjectTable.secondLevelShift));
							ProcessChangeList(so);
						}
					}
				}
			}
			sortedTypeTable = new ArrayList();
			foreach (TypeDesc t in typeIndexToTypeDesc)
				if (t != null)
					sortedTypeTable.Add(t);
			sortedTypeTable.Sort();
		}

		static Color[] firstColors =
		{
			Color.Red,
			Color.Yellow,
			Color.Green,
			Color.Cyan,
			Color.Blue,
			Color.Magenta,
		};

		static Color[] colors = new Color[16];

		Color MixColor(Color a, Color b)
		{
			int R = (a.R + b.R)/2;
			int G = (a.G + b.G)/2;
			int B = (a.B + b.B)/2;

			return Color.FromArgb(R, G, B);
		}

		static void GrowColors()
		{
			Color[] newColors = new Color[2*colors.Length];
			for (int i = 0; i < colors.Length; i++)
				newColors[i] = colors[i];
			colors = newColors;
		}

		private void ColorTypes()
		{
			int count = 0;

			foreach (TypeDesc t in sortedTypeTable)
			{
				if (count >= colors.Length)
					GrowColors();
				if (count < firstColors.Length)
					colors[count] = firstColors[count];
				else
					colors[count] = MixColor(colors[count - firstColors.Length], colors[count - firstColors.Length + 1]);
				t.color = colors[count];
				if (t.typeName == "Free Space")
					t.color = Color.White;
				else
					count++;
			}
		}

		private void AssignBrushesPensToTypes()
		{
			bool anyTypeSelected = false;
			foreach (TypeDesc t in sortedTypeTable)
				anyTypeSelected |= t.selected;

			foreach (TypeDesc t in sortedTypeTable)
			{
				Color color = t.color;
				if (t.selected)
					color = Color.Black;
				else if (anyTypeSelected)
					color = MixColor(color, Color.White);
				t.brush = new SolidBrush(color);
				t.pen = new Pen(t.brush);
			}
		}

		int Scale(GroupBox groupBox, int pixelsAvailable, int rangeNeeded)
		{
			foreach (RadioButton rb in groupBox.Controls)
			{
				if (rb.Checked)
					return Int32.Parse(rb.Text);
			}
			// No radio button was checked - let's come up with a suitable default
			RadioButton maxLowScaleRB = null;
			int maxLowRange = 0;
			RadioButton minHighScaleRB = null;
			int minHighRange = Int32.MaxValue;
			foreach (RadioButton rb in groupBox.Controls)
			{
				int range = pixelsAvailable*Int32.Parse(rb.Text);
				if (range < rangeNeeded)
				{
					if (maxLowRange < range)
					{
						maxLowRange = range;
						maxLowScaleRB = rb;
					}
				}
				else
				{
					if (minHighRange > range)
					{
						minHighRange = range;
						minHighScaleRB = rb;
					}
				}
			}
			if (minHighScaleRB != null)
			{
				minHighScaleRB.Checked = true;
				return Int32.Parse(minHighScaleRB.Text);
			}
			else
			{
				maxLowScaleRB.Checked = true;
				return Int32.Parse(maxLowScaleRB.Text);
			}
		}

		int verticalScale;
		int horizontalScale;

		const int leftMargin = 30;
		const int bottomMargin = 30;
		const int gap = 10;
		const int clickMargin = 20;
		const int topMargin = 30;
		int rightMargin = 80;
		const int minHeight = 400;
		int dotSize = 8;

		private int TimeToX(double time)
		{
			return leftMargin + addressLabelWidth + (int)(time*1000/horizontalScale);
		}

		private int AddrToY(int addr)
		{
			int y = topMargin;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				if (r.loAddr <= addr && addr <= r.hiAddr)
					return y + (r.hiAddr - addr)/verticalScale;
				y += (r.hiAddr - r.loAddr)/verticalScale;
				y += gap + timeLabelHeight;
			}
			return y;
		}

		void IntersectIntervals(int aLow, int aHigh, ref int bLow, ref int bHigh)
		{
			bLow = Math.Max(aLow, bLow);
			bHigh = Math.Min(aHigh, bHigh);
		}

		private void DrawChangeList(Graphics g, SampleObjectTable.SampleObject so, int addr)
		{
			double lastTime = lastLog.TickIndexToTime(sampleObjectTable.lastTickIndex);
			int y = AddrToY(addr);
			RectangleF clipRect = g.VisibleClipBounds;
			for ( ; so != null; so = so.prev)
			{
				TypeDesc t = typeIndexToTypeDesc[so.typeIndex];

				double allocTime = lastLog.TickIndexToTime(so.allocTickIndex);
				int x1 = TimeToX(allocTime);
				int x2 = TimeToX(lastTime);
				IntersectIntervals((int)clipRect.Left, (int)clipRect.Right, ref x1, ref x2);
				if (x1 < x2)
					g.DrawLine(t.pen, x1, y, x2, y);
				lastTime = allocTime;
			}
		}

		private void DrawSamples(Graphics g, SampleObjectTable.SampleObject[][] masterTable)
		{
			RectangleF clipRect = g.VisibleClipBounds;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				int rangeTop = AddrToY(r.hiAddr);
				int rangeBottom = AddrToY(r.loAddr);
				IntersectIntervals((int)clipRect.Top, (int)clipRect.Bottom, ref rangeTop, ref rangeBottom);
				if (rangeTop < rangeBottom)
				{
					int hiAddr = YToAddr(rangeTop);
					for (int addr = YToAddr(rangeBottom)/verticalScale*verticalScale; addr <= hiAddr; addr += verticalScale)
					{
						int i = addr >> SampleObjectTable.firstLevelShift;
						SampleObjectTable.SampleObject[] soa = masterTable[i];
						if (soa != null)
						{
							int j = (addr >> SampleObjectTable.secondLevelShift) & (SampleObjectTable.secondLevelLength-1);
							SampleObjectTable.SampleObject so = soa[j];
							if (so != null)
							{
								int y = AddrToY(addr);
								Debug.Assert(addr == (i<<SampleObjectTable.firstLevelShift)
								                   + (j<<SampleObjectTable.secondLevelShift));
								if (clipRect.Top <= y && y <= clipRect.Bottom)
									DrawChangeList(g, so, addr);
							}
						}
					}
				}
			}
		}

		int addressLabelWidth;

		private void DrawAddressLabel(Graphics g, Brush brush, Pen pen, AddressRange r, int y, int addr)
		{
			y += (r.hiAddr - addr)/verticalScale;
			string s = string.Format("{0:x8}", addr);
			g.DrawString(s, font, brush, leftMargin, y - font.Height/2);
			g.DrawLine(pen, leftMargin + addressLabelWidth - 3, y, leftMargin + addressLabelWidth, y);
		}

		private void DrawAddressLabels(Graphics g)
		{
			RectangleF clipRect = g.VisibleClipBounds;
			if (clipRect.Left > leftMargin + addressLabelWidth)
				return;
			Brush brush = new SolidBrush(Color.Black);
			Pen pen = new Pen(brush);
			const int minLabelPitchInPixels = 30;
			int minLabelPitch = minLabelPitchInPixels*verticalScale;

			int labelPitch = 1024;
			while (labelPitch < minLabelPitch)
				labelPitch *= 2;

			int y = topMargin;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				DrawAddressLabel(g, brush, pen, r, y, r.loAddr);
				for (int addr = (r.loAddr + labelPitch*3/2) & ~(labelPitch-1); addr <= r.hiAddr; addr += labelPitch)
					DrawAddressLabel(g, brush, pen, r, y, addr);
				y += (r.hiAddr - r.loAddr)/verticalScale;
				y += gap + timeLabelHeight;
			}
		}

		int timeLabelHeight;

		private void DrawTimeLabels(Graphics g, double lastTime)
		{
			RectangleF clipRect = g.VisibleClipBounds;
			int labelPitchInPixels = 100;
			int timeLabelWidth = (int)g.MeasureString("999.9 sec ", font).Width;
			while (labelPitchInPixels < timeLabelWidth)
				labelPitchInPixels += 100;
			double labelPitch = labelPitchInPixels*horizontalScale*0.001;

			Brush brush = new SolidBrush(Color.DarkBlue);
			Pen pen = new Pen(brush);

			int y = topMargin;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				y += (r.hiAddr - r.loAddr)/verticalScale;
				if (y <= clipRect.Bottom && clipRect.Top <= y + timeLabelHeight)
				{
					for (double time = 0; time < lastTime; time += labelPitch)
					{
						int x = TimeToX(time);
						int x1 = x;
						int x2 = x1 + timeLabelWidth;
						IntersectIntervals((int)clipRect.Left, (int)clipRect.Right, ref x1, ref x2);
						if (x1 < x2)
						{
							string s = string.Format("{0:f1} sec", time);
							g.DrawLine(pen, x, y, x, y + font.Height + 6);
							g.DrawString(s, font, brush, x, y + font.Height);
						}
					}
				}
				y += timeLabelHeight + gap;
			}
		}

		private void DrawGcTicks(Graphics g, SampleObjectTable.SampleObject gcTickList)
		{
			RectangleF clipRect = g.VisibleClipBounds;
			Brush[] brushes = new Brush[3];
			Pen[] pens = new Pen[3];
			brushes[0] = new SolidBrush(Color.Red);
			brushes[1] = new SolidBrush(Color.Green);
			brushes[2] = new SolidBrush(Color.Blue);
			for (int i = 0; i < 3; i++)
				pens[i] = new Pen(brushes[i]);

			int totalGcCount = 0;
			for (SampleObjectTable.SampleObject gc = gcTickList; gc != null; gc = gc.prev)
				totalGcCount++;

			int y = topMargin;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				y += (r.hiAddr - r.loAddr)/verticalScale;
				if (y <= clipRect.Bottom && clipRect.Top <= y + timeLabelHeight)
				{
					int gcCount = totalGcCount;
					int lastLabelX = Int32.MaxValue;
					for (SampleObjectTable.SampleObject gc = gcTickList; gc != null; gc = gc.prev)
					{
						int gen = gc.typeIndex;
						int x = TimeToX(lastLog.TickIndexToTime(gc.allocTickIndex));
						string s;
						if (gen == 0)
							s = string.Format("gc #{0}", gcCount);
						else
							s = string.Format("gc #{0} (gen {1})", gcCount, gen);
						int minLabelPitch = (int)g.MeasureString(s, font).Width + 10;
						if (lastLabelX - x >= minLabelPitch)
						{
							int x1 = x;
							int x2 = x1 + minLabelPitch;
							IntersectIntervals((int)clipRect.Left, (int)clipRect.Right, ref x1, ref x2);
							if (x1 < x2)
							{
								g.DrawLine(pens[gen], x, y, x, y+6);
								g.DrawString(s, font, brushes[gen], x, y);
							}
							lastLabelX = x;
						}
						else if (clipRect.Left <= x && x <= clipRect.Right)
						{
							g.DrawLine(pens[gen], x, y, x, y+3);
						}
						gcCount--;
					}
				}
				y += timeLabelHeight + gap;
			}
		}

		SampleObjectTable sampleObjectTable;
		ReadNewLog lastLog;
		int lastTickIndex;
		bool initialized;

		private int RightMargin(Graphics g)
		{
			return (int)g.MeasureString("gc #999 (gen 2)", font).Width;
		}

		private void graphPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			initialized = false;

			Graphics g = e.Graphics;

			rightMargin = RightMargin(g);

			lastTickIndex = sampleObjectTable.lastTickIndex;

			if (rangeList == null)
			{
				BuildAddressRangesTypeTable(sampleObjectTable.masterTable);
				ColorTypes();
				AssignBrushesPensToTypes();
			}

			int range = 0;
			for (AddressRange r = rangeList; r != null; r = r.next)
				range += r.hiAddr - r.loAddr;

			timeLabelHeight = font.Height*2;

			verticalScale = Scale(verticalScaleGroupBox, graphPanel.Height - topMargin - bottomMargin - timeLabelHeight - (timeLabelHeight + gap)*(rangeCount-1), range/1024)*1024;

			addressLabelWidth = (int)e.Graphics.MeasureString("012345678", font).Width;

			double lastTime = lastLog.TickIndexToTime(lastTickIndex);
			horizontalScale = Scale(horizontalScaleGroupBox, graphPanel.Width - leftMargin - addressLabelWidth - rightMargin, (int)(lastTime*1000.0));

			graphPanel.Width = leftMargin
				+ addressLabelWidth
				+ (int)(lastTime*1000/horizontalScale)
				+ rightMargin;

			int height = topMargin;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				height += (r.hiAddr - r.loAddr)/verticalScale;
				height += gap + timeLabelHeight;
			}
			height -= gap;
			height += bottomMargin;

			graphPanel.Height = height;

			g.SetClip(e.ClipRectangle);

			DrawSamples(g, sampleObjectTable.masterTable);

			DrawAddressLabels(g);

			DrawTimeLabels(g, lastTime);

			DrawGcTicks(g, sampleObjectTable.gcTickList);

			if (selectedStartTickIndex != selectedEndTickIndex)
				DrawSelectionVerticalLine(g, selectedStartTickIndex);
			DrawSelectionVerticalLine(g, selectedEndTickIndex);
			DrawSelectionHorizontalLines(g, selectedStartTickIndex, selectedEndTickIndex);

			initialized = true;
		}

		private void Refresh(object sender, System.EventArgs e)
		{
			graphPanel.Invalidate();
		}

		const int typeLegendSpacing = 3;

		private void CalculateAllocatedObjectSizes(int startTickIndex, int endTickIndex, int addr)
		{
			int index = addr >> SampleObjectTable.firstLevelShift;
			SampleObjectTable.SampleObject[] sot = sampleObjectTable.masterTable[index];
			if (sot == null)
				return;

			index = (addr >> SampleObjectTable.secondLevelShift) & (SampleObjectTable.secondLevelLength-1);

			for (SampleObjectTable.SampleObject so = sot[index]; so != null; so = so.prev)
			{
				if (startTickIndex <= so.allocTickIndex && so.allocTickIndex < endTickIndex && so.typeIndex != 0)
				{
					if (so.prev == null || so.prev.typeIndex == 0)
						typeIndexToTypeDesc[so.typeIndex].totalSize += SampleObjectTable.sampleGrain;
				}
			}
		}

		private void CalculateAllocatedObjectSizes(int startTick, int endTick)
		{
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				for (int addr = r.loAddr; addr < r.hiAddr; addr += SampleObjectTable.sampleGrain)
				{
					CalculateAllocatedObjectSizes(startTick, endTick, addr);
				}
			}
		}
		
		private void CalculateLiveObjectSizes(int tick)
		{
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				for (int addr = r.loAddr; addr < r.hiAddr; addr += SampleObjectTable.sampleGrain)
				{
					SampleObjectTable.SampleObject so = FindSampleObject(tick, addr);
					if (so != null && so.typeIndex != 0)
						typeIndexToTypeDesc[so.typeIndex].totalSize += SampleObjectTable.sampleGrain;
				}
			}
		}

		private void DrawTypeLegend(Graphics g)
		{
			dotSize = (int)g.MeasureString("0", font).Width;
			int maxWidth = 0;
			int x = leftMargin;
			int y = topMargin + font.Height + typeLegendSpacing;
			foreach (TypeDesc t in sortedTypeTable)
			{
				int typeWidth = (int)g.MeasureString(t.typeName + " - 999,999,999 bytes (100.00%)", font).Width+dotSize*2;
				t.rect = new Rectangle(x, y, typeWidth, font.Height);
				if (maxWidth < t.rect.Width)
					maxWidth = t.rect.Width;
				y = t.rect.Bottom + typeLegendSpacing;
			}
			int height = y + bottomMargin;
			typeLegendPanel.Height = height;

			int width = leftMargin + maxWidth + rightMargin;
			typeLegendPanel.Width = width;

			x = leftMargin;
			y = topMargin;

			Brush blackBrush = new SolidBrush(Color.Black);

			long totalSize = 0;
			foreach (TypeDesc t in sortedTypeTable)
				totalSize += t.totalSize;
			if (totalSize == 0)
				totalSize = 1;

			string title = "Types:";
			if (selectedStartTickIndex != 0)
			{
				double startTime = lastLog.TickIndexToTime(selectedStartTickIndex);
				double endTime = lastLog.TickIndexToTime(selectedEndTickIndex);
				if (selectedEndTickIndex != selectedStartTickIndex)
				{
					title = string.Format("Types - estimated sizes allocated between {0:f3} and {1:f3} seconds:", startTime, endTime);
				}
				else
				{
					title = string.Format("Types - estimated sizes live at {0:f3} seconds:", startTime);
				}
			}
			g.DrawString(title, font, blackBrush, leftMargin, topMargin);
			int dotOffset = (font.Height - dotSize)/2;
			foreach (TypeDesc t in sortedTypeTable)
			{
				string caption = t.typeName;
				if (selectedStartTickIndex != 0)
				{
					double percentage = 100.0*t.totalSize/totalSize;
					caption += string.Format(" - {0:n0} bytes ({1:f2}%)", t.totalSize, percentage);
				}
				g.FillRectangle(t.brush, t.rect.Left, t.rect.Top+dotOffset, dotSize, dotSize);
				g.DrawString(caption, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top);
				y = t.rect.Bottom + typeLegendSpacing;
			}
		}

		private void typeLegendPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			if (rangeList == null)
			{
				BuildAddressRangesTypeTable(sampleObjectTable.masterTable);
				ColorTypes();
				AssignBrushesPensToTypes();
			}

			DrawTypeLegend(e.Graphics);		
		}

		private void typeLegendPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != 0)
			{
				if (sortedTypeTable != null)
				{
					foreach (TypeDesc t in sortedTypeTable)
					{
						if (t.rect.Contains(e.X, e.Y) != t.selected)
						{
							t.selected = !t.selected;
							AssignBrushesPensToTypes();
							graphPanel.Invalidate();
							typeLegendPanel.Invalidate();
						}
					}
				}
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(typeLegendPanel, p);
			}
		}

		private void versionTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			if (font != Form1.instance.font)
			{
				font = Form1.instance.font;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}

			ReadLogResult lastLogResult = Form1.instance.lastLogResult;
			if (lastLogResult != null && lastLogResult.sampleObjectTable != sampleObjectTable)
			{
				sampleObjectTable = lastLogResult.sampleObjectTable;
				lastLog = sampleObjectTable.readNewLog;
				typeName = lastLog.typeName;
				lastTickIndex = sampleObjectTable.lastTickIndex;

				rangeList = null;
				rangeCount = 0;

				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}
		}

		private int XToTickIndex(int x)
		{
			x -= leftMargin + addressLabelWidth;
			double time = x*horizontalScale*0.001;
			return sampleObjectTable.readNewLog.TimeToTickIndex(time);
		}

		private int YToAddr(int y)
		{
			int rY = topMargin;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				int nextY = rY + (r.hiAddr - r.loAddr)/verticalScale;
				if (rY <= y && y <= nextY)
					return r.hiAddr - (y - rY)*verticalScale;
				rY = nextY;
				rY += gap + timeLabelHeight;
			}
			return 0;
		}

		private void DrawChangeList(Graphics g, SampleObjectTable.SampleObject so, int addr, int tickIndex)
		{
			int nextTickIndex = sampleObjectTable.lastTickIndex;
			for ( ; so != null; so = so.prev)
			{
				if (so.allocTickIndex <= tickIndex && tickIndex < nextTickIndex)
				{
					TypeDesc t = typeIndexToTypeDesc[so.typeIndex];

					int x = TimeToX(lastLog.TickIndexToTime(tickIndex));
					int y = AddrToY(addr);
					g.DrawLine(t.pen, x-1, y, x, y);
					break;
				}
				nextTickIndex = so.allocTickIndex;
			}
		}

		private void DrawSamples(Graphics g, SampleObjectTable.SampleObject[][] masterTable, int tick)
		{
			for (int i = 0; i < masterTable.Length; i++)
			{
				SampleObjectTable.SampleObject[] soa = masterTable[i];
				if (soa != null)
				{
					for (int j = 0; j < soa.Length; j++)
					{
						SampleObjectTable.SampleObject so = soa[j];
						if (so != null)
						{
							int addr = (i<<SampleObjectTable.firstLevelShift)
								     + (j<<SampleObjectTable.secondLevelShift);
							if ((addr % verticalScale) == 0)
								DrawChangeList(g, so, addr, tick);
						}
					}
				}
			}
		}

		const int selectionVerticalMargin = 5;

		private void EraseSelectionVerticalLine(Graphics g, int tickIndex)
		{
			Pen backgroundPen = new Pen(graphPanel.BackColor);
			int x = TimeToX(lastLog.TickIndexToTime(tickIndex));
			g.DrawLine(backgroundPen, x, 0, x, graphPanel.Height);
			DrawSamples(g, sampleObjectTable.masterTable, tickIndex);
		}

		private void DrawSelectionVerticalLine(Graphics g, int tickIndex)
		{
			int x = TimeToX(lastLog.TickIndexToTime(tickIndex));
			Pen blackPen = new Pen(Color.Black);
			g.DrawLine(blackPen, x, selectionVerticalMargin, x, graphPanel.Height-selectionVerticalMargin);
		}

		private void DrawSelectionHorizontalLines(Graphics g, Pen pen, int startTickIndex, int endTickIndex)
		{
			int startX = TimeToX(lastLog.TickIndexToTime(startTickIndex));
			int endX = TimeToX(lastLog.TickIndexToTime(endTickIndex));
			g.DrawLine(pen, startX, selectionVerticalMargin, endX, selectionVerticalMargin);
			g.DrawLine(pen, startX, graphPanel.Height-selectionVerticalMargin, endX, graphPanel.Height-selectionVerticalMargin);
		}

		private void EraseSelectionHorizontalLines(Graphics g, int startTick, int endTick)
		{
			Pen backGroundPen = new Pen(graphPanel.BackColor);
			DrawSelectionHorizontalLines(g, backGroundPen, startTick, endTick);
		}

		private void DrawSelectionHorizontalLines(Graphics g, int startTick, int endTick)
		{
			Pen blackPen = new Pen(Color.Black);
			DrawSelectionHorizontalLines(g, blackPen, startTick, endTick);
		}

		private int selectedStartTickIndex, selectedEndTickIndex, selectionAnchorTickIndex;

		private void SetSelection(int newStartTickIndex, int newEndTickIndex)
		{
			Graphics g = graphPanel.CreateGraphics();
			if (newStartTickIndex != selectedStartTickIndex)
				EraseSelectionVerticalLine(g, selectedStartTickIndex);
			if (newEndTickIndex!= selectedEndTickIndex)
				EraseSelectionVerticalLine(g, selectedEndTickIndex);
			if (newStartTickIndex != newEndTickIndex)
				DrawSelectionVerticalLine(g, newStartTickIndex);
			DrawSelectionVerticalLine(g, newEndTickIndex);
			if (newStartTickIndex == selectedStartTickIndex)
			{
				if (newEndTickIndex < selectedEndTickIndex)
					EraseSelectionHorizontalLines(g, newEndTickIndex, selectedEndTickIndex);
				else
					DrawSelectionHorizontalLines(g, selectedEndTickIndex, newEndTickIndex);
			}
			else if (newEndTickIndex == selectedEndTickIndex)
			{
				if (newStartTickIndex < selectedStartTickIndex)
					DrawSelectionHorizontalLines(g, newStartTickIndex, selectedStartTickIndex);
				else
					EraseSelectionHorizontalLines(g, selectedStartTickIndex, newStartTickIndex);
			}
			else
			{
				EraseSelectionHorizontalLines(g, selectedStartTickIndex, selectedEndTickIndex);
				DrawSelectionHorizontalLines(g, newStartTickIndex, newEndTickIndex);
			}
			selectedStartTickIndex = newStartTickIndex;
			selectedEndTickIndex = newEndTickIndex;

			DrawAddressLabels(g);
			DrawTimeLabels(g, lastLog.TickIndexToTime(lastTickIndex));
			DrawGcTicks(g, sampleObjectTable.gcTickList);

			if (selectedStartTickIndex != 0)
			{
				double selectedStartTime = lastLog.TickIndexToTime(selectedStartTickIndex);
				double selectedEndTime = lastLog.TickIndexToTime(selectedEndTickIndex);
				if (selectedStartTime == selectedEndTime)
				{
					Text = string.Format("View Time Line - selected: {0:f3} seconds", selectedStartTime);
					showHistogramMenuItem.Enabled = false;
					showObjectsMenuItem.Enabled = true;
					showRelocatedMenuItem.Enabled = false;
					whoAllocatedMenuItem.Enabled = false;
					showAgeHistogramMenuItem.Enabled = true;
				}
				else
				{
					Text = string.Format("View Time Line - selected: {0:f3} seconds - {1:f3} seconds", selectedStartTime, selectedEndTime);
					showHistogramMenuItem.Enabled = true;
					showObjectsMenuItem.Enabled = false;
					showRelocatedMenuItem.Enabled = true;
					whoAllocatedMenuItem.Enabled = true;
					showAgeHistogramMenuItem.Enabled = false;
				}
			}
			else
			{
				Text = "View Time Line";
				showHistogramMenuItem.Enabled = true;
				showObjectsMenuItem.Enabled = false;
				showRelocatedMenuItem.Enabled = true;
				whoAllocatedMenuItem.Enabled = true;
			}
			if (selectedStartTickIndex != 0)
			{
				foreach (TypeDesc t in sortedTypeTable)
					t.totalSize = 0;

				if (selectedStartTickIndex == selectedEndTickIndex)
					CalculateLiveObjectSizes(selectedStartTickIndex);
				else
					CalculateAllocatedObjectSizes(selectedStartTickIndex, selectedEndTickIndex);

				sortedTypeTable.Sort();
			}
			typeLegendPanel.Invalidate();
		}

		private void ExtendSelection(int x)
		{
			int selectedTickIndex = XToTickIndex(x);
			if (selectedTickIndex != 0)
			{
				if (selectedTickIndex < selectionAnchorTickIndex)
					SetSelection(selectedTickIndex, selectionAnchorTickIndex);
				else
					SetSelection(selectionAnchorTickIndex, selectedTickIndex);
			}
		}

		private void graphPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != 0)
			{
				if ((Control.ModifierKeys & Keys.Shift) != 0)
				{
					ExtendSelection(e.X);
				}
				else
				{
					selectionAnchorTickIndex = XToTickIndex(e.X);
					SetSelection(selectionAnchorTickIndex, selectionAnchorTickIndex);
				}
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(graphPanel, p);
			}
		}

		SampleObjectTable.SampleObject FindSampleObject(int tickIndex, int addr)
		{
			int index = addr >> SampleObjectTable.firstLevelShift;
			SampleObjectTable.SampleObject[] sot = sampleObjectTable.masterTable[index];
			if (sot == null)
				return null;

			index = (addr >> SampleObjectTable.secondLevelShift) & (SampleObjectTable.secondLevelLength-1);
			
			int nextTickIndex = lastTickIndex;
			for (SampleObjectTable.SampleObject so = sot[index]; so != null; so = so.prev)
			{
				if (so.allocTickIndex <= tickIndex && tickIndex < nextTickIndex)
					return so;
				nextTickIndex = so.allocTickIndex;
			}
			return null;
		}

		private int HeapSize(int tick)
		{
			int sum = 0;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				for (int addr = r.loAddr; addr < r.hiAddr; addr += SampleObjectTable.sampleGrain)
				{
					SampleObjectTable.SampleObject so = FindSampleObject(tick, addr);
					if (so != null && so.typeIndex != 0)
						sum += SampleObjectTable.sampleGrain;
				}
			}
			return sum;
		}
		
		private ToolTip toolTip;

		private void graphPanel_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (!initialized)
				return;

			if ((e.Button & MouseButtons.Left) != 0)
			{
				ExtendSelection(e.X);
			}
			else if (e.Button == MouseButtons.None)
			{
				int tickIndex = XToTickIndex(e.X);
				int addr = YToAddr(e.Y);
				int heapSize = HeapSize(tickIndex);
				string caption = string.Format("{0:f3} seconds, {1:n0} bytes heap size", lastLog.TickIndexToTime(tickIndex), heapSize);
				SampleObjectTable.SampleObject so = FindSampleObject(tickIndex, addr);
				if (so != null && so.typeIndex != 0)
					caption = string.Format("{0} at 0x{1:x} - ", typeName[so.typeIndex], addr) + caption;
				toolTip.Active = true;
				toolTip.SetToolTip(graphPanel, caption);
			}
		}

		private void graphOuterPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != 0)
			{
				if ((Control.ModifierKeys & Keys.Shift) == 0)
				{
					selectionAnchorTickIndex = 0;
					SetSelection(0, 0);
				}
			}
		}

		private void whoAllocatedMenuItem_Click(object sender, System.EventArgs e)
		{
			int startTickIndex = 0;
			int endTickIndex = lastTickIndex;
			if (selectedStartTickIndex != 0)
			{
				startTickIndex = selectedStartTickIndex;
				endTickIndex = selectedEndTickIndex;
			}
			ReadNewLog log = sampleObjectTable.readNewLog;
			long startPos = log.TickIndexToPos(startTickIndex);
			long endPos = log.TickIndexToPos(endTickIndex);

			// Read the selected portion of the log again
			ReadLogResult readLogResult = new ReadLogResult();
			readLogResult.allocatedHistogram = new Histogram(log);
			log.ReadFile(startPos, endPos, readLogResult);
			Graph graph = readLogResult.allocatedHistogram.BuildAllocationGraph();

			// And post it back to the main form - hardest part is to compute an appropriate title...

			string title = string.Format("Allocation Graph for Objects allocated between {0:f3} and {1:f3} seconds", lastLog.TickIndexToTime(startTickIndex), lastLog.TickIndexToTime(endTickIndex));
			GraphViewForm graphViewForm = new GraphViewForm(graph, title);
			graphViewForm.Visible = true;
		}

		private void showHistogramMenuItem_Click(object sender, System.EventArgs e)
		{
			int startTickIndex = 0;
			int endTickIndex = lastTickIndex;
			if (selectedStartTickIndex != 0)
			{
				startTickIndex = selectedStartTickIndex;
				endTickIndex = selectedEndTickIndex;
			}
			ReadNewLog log = sampleObjectTable.readNewLog;
			long startPos = log.TickIndexToPos(startTickIndex);
			long endPos = log.TickIndexToPos(endTickIndex);

			// Read the selected portion of the log again
			ReadLogResult readLogResult = new ReadLogResult();
			readLogResult.allocatedHistogram = new Histogram(log);
			log.ReadFile(startPos, endPos, readLogResult);

			// And post it to a new histogram form - hardest part is to compute an appropriate title...

			string title = string.Format("Histogram by Size for Objects allocated between {0:f3} and {1:f3} seconds", lastLog.TickIndexToTime(startTickIndex), lastLog.TickIndexToTime(endTickIndex));
			HistogramViewForm histogramViewForm = new HistogramViewForm(readLogResult.allocatedHistogram, title);
			histogramViewForm.Show();
		}

		private void showObjectsMenuItem_Click(object sender, System.EventArgs e)
		{
			int endTickIndex = lastTickIndex;
			if (selectedEndTickIndex != 0)
			{
				endTickIndex = selectedEndTickIndex;
			}
			ReadNewLog log = sampleObjectTable.readNewLog;
			long endPos = log.TickIndexToPos(endTickIndex);

			// Read the selected portion of the log again
			ReadLogResult readLogResult = new ReadLogResult();
			readLogResult.liveObjectTable = new LiveObjectTable(log);
			log.ReadFile(0, endPos, readLogResult);

			// And post it to a new Objects by Address form - hardest part is to compute an appropriate title...

			string title = string.Format("Live Objects by Address at {0:f3} seconds", lastLog.TickIndexToTime(endTickIndex));
			ViewByAddressForm viewByAddressForm = new ViewByAddressForm(readLogResult.liveObjectTable, title);
			viewByAddressForm.Show();
		}

		private void showRelocatedMenuItem_Click(object sender, System.EventArgs e)
		{
			int startTickIndex = 0;
			int endTickIndex = lastTickIndex;
			if (selectedStartTickIndex != 0)
			{
				startTickIndex = selectedStartTickIndex;
				endTickIndex = selectedEndTickIndex;
			}
			ReadNewLog log = sampleObjectTable.readNewLog;
			long startPos = log.TickIndexToPos(startTickIndex);
			long endPos = log.TickIndexToPos(endTickIndex);

			// Read the selected portion of the log again

			ReadLogResult readLogResult = new ReadLogResult();
			readLogResult.relocatedHistogram = new Histogram(log);
			readLogResult.liveObjectTable = new LiveObjectTable(log);
			log.ReadFile(startPos, endPos, readLogResult);

			// And post it to a new histogram form - hardest part is to compute an appropriate title...

			string title = string.Format("Histogram by Size for Objects relocated between {0:f3} and {1:f3} seconds", lastLog.TickIndexToTime(startTickIndex), lastLog.TickIndexToTime(endTickIndex));
			HistogramViewForm histogramViewForm = new HistogramViewForm(readLogResult.relocatedHistogram, title);
			histogramViewForm.Show();
		}

		private void showAgeHistogramMenuItem_Click(object sender, System.EventArgs e)
		{
			int endTickIndex = lastTickIndex;
			if (selectedEndTickIndex != 0)
			{
				endTickIndex = selectedEndTickIndex;
			}
			ReadNewLog log = sampleObjectTable.readNewLog;
			long endPos = log.TickIndexToPos(endTickIndex);

			// Read the selected portion of the log again
			ReadLogResult readLogResult = new ReadLogResult();
			readLogResult.liveObjectTable = new LiveObjectTable(log);
			log.ReadFile(0, endPos, readLogResult);

			// And post it to a new Histogram by Age form - hardest part is to compute an appropriate title...

			string title = string.Format("Histogram by Age for Live Objects at {0:f3} seconds", lastLog.TickIndexToTime(endTickIndex));
			AgeHistogram ageHistogram = new AgeHistogram(readLogResult.liveObjectTable, title);
			ageHistogram.Show();		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\caspol\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "CASPOL.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework CAS Policy Manager\0"
#define VER_ORIGFILENAME_STR    "caspol.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\comservicestlb\makefile.inc ===
target_sign_link :  $(TARGETPATH)\$(TARGETNAME)

$(TARGETPATH)\$(TARGETNAME) : $(TARGETPATH)\Microsoft.ComServices.dll $(TARGETPATH)\tlbexp.exe
!if "$(TARGETCOMPLUS)" != ""
	$(TARGETPATH)\tlbexp.exe $(TARGETCOMPLUS)\Microsoft.ComServices.dll /out:$(TARGETPATH)\Microsoft.ComServices.tlb
    copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!else
	$(TARGETPATH)\tlbexp.exe $(TARGETPATH)\Microsoft.ComServices.dll /out:$(TARGETPATH)\Microsoft.ComServices.tlb
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\chainenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  // Exposes an enumerator for Chains. 
  //
  // This is horribly broken at this point, as Chains aren't implemented yet.
  internal class ChainEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugChainEnum m_enum;

#if I_DONT_WANT_TO
    private Chain m_chain;
#else
    private Object m_chain;
#endif

    internal ChainEnumerator (ICorDebugChainEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new ChainEnumerator ((ICorDebugChainEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
#if I_DONT_WANT_TO
      ICorDebugChain[] a = new ICorDebugChain[1];
      uint c = 0;
      int r = m_enum.Next (a.Length, a, ref c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_chain = new Chain (a[0]);
      else
        m_chain = null;
      return m_chain != null;
#else
      return false;
#endif
      }

    public void Reset ()
      {m_enum.Reset ();
      m_chain = null;}

    public Object Current
      {get {return m_chain;}}
    } /* class ChainEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\breakpointenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for Assemblies. */
  internal class BreakpointEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugBreakpointEnum m_enum;
    private Breakpoint m_br;

    internal BreakpointEnumerator (ICorDebugBreakpointEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new BreakpointEnumerator ((ICorDebugBreakpointEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugBreakpoint[] a = new ICorDebugBreakpoint[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_br = new Breakpoint (a[0]);
      else
        m_br = null;
      return m_br != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_br = null;}

    public Object Current
      {get {return m_br;}}
    } /* class BreakpointEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\breakpoint.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  /** A breakpoint. */
  public class Breakpoint
    {
    private ICorDebugBreakpoint m_br;

    internal Breakpoint (ICorDebugBreakpoint br)
      {m_br = br;}

    protected ICorDebugBreakpoint GetBreakpoint ()
      {return m_br;}

    public void Activate (bool active)
      {m_br.Activate (active ? 1 : 0);}
    public void Activate ()
      {Activate (true);}
    public void Deactivate ()
      {Activate (false);}

    public bool IsActive ()
      {
      int r = 0;
      m_br.IsActive (out r);
      return !(r==0);
      }
    } /* class Breakpoint */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\controller.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using CORDBLib;

namespace Debugging
  {
  // Represents a scope at which program execution can be controlled.
  public class Controller
    {
    private ICorDebugController m_controller;

    protected ICorDebugController GetController ()
      {return m_controller;}

    internal Controller (ICorDebugController controller)
      {
      m_controller = controller;
      }

    // Cooperative stop on all threads running managed code in the process.
    public void Stop (int timeout)
      {m_controller.Stop ((uint)timeout);}

    // Continue processes after a call to Stop.
    //
    // outOfBand is true if continuing from an unmanaged event that
    // was sent with the outOfBand flag in the unmanaged callback;
    // false if continueing from a managed event or normal unmanaged event.
    public void Continue (bool outOfBand)
      {m_controller.Continue (outOfBand ? 1 : 0);}

    // Are the threads in the process running freely?
    public bool IsRunning ()
      {
      int running = 0;
      m_controller.IsRunning (out running);
      return !(running == 0);
      }

    // Are there managed callbacks queued up for the requested thread?
    public bool HasQueuedCallbacks (DebuggedThread thread)
      {
      int queued = 0;
      m_controller.HasQueuedCallbacks (thread.GetInterface(), out queued);
      return !(queued == 0);
      }

    /** Enumerate over all threads in active in the process. */
    public IEnumerable Threads
      {
      get
        {
        ICorDebugThreadEnum ethreads = null;
        m_controller.EnumerateThreads (out ethreads);
        return new DebuggedThreadEnumerator (ethreads);
        }
      }

    // Set the current debug state of each thread.
    public void SetAllThreadsDebugState (
      CorDebugThreadState   state, 
      DebuggedThread        exceptThis)
      {
      m_controller.SetAllThreadsDebugState (state, 
        exceptThis != null ? exceptThis.GetInterface() : null);
      }

    /** Detach the debugger from the process/appdomain. */
    public void Detach ()
      {m_controller.Detach ();}
    
    /** Terminate the current process. */
    public void Terminate (int exitCode)
      {m_controller.Terminate ((uint)exitCode);}

    /** Can the delta PEs be applied to the running process? */
    /*
    public IEnumerable CanCommitChanges (uint number, 
      EditAndContinueSnapshot[] snapshots)
      {
      ICorDebugErrorInfoEnum error = null;
      m_controller.CanCommitChanges (number, snapshots, out error);
      if (error == null)
        return null;
      return new ErrorInfoEnumerator (error);
      }
     */

    /** Apply the delta PEs to the running process. */
    /*
    public IEnumerable CommitChanges (uint number, 
      EditAndContinueSnapshot[] snapshots)
      {
      ICorDebugErrorInfoEnum error = null;
      m_controller.CommitChanges (number, snapshots, out error);
      if (error == null)
        return null;
      return new ErrorInfoEnumerator (error);
      }
     */
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\allocationprofiler\viewbyaddressform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;

namespace AllocationProfiler
{
	/// <summary>
	/// Summary description for ViewByAddressForm.
	/// </summary>
	public class ViewByAddressForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.RadioButton fourRadioButton;
		private System.Windows.Forms.RadioButton eightRadioButton;
		private System.Windows.Forms.RadioButton sixteenRadioButton;
		private System.Windows.Forms.RadioButton thirtytwoRadioButton;
		private System.Windows.Forms.RadioButton sixtyfourRadioButton;
		private System.Windows.Forms.RadioButton onetwoeightRadioButton;
		private System.Windows.Forms.RadioButton twofivesixRadioButton;
		private System.Windows.Forms.RadioButton fiveonetwoRadioButton;
		private System.Windows.Forms.RadioButton tentwentyfourRadioButton;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Panel outerGraphPanel;
		private System.Windows.Forms.Panel graphPanel;
		private System.Windows.Forms.Splitter splitter1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Panel typeLegendPanel;
		private System.Windows.Forms.GroupBox bytesPerPixelgroupBox;
		private System.Windows.Forms.GroupBox heapWidthGroupBox;
		private System.Timers.Timer versionTimer;
		private System.Windows.Forms.ContextMenu contextMenu;
		private System.Windows.Forms.MenuItem showAllocatorsMenuItem;
		private System.Windows.Forms.MenuItem showHistogramMenuItem;
		private System.Windows.Forms.MenuItem exportMenuItem;
		private System.Windows.Forms.SaveFileDialog exportSaveFileDialog;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		private bool autoUpdate;
		private System.Windows.Forms.RadioButton threetwoRadioButton;
		private System.Windows.Forms.RadioButton sixfourradioButton;
		private string baseTitle;

		Font font;

		internal ViewByAddressForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			toolTip = new ToolTip();
			toolTip.Active = false;
			toolTip.ShowAlways = true;

			autoUpdate = true;
			baseTitle = "View Objects by Address";

			ReadLogResult logResult = Form1.instance.lastLogResult;
			if (logResult != null)
			{
				liveObjectTable = logResult.liveObjectTable;
				typeName = liveObjectTable.readNewLog.typeName;
			}

			font = Form1.instance.font;
		}

		internal ViewByAddressForm(LiveObjectTable liveObjectTable, string title) : this()
		{
			this.liveObjectTable = liveObjectTable;
			autoUpdate = false;
			baseTitle = title;
			Text = title;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			versionTimer.Stop();
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.bytesPerPixelgroupBox = new System.Windows.Forms.GroupBox();
			this.sixtyfourRadioButton = new System.Windows.Forms.RadioButton();
			this.thirtytwoRadioButton = new System.Windows.Forms.RadioButton();
			this.sixteenRadioButton = new System.Windows.Forms.RadioButton();
			this.eightRadioButton = new System.Windows.Forms.RadioButton();
			this.fourRadioButton = new System.Windows.Forms.RadioButton();
			this.heapWidthGroupBox = new System.Windows.Forms.GroupBox();
			this.sixfourradioButton = new System.Windows.Forms.RadioButton();
			this.threetwoRadioButton = new System.Windows.Forms.RadioButton();
			this.tentwentyfourRadioButton = new System.Windows.Forms.RadioButton();
			this.fiveonetwoRadioButton = new System.Windows.Forms.RadioButton();
			this.twofivesixRadioButton = new System.Windows.Forms.RadioButton();
			this.onetwoeightRadioButton = new System.Windows.Forms.RadioButton();
			this.panel1 = new System.Windows.Forms.Panel();
			this.outerGraphPanel = new System.Windows.Forms.Panel();
			this.graphPanel = new System.Windows.Forms.Panel();
			this.splitter1 = new System.Windows.Forms.Splitter();
			this.panel2 = new System.Windows.Forms.Panel();
			this.typeLegendPanel = new System.Windows.Forms.Panel();
			this.versionTimer = new System.Timers.Timer();
			this.contextMenu = new System.Windows.Forms.ContextMenu();
			this.showAllocatorsMenuItem = new System.Windows.Forms.MenuItem();
			this.showHistogramMenuItem = new System.Windows.Forms.MenuItem();
			this.exportMenuItem = new System.Windows.Forms.MenuItem();
			this.exportSaveFileDialog = new System.Windows.Forms.SaveFileDialog();
			this.bytesPerPixelgroupBox.SuspendLayout();
			this.heapWidthGroupBox.SuspendLayout();
			this.panel1.SuspendLayout();
			this.outerGraphPanel.SuspendLayout();
			this.panel2.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.versionTimer)).BeginInit();
			this.SuspendLayout();
			// 
			// bytesPerPixelgroupBox
			// 
			this.bytesPerPixelgroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																								this.sixtyfourRadioButton,
																								this.thirtytwoRadioButton,
																								this.sixteenRadioButton,
																								this.eightRadioButton,
																								this.fourRadioButton});
			this.bytesPerPixelgroupBox.Location = new System.Drawing.Point(40, 24);
			this.bytesPerPixelgroupBox.Name = "bytesPerPixelgroupBox";
			this.bytesPerPixelgroupBox.Size = new System.Drawing.Size(216, 48);
			this.bytesPerPixelgroupBox.TabIndex = 1;
			this.bytesPerPixelgroupBox.TabStop = false;
			this.bytesPerPixelgroupBox.Text = "Bytes / Pixel";
			// 
			// sixtyfourRadioButton
			// 
			this.sixtyfourRadioButton.Location = new System.Drawing.Point(168, 16);
			this.sixtyfourRadioButton.Name = "sixtyfourRadioButton";
			this.sixtyfourRadioButton.Size = new System.Drawing.Size(40, 24);
			this.sixtyfourRadioButton.TabIndex = 4;
			this.sixtyfourRadioButton.Text = "64";
			this.sixtyfourRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// thirtytwoRadioButton
			// 
			this.thirtytwoRadioButton.Location = new System.Drawing.Point(128, 16);
			this.thirtytwoRadioButton.Name = "thirtytwoRadioButton";
			this.thirtytwoRadioButton.Size = new System.Drawing.Size(40, 24);
			this.thirtytwoRadioButton.TabIndex = 3;
			this.thirtytwoRadioButton.Text = "32";
			this.thirtytwoRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// sixteenRadioButton
			// 
			this.sixteenRadioButton.Location = new System.Drawing.Point(88, 16);
			this.sixteenRadioButton.Name = "sixteenRadioButton";
			this.sixteenRadioButton.Size = new System.Drawing.Size(40, 24);
			this.sixteenRadioButton.TabIndex = 2;
			this.sixteenRadioButton.Text = "16";
			this.sixteenRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// eightRadioButton
			// 
			this.eightRadioButton.Location = new System.Drawing.Point(48, 16);
			this.eightRadioButton.Name = "eightRadioButton";
			this.eightRadioButton.Size = new System.Drawing.Size(32, 24);
			this.eightRadioButton.TabIndex = 1;
			this.eightRadioButton.Text = "8";
			this.eightRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fourRadioButton
			// 
			this.fourRadioButton.Location = new System.Drawing.Point(8, 16);
			this.fourRadioButton.Name = "fourRadioButton";
			this.fourRadioButton.Size = new System.Drawing.Size(32, 24);
			this.fourRadioButton.TabIndex = 0;
			this.fourRadioButton.Text = "4";
			this.fourRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// heapWidthGroupBox
			// 
			this.heapWidthGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
																							this.sixfourradioButton,
																							this.threetwoRadioButton,
																							this.tentwentyfourRadioButton,
																							this.fiveonetwoRadioButton,
																							this.twofivesixRadioButton,
																							this.onetwoeightRadioButton});
			this.heapWidthGroupBox.Location = new System.Drawing.Point(304, 24);
			this.heapWidthGroupBox.Name = "heapWidthGroupBox";
			this.heapWidthGroupBox.Size = new System.Drawing.Size(296, 48);
			this.heapWidthGroupBox.TabIndex = 2;
			this.heapWidthGroupBox.TabStop = false;
			this.heapWidthGroupBox.Text = "Width / Addressrange";
			// 
			// sixfourradioButton
			// 
			this.sixfourradioButton.Location = new System.Drawing.Point(56, 16);
			this.sixfourradioButton.Name = "sixfourradioButton";
			this.sixfourradioButton.Size = new System.Drawing.Size(40, 24);
			this.sixfourradioButton.TabIndex = 5;
			this.sixfourradioButton.Text = "64";
			this.sixfourradioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// threetwoRadioButton
			// 
			this.threetwoRadioButton.Location = new System.Drawing.Point(16, 16);
			this.threetwoRadioButton.Name = "threetwoRadioButton";
			this.threetwoRadioButton.Size = new System.Drawing.Size(40, 24);
			this.threetwoRadioButton.TabIndex = 4;
			this.threetwoRadioButton.Text = "32";
			this.threetwoRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// tentwentyfourRadioButton
			// 
			this.tentwentyfourRadioButton.Location = new System.Drawing.Point(240, 16);
			this.tentwentyfourRadioButton.Name = "tentwentyfourRadioButton";
			this.tentwentyfourRadioButton.Size = new System.Drawing.Size(48, 24);
			this.tentwentyfourRadioButton.TabIndex = 3;
			this.tentwentyfourRadioButton.Text = "1024";
			this.tentwentyfourRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// fiveonetwoRadioButton
			// 
			this.fiveonetwoRadioButton.Location = new System.Drawing.Point(192, 16);
			this.fiveonetwoRadioButton.Name = "fiveonetwoRadioButton";
			this.fiveonetwoRadioButton.Size = new System.Drawing.Size(48, 24);
			this.fiveonetwoRadioButton.TabIndex = 2;
			this.fiveonetwoRadioButton.Text = "512";
			this.fiveonetwoRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// twofivesixRadioButton
			// 
			this.twofivesixRadioButton.Location = new System.Drawing.Point(144, 16);
			this.twofivesixRadioButton.Name = "twofivesixRadioButton";
			this.twofivesixRadioButton.Size = new System.Drawing.Size(48, 24);
			this.twofivesixRadioButton.TabIndex = 1;
			this.twofivesixRadioButton.Text = "256";
			this.twofivesixRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// onetwoeightRadioButton
			// 
			this.onetwoeightRadioButton.Location = new System.Drawing.Point(96, 16);
			this.onetwoeightRadioButton.Name = "onetwoeightRadioButton";
			this.onetwoeightRadioButton.Size = new System.Drawing.Size(48, 24);
			this.onetwoeightRadioButton.TabIndex = 0;
			this.onetwoeightRadioButton.Text = "128";
			this.onetwoeightRadioButton.CheckedChanged += new System.EventHandler(this.Refresh);
			// 
			// panel1
			// 
			this.panel1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.bytesPerPixelgroupBox,
																				 this.heapWidthGroupBox});
			this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(864, 100);
			this.panel1.TabIndex = 3;
			// 
			// outerGraphPanel
			// 
			this.outerGraphPanel.AutoScroll = true;
			this.outerGraphPanel.BackColor = System.Drawing.SystemColors.Control;
			this.outerGraphPanel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.outerGraphPanel.Controls.AddRange(new System.Windows.Forms.Control[] {
																						  this.graphPanel});
			this.outerGraphPanel.Dock = System.Windows.Forms.DockStyle.Left;
			this.outerGraphPanel.Location = new System.Drawing.Point(0, 100);
			this.outerGraphPanel.Name = "outerGraphPanel";
			this.outerGraphPanel.Size = new System.Drawing.Size(520, 489);
			this.outerGraphPanel.TabIndex = 4;
			// 
			// graphPanel
			// 
			this.graphPanel.BackColor = System.Drawing.SystemColors.Control;
			this.graphPanel.Name = "graphPanel";
			this.graphPanel.Size = new System.Drawing.Size(512, 480);
			this.graphPanel.TabIndex = 0;
			this.graphPanel.MouseUp += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseUp);
			this.graphPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.graphPanel_Paint);
			this.graphPanel.MouseMove += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseMove);
			this.graphPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.graphPanel_MouseDown);
			// 
			// splitter1
			// 
			this.splitter1.Location = new System.Drawing.Point(520, 100);
			this.splitter1.Name = "splitter1";
			this.splitter1.Size = new System.Drawing.Size(3, 489);
			this.splitter1.TabIndex = 5;
			this.splitter1.TabStop = false;
			// 
			// panel2
			// 
			this.panel2.AutoScroll = true;
			this.panel2.BackColor = System.Drawing.SystemColors.Control;
			this.panel2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.panel2.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.typeLegendPanel});
			this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel2.Location = new System.Drawing.Point(523, 100);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(341, 489);
			this.panel2.TabIndex = 6;
			// 
			// typeLegendPanel
			// 
			this.typeLegendPanel.BackColor = System.Drawing.SystemColors.Control;
			this.typeLegendPanel.Name = "typeLegendPanel";
			this.typeLegendPanel.Size = new System.Drawing.Size(336, 480);
			this.typeLegendPanel.TabIndex = 0;
			this.typeLegendPanel.Paint += new System.Windows.Forms.PaintEventHandler(this.typeLegendPanel_Paint);
			this.typeLegendPanel.MouseDown += new System.Windows.Forms.MouseEventHandler(this.typeLegendPanel_MouseDown);
			// 
			// versionTimer
			// 
			this.versionTimer.Enabled = true;
			this.versionTimer.SynchronizingObject = this;
			this.versionTimer.Elapsed += new System.Timers.ElapsedEventHandler(this.versionTimer_Elapsed);
			// 
			// contextMenu
			// 
			this.contextMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																						this.showAllocatorsMenuItem,
																						this.showHistogramMenuItem,
																						this.exportMenuItem});
			// 
			// showAllocatorsMenuItem
			// 
			this.showAllocatorsMenuItem.Index = 0;
			this.showAllocatorsMenuItem.Text = "Show Who Allocated";
			this.showAllocatorsMenuItem.Click += new System.EventHandler(this.showAllocatorsMenuItem_Click);
			// 
			// showHistogramMenuItem
			// 
			this.showHistogramMenuItem.Index = 1;
			this.showHistogramMenuItem.Text = "Show Histogram by Size";
			this.showHistogramMenuItem.Click += new System.EventHandler(this.showHistogramMenuItem_Click);
			// 
			// exportMenuItem
			// 
			this.exportMenuItem.Index = 2;
			this.exportMenuItem.Text = "Export Data to File...";
			this.exportMenuItem.Click += new System.EventHandler(this.exportMenuItem_Click);
			// 
			// exportSaveFileDialog
			// 
			this.exportSaveFileDialog.FileName = "doc1";
			// 
			// ViewByAddressForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(864, 589);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.panel2,
																		  this.splitter1,
																		  this.outerGraphPanel,
																		  this.panel1});
			this.Name = "ViewByAddressForm";
			this.Text = "View Objects by Address";
			this.bytesPerPixelgroupBox.ResumeLayout(false);
			this.heapWidthGroupBox.ResumeLayout(false);
			this.panel1.ResumeLayout(false);
			this.outerGraphPanel.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.versionTimer)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		Brush blackBrush = new SolidBrush(Color.Black);

		const int generations = 3;

		class AddressRange
		{
			internal int	loAddr;
			internal int hiAddr;
			internal AddressRange next;
			internal int index;
			internal int[] genLoAddr;
			internal int[] genHiAddr;

			internal AddressRange(int loAddr, int hiAddr, AddressRange next, int index)
			{
				this.loAddr = loAddr;
				this.hiAddr = hiAddr;
				this.next = next;
				this.index = index;
				this.genLoAddr = new int[generations];
				this.genHiAddr = new int[generations];
				for (int i = 0; i < generations; i++)
				{
					this.genLoAddr[i] = int.MaxValue;
					this.genHiAddr[i] = int.MinValue;
				}
			}
		}

		const int allowableGap = 1024*1024-1;

		AddressRange rangeList = null;
		int rangeCount = 0;

		class TypeDesc : IComparable
		{
			internal string	typeName;
			internal int typeIndex;
			internal int totalSize;
			internal int selectedSize;
			internal double percentage;
			internal double selectedPercentage;
			internal Color[] colors;
			internal Brush[] brushes;
			internal Pen[] pens;
			internal int selected;
			internal Rectangle rect;

			internal TypeDesc(int typeIndex, string typeName)
			{
				this.typeIndex = typeIndex;
				this.typeName = typeName;
			}

			public int CompareTo(Object o)
			{
				TypeDesc t = (TypeDesc)o;
				if (t.selectedSize != this.selectedSize)
					return t.selectedSize - this.selectedSize;
				return t.totalSize - this.totalSize;
			}
		}

		TypeDesc[] typeIndexToTypeDesc;
		string[] typeName;

		ArrayList sortedTypeTable;

		void BuildAddressRangesTypeTable()
		{
			rangeList = null;
			rangeCount = 0;

			if (typeIndexToTypeDesc == null || typeIndexToTypeDesc.Length < typeName.Length)
				typeIndexToTypeDesc = new TypeDesc[typeName.Length];
			else
			{
				foreach (TypeDesc t in typeIndexToTypeDesc)
				{
					if (t != null)
					{
						t.totalSize = 0;
						t.selectedSize = 0;
					}
				}
			}

			int totalAllocated = 0;
			int totalSelected = 0;
			LiveObjectTable.LiveObject o;
			for (liveObjectTable.GetNextObject(0, int.MaxValue, out o); o.id < int.MaxValue; liveObjectTable.GetNextObject(o.id + o.size, int.MaxValue, out o))
			{
				// Check whether we can fit this object into the last range we created.
				// We assume the liveObjectList is sorted, so the object can only attach
				// at the end of this range.
				if (rangeList != null && o.id - rangeList.hiAddr <= allowableGap)
				{
					Debug.Assert(o.id >= rangeList.hiAddr);
					rangeList.hiAddr = o.id + o.size;
				}
				else
				{
					rangeList = new AddressRange(o.id, o.id + o.size, rangeList, rangeCount++);
				}

				TypeDesc t = typeIndexToTypeDesc[o.typeIndex];
				if (t == null)
				{
					t = new TypeDesc(o.typeIndex, typeName[o.typeIndex]);
					typeIndexToTypeDesc[o.typeIndex] = t;
				}
				t.totalSize += o.size;
				totalAllocated += o.size;
				if (InsideSelection(o.id) != 0)
				{
					t.selectedSize += o.size;
					totalSelected += o.size;
				}
				
				int gen = 0;
				if (o.allocTickIndex <= liveObjectTable.gen2LimitTickIndex)
					gen = 2;
				else if (o.allocTickIndex <= liveObjectTable.gen1LimitTickIndex)
					gen = 1;

				if (rangeList.genLoAddr[gen] > o.id)
					rangeList.genLoAddr[gen] = o.id;
				if (rangeList.genHiAddr[gen] < o.id + o.size)
					rangeList.genHiAddr[gen] = o.id + o.size;
			}

			sortedTypeTable = new ArrayList();
			foreach (TypeDesc t in typeIndexToTypeDesc)
				if (t != null)
					sortedTypeTable.Add(t);
			sortedTypeTable.Sort();

			foreach (TypeDesc t in sortedTypeTable)
			{
				t.percentage = 0.0;
				if (totalAllocated > 0)
					t.percentage = 100.0*t.totalSize/totalAllocated;
				t.selectedPercentage = 0.0;
				if (totalSelected > 0)
					t.selectedPercentage = 100*t.selectedSize/totalSelected;
			}
		}

		const int typeLegendLeftMargin = 20;
		int leftMargin = 70;
		const int bottomMargin = 40;
		const int clickMargin = 20;
		const int topMargin = 30;
		const int rightMargin = 30;
		const int minHeight = 400;
		private int gap = 50;
		int dotSize = 8;
		const int typeLegendSpacing = 3;

		private int LeftMargin(Graphics g)
		{
			return 20 + (int)g.MeasureString("01234567", font).Width;
		}

		int Scale(GroupBox groupBox, int pixelsAvailable, int rangeNeeded)
		{
			foreach (RadioButton rb in groupBox.Controls)
			{
				if (rb.Checked)
					return Int32.Parse(rb.Text);
			}
			// No radio button was checked - let's come up with a suitable default
			RadioButton maxLowScaleRB = null;
			int maxLowRange = 0;
			RadioButton minHighScaleRB = null;
			int minHighRange = Int32.MaxValue;
			foreach (RadioButton rb in groupBox.Controls)
			{
				int range = pixelsAvailable*Int32.Parse(rb.Text);
				if (range < rangeNeeded)
				{
					if (maxLowRange < range)
					{
						maxLowRange = range;
						maxLowScaleRB = rb;
					}
				}
				else
				{
					if (minHighRange > range)
					{
						minHighRange = range;
						minHighScaleRB = rb;
					}
				}
			}
			if (minHighScaleRB != null)
			{
				minHighScaleRB.Checked = true;
				return Int32.Parse(minHighScaleRB.Text);
			}
			else
			{
				maxLowScaleRB.Checked = true;
				return Int32.Parse(maxLowScaleRB.Text);
			}
		}

		int BytesPerPixel(int availablePixels, int neededRange)
		{
			return Scale(bytesPerPixelgroupBox, availablePixels, neededRange);
		}

		int HeapWidth(int rangeCount)
		{
			foreach (RadioButton rb in heapWidthGroupBox.Controls)
			{
				if (rb.Checked)
					return Int32.Parse(rb.Text);
			}
			foreach (RadioButton rb in heapWidthGroupBox.Controls)
			{
				int width = Int32.Parse(rb.Text)*rangeCount;
				if (200 <= width && width < 400)
				{
					rb.Checked = true;
					return Int32.Parse(rb.Text);
				}
			}
			onetwoeightRadioButton.Checked = true;
			return 128;
		}

		static Color[] firstColors =
		{
			Color.Red,
			Color.Yellow,
			Color.Green,
			Color.Cyan,
			Color.Blue,
			Color.Magenta,
		};

		static Color[] colors = new Color[16];

		Color MixColor(Color a, Color b)
		{
			int R = (a.R + b.R)/2;
			int G = (a.G + b.G)/2;
			int B = (a.B + b.B)/2;

			return Color.FromArgb(R, G, B);
		}

		static void GrowColors()
		{
			Color[] newColors = new Color[2*colors.Length];
			for (int i = 0; i < colors.Length; i++)
				newColors[i] = colors[i];
			colors = newColors;
		}

		private void ColorTypes()
		{
			bool anyTypesUncolored = false;
			foreach (TypeDesc t in sortedTypeTable)
				anyTypesUncolored |= t.brushes == null;

			if (!anyTypesUncolored)
				return;

			int count = 0;
			foreach (TypeDesc t in sortedTypeTable)
			{
				if (count >= colors.Length)
					GrowColors();
				if (count < firstColors.Length)
					colors[count] = firstColors[count];
				else
					colors[count] = MixColor(colors[count - firstColors.Length], colors[count - firstColors.Length + 1]);
				t.colors = new Color[2];
				t.colors[0] = colors[count];
				t.colors[1] = MixColor(colors[count], Color.Black);
				t.brushes = new Brush[2];
				t.pens = new Pen[2];
				for (int i = 0; i < 2; i++)
				{
					t.brushes[i] = new SolidBrush(t.colors[i]);
					t.pens[i] = new Pen(t.brushes[i]);
				}
				count++;
			}
		}

		private AddressRange AddressRangeOf(int addr)
		{
			AddressRange r;
			for (r = rangeList; r != null; r = r.next)
			{
				if (r.loAddr <= addr && addr <= r.hiAddr)
					break;
			}
			return r;
		}

		private AddressRange AddressRangeOfObject(ref LiveObjectTable.LiveObject o)
		{
			AddressRange r = AddressRangeOf(o.id);
			if (r != null)
				return r;

			Debug.Assert(false);
			rangeList = new AddressRange(o.id, o.id + o.size, rangeList, rangeCount++);

			return rangeList;
		}

		private AddressRange AddressRangeOfObject(ref LiveObjectTable.LiveObject o, AddressRange hint)
		{
			if (hint != null && hint.loAddr <= o.id && o.id < hint.hiAddr)
				return hint;

			return AddressRangeOfObject(ref o);
		}

		private void DrawHorizontalLine(Graphics g, Pen pen, int x1, int x2, int y)
		{
			RectangleF clipRect = g.VisibleClipBounds;
			if (clipRect.Top <= y && y <= clipRect.Bottom)
			{
				IntersectIntervals((int)clipRect.Left, (int)clipRect.Right, ref x1, ref x2);
				if (x1 < x2)
					g.DrawLine(pen, x1, y, x2, y);
			}
		}

		private void FillSpace(Graphics g, AddressRange r, Pen pen, int start, int end)
		{
			// and a relative address of the object in this range
			int relativeStartAddr = start - r.loAddr;
			int relativeEndAddr = end - r.loAddr;

			// divide the relative address by bytesPerPixel to get a pixelAddress
			int pixelStartAddr = relativeStartAddr / bytesPerPixel;
			int pixelEndAddr = relativeEndAddr / bytesPerPixel;

			// pixelAddress / heapWidth gives y more or less
			int yAddr = pixelStartAddr / heapWidth;

			// figure out base x for this range
			int baseX = leftMargin + r.index*(heapWidth + gap);

			// figure out how many pixels to draw - there's going to be some rounding error
			int pixelsRemaining = (pixelEndAddr - pixelStartAddr);

			// pixelAddress % heapWidth + baseX gives x
			int xAddr = pixelStartAddr % heapWidth;

			// now draw a line o.size / bytesPerPixel in length at x, y
			// taking care to handle wraparound.
			int x = baseX + xAddr;
			int y = graphPanel.Size.Height - bottomMargin - yAddr;

			while (pixelsRemaining > 0)
			{
				if (xAddr + pixelsRemaining > heapWidth)
				{
					DrawHorizontalLine(g, pen, x, baseX + heapWidth, y);
					pixelsRemaining -= heapWidth - xAddr;
					x = baseX;
					xAddr = 0;
					y--;
				}
				else
				{
					DrawHorizontalLine(g, pen, x, x + pixelsRemaining, y);
					break;
				}
			}
		}

		private int VisibleYToAddress(AddressRange r, int y)
		{
			return r.loAddr + (graphPanel.Size.Height - bottomMargin - y + graphPanel.Top)*heapWidth*bytesPerPixel;
		}

		private int InsideSelection(int addr)
		{
			if (selectedLowAddr <= addr && addr < selectedHighAddr)
				return 1;
			else
				return 0;
		}

		const int align = 4;
		
		void IntersectIntervals(int aLow, int aHigh, ref int bLow, ref int bHigh)
		{
			bLow = Math.Max(aLow, bLow);
			bHigh = Math.Min(aHigh, bHigh);
		}

		private void DrawLiveObjects(Graphics g, TypeDesc selectedType, int lowAddr, int highAddr)
		{
			Pen freePen = new Pen(Color.White);

			RectangleF clipRect = g.VisibleClipBounds;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				// figure out base x for this range
				int x1 = leftMargin + r.index*(heapWidth + gap);
				int x2 = x1 + heapWidth;
				if (x2 < clipRect.Left || clipRect.Right < x1)
					continue;
				int visibleStartAddr = VisibleYToAddress(r, outerGraphPanel.Size.Height);
				int visibleEndAddr = VisibleYToAddress(r, 0);
				if (clipRect.Height < outerGraphPanel.Size.Height)
				{
					visibleStartAddr = VisibleYToAddress(r, (int)clipRect.Bottom + graphPanel.Top + 1);
					visibleEndAddr = VisibleYToAddress(r, (int)clipRect.Top + graphPanel.Top - 1);
				}

				IntersectIntervals(lowAddr, highAddr, ref visibleStartAddr, ref visibleEndAddr);
				IntersectIntervals(r.loAddr, r.hiAddr, ref visibleStartAddr, ref visibleEndAddr);

				LiveObjectTable.LiveObject o;
				int addr = liveObjectTable.FindObjectBackward(visibleStartAddr);
				liveObjectTable.GetNextObject(addr, visibleStartAddr, out o);
				if (o.id + o.size + align - 1 < visibleStartAddr)
					addr = visibleStartAddr;
				visibleEndAddr += align - 1;
				for (liveObjectTable.GetNextObject(addr, visibleEndAddr, out o); o.id < visibleEndAddr; liveObjectTable.GetNextObject(addr, visibleEndAddr, out o))
				{
					// fill any space between this object and the end of the previous one
					// (or the start of the range, as the case may be) in white
					if (addr + align - 1 < o.id)
					{
						FillSpace(g, r, freePen, addr, o.id);
					}

					LiveObjectTable.LiveObject oo;
					for (addr = o.id + o.size; addr < visibleEndAddr; )
					{
						// extend this range if oo is adjacent, of the same type, and still in the range
						liveObjectTable.GetNextObject(addr, visibleEndAddr, out oo);
						if (oo.id < visibleEndAddr && addr + align - 1 >= oo.id && oo.typeIndex == o.typeIndex)
						{
							addr = oo.id + oo.size;
						}
						else
							break;
					}

					// figure out what type the object is
					TypeDesc t = typeIndexToTypeDesc[o.typeIndex];

					// fill the space in the type's color
					FillSpace(g, r, t.pens[t.selected], o.id, addr);
				}
				if (addr + align - 1 < visibleEndAddr)
				{
					FillSpace(g, r, freePen, addr, visibleEndAddr);
				}
			}
		}

		int bytesPerPixel;
		int heapWidth;

		private void DrawHeapAddress(Graphics g, Brush brush, Pen pen, AddressRange r, int addr)
		{
			int baseX = leftMargin + r.index*(heapWidth + gap);

			int baseY = graphPanel.Size.Height - bottomMargin;

			// and a relative address of the object in this range
			int relativeAddr = addr - r.loAddr;

			// divide the relative address by bytesPerPixel and heapWidth
			int yAddr = relativeAddr / (bytesPerPixel*heapWidth);

			string label = string.Format("{0:x8}", addr);

			int width = (int)g.MeasureString(label, font).Width+2;
			int y = baseY - yAddr;
			g.DrawString(label, font, brush, baseX - width, y - font.Height/2);
			g.DrawLine(pen, baseX-3, y, baseX-2, y);
		}

		private void DrawHeapLegend(Graphics g)
		{
			Brush brush = new SolidBrush(Color.Black);
			Pen pen = new Pen(brush);

			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				const int pixelPitch = 64;
	
				int addrPitch = pixelPitch*bytesPerPixel*heapWidth;

				DrawHeapAddress(g, brush, pen, r, r.loAddr);

				for (int addr = (r.loAddr + addrPitch*3/2)/addrPitch*addrPitch; addr < r.hiAddr; addr += addrPitch)
				{
					DrawHeapAddress(g, brush, pen, r, addr);
				}
			}
		}

		private void DrawGenerationLimits(Graphics g)
		{
			Brush[] brush = new Brush[generations];
			Pen[] pen = new Pen[generations];
			brush[0] = new SolidBrush(Color.Red);
			brush[1] = new SolidBrush(Color.Green);
			brush[2] = new SolidBrush(Color.Blue);
			for (int gen = 0; gen < generations; gen++)
			{
				pen[gen] = new Pen(brush[gen], 3);
				pen[gen].EndCap = System.Drawing.Drawing2D.LineCap.ArrowAnchor;
				pen[gen].StartCap = System.Drawing.Drawing2D.LineCap.ArrowAnchor;
			}

			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				int baseX = leftMargin + r.index*(heapWidth + gap) + heapWidth + 4;

				int baseY = graphPanel.Size.Height - bottomMargin;

				for (int gen = 0; gen < generations; gen++)
				{
					if (r.genLoAddr[gen] < r.genHiAddr[gen])
					{
						int relativeLoAddr = r.genLoAddr[gen] - r.loAddr;
						int relativeHiAddr = r.genHiAddr[gen] - r.loAddr;
						int yLoAddr = relativeLoAddr / (bytesPerPixel*heapWidth);
						int yHiAddr = relativeHiAddr / (bytesPerPixel*heapWidth);

						int yLo = baseY - yLoAddr;
						int yHi = baseY - yHiAddr;
						if (yLo - yHi > font.Height)
						{
							g.DrawLine(pen[gen], baseX+gen*3, yLo, baseX+gen*3, yHi);
							string label = string.Format("gen {0}", gen);
							g.DrawString(label, font, brush[gen], baseX+gen*3+2, (yLo + yHi - font.Height)/2);
						}
					}
				}
			}
		}

		private void DrawTypeDescription(Graphics g, TypeDesc t)
		{
			int dotOffset = (font.Height - dotSize)/2;
			g.FillRectangle(t.brushes[t.selected], t.rect.Left, t.rect.Top+dotOffset, dotSize, dotSize);
			g.DrawString(t.typeName, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top);
			string s = string.Format(" ({0:n0} bytes, {1:f2}% - {2:n0} bytes, {3:f2}% selected)",
				                         t.totalSize,  t.percentage,      t.selectedSize, t.selectedPercentage);
			g.DrawString(s, font, blackBrush, t.rect.Left + dotSize*2, t.rect.Top + font.Height);
		}

		private void CalculateSelectedTypes()
		{
			foreach (TypeDesc t in sortedTypeTable)
			{
				t.selectedSize = 0;
			}

			int totalSelected = 0;
			LiveObjectTable.LiveObject o;
			for (liveObjectTable.GetNextObject(selectedLowAddr, selectedHighAddr, out o); o.id < selectedHighAddr; liveObjectTable.GetNextObject(o.id + o.size, selectedHighAddr, out o))
			{
				TypeDesc t = typeIndexToTypeDesc[o.typeIndex];
				t.selectedSize += o.size;
				totalSelected += o.size;
			}

			foreach (TypeDesc t in sortedTypeTable)
			{
				if (totalSelected != 0)
					t.selectedPercentage = 100.0*t.selectedSize/totalSelected;
				else
					t.selectedPercentage = 0.0;
			}

			sortedTypeTable.Sort();
		}

		private void DrawTypeLegend(Graphics g)
		{
			int x = typeLegendLeftMargin;
			int y = topMargin;

			Brush whiteBrush = new SolidBrush(Color.White);
			int dotOffset = (font.Height - dotSize)/2;
			g.FillRectangle(whiteBrush, x, y+dotOffset, dotSize, dotSize);
			g.DrawString("Free space", font, blackBrush, x + dotSize*2, y);
			y += font.Height + typeLegendSpacing;

			foreach (TypeDesc t in sortedTypeTable)
			{
				t.rect = new Rectangle(x, y, (int)g.MeasureString(t.typeName, font).Width+dotSize*2, font.Height*2);
				DrawTypeDescription(g, t);
				y = t.rect.Bottom + typeLegendSpacing;
			}
		}

		bool initialized = false;

		LiveObjectTable liveObjectTable;

		private void graphPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			Graphics g = e.Graphics;

			if (!initialized)
			{
				if (autoUpdate)
					liveObjectTable = Form1.instance.lastLogResult.liveObjectTable;

				typeName = liveObjectTable.readNewLog.typeName;

				leftMargin = LeftMargin(g);

				BuildAddressRangesTypeTable();

				ColorTypes();
			}

			gap = (int)g.MeasureString("  gen 0 0123456789", font).Width;

			g.SetClip(e.ClipRectangle);

			heapWidth = HeapWidth(rangeCount);

			int maxRangeSize = 0;
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				int rangeSize = r.hiAddr - r.loAddr;
				if (maxRangeSize < rangeSize)
					maxRangeSize = rangeSize;
			}

			bytesPerPixel = BytesPerPixel(graphPanel.Height - topMargin - bottomMargin, maxRangeSize/heapWidth);
			
			int maxHeight = maxRangeSize/(bytesPerPixel*heapWidth);
			int height = topMargin + maxHeight + bottomMargin;
			if (height < minHeight)
				height = minHeight;
			graphPanel.Height = height;

			int width = leftMargin + rangeCount*(heapWidth + gap) + rightMargin;
			graphPanel.Width = width;

			DrawLiveObjects(g, null, 0, Int32.MaxValue);

			Pen pen = new Pen(Color.Black);
			DrawSelectionHorizontalLine(g, pen, selectedHighAddr);
			DrawSelectionHorizontalLine(g, pen, selectedLowAddr);
			DrawSelectionVerticalLines(g, pen, selectedLowAddr, selectedHighAddr);

			DrawHeapLegend(g);

			DrawGenerationLimits(g);

			initialized = true;
		}

		private void Refresh(object sender, System.EventArgs e)
		{
			graphPanel.Invalidate();
			initialized = false;
		}

		int selectedStartAddr, selectedEndAddr;
		int selectedLowAddr, selectedHighAddr;

		private int PixelCoordinatesToAddress(int x, int y)
		{
			// First, find the correct range (if any).
			// we recognize a zone around the ranges as meaning the extreme in that direction
			for (AddressRange r = rangeList; r != null; r = r.next)
			{
				// figure out the boundaries of this particular range
				int minX = leftMargin + r.index*(heapWidth + gap);
				int maxY = graphPanel.Size.Height - bottomMargin;
				int maxX = minX + heapWidth;
				int minY = maxY - (r.hiAddr - r.loAddr)/(bytesPerPixel*heapWidth);

				if (minX - clickMargin <= x && x <= maxX + clickMargin &&
					minY - clickMargin <= y && y <= maxY + clickMargin)
				{
					// This is the right range - limit the coordinates to the actual extremes.
					if (x < minX)
						x = minX;
					else if (x > maxX)
						x = maxX;
					if (y < minY)
						y = minY;
					else if (y > maxY)
						y = maxY;

					// Reduce the coordinates to relative coordinates in the range - flipping y
					x = x - minX;
					y = maxY - y;

					// Now figure out the address
					int addr = r.loAddr + (y*heapWidth + x)*bytesPerPixel;

					// Limit it so it's within the range of address in r
					if (addr < r.loAddr)
						addr = r.loAddr;
					if (addr > r.hiAddr)
						addr = r.hiAddr;

					return addr;
				}
			}

			return 0;
		}

		private void DrawLiveObjectInterval(Graphics g, int low, int high)
		{
			if (low < high)
				DrawLiveObjects(g, null, low, high);
		}

		private void DrawLiveObjectIntervals(int aLow, int aHigh, int bLow, int bHigh)
		{
			Graphics g = graphPanel.CreateGraphics();

			// draw the live objects in [aLow, aHigh) and [bLow, bHigh)
			// but excluding the ones in the intersection of both intervals
			// caller guarantees aLow <= bLow && aLow <= aHigh && bLow <= bHigh

			Debug.Assert(aLow <= bLow && aLow <= aHigh && bLow <= bHigh);
			if (aHigh <= bLow)
			{
				// this implies two disjoint intervals
				Debug.Assert(aLow <= aHigh && aHigh <= bLow && bLow <= bHigh);
				DrawLiveObjectInterval(g, aLow, aHigh);
				DrawLiveObjectInterval(g, bLow, bHigh);
			}
			else
			{
				Debug.Assert(aLow <= bLow && bLow <= aHigh && bLow <= bHigh);
				if (bHigh <= aHigh)
				{
					// this implies b interval is nested within a
					Debug.Assert(aLow <= bLow && bLow <= bHigh && bHigh <= aHigh);
					DrawLiveObjectInterval(g, aLow, bLow);
					DrawLiveObjectInterval(g, bHigh, aHigh);
				}
				else
				{
					// this implies a starts before b, and ends bfore b
					Debug.Assert(aLow <= bLow && bLow <= aHigh && aHigh <= bHigh);
					DrawLiveObjectInterval(g, aLow, bLow);
					DrawLiveObjectInterval(g, aHigh, bHigh);
				}
			}
		}

		private void EraseSelectionHorizontalLine(Graphics g, int addr)
		{
			if (addr != 0)
			{
				Pen backGroundPen = new Pen(graphPanel.BackColor);
				AddressRange r = AddressRangeOf(addr);
				if (r != null)
					FillSpace(g, r, backGroundPen, addr, addr + heapWidth*bytesPerPixel);
				DrawLiveObjectInterval(g, addr, addr + heapWidth*bytesPerPixel);
			}
		}

		private void DrawSelectionHorizontalLine(Graphics g, Pen pen, int addr)
		{
			AddressRange r = AddressRangeOf(addr);
			if (r != null)
				FillSpace(g, r, pen, addr, addr + heapWidth*bytesPerPixel);
		}

		private void DrawSelectionVerticalLines(Graphics g, Pen pen, int lowAddr, int highAddr)
		{
			AddressRange r = AddressRangeOf(lowAddr);
			if (r == null)
				return;

			int baseX = leftMargin + r.index*(heapWidth + gap);

			int baseY = graphPanel.Size.Height - bottomMargin;

			// and a relative address of the object in this range
			int relativeLowAddr = lowAddr - r.loAddr;
			int relativeHighAddr = highAddr - r.loAddr;

			// divide the relative address by bytesPerPixel and heapWidth
			int yLowAddr = relativeLowAddr / (bytesPerPixel*heapWidth);
			int yHighAddr = relativeHighAddr / (bytesPerPixel*heapWidth);

			int lowY = baseY - yLowAddr;
			int highY = baseY - yHighAddr;
			g.DrawLine(pen, baseX-1, lowY-1, baseX-1, highY-1);
			g.DrawLine(pen, baseX+heapWidth+1, lowY, baseX+heapWidth+1, highY);
		}

		private void SetTitle()
		{
			TypeDesc selectedType = FindSelectedType();
			string title = baseTitle;
			if (selectedType != null || selectedLowAddr != 0)
				title += " - selected: " + ComputeObjectsDescription(selectedType, selectedLowAddr, selectedHighAddr);
			Text = title;
		}

		private void SetSelection()
		{
			int oldLowAddr = selectedLowAddr;
			int oldHighAddr = selectedHighAddr;
			if (selectedStartAddr < selectedEndAddr)
			{
				selectedLowAddr = selectedStartAddr;
				selectedHighAddr = selectedEndAddr;
			}
			else
			{
				selectedLowAddr = selectedEndAddr;
				selectedHighAddr = selectedStartAddr;
			}
			if (oldLowAddr != selectedLowAddr || oldHighAddr != selectedHighAddr)
			{
				// we need to paint what's different, i.e. whatever is in
				// the old selection but not the new, and vice versa.
/*
				if (oldLowAddr < selectedLowAddr)
					DrawLiveObjectIntervals(oldLowAddr, oldHighAddr, selectedLowAddr, selectedHighAddr);
				else
					DrawLiveObjectIntervals(selectedLowAddr, selectedHighAddr, oldLowAddr, oldHighAddr);
*/
				Graphics g = graphPanel.CreateGraphics();
				Pen blackPen = new Pen(Color.Black);
				Pen backGroundPen = new Pen(graphPanel.BackColor);
				if (oldLowAddr != selectedLowAddr)
					EraseSelectionHorizontalLine(g, oldLowAddr);
				if (oldHighAddr != selectedHighAddr)
					EraseSelectionHorizontalLine(g, oldHighAddr);
				DrawSelectionHorizontalLine(g, blackPen, selectedHighAddr);
				DrawSelectionHorizontalLine(g, blackPen, selectedLowAddr);
				if (oldLowAddr == selectedLowAddr)
				{
					if (oldHighAddr < selectedHighAddr)
						DrawSelectionVerticalLines(g, blackPen, oldHighAddr, selectedHighAddr);
					else
						DrawSelectionVerticalLines(g, backGroundPen, selectedHighAddr, oldHighAddr);
				}
				else if (oldHighAddr == selectedHighAddr)
				{
					if (oldLowAddr < selectedLowAddr)
						DrawSelectionVerticalLines(g, backGroundPen, oldLowAddr, selectedLowAddr);
					else
						DrawSelectionVerticalLines(g, blackPen, selectedLowAddr, oldLowAddr);
				}
				else
				{
					DrawSelectionVerticalLines(g, backGroundPen, oldLowAddr, oldHighAddr);
					DrawSelectionVerticalLines(g, blackPen, selectedLowAddr, selectedHighAddr);
				}
				SetTitle();
				CalculateSelectedTypes();
				typeLegendPanel.Invalidate();
			}
		}

		private void graphPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != MouseButtons.None)
			{
				if ((Control.ModifierKeys & Keys.Shift) != 0)
				{
					selectedEndAddr = PixelCoordinatesToAddress(e.X, e.Y);
					SetSelection();
				}
				else
				{
					selectedStartAddr = PixelCoordinatesToAddress(e.X, e.Y);
					if (selectedEndAddr != 0)
					{
						selectedEndAddr = selectedStartAddr;
						SetSelection();
					}
				}
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(graphPanel, p);
			}
		}

		private ToolTip toolTip;

		private bool FindObject(int addr, out LiveObjectTable.LiveObject o)
		{
			int id = liveObjectTable.FindObjectBackward(addr);
			liveObjectTable.GetNextObject(id, addr + 4, out o);
			return o.id <= addr && addr < o.id + o.size;
		}

		string FormatSize(int size)
		{
			double w = size;
			string byteString = "bytes";
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "kB";
			}
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "MB";
			}
			if (w >= 1024)
			{
				w /= 1024;
				byteString = "GB";
			}
			string format = "{0:f0} {1}";
			if (w < 10)
				format = "{0:f1} {1}";
			return string.Format(format, w, byteString);
		}

		private void graphPanel_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (!initialized)
				return;

			if (e.Button == MouseButtons.None)
			{
				LiveObjectTable.LiveObject o;
				if (FindObject(PixelCoordinatesToAddress(e.X, e.Y), out o))
				{
					ReadNewLog log = liveObjectTable.readNewLog;
					double age = (log.TickIndexToTime(liveObjectTable.lastTickIndex) - log.TickIndexToTime(o.allocTickIndex));
					string caption = string.Format("{0} at 0x{1:x} using {2} - {3:f3} secs old", typeIndexToTypeDesc[o.typeIndex].typeName, o.id, FormatSize(o.size), age);
					toolTip.Active = true;
					toolTip.SetToolTip(graphPanel, caption);
				}
				else
				{
					toolTip.Active = false;
					toolTip.SetToolTip(graphPanel, "");
				}
				return;
			}

			toolTip.Active = false;
			toolTip.SetToolTip(graphPanel, "");

			// So the mouse is moving with the left button down
			// Presumably the user wants to make a selection
			if (selectedStartAddr != 0)
			{
				int newEndAddr = PixelCoordinatesToAddress(e.X, e.Y);
				if (newEndAddr != selectedEndAddr)
				{
					selectedEndAddr = newEndAddr;
					SetSelection();
				}
			}
		}

		private void graphPanel_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (e.Button == MouseButtons.None)
			{
				if (selectedStartAddr != 0)
					selectedEndAddr = PixelCoordinatesToAddress(e.X, e.Y);
				SetSelection();
			}
		}

		private void typeLegendPanel_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			if (!initialized)
			{
				BuildAddressRangesTypeTable();
				ColorTypes();
			}

			Graphics g = e.Graphics;

			int maxTypeNameWidth = 0;
			foreach (TypeDesc t in sortedTypeTable)
			{
				int typeWidth = (int)g.MeasureString(t.typeName, font).Width;
				if (maxTypeNameWidth < typeWidth)
					maxTypeNameWidth = typeWidth;
				typeWidth = (int)g.MeasureString(" (999,999,999 bytes, 99.99% - 999,999,999 bytes, 99.99% selected)", font).Width;
				if (maxTypeNameWidth < typeWidth)
					maxTypeNameWidth = typeWidth;
			}
			dotSize = (int)g.MeasureString("0", font).Width;

			int width = leftMargin + dotSize + maxTypeNameWidth + rightMargin;

			typeLegendPanel.Width = width;

			int height = topMargin + sortedTypeTable.Count*(font.Height*2 + typeLegendSpacing) + bottomMargin;

			typeLegendPanel.Height = height;

			DrawTypeLegend(g);	
		}

		private void RedrawType(TypeDesc t)
		{
			DrawTypeDescription(typeLegendPanel.CreateGraphics(), t);
			Graphics g = graphPanel.CreateGraphics();
			DrawLiveObjects(g, t, 0, Int32.MaxValue);
			Pen pen = new Pen(Color.Black);
			DrawSelectionHorizontalLine(g, pen, selectedHighAddr);
			DrawSelectionHorizontalLine(g, pen, selectedLowAddr);
		}

		private void typeLegendPanel_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != MouseButtons.None)
			{
				foreach (TypeDesc t in sortedTypeTable)
				{
					if (t.rect.Contains(e.X, e.Y) || t.selected != 0)
					{
						t.selected = 1 - t.selected;
						RedrawType(t);
						SetTitle();
					}
				}
			}
			else if ((e.Button & MouseButtons.Right) != MouseButtons.None)
			{
				Point p = new Point(e.X, e.Y);
				contextMenu.Show(typeLegendPanel, p);
			}
		}

		private void versionTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			if (font != Form1.instance.font)
			{
				font = Form1.instance.font;
				initialized = false;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}

			if (!autoUpdate)
				return;

			ReadLogResult logResult = Form1.instance.lastLogResult;
			if (logResult != null && logResult.liveObjectTable != liveObjectTable)
			{
				liveObjectTable = logResult.liveObjectTable;
				initialized = false;
				graphPanel.Invalidate();
				typeLegendPanel.Invalidate();
			}
		}

		private TypeDesc FindSelectedType()
		{
			// Figure out whether there's a selected type
			foreach (TypeDesc t in sortedTypeTable)
			{
				if (t.selected != 0)
					return t;
			}
			return null;
		}

		private string ComputeObjectsDescription(TypeDesc selectedType, int selectedLowAddr, int selectedHighAddr)
		{
			string description = "";
			if (selectedType != null)
				description += selectedType.typeName + " ";
			description += "objects ";
			if (selectedLowAddr > 0)
				description += string.Format("between {0:x8} and {1:x8}", selectedLowAddr, selectedHighAddr);
			return description;
		}

		private void showAllocatorsMenuItem_Click(object sender, System.EventArgs e)
		{
			TypeDesc selectedType = FindSelectedType();

			// Create a new allocation graph and add all the objects in the selected address range
			// whose type matches the selected type (if any).

			ReadNewLog log = liveObjectTable.readNewLog;
			Histogram histogram = new Histogram(log);
			int low = selectedLowAddr;
			int high = low == 0 ? int.MaxValue : selectedHighAddr;
			LiveObjectTable.LiveObject o;
			for (liveObjectTable.GetNextObject(low, high, out o); o.id < high; liveObjectTable.GetNextObject(o.id + o.size, high, out o))
			{
				if (selectedType == null || selectedType.typeIndex == o.typeIndex)
					histogram.AddObject(o.typeSizeStacktraceIndex, 1);
			}

			// Build the real graph from the histogram

			Graph graph = histogram.BuildAllocationGraph();

			// And post it back to the main form - hardest part is to compute an appropriate title...

			string title = "Allocation Graph for live " + ComputeObjectsDescription(selectedType, selectedLowAddr, selectedHighAddr);
			GraphViewForm graphViewForm = new GraphViewForm(graph, title);
			graphViewForm.Visible = true;
		}

		private void showHistogramMenuItem_Click(object sender, System.EventArgs e)
		{
			TypeDesc selectedType = FindSelectedType();

			// Create a new histogram and add all the objects in the selected address range
			// whose type matches the selected type (if any).

			ReadNewLog log = liveObjectTable.readNewLog;
			Histogram histogram = new Histogram(log);
			int low = selectedLowAddr;
			int high = low == 0 ? int.MaxValue : selectedHighAddr;
			LiveObjectTable.LiveObject o;
			for (liveObjectTable.GetNextObject(low, high, out o); o.id < high; liveObjectTable.GetNextObject(o.id + o.size, high, out o))
			{
				if (selectedType == null || selectedType.typeIndex == o.typeIndex)
					histogram.AddObject(o.typeSizeStacktraceIndex, 1);
			}

			string title = "Histogram by Size for live " + ComputeObjectsDescription(selectedType, selectedLowAddr, selectedHighAddr);
			HistogramViewForm histogramViewForm = new HistogramViewForm(histogram, title);
			histogramViewForm.Show();
		}

		private void exportMenuItem_Click(object sender, System.EventArgs e)
		{
			exportSaveFileDialog.FileName = "LiveObjects.csv";
			exportSaveFileDialog.Filter = "Comma separated files | *.csv";
			if (exportSaveFileDialog.ShowDialog() == DialogResult.OK)
			{
				StreamWriter w = new StreamWriter(exportSaveFileDialog.FileName);

				TypeDesc selectedType = FindSelectedType();

				string title = "List of" + ComputeObjectsDescription(selectedType, selectedLowAddr, selectedHighAddr);

				w.WriteLine(title);
				w.WriteLine();

				w.WriteLine("{0},{1},{2},{3},{4},{5}", "Address", "Size", "Type", "Age", "Allocated by", "Called from");

				int low = selectedLowAddr;
				int high = low == 0 ? int.MaxValue : selectedHighAddr;
				LiveObjectTable.LiveObject o;
				ReadNewLog log = liveObjectTable.readNewLog;
				for (liveObjectTable.GetNextObject(low, high, out o); o.id < high; liveObjectTable.GetNextObject(o.id + o.size, high, out o))
				{
					if (selectedType != null && selectedType.typeIndex != o.typeIndex)
						continue;
					double age = (log.TickIndexToTime(liveObjectTable.lastTickIndex) - log.TickIndexToTime(o.allocTickIndex));
					w.Write("0x{0:x},{1},{2},{3:f3}", o.id, o.size, typeName[o.typeIndex], age);

					int[] stacktrace = log.stacktraceTable.IndexToStacktrace(o.typeSizeStacktraceIndex);
					for (int i = 2; i < stacktrace.Length; i++)
					{
						w.Write(",{0}", log.funcName[stacktrace[i]]);
					}
					w.WriteLine();
				}

				w.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedappdomain.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using CORDBLib;

namespace Debugging
  {
  public class DebuggedAppDomain : Controller
    {
    /** Create an DebuggedAppDomain object. */
    internal DebuggedAppDomain (ICorDebugAppDomain ad)
      : base (ad)
      {}

    /** Get the ICorDebugAppDomain interface back from the Controller. */
    private ICorDebugAppDomain _ad ()
      {return (ICorDebugAppDomain) GetController();}

    /** Get the process containing the DebuggedAppDomain. */
    public DebuggedProcess Process
      {
      get
        {
        ICorDebugProcess proc = null;
        _ad().GetProcess (out proc);
        return new DebuggedProcess (proc);
        }
      }

    /** Get all Assemblies in the DebuggedAppDomain. */
    public IEnumerable Assemblies
      {
      get
        {
        ICorDebugAssemblyEnum eas = null;
        _ad().EnumerateAssemblies (out eas);
        return new DebuggedAssemblyEnumerator (eas);
        }
      }

    /** Get the module for the given metadata interface */
#if I_DONT_WANT_TO
    public DebuggedModule GetModuleFromMetaDataInterface (IUnknown metaData)
      {
      ICorDebugModule module = null;
      _ad().GetModuleFromMetaDataInterface (metaData, out module);
      return new DebuggedModule (module);
      }
#endif

    /** All active breakpoints in the DebuggedAppDomain */
    public IEnumerable Breakpoints
      {
      get
        {
        ICorDebugBreakpointEnum bpoint = null;
        _ad().EnumerateBreakpoints (out bpoint);
        return new BreakpointEnumerator (bpoint);
        }
      }

    /** All active steppers in the DebuggedAppDomain */
    public IEnumerable Steppers
      {
      get
        {
        ICorDebugStepperEnum step = null;
        _ad().EnumerateSteppers (out step);
        return new StepperEnumerator (step);
        }
      }

    /** Is the debugger attached to the DebuggedAppDomain? */
    public bool IsAttached ()
      {
      int attach = 0;
      _ad().IsAttached (out attach);
      return !(attach==0);
      }

    /** The name of the DebuggedAppDomain */
    public String Name
      {
      get
        {
        // XXX: is this big enough?
        char[] name = new Char[300];
        uint fetched = 0;
        _ad().GetName ((uint)name.Length, out fetched, name);
        // ``fetched'' includes terminating null; String doesn't handle null,
        // so we "forget" it.
        return new String (name, 0, (int) (fetched-1));
        }
      }

    /** Get the runtime App domain object */
    public Value Object
      {
      get
        {
        ICorDebugValue val = null;
        _ad().GetObject (out val);
        return new Value (val);
        }
      }

    // Attach the AppDomain to receiv all DebuggedAppDomain related events (e.g.
    // load assembly, load module, etc.) in order to debug the AppDomain.
    public void Attach ()
      {_ad().Attach ();}

    /** Get the ID of this DebuggedAppDomain */
    public int Id
      {
      get
        {
        uint id = 0;
        _ad().GetID (out id);
        return (int) id;
        }
      }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedassemblyenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for Assemblies. */
  internal class DebuggedAssemblyEnumerator : 
    IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugAssemblyEnum m_enum;
    private DebuggedAssembly m_asm;

    internal DebuggedAssemblyEnumerator (ICorDebugAssemblyEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new DebuggedAssemblyEnumerator ((ICorDebugAssemblyEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugAssembly[] a = new ICorDebugAssembly[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_asm = new DebuggedAssembly (a[0]);
      else
        m_asm = null;
      return m_asm != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_asm = null;}

    public Object Current
      {get {return m_asm;}}
    } /* class AssemblyEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedappdomainenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for AppDomains. */
  internal class DebuggedAppDomainEnumerator : 
    IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugAppDomainEnum m_enum;
    private DebuggedAppDomain m_ad;

    internal DebuggedAppDomainEnumerator (ICorDebugAppDomainEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new DebuggedAppDomainEnumerator ((ICorDebugAppDomainEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugAppDomain[] a = new ICorDebugAppDomain [1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_ad = new DebuggedAppDomain (a[0]);
      else
        m_ad = null;
      return m_ad != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_ad = null;}

    public Object Current
      {get {return m_ad;}}
    } /* class AppDomainEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedassembly.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;
using Debugging;
using System.Collections;

namespace Debugging
  {
  // Information about an Assembly being debugged.
  public class DebuggedAssembly
    {
    private ICorDebugAssembly m_asm;

    internal DebuggedAssembly (ICorDebugAssembly a)
      {m_asm = a;}

    /** Get the process containing the Assembly. */
    public DebuggedProcess Process
      {
      get
        {
        ICorDebugProcess proc = null;
        m_asm.GetProcess (out proc);
        return new DebuggedProcess (proc);
        }
      }

    /** Get the AppDomain containing the assembly. */
    public DebuggedAppDomain AppDomain
      {
      get
        {
        ICorDebugAppDomain ad = null;
        m_asm.GetAppDomain (out ad);
        return new DebuggedAppDomain (ad);
        }
      }

    /** All the modules in the assembly. */
    public IEnumerable Modules
      {
      get
        {
        ICorDebugModuleEnum emod = null;
        m_asm.EnumerateModules (out emod);
        return new DebuggedModuleEnumerator (emod);
        }
      }
    
    /** Get the name of the code base used to load the assembly. */
    public String CodeBase
      {
      get
        {
        char[] name = new char[300];
        uint sz = 0;
        m_asm.GetCodeBase ((uint) name.Length, out sz, name);
        // ``sz'' includes terminating null; String doesn't handle null,
        // so we "forget" it.
        return new String (name, 0, (int) (sz-1));
        }
      }

    /** The name of the assembly. */
    public String Name
      {
      get
        {
        char[] name = new char[300];
        uint sz = 0;
        m_asm.GetName ((uint) name.Length, out sz, name);
        // ``sz'' includes terminating null; String doesn't handle null,
        // so we "forget" it.
        return new String (name, 0, (int) (sz-1));
        }
      }
    } /* class Assembly */
  } /* namespace debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\cordebugger.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using CORDBLib;
using System.Runtime.InteropServices;


namespace Debugging
  {
  // Wraps the standard URT Debugger
  public class CorDebugger
    {
    private ICorDebug m_debugger;
    
    // Create a debugger that can be used to debug an URT program.
    public CorDebugger ()
      {
      m_debugger = new CorDebug ();
      m_debugger.Initialize ();
      }

    // Closes the debugger.  After this method is called, it is an error
    // to call any other methods on this object.
    public void Terminate ()
      {
      if (m_debugger != null)
        {
        try
          {
          m_debugger.Terminate ();
          }
        catch (System.Exception e)
          {
          Console.WriteLine ("termination error: " + e.Message);
          }
        m_debugger = null;
        }
      }

    // Specify the callback object to use for managed events.
    public void SetManagedHandler (ICorDebugManagedCallback callback)
      {m_debugger.SetManagedHandler (callback);}

    // Specify the callback object to use for unmanaged events.
    public void SetUnmanagedHandler (ICorDebugUnmanagedCallback callback)
      {m_debugger.SetUnmanagedHandler (callback);}

    // Launch a process under the control of the debugger.
    //
    // Parameters are the same as the Win32 CreateProcess call.
    public DebuggedProcess CreateProcess (
      String appName,
      String commandLine
      )
      {
      return CreateProcess (appName, commandLine, ".");
      }

    // Launch a process under the control of the debugger.
    //
    // Parameters are the same as the Win32 CreateProcess call.
    public DebuggedProcess CreateProcess (
      String appName,
      String commandLine,
      String currentDirectory
      )
      {
      return CreateProcess (appName, commandLine, currentDirectory, 0);
      }

    // Launch a process under the control of the debugger.
    //
    // Parameters are the same as the Win32 CreateProcess call.
    public DebuggedProcess CreateProcess (
      String appName,
      String commandLine,
      String currentDirectory,
      int    flags
      )
      {
      PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();

      STARTUPINFO si = new STARTUPINFO ();
#if BAD
      unsafe si.cb = sizeof (Microsoft.Win32.Interop.STARTUPINFO);
#else
      /*
       * Preferrably, the above #if'd out statement would be used.
       * However, STARTUPINFO isn't a value_type, so the sizeof 
       * operator can't be used.
       *
       * "68" is the value returned from compiling the C++ code:
       *    printf ("%i\n", sizeof (STARTUPINFO);
       *
       * Caveat emptor.
       */
      si.cb = 68;
#endif

      DebuggedProcess ret = CreateProcess (
        appName,
        commandLine, 
        null,
        null,
        true,   // inherit handles
        flags,  // creation flags
        0,      // environment
        currentDirectory,
        si,     // startup info
        ref pi, // process information
        CorDebugCreateProcessFlags.DEBUG_NO_SPECIAL_OPTIONS);

      CloseHandle (pi.hProcess);
      CloseHandle (pi.hThread);

      return ret;
      }

    // Launch a process under the control of the debugger.
    //
    // Parameters are the same as the Win32 CreateProcess call.
    //
    // The caller should remember to execute:
    //
    //    Microsoft.Win32.Interop.Windows.CloseHandle (
    //      processInformation.hProcess);
    //
    // after CreateProcess returns.
    public DebuggedProcess CreateProcess (
      String                      appName,
      String                      commandLine,
      SECURITY_ATTRIBUTES         processAttributes,
      SECURITY_ATTRIBUTES         threadAttributes,
      bool                        inheritHandles,
      int                         creationFlags,
      int                         environment,  // ???
      String                      currentDirectory,
      STARTUPINFO                 startupInfo,
      ref PROCESS_INFORMATION     processInformation,
      CorDebugCreateProcessFlags  debuggingFlags)
      {ICorDebugProcess proc = null;

      m_debugger.CreateProcess (
        appName, 
        commandLine, 
        processAttributes,
        threadAttributes, 
        inheritHandles ? 1 : 0, 
        (uint) creationFlags, 
        environment, 
        currentDirectory, 
        startupInfo, 
        processInformation, 
        debuggingFlags,
        out proc);

      return new DebuggedProcess (proc);}

    // Attach to an active process
    public DebuggedProcess DebugActiveProcess (int pid, bool win32Attach)
      {
      ICorDebugProcess proc = null;
      m_debugger.DebugActiveProcess ((uint)pid, win32Attach ? 1 : 0, out proc);
      return new DebuggedProcess (proc);
      }

    // Enuerate all processes currently being debugged.
    public IEnumerable Processes
      {
      get
        {
        ICorDebugProcessEnum eproc = null;
        m_debugger.EnumerateProcesses (out eproc);
        return new DebuggedProcessEnumerator (eproc);
        }
      }

    // Get the Process object for the given PID.
    public DebuggedProcess GetProcess (int pid)
      {
      ICorDebugProcess proc = null;
      m_debugger.GetProcess ((uint) pid, out proc);
      return new DebuggedProcess (proc);
      }

    [DllImport("kernel32.dll"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    private static extern bool CloseHandle(int handle);
    } /* class Debugger */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedmodule.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  public class DebuggedModule
    {
    private ICorDebugModule m_mod;

    internal DebuggedModule (ICorDebugModule mod)
      {m_mod = mod;}

    /** The process this module is in. */
    public DebuggedProcess Process
      {
      get
        {
        ICorDebugProcess proc = null;
        m_mod.GetProcess (out proc);
        return new DebuggedProcess (proc);
        }
      }

    /** The base address of this module */
    public long BaseAddress
      {
      get
        {
        ulong addr = 0;
        m_mod.GetBaseAddress (out addr);
        return (long) addr;
        }
      }

    /** The assembly this module is in. */
    public DebuggedAssembly Assembly
      {
      get
        {
        ICorDebugAssembly a = null;
        m_mod.GetAssembly (out a);
        return new DebuggedAssembly (a);
        }
      }

    /** The name of the module. */
    public String Name
      {
      get
        {
        // XXX: is this big enough?
        char[] name = new Char[300];
        uint fetched = 0;
        m_mod.GetName ((uint) name.Length, out fetched, name);
        // ``fetched'' includes terminating null; String doesn't handle null,
        // so we "forget" it.
        return new String (name, 0, (int) (fetched-1));
        }
      }

    // should the jitter preserve debugging information for methods 
    // in this module?
    public void EnableJITDebugging (bool trackJitInfo, bool allowJitOpts)
      {
      m_mod.EnableJITDebugging (trackJitInfo ? 1 : 0, 
        allowJitOpts ? 1 : 0);
      }

    /** Are ClassLoad callbacks called for this module? */
    public void EnableClassLoadCallbacks (bool a)
      {
      m_mod.EnableClassLoadCallbacks (a ? 1 : 0);
      }

#if I_DONT_WANT_TO
    /** Get the function from the metadata info. */
    public DebuggedFunction GetFunctionFromToken (mdMethodDef md);

    /** Get the function from the relative address */
    public DebuggedFunction GetFunctionFromRVA (long addr);
#endif

    /** get the class from metadata info. */
    public DebuggedClass GetClassFromToken (int typeDef)
      {
      ICorDebugClass c = null;
      m_mod.GetClassFromToken ((uint)typeDef, out c);
      return new DebuggedClass (c);
      }

    // create a breakpoint which is triggered when code in the module
    // is executed.
    public DebuggedModuleBreakpoint CreateBreakpoint ()
      {
      ICorDebugModuleBreakpoint mbr = null;
      m_mod.CreateBreakpoint (out mbr);
      return new DebuggedModuleBreakpoint (mbr);
      }

#if I_DONT_WANT_TO
    /** Edit & continue support */
    public EditAndContinueSnapshot GetEditAndContinueSnapshot ();

    /** ??? */
    public IUnknown GetMetaDataInterface (REFIID riid);
#endif

    /** Get the token for the mdouel table entry of this object. */
    public int Token
      {
      get
        {
        uint t = 0;
        m_mod.GetToken (out t);
        return (int) t;
        }
      }

    /** is this a dynamic module? */
    public bool IsDynamic ()
      {
      int b = 0;
      m_mod.IsDynamic (out b);
      return !(b==0);
      }

    /** get the value object for the given global variable. */
    public Value GetGlobalVariableValue (int fieldDef)
      {
      ICorDebugValue v = null;
      m_mod.GetGlobalVariableValue ((uint) fieldDef, out v);
      return new Value (v);
      }

    /** The size (in bytes) of the module. */
    public int Size
      {
      get
        {
        uint s = 0;
        m_mod.GetSize (out s);
        return (int) s;
        }
      }
    } /* class Module */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedclass.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  public class DebuggedClass
    {
    private ICorDebugClass m_c;

    internal DebuggedClass (ICorDebugClass c)
      {m_c = c;}

    internal ICorDebugClass GetInterface ()
      {return m_c;}

    /** The module containing the class */
    public DebuggedModule Module
      {
      get
        {
        ICorDebugModule m = null;
        m_c.GetModule (out m);
        return new DebuggedModule (m);
        }
      }

    /** The metadata typedef token of the class. */
    public int Token
      {
      get
        {
        uint td = 0;
        m_c.GetToken (out td);
        return (int) td;
        }
      }

#if I_DONT_WANT_TO
    // i don't want to write Frame yet.
    public Value GetStaticFieldValue (uint fieldDef, Frame f);
#endif
    } /* class Class */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedfunctionbreakpoint.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;
using Debugging;

namespace Debugging
  {
  public class DebuggedFunctionBreakpoint : Breakpoint
    {
    private ICorDebugFunctionBreakpoint _fbr ()
      {return (ICorDebugFunctionBreakpoint) GetBreakpoint();}

    internal DebuggedFunctionBreakpoint (ICorDebugFunctionBreakpoint br)
      : base (br)
      {}

#if I_DONT_WANT_TO
    public DebuggedFunction Function
      {
      get
        {
        ICorDebugFunction f = null;
        _fbr().GetFunction (out f);
        return new DebuggedFunction (f);
        }
      }
#endif

    public int Offset
      {
      get
        {
        uint off = 0;
        _fbr().GetOffset (out off);
        return (int) off;
        }
      }
    } /* class FunctionBreakpoint */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedmodulebreakpoint.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  public class DebuggedModuleBreakpoint : Breakpoint
    {
    private ICorDebugModuleBreakpoint _mbr()
      {return (ICorDebugModuleBreakpoint) GetBreakpoint();}

    internal DebuggedModuleBreakpoint (ICorDebugModuleBreakpoint br)
      : base (br)
      {}

    public DebuggedModule Module
      {
      get
        {
        ICorDebugModule m = null;
        _mbr().GetModule (out m);
        return new DebuggedModule (m);
        }
      }
    } /* class ModuleBreakpoint */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedmoduleenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for Modules. */
  internal class DebuggedModuleEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugModuleEnum m_enum;
    private DebuggedModule m_mod;

    internal DebuggedModuleEnumerator (ICorDebugModuleEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new DebuggedModuleEnumerator ((ICorDebugModuleEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugModule[] a = new ICorDebugModule[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_mod = new DebuggedModule (a[0]);
      else
        m_mod = null;
      return m_mod != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_mod = null;}

    public Object Current
      {get {return m_mod;}}
    } /* class ModuleEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedobjectenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  // Exposes an enumerator for Objects. 
  //
  // Apparently the "Object"'s this enumerator returns is the address of
  // each object, not a description of the object itself.
  //
  // At least, the ``Next'' method in the IDL returns a uint64, so there
  // isn't much else it could be returning...
  internal class DebuggedObjectEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugObjectEnum m_enum;

    private ulong m_obj;

    internal DebuggedObjectEnumerator (ICorDebugObjectEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new DebuggedObjectEnumerator ((ICorDebugObjectEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ulong[] a = new ulong[1];
      uint c = 0;
      int r = m_enum.Next ((uint)a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        {
        m_obj = a[0];
        return true;
        }
      return false;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_obj = 0;}

    public Object Current
      {get {return m_obj;}}
    } /* class DebuggedObjectEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\caspol\caspol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  caspol.cool
//
//  caspol is a command-line utility for manipulating the policy for a machine.
//

using System;
using Assembly = System.Reflection.Assembly;
using AssemblyName = System.Reflection.AssemblyName;
using System.Collections;
using System.IO;
using System.Security.Policy;
using System.Security.Util;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Reflection;
using System.Security.Permissions;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using Microsoft.Win32;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Globalization;
using System.Resources;
using System.Threading;

[assembly:AssemblyTitleAttribute("CasPol")]

namespace Caspol
{


    delegate void OptionHandler( String[] args, int index, out int numArgsUsed );
    delegate IMembershipCondition MembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset );
    delegate void CodeGroupAttributeHandler( CodeGroup group, String[] args, int index, out int offset );


    enum LevelType
    {
        None = 0,
        Machine = 1,
        UserDefault = 2,
        UserCustom = 3,
        All = 4,
        Enterprise = 5,
        AllCustom = 6
    }

    public class caspol
    {
        // Indicator of the last specified level.
        private static LevelType m_levelType = LevelType.None;
        private static PolicyLevel m_currentCustomLevel;
        private static String m_levelPath;
        private static ArrayList m_levelAssemblyList;

        private static ArrayList m_machineAssemblies = new ArrayList();
        private static ArrayList m_userAssemblies = new ArrayList();
        private static ArrayList m_enterpriseAssemblies = new ArrayList();
        private static ArrayList m_customUserAssemblies = new ArrayList();
    
        // The space used to indent the code groups
        private const String m_indent = "   ";
    
        // The allowed separators within labels (right now only 1.2.3 is legal)
        private const String m_labelSeparators = ".";
    
        private static bool m_force = false;
    
        private static bool m_success = true;
    
        private static String m_danglingLevelIndicator = null;

        private const String m_policyKey = "Software\\Microsoft\\.NETFramework\\v" + Util.Version.SBSVersionString + "\\Security\\Policy";

        internal static ResourceManager manager = new ResourceManager( "caspol", Assembly.GetExecutingAssembly() );
        
        // The table of options that are recognized.
        // Note: the order in this table is also the order in which they are displayed
        // on the help screen.
        private static OptionTableEntry[] optionTable =
            { new OptionTableEntry( manager.GetString( "OptionTable_Machine" ), new OptionHandler( MachineHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_MachineAbbr" ), new OptionHandler( MachineHandler ), manager.GetString( "OptionTable_Machine" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_User" ), new OptionHandler( UserHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_UserAbbr" ), new OptionHandler( UserHandler ), manager.GetString( "OptionTable_User" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_Enterprise" ), new OptionHandler( EnterpriseHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_EnterpriseAbbr" ), new OptionHandler( EnterpriseHandler ), manager.GetString( "OptionTable_Enterprise" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_CustomUser" ), new OptionHandler( CustomUserHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_CustomUserAbbr" ), new OptionHandler( CustomUserHandler ), manager.GetString( "OptionTable_CustomUser" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_All" ), new OptionHandler( AllHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AllAbbr" ), new OptionHandler( AllHandler ), manager.GetString( "OptionTable_All" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_CustomAll" ), new OptionHandler( CustomAllHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_CustomAllAbbr" ), new OptionHandler( CustomAllHandler ), manager.GetString( "OptionTable_CustomAll" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_List" ), new OptionHandler( ListHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListAbbr" ), new OptionHandler( ListHandler ), manager.GetString( "OptionTable_List" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListGroups" ), new OptionHandler( ListGroupHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListGroupsAbbr" ), new OptionHandler( ListGroupHandler ), manager.GetString( "OptionTable_ListGroups" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListPSet" ), new OptionHandler( ListPermHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListPSetAbbr" ), new OptionHandler( ListPermHandler ), manager.GetString( "OptionTable_ListPSet" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListFullTrust" ), new OptionHandler( ListFullTrustHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListFullTrustAbbr" ), new OptionHandler( ListFullTrustHandler ), manager.GetString( "OptionTable_ListFullTrust" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListDescription" ), new OptionHandler( ListDescriptionHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListDescriptionAbbr" ), new OptionHandler( ListDescriptionHandler ), manager.GetString( "OptionTable_ListDescription" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AddPSet" ), new OptionHandler( AddPermHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AddPSetAbbr" ), new OptionHandler( AddPermHandler ), manager.GetString( "OptionTable_AddPSet" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ChgPSet" ), new OptionHandler( ChgPermHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ChgPSetAbbr" ), new OptionHandler( ChgPermHandler ), manager.GetString( "OptionTable_ChgPSet" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RemPSet" ), new OptionHandler( RemPermHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RemPSetAbbr" ), new OptionHandler( RemPermHandler ), manager.GetString( "OptionTable_RemPSet" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AddFullTrust" ), new OptionHandler( AddFullTrustHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AddFullTrustAbbr" ), new OptionHandler( AddFullTrustHandler ), manager.GetString( "OptionTable_AddFullTrust" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RemFullTrust" ), new OptionHandler( RemFullTrustHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RemFullTrustAbbr" ), new OptionHandler( RemFullTrustHandler ), manager.GetString( "OptionTable_RemFullTrust" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RemGroup" ), new OptionHandler( RemGroupHandler ), null, true, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RemGroupAbbr" ), new OptionHandler( RemGroupHandler ), manager.GetString( "OptionTable_RemGroup" ), true, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ChgGroup" ), new OptionHandler( ChgGroupHandler ), null, true, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ChgGroupAbbr" ), new OptionHandler( ChgGroupHandler ), manager.GetString( "OptionTable_ChgGroup" ), true, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AddGroup" ), new OptionHandler( AddGroupHandler ), null, true, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_AddGroupAbbr" ), new OptionHandler( AddGroupHandler ), manager.GetString( "OptionTable_AddGroup" ), true, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ResolveGroup" ), new OptionHandler( ResolveGroupHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ResolveGroupAbbr" ), new OptionHandler( ResolveGroupHandler ), manager.GetString( "OptionTable_ResolveGroup" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ResolvePerm" ), new OptionHandler( ResolvePermHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ResolvePermAbbr" ), new OptionHandler( ResolvePermHandler ), manager.GetString( "OptionTable_ResolvePerm" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_Security" ), new OptionHandler( SecurityHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_SecurityAbbr" ), new OptionHandler( SecurityHandler ), manager.GetString( "OptionTable_Security" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_Execution" ), new OptionHandler( ExecutionHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ExecutionAbbr" ), new OptionHandler( ExecutionHandler ), manager.GetString( "OptionTable_Execution" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_PolChgPrompt" ), new OptionHandler( PolicyChangeHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_PolChgPromptAbbr" ), new OptionHandler( PolicyChangeHandler ), manager.GetString( "OptionTable_PolChgPrompt" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_Quiet" ), new OptionHandler( QuietHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_QuietAbbr" ), new OptionHandler( QuietHandler ), manager.GetString( "OptionTable_Quiet" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_Recover" ), new OptionHandler( RecoverHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_RecoverAbbr" ), new OptionHandler( RecoverHandler ), manager.GetString( "OptionTable_Recover" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_Reset" ), new OptionHandler( ResetHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ResetAbbr" ), new OptionHandler( ResetHandler ), manager.GetString( "OptionTable_Reset" ), true ), 
              new OptionTableEntry( manager.GetString( "OptionTable_Force" ), new OptionHandler( ForceHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ForceAbbr" ), new OptionHandler( ForceHandler ), manager.GetString( "OptionTable_Force" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_BuildCache" ), new OptionHandler( BuildCacheHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_BuildCacheAbbr" ), new OptionHandler( BuildCacheHandler ), manager.GetString( "OptionTable_BuildCache" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_Help" ), new OptionHandler( HelpHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr1" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr2" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr3" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ), true ),
            };
        
        private static MembershipConditionTableEntry[] mshipTable =
            { new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_All" ), new MembershipConditionHandler( AllMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_AppDir" ), new MembershipConditionHandler( ApplicationDirectoryMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Custom" ), new MembershipConditionHandler( CustomMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Hash" ), new MembershipConditionHandler( HashMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Pub" ), new MembershipConditionHandler( PublisherMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Site" ), new MembershipConditionHandler( SiteMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Strong" ), new MembershipConditionHandler( StrongNameMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Url" ), new MembershipConditionHandler( URLMembershipConditionHandler ) ),
              new MembershipConditionTableEntry( manager.GetString( "MembershipConditionTable_Zone" ), new MembershipConditionHandler( ZoneMembershipConditionHandler ) ),
            };
        
        private static CodeGroupAttributeTableEntry[] cgAttrTable =
            { new CodeGroupAttributeTableEntry( manager.GetString( "CodeGroupAttributeTable_Exclusive" ), PolicyStatementAttribute.Exclusive, manager.GetString( "Help_Option_ExclusiveFlag" ) ),
              new CodeGroupAttributeTableEntry( manager.GetString( "CodeGroupAttributeTable_LevelFinal" ), PolicyStatementAttribute.LevelFinal, manager.GetString( "Help_Option_LevelFinalFlag" ) ),
              new CodeGroupAttributeTableEntry( manager.GetString( "CodeGroupAttributeTable_Name" ), new CodeGroupAttributeHandler( CodeGroupNameHandler ), true ),
              new CodeGroupAttributeTableEntry( manager.GetString( "CodeGroupAttributeTable_NameAbbr" ), new CodeGroupAttributeHandler( CodeGroupNameHandler ), false ),
              new CodeGroupAttributeTableEntry( manager.GetString( "CodeGroupAttributeTable_Description" ), new CodeGroupAttributeHandler( CodeGroupDescriptionHandler ), true ),
              new CodeGroupAttributeTableEntry( manager.GetString( "CodeGroupAttributeTable_DescriptionAbbr" ), new CodeGroupAttributeHandler( CodeGroupDescriptionHandler ), false )
            };
        
        // Map between zone number and zone name.    
        private static String[] s_names =
            {"MyComputer", "Intranet", "Trusted", "Internet", "Untrusted"};
    

        private static bool screenPauseEnabled = false;
        private static readonly int ScreenHeight = 23;
        private static int linesSeen = 0;

        private static void PauseCapableWriteLine( String msg )
        {
            String[] splitMsg = msg.Split( '\n' );

            for (int i = 0; i < splitMsg.Length; ++i)
            {
                Console.WriteLine( splitMsg[i].Trim( System.Environment.NewLine.ToCharArray() ) );
                if (++linesSeen == ScreenHeight && screenPauseEnabled)
                {
// We can do the lines below to effectively print out screen at a time.  Commenting
// out for now since it requires some tests to be changed and it's not an important
// enough feature to merit the trouble. -gregfee 3/30/2001                   
                    Console.WriteLine( manager.GetString( "Dialog_PressEnterToContinue" ) );
                    Console.ReadLine();
//
                    linesSeen = 0;
                }
            }
        }

        static String GenerateHeader()
        {
            StringBuilder sb = new StringBuilder();
                sb.Append( manager.GetString( "Copyright_Line1" ) + " " + Util.Version.VersionString );
            sb.Append( Environment.NewLine + manager.GetString( "Copyright_Line2" ) + Environment.NewLine );
            return sb.ToString();
        }        

        public static void Main( String[] args )
        {
            PauseCapableWriteLine( GenerateHeader() );
    
            try
            {
                if (args.Length == 0)
                {
                    Error( null, manager.GetString( "Error_NotEnoughArgs" ), -1 );
                }
                else
                {
                    String[] normalizedArgs = args;

                    // Uncomment the line below to enable the new format
                    // Note: this doesn't change acceptance of the old style.
                    // normalizedArgs = NormalizeArguments( args );

                    Run( normalizedArgs );
                }
            }
            catch (ExitException)
            {
            }
        }

        static String[] NormalizeArguments( String[] args )
        {
            ArrayList normalizedArgsList = new ArrayList();

            for (int i = 0; i < args.Length; ++i)
            {
                if (args[i] == null)
                    continue;

                String[] tempNormalizedArg = NormalizeArgument( args[i] );

                for (int j = 0; j < tempNormalizedArg.Length; ++j)
                {
                    normalizedArgsList.Add( tempNormalizedArg[j] );
                }
            }

            String[] normalizedArgs = new String[normalizedArgsList.Count];

            normalizedArgsList.CopyTo( normalizedArgs );

            return normalizedArgs;
        }

        static bool TestArgument( String arg )
        {
            // This function makes sure that anywhere we are changing from a '/'
            // to a '-' we are producing a valid option.  This may make our
            // error reporting less than stellar, but it leaves the old style
            // in it's most functional form.

            for (int i = 0; i < optionTable.Length; ++i)
            {
                if (String.Compare( optionTable[i].option, arg, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }

            return false;
        }


        static String[] NormalizeArgument( String arg )
        {
            // Here's where the actual work to convert a given argument from the
            // .Net "standard" form to the "caspol native" form.

            String[] retval;

            char[] colonAndEquals = new char[] { ':', '=' };

            // We only convert args that start with a forward slash
            // Note: this allows you to mix and match the argument styles.

            if (arg[0] == '/')
            {
                int colonIndex = arg.IndexOfAny( colonAndEquals );

                if (colonIndex == -1)
                {
                    // There are no subarguments, so just test the argument
                    // and return it as necessary.

                    retval = new String[1];

                    String temp = '-' + arg.Substring( 1, arg.Length - 1 );

                    if (TestArgument( temp ))
                        retval[0] = temp;
                    else
                        retval[0] = arg;

                    return retval;
                }
                else
                {
                    // There are subarguments so it gets a little trickier.

                    char[] commaAndQuote = new char[] { ',', '\"' };

                    // First, test the first argument to make sure it will be
                    // valid with the change to a dash.

                    String temp = '-' + arg.Substring( 1, colonIndex - 1 );

                    if (!TestArgument( temp ))
                    {
                        retval = new String[1];

                        retval[0] = temp;

                        return retval;
                    }

                    // If so, we start a list of the arguments contained within
                    // this single new form argument.
    
                    ArrayList newArgs = new ArrayList();

                    newArgs.Add( temp );

                    String remainingArgs = arg.Substring( colonIndex + 1 );

                    bool inQuote = false;
                    String intermediateArg = null;

                    // Iterate through the rest of the new form argument
                    // parsing out all the individual arguments.

                    for (;;)
                    {
                        // We handle the quoted case explicitly here, so things get
                        // a little wacky.

                        int commaIndex = remainingArgs.IndexOfAny( commaAndQuote );

                        if (commaIndex == -1)
                        {
                            if (remainingArgs.Length > 0)
                            {
                                newArgs.Add( remainingArgs );
                            }
                            break;
                        }
                        else if (remainingArgs[commaIndex] == '\"')
                        {
                            // Here we capture any quotes in the string.  If we are in a quote, this newly
                            // discovered quote means the quote is complete and we add the argument
                            // to the list.  If not, we are starting a new quote so we reset the intermediate argument.

                            if (inQuote)
                            {
                                newArgs.Add( intermediateArg + (commaIndex == 0 ? "" : remainingArgs.Substring( 0, commaIndex )) );
                                remainingArgs = remainingArgs.Substring( commaIndex + 1 );
                                inQuote = false;
                            }
                            else
                            {
                                remainingArgs = remainingArgs.Substring( 1 );
                                intermediateArg = "";
                                inQuote = true;
                            }
                        }
                        else if (!inQuote)
                        {
                            // If we are not in a quote, we just add the substring to the
                            // argument list, ignoring consecutive commas.

                            if (commaIndex == 0)
                            {
                                remainingArgs = remainingArgs.Substring( 1 );
                            }
                            else
                            {
                                newArgs.Add( remainingArgs.Substring( 0, commaIndex ) );
                                remainingArgs = remainingArgs.Substring( commaIndex + 1 );
                            }
                        }
                        else
                        {
                            // If we are in a quote, then we want to append everything to the
                            // intermediateArg (including the comma).

                            intermediateArg += remainingArgs.Substring( 0, commaIndex + 1 );
                            remainingArgs = remainingArgs.Substring( commaIndex + 1 );
                        }

                    }

                    retval = new String[newArgs.Count];

                    newArgs.CopyTo( retval );

                    return retval;
                }
            }
            else
            {
                retval = new String[1];

                retval[0] = arg;

                return retval;
            }
        }



        
    
        static void Run( String[] args )
        {
            int numArgs = args.Length;
            int currentIndex = 0;
            int numArgsUsed = 0;
        
            while (currentIndex < numArgs)
            {
                bool foundOption = false;
        
                for (int index = 0; index < optionTable.Length; ++index)
                {
                    if (args[currentIndex][0] == '/')
                    {
                        args[currentIndex] = '-' + args[currentIndex].Substring( 1, args[currentIndex].Length - 1 );
                    }

                    if (String.Compare( optionTable[index].option, args[currentIndex], true, CultureInfo.InvariantCulture) == 0)
                    {
                        try
                        {
                            optionTable[index].handler(args, currentIndex, out numArgsUsed );
                        }
                        catch (Exception e)
                        {
                            if (!(e is ExitException))
                            {
    #if _DEBUG
                                Error( null, String.Format( manager.GetString( "Error_RuntimeError" ), e.ToString() ), -1 );
    #else
                                String message = e.Message;

                                if (message == null || message.Equals( "" ))
                                {
                                    message = e.GetType().AssemblyQualifiedName;
                                }

                                Error( null, String.Format( manager.GetString( "Error_RuntimeError" ), message ), -1 );
    #endif
                            }
                            return;
                        }
                    
                        foundOption = true;
                        currentIndex += numArgsUsed;
                        break;
                    }
                }
                if (!foundOption)
                {
                    try
                    {
                        Error( null, String.Format( manager.GetString( "Error_InvalidOption" ), args[currentIndex] ), -1 );
                    }
                    catch (Exception e)
                    {
                        if (!(e is ExitException))
                        {
                            String message = e.Message;

                            if (message == null || message.Equals( "" ))
                            {
                                message = e.GetType().AssemblyQualifiedName;
                            }

                            Help( null, manager.GetString( "Error_UnhandledError" ) + message );
                        }
                        return;
                    }
                }
            }
            if (m_danglingLevelIndicator != null)
                PauseCapableWriteLine( String.Format( manager.GetString( "Error_DanglingLevelIndicator" ), m_danglingLevelIndicator ) );
        
            if (m_success)
                PauseCapableWriteLine( manager.GetString( "Dialog_Success" ) );
        }
    
        private static PermissionSet GeneratecaspolRequiredPermSet()
        {
            PermissionSet permSet = new PermissionSet( PermissionState.None );
            permSet.AddPermission( new SecurityPermission( SecurityPermissionFlag.Execution | SecurityPermissionFlag.ControlPolicy ) );
            return permSet;
        }
    
        private static int ConvertHexDigit(Char val) {
            int retval;
            if (val <= '9')
                retval = (val - '0');
            else if (val >= 'a')
                retval = ((val - 'a') + 10);
            else
                retval = ((val - 'A') + 10);
            return retval;
                
        }

        
        public static byte[] DecodeHexString(String hexString)
        {
            if (hexString == null)
                throw new ArgumentNullException( "hexString" );
                
            bool spaceSkippingMode = false;    
                
            int i = 0;
            int length = hexString.Length;
        
            if (hexString.StartsWith( "0x" ))
            {
                length = hexString.Length - 2;
                i = 2;
            }
        
            // Hex strings must always have 2N or (3N - 1) entries.
        
            if (length % 2 != 0 && length % 3 != 2)
            {
                throw new ArgumentException( manager.GetString( "Argument_ImproperlyFormattedHexString") );
            }                
            
            byte[] sArray;
            
            if (length >=3 && hexString[i + 2] == ' ')
            {
                spaceSkippingMode = true;
                
                // Each hex digit will take three spaces, except the first (hence the plus 1).
                sArray = new byte[length / 3 + 1];
            }
            else
            {
                // Each hex digit will take two spaces
                sArray = new byte[length / 2];
            }
            
            int digit;
            int rawdigit;
            for (int j = 0; i < hexString.Length; i += 2, j++) {
                rawdigit = ConvertHexDigit(hexString[i]);
                digit = ConvertHexDigit(hexString[i+1]);
                sArray[j] = (byte) (digit | (rawdigit << 4));
                if (spaceSkippingMode)
                    i++;
            }
            return(sArray);    
        }


        static void CodeGroupNameHandler( CodeGroup group, String[] args, int index, out int offset )
        {
            offset = 2;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Name" ) );
                return;
            }
        
            if (args.Length - index < 1)
            {
                ErrorMShip( args[0], manager.GetString( "CodeGroupAttributeTable_Name" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            if (args[index+1][0] >= '0' &&
                args[index+1][0] <= '9')
            {
                ErrorMShip( args[0], manager.GetString( "CodeGroupAttributeTable_Name" ), manager.GetString( "Error_CodeGroup_ImproperName" ), -1 );
            }

            group.Name = args[index+1];
        }

        static void CodeGroupDescriptionHandler( CodeGroup group, String[] args, int index, out int offset )
        {
            offset = 2;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Description" ) );
                return;
            }
        
            if (args.Length - index < 1)
            {
                ErrorMShip( args[0], manager.GetString( "CodeGroupAttributeTable_Description" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            group.Description = args[index+1];
        }


        static PolicyStatementAttribute IsExclusive( CodeGroup group, String[] args, int index, out int argsUsed )
        {
            PolicyStatementAttribute attr = PolicyStatementAttribute.Nothing;
        
            argsUsed = 0;
        
            int usedInThisIteration;
            int tableCount = cgAttrTable.Length;
        
            do
            {
                usedInThisIteration = 0;
        
                if ((args.Length - (index + argsUsed)) == 0)
                {
                    break;
                }

                for (int i = 0; i < tableCount; ++i)
                {
                    if (String.Compare( args[index+argsUsed], cgAttrTable[i].label, true, CultureInfo.InvariantCulture) == 0)
                    {
                        if (cgAttrTable[i].handler == null)
                        {
                            if ((args.Length - (index + argsUsed + 1)) <= 0)
                            {
                                throw new Exception( String.Format( manager.GetString( "Error_NotEnoughArgs" ) ) );
                            }
                            else if (String.Compare( args[index+argsUsed+1], manager.GetString( "Misc_On" ), true, CultureInfo.InvariantCulture) == 0)
                            {
                                attr |= cgAttrTable[i].value;
                            }
                            else if (String.Compare( args[index+argsUsed+1], manager.GetString( "Misc_Off" ), true, CultureInfo.InvariantCulture) == 0)
                            {
                                attr &= ~cgAttrTable[i].value;
                            }
                            else
                            {
                                throw new Exception( String.Format( manager.GetString( "Error_InvalidOptionTo" ), cgAttrTable[i].label, args[index+argsUsed+1] ) );
                            }
                            usedInThisIteration = 2;
                        }
                        else
                        {
                            cgAttrTable[i].handler( group, args, index + argsUsed, out usedInThisIteration );
                        }
                        break;
                    }

                }
                if (usedInThisIteration == 0)
                {
                    break;
                }
                else
                {
                    argsUsed += usedInThisIteration;
                }
            
            } while (true);
    
            return attr;
        }
    
        static IMembershipCondition CreateMembershipCondition( PolicyLevel level, String[] args, int index, out int offset )
        {
            IMembershipCondition mship = CreateMembershipConditionNoThrow( level, args, index, out offset );
        
            if (mship == null)
            {
                int optionIndex = index >= 2 ? 2 : 0;
                ErrorMShip( args[optionIndex], null, String.Format( manager.GetString( "Error_UnknownMembershipCondition" ), args[index] ), -1 );
            }
        
            return mship;
        }
    
        static IMembershipCondition CreateMembershipConditionNoThrow( PolicyLevel level, String[] args, int index, out int offset )
        {
            for (int i = 0; i < mshipTable.Length; ++i)
            {
                if (String.Compare( mshipTable[i].option, args[index], true, CultureInfo.InvariantCulture) == 0)
                {
                    return mshipTable[i].handler( level, args, index, out offset );
                }
            }
        
            offset = 0;
        
            return null;
        }    
    
        static IMembershipCondition AllMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            offset = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_All" ) );
                return null;
            }
        
            return new AllMembershipCondition();
        }
    
        static IMembershipCondition ApplicationDirectoryMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            offset = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_AppDir" ) );
                return null;
            }
        
            return new ApplicationDirectoryMembershipCondition();
        }

        static IMembershipCondition CustomMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Custom" ) );
                offset = 1;
                return null;
            }
        
            if (args.Length - index < 2)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Custom" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }

            offset = 2;

            SecurityElement element = ReadXmlFile( args, index+1 );

            if (element == null)
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Custom" ), manager.GetString( "Error_Custom_ErrorDecodingArg" ), -1 );

            // Grab the class name and create the proper membership condition;

            IMembershipCondition cond = null;
            Type type;
            String className = element.Attribute( "class" );

            if (className == null)
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Custom" ), manager.GetString( "Error_Custom_InvalidXml" ), -1 );
        
            type = Type.GetType( className );

            try
            {
                cond = (IMembershipCondition)Activator.CreateInstance( type );
            }
            catch (Exception)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Custom" ), manager.GetString( "Error_Custom_UnableToCreate" ), -1 );
            }           

            if (cond == null)
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Custom" ), manager.GetString( "Error_Custom_InvalidXml" ), -1 );

            try
            {
                cond.FromXml( element );
            }
            catch (Exception e2)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Custom" ), String.Format( manager.GetString( "Error_Custom_InvalidXml" ), e2 ), -1 );
            }                       

            m_levelAssemblyList.Add( cond.GetType().Module.Assembly );

            return cond;
        }

    
        static IMembershipCondition HashMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Hash" ) );
                offset = 0;
                return null;
            }
        
            if (args.Length - index < 4)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Hash" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            HashAlgorithm hashAlg = HashAlgorithm.Create( args[index+1] );

            if (hashAlg == null)
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Hash" ), String.Format( manager.GetString( "Error_UnknownHashAlgorithm" ), args[index+1] ), -1 );

            byte[] hashValue = null;
        
            if (String.Compare( args[index+2], manager.GetString( "Misc_File" ), true, CultureInfo.InvariantCulture) == 0)
            {
                try
                {
                    hashValue = new Hash( LoadAssembly( args[index+3], manager.GetString( "MembershipConditionTable_Hash" ) ) ).GenerateHash( HashAlgorithm.Create( args[index+1] ) );
                }
                catch (Exception e1)
                {
                    ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Hash" ), String.Format( manager.GetString( "Error_Hash_UnableToGenerateHash" ), e1 ), -1 );
                }
                offset = 4;
            }
            else if (String.Compare( args[index+2], manager.GetString( "Misc_Hex" ), true, CultureInfo.InvariantCulture) == 0)
            {
                hashValue = DecodeHexString( args[index+3] );
                offset = 4;
            }
            else
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Hash" ), String.Format( manager.GetString( "Error_Hash_InvalidOption" ), args[index+2] ), -1 );
                // not reached;
                offset = 0;
            }
            
            return new HashMembershipCondition( hashAlg, hashValue );
        }
    
        static IMembershipCondition PublisherMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            offset = 3;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Pub" ) );
                return null;
            }
        
            if (args.Length - index < 2)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Pub" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            X509Certificate pub = null;
        
            if (String.Compare( args[index+1], manager.GetString( "Misc_File" ), true, CultureInfo.InvariantCulture) == 0)
            {
                pub = X509Certificate.CreateFromSignedFile( args[index+2] );
            }
            else if (String.Compare( args[index+1], manager.GetString( "Misc_Cert" ), true, CultureInfo.InvariantCulture) == 0)
            {
                pub = X509Certificate.CreateFromCertFile( args[index+2] );
            }
            else if (String.Compare( args[index+1], manager.GetString( "Misc_Hex" ), true, CultureInfo.InvariantCulture) == 0)
            {
                pub = new X509Certificate( DecodeHexString( args[index+2] ) );
            }
            else            
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Pub" ), "Invalid publisher option - " + args[index+1], -1 );
            }
            
            return new PublisherMembershipCondition( pub );
        }    
    
        static IMembershipCondition SiteMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            offset = 2;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Site" ) );
                return null;
            }
        
            if (args.Length - index < 1)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Site" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            return new SiteMembershipCondition( args[index+1] );
        }
    
        static IMembershipCondition StrongNameMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Strong" ) );
                offset = 0;
                return null;
            }
        
            if (args.Length - index < 5)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Strong" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            StrongNamePublicKeyBlob publicKey = null;
            String assemblyName = null;
            String assemblyVersion = null;
            
            if (String.Compare( args[index+1], manager.GetString( "Misc_File" ), true, CultureInfo.InvariantCulture) == 0)
            {
                AssemblyName name = AssemblyName.GetAssemblyName( args[index+2] );
                publicKey = new StrongNamePublicKeyBlob( name.GetPublicKey() );
                assemblyName = args[index+3];
                assemblyVersion = args[index+4];
                offset = 5;
            }
            else
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Strong" ), String.Format( manager.GetString( "Error_StrongName_InvalidOption" ), args[index+1] ), -1 );
                // not reached
                offset = 0;
            }
                
            if (String.Compare( assemblyName, manager.GetString( "Misc_NoName" ), true, CultureInfo.InvariantCulture) == 0)
            {
                assemblyName = null;
            }
                    
            if (String.Compare( assemblyVersion, manager.GetString( "Misc_NoVersion" ), true, CultureInfo.InvariantCulture) == 0)
            {
                assemblyVersion = null;
            }
        
            Version asmVer = null;
        
            if (assemblyVersion != null)
            {
                try
                {
                    asmVer = new Version( assemblyVersion );
                }
                catch (Exception)
                {
                    ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Strong" ), manager.GetString( "Error_StrongName_ImproperlyFormattedVersion" ), -1 );
                }
            }
                
            return new StrongNameMembershipCondition( publicKey, assemblyName, asmVer );
        }         
    
        static IMembershipCondition URLMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            offset = 2;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Url" ) );
                return null;
            }
        
            if (args.Length - index < 1)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Url" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            return new UrlMembershipCondition( args[index+1] );
        }
    
        static IMembershipCondition ZoneMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
        {
            offset = 2;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_MembershipCondition_Zone" ) );
                for (int i = 0; i < s_names.Length; ++i)
                    PauseCapableWriteLine( "                                 " + s_names[i] );
                return null;
            }
        
            if (args.Length - index < 2)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Zone" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            SecurityZone zoneNum = SecurityZone.NoZone;
                
            try
            {
                zoneNum = (SecurityZone)Int32.Parse( args[index+1] );
            }
            catch (Exception)
            {
                for (int i = 0; i < s_names.Length; ++i)
                {
                    if (String.Compare( args[index+1], s_names[i], true, CultureInfo.InvariantCulture) == 0)
                    {
                        zoneNum = (SecurityZone)i;
                        break;
                    }
                }
            }
                
            if (zoneNum < SecurityZone.MyComputer || zoneNum > SecurityZone.Untrusted)
            {
                ErrorMShip( args[0], manager.GetString( "MembershipConditionTable_Zone" ), String.Format( manager.GetString( "Error_Zone_InvalidZone" ), args[index+1] ), -1 );
            }
        
            return new ZoneMembershipCondition( zoneNum );
        }            
    
    
        static PolicyLevel GetLevel( String label )
        {
            IEnumerator enumerator;
                
            try
            {
                enumerator = SecurityManager.PolicyHierarchy();
            }
            catch (SecurityException)
            {
                Error( null, "Insufficient rights to obtain policy level", -1 );
                // not reached
                return null;
            }
                
            while (enumerator.MoveNext())
            {
                PolicyLevel level = (PolicyLevel)enumerator.Current;
                if (level.Label.Equals( label ))
                {
                    return level;
                }
            }
                
            return null;
        }    
        
        static PolicyLevel GetLevel()
        {
            return GetLevel( LevelType.None );
        }
        
        static PolicyLevel GetLevel( LevelType type )
        {
            m_danglingLevelIndicator = null;

            if (m_levelType == LevelType.None)
            {
                if (type == LevelType.None)
                {            
                    bool isAdmin = false;

                    try
                    {
                        WindowsPrincipal principal = new WindowsPrincipal( WindowsIdentity.GetCurrent() );
                        isAdmin = principal.IsInRole( WindowsBuiltInRole.Administrator );
                    }
                    catch (Exception)
                    {
                    }

                    if (isAdmin)
                    {
                        m_levelAssemblyList = m_machineAssemblies;
                        return GetLevel( "Machine" );
                    }
                    else
                    {
                        m_levelAssemblyList = m_userAssemblies;
                        return GetLevel( "User" );
                    }
                }
                else if (type == LevelType.All)
                {
                    return null;
                }
                else
                {
                    Error( null, "Unknown level type", -1 );
                    /* not reached */
                    return null;
                }
            }
            else if (m_levelType == LevelType.Machine)
            {
                m_levelAssemblyList = m_machineAssemblies;
                return GetLevel( "Machine" );
            }
            else if (m_levelType == LevelType.UserDefault)
            {
                m_levelAssemblyList = m_userAssemblies;
                return GetLevel( "User" );
            }
            else if (m_levelType == LevelType.UserCustom)
            {
                if (m_currentCustomLevel == null)
                {
                    m_levelAssemblyList = m_customUserAssemblies;
                    try
                    {
                        m_currentCustomLevel = SecurityManager.LoadPolicyLevelFromFile( m_levelPath, PolicyLevelType.User );
                    }
                    catch (Exception e)
                    {
                        Error( null, e.Message, -1 );
                    }
                }
                return m_currentCustomLevel;
            }
            else if (m_levelType == LevelType.All)
            {
                return null;
            }
            else if (m_levelType == LevelType.Enterprise)
            {
                m_levelAssemblyList = m_enterpriseAssemblies;
                return GetLevel( "Enterprise" );
            }
            else if (m_levelType == LevelType.AllCustom)
            {
                if (m_currentCustomLevel == null)
                {
                    try
                    {
                        m_currentCustomLevel = SecurityManager.LoadPolicyLevelFromFile( m_levelPath, PolicyLevelType.User );
                    }
                    catch (Exception e)
                    {
                        Error( null, e.Message, -1 );
                    }
                }
                return null;
            }
            else
            {
                // This should never occur.
                Error( null, "Unknown level type", -1 );
                /* not reached */
                return null;
            }
        }        

    
        static String ParentLabel( String label )
        {
            if (label[0] < '0' || label[0] > '9')
            {
                PolicyLevel level = GetLevel();
                Object obj;
                String numericLabel = "1";
                if (level.RootCodeGroup.Name.Equals( label ))
                    obj = level.RootCodeGroup;
                else
                    obj = GetLabelByName( label, level.RootCodeGroup, ref numericLabel );
                label = numericLabel;
            }

            String[] separated = label.Split( m_labelSeparators.ToCharArray() );
            int size = separated[separated.Length-1] == null || separated[separated.Length-1].Equals( "" )
                            ? separated.Length-1 : separated.Length;
        
            StringBuilder sb = new StringBuilder();
        
            for (int i = 0; i < size-1; ++i)
            {
                sb.Append( separated[i] );
                sb.Append( '.' );
            }
        
            return sb.ToString();
        }


        static void ReplaceLabel( String label, CodeGroup obj )
        {
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                return;
            }
        
            if (label == null)
            {
                return;
            }        
    
            if (label[0] < '0' || label[0] > '9')
            {
                String numericLabel = "1";
                GetLabelByName( label, level.RootCodeGroup, ref numericLabel );
                label = numericLabel;
            }

            String[] separated = label.Split( m_labelSeparators.ToCharArray() );
            int size = separated[separated.Length-1] == null || separated[separated.Length-1].Equals( "" )
                            ? separated.Length-1 : separated.Length;
        
            if (size >= 1 && !separated[0].Equals( "1" ))
            {
                throw new ArgumentException( String.Format( manager.GetString( "Error_InvalidLabelArg" ), label ) );
            }
        
        
            CodeGroup group = level.RootCodeGroup;

            if (size == 1 && separated[0].Equals( "1" ))
            {
                level.RootCodeGroup = obj;
                return;
            }

            ArrayList groupsList = new ArrayList();
        
            CodeGroup newGroup = group;

            groupsList.Insert( 0, group );

            for (int index = 1; index < size - 1; ++index)
            {
                IEnumerator enumerator = group.Children.GetEnumerator();
                int count = 1;
            
                while (enumerator.MoveNext())
                {
                    if (count == Int32.Parse( separated[index] ))
                    {
                        newGroup = (CodeGroup)enumerator.Current;
                        break;
                    }
                    else
                    {
                        count++;
                    }
                }
            
                if (newGroup == null)
                    throw new ArgumentException( String.Format( manager.GetString( "Error_InvalidLabelArg" ), label ) );
                else
                {
                    group = newGroup;
                    groupsList.Insert( 0, group );
                }
            }

            groupsList.Insert( 0, obj );

            for (int i = 1; i < groupsList.Count; ++i)
            {
                newGroup = (CodeGroup)groupsList[i];

                IEnumerator finalEnumerator = newGroup.Children.GetEnumerator();

                newGroup.Children = new ArrayList();

                int finalCount = 1;
                while (finalEnumerator.MoveNext())
                {
                    if (finalCount == Int32.Parse( separated[size-i] ))
                    {
                        newGroup.AddChild( (CodeGroup)groupsList[i-1] );
                    }
                    else
                    {
                        newGroup.AddChild( (CodeGroup)finalEnumerator.Current );
                    }
                    finalCount++;
                }

            }

            level.RootCodeGroup = (CodeGroup)groupsList[groupsList.Count-1];        
        }

    
        static Object GetLabel( String label )
        {
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                return null;
            }
        
            if (label == null)
            {
                return null;
            }        
    
            if (label[0] < '0' || label[0] > '9')
            {
                String numericLabel = "1";
                if (level.RootCodeGroup.Name.Equals( label ))
                    return level.RootCodeGroup;
                else
                    return GetLabelByName( label, level.RootCodeGroup, ref numericLabel );
            }

            String[] separated = label.Split( m_labelSeparators.ToCharArray() );
            int size = separated[separated.Length-1] == null || separated[separated.Length-1].Equals( "" )
                            ? separated.Length-1 : separated.Length;
        
            if (size >= 1 && !separated[0].Equals( "1" ))
            {
                throw new ArgumentException( String.Format( manager.GetString( "Error_InvalidLabelArg" ), label ) );
            }
        
        
            CodeGroup group = level.RootCodeGroup;

            if (size == 1 && separated[0].Equals( "1" ))
            {
                return group;
            }
        
            for (int index = 1; index < size; ++index)
            {
                CodeGroup newGroup = null;
                IEnumerator enumerator = group.Children.GetEnumerator();
                int count = 1;
            
                while (enumerator.MoveNext())
                {
                    if (count == Int32.Parse( separated[index] ))
                    {
                        newGroup = (CodeGroup)enumerator.Current;
                        break;
                    }
                    else
                    {
                        count++;
                    }
                }
            
                if (newGroup == null)
                    throw new ArgumentException( String.Format( manager.GetString( "Error_InvalidLabelArg" ), label ) );
                else
                    group = newGroup;
            }
        
            return group;
        }

        static Object GetLabelByName( String label, CodeGroup group, ref String numericLabel )
        {
            if (group.Name != null && group.Name.Equals( label ))
            {
                numericLabel = "1";
                return group;
            }

            return GetLabelByNameHelper( label, group, ref numericLabel );
        }

        static Object GetLabelByNameHelper( String label, CodeGroup group, ref String numericLabel )
        {
            IEnumerator enumerator = group.Children.GetEnumerator();

            int count = 1;

            while (enumerator.MoveNext())
            {
                String tempNumericLabel;
            
                tempNumericLabel = numericLabel + "." + count;

                CodeGroup currentGroup = (CodeGroup)enumerator.Current;

                if (currentGroup.Name != null && currentGroup.Name.Equals( label ))
                {
                    numericLabel = tempNumericLabel;
                    return enumerator.Current;
                }

                Object retval = GetLabelByNameHelper( label, currentGroup, ref tempNumericLabel );

                if (retval != null)
                {
                    numericLabel = tempNumericLabel;
                    return retval;
                }

                count++;
            }

            numericLabel = null;
            return null;
        }
    
        static bool DisplayMShipInfo( String which )
        {
            if (which == null)
                return true;
            
            for (int i = 0; i < optionTable.Length; ++i)
            {
                // Only list if we've said to list it.        
                if (String.Compare( which, optionTable[i].option, true, CultureInfo.InvariantCulture) == 0)
                    return optionTable[i].displayMShip;
            }
        
            return true;
        }
                
        static void Error( String which, String message, int errorCode )
        {
            ErrorMShip( which, null, message, errorCode, DisplayMShipInfo( which ) );
        }
    
        static void ErrorMShip( String whichOption, String whichMShip, String message, int errorCode )
        {
            ErrorMShip( whichOption, whichMShip, message, errorCode, true );
        }
    
        static void ErrorMShip( String whichOption, String whichMShip, String message, int errorCode, bool displayMshipInfo )
        {
            HelpMShip( whichOption, whichMShip, String.Format( manager.GetString( "Error_Arg" ), message ), displayMshipInfo );
            // HACK: throw an exception here instead of exiting since we can't always
            // call Runtime.Exit().
            System.Environment.ExitCode = errorCode;
            throw new ExitException();
        }
    
        static void Help( String which, String message )
        {
            HelpMShip( which, null, message, DisplayMShipInfo( which ) );
        }
    
        static void Help( String which, String message, bool displayMshipInfo )
        {
            HelpMShip( which, null, message, displayMshipInfo );
        }
    
        static void HelpMShip( String whichOption, String whichMShip, String message )
        {
            HelpMShip( whichOption, whichMShip, message, true );
        }
    
        static void HelpMShip( String whichOption, String whichMShip, String message, bool displayMShipInfo )
        {
            PauseCapableWriteLine( message + Environment.NewLine );
    
            PauseCapableWriteLine( manager.GetString( "Usage" ) + Environment.NewLine );
    
            String[] helpArgs = new String[1];
            helpArgs[0] = "__internal_usage__";
            int numArgs = 0;
            // Remove this when the C# bug is fixed.
            numArgs++;
    
            for (int i = 0; i < optionTable.Length; ++i)
            {
                // Only list if we've said to list it.        
                if (optionTable[i].list)
                {
                    // Look for all the options that aren't the same as something as and that we have requested.
                    if (optionTable[i].sameAs == null && (whichOption == null || String.Compare( whichOption, optionTable[i].option, true, CultureInfo.InvariantCulture) == 0))
                    {
                        // For each option we find, print out all like options first.
                        for (int j = 0; j < optionTable.Length; ++j)
                        {
                            if (optionTable[j].list && optionTable[j].sameAs != null && String.Compare( optionTable[i].option, optionTable[j].sameAs, true, CultureInfo.InvariantCulture) == 0)
                            {
                                StringBuilder sb = new StringBuilder();
                                sb.Append( manager.GetString( "Usage_Name" ) );
                                sb.Append( " " );
                                sb.Append( optionTable[j].option );
                                PauseCapableWriteLine( sb.ToString() );
                            }
                        }
                        
                        optionTable[i].handler(helpArgs, 0, out numArgs);
                        PauseCapableWriteLine( "" );
                    }
                }
            }
    
            if (displayMShipInfo)
            {
                PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Usage_MembershipCondition" ) );
    
                for (int i = 0; i < mshipTable.Length; ++i)
                {
                    if (whichMShip == null || String.Compare( whichMShip, mshipTable[i].option, true, CultureInfo.InvariantCulture) == 0)
                    {
                        int offset = 0;
                        mshipTable[i].handler( null, helpArgs, 0, out offset );
                    }
                }
    
        
                PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Usage_CodeGroupAttribute" ) );
    
                for (int i = 0; i < cgAttrTable.Length; ++i)
                {
                    if (cgAttrTable[i].display)
                    {
                        if (cgAttrTable[i].handler == null)
                        {
                            PauseCapableWriteLine( "  " + cgAttrTable[i].label + manager.GetString( "Dialog_OnOff" ) );
                            PauseCapableWriteLine( "                           " + cgAttrTable[i].description );
                        }
                        else
                        {
                            cgAttrTable[i].handler( null, helpArgs, 0, out numArgs );
                        }
                    }
                }
            }
        }
    
        private static StrongName FindStrongName( Evidence evidence )
        {
            if (evidence == null)
                return null;

            IEnumerator enumerator = evidence.GetHostEnumerator();

            while (enumerator.MoveNext())
            {
                StrongName sn = enumerator.Current as StrongName;

                if (sn != null)
                    return sn;
            }

            return null;
        }

        private static bool GetAnswer()
        {
            String input = Console.ReadLine();
        
            return !(input == null || (String.Compare( input, manager.GetString( "Misc_Yes" ), true, CultureInfo.InvariantCulture) != 0 && String.Compare( input, manager.GetString( "Misc_YesAbbr" ), true, CultureInfo.InvariantCulture) != 0));        
        }
    

        private static void CheckAddedAssemblies( PolicyLevel level, ref ArrayList assemblies )
        {
            try
            {
                if (assemblies == null || level == null)
                    return;

                IEnumerator enumerator = assemblies.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    Assembly assembly = (Assembly)enumerator.Current;
                    StrongName sn = FindStrongName( assembly.Evidence );

                    if (sn == null)
                    {
                    PauseCapableWriteLine( manager.GetString( "Dialog_AssemblyNotStrongNamed" ) );
                        if (!GetAnswer())
                            throw new ExitException();
                    }
                    else if (!sn.Name.Equals( "mscorlib" ))
                    {
                        IEnumerator snEnumerator = level.FullTrustAssemblies.GetEnumerator();
                        bool found = false;

                        Evidence evidence = new Evidence();
                        evidence.AddHost( sn );

                        while (snEnumerator.MoveNext())
                        {
                            if (((StrongNameMembershipCondition)snEnumerator.Current).Check( evidence ))
                            {
                                found = true;
                                break;
                            }
                        }

                        if (!found)
                        {
                        PauseCapableWriteLine( manager.GetString( "Dialog_StrongNameAssemblyAdded1" ) );
                            PauseCapableWriteLine( sn.Name + " " + sn.Version );
                        PauseCapableWriteLine( manager.GetString( "Dialog_StrongNameAssemblyAdded2" ) );
                            if (GetAnswer())
                            {
                                level.AddFullTrustAssembly( sn );
                            }
                        }
                    }
                }
            }
            finally
            {
                assemblies = new ArrayList();
            }
        }

        private static bool Quiet = false;

        private static bool PolicyPrompt
        {
            get
            {
                RegistryKey key = Registry.LocalMachine.OpenSubKey( m_policyKey, false);

                bool promptOn;

                if (key == null)
                {
                    promptOn = true;        
                }
                else
                {
                    byte[] value = (byte[])key.GetValue( "CaspolSettings", null );
		    key.Close();

                    if (value == null)
                        promptOn = true;
                    else
                        promptOn = (value[0] & 0x01) != 0x01;
                }
 
                return promptOn;
            }

            set
            {
                RegistryKey key = Registry.LocalMachine.OpenSubKey( m_policyKey, false);
        
                if (key == null)
                    key = Registry.LocalMachine.CreateSubKey( m_policyKey );

                byte[] keyValue = (byte[])key.GetValue( "CaspolSettings", null );
        	key.Close();

                if (keyValue == null)
                {
                    keyValue = new byte[4];
                    keyValue[0] = 0;
                    keyValue[1] = 0;
                    keyValue[2] = 0;
                    keyValue[3] = 0;
                }
            
                if (value)
                {
                    keyValue[0] = 0;
                }
                else
                {
                    keyValue[0] = 1;
                }
		key = Registry.LocalMachine.OpenSubKey( m_policyKey, true);
                key.SetValue( "CaspolSettings", keyValue );
	        key.Close();
            }
        }

        static void SafeSavePolicy()
        {
            if (true)
            {
                CheckAddedAssemblies( GetLevel( "enterprise" ), ref m_enterpriseAssemblies );
                CheckAddedAssemblies( GetLevel( "machine" ), ref m_machineAssemblies );
                CheckAddedAssemblies( GetLevel( "user" ), ref m_userAssemblies );
                CheckAddedAssemblies( m_currentCustomLevel, ref m_customUserAssemblies );
            }

            if (!m_force)
            {
                PermissionSet denied = null;
                PermissionSet granted = null;
                try
                {
                    granted = SecurityManager.ResolvePolicy( Assembly.GetExecutingAssembly().Evidence, null, null, null, out denied );
                }
                catch (PolicyException)
                {
                }

                PermissionSet caspolRequired = GeneratecaspolRequiredPermSet();
            
                if (granted == null || !caspolRequired.IsSubsetOf( granted ) || (denied != null && caspolRequired.Intersect( denied ) != null))
                {
                    PauseCapableWriteLine( manager.GetString( "Dialog_CaspolOperationRestricted" ) );
                    m_success = false;
                    throw new ExitException();
                }
            }
            
            IEnumerator levelEnumerator = null;

            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }

            if (levelEnumerator == null)
                return;

            try
            {            
                if (PolicyPrompt && !Quiet)
                {
                    PauseCapableWriteLine( manager.GetString( "Dialog_AlterPolicy" ) );
        
                    if (GetAnswer())
                    {
                        while (levelEnumerator.MoveNext())
                        {
                            SecurityManager.SavePolicyLevel( (PolicyLevel)levelEnumerator.Current );
                        }
                    }
                    else
                    {
                        PauseCapableWriteLine( manager.GetString( "Dialog_PolicySaveAborted" ) );
                        m_success = false;
                        throw new ExitException();
                    }
                }
                else
                {
                    while (levelEnumerator.MoveNext())
                    {
                        SecurityManager.SavePolicyLevel( (PolicyLevel)levelEnumerator.Current );
                    }
                }
            }
            catch (Exception e)
            {
                // If the exception thrown is an ExitException, just rethrow it.
                // Otherwise try to save policy since any exception in this block
                // are just saying that reading from the registry or gathering info
                // from the user failed.
        
                if (e is ExitException)
                    throw e;
        
                levelEnumerator.Reset();
                while (levelEnumerator.MoveNext())
                {
                    SecurityManager.SavePolicyLevel( (PolicyLevel)levelEnumerator.Current );
                }
            }

            Quiet = false;
        }
    
        static void MachineHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Machine" ) );
                return;
            }
        
            m_danglingLevelIndicator = manager.GetString( "OptionTable_Machine" );
            m_levelPath = null;
            m_levelType = LevelType.Machine;
        }
    
        static void UserHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_User" ) );
                return;
            }
        
            m_danglingLevelIndicator = manager.GetString( "OptionTable_User" );
            m_levelPath = null;
            m_levelType = LevelType.UserDefault;
        }
    
        static void EnterpriseHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Enterprise" ) );
                return;
            }
        
            m_danglingLevelIndicator = manager.GetString( "OptionTable_Enterprise" );
            m_levelPath = null;
            m_levelType = LevelType.Enterprise;
        }
    
        static void CustomUserHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_CustomUser" ) );
                return;
            }
        
            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_CustomUser" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }

            m_danglingLevelIndicator = manager.GetString( "OptionTable_CustomUser" );
            m_levelPath = args[index+1];
            m_levelType = LevelType.UserCustom;
            m_currentCustomLevel = null;
        }


        static void AllHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_All" ) );
                return;
            }
        
            m_danglingLevelIndicator = manager.GetString( "OptionTable_All" );
            m_levelPath = null;
            m_levelType = LevelType.All;
        }    

        static void CustomAllHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_CustomAll" ) );
                return;
            }
        
            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_CustomAll" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }

            m_danglingLevelIndicator = manager.GetString( "OptionTable_CustomAll" );
            m_levelPath = args[index+1];
            m_levelType = LevelType.AllCustom;
            m_currentCustomLevel = null;
        }

            
        static void SecurityHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_Security" ) );
                return;
            }

            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_Security" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            if (String.Compare( args[index + 1], manager.GetString( "Misc_On" ), true, CultureInfo.InvariantCulture) == 0)
            {
                SecurityManager.SecurityEnabled = true;
            }
            else if (String.Compare( args[index + 1], manager.GetString( "Misc_Off" ), true, CultureInfo.InvariantCulture) == 0)
            {
                SecurityManager.SecurityEnabled = false;
            }
            else
            {
                Error( manager.GetString( "OptionTable_Security" ), String.Format( manager.GetString( "Error_InvalidOption" ), args[index + 1] ), -1 );
            }
            SecurityManager.SavePolicy();
        }
    
        static void ExecutionHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_Execution" ) );
                return;
            }

            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_Execution" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            if (String.Compare( args[index + 1], manager.GetString( "Misc_On" ), true, CultureInfo.InvariantCulture) == 0)
            {
                SecurityManager.CheckExecutionRights = true;
            }
            else if (String.Compare( args[index + 1], manager.GetString( "Misc_Off" ), true, CultureInfo.InvariantCulture) == 0)
            {
                SecurityManager.CheckExecutionRights = false;
            }
            else
            {
                Error( manager.GetString( "OptionTable_Execution" ), String.Format( manager.GetString( "Error_InvalidOption" ), args[index + 1] ), -1 );
            }

            SecurityManager.SavePolicy();
        }
    
        static void BuildCacheHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_BuildCache" ) );
                return;
            }

            SecurityManager.SavePolicy();
        }
    
        static void PolicyChangeHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_PolChgPrompt" ) );
                return;
            }

            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_PolChgPrompt" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }

            if (String.Compare( args[index + 1], manager.GetString( "Misc_On" ), true, CultureInfo.InvariantCulture) == 0)
            {
                PolicyPrompt = true;
            }
            else if (String.Compare( args[index + 1], manager.GetString( "Misc_Off" ), true, CultureInfo.InvariantCulture) == 0)
            {
                PolicyPrompt = false;
            }
            else
            {
                Error( manager.GetString( "OptionTable_PolChgPrompt" ), String.Format( manager.GetString( "Error_InvalidOption" ), args[index+1] ), -1 );
            }
        }


        static void QuietHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Quiet" ) );
                return;
            }

            Quiet = true;
        }

    
        static void RecoverHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Recover" ) );
                return;
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_Recover" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            } 
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    ((PolicyLevel)levelEnumerator.Current).Recover();
                }
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
            }
        
                Error( manager.GetString( "OptionTable_Recover" ), message, -1 );
            }
        
        }
    
        static void ResetHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Reset" ) );
                return;
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_Reset" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
                    PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_ResettingPolicy" ), currentLevel.Label ) );
                    currentLevel.Reset();
                }
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
                }

                Error( manager.GetString( "OptionTable_Reset" ), message, -1 );
            }
        
        
        
            SafeSavePolicy();
        }
    
        static void ForceHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Force" ) );
                return;
            }

            m_force = true;
        }
    
    
        static void HelpHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Help" ) );
                return;
            }
        
            try
            {
                screenPauseEnabled = true;
                m_success = false;

                Help( null, manager.GetString( "Dialog_HelpScreen" ) );
            }
            finally
            {
                screenPauseEnabled = false;
            }
        }        
    
        private static void DisplayLevelCodeGroups( PolicyLevel level )
        {
            DisplayCodeGroups( level.RootCodeGroup, level.RootCodeGroup );
        }
    
        private static void DisplayCodeGroups( CodeGroup displayGroup, CodeGroup rootGroup )
        {
            String label = "1";
            
            PauseCapableWriteLine( label + ".  " +
                (displayGroup.MergeLogic.Equals( "Union" ) ? "" : ("(" + displayGroup.MergeLogic + ") ")) +
                displayGroup.MembershipCondition.ToString() + ": " +
                (displayGroup.PermissionSetName == null ? manager.GetString( "Dialog_Unknown" ) : displayGroup.PermissionSetName) +
                ( displayGroup.AttributeString == null ||
                  displayGroup.AttributeString.Equals( "" ) ? "" :
                " (" + displayGroup.AttributeString + ")" ) );
                
            if (displayGroup == rootGroup)
                ListCodeGroup( label, m_indent, displayGroup.Children.GetEnumerator(), null );
            else
                ListCodeGroup( label, m_indent, displayGroup.Children.GetEnumerator(), rootGroup.Children.GetEnumerator() );
        }
    
        private static void DisplayLevelCodeGroupNameDescriptions( PolicyLevel level )
        {
            DisplayCodeGroupNameDescriptions( level.RootCodeGroup );
        }
    
        private static void DisplayCodeGroupNameDescriptions( CodeGroup group )
        {
            String label = "1";
            
            PauseCapableWriteLine(
                label + ". " +
                (group.Name != null && !group.Name.Equals( "" ) ? group.Name : "@@No label@@") +
                ": " +
                (group.Description != null && !group.Description.Equals( "" ) ? group.Description : "@@No description@@") );  
                          
            ListCodeGroupNameDescription( label, m_indent, group.Children.GetEnumerator() );
        }        
    
        private static void DisplayLevelPermissionSets( PolicyLevel level )
        {
            IEnumerator permEnumerator = level.NamedPermissionSets.GetEnumerator();
            
            int inner_count = 1;
            
            while (permEnumerator.MoveNext())
            {
                NamedPermissionSet permSet = (NamedPermissionSet)permEnumerator.Current;
                
                StringBuilder sb = new StringBuilder();
                
                sb.Append( inner_count + ". " + permSet.Name );
                if (permSet.Description != null && !permSet.Description.Equals( "" ))
                {
                    sb.Append( " (" + permSet.Description + ")" );
                }
                sb.Append( " =" + Environment.NewLine + permSet.ToXml().ToString() );
                
                PauseCapableWriteLine( sb.ToString() );
                
                ++inner_count;
            }    
        }

        private static void DisplayLevelFullTrustAssemblies( PolicyLevel level )
        {
            IEnumerator ftEnumerator = level.FullTrustAssemblies.GetEnumerator();
            
            int inner_count = 1;
            
            while (ftEnumerator.MoveNext())
            {
                StrongNameMembershipCondition sn = (StrongNameMembershipCondition)ftEnumerator.Current;
                
                StringBuilder sb = new StringBuilder();
                
                sb.Append( inner_count + ". " );
                if (sn.Name != null)
                {
                    sb.Append( " " + sn.Name );
                }
                if ((Object) sn.Version != null)
                {
                    sb.Append( " " + sn.Version );
                }
                sb.Append( " =" + Environment.NewLine + sn.ToString() );
                
                PauseCapableWriteLine( sb.ToString() );
                
                ++inner_count;
            }    
        }
    
        static void DisplaySecurityOnOff()
        {
            PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_SecurityIs" ), manager.GetString( SecurityManager.SecurityEnabled ? "Misc_OnCap" : "Misc_OffCap" ) ) );
            PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_ExecutionCheckingIs" ), manager.GetString( SecurityManager.CheckExecutionRights ? "Misc_OnCap" : "Misc_OffCap" ) ) );
        
            try
            {
                    PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_PolicyChangePromptIs" ), manager.GetString( PolicyPrompt ? "Misc_OnCap" : "Misc_OffCap" ) ) );
            }
            catch (Exception)
            {
                PauseCapableWriteLine( manager.GetString( "Dialog_UnableToDisplayChangePrompt" ) );
            }
        
        }
    
        static void ListHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_List" ) );
                return;
            }

            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_List" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            DisplaySecurityOnOff();
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
                    PauseCapableWriteLine( Environment.NewLine + String.Format( manager.GetString( "Dialog_Level" ), currentLevel.Label ) );
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_CodeGroups" ) + Environment.NewLine );
                    DisplayLevelCodeGroups( currentLevel ); 
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_NamedPermissionSets" ) + Environment.NewLine );
                    DisplayLevelPermissionSets( currentLevel );
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_FullTrustAssemblies" ) + Environment.NewLine );
                    DisplayLevelFullTrustAssemblies( currentLevel );
                }
            }
            catch (Exception e)
            {
                Error( manager.GetString( "OptionTable_List" ), e.Message, -1 );
            }

        }
    
        static void ListGroupHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;
    
            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_ListGroups" ) );
                return;
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_ListGroups" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            DisplaySecurityOnOff();
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
                    PauseCapableWriteLine( Environment.NewLine + String.Format( manager.GetString( "Dialog_Level" ), currentLevel.Label ) );
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_CodeGroups" ) + Environment.NewLine );
                    DisplayLevelCodeGroups( currentLevel ); 
                }
            }
            catch (Exception e)
            {
                Error( manager.GetString( "OptionTable_ListGroups" ), e.Message, -1 );
            }
        }
    
        static void ListPermHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;
    
            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_ListPSet" ) );
                return;
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_ListPset" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            DisplaySecurityOnOff();
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
                    PauseCapableWriteLine( Environment.NewLine + String.Format( manager.GetString( "Dialog_Level" ), currentLevel.Label ) );
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_NamedPermissionSets" ) + Environment.NewLine );
                    DisplayLevelPermissionSets( currentLevel );
                }
            }
            catch (Exception e)
            {
                Error( manager.GetString( "OptionTable_ListPset" ), e.Message, -1 );
            }
        }
    
        static void ListFullTrustHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;
    
            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_ListFullTrust" ) );
                return;
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_ListFullTrust" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            DisplaySecurityOnOff();
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
                    PauseCapableWriteLine( Environment.NewLine + String.Format( manager.GetString( "Dialog_Level" ), currentLevel.Label ) );
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_FullTrustAssemblies" ) + Environment.NewLine );
                    DisplayLevelFullTrustAssemblies( currentLevel );
                }
            }
            catch (Exception e)
            {
                Error( manager.GetString( "OptionTable_ListFullTrust" ), e.Message, -1 );
            }

        }


        static void ListDescriptionHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;
    
            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_ListDescription" ) );
                return;
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null && m_levelType == LevelType.All)
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_ListDescription" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            DisplaySecurityOnOff();
        
            try
            {
                while (levelEnumerator.MoveNext())
                {
                    PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
                    PauseCapableWriteLine( Environment.NewLine + String.Format( manager.GetString( "Dialog_Level" ), currentLevel.Label ) );
                    PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_FullTrustAssemblies" ) + Environment.NewLine );
                    DisplayLevelCodeGroupNameDescriptions( currentLevel );
                }
            }
            catch (Exception e)
            {
                Error( manager.GetString( "OptionTable_ListDescription" ), e.Message, -1 );
            }

        }
   
        static void ListCodeGroup( String prefix, String indent, IEnumerator dispEnumerator, IEnumerator rootEnumerator )
        {
            if (dispEnumerator == null)
                return;
        
            int count = 0;
            CodeGroup rootGroup = null;
        
            while (dispEnumerator.MoveNext())
            {
                CodeGroup group = (CodeGroup)dispEnumerator.Current;

                if(rootEnumerator == null)
                    ++count;
                else
                {
                    do
                    {
                        if(!rootEnumerator.MoveNext())
                            Error( manager.GetString( "OptionTable_ResolveGroup" ), manager.GetString( "Error_CodeGroup_NoMatch" ), -1 );
                        rootGroup = (CodeGroup)rootEnumerator.Current;
                        ++count;
                    } while (!rootGroup.Equals( group ));
                }

                String label = prefix + "." + count;
            
                PauseCapableWriteLine( indent + label + ".  " +
                    (group.MergeLogic.Equals( manager.GetString( "Misc_MergeUnion" ) ) ? "" : ("(" + group.MergeLogic + ") ")) +
                    (group.MembershipCondition == null ? group.GetType().FullName : group.MembershipCondition.ToString()) +
                    ": " +
                    (group.PermissionSetName == null ? manager.GetString( "Dialog_Unknown" ) : group.PermissionSetName) +
                    ( group.AttributeString == null ||
                      group.AttributeString.Equals( "" ) ? "" :
                    " (" + group.AttributeString + ")" ) );
                
                if(rootEnumerator == null)
                    ListCodeGroup( label, indent + m_indent, group.Children.GetEnumerator(), null );
                else
                    ListCodeGroup( label, indent + m_indent, group.Children.GetEnumerator(), rootGroup.Children.GetEnumerator() );
            }
        }
    
        static void ListCodeGroupNameDescription( String prefix, String indent, IEnumerator enumerator )
        {
            if (enumerator == null)
                return;
        
            int count = 1;
        
            while (enumerator.MoveNext())
            {
                String label = prefix + "." + count;
                CodeGroup group = (CodeGroup)enumerator.Current;
            
                PauseCapableWriteLine(
                    indent + 
                    label + ". " +
                    (group.Name != null && !group.Name.Equals( "" ) ? group.Name : "@@No label@@") +
                    ": " +
                    (group.Description != null && !group.Description.Equals( "" ) ? group.Description : "@@No description@@") );                
                
                ListCodeGroupNameDescription( label, indent + m_indent, group.Children.GetEnumerator() );
            
                ++count;
            }
        }
    

        static void AddPermHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_AddPSet" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_AddPset" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_AddPset" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_AddPset" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            NamedPermissionSet permSet = null;
        
            try
            {
                permSet = GetPermissionSet( args, index + 1 );
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
                }

                Error( manager.GetString( "OptionTable_AddPset" ), message, -1 );
            }
        
            IEnumerator enumerator = permSet.GetEnumerator();

            while (enumerator.MoveNext())
            {
                m_levelAssemblyList.Add( enumerator.Current.GetType().Module.Assembly );
            }

            // Detect whether there is a provided name.
        
            if (args.Length - index > 2)
            {
                // Check to make sure it's not just someone putting another option on the command line.
        
                bool isOption = false;
        
                for (int i = 0; i < optionTable.Length; ++i)
                {
                    if (String.Compare( optionTable[i].option, args[index + 2], true, CultureInfo.InvariantCulture) == 0)
                    {
                        isOption = true;
                        break;
                    }
                }
            
                if (!isOption)
                {
                    permSet.Name = args[index+2];
                    numArgsUsed = 3;
                }
            }
        
            if (permSet.Name == null || permSet.Name.Equals( "" ))
            {
                Error( manager.GetString( "OptionTable_AddPset" ), manager.GetString( "Error_PermSet_NoName" ), -1 );
            }
        
            try
            {
                level.AddNamedPermissionSet( permSet );
            }
            catch (Exception)
            {
                Error( manager.GetString( "OptionTable_AddPset" ), manager.GetString( "Error_PermSet_AlreadyExist" ), -1 );
                return;
            }
        
            SafeSavePolicy();
        }
    
        static void AddFullTrustHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_AddFullTrust" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_AddFullTrust" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_AddFullTrust" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_AddFullTrust" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            Assembly assembly = LoadAssembly( args[index + 1], manager.GetString( "OptionTable_AddFullTrust" ) );
        
            if (assembly == null)
            {
                Error( manager.GetString( "OptionTable_AddFullTrust" ), manager.GetString( "Error_UnableToLoadAssembly" ), -1 );
            }

            StrongName sn = FindStrongName( assembly.Evidence );

            if (sn == null)
            {
                Error( manager.GetString( "OptionTable_AddFullTrust" ), manager.GetString( "Error_NotStrongNamed" ), -1 );
            }

            try
            {
                level.AddFullTrustAssembly( sn );
            }
            catch (Exception)
            {
                Error( manager.GetString( "OptionTable_AddFullTrust" ), manager.GetString( "Error_FullTrust_AlreadyFullTrust" ), -1 );
            }
        
            SafeSavePolicy();
        }

        static void ChgPermHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_ChgPSet" ) );
                return;
            }

            numArgsUsed = 3;

            if (args.Length - index < 3)
            {
                Error( manager.GetString( "OptionTable_ChgPSet" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_ChgPSet" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_ChgPSet" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            NamedPermissionSet permSet = null;
        
            try
            {
                permSet = GetPermissionSet( args, index + 1 );
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
            }
        
                Error( manager.GetString( "OptionTable_ChgPSet" ), message, -1 );
            }
        
            try
            {
                level.ChangeNamedPermissionSet( args[index+2], permSet );
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
            }            
        
                Error( manager.GetString( "OptionTable_ChgPSet" ), message, -1 );
            }            
        
            SafeSavePolicy();
        }        
    
        static void RemPermHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_RemPSet" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_RemPSet" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_RemPSet" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_RemPSet" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            PermissionSet removedSet = null;
        
            try
            {
                removedSet = level.RemoveNamedPermissionSet( args[index+1] );
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
            }
        
                Error( manager.GetString( "OptionTable_RemPSet" ), message, -1 );
            }
        
            if (removedSet != null)
            {
                SafeSavePolicy();
            }
            else
            {
                Error( manager.GetString( "OptionTable_RemPSet" ), String.Format( manager.GetString( "Error_PermSet_DoesNotExist" ), args[index+1] ), -1 );
            }
        }

        static void RemFullTrustHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_RemFullTrust" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_RemFullTrust" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_RemFullTrust" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_RemFullTrust" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            Assembly assembly = LoadAssembly( args[index+1], manager.GetString( "OptionTable_RemFullTrust" ) );

            if (assembly == null)
            {
                Error( manager.GetString( "OptionTable_RemFullTrust" ), manager.GetString( "Error_UnableToLoadAssembly" ), -1 );
            }
        
            StrongName sn = FindStrongName( assembly.Evidence );

            if (sn == null)
            {
                Error( manager.GetString( "OptionTable_RemFullTrust" ), manager.GetString( "Error_NotStrongNamed" ), -1 );
            }

            try
            {
                level.RemoveFullTrustAssembly( sn );
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
                }

                Error( manager.GetString( "OptionTable_RemFullTrust" ), message, -1 );
            }
        
            SafeSavePolicy();
        }

    
        static void RemGroupHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_RemGroup" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            Object removeValue = null;
            Object parentValue = null;
        
            try
            {
                removeValue = GetLabel( args[index+1] );
            }
            catch (Exception e)
            {
                if (e is SecurityException)
                    Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_PolicyPermissionDenied" ), -1 );
                else        
                    Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
        
            if (removeValue == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_RemGroup" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
       
            if (!(removeValue is CodeGroup))
            {
                Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_CodeGroup_MustBeCodeGroup" ), -1 );
                return;
            }

            String parentLabel = ParentLabel( args[index+1] );
        
            try
            {
                parentValue = GetLabel( parentLabel );
            }
            catch (Exception)
            {
                Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
        
            if (parentValue == null)
            {
                Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
       
            if (!(parentValue is CodeGroup))
            {
                Error( manager.GetString( "OptionTable_RemGroup" ), manager.GetString( "Error_CodeGroup_MustBeCodeGroup" ), -1 );
                return;
            }      
        
            PolicyLevel level = GetLevel();
            String numericLabel = null;
            Object group = GetLabelByName( args[index+1], level.RootCodeGroup, ref numericLabel );

            if (group == null || numericLabel == null)
            {
                numericLabel = args[index+1];
            }

            String[] splitLabel = numericLabel.Split( '.' );
            int indexToSkip;
            
            if (splitLabel[splitLabel.Length-1] != null && splitLabel[splitLabel.Length-1].Length != 0)
                indexToSkip = Int32.Parse( splitLabel[splitLabel.Length-1] );
            else
                indexToSkip = Int32.Parse( splitLabel[splitLabel.Length-2] );

            IEnumerator enumerator = ((CodeGroup)parentValue).Children.GetEnumerator();

            ((CodeGroup)parentValue).Children = new ArrayList();
            int count = 1;

            while (enumerator.MoveNext())
            {
                if (count != indexToSkip)
                    ((CodeGroup)parentValue).AddChild( (CodeGroup)enumerator.Current );
                count++;
            }

            ReplaceLabel( parentLabel, (CodeGroup)parentValue );

            SafeSavePolicy();
        
            PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_RemovedCodeGroup" ), GetLevel().Label ) );        
        
        }
    
        static void AddGroupHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_AddGroup" ) );
                return;
            }
        
            numArgsUsed = 2;

            if (args.Length - index < 4) 
            {
                Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }
        
            Object parentValue = null;

            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_AddGroup" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            try
            {
                parentValue = GetLabel( args[index+1] );
            }
            catch (Exception e)
            {
                if (e is SecurityException)
                    Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_PolicyPermissionDenied" ), -1 );
                else        
                    Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
        
            if (parentValue == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_AddGroup" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
       
            if (!(parentValue is CodeGroup))
            {
                Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_CodeGroup_MustBeCodeGroup" ), -1 );
                return;
            }
        
            int offset = 0, exlOffset = 0;
        
            IMembershipCondition mship = CreateMembershipCondition( level, args, index+2, out offset );
        
            if (args.Length <= index + 2 + offset)
            {
                Error( manager.GetString( "OptionTable_AddGroup" ), manager.GetString( "Error_CodeGroup_NoPermissionSet" ), -1 );
                return;
            }

            CodeGroup newGroup = null;

            try
            {
                newGroup = new UnionCodeGroup( mship, new PolicyStatement( GetPermissionSet( level, args[index + 2 + offset] ), PolicyStatementAttribute.Nothing ) );

                PolicyStatement statement = newGroup.PolicyStatement;

                statement.Attributes = IsExclusive( newGroup, args, index + 3 + offset, out exlOffset );

                newGroup.PolicyStatement = statement;
            }
            catch (Exception e)
            {
                String message = e.Message;

                if (message == null || message.Equals( "" ))
                {
                    message = e.GetType().AssemblyQualifiedName;
                }

                Error( manager.GetString( "OptionTable_AddGroup" ), message, -1 );
            }

            ((CodeGroup)parentValue).AddChild( newGroup );
            ReplaceLabel( args[index+1], (CodeGroup)parentValue );

            SafeSavePolicy();
        
            PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_AddedCodeGroup" ), args[index+2], level.Label ) );        
        
            numArgsUsed = offset + exlOffset + 3;
        }
    
        static void ChgGroupHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_ChgGroup" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 3)
            {
                Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
                return;
            }        
        
            Object group = null;
        
            PolicyLevel level = GetLevel();
        
            if (level == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_ChgGroup" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }        
            try
            {
                group = GetLabel( args[index+1] );
            }
            catch (Exception e)
            {
                if (e is SecurityException)
                    Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Error_PolicyPermissionDenied" ), -1 );
                else        
                    Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
        
            if (group == null)
            {
                if (m_levelType == LevelType.All || m_levelType == LevelType.AllCustom)
                    Error( manager.GetString( "OptionTable_ChgGroup" ), String.Format( manager.GetString( "Dialog_NotValidWithAll" ), manager.GetString( "OptionTable_All" ) ), -1 );
                else
                    Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Error_InvalidLabel" ), -1 );
                return;
            }
       
            if (!(group is CodeGroup))
            {
                Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Error_CodeGroup_MustBeCodeGroup" ), -1 );
                return;
            }
        
            CodeGroup codeGroup = (CodeGroup)group;
        
            bool foundAtLeastOneMatch = false;
        
            StringBuilder sb = new StringBuilder();
        
            // chggroup can take an arbitrary number of arguments.  To do this,
            // we just iterate through the argument array until we find the
            // end of the array or another option.

            while (true)
            {
                int offset = 0;

                // If we are at the end of argument array, break
            
                if (args.Length - index <= numArgsUsed)
                    break;

                // If we have found another option, break

                int i;

                for (i = 0; i < optionTable.Length; ++i)
                {
                    if (String.Compare( args[index + numArgsUsed], optionTable[i].option, true, CultureInfo.InvariantCulture) == 0)
                        break;
                }

                if (i != optionTable.Length)
                    break;

                // Check to see if we've found a membership condition arg.
        
                IMembershipCondition condition = CreateMembershipConditionNoThrow( level, args, index + numArgsUsed, out offset );
        
                if (condition != null && offset != 0)
                {
                    codeGroup.MembershipCondition = condition;
                    if (foundAtLeastOneMatch)
                        sb.Append( Environment.NewLine );
                    sb.Append( String.Format( manager.GetString( "Dialog_ChangedCodeGroupMembershipCondition" ), args[index+numArgsUsed], level.Label ) );
                    numArgsUsed += offset;        
                    foundAtLeastOneMatch = true;
                
                    continue;
                }

                // Check to see if we've found an attribute arg.
        
                PolicyStatementAttribute attr = PolicyStatementAttribute.Nothing;
        
                attr = IsExclusive( (CodeGroup)group, args, index + numArgsUsed, out offset );

                if (offset != 0)
                {
                    PolicyStatement ps = ((CodeGroup)codeGroup).PolicyStatement;
                    ps.Attributes = attr;
                    ((CodeGroup)codeGroup).PolicyStatement = ps;
                    
                    if (foundAtLeastOneMatch)
                        sb.Append( Environment.NewLine );
                    if (codeGroup.AttributeString == null || codeGroup.AttributeString.Equals( "" ))
                        sb.Append( String.Format( manager.GetString( "Dialog_ChangedCodeGroupAttributes1" ), level.Label ) );   
                    else
                        sb.Append( String.Format( manager.GetString( "Dialog_ChangedCodeGroupAttributes2" ), ((CodeGroup)codeGroup).AttributeString, level.Label ) );
                    numArgsUsed += offset;
                    foundAtLeastOneMatch = true;
                    continue;
                }

                // Check to see if we've found a permission set arg.

                PermissionSet permSet = null;

                try
                {
                    permSet = GetPermissionSet( level, args[index + numArgsUsed] );
                }
                catch (Exception e)
                {
                    String message = e.Message;

                    if (message == null || message.Equals( "" ))
                    {
                        message = e.GetType().AssemblyQualifiedName;
                }
        
                    Error( manager.GetString( "OptionTable_ChgGroup" ), message, -1 );
                }
        
                if (permSet != null)
                {
                    if (codeGroup is UnionCodeGroup)
                    {
                        PolicyStatement ps = ((UnionCodeGroup)codeGroup).PolicyStatement;
                        ps.PermissionSet = permSet;
                        ((UnionCodeGroup)codeGroup).PolicyStatement = ps;
                    }
                    else if (codeGroup is FirstMatchCodeGroup)
                    {
                        PolicyStatement ps = ((FirstMatchCodeGroup)codeGroup).PolicyStatement;
                        ps.PermissionSet = permSet;
                        ((FirstMatchCodeGroup)codeGroup).PolicyStatement = ps;
                    }
                    else
                        Error( manager.GetString( "OptionTable_ChgGroup" ), manager.GetString( "Dialog_BuiltInOnly" ), -1 );
                
                    if (foundAtLeastOneMatch)
                        sb.Append( Environment.NewLine );
                    sb.Append( String.Format( manager.GetString( "Dialog_ChangedCodeGroupPermissionSet" ), args[index+numArgsUsed], level.Label ) );
                
                    numArgsUsed++;
                    foundAtLeastOneMatch = true;
                    continue;
                }
        
                if (!foundAtLeastOneMatch)
                    Error( manager.GetString( "OptionTable_ChgGroup" ), String.Format( manager.GetString( "Error_CodeGroup_UnrecognizedOption" ), args[index + 2] ), -1 );
                else
                    break;
            }
        
            ReplaceLabel( args[index+1], codeGroup );

            SafeSavePolicy();
        
            PauseCapableWriteLine( sb.ToString() );
        }

        static Assembly LoadAssembly( String fileName, String option )
        {
            return LoadAssembly( fileName, option, true );
        }

        static Assembly LoadAssembly( String fileName, String option, bool errorOnFail )
        {
            AppDomain domain = AppDomain.CreateDomain( "Caspol Domain",
                                                       null,
                                                       Environment.CurrentDirectory,
                                                       Thread.GetDomain().BaseDirectory,
                                                       false );

            if (domain == null)
                Error( option, manager.GetString( "Error_UnableToLoadAssembly" ), -1 );
        
            Assembly asm = null;
        
            try
            {
                asm = domain.Load( fileName );
            }
            catch (Exception)
            {
            }
        
            if (asm != null)
                return asm;
            
            try
            {
                asm = Assembly.LoadFrom( fileName );
            }
            catch (Exception)
            {
            }
        
            try
            {
                asm = Assembly.LoadFrom( Environment.CurrentDirectory + "\\" + fileName );
            }
            catch (Exception)
            {
            }

            if (asm != null)
                return asm;

            if (errorOnFail)            
                Error( option, manager.GetString( "Error_UnableToLoadAssembly" ), -1 );

            return null;
        }            
    
        static Evidence GenerateShellEvidence( String fileName, String option )
        {
            Assembly asm = LoadAssembly( fileName, option, false );

            if (asm == null)
            {
                String fullPath = Path.GetFullPath( fileName );

                if (fullPath == null || !File.Exists( fullPath ))
                    Error( option, manager.GetString( "Error_UnableToLoadAssembly" ), -1 );

                    if (PolicyPrompt)
                {
                    PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_UseFakeEvidenceQuestion" ), fileName ) );

                    if (!GetAnswer())
                    {
                        PauseCapableWriteLine( manager.GetString( "Dialog_OperationAborted" ) );
                        throw new ExitException();
                    }
                }
                else
                {
                    PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_UseFakeEvidence" ), fileName ) );
                }

                String fileUrl = "file:///" + fullPath;

                Evidence evidence = new Evidence();
                evidence.AddHost( Zone.CreateFromUrl( fileUrl ) );
                evidence.AddHost( new Url( fileUrl ) );

                return evidence;
            }
            else
            {           
                return asm.Evidence;
            }
        }
    
        static void ResolveGroupHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_ResolveGroup" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_ResolveGroup" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = m_levelType == LevelType.None ? null : GetLevel( m_levelType );
        
            if (level == null && (m_levelType == LevelType.All || m_levelType == LevelType.None))
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_ResolveGroup" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            Evidence evidence = GenerateShellEvidence( args[index+1], manager.GetString( "OptionTable_ResolveGroup" ) );
        
            while (levelEnumerator.MoveNext())
            {
                PauseCapableWriteLine( Environment.NewLine + String.Format( manager.GetString( "Dialog_Level" ), ((PolicyLevel)levelEnumerator.Current).Label ) );
                PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_CodeGroups" ) + Environment.NewLine );
                CodeGroup displayGroup = ((PolicyLevel)levelEnumerator.Current).ResolveMatchingCodeGroups( evidence );
                CodeGroup rootGroup = ((PolicyLevel)levelEnumerator.Current).RootCodeGroup;
                DisplayCodeGroups( displayGroup, rootGroup );
            
                PauseCapableWriteLine( "" );
            }
        
        }
    
        static void ResolvePermHandler( String[] args, int index, out int numArgsUsed )
        {
            if (args[index].Equals( "__internal_usage__" ))
            {
                numArgsUsed = 1;
                PauseCapableWriteLine( manager.GetString( "Help_Option_ResolvePerm" ) );
                return;
            }
        
            numArgsUsed = 2;
        
            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_ResolvePerm" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
        
            IEnumerator levelEnumerator = null;
        
            PolicyLevel level = m_levelType == LevelType.None ? null : GetLevel( m_levelType );
        
            if (level == null && (m_levelType == LevelType.All || m_levelType == LevelType.None))
            {
                levelEnumerator = SecurityManager.PolicyHierarchy();
            }
            else if (level == null && m_levelType == LevelType.AllCustom)
            {
                ArrayList list = new ArrayList();
                list.Add( GetLevel( "Enterprise" ) );
                list.Add( GetLevel( "Machine" ) );
                list.Add( m_currentCustomLevel );
                levelEnumerator = list.GetEnumerator();
            }
            else if (level != null)
            {
                ArrayList list = new ArrayList();
                list.Add( level );
                levelEnumerator = list.GetEnumerator();
            }
        
            if (levelEnumerator == null)
            {
                Error( manager.GetString( "OptionTable_ResolvePerm" ), manager.GetString( "Error_UnableToRetrieveLevel" ), -1 );
            }
        
            Evidence evidence = GenerateShellEvidence( args[index+1], manager.GetString( "OptionTable_ResolvePerm" ) );
        
            PermissionSet grant = null;
        
            while (levelEnumerator.MoveNext())
            {
                PauseCapableWriteLine( "Resolving permissions for level = " + ((PolicyLevel)levelEnumerator.Current).Label );
            
                PolicyStatement policy = ((PolicyLevel)levelEnumerator.Current).Resolve( evidence );
            
                if (policy != null)
                {
                    if (grant == null)
                        grant = policy.PermissionSet;
                    else
                        grant = grant.Intersect( policy.PermissionSet );

                    if (grant == null)
                        grant = new PermissionSet( PermissionState.None );

                    if (policy.Attributes == PolicyStatementAttribute.LevelFinal)
                        break;
                }
                else
                    grant = new PermissionSet( PermissionState.None );
            }

            IEnumerator evidenceEnumerator = evidence.GetEnumerator();
            while (evidenceEnumerator.MoveNext())
            {
                try
                {
                    Object obj = evidenceEnumerator.Current;
                    IIdentityPermissionFactory factory = obj as IIdentityPermissionFactory;
                    if (factory != null)
                    {
                        IPermission perm = factory.CreateIdentityPermission( evidence );
                    
                        if (perm != null)
                        {
                            grant.AddPermission( perm );
                        }
                    }
                }
                catch (Exception)
                {
                    // TODO: report an error?
                }
            }


            PauseCapableWriteLine( Environment.NewLine + manager.GetString( "Dialog_Grant" ) + Environment.NewLine + grant.ToString() );
        
        }

        static SecurityElement ReadXmlFile( String[] args, int index )
        {
            FileStream f;

            try
            {
                f = new FileStream(args[index], FileMode.Open, FileAccess.Read);
            }
            catch (Exception)
            {
                throw new Exception( manager.GetString( "Error_File_UnableToOpenFile" ) );
            }

            // Do the actual decode.
        
            Encoding[] encodings = new Encoding[] { Encoding.UTF8, Encoding.ASCII, Encoding.Unicode };

            bool success = false;
            Exception exception = null;
            Parser parser = null;

            for (int i = 0; !success && i < encodings.Length; ++i)
            {

                try
                {
                    f.Position = 0;

                    StreamReader reader = new StreamReader( f, encodings[i], true );
                    parser = new Parser( reader );
                    success = true;
                }
                catch (Exception e1)
                {
                    if (exception == null)
                        exception = e1;
                }
            }

            f.Close();

            if (!success)
            {
                throw exception;
            }

            return parser.GetTopElement();
        }        
    
        static NamedPermissionSet GetPermissionSet(String[] args, int index)
        {
            // Create named permission set with "no name" since you have to give it a name.
            NamedPermissionSet p = new NamedPermissionSet( "@@no name@@" );

            p.FromXml( ReadXmlFile( args, index ) );

            return p;
        }

   
        static NamedPermissionSet GetPermissionSet( PolicyLevel level, String name )
        {
            NamedPermissionSet permSet = level.GetNamedPermissionSet( name );
            if (permSet == null)
            {
                throw new ArgumentException( String.Format( manager.GetString( "Error_UnknownPermissionSet" ), name ) );
            }
            return permSet;
        }

    }    

    internal class OptionTableEntry
    {
        public OptionTableEntry( String option, OptionHandler handler, String sameAs, bool list )
        {
            this.option = option;
            this.handler = handler;
            this.sameAs = sameAs;
            this.list = list;
            this.displayMShip = false;
        }

        public OptionTableEntry( String option, OptionHandler handler, String sameAs, bool list, bool displayMShip )
        {
            this.option = option;
            this.handler = handler;
            this.sameAs = sameAs;
            this.list = list;
            this.displayMShip = displayMShip;
        }
   
        
        internal String option;
        internal OptionHandler handler;
        internal String sameAs;
        internal bool list;
        internal bool displayMShip;
    }

    internal class MembershipConditionTableEntry
    {
        public MembershipConditionTableEntry( String option, MembershipConditionHandler handler )
        {
            this.option = option;
            this.handler = handler;
        }
        
        internal String option;
        internal MembershipConditionHandler handler;
    }

    internal class CodeGroupAttributeTableEntry
    {
        public CodeGroupAttributeTableEntry( String label, PolicyStatementAttribute value, String description )
        {
            this.label = label;
            this.value = value;
            this.description = description;
            this.display = true;
            this.handler = null;
        }

        public CodeGroupAttributeTableEntry( String label, CodeGroupAttributeHandler handler, bool display )
        {
            this.label = label;
            this.handler = handler;
            this.display = display;
            this.description = null;
        }
    
        internal String label;
        internal bool display;
        internal PolicyStatementAttribute value;
        internal String description;
        internal CodeGroupAttributeHandler handler;
    }

    class ExitException : Exception
    {
    }

    internal enum SecurityElementType
    {
        Regular = 0,
        Format = 1,
        Comment = 2
    }


    sealed internal class Parser
    {
        private SecurityElement   _ecurr = null ;
        private Tokenizer _t     = null ;
    
        public SecurityElement GetTopElement()
        {
            return (SecurityElement)_ecurr.Children[0];
        }

        public Encoding GetEncoding()
        {
            return _t.GetEncoding();
        }
    
        private void ParseContents (SecurityElement e, bool restarted)
        {
            //
            // Iteratively collect stuff up until the next end-tag.
            // We've already seen the open-tag.
            //

            SecurityElementType lastType = SecurityElementType.Regular;

            ParserStack stack = new ParserStack();
            ParserStackFrame firstFrame = new ParserStackFrame();
            firstFrame.element = e;
            firstFrame.intag = false;
            stack.Push( firstFrame );
            
            bool needToBreak = false;
            bool needToPop = false;
            
            int i;

            do
            {
                ParserStackFrame locFrame = stack.Peek();
                
                for (i = _t.NextTokenType () ; i != -1 ; i = _t.NextTokenType ())
                {
                    switch (i)
                    {
                    case Tokenizer.cstr:
                        {
                            if (locFrame.intag)
                            {
                                if (locFrame.type == SecurityElementType.Comment)
                                {
                                    String appendString;

                                    if (locFrame.sawEquals)
                                    {
                                        appendString = "=\"" + _t.GetStringToken() + "\"";
                                        locFrame.sawEquals = false;
                                    }
                                    else
                                    {
                                        appendString = " " + _t.GetStringToken();
                                    }

                                    // Always set this directly since comments are not subjected
                                    // to the same restraints as other element types.  The strings
                                    // are all escaped so this shouldn't be a problem.

                                    locFrame.element.Tag = locFrame.element.Tag + appendString;
                                }
                                else
                                {
                                    // We're in a regular tag, so we've found an attribute/value pair.
                                
                                    if (locFrame.strValue == null)
                                    {
                                        // Found attribute name, save it for later.
                                    
                                        locFrame.strValue = _t.GetStringToken ();
                                    }
                                    else
                                    {
                                        // Found attribute text, add the pair to the current element.

                                        if (!locFrame.sawEquals)
                                            throw new XmlSyntaxException( _t.LineNo );

                                        locFrame.element.AddAttribute( locFrame.strValue, _t.GetStringToken() );

                                        locFrame.strValue = null;
                                    }
                                }
                            }
                            else
                            {
                                // We're not in a tag, so we've found text between tags.
                                
                                if (locFrame.element.Text == null)
                                    locFrame.element.Text = "" ;
    
                                StringBuilder sb = new StringBuilder (locFrame.element.Text) ;
    
                                //
                                // Separate tokens with single spaces, collapsing whitespace
                                //
                                if (!locFrame.element.Text.Equals (""))
                                    sb.Append (" ") ;
                            
                                sb.Append (_t.GetStringToken ()) ;
                                locFrame.element.Text = sb.ToString ();
                            }
                        }
                        break ;
        
                    case Tokenizer.bra:
                        locFrame.intag = true;
                        i = _t.NextTokenType () ;
    
                        if (i == Tokenizer.slash)
                        {
                            while (true)
                            {
                                // spin; don't care what's in here
                                i = _t.NextTokenType();
                                if (i == Tokenizer.cstr)
                                    continue;
                                else if (i == -1)
                                    throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_UnexpectedEndOfFile" ));
                                else
                                    break;
                            }
        
                            if (i != Tokenizer.ket)
                            {
                                    throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                            }
         
                            locFrame.intag = false;
         
                            // Found the end of this element
                            lastType = stack.Peek().type;
                            stack.Pop();
                            
                            needToBreak = true;

                        }
                        else if (i == Tokenizer.cstr)
                        {
                            // Found a child
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement (_t.GetStringToken() );
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.bang)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            ParserStackFrame newFrame = new ParserStackFrame();
        
                            newFrame.status = 1;

                            do
                            {
                                i = _t.NextTokenType();

                                if (newFrame.status < 3)
                                {
                                    if (i != Tokenizer.dash)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        newFrame.status++;
                                }
                                else
                                {
                                    if (i != Tokenizer.cstr)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        break;
                                }
                            }
                            while (true);                                    

                            
                            newFrame.element = new SecurityElement (_t.GetStringToken());

                            newFrame.type = SecurityElementType.Comment;
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.quest)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            i = _t.NextTokenType();

                            if (i != Tokenizer.cstr)
                                throw new XmlSyntaxException( _t.LineNo );
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement ( _t.GetStringToken());

                            newFrame.type = SecurityElementType.Format;
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            newFrame.status = 1;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else   
                        {
                            throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_ExpectedSlashOrString" ));
                        }
                        break ;
        
                    case Tokenizer.equals:
                        locFrame.sawEquals = true;
                        break;
                        
                    case Tokenizer.ket:
                        if (locFrame.intag)
                        {
                            locFrame.intag = false;
                            continue;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_UnexpectedCloseBracket" ));
                        }
                        // not reachable
                        
                    case Tokenizer.slash:
                        locFrame.element.Text = null;
                        
                        i = _t.NextTokenType ();
                        
                        if (i == Tokenizer.ket)
                        {
                            // Found the end of this element
                            lastType = stack.Peek().type;
                            stack.Pop();
                            
                            needToBreak = true;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                        }
                        break;
                        
                    case Tokenizer.quest:
                        if (locFrame.intag && locFrame.type == SecurityElementType.Format && locFrame.status == 1)
                        {
                            i = _t.NextTokenType ();

                            if (i == Tokenizer.ket)
                            {
                                lastType = stack.Peek().type;
                                stack.Pop();

                                needToBreak = true;
                            }
                            else
                            {
                                throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    case Tokenizer.dash:
                        if (locFrame.intag && (locFrame.status > 0 && locFrame.status < 5) && locFrame.type == SecurityElementType.Comment)
                        {
                            locFrame.status++;

                            if (locFrame.status == 5)
                            {
                                i = _t.NextTokenType ();

                                if (i == Tokenizer.ket)
                                {
                                    lastType = stack.Peek().type;
                                    stack.Pop();

                                    needToBreak = true;
                                }
                                else
                                {
                                    throw new XmlSyntaxException (_t.LineNo, caspol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                                }
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    default:
                        throw new XmlSyntaxException (_t.LineNo) ;
                    }
                    
                    if (needToBreak)
                    {
                        needToBreak = false;
                        needToPop = false;
                        break;
                    }
                    else
                    {
                        needToPop = true;
                    }
                }
                if (needToPop)
                {
                    lastType = stack.Peek().type;
                    stack.Pop();
                }
                else if (i == -1 && stack.GetCount() != 1)
                {
                    // This means that we still have items on the stack, but the end of our
                    // stream has been reached.

                    throw new XmlSyntaxException( _t.LineNo, caspol.manager.GetString( "XMLSyntax_UnexpectedEndOfFile" ));
                }
            }
            while (stack.GetCount() > 1);

            SecurityElement topElement = this.GetTopElement();

            if (lastType == SecurityElementType.Format)
            {
                if (restarted)
                    throw new XmlSyntaxException( _t.LineNo );

                String format = topElement.Attribute( "encoding" );

                if (format != null)
                {
                    _t.ChangeFormat( System.Text.Encoding.GetEncoding( format ) );
                }

                _ecurr = new SecurityElement( "junk" );
                ParseContents( _ecurr, true );
            }

            
        }
    
        private Parser(Tokenizer t)
        {
            _t = t;
            _ecurr       = new SecurityElement( "junk" );

            ParseContents (_ecurr, false) ;
        }
        
        public Parser (String input)
            : this (new Tokenizer (input))
        {
        }
    
        public Parser (BinaryReader input)
            : this (new Tokenizer (input))
        {
        }
       
        public Parser( byte[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
        public Parser( StreamReader input )
            : this (new Tokenizer( input ) )
        {
        }
        
        public Parser( Stream input )
            : this (new Tokenizer( input ) )
        {
        }
        
        public Parser( char[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
    }                                              
    
    
    internal class ParserStackFrame
    {
        internal SecurityElement element = null;
        internal bool intag = true;
        internal String strValue = null;
        internal int status = 0;
        internal bool sawEquals = false;
        internal SecurityElementType type = SecurityElementType.Regular;
    }
    
    
    internal class ParserStack
    {
        private ArrayList m_array;
        
        public ParserStack()
        {
            m_array = new ArrayList();
        }
        
        public void Push( ParserStackFrame element )
        {
            m_array.Add( element );
        }
        
        public ParserStackFrame Pop()
        {
            if (!IsEmpty())
            {
                int count = m_array.Count;
                ParserStackFrame temp = (ParserStackFrame) m_array[count-1];
                m_array.RemoveAt( count-1 );
                return temp;
            }
            else
            {
                throw new InvalidOperationException( caspol.manager.GetString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        public ParserStackFrame Peek()
        {
            if (!IsEmpty())
            {
                return (ParserStackFrame) m_array[m_array.Count-1];
            }
            else
            {
                throw new InvalidOperationException( caspol.manager.GetString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        public bool IsEmpty()
        {
            return m_array.Count == 0;
        }
        
        public int GetCount()
        {
            return m_array.Count;
        }
        
    }


    internal class Tokenizer 
    {
        private ITokenReader         _input;
        private bool             _fintag;
        private StringBuilder       _cstr;
        private char[]              _sbarray;
        private int                 _sbindex;
        private const int          _sbmaxsize = 128;
    
        // There are five externally knowable token types: bras, kets,
        // slashes, cstrs, and equals.  
    
        internal const int bra     = 0;
        internal const int ket     = 1;
        internal const int slash   = 2;
        internal const int cstr    = 3;
        internal const int equals  = 4;
        internal const int quest   = 5;
        internal const int bang    = 6;
        internal const int dash    = 7;

        internal const int intOpenBracket = (int) '<';
        internal const int intCloseBracket = (int) '>';
        internal const int intSlash = (int) '/';
        internal const int intEquals = (int) '=';
        internal const int intQuote = (int) '\"';
        internal const int intQuest = (int) '?';
        internal const int intBang = (int) '!';
        internal const int intDash = (int) '-';
    
        public int  LineNo;
    
        //================================================================
        // Constructor uses given ICharInputStream
        //

        internal Tokenizer (String input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StringTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        

        internal Tokenizer (BinaryReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new TokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (byte[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new ByteTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (char[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new CharTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        
        
        internal Tokenizer (StreamReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }
    
        internal Tokenizer (Stream input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(new StreamReader( input )) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }


        internal void ChangeFormat( System.Text.Encoding encoding )
        {
            if (encoding == null)
            {
                return;
            }

            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return;
            }

            Stream stream = reader._in.BaseStream;

            String fakeReadString = new String( new char[reader.NumCharEncountered] );

            stream.Position = reader._in.CurrentEncoding.GetByteCount( fakeReadString );

            _input = new StreamTokenReader( new StreamReader( stream, encoding ) );
        }

        internal System.Text.Encoding GetEncoding()
        {
            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return null;
            }
            
            return reader._in.CurrentEncoding;
        }

   
        //================================================================
        // 
        //
        private bool FIsWhite (int j)
        {
            if ((j == 10) && (_input.Peek() != -1))
                LineNo ++ ;
    
            bool retval =  (j == 32) || (j ==  9)  // Space and tab
                        || (j == 13) || (j == 10); // CR and LF
         
            return retval;
                
        }
    
        //================================================================
        // Parser needs to know types of tokens
        //
        private void SBArrayAppend(char c) {
            // this is the common case
            if (_sbindex != _sbmaxsize) {
                _sbarray[_sbindex] = c;
                _sbindex++;
                return;
            } 
            // OK, first check if we have to init the StringBuilder
            if (_cstr == null) {
                _cstr = new StringBuilder();
            }
            // OK, copy from _sbarray to _cstr
            _cstr.Append(_sbarray,0,_sbmaxsize);
            // reset _sbarray pointer
            _sbarray[0] = c;
            _sbindex = 1;
            return;
        }
        
        internal int NextTokenType()
        {
            _cstr = null;
            _sbindex = 0;
            int i;
            
            i = _input.Read();
        BEGINNING_AFTER_READ:            
        
            switch (i)
            {
            case -1:
                return -1;
                
            case intOpenBracket:
                _fintag = true;
                return bra;
                
            case intCloseBracket:
                _fintag = false;
                return ket;
                
            case intEquals:
                return equals;
                
            case intSlash:
                if (_fintag) return slash;
                goto default;

            case intQuest:
                if (_fintag) return quest;
                goto default;

            case intBang:
                if (_fintag) return bang;
                goto default;

            case intDash:
                if (_fintag) return dash;
                goto default;
                
            default:
                // We either have a string or whitespace.
                if (FIsWhite( i ))
                {
                    do
                    {
                        i = _input.Read();
                    } while (FIsWhite( i ));
                    
                    goto BEGINNING_AFTER_READ;
                }
                else
                {
                    // The first and last characters in a string can be quotes.
                    
                    bool inQuotedString = false;

                    if (i == intQuote)
                    {
                        inQuotedString = true;
                        i = _input.Read();

                        if (i == intQuote)
                            return cstr;
                    }

                    do
                    {
                        SBArrayAppend( (char)i );
                        i = _input.Peek();
                        if (!inQuotedString && (FIsWhite( i ) || i == intOpenBracket || (_fintag && (i == intCloseBracket || i == intEquals || i == intSlash))))
                            break;
                        _input.Read();
                        if (i == intQuote && inQuotedString)
                            break;
                        if (i == -1)
                            return -1;
                    } while (true);
                    
                    return cstr;
                }
            }
            
        }
        

        //================================================================
        //
        //
        
        internal String GetStringToken ()
        {
            // OK, easy case first, _cstr == null
            if (_cstr == null) {
                // degenerate case
                if (_sbindex == 0) return("");
                return(new String(_sbarray,0,_sbindex));
            }
            // OK, now we know we have a StringBuilder already, so just append chars
            _cstr.Append(_sbarray,0,_sbindex);
            return(_cstr.ToString());
        }
    
        internal interface ITokenReader
        {
            int Peek();
            int Read();
        }
    
        internal class ByteTokenReader : ITokenReader {
            private byte[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal ByteTokenReader( byte[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }

        internal class StringTokenReader : ITokenReader {
            private String _input;
            private int _currentIndex;
            private int _inputSize;
            
            internal StringTokenReader( String input )
            {
                _input = input;
                _currentIndex = 0;
                _inputSize = input.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex++];
                }
            }
        } 
        
        internal class CharTokenReader : ITokenReader {
            private char[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal CharTokenReader( char[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }        
                
        internal class TokenReader : ITokenReader {
    
            private BinaryReader _in;
    
            internal TokenReader(BinaryReader input) {
                _in = input;
            }
    
            public virtual int Peek() {
                return _in.PeekChar();
            }
    
            public virtual int Read() {
                return _in.Read();
            }
        }
        
        internal class StreamTokenReader : ITokenReader {
            
            internal StreamReader _in;
            internal int _numCharRead;
            
            internal StreamTokenReader(StreamReader input) {
                _in = input;
                _numCharRead = 0;
            }
            
            public virtual int Peek() {
                return _in.Peek();
            }
            
            public virtual int Read() {
                int value = _in.Read();
                if (value != -1)
                    _numCharRead++;
                return value;
            }

            internal int NumCharEncountered
            {
                get
                {
                    return _numCharRead;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedprocessenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for Processes. */
  internal class DebuggedProcessEnumerator : 
    IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugProcessEnum m_enum;
    private DebuggedProcess m_proc;

    internal DebuggedProcessEnumerator (ICorDebugProcessEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new DebuggedProcessEnumerator ((ICorDebugProcessEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugProcess[] a = new ICorDebugProcess[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_proc = new DebuggedProcess (a[0]);
      else
        m_proc = null;
      return m_proc != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_proc = null;}

    public Object Current
      {get {return m_proc;}}
    } /* class ProcessEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedprocess.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using CORDBLib;

namespace Debugging
  {
  /** A process running some managed code. */
  public class DebuggedProcess : Controller
    {
    internal DebuggedProcess (ICorDebugProcess proc)
      : base (proc)
      {}

    private ICorDebugProcess _p ()
      {return (ICorDebugProcess) GetController();}

    /** The OS ID of the process. */
    public int Id
      {
      get
        {
        uint id = 0;
        _p().GetID (out id);
        return (int) id;
        }
      }

    /** Returns a handle to the process. */
    public int Handle
      {
      get
        {
        uint h = 0;
        _p().GetHandle (out h);
        return (int) h;
        }
      }

    /** All managed objects in the process. */
    public IEnumerable Objects
      {
      get
        {
        ICorDebugObjectEnum eobj = null;
        _p().EnumerateObjects (out eobj);
        return new DebuggedObjectEnumerator (eobj);
        }
      }

    /** Is the address inside a transition stub? */
    public bool IsTransitionStub (ulong address)
      {
      int y = 0;
      _p().IsTransitionStub (address, out y);
      return !(y==0);
      }

    /** Has the thead been susbended? */
    public bool IsOSSuspended (int tid)
      {
      int y = 0;
      _p().IsOSSuspended ((uint) tid, out y);
      return !(y==0);
      }


    /** Get the context for the given thread. */
    /*
     * This should return a CONTEXT object or something.  Raw bytes are bad.
    public byte[] GetThreadContext (uint tid);
     */

    /** Set the context for a given thread. */
    /* Need to know what a CONTEXT is.
    public void SetThreadContext (uint tid, CONTEXT ctx);
     */

    /** Read memory from the process. */
    public int ReadMemory (long address, int sz, byte[] buf)
      {
      uint read = 0;
      _p().ReadMemory ((ulong) address, (uint) sz, buf, out read);
      return (int) read;
      }

    /** Write memory in the process. */
    public int WriteMemory (long address, int sz, byte[] buf)
      {
      uint written = 0;
      _p().WriteMemory ((ulong) address, (uint) sz, buf, out written);
      return (int) written;
      }

    /** Clear the current unmanaged exception on the given thread. */
    public void ClearCurrentException (int tid)
      {
      _p().ClearCurrentException ((uint) tid);
      }

    /** enable/disable sending of log messages to the debugger for logging. */
    public void EnableLogMessages (bool f)
      {
      _p().EnableLogMessages (f ? 1 : 0);
      }

    public void EnableLogMessages ()
      {EnableLogMessages (true);}
    public void DisableLogMessages ()
      {EnableLogMessages (false);}

    /** Modify the specified switches severity level */
    public void ModifyLogSwitch (String name, int level)
      {
#if I_DONT_WANT_TO
      // name needs to be null-terminated, hence the padding
      _p().ModifyLogSwitch (
        name.PadRight (name.Length, '\0').ToCharArray(), 
        level);
#else
      short c = (short) name[0];
      _p().ModifyLogSwitch (
        ref c,
        level);
#endif
      }

    /** All appdomains in the process. */
    public IEnumerable AppDomains
      {
      get
        {
        ICorDebugAppDomainEnum ead = null;
        _p().EnumerateAppDomains (out ead);
        return new DebuggedAppDomainEnumerator (ead);
        }
      }

    /** Get the runtime proces object. */
    public Value Object
      {
      get
        {
        ICorDebugValue v = null;
        _p().GetObject (out v);
        return new Value (v);
        }
      }

    /** get the thread for a cookie. */
    public DebuggedThread ThreadForFiberCookie (int cookie)
      {
      ICorDebugThread thread = null;
      int r = _p().ThreadForFiberCookie ((uint) cookie, out thread);
      // TODO: make this exception its own type.
      if (r==1)
        // S_FALSE returned.
        throw new Exception ("bad thread cookie.  bad!");
      return new DebuggedThread (thread);
      }
    } /* class Process */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedthreadenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for Threads. */
  internal class DebuggedThreadEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugThreadEnum m_enum;
    private DebuggedThread m_th;

    internal DebuggedThreadEnumerator (ICorDebugThreadEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new DebuggedThreadEnumerator ((ICorDebugThreadEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugThread[] a = new ICorDebugThread[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_th = new DebuggedThread (a[0]);
      else
        m_th = null;
      return m_th != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_th = null;}

    public Object Current
      {get {return m_th;}}
    } /* class ThreadEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debuggedthread.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;
using Debugging;

namespace Debugging
  {
  /** A thread in the debugged process. */
  public class DebuggedThread
    {
    private ICorDebugThread m_th;

    internal DebuggedThread (ICorDebugThread th)
      {m_th = th;}

    internal ICorDebugThread GetInterface ()
      {return m_th;}

    /** The process that this thread is in. */
    public DebuggedProcess Process
      {
      get
        {
        ICorDebugProcess p = null;
        m_th.GetProcess (out p);
        return new DebuggedProcess (p);
        }
      }

    /** the OS id of the thread. */
    public int Id
      {
      get
        {
        uint id = 0;
        m_th.GetID (out id);
        return (int) id;
        }
      }

    /** The handle of the active part of the thread. */
    public int Handle
      {
      get
        {
        uint h = 0;
        m_th.GetHandle (out h);
        return (int) h;
        }
      }

    /** The AppDomain that owns the thread. */
    public DebuggedAppDomain AppDomain
      {
      get
        {
        ICorDebugAppDomain ad = null;
        m_th.GetAppDomain (out ad);
        return new DebuggedAppDomain (ad);
        }
      }

    /** Set the current debug state of the thread. */
    public CorDebugThreadState DebugState
      {
      get
        {
        CorDebugThreadState s = CorDebugThreadState.THREAD_RUN;
        m_th.GetDebugState (out s);
        return s;
        }
      set
        {
        m_th.SetDebugState (value);
        }
      }

    /** the user state. */
    public CorDebugUserState UserState
      {
      get
        {
        CorDebugUserState s = CorDebugUserState.USER_STOP_REQUESTED;
        m_th.GetUserState (out s);
        return s;
        }
      }

    /** the exception object which is currently being thrown by the thread. */
    public Value CurrentException
      {
      get
        {
        ICorDebugValue v = null;
        m_th.GetCurrentException (out v);
        return (v==null) ? null : new Value (v);
        }
      }

    // Clear the current exception object, preventing it from being thrown.
    public void ClearCurrentException ()
      {m_th.ClearCurrentException ();}

    // create a stepper object relative to the active frame in this thread.
    public Stepper CreateStepper ()
      {
      ICorDebugStepper s = null;
      m_th.CreateStepper (out s);
      return new Stepper (s);
      }

#if I_DONT_WANT_TO_DO_THIS_YET
    /** All stack chains in the thread. */
    public IEnumerable Chains
      {
      get
        {
        ICorDebugChainEnum ec = null;
        m_th.EnumerateChains (out ec);
        return new ChainEnumerator (ec);
        }
      }

    /** The most recent chain in the thread, if any. */
    public Chain ActiveChain
      {
      get
        {
        ICorDebugChain ch = null;
        m_th.GetActiveChain (out ch);
        return ch == null ? ch : new Chain (ch);
        }
      }

    /** Get the active frame. */
    public Frame ActiveFrame
      {
      get
        {
        ICorDebugFrame f = null;
        m_th.GetActiveFrame (out f);
        return f==null ? f : new Frame (f);
        }
      }

    /** Get the register set for the active part of the thread. */
    public RegisterSet RegisterSet
      {
      get
        {
        ICorDebugRegisterSet r = null;
        m_th.GetRegisterSet (out r);
        return new RegisterSet (r);
        }
      }

    /** Creates an evaluation object. */
    public Eval CreateEval ()
      {
      ICorDebugEval e = null;
      m_th.CreateEval (out e);
      return new Eval (e);
      }
#endif

    /** Get the runtime thread object. */
    public Value Object
      {
      get
        {
        ICorDebugValue v = null;
        m_th.GetObject (out v);
        return new Value (v);
        }
      }
    } /* class Thread */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\eval.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  // collects functionality which requires runnint code inside the debuggee.
  public class Eval
    {
    private ICorDebugEval m_eval;

    internal Eval (ICorDebugEval e)
      {m_eval = e;}

#if I_DONT_WANT_TO
    public void CallFunction (Function f, Value[] args, uint nargs);
    public void NewObject (Function ctor, Value[] args, uint nargs);
#endif

    /** Create an object w/o invoking its constructor. */
    public void NewObjectNoContstructor (DebuggedClass c)
      {
      m_eval.NewObjectNoConstructor (c.GetInterface ());
      }

    /** allocate a string w/ the given contents. */
    public void NewString (String s)
      {
      // s needs to be null-terminated, hence the padding.
      // m_eval.NewString (s.PadRight (s.Length, '\0').ToCharArray());
      m_eval.NewString (s);
      }

#if I_DONT_WANT_TO
    public void NewArray (CorElementType type, Class c, uint rank, 
      uint[] dims, uint[] lowBounds);
#endif

    /** Does the Eval have an active computation? */
    public bool IsActive ()
      {
      int r = 0;
      m_eval.IsActive (out r);
      return !(r==0);
      }

    /** Abort the current computation. */
    public void Abort ()
      {m_eval.Abort ();}

    /** Result of the evaluation.  Valid only after the eval is complete. */
    public Value Result
      {
      get
        {
        ICorDebugValue v = null;
        m_eval.GetResult (out v);
        return new Value (v);
        }
      }

    /** The thread that this eval was created in. */
    public DebuggedThread Thread
      {
      get
        {
        ICorDebugThread t = null;
        m_eval.GetThread (out t);
        return new DebuggedThread (t);
        }
      }

    /** Create a Value to use it in a Function Evaluation. */
    public Value CreateValue (uint type, DebuggedClass c)
      {
      ICorDebugValue v = null;
      m_eval.CreateValue (type, c.GetInterface (), out v);
      return new Value (v);
      }
    } /* class Eval */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\managedevents.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Provides managed events from the debugger for managed code.
//

using System;
using System.Collections;
using System.Diagnostics;
using CORDBLib;
using Debugging;

namespace Debugging
  {
  // All of the Debugger events make a Controller available (to specify
  // whether or not to continue the program, or to stop, etc.).
  //
  // This serves as the base class for all events used for debugging.
  //
  // NOTE: If you don't want Controller.Continue(false) to be
  // called after event processing has finished, you need to set the
  // Continue property to false.
  public class DebuggingEventArgs : EventArgs
    {
    private Controller m_controller;

    private bool m_continue;

    public DebuggingEventArgs (Controller controller)
      {m_controller = controller;
      m_continue = true;}

    /** The Controller of the current event. */
    public Controller  Controller
      {get {return m_controller;}}

    // The default behavior after an event is to Continue processing
    // after the event has been handled.  This can be changed by
    // setting this property to false.
    public bool Continue
      {get {return m_continue;}
      set {m_continue = value;}}
    }


  // This class is used for all events that only have access to the 
  // DebuggedProcess that is generating the event.
  public class DebuggedProcessEventArgs : DebuggingEventArgs
    {
    public DebuggedProcessEventArgs (DebuggedProcess p)
      : base (p)
      {}

    /** The process that generated the event. */
    public DebuggedProcess Process
      {get {return (DebuggedProcess) Controller;}}
    }

  public delegate void DebuggedProcessEventHandler (Object sender, 
    DebuggedProcessEventArgs e);


  // The event arguments for events that contain both a DebuggedProcess
  // and an DebuggedAppDomain.
  public class DebuggedAppDomainEventArgs : DebuggedProcessEventArgs
    {
    private DebuggedAppDomain m_ad;

    public DebuggedAppDomainEventArgs (
      DebuggedProcess process, DebuggedAppDomain ad)
      : base (process)
      {m_ad = ad;}

    /** The AppDomain that generated the event. */
    public DebuggedAppDomain AppDomain
      {get {return m_ad;}}
    }

  public delegate void DebuggedAppDomainEventHandler (Object sender, 
    DebuggedAppDomainEventArgs e);

  
  // The base class for events which take an DebuggedAppDomain as their
  // source, but not a DebuggedProcess.
  public class DebuggedAppDomainBaseEventArgs : DebuggingEventArgs
    {
    public DebuggedAppDomainBaseEventArgs (DebuggedAppDomain ad)
      : base (ad)
      {}

    public DebuggedAppDomain AppDomain
      {get {return (DebuggedAppDomain) Controller;}}
    }


  // Arguments for events dealing with threads.
  public class DebuggedThreadEventArgs : DebuggedAppDomainBaseEventArgs
    {
    private DebuggedThread m_thread;

    public DebuggedThreadEventArgs (DebuggedAppDomain ad, DebuggedThread thread)
      : base (ad)
      {m_thread = thread;}

    /** The DebuggedThread of interest. */
    public DebuggedThread Thread
      {get {return m_thread;}}
    }

  public delegate void DebuggedThreadEventHandler (Object sender, 
    DebuggedThreadEventArgs e);


  // Arguments for events involving breakpoints.
  public class BreakpointEventArgs : DebuggedThreadEventArgs
    {
    private Breakpoint m_break;

    public BreakpointEventArgs (DebuggedAppDomain ad, 
      DebuggedThread thread, 
      Breakpoint br)
      : base (ad, thread)
      {m_break = br;}

    /** The breakpoint involved. */
    public Breakpoint Breakpoint
      {get {return m_break;}}
    }

  public delegate void BreakpointEventHandler (Object sender, 
    BreakpointEventArgs e);


  // Arguments for when a Step operation has completed.
  public class StepCompleteEventArgs : DebuggedThreadEventArgs
    {
    private Stepper    m_step;
    private CorDebugStepReason  m_reason;

    public StepCompleteEventArgs (DebuggedAppDomain ad, DebuggedThread thread, 
      Stepper step, CorDebugStepReason reason)
      : base (ad, thread)
      {m_step = step;
      m_reason = reason;}

    public Stepper Stepper
      {get {return m_step;}}
    public CorDebugStepReason Reason
      {get {return m_reason;}}
    }

  public delegate void StepCompleteEventHandler (Object sender, 
    StepCompleteEventArgs e);


  // For events dealing with exceptions.
  public class DebuggedExceptionEventArgs : DebuggedThreadEventArgs
    {
    bool  m_unhandled;

    public DebuggedExceptionEventArgs (DebuggedAppDomain ad, 
      DebuggedThread thread, 
      bool unhandled)
      : base (ad, thread)
      {m_unhandled = unhandled;}

    /** Has the exception been handled yet? */
    public bool Unhandled
      {get {return m_unhandled;}}
    }

  public delegate void DebuggedExceptionEventHandler (Object sender, 
    DebuggedExceptionEventArgs e);


  // For events dealing the evaluation of something...
  public class EvalEventArgs : DebuggedThreadEventArgs
    {
    Eval m_eval;

    public EvalEventArgs (DebuggedAppDomain ad, DebuggedThread thread, 
      Eval eval)
      : base (ad, thread)
      {m_eval = eval;}

    /** The object being evaluated. */
    public Eval  Eval
      {get {return m_eval;}}
    }

  public delegate void EvalEventHandler (Object sender, EvalEventArgs e);


  // For events dealing with module loading/unloading.
  public class DebuggedModuleEventArgs : DebuggedAppDomainBaseEventArgs
    {
    DebuggedModule m_module;

    public DebuggedModuleEventArgs (DebuggedAppDomain ad, DebuggedModule module)
      : base (ad)
      {m_module = module;}

    public DebuggedModule  Module
      {get {return m_module;}}
    }

  public delegate void DebuggedModuleEventHandler (Object sender, 
    DebuggedModuleEventArgs e);


  // For events dealing with class loading/unloading.
  public class DebuggedClassEventArgs : DebuggedAppDomainBaseEventArgs
    {
    DebuggedClass m_class;

    public DebuggedClassEventArgs (DebuggedAppDomain ad, DebuggedClass Class)
      : base (ad)
      {m_class = Class;}

    public DebuggedClass  Class
      {get {return m_class;}}
    }

  public delegate void DebuggedClassEventHandler (Object sender, 
    DebuggedClassEventArgs e);

  
  // For events dealing with debugger errors.
  public class DebuggerErrorEventArgs : DebuggedProcessEventArgs
    {
    int   m_errorHR;
    int   m_errorCode;

    public DebuggerErrorEventArgs (DebuggedProcess process, int errorHR, 
      int errorCode)
      : base (process)
      {m_errorHR = errorHR;
      m_errorCode = errorCode;}
    public int  ErrorHR
      {get {return m_errorHR;}}
    public int ErrorCode
      {get {return m_errorCode;}}
    }

  public delegate void DebuggerErrorEventHandler (Object sender, 
    DebuggerErrorEventArgs e);


  // For events dealing with Assemblies.
  public class DebuggedAssemblyEventArgs : DebuggedAppDomainBaseEventArgs
    {
    private DebuggedAssembly m_assembly;
    public DebuggedAssemblyEventArgs (DebuggedAppDomain ad, 
      DebuggedAssembly assembly)
      : base (ad)
      {m_assembly = assembly;}

    /** The Assembly of interest. */
    public DebuggedAssembly Assembly
      {get {return m_assembly;}}
    }

  public delegate void DebuggedAssemblyEventHandler (Object sender, 
    DebuggedAssemblyEventArgs e);


  // For events dealing with logged messages.
  public class LogMessageEventArgs : DebuggedThreadEventArgs
    {
    int m_level;
    // XXX should be string
    short m_logSwitchName;

    // XXX should be string
    short m_message;

    public LogMessageEventArgs (DebuggedAppDomain ad, DebuggedThread thread,
      int level, short logSwitchName, short message)
      : base (ad, thread)
      {m_level = level;
      m_logSwitchName = logSwitchName;
      m_message = message;}

    public int  Level
      {get {return m_level;}}
    public short  LogSwitchName
      {get {return m_logSwitchName;}}
    public short Message
      {get {return  m_message;}}
    }

  public delegate void LogMessageEventHandler (Object sender, 
    LogMessageEventArgs e);


  // For events dealing with logged messages.
  public class LogSwitchEventArgs : DebuggedThreadEventArgs
    {
    int m_level;

    int m_reason;

    // XXX should be string
    short m_logSwitchName;

    // XXX should be string
    short m_parentName;

    public LogSwitchEventArgs (DebuggedAppDomain ad, DebuggedThread thread,
      int level, int reason, short logSwitchName, short parentName)
      : base (ad, thread)
      {m_level = level;
      m_reason = reason;
      m_logSwitchName = logSwitchName;
      m_parentName = parentName;}

    public int  Level
      {get {return m_level;}}
    public int Reason
      {get {return m_reason;}}
    public short  LogSwitchName
      {get {return m_logSwitchName;}}
    public short ParentName
      {get {return  m_parentName;}}
    }

  public delegate void LogSwitchEventHandler (Object sender, 
    LogSwitchEventArgs e);


  // For events dealing module symbol updates.
  public class UpdateModuleSymbolsEventArgs : DebuggedModuleEventArgs
    {
    IStream m_stream;

    public UpdateModuleSymbolsEventArgs (DebuggedAppDomain ad, 
      DebuggedModule module, IStream stream)
      : base (ad, module)
      {m_stream = stream ;}

    public IStream Stream
      {get {return m_stream;}}
    }

  public delegate void UpdateModuleSymbolsEventHandler (Object sender, 
    UpdateModuleSymbolsEventArgs e);


  // This class attaches to a process and signals events for "managed"
  // debugger events.
  public class ManagedEvents
    {
    // This is the object that gets passed to the debugger.  It's
    // the intermediate "source" of the events, which repackages
    // the event arguments into a more approprate form and forwards
    // the call to the appropriate function.
    private class ManagedCallback : ICorDebugManagedCallback
      {
      private ManagedEvents m_delegate;

      public ManagedCallback (ManagedEvents outer)
        {m_delegate = outer;}

      public void Breakpoint (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread,
        ICorDebugBreakpoint breakpoint)
        {m_delegate.OnBreakpoint (
          new BreakpointEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread), 
            new Breakpoint (breakpoint)));}

      public void StepComplete (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread,
        ICorDebugStepper    step,
        CorDebugStepReason  reason)
        {m_delegate.OnStepComplete (
          new StepCompleteEventArgs (
            new DebuggedAppDomain (appDomain), 
            new DebuggedThread (thread), 
            new Stepper(step), 
            reason));}

      public void Break (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread)
        {m_delegate.OnBreak (
          new DebuggedThreadEventArgs (
            new DebuggedAppDomain (appDomain), 
            new DebuggedThread (thread)));}

      public void Exception (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread,
        int                 unhandled)
        {m_delegate.OnException (
          new DebuggedExceptionEventArgs (
            new DebuggedAppDomain (appDomain), 
            new DebuggedThread (thread),
            !(unhandled == 0)));}
          /* pass false if ``unhandled'' is 0 -- mapping TRUE to true, etc. */

      public void EvalComplete (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread,
        ICorDebugEval       eval)
        {m_delegate.OnEvalComplete (
          new EvalEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread), 
            new Eval(eval)));}

      public void EvalException (
        ICorDebugAppDomain appDomain,
        ICorDebugThread thread,
        ICorDebugEval eval)
        {m_delegate.OnEvalException (
          new EvalEventArgs (
            new DebuggedAppDomain (appDomain), 
            new DebuggedThread (thread), 
            new Eval (eval)));}

      public void CreateProcess (
        ICorDebugProcess process)
        {m_delegate._on_create_process (
          new DebuggedProcessEventArgs (
            new DebuggedProcess (process)));}

      public void ExitProcess (
        ICorDebugProcess process)
        {m_delegate._on_process_exit (
          new DebuggedProcessEventArgs (
            new DebuggedProcess (process)));}

      public void CreateThread (
        ICorDebugAppDomain appDomain,
        ICorDebugThread thread)
        {m_delegate.OnCreateThread (
          new DebuggedThreadEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread)));}

      public void ExitThread (
        ICorDebugAppDomain appDomain,
        ICorDebugThread thread)
        {m_delegate.OnThreadExit (
          new DebuggedThreadEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread)));}

      public void LoadModule (
        ICorDebugAppDomain appDomain,
        ICorDebugModule module)
        {m_delegate.OnModuleLoad (
          new DebuggedModuleEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedModule (module)));}

      public void UnloadModule (
        ICorDebugAppDomain appDomain,
        ICorDebugModule module)
        {m_delegate.OnModuleUnload (
          new DebuggedModuleEventArgs (
            new DebuggedAppDomain (appDomain), 
            new DebuggedModule (module)));}

      public void LoadClass (
        ICorDebugAppDomain appDomain,
        ICorDebugClass c)
        {m_delegate.OnClassLoad (
          new DebuggedClassEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedClass (c)));}

      public void UnloadClass (
        ICorDebugAppDomain appDomain,
        ICorDebugClass c)
        {m_delegate.OnClassUnload (
          new DebuggedClassEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedClass (c)));}

      public void DebuggerError (
        ICorDebugProcess  process,
        int               errorHR,
        uint              errorCode)
        {m_delegate.OnDebuggerError (
          new DebuggerErrorEventArgs (
            new DebuggedProcess (process), 
            errorHR, 
            (int) errorCode));}

      public void LogMessage (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread,
        int                 level,
        ref short           logSwitchName,  // XXX: should be String
        ref short           message)        // XXX: should be String
        {m_delegate.OnLogMessage (
          new LogMessageEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread), 
            level, logSwitchName, message));}

      public void LogSwitch (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread,
        int                 level,
        uint                reason,
        ref short           logSwitchName,  // XXX: should be String
        ref short           parentName)     // XXX: should be String
        {m_delegate.OnLogSwitch (
          new LogSwitchEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread), 
            level, (int) reason, logSwitchName, parentName));}

      public void CreateAppDomain (
        ICorDebugProcess    process,
        ICorDebugAppDomain  appDomain)
        {m_delegate.OnCreateAppDomain (
          new DebuggedAppDomainEventArgs (
            new DebuggedProcess (process), 
            new DebuggedAppDomain(appDomain)));}

      public void ExitAppDomain (
        ICorDebugProcess    process,
        ICorDebugAppDomain  appDomain)
        {m_delegate.OnAppDomainExit (
          new DebuggedAppDomainEventArgs (
            new DebuggedProcess (process), 
            new DebuggedAppDomain (appDomain)));}

      public void LoadAssembly (
        ICorDebugAppDomain  appDomain,
        ICorDebugAssembly   assembly)
        {m_delegate.OnAssemblyLoad (
          new DebuggedAssemblyEventArgs (
            new DebuggedAppDomain (appDomain), 
            new DebuggedAssembly (assembly)));}

      public void UnloadAssembly (
        ICorDebugAppDomain  appDomain,
        ICorDebugAssembly   assembly)
        {m_delegate.OnAssemblyUnload (
          new DebuggedAssemblyEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedAssembly (assembly)));}

      public void ControlCTrap (
        ICorDebugProcess process)
        {m_delegate.OnControlCTrap (
          new DebuggedProcessEventArgs (new DebuggedProcess (process)));}

      public void NameChange (
        ICorDebugAppDomain  appDomain,
        ICorDebugThread     thread)
        {m_delegate.OnNameChange (
          new DebuggedThreadEventArgs (
            new DebuggedAppDomain(appDomain), 
            new DebuggedThread (thread)));}

      public void UpdateModuleSymbols (
        ICorDebugAppDomain  appDomain,
        ICorDebugModule     module,
        IStream             stream)
        {m_delegate.OnUpdateModuleSymbols (
          new UpdateModuleSymbolsEventArgs(
            new DebuggedAppDomain(appDomain), 
            new DebuggedModule (module), 
            stream));}
      }

    //
    // Each of the events that we expose
    //
    private event BreakpointEventHandler          m_breakpoint;
    private event StepCompleteEventHandler        m_step_complete;
    private event DebuggedThreadEventHandler      m_break;
    private event DebuggedExceptionEventHandler   m_exception;
    private event EvalEventHandler                m_eval_complete;
    private event EvalEventHandler                m_eval_exception;
    private event DebuggedProcessEventHandler     m_create_process;
    private event DebuggedProcessEventHandler     m_process_exit;
    private event DebuggedThreadEventHandler      m_create_thread;
    private event DebuggedThreadEventHandler      m_thread_exit;
    private event DebuggedModuleEventHandler      m_module_load;
    private event DebuggedModuleEventHandler      m_module_unload;
    private event DebuggedClassEventHandler       m_class_load;
    private event DebuggedClassEventHandler       m_class_unload;
    private event DebuggerErrorEventHandler       m_debugger_error;
    private event LogMessageEventHandler          m_log_message;
    private event LogSwitchEventHandler           m_log_switch;
    private event DebuggedAppDomainEventHandler   m_create_appdomain;
    private event DebuggedAppDomainEventHandler   m_appdomain_exit;
    private event DebuggedAssemblyEventHandler    m_assembly_load;
    private event DebuggedAssemblyEventHandler    m_assembly_unload;
    private event DebuggedProcessEventHandler     m_control_c_trap;
    private event DebuggedThreadEventHandler      m_name_change;
    private event UpdateModuleSymbolsEventHandler m_update_module_symbols;

    /** the source of the events. */
    private CorDebugger m_debugger;

    /** Each of the processes that we're listening on. */
    private IList     m_pids = new ArrayList ();

    // Create the debugger & set up the callback for later use.
    private void _create_debugger ()
      {
      if (m_debugger == null)
        {
        m_debugger = new CorDebugger ();
        m_debugger.SetManagedHandler (new ManagedCallback(this));
        }
      }

    // Initialize the object, creating the debugger and setting up the
    // callback object for later use.
    public ManagedEvents ()
      {
      m_debugger = null;
      _create_debugger ();
      }

    // Close the connection with the debugger.
    //
    // We detach from any currently connected processes, as we don't want 
    // them to quit after we're gone.
    public void Close ()
      {
      if (m_debugger != null)
        {
        // Disconnect from each connected process.
        foreach (int pid in m_pids)
          {
          try
            {
            Trace.WriteLine ("attempting to detach from: " + pid);
            DebuggedProcess proc = m_debugger.GetProcess (pid);
            proc.Stop (5000);
            proc.Detach ();
            }
          catch (System.Exception e)
            {
            Trace.WriteLine ("unable to detach: " + e.ToString());
            }
          }
        m_pids.Clear ();

        // close the connection with the debugger.
        try
          {
          m_debugger.Terminate ();
          }
        catch (System.Exception e)
          {
          Trace.WriteLine ("Unable to terminate debugger: " + e.ToString());
          }
        m_debugger = null;
        }
      }

      ~ManagedEvents()
      {Close ();}

    // Gain access to the debugger object.
    public CorDebugger GetDebugger ()
      {_create_debugger ();
      return m_debugger;}

    // Attach the debugger to the requested process.
    //
    // Note: The caller must call Continue on the returned
    // Process object to keep the process from halting.
    public DebuggedProcess AttachToProcess (int pid)
      {
      _create_debugger ();
      m_pids.Add (pid);
      DebuggedProcess p = m_debugger.DebugActiveProcess (pid, false);
      return p;
      }

    // Helper for invoking events.  Checks to make sure that handlers
    // are hooked up to a handler before the handler is invoked.
    //
    // We want to allow maximum flexibility by our callers.  As such,
    // we don't require that they call e.Controller.Continue,
    // nor do we require that this class call it.  Someone needs
    // to call it, however.
    //
    // Consequently, if an exception is thrown and the process is stopped,
    // the process is continued automatically.
    private void _on_event (Delegate d, DebuggingEventArgs e)
      {
      /*
       * In order to ensure that Continue() is called only once, 
       * we have this dual level exception handler.  Alas, we lose
       * the stack trace, so we create a new exception and set
       * the inner exception accordingly.
       */
      try
        {
        try
          {
          if (d != null)
            d.DynamicInvoke (new Object[]{this, e});
          }
        catch (Exception ex)
          {
          e.Continue = true;
          throw new Exception (ex.Message, ex);
          }
        }
      finally
        {
        /*
         * The self-test mechanism just tests the event signalling mechanism;
         * no debugger is actually created or used.  Hence, there's no
         * controller.
         */
#if !SELF_TEST
        /*
         * Checking for ``e.Controller.IsRunning()'' doesn't seem to 
         * determine if the process is in a Stopped state or not.
         */
        if (e.Continue)
          e.Controller.Continue (false);
#endif
        }
      }

    //
    // Breakpoint Event
    //
    public event BreakpointEventHandler Breakpoint
      {remove {m_breakpoint -= value;}
      add {m_breakpoint += value;}}

    protected virtual void OnBreakpoint (BreakpointEventArgs e)
      {_on_event (m_breakpoint, e);}

    //
    // StepComplete Event
    //
    public event StepCompleteEventHandler StepComplete
      {remove {m_step_complete -= value;}
      add {m_step_complete += value;}}

    protected virtual void OnStepComplete (StepCompleteEventArgs e)
      {_on_event (m_step_complete, e);}

    //
    // Break Event
    //
    public event DebuggedThreadEventHandler Break
      {remove {m_break -= value;}
      add {m_break += value;}}

    protected virtual void OnBreak (DebuggedThreadEventArgs e)
      {_on_event (m_break, e);}

    //
    // Exception Event
    //
    public event DebuggedExceptionEventHandler Exception
      {remove {m_exception -= value;}
      add {m_exception += value;}}

    protected virtual void OnException (DebuggedExceptionEventArgs e)
      {_on_event (m_exception, e);}

    //
    // EvalComplete Event 
    //
    public event EvalEventHandler EvalComplete
      {remove {m_eval_complete -= value;}
      add {m_eval_complete += value;}}

    protected virtual void OnEvalComplete (EvalEventArgs e)
      {_on_event (m_eval_complete, e);}

    //
    // EvalException Event 
    //
    public event EvalEventHandler EvalException
      {remove {m_eval_exception -= value;}
      add {m_eval_exception += value;}}

    protected virtual void OnEvalException (EvalEventArgs e)
      {_on_event (m_eval_exception, e);}

    //
    // CreateProcess Event 
    //
    public event DebuggedProcessEventHandler CreateProcess
      {remove {m_create_process -= value;}
      add {m_create_process += value;}}

    // We get this process if someone used the Debugger to create 
    // a process (instead of attaching to one).  We need to grab
    // the PID of the process so that our normal handling of the 
    // ProcessExit event will work correctly.
    private void _on_create_process (DebuggedProcessEventArgs e)
      {m_pids.Add (e.Process.Id);
      OnCreateProcess (e);}

    protected virtual void OnCreateProcess (DebuggedProcessEventArgs e)
      {_on_event (m_create_process, e);}

    //
    // ExitProcess Event 
    //
    public event DebuggedProcessEventHandler ProcessExit
      {remove {m_process_exit -= value;}
      add {m_process_exit += value;}}

    // Since ``OnProcessExit'' might be overriden by a derived class,
    // the "COM+ Frameworks Practices" site suggests that the default
    // event handler not do any necessary processing.
    //
    // Removing the exitted process pid from the list of pids to detach
    // from is "necessary", so we don't do that in the event handler,
    // we do that here.  After removing the pid, then we call the 
    // default event handler.
    private void _on_process_exit (DebuggedProcessEventArgs e)
      {// we don't want to detach from a process if it doesn't exist anymore.
      m_pids.Remove (e.Process.Id);
      OnProcessExit (e);}

    protected virtual void OnProcessExit (DebuggedProcessEventArgs e)
      {_on_event (m_process_exit, e);}

    //
    // CreateThread Event 
    //
    public event DebuggedThreadEventHandler CreateThread
      {remove {m_create_thread -= value;}
      add {m_create_thread += value;}}

    protected virtual void OnCreateThread (DebuggedThreadEventArgs e)
      {_on_event (m_create_thread, e);}

    //
    // ExitThread Event 
    //
    public event DebuggedThreadEventHandler ThreadExit
      {remove {m_thread_exit -= value;}
      add {m_thread_exit += value;}}

    protected virtual void OnThreadExit (DebuggedThreadEventArgs e)
      {_on_event (m_thread_exit, e);}

    //
    // LoadModule Event 
    //
    public event DebuggedModuleEventHandler ModuleLoad
      {remove {m_module_load -= value;}
      add {m_module_load += value;}}

    protected virtual void OnModuleLoad (DebuggedModuleEventArgs e)
      {_on_event (m_module_load, e);}

    //
    // UnloadModule Event 
    //
    public event DebuggedModuleEventHandler ModuleUnload
      {remove {m_module_unload -= value;}
      add {m_module_unload += value;}}

    protected virtual void OnModuleUnload (DebuggedModuleEventArgs e)
      {_on_event (m_module_unload, e);}

    //
    // LoadClass Event 
    //
    public event DebuggedClassEventHandler ClassLoad
      {remove {m_class_load -= value;}
      add {m_class_load += value;}}

    protected virtual void OnClassLoad (DebuggedClassEventArgs e)
      {_on_event (m_class_load, e);}

    //
    // UnloadClass Event 
    //
    public event DebuggedClassEventHandler ClassUnload
      {remove {m_class_unload -= value;}
      add {m_class_unload += value;}}

    protected virtual void OnClassUnload (DebuggedClassEventArgs e)
      {_on_event (m_class_unload, e);}

    //
    // DebuggerError Event 
    //
    public event DebuggerErrorEventHandler DebuggerError
      {remove {m_debugger_error -= value;}
      add {m_debugger_error += value;}}

    protected virtual void OnDebuggerError (DebuggerErrorEventArgs e)
      {_on_event (m_debugger_error, e);}

    //
    // LogMessage Event 
    //
    public event LogMessageEventHandler LogMessage
      {remove {m_log_message -= value;}
      add {m_log_message += value;}}

    protected virtual void OnLogMessage (LogMessageEventArgs e)
      {_on_event (m_log_message, e);}

    //
    // LogSwitch Event 
    //
    public event LogSwitchEventHandler LogSwitch
      {remove {m_log_switch -= value;}
      add {m_log_switch += value;}}

    protected virtual void OnLogSwitch (LogSwitchEventArgs e)
      {_on_event (m_log_switch, e);}

    //
    // CreateAppDomain Event 
    //
    public event DebuggedAppDomainEventHandler CreateAppDomain
      {remove {m_create_appdomain -= value;}
      add {m_create_appdomain += value;}}

    protected virtual void OnCreateAppDomain (DebuggedAppDomainEventArgs e)
      {_on_event (m_create_appdomain, e);}

    //
    // ExitAppDomain Event 
    //
    public event DebuggedAppDomainEventHandler AppDomainExit
      {remove {m_appdomain_exit -= value;}
      add {m_appdomain_exit += value;}}

    protected virtual void OnAppDomainExit (DebuggedAppDomainEventArgs e)
      {_on_event (m_appdomain_exit, e);}

    //
    // LoadAssembly Event 
    //
    public event DebuggedAssemblyEventHandler AssemblyLoad
      {remove {m_assembly_load -= value;}
      add {m_assembly_load += value;}}

    protected virtual void OnAssemblyLoad (DebuggedAssemblyEventArgs e)
      {_on_event (m_assembly_load, e);}

    //
    // UnloadAssembly Event 
    //
    public event DebuggedAssemblyEventHandler AssemblyUnload
      {remove {m_assembly_unload -= value;}
      add {m_assembly_unload += value;}}

    protected virtual void OnAssemblyUnload (DebuggedAssemblyEventArgs e)
      {_on_event (m_assembly_unload, e);}

    //
    // ControlCTrap Event 
    //
    public event DebuggedProcessEventHandler ControlCTrap
      {remove {m_control_c_trap -= value;}
      add {m_control_c_trap += value;}}

    protected virtual void OnControlCTrap (DebuggedProcessEventArgs e)
      {_on_event (m_control_c_trap, e);}

    //
    // NameChange Event 
    //
    public event DebuggedThreadEventHandler NameChange
      {remove {m_name_change -= value;}
      add {m_name_change += value;}}

    protected virtual void OnNameChange (DebuggedThreadEventArgs e)
      {_on_event (m_name_change, e);}

    //
    // UpdateModuleSymbols Event 
    //
    public event UpdateModuleSymbolsEventHandler UpdateModuleSymbols
      {remove {m_update_module_symbols -= value;}
      add {m_update_module_symbols += value;}}

    protected virtual void OnUpdateModuleSymbols (
      UpdateModuleSymbolsEventArgs e)
      {_on_event (m_update_module_symbols, e);}


    //
    // For Self-tests
    //

#if SELF_TEST
    // Compile with:
    //    csc /d:SELF_TEST /r:CORDBLib.dll /r:Microsoft.Win32.Interop.Dll \
    //    /out:me.exe *.cs
    private static void Main ()
      {
      ManagedEvents mde = new ManagedEvents ();
      mde.Breakpoint += new BreakpointEventHandler (_test_breakpoint);
      mde.Breakpoint += new BreakpointEventHandler (_test_breakpoint);
      Console.WriteLine ("this should generate output.");
      mde.OnBreakpoint (new BreakpointEventArgs (null, null, null));
      mde.Breakpoint -= new BreakpointEventHandler (_test_breakpoint);
      mde.Breakpoint -= new BreakpointEventHandler (_test_breakpoint);
      Console.WriteLine ("this shouldn't generate output.");
      mde.OnBreakpoint (null);
      }
    private static void _test_breakpoint (Object sender, BreakpointEventArgs e)
      {
      Console.WriteLine ("Breakpoint event handler invoked.");
      }
#endif
    } /* public class ManagedEvents */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\errorinfoenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  // Exposes an enumerator for ErrorInfo objects. 
  //
  // This is horribly broken at this point, as ErrorInfo isn't implemented yet.
  internal class ErrorInfoEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugErrorInfoEnum m_enum;

#if I_DONT_WANT_TO
    private ErrorInfo m_einfo;
#else
    private Object m_einfo;
#endif

    internal ErrorInfoEnumerator (ICorDebugErrorInfoEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new ErrorInfoEnumerator ((ICorDebugErrorInfoEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
#if I_DONT_WANT_TO
      ICorDebugErrorInfo[] a = new ICorDebugErrorInfo[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_einfo = new ErrorInfo (a[0]);
      else
        m_einfo = null;
      return m_einfo != null;
#else
      return false;
#endif
      }

    public void Reset ()
      {m_enum.Reset ();
      m_einfo = null;}

    public Object Current
      {get {return m_einfo;}}
    } /* class ErrorInfoEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\stepperenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using System.Collections;
using Debugging;
using CORDBLib;

namespace Debugging
  {
  /** Exposes an enumerator for Steppers. */
  internal class StepperEnumerator : IEnumerable, IEnumerator, ICloneable
    {
    private ICorDebugStepperEnum m_enum;
    private Stepper m_step;

    internal StepperEnumerator (ICorDebugStepperEnum e)
      {m_enum = e;}

    //
    // ICloneable interface
    //
    public Object Clone ()
      {
      ICorDebugEnum clone = null;
      m_enum.Clone (out clone);
      return new StepperEnumerator ((ICorDebugStepperEnum)clone);
      }

    //
    // IEnumerable interface
    //
    public IEnumerator GetEnumerator ()
      {return this;}

    //
    // IEnumerator interface
    //
    public bool MoveNext ()
      {
      ICorDebugStepper[] a = new ICorDebugStepper[1];
      uint c = 0;
      int r = m_enum.Next ((uint) a.Length, a, out c);
      if (r==0 && c==1) // S_OK && we got 1 new element
        m_step = new Stepper (a[0]);
      else
        m_step = null;
      return m_step != null;
      }

    public void Reset ()
      {m_enum.Reset ();
      m_step= null;}

    public Object Current
      {get {return m_step;}}
    } /* class StepperEnumerator */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\stepper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  /** Represents a stepping operation performed by the debugger. */
  public class Stepper
    {
    private ICorDebugStepper m_step;

    internal Stepper (ICorDebugStepper step)
      {m_step = step;}

    /** Is the stepper active and stepping? */
    public bool IsActive ()
      {
      int a = 9;
      m_step.IsActive (out a);
      return !(a==0);
      }

    /** cancel the last stepping command received. */
    public void Deactivate ()
      {m_step.Deactivate ();}

    /** which intercept code will be stepped into by the debugger? */
    public void SetInterceptMask (CorDebugIntercept mask)
      {m_step.SetInterceptMask (mask);}

    /** Should the stepper stop in jitted code not mapped to IL? */
    public void SetUnmappedStopMask (CorDebugUnmappedStop mask)
      {m_step.SetUnmappedStopMask (mask);}

    /** single step the tread. */
    public void Step (bool into)
      {m_step.Step (into ? 1 : 0);}

    /** Step until code outside of the range is reached. */
    public void StepRange (bool into, COR_DEBUG_STEP_RANGE[] ranges, int cnt)
      {
      m_step.StepRange (into ? 1 : 0, ranges, (uint) cnt);
      }

    // Completes after the current frame is returned from normally & the
    // previous frame is reactivated.
    public void StepOut ()
      {m_step.StepOut ();}

    // Set whether the ranges passed to StepRange are relative to the
    // IL code or the native code for the method being stepped in.
    public void SetRangeIL (bool il)
      {m_step.SetRangeIL (il ? 1 : 0);}
    } /* class Stepper */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\cordblib\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.il

il_target: $(IL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
# Copy the files to the target COM+ directory
	copy $(TARGETPATH)\$(TRUETARGETNAME)* $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\value.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  /** A value in the remote process. */
  public class Value
    {
    private ICorDebugValue  m_val;

    internal Value (ICorDebugValue v)
      {m_val = v;}

    /** The simple type of the value. */
    public int Type
      {
      get
        {
        uint t = 0;
        m_val.GetType (out t);
        return (int) t;
        }
      }

    /** size of the value (in bytes). */
    public int Size
      {
      get
        {
        uint s = 0;
        m_val.GetSize (out s);
        return (int) s;
        }
      }

    /** Address of the value in the debuggee process. */
    public long Address
      {
      get
        {
        ulong addr = 0;
        m_val.GetAddress (out addr);
        return (long) addr;
        }
      }

    /** Breakpoint triggered when the value is modified. */
    public ValueBreakpoint CreateBreakpoint ()
      {
      ICorDebugValueBreakpoint bp = null;
      m_val.CreateBreakpoint (out bp);
      return new ValueBreakpoint (bp);
      }
    } /* class Value */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\valuebreakpoint.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File description here...
//

using System;
using CORDBLib;

namespace Debugging
  {
  public class ValueBreakpoint : Breakpoint
    {
    private ICorDebugValueBreakpoint _vbr()
      {return (ICorDebugValueBreakpoint) GetBreakpoint();}

    internal ValueBreakpoint (ICorDebugValueBreakpoint br)
      : base (br)
      {}

    public Value Value
      {
      get
        {
        ICorDebugValue m = null;
        _vbr().GetValue (out m);
        return new Value (m);
        }
      }
    } /* class ValueBreakpoint */
  } /* namespace Debugging */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debugging\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_link: $(TARGETPATH)\$(TARGETNAME)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\cordblib\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "CORDBLib.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Debugger Assembly Import Library\0"
#define VER_ORIGFILENAME_STR    "CORDBLib.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\enterprisemanifest\makefile.inc ===
target_sign_link: $(TARGETPATH)\$(TARGETNAME)

$(TARGETPATH)\$(TARGETNAME): $(O)\$(ASSEMBLYNAME).tmp
    copy $(O)\$(ASSEMBLYNAME).tmp $(TARGETPATH)\$(TARGETNAME)
!if "$(TARGETCOMPLUS)" != ""
    copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)\$(ASSEMBLYNAME).dll
!endif

$(O)\$(ASSEMBLYNAME).tmp: $(O)\$(ASSEMBLYNAME).dll.manifest
    copy $(TARGETPATH)\$(ASSEMBLYNAME).dll $(O)\$(ASSEMBLYNAME).tmp
    GenMan32 $(O)\$(ASSEMBLYNAME).tmp /add /manifest:$(O)\$(ASSEMBLYNAME).dll.manifest

$(O)\$(ASSEMBLYNAME).dll.manifest: $(TARGETPATH)\$(ASSEMBLYNAME).dll
    -del $(O)\$(ASSEMBLYNAME).dll.manifest
!if "$(TARGETCOMPLUS)" != ""
    GenMan32 $(TARGETCOMPLUS)\$(ASSEMBLYNAME).dll /out:$(O)\$(ASSEMBLYNAME).dll.manifest
!else
    GenMan32 $(TARGETPATH)\$(ASSEMBLYNAME).dll /out:$(O)\$(ASSEMBLYNAME).dll.manifest
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\cordebuggerwrapper\debugging\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "Debugging.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Debugger Wrapper API\0"
#define VER_ORIGFILENAME_STR    "Debugging.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\enterprisetlb\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "System.EnterpriseServices.tlb"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Services Support Infrastructure Type Library\0"
#define VER_ORIGFILENAME_STR    "System.EnterpriseServices.tlb\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\genman32options.cs ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==

using System;

namespace GenMan32
{
    [Serializable()]
    public sealed class GenMan32Options
    {
        public String m_strAssemblyName         = null;
        public String m_strTypeLibName          = null;
        public String m_strOutputFileName       = null;
        public String m_strInputManifestFile    = null;
        public String m_strReferenceFiles        = null;
        public bool   m_bSilentMode             = false;
        public bool   m_bAddManifest            = false;
        public bool   m_bRemoveManifest         = false;
        public bool   m_bReplaceManifest        = false;
        public bool   m_bGenerateTypeLib        = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\enterprisetlb\makefile.inc ===
!if "$(TARGETCOMPLUS)" != ""
	TLBSRCDLL=$(TARGETCOMPLUS)\$(TARGETNAME:.tlb=.dll)
!else
	TLBSRCDLL=$(TARGETPATH)\$(TARGETNAME:.tlb=.dll)
!endif

MKTYPLIBLINK = $(LINKER) -Incremental:NO
TLBLINKFLAGS = \
	-dll \
	-nodefaultlib \
	-debug:none \
	-noentry \
	-heap:0,0 \
	-stack:0,0 \

C_DEFINES = $(C_DEFINES) -DREAL_TLB_FILE=$(O)\$(TARGETNAME:.tlb=.tmp)

target_sign_link :  $(TARGETPATH)\$(TARGETNAME)

$(O)\$(TARGETNAME:.tlb=.tmp) : $(TARGETPATH)\$(TARGETNAME:.tlb=.dll) $(TARGETPATH)\tlbexp.exe
	$(TARGETPATH)\tlbexp.exe /names:$(TARGETNAME:.tlb=.names) $(TARGETPATH)\$(TARGETNAME:.tlb=.dll) /out:$(O)\$(TARGETNAME:.tlb=.tmp)
	NamesGen /verify:$(TARGETNAME:.tlb=.names) $(O)\$(TARGETNAME:.tlb=.tmp)

$(TARGETPATH)\$(TARGETNAME) : $(O)\$(TARGETNAME:.tlb=.tmp) $(O)\mktlb.res
	$(MKTYPLIBLINK) $(TLBLINKFLAGS) -out:$@ $(O)\mktlb.res
!if "$(TARGETCOMPLUS)" != ""
    copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif

!if "$(TARGETCOMPLUS)" != ""
    regasm /regfile:$(O)\$(ASSEMBLYNAME).reg $(TARGETCOMPLUS)\$(ASSEMBLYNAME).dll
!else
    regasm /regfile:$(O)\$(ASSEMBLYNAME).reg $(TARGETPATH)\$(ASSEMBLYNAME).dll
!endif
    RegKeySeperator $(O)\$(ASSEMBLYNAME).reg
    move $(ASSEMBLYNAME)_Shared.reg $(TARGETCOMPLUS)
    move $(ASSEMBLYNAME)_Version.reg $(TARGETCOMPLUS)
	copy regsvcs.exe.rtm.config $(TARGETCOMPLUS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\genman32.cs ===
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
using System;
using System.IO;
using System.Text;

namespace GenMan32
{
    class GenMan32Main 
    {
        private const int SuccessReturnCode = 0;
        private const int ErrorReturnCode = 100;

        public static int Main(String[] args)
        {
            // Parse the command line arguments
            if (!ParseArguments(args, ref s_Options))
                return ErrorReturnCode;

            // If we are not in silent mode then print the logo
            if (!s_Options.m_bSilentMode)
                PrintLogo();

            try
            { 
                GenMan32Code.Run(s_Options);
                ReportResult();
                return SuccessReturnCode;
            }
            catch(Exception e)
            {
                Console.WriteLine("Error: {0}", e.Message); 
                return ErrorReturnCode;
            }
        }

        private static void ReportResult()
        {
            if(!s_Options.m_bSilentMode)
            {
                if (s_Options.m_strOutputFileName != null)
                    Console.WriteLine("Win32 Manifest file {0} is created successfully", s_Options.m_strOutputFileName);
                if (s_Options.m_bAddManifest)
                    Console.WriteLine("Win32 Manifest added to assembly {0} successfully", s_Options.m_strAssemblyName);
                else if (s_Options.m_bRemoveManifest)
                    Console.WriteLine("Manifest is removed from assembly {0} successfully", s_Options.m_strAssemblyName);
                else if (s_Options.m_bReplaceManifest)
                    Console.WriteLine("Manifest is replaced from assembly {0} successfully", s_Options.m_strAssemblyName);
            }
        }

        private static bool ParseArguments(String[] args, ref GenMan32Options options)
        {
            CommandLine cmdLine;
            Option opt;

            options = new GenMan32Options();

            try
            {
                cmdLine = new CommandLine(args, new String[] {"add", "*out", "remove", "replace", "*manifest", "silent", "?", "help", "typelib", "*reference"});
            }
            catch (ApplicationException e)
            {
                PrintLogo();
                Console.WriteLine(e.Message);
                return false;
            }

            if ((cmdLine.NumArgs + cmdLine.NumOpts) < 1)
            {
                PrintUsage();
                return false;
            }

            StringBuilder sb = null;
            // Get the name of the input assembly
            options.m_strAssemblyName = cmdLine.GetNextArg();

            while((opt = cmdLine.GetNextOption()) != null)
            {
                // Dermine which option was specified
                if (opt.Name.Equals("add"))
                    options.m_bAddManifest= true;
                else if (opt.Name.Equals("out"))
                    options.m_strOutputFileName = opt.Value;
                else if (opt.Name.Equals("manifest"))
                    options.m_strInputManifestFile = opt.Value;
                else if (opt.Name.Equals("silent"))
                    options.m_bSilentMode = true;
                else if (opt.Name.Equals("remove"))
                    options.m_bRemoveManifest= true;
                else if (opt.Name.Equals("replace"))
                    options.m_bReplaceManifest = true;
                else if (opt.Name.Equals("typelib"))
                    options.m_bGenerateTypeLib = true;
                else if (opt.Name.Equals("reference"))
                {
                    if (sb == null)
                        sb = new StringBuilder(opt.Value);
                    else
                    {
                        // '?' is the separator
                        sb.Append("?");
                        sb.Append(opt.Value);
                    }
                    options.m_strReferenceFiles = sb.ToString();
                }
                else if (opt.Name.Equals("?") || opt.Name.Equals("help"))
                {
                    PrintUsage();
                    return false;
                }
                else
                {
                    PrintLogo();
                    Console.WriteLine("Error: Invalid Option.");
                    return false;
                }
            }// end of while

            // Make sure input assembly is specified
            if (options.m_strAssemblyName == null)
            {
                PrintLogo();
                Console.WriteLine("Error: No input file.");
                return false;
            }

            // check options conflict           
            if ((options.m_strInputManifestFile != null)&&(options.m_strOutputFileName != null))
            {
                PrintLogo();
                Console.WriteLine("Error: /manifest and /out options cannot be used together.");
                return false;
            }

            if ((options.m_bAddManifest && (options.m_bRemoveManifest||options.m_bReplaceManifest)) ||
                (options.m_bRemoveManifest && (options.m_bAddManifest||options.m_bReplaceManifest)) ||
                (options.m_bReplaceManifest && (options.m_bAddManifest||options.m_bRemoveManifest)) )
            {
                PrintLogo();
                Console.WriteLine("Error: only one of /add, /remove /replace options can be specified.");
                return false;
            }

            if (options.m_bRemoveManifest&&options.m_strInputManifestFile != null)
            {
                PrintLogo();
                Console.WriteLine("Error: /remove does not accept /manifest option.");
                return false;
            }

            if (options.m_bReplaceManifest&&options.m_strInputManifestFile==null)
            {
                PrintLogo();
                Console.WriteLine("Error: /replace need to specify new manifest using /manifest option.");
                return false;
            }

            if (options.m_strInputManifestFile != null) // input file specified
            {
                // verify the manifest file exists
                if (!File.Exists(options.m_strInputManifestFile))
                {
                    PrintLogo();
                    Console.WriteLine("Error: Manifest file {0} does not exist.", options.m_strInputManifestFile);
                    return false;
                }
            }

            return true;
        } // end of ParseArguments

        private static void PrintLogo()
        {
            Console.WriteLine("Microsoft (R) .NET Framework Win32 Manifest File Generation Utility " + Util.Version.VersionString);
            Console.WriteLine("Copyright (C) Microsoft Corporation 1998-2002.  All rights reserved.\n");
        }

        private static void PrintUsage()
        {
            PrintLogo();
            Console.WriteLine("Syntax: GenMan32 AssemblyPath [Options]");
            Console.WriteLine("Options:");
            Console.WriteLine("  /add               Add manifest file to the assembly as a resource");
            Console.WriteLine("                     If /manifest option is provided, use it as input");
            Console.WriteLine("                     Otherwise generate one from the assembly");
            Console.WriteLine("  /remove            Remove an embedded manifest from the assembly");
            Console.WriteLine("  /replace           Replace embedded manifest with new manifest");
            Console.WriteLine("                     New manifest is specified by /manifest option");
            Console.WriteLine("  /manifest:filename Specify the manifest file to add or replace");
            Console.WriteLine("                     Used together with option /add or /replace");
            Console.WriteLine("  /typelib           Generate typelib and record all the interfaces in manifest");
            Console.WriteLine("                     This options should not apply on interop assemblies");
            Console.WriteLine("  /reference:filename Specify the dependency of the assembly.");
            Console.WriteLine("                     If the file has a Win32 manifest in its resource, ");
            Console.WriteLine("                     generated manifest will have a dependency section on it.");
            Console.WriteLine("                     To specify multiple dependencies, use multiple /reference.");
            Console.WriteLine("                     E.g /reference:1.dll /reference:2.dll.");
            Console.WriteLine("  /out:filename      Generate manifest and copy it to the specified file");
            Console.WriteLine("                     default generate AssemblyPath.manifest file");
            Console.WriteLine("  /silent            Silent mode. Prevent displaying of output message");
            Console.WriteLine("  /? or /help        Display this usage message");
            Console.WriteLine();
        }

        internal static GenMan32Options s_Options = null;
    } // end of class GenMan32Main

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "REGMAN32.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft (R) .NET Framework Win32 Manifest File Generation Utility\0"
#define VER_ORIGFILENAME_STR    "GenMan32.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\updateresource.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace GenMan32
{
    internal class ResourceHelper
    {
        internal static void UpdateResourceInFile(String strAssemblyName, String strResourceFileName, int idType, int idRes)
        {
            IntPtr      hAssembly = (IntPtr) 0;
            IntPtr      hResource = (IntPtr) 0;
            bool        bDelete = false;
            bool        bResFound = false;
            
            if ((strAssemblyName == null)||(strAssemblyName == String.Empty)||(idRes < 1))
            {
               throw new ApplicationException("Invalid argument passed in UpdateResourceInFile!"); 
            }
            
            // if no manifest file, means delete resource
            if (strResourceFileName == null || strResourceFileName == String.Empty)
            {
                bDelete = true;
            }

            // check existence of resources
            hAssembly = LoadLibrary(strAssemblyName);
            if (hAssembly == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Cannot load {0}!", strAssemblyName));
            }

            //String resId = "#" + idRes.ToString();
            if (FindResource(hAssembly, idRes, idType) != (IntPtr)0)
            {
                bResFound = true;
            }
        
            FreeLibrary(hAssembly);
            
            // Check conflict
            if (bResFound && !bDelete)
            {
                throw new ApplicationException(String.Format("Resource already exists in {0}", strAssemblyName));
            }

            if (bDelete && !bResFound)
            {
                throw new ApplicationException(String.Format("Resource does not exist in {0}", strAssemblyName));
            }

            // read manifest file
            FileStream fs = null;
            int fileLength = 0;
            byte[] fileContent = null;

            if (!bDelete)
            {
                try
                {
                    fs = File.OpenRead(strResourceFileName);

                    fileLength = (int)fs.Length;
                    fileContent = new byte[fileLength];

                    fs.Read(fileContent, 0, fileLength);
                    fs.Close();
                    fs = null;
                }
                catch (Exception)
                {
                    if (fs != null)
                        fs.Close();
                    throw new ApplicationException(String.Format("Error reading {0}", strResourceFileName));
                }
            }

            // update resource
            hResource = BeginUpdateResource(strAssemblyName, false);
            if ( hResource == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName));
            }

            bool updateSuccess = true;
            
            if (!UpdateResource(hResource,
                                idType,
                                idRes,
                                0,
                                fileContent,
                                fileLength))
            {
                updateSuccess = false;
            }

            if (!EndUpdateResource(hResource, false))
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }

            if (!updateSuccess)
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }
        }

        internal static void UpdateResourceInFile(String strAssemblyName, String strResourceFileName, String idType, String idRes)
        {
            IntPtr      hAssembly = (IntPtr) 0;
            IntPtr      hResource = (IntPtr) 0;
            bool        bDelete = false;
            bool        bResFound = false;
            
            if (strAssemblyName == null || strAssemblyName == String.Empty ||
                idType == null || idType == String.Empty ||
                idRes == null || idRes == String.Empty)
            {
               throw new ApplicationException("Invalid argument passed in UpdateResourceInFile!"); 
            }

            
            // if no manifest file, means delete resource
            if (strResourceFileName == null || strResourceFileName == String.Empty)
            {
                bDelete = true;
            }

            // check existence of resources
            hAssembly = LoadLibrary(strAssemblyName);
            if (hAssembly == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Cannot load {0}!", strAssemblyName));
            }

            //String resId = "#" + idRes.ToString();
            if (FindResource(hAssembly, idRes, idType) != (IntPtr)0)
            {
                bResFound = true;
            }
        
            FreeLibrary(hAssembly);
            
            // Check conflict
            if (bResFound && !bDelete)
            {
                throw new ApplicationException(String.Format("Resource already exists in {0}", strAssemblyName));
            }

            if (bDelete && !bResFound)
            {
                throw new ApplicationException(String.Format("Resource does not exist in {0}", strAssemblyName));
            }

            // read manifest file
            FileStream fs = null;
            int fileLength = 0;
            byte[] fileContent = null;

            if (!bDelete)
            {
                try
                {
                    fs = File.OpenRead(strResourceFileName);

                    fileLength = (int)fs.Length;
                    fileContent = new byte[fileLength];

                    fs.Read(fileContent, 0, fileLength);
                    fs.Close();
                    fs = null;
                }
                catch (Exception)
                {
                    if (fs != null)
                        fs.Close();
                    throw new ApplicationException(String.Format("Error reading {0}", strResourceFileName));
                }
            }

            // update resource
            hResource = BeginUpdateResource(strAssemblyName, false);
            if ( hResource == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName));
            }

            bool updateSuccess = true;
            
            if (!UpdateResource(hResource,
                                idType,
                                idRes,
                                0,
                                fileContent,
                                fileLength))
            {
                updateSuccess = false;
            }

            if (!EndUpdateResource(hResource, false))
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }

            if (!updateSuccess)
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }
        }
       
        internal static void UpdateResourceInFile(String strAssemblyName, String strResourceFileName, String idType, int idRes)
        {
            IntPtr      hAssembly = (IntPtr) 0;
            IntPtr      hResource = (IntPtr) 0;
            bool        bDelete = false;
            bool        bResFound = false;
            
            if (strAssemblyName == null || strAssemblyName == String.Empty ||
                idType == null || idType == String.Empty || idRes < 1)
            {
               throw new ApplicationException("Invalid argument passed in UpdateResourceInFile!"); 
            }
            
            // if no manifest file, means delete resource
            if (strResourceFileName == null || strResourceFileName == String.Empty)
            {
                bDelete = true;
            }

            // check existence of resources
            hAssembly = LoadLibrary(strAssemblyName);
            if (hAssembly == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Cannot load {0}!", strAssemblyName));
            }

            //String resId = "#" + idRes.ToString();
            if (FindResource(hAssembly, idRes, idType) != (IntPtr)0)
            {
                bResFound = true;
            }
        
            FreeLibrary(hAssembly);
            
            // Check conflict
            if (bResFound && !bDelete)
            {
                throw new ApplicationException(String.Format("Resource already exists in {0}", strAssemblyName));
            }

            if (bDelete && !bResFound)
            {
                throw new ApplicationException(String.Format("Resource does not exist in {0}", strAssemblyName));
            }

            // read manifest file
            FileStream fs = null;
            int fileLength = 0;
            byte[] fileContent = null;

            if (!bDelete)
            {
                try
                {
                    fs = File.OpenRead(strResourceFileName);

                    fileLength = (int)fs.Length;
                    fileContent = new byte[fileLength];

                    fs.Read(fileContent, 0, fileLength);
                    fs.Close();
                    fs = null;
                }
                catch (Exception)
                {
                    if (fs != null)
                        fs.Close();
                    throw new ApplicationException(String.Format("Error reading {0}", strResourceFileName));
                }
            }

            // update resource
            hResource = BeginUpdateResource(strAssemblyName, false);
            if ( hResource == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName));
            }

            bool updateSuccess = true;
            
            if (!UpdateResource(hResource,
                                idType,
                                idRes,
                                0,
                                fileContent,
                                fileLength))
            {
                updateSuccess = false;
            }

            if (!EndUpdateResource(hResource, false))
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }

            if (!updateSuccess)
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }
        }

        internal static void UpdateResourceInFile(String strAssemblyName, String strResourceFileName, int idType, String idRes)
        {
            IntPtr      hAssembly = (IntPtr) 0;
            IntPtr      hResource = (IntPtr) 0;
            bool        bDelete = false;
            bool        bResFound = false;
            
            if (strAssemblyName == null || strAssemblyName == String.Empty ||
                idRes == null || idRes == String.Empty || idType < 1)
            {
               throw new ApplicationException("Invalid argument passed in UpdateResourceInFile!"); 
            }
            
            // if no manifest file, means delete resource
            if (strResourceFileName == null || strResourceFileName == String.Empty)
            {
                bDelete = true;
            }

            // check existence of resources
            hAssembly = LoadLibrary(strAssemblyName);
            if (hAssembly == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Cannot load {0}!", strAssemblyName));
            }

            //String resId = "#" + idRes.ToString();
            if (FindResource(hAssembly, idRes, idType) != (IntPtr)0)
            {
                bResFound = true;
            }
        
            FreeLibrary(hAssembly);
            
            // Check conflict
            if (bResFound && !bDelete)
            {
                throw new ApplicationException(String.Format("Resource already exists in {0}", strAssemblyName));
            }

            if (bDelete && !bResFound)
            {
                throw new ApplicationException(String.Format("Resource does not exist in {0}", strAssemblyName));
            }

            // read manifest file
            FileStream fs = null;
            int fileLength = 0;
            byte[] fileContent = null;

            if (!bDelete)
            {
                try
                {
                    fs = File.OpenRead(strResourceFileName);

                    fileLength = (int)fs.Length;
                    fileContent = new byte[fileLength];

                    fs.Read(fileContent, 0, fileLength);
                    fs.Close();
                    fs = null;
                }
                catch (Exception)
                {
                    if (fs != null)
                        fs.Close();
                    throw new ApplicationException(String.Format("Error reading {0}", strResourceFileName));
                }
            }

            // update resource
            hResource = BeginUpdateResource(strAssemblyName, false);
            if ( hResource == (IntPtr)0)
            {
                throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName));
            }

            bool updateSuccess = true;
            
            if (!UpdateResource(hResource,
                                idType,
                                idRes,
                                0,
                                fileContent,
                                fileLength))
            {
                updateSuccess = false;
            }

            if (!EndUpdateResource(hResource, false))
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }

            if (!updateSuccess)
            {
               throw new ApplicationException(String.Format("Error updating resource for {0}", strAssemblyName)); 
            }
        }

        
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr LoadLibrary(String strLibrary);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern void FreeLibrary(IntPtr ptr);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr FindResource(IntPtr hModule, int lpName, int lpType);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr FindResource(IntPtr hModule, String lpName, String lpType);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr FindResource(IntPtr hModule, String lpName, int lpType);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr FindResource(IntPtr hModule, int lpName, String lpType);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr BeginUpdateResource(String fileName, bool deleteExistingResource);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern bool UpdateResource(IntPtr hUpdate, int lpType, int lpName, int wLanguage, byte[] data, int cbData);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern bool UpdateResource(IntPtr hUpdate, String lpType, String lpName, int wLanguage, byte[] data, int cbData);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern bool UpdateResource(IntPtr hUpdate, String lpType, int lpName, int wLanguage, byte[] data, int cbData);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern bool UpdateResource(IntPtr hUpdate, int lpType, String lpName, int wLanguage, byte[] data, int cbData);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern bool EndUpdateResource(IntPtr hUpdate, bool fDiscard);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\genman32code.cs ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;
using System.Collections;
using System.Security.Policy;

[assembly:ComVisible(false)]
namespace GenMan32
{
    internal enum REGKIND
    {
        REGKIND_DEFAULT         = 0,
        REGKIND_REGISTER        = 1,
        REGKIND_NONE            = 2
    }
    
    public class GenMan32Code
    {
        public static void Run(GenMan32Options Options)
        {
            if (!File.Exists(Path.GetFullPath(Options.m_strAssemblyName)))
            {
                throw new ApplicationException("Input file is not found");
            }

            String strTlbName = null;
            if (Options.m_bGenerateTypeLib)
                strTlbName = GenerateTypeLibUsingHelper(Options.m_strAssemblyName);
            if (strTlbName != null) // strTlbName == null if the assembly has embedded typelib.
                EmbedTypeLibToAssembly(strTlbName, Options.m_strAssemblyName);

            String strOutputFileName = Options.m_strAssemblyName + ".Manifest";

            if (Options.m_bAddManifest) 
            {   // Add the manifest file to the assembly as a resource
                if (Options.m_strInputManifestFile != null) // input file specified
                {
                    AddManifestToAssembly(Options.m_strInputManifestFile, Options.m_strAssemblyName);
                }
                else  // no input file specified
                {
                    strOutputFileName += ".tmp"; // change it to a tmp file
                    if (Options.m_strOutputFileName != null)
                    {
                        strOutputFileName = Options.m_strOutputFileName;
                        if (File.Exists(strOutputFileName))
                            throw new ApplicationException(String.Format("Manifest file {0} exists", strOutputFileName));
                    }

                    // generate the tmp manifest file, add it to assembly, and delete the tmp file if needed

                    // Here we need use a helper. Because GenerateWin32ManifestFile will
                    // load strAssemblyName, thus prevent any change to the assembly(AddManifestToAssembly).
                    // The helper will run in a separate domain. And when it returns, it releases the lock on the assembly.
                    GenerateWin32ManifestFileUsingHelper(strOutputFileName, Options.m_strAssemblyName, Options.m_bGenerateTypeLib, Options.m_strReferenceFiles);
                    try
                    {
                        AddManifestToAssembly(strOutputFileName, Options.m_strAssemblyName);
                    }
                    catch (Exception e)
                    {
                        if (Options.m_strOutputFileName == null)
                            File.Delete(strOutputFileName);
                        throw e;
                    }

                    if (Options.m_strOutputFileName == null)
                        File.Delete(strOutputFileName);
                }
            }
            else if (Options.m_bRemoveManifest) // remove manifest from an assembly
            {
                RemoveManifestFromAssembly(Options.m_strAssemblyName);
            }
            else if (Options.m_bReplaceManifest)
            {
                ReplaceManifestInAssembly(Options.m_strInputManifestFile, Options.m_strAssemblyName);
            }
            else // generate manifest file only
            {
                if (Options.m_strOutputFileName != null)
                    strOutputFileName = Options.m_strOutputFileName;
                else 
                    Options.m_strOutputFileName = strOutputFileName; // copy out output filename
                    
                if ( File.Exists( strOutputFileName ) )
                    throw new ApplicationException(String.Format("Manifest file {0} exists.", strOutputFileName));
                    
                GenerateWin32ManifestFile(strOutputFileName, Options.m_strAssemblyName, Options.m_bGenerateTypeLib, Options.m_strReferenceFiles);
            }
        }

        private static void ReplaceManifestInAssembly(String strManifestFileName, String strAssemblyName)
        {
            // delete old manifest
            ResourceHelper.UpdateResourceInFile(strAssemblyName, null, 24, 1);
            // add new manifest
            ResourceHelper.UpdateResourceInFile(strAssemblyName, strManifestFileName, 24, 1);
        }
        
        private static void RemoveManifestFromAssembly(String strAssemblyName)
        {
            ResourceHelper.UpdateResourceInFile(strAssemblyName, null, 24, 1);
        }

        private static void AddManifestToAssembly(String strManifestFileName, String strAssemblyName)
        {
            // win32 manifest is resource of type 24. 
            // Id 1 is the right place for component manifest.
            ResourceHelper.UpdateResourceInFile(strAssemblyName, strManifestFileName , 24, 1);
        }
        
        private static void EmbedTypeLibToAssembly(String strTlbName, String strAssemblyName)
        {
            try
            {
                ResourceHelper.UpdateResourceInFile(strAssemblyName, strTlbName, "TYPELIB", 1);
                if (!GenMan32Main.s_Options.m_bSilentMode)
                    Console.WriteLine("Typelib embedded into assembly {0}.", strAssemblyName);
            }
            finally
            {
                // We generate temporary typelib. 
                // Delete it after we embed it to the assembly
                File.Delete(strTlbName);
            }
        }

        private static String GenerateTypeLibUsingHelper(String strAssemblyName)
        {
            String adName = "GenMan32: " + Guid.NewGuid().ToString();
            String strTlbName = null;

            Evidence si = null;
            AppDomain ad = AppDomain.CreateDomain(adName, si);
            if (ad == null)
                throw new ApplicationException("Unable to create AppDomain for generating typelib");
            try
            {
                Helper h = (Helper)ad.CreateInstanceAndUnwrap(Assembly.GetAssembly(typeof(GenMan32.Helper)).FullName, typeof(GenMan32.Helper).FullName);
                h.GenerateTypeLib(strAssemblyName, ref strTlbName);
            }
            finally
            {
                AppDomain.Unload(ad);
            }

            if (strTlbName != null && !GenMan32Main.s_Options.m_bSilentMode)
                Console.WriteLine("Typelib generated for assembly {0}.", strAssemblyName);

            return strTlbName;
        }

        // GenerateTypeLib
        //  Params:
        //      strAssemblyName:    assembly file name
        //      strTlbName:         [In]  Output typelib file name. If null, GenerateTypeLib will generate one.
        //                          [Out] Final output typelib file name. 
        //  Return:
        //      Generated typelib.
        internal static UCOMITypeLib GenerateTypeLib(String strAssemblyName, ref String strTlbName)
        {
            if (ContainsEmbeddedTlb(strAssemblyName))
            {
                strTlbName = null;
                return null;
            }

            // COM imported assembly should not use this option.
            Assembly asm = Assembly.LoadFrom(strAssemblyName);
            object[] AsmAttributes = asm.GetCustomAttributes( typeof( ImportedFromTypeLibAttribute ), true );
            if( AsmAttributes.Length > 0 )
                throw new ApplicationException(String.Format("{0} is imported from a typelib. /typelib option should not be used with COM imported assembly.", strAssemblyName));

            // This is the temporary typelib file name
            
            if (strTlbName == null)
            {
                // Retrieve the path of the assembly on disk.
                Module[] aModule = asm.GetLoadedModules();
                String asmPath = Path.GetDirectoryName(aModule[0].FullyQualifiedName);

                // If the typelib name is null then create it from the assembly name.
                strTlbName = Path.Combine(asmPath, asm.GetName().Name) + ".tlb.tmp";
            }

            return GenerateTypeLib(asm, ref strTlbName);
        }

        internal static UCOMITypeLib GenerateTypeLib(Assembly asm, ref String strTlbName)
        {
            ITypeLibConverter tlbConv = new TypeLibConverter();
            
            ExporterCallback callback = new ExporterCallback();
            UCOMITypeLib tlb = (UCOMITypeLib)tlbConv.ConvertAssemblyToTypeLib(asm, strTlbName, 0, callback);

            // Persist the typelib.
            UCOMICreateITypeLib createTlb = (UCOMICreateITypeLib)tlb;
            createTlb.SaveAllChanges();

            return tlb;
        }

        private static void GenerateWin32ManifestFileUsingHelper(String strAssemblyManifestFileName, String strAssemblyName, bool bGenerateTypeLib, String strReferenceFiles)
        {
            String adName = "GenMan32: " + Guid.NewGuid().ToString();

            Evidence si = null;
            AppDomain ad = AppDomain.CreateDomain(adName, si);
            if (ad == null)
                throw new ApplicationException("Unable to create AppDomain for generating assembly manifest");
            try
            {
                Helper h = (Helper)ad.CreateInstanceAndUnwrap(Assembly.GetAssembly(typeof(GenMan32.Helper)).FullName, typeof(GenMan32.Helper).FullName);
                h.GenerateWin32ManifestFile(strAssemblyManifestFileName, strAssemblyName, bGenerateTypeLib, strReferenceFiles);
            }
            finally
            {
                AppDomain.Unload(ad);
            }
        }

        internal static void GenerateWin32ManifestFile(String strAssemblyManifestFileName, String strAssemblyName, bool bGenerateTypeLib, String strReferenceFiles)
        {
            Stream s = null;
            String title = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>";
            
            // Load the assembly
            Assembly asm = null;

            asm = Assembly.LoadFrom(strAssemblyName);

            String path = Path.GetDirectoryName( strAssemblyManifestFileName);
            if (path != "" && !Directory.Exists(path))
            {
                Directory.CreateDirectory( Path.GetDirectoryName( strAssemblyManifestFileName) );
            }
                   
            s = File.Create(strAssemblyManifestFileName);

            try
            {
                // manifest title
                WriteUTFChars(s, title+Environment.NewLine);
            
                AsmCreateWin32ManifestFile(s, asm, bGenerateTypeLib, strReferenceFiles);
                
            }
            catch( Exception e)
            {
                // clean up before we lost control
                s.Close();
                File.Delete(strAssemblyManifestFileName);
                throw e;
            }
            
            s.Close();
        }

        private static void AsmCreateWin32ManifestFile(Stream s, Assembly asm, bool bGenerateTypeLib, String strReferenceFiles)
        {
            String asmTitle = "<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">";
            String asmEnd = "</assembly>";
            
            // element assembly
            WriteUTFChars(s, asmTitle+Environment.NewLine);

            // element assemblyIdentity 
            WriteAsmIDElement(s, asm, 4);

            // depdency
            if (strReferenceFiles != null)
            {
                char[] sep1 = new char[1];
                sep1[0] = '?';
                String[] refFiles = strReferenceFiles.Split(sep1);

                foreach(String refFile in refFiles)
                {
                    if (refFile != String.Empty)
                    {
                        String refAsmId = null;
                        try
                        {                        
                            refAsmId = GetAssemblyIdentity(refFile);
                        }
                        catch(Exception e)
                        {
                            Console.WriteLine("Warning: Exception occurs during extracting assembly identity from {0}.", refFile);
                            Console.WriteLine("Exception message: {0}", e.Message);
                            Console.WriteLine("This reference will be ignored.");
                        }

                        if (refAsmId != null)
                        {
                            char[] sep2 = new char[2];
                            sep2[0] = '\r';
                            sep2[1] = '\n';
                            String[] lines = refAsmId.Split(sep2);
                    
                            WriteUTFChars(s, "<dependency>"+Environment.NewLine, 4);
                            WriteUTFChars(s, "<dependentAssembly>"+Environment.NewLine, 8);
                            for (int i = 0; i< lines.Length; i++)
                            {
                                if (lines[i] != String.Empty)
                                {
                                    int offset = 8;
                                    if (i == 0)
                                        offset = 12;
                                    WriteUTFChars(s, lines[i]+Environment.NewLine, offset);
                                }
                            }
                            WriteUTFChars(s, "</dependentAssembly>"+Environment.NewLine, 8);
                            WriteUTFChars(s, "</dependency>"+Environment.NewLine, 4);
                        }
                    }
                }
            }
                
            RegistrationServices regServices = new RegistrationServices();

            // Retrieve the runtime version used to build the assembly.
            String strRuntimeVersion = asm.ImageRuntimeVersion;

            // element file
            Module[] modules = asm.GetModules();
            foreach (Module m in modules)
            {
                WriteTypes(s, m, asm, strRuntimeVersion, regServices, bGenerateTypeLib, 4);
            }
            for (int i = 0; i < modules.Length; i++)
            {
                // First module contains assembly metadata.
                // Need to put more information.
                if (i == 0 && bGenerateTypeLib)
                    WriteFileElement(s, modules[i], asm, 4);
                else
                    WriteFileElement(s, modules[i], 4);
            }

            WriteUTFChars(s, asmEnd);
        }

        // ordinary module, simple output
        private static void WriteFileElement(Stream s, Module m, int offset)
        {
            WriteUTFChars(s, "<file ", offset);
            WriteUTFChars(s, "name=\""+m.Name+"\">"+Environment.NewLine);
            WriteUTFChars(s, "</file>"+Environment.NewLine, offset);
        }

        // assembly metadata
        // Need to add typelib 
        private static void WriteFileElement(Stream s, Module m, Assembly asm, int offset)
        {
            WriteUTFChars(s, "<file ", offset);
            WriteUTFChars(s, "name=\""+m.Name+"\">"+Environment.NewLine);

            // typelib tag
            AssemblyName asmName = asm.GetName();
            String strHelpDir = Path.GetDirectoryName(asm.Location);
            String strTlbVersion = asmName.Version.Major.ToString() + "." + asmName.Version.Minor.ToString();
            String strTlbId = "{" + Marshal.GetTypeLibGuidForAssembly(asm).ToString().ToUpper() + "}";

            WriteUTFChars(s, "<typelib"+Environment.NewLine, offset + 4);
            WriteUTFChars(s, "tlbid=\""+strTlbId+"\""+Environment.NewLine, offset+8);
            WriteUTFChars(s, "version=\""+strTlbVersion+"\""+Environment.NewLine, offset+8);
            WriteUTFChars(s, "helpdir=\""+strHelpDir+"\" />"+Environment.NewLine, offset+8);

            WriteUTFChars(s, "</file>"+Environment.NewLine, offset);
        }

       
        // write all the types need to register in module m
        private static void WriteTypes(Stream s, Module m, Assembly asm, String strRuntimeVersion, RegistrationServices regServices, bool bGenerateTypeLib, int offset)
        {
            String name = null;
            AssemblyName asmName = asm.GetName();
            String strTlbId = "{" + Marshal.GetTypeLibGuidForAssembly(asm).ToString().ToUpper() + "}";

            // element comClass or interface
            Type[] aTypes = m.GetTypes();

            foreach (Type t in aTypes)
            {
                // only registrable managed types will show up in the manifest file
                if (regServices.TypeRequiresRegistration(t)) 
                {
                    String strClsId = "{"+Marshal.GenerateGuidForType(t).ToString().ToUpper()+"}";
                    name = t.FullName;

                    // this type is a com imported type or Record
                    if (regServices.TypeRepresentsComType(t) || t.IsValueType)
                    {
                        WriteUTFChars(s, "<clrSurrogate"+Environment.NewLine, offset);
                        // attribute clsid
                        WriteUTFChars(s, "    clsid=\""+strClsId+"\""+Environment.NewLine, offset);
                        // attribute class
                        WriteUTFChars(s, "    name=\""+name+"\">"+Environment.NewLine, offset);
                        WriteUTFChars(s, "</clrSurrogate>"+Environment.NewLine, offset);
                    }
                    else
                    // this is a managed type
                    {
                        String strProgId = Marshal.GenerateProgIdForType(t);
                        WriteUTFChars(s, "<clrClass"+Environment.NewLine, offset);
                        // attribute clsid
                        WriteUTFChars(s, "    clsid=\""+strClsId+"\""+Environment.NewLine, offset);
                        // attribute progid
                        WriteUTFChars(s, "    progid=\""+strProgId+"\""+Environment.NewLine, offset);
                        // attribute threadingModel
                        WriteUTFChars(s, "    threadingModel=\"Both\""+Environment.NewLine, offset);
                        // attribute class
                        WriteUTFChars(s, "    name=\""+name+"\""+Environment.NewLine, offset);
                        // attribute runtimeVersion
                        WriteUTFChars(s, "    runtimeVersion=\""+strRuntimeVersion+"\">" + Environment.NewLine, offset);
                        WriteUTFChars(s, "</clrClass>"+Environment.NewLine, offset);
                    }
                }
                else
                {
                     // public, non-imported from COM's interface need to be in the manifest
                    if (bGenerateTypeLib && t.IsInterface && t.IsPublic && !t.IsImport)
                    {
                        String strIID = "{"+Marshal.GenerateGuidForType(t).ToString().ToUpper()+"}";
                        WriteUTFChars(s, "<comInterfaceExternalProxyStub"+Environment.NewLine, offset);
                        WriteUTFChars(s, "iid=\""+strIID+"\""+Environment.NewLine, offset + 4);                        
                        // Should t.FullName be used here?
                        // Seems t.Name matches what regasm does.
                        WriteUTFChars(s, "name=\""+t.Name+"\""+Environment.NewLine, offset + 4);
                        WriteUTFChars(s, "numMethods=\""+t.GetMethods().Length+"\""+Environment.NewLine, offset + 4);
                        // Seems regasm puts this guid for every interface. 
                        // Correct it if this is not true
                        WriteUTFChars(s, "proxyStubClsid32=\"{00020424-0000-0000-C000-000000000046}\""+Environment.NewLine, offset + 4);
                        WriteUTFChars(s, "tlbid=\""+strTlbId+"\" />"+Environment.NewLine, offset + 4);
                    }
                }
            }
        }

        private static void WriteAsmIDElement(Stream s, Assembly assembly, int offset)
        {
            AssemblyName asmName = assembly.GetName();
            // attribute version
            String version = asmName.Version.ToString();
            // attribute name
            String name = asmName.Name;
            // attribute publicKey, ignore it
            // byte[] publicKey = asmName.GetPublicKey();
            // attribute publicKeyToken
            byte[] publicKeyToken = asmName.GetPublicKeyToken();
            // attribute language
            String language = asmName.CultureInfo.ToString();
            // attribute type, ignore it
            //String type = "win32";
            
            WriteUTFChars(s, "<assemblyIdentity" + Environment.NewLine, offset);
            WriteUTFChars(s, "    name=\""+name+"\""+Environment.NewLine, offset);
            WriteUTFChars(s, "    version=\""+version+"\"", offset);
            if (publicKeyToken != null && publicKeyToken.Length != 0)
            {
                WriteUTFChars(s, Environment.NewLine);
                WriteUTFChars(s, "    publicKeyToken=\"", offset);
                WriteUTFChars(s, publicKeyToken);
                WriteUTFChars(s, "\"");
            }

            if (language=="") 
                WriteUTFChars(s, " />"+Environment.NewLine);
            else 
            {
                WriteUTFChars(s, Environment.NewLine);
                WriteUTFChars(s, "    language=\""+language+"\" />"+Environment.NewLine, offset);
            }
        }

        private static void WriteUTFChars(Stream s, byte[] bytes)
        {
            foreach(byte b in bytes)
                WriteUTFChars(s, b.ToString("x2"));
        }

        private static void WriteUTFChars(Stream s, String value, int offset)
        {
            for(int i=0;i<offset;i++)
            {
                WriteUTFChars(s," ");
            }
            WriteUTFChars(s, value);
        }

        private static void WriteUTFChars(Stream s, String value)
        {
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(value);
            s.Write(bytes, 0, bytes.Length);
        }
        
        private static bool ContainsEmbeddedTlb(String strFileName)
        {
            UCOMITypeLib Tlb = null;

            try
            {
                LoadTypeLibEx(strFileName, REGKIND.REGKIND_NONE, out Tlb);
            }
            catch (Exception)
            {
            }
    
            return Tlb != null ? true : false;
        }
        
        private static String GetAssemblyIdentity(String fileName)
        {
            IntPtr hInst = (IntPtr) 0;
            IntPtr hRes = (IntPtr) 0;
            IntPtr hGlobal = (IntPtr) 0;
            IntPtr hMem = (IntPtr) 0;
            String strAsmId = null;
    
            try
            {
                hInst = LoadLibrary(fileName);
                if (hInst == (IntPtr) 0)
                    throw new ApplicationException("Fail to load library "+fileName+".");
    
                hRes = FindResource(hInst, 1, 24); //type RT_MANIFEST, ID 1
                if (hRes == (IntPtr) 0)
                    throw new ApplicationException("Win32 Manifest does not exist in "+fileName+".");
    
                hGlobal = LoadResource(hInst, hRes);
                if (hGlobal == (IntPtr) 0)
                    throw new ApplicationException("Fail to load win32 manifest in "+fileName+".");
    
                hMem = LockResource(hGlobal);
    
                int cbSize = SizeofResource(hInst, hRes);
                if (cbSize == 0)
                    throw new ApplicationException("Win32 manifest of "+fileName+" has length 0!");
    
                String strMan = Marshal.PtrToStringAnsi(hMem);
                int idStart = strMan.IndexOf("<assemblyIdentity", 0);
                int idEnd = strMan.IndexOf("/>", idStart);
                strAsmId = strMan.Substring(idStart, idEnd+2-idStart);
            } 
            finally
            {
                if (hGlobal != (IntPtr) 0)
                    FreeResource(hGlobal);
                if (hInst != (IntPtr) 0)
                    FreeLibrary(hInst);
            }
    
            return strAsmId;
        }
    
            
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr LoadLibrary(String strLibrary);
    
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern void FreeLibrary(IntPtr ptr);
    
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr FindResource(IntPtr hInst, int idType, int idRes);
    
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr LoadResource(IntPtr hInst, IntPtr hRes);
    
    
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern IntPtr LockResource(IntPtr hGlobal);
    
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern int SizeofResource(IntPtr hInst, IntPtr hRes);
        
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        private static extern void FreeResource(IntPtr hGlobal);

        [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
        private static extern void LoadTypeLibEx(String strTypeLibName, REGKIND regKind, out UCOMITypeLib TypeLib);
       
    } // end of class GenMan32

    internal class Helper : MarshalByRefObject
    {
        internal void GenerateWin32ManifestFile(String strAssemblyManifestFileName, String strAssemblyName, bool bGenerateTypeLib, String strReferenceFiles)
        {
            GenMan32Code.GenerateWin32ManifestFile(strAssemblyManifestFileName, strAssemblyName, bGenerateTypeLib, strReferenceFiles);
        }

        internal UCOMITypeLib GenerateTypeLib(String strAssemblyName, ref String strTlbName)
        {
            return GenMan32Code.GenerateTypeLib(strAssemblyName, ref strTlbName);
        }
    }

    [GuidAttribute("00020406-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComVisible(false)]
    [ComImport]
    internal interface UCOMICreateITypeLib
    {
        void CreateTypeInfo();       
        void SetName();       
        void SetVersion();        
        void SetGuid();
        void SetDocString();
        void SetHelpFileName();        
        void SetHelpContext();
        void SetLcid();
        void SetLibFlags();
        void SaveAllChanges();
    }

    internal class ExporterCallback : ITypeLibExporterNotifySink
    {
        public void ReportEvent(ExporterEventKind EventKind, int EventCode, String EventMsg)
        {
            if (!GenMan32Main.s_Options.m_bSilentMode)
                Console.WriteLine(EventMsg);
        }
    
        public Object ResolveRef(Assembly asm)
        {
            UCOMITypeLib rslt = null;

            Module[] aModule = asm.GetLoadedModules();
            String asmPath = Path.GetDirectoryName(aModule[0].FullyQualifiedName);

            // If the typelib name is null then create it from the assembly name.
            String FullyQualifiedTypeLibName = Path.Combine(asmPath, asm.GetName().Name) + ".tlb.tmp";
            
            // Export the typelib for the module.
            rslt = GenMan32Code.GenerateTypeLib(asm, ref FullyQualifiedTypeLibName);

            return rslt;
        }
    }   

} // end of namespace GenMan32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genpubcfg\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_link: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genman32\commandline.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections;
using System.Globalization;

namespace GenMan32 {

internal class Option
{
    private String m_strName;
    private String m_strValue;

    public Option(String strName, String strValue)
    {
        m_strName = strName;
        m_strValue = strValue;
    }

    public String Name { get { return m_strName; } }
    public String Value { get { return m_strValue; } }
}

internal class Abbrevs
{
    private String[] m_aOptions;
    private bool[] m_bRequiresValue;
    private bool[] m_bCanHaveValue;

    public Abbrevs(String[] aOptions)
    {
        m_aOptions = new String[aOptions.Length];
        m_bRequiresValue = new bool[aOptions.Length];
        m_bCanHaveValue = new bool[aOptions.Length];

        // Store option list in lower case for canonical comparison.
        for (int i = 0; i < aOptions.Length; i++)
        {
            String strOption = aOptions[i].ToLower(CultureInfo.InvariantCulture);

            // A leading '*' implies the option requires a value
            // (the '*' itself is not stored in the option name).
            if (strOption.StartsWith("*"))
            {
                m_bRequiresValue[i] = true;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }
            else if (strOption.StartsWith("+"))
            {
                m_bRequiresValue[i] = false;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }

            m_aOptions[i] = strOption;
        }
    }

    public String Lookup(String strOpt, out bool bRequiresValue, out bool bCanHaveValue)
    {
        String strOptLower = strOpt.ToLower(CultureInfo.InvariantCulture);
        int i;
        bool bMatched = false;
        int iMatch = -1;

        // Compare option to stored list.
        for (i = 0; i < m_aOptions.Length; i++)
        {
            // Exact matches always cause immediate termination of
            // the search (else with options foo and foobar, the user
            // could never specify foo unambiguously).
            if (strOptLower.Equals(m_aOptions[i]))
            {
                bRequiresValue = m_bRequiresValue[i];
                bCanHaveValue = m_bCanHaveValue[i];
                return m_aOptions[i];
            }

            // Check for potential match (the input word is a prefix
            // of the current stored option).
            if (m_aOptions[i].StartsWith(strOptLower))
            {
                // If we've already seen a prefix match then the
                // input word is ambiguous.
                if (bMatched)
                    throw new ApplicationException("Error: Ambiguous option: " + strOpt);

                // Remember this partial match.
                bMatched = true;
                iMatch = i;
            }
        }

        // If we get here with bMatched set, we saw one and only one
        // partial match, so we've got a winner.
        if (bMatched)
        {
            bRequiresValue = m_bRequiresValue[iMatch];
            bCanHaveValue = m_bCanHaveValue[iMatch];
            return m_aOptions[iMatch];
        }

        // Else the word doesn't match at all.
        throw new ApplicationException("Error: Unknown Option");
    }
}

internal class CommandLine
{
    private String[] m_aArgList;
    private Option[] m_aOptList;
    private int m_iArgCursor;
    private int m_iOptCursor;
    private Abbrevs m_sValidOptions;

    public CommandLine(String[] aArgs, String[] aValidOpts)
    {
        int i, iArg, iOpt;

        // Keep a list of valid option names.
        m_sValidOptions = new Abbrevs(aValidOpts);

        // Temporary lists of raw arguments and options and their
        // associated values.
        String[] aArgList = new String[aArgs.Length];
        Option[] aOptList = new Option[aArgs.Length];

        // Reset counters of raw arguments and option/value pairs found
        // so far.
        iArg = 0;
        iOpt = 0;

        // Iterate through words of command line.
        for (i = 0; i < aArgs.Length; i++)
        {
            // Check for option or raw argument.
            if (aArgs[i].StartsWith("/") ||
                aArgs[i].StartsWith("-"))
            {
                String strOpt;
                String strVal = null;
                bool bRequiresValue;
                bool bCanHaveValue;

                // It's an option. Strip leading '/' or '-' and
                // anything after a value separator (':' or
                // '=').
                int iColon = aArgs[i].IndexOfAny(new char[] {':', '='});
                if (iColon == -1)
                        strOpt = aArgs[i].Substring(1);
                else
                        strOpt = aArgs[i].Substring(1, iColon - 1);

                // Look it up in the table of valid options (to
                // check it exists, get the full option name and
                // to see if an associated value is expected).
                strOpt = m_sValidOptions.Lookup(strOpt, out bRequiresValue, out bCanHaveValue);

                // Check that the user hasn't specified a value separator for an option 
                // that doesn't take a value.
                if (!bCanHaveValue && (iColon != -1))
                    throw new ApplicationException("Error: " + strOpt + ": No Value Required");

                // Check that the user has put a colon if the option requires a value.
                if (bRequiresValue && (iColon == -1))
                    throw new ApplicationException("Error: " + strOpt + ": Value Required");
                
                // Go look for a value if there is one.
                if (bCanHaveValue && iColon != -1)
                {
                    if (iColon == (aArgs[i].Length - 1))
                    {
                        // No value separator, or
                        // separator is at end of
                        // option; look for value in
                        // next command line arg.
                        if (i + 1 == aArgs.Length)
                        {
                            throw new ApplicationException("Error: "+strOpt+": Value Required");
                        }
                        else
                        {
                            if ((aArgs[i + 1].StartsWith( "/" ) || aArgs[i + 1].StartsWith( "-" )))
                                throw new ApplicationException("Error: "+strOpt+": Value Required");

                            strVal = aArgs[i+1];
                            i++;
                        }
                    }
                    else
                    {
                        // Value is in same command line
                        // arg as the option, substring
                        // it out.
                        strVal = aArgs[i].Substring(iColon + 1);
                    }
                }

                // Build the option value pair.
                aOptList[iOpt++] = new Option(strOpt, strVal);
            }
            else
            {
                // Command line word is a raw argument.
                aArgList[iArg++] = aArgs[i];
            }
        }

        // Allocate the non-temporary arg and option lists at exactly
        // the right size.
        m_aArgList = new String[iArg];
        m_aOptList = new Option[iOpt];

        // Copy in the values we've calculated.
        Array.Copy(aArgList, m_aArgList, iArg);
        Array.Copy(aOptList, m_aOptList, iOpt);

        // Reset enumeration cursors to start of lists.
        m_iArgCursor = 0;
        m_iOptCursor = 0;
    }

    public int NumArgs { get { return m_aArgList.Length; } }

    public int NumOpts { get { return m_aOptList.Length; } }

    public String GetNextArg()
    {
        if (m_iArgCursor >= m_aArgList.Length)
            return null;
        return m_aArgList[m_iArgCursor++];
    }

    public Option GetNextOption()
    {
        if (m_iOptCursor >= m_aOptList.Length)
            return null;
        return m_aOptList[m_iOptCursor++];
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\icecapapi\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\IceCapAPI.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\icecapapi\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "IceCapAPI.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime IceCapAPI Wrappper\0"
#define VER_ORIGFILENAME_STR    "IceCapAPI.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genpubcfg\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "GenPubCfg.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft Publisher Policy Generator\0"
#define VER_ORIGFILENAME_STR    "GenPubCfg.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\icecapapi\icecapapi.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// IceCap API COM+ Wrapper
// This COM+ class wraps the IceCap API for the unmanaged native functions
// described in IceCap.h . See the IceCAP 4 User's guide for more information.
//

using System.Runtime.InteropServices;   // StructLayout, etc.

public class IceCapAPI
{

    public const int PROFILE_GLOBALLEVEL = 1;
    public const int PROFILE_PROCESSLEVEL = 2;
    public const int PROFILE_THREADLEVEL = 3;
    public const int PROFILE_CURRENTID = -1;
    
// Start/Stop Api's
    [DllImport("icecap")]
    public static extern int StopProfile(int nLevel, int dwId);

    [DllImport("icecap")]
    public static extern int StartProfile(int nLevel, int dwId);

// Suspend/Resume Api's
    [DllImport("icecap")]
    public static extern int SuspendProfile(int nLevel, int dwId);

    [DllImport("icecap")]
    public static extern int ResumeProfile(int nLevel, int dwId);

    
    // xxxProfile return codes
    public const int PROFILE_OK                         = 0;    // xxxProfile call successful
    public const int PROFILE_ERROR_NOT_YET_IMPLEMENTED  = 1;    // api or level,id combination not supported yet
    public const int PROFILE_ERROR_MODE_NEVER           = 2;    // mode was never when called
    public const int PROFILE_ERROR_LEVEL_NOEXIST        = 3;    // level doesn't exist
    public const int PROFILE_ERROR_ID_NOEXIST           = 4;    // id doesn't exist

    // MarkProfile return codes
    public const int MARK_OK                            = 0;    // Mark was taken successfully
    public const int MARK_ERROR_MODE_NEVER              = 1;    // Profiling was never when MarkProfile called
    public const int MARK_ERROR_MODE_OFF                = 2;    // Profiling was off when MarkProfile called
    public const int MARK_ERROR_MARKER_RESERVED         = 3;    // Mark value passed is a reserved value
    public const int MARK_TEXTTOOLONG                   = 4;    // Comment text was truncated

    // NameProfile return codes
    public const int NAME_OK                            = 0;    // Name was registered sucessfullly
    public const int NAME_ERROR_TEXTTRUNCATED           = 1;    // The name text was too long and was therefore truncated
    public const int NAME_ERROR_REDEFINITION            = 2;    // The given profile element has already been named
    public const int NAME_ERROR_LEVEL_NOEXIST           = 3;    // level doesn't exist
    public const int NAME_ERROR_ID_NOEXIST              = 4;    // id doesn't exist
    public const int NAME_ERROR_INVALID_NAME            = 5;    // name does not meet the specification's requirements





// Icecap 3.x Compatibility defines
    public static int StartCAP() 
    {
        return StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
    }

    public static int StopCAP() 
    {   
        return StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
    }

    public static int SuspendCAP() 
    {
        return SuspendProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
    }

    public static int ResumeCAP() 
    {
        return ResumeProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
    }

    public static int StartCAPAll() 
    {
        return StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
    }

    public static int StopCAPAll() 
    {
        return StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
    }

    public static int SuspendCAPAll() 
    {
        return SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
    }

    public static int ResumeCAPAll() 
    {
        return ResumeProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ieexec\ieexec\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_link: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ieexec\ieexecremote\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_link: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\IEExecRemote.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ieexec\ieexec\ieexec.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: IEExecute
**
** Purpose: Used to setup the correct IE hosting environment before executing an
**          assembly
**
** Date: April 28, 1999
**
=============================================================================*/
[assembly: System.Runtime.InteropServices.ComCompatibleVersion(1,0,3300,0)]
[assembly: System.Runtime.InteropServices.TypeLibVersion(1,10)] 


namespace IEHost.Execute {

    using System;
    using System.Text;
    using System.Reflection;
    using System.Runtime.Remoting;
    using System.Globalization;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;
    using AssemblyHashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm;
    
    class IEExecute 
    {
    
        private static bool FailRebinds(PermissionSet psAllowed)
        {
            bool noRebinds = true;  
            if(psAllowed != null) {
                if(psAllowed.IsUnrestricted())
                    noRebinds = false;
                else {
                    SecurityPermission sp = (SecurityPermission) psAllowed.GetPermission(typeof(SecurityPermission));
                    if(sp != null && ((sp.Flags & SecurityPermissionFlag.BindingRedirects) != 0))
                        noRebinds = false;
                }
            }
            return noRebinds;
        }

        internal static string GetSiteName(string pURL) 
        {
            string siteName = null;
            if(pURL != null) {
                int j = pURL.IndexOf(':');  
                
                // If there is a protocal remove it. In a URL of the form
                // yyyy://xxxx/zzzz   where yyyy is the protocal, xxxx is
                // the site and zzzz is extra we want to get xxxx.
                if(j != -1 && 
                   j+3 < pURL.Length &&
                   pURL[j+1] == '/' &&
                   pURL[j+2] == '/') 
                    {
                        j+=3;
                        
                        // Remove characters after the
                        // next /.  
                        int i = pURL.IndexOf('/',j);
                        if(i > -1) 
                            siteName = pURL.Substring(j,i-j);
                        else 
                            siteName = pURL.Substring(j);
                    }
            
                if(siteName == null)
                    siteName = pURL;
            }
            return siteName;
        }
    
        internal static byte[] DecodeHex(string hexString) {
            if (hexString != null)
            {
                if (hexString.Length%2!=0)
                    throw new ArgumentException("hexString");
                byte[] sArray = new byte[(hexString.Length / 2)];
                int digit;
                int rawdigit;
                for (int i = 0, j = 0; i < hexString.Length; i += 2, j++) {
                    digit = ConvertHexDigit(hexString[i]);
                    rawdigit = ConvertHexDigit(hexString[i+1]);
                    sArray[j] = (byte) (digit | (rawdigit << 4));
                }
                return(sArray);
            }

            return new byte[0];
        }
        internal static int ConvertHexDigit(char val) {
            if (val <= '9') return (val - '0');
            return ((val - 'A') + 10);
        }
        
        // Arguments: Codebase, flags, zone, uniqueid
        // If the flags indicate zone then a zone must be provided. 
        // If the flags indicate a site then a uniqueid must be provided
        internal static int Main(string[] args)
        {

            if(args.Length != 1)
                throw new ArgumentException();

            int index = 0;

            string file = args[index++];
            if ((file.Length == 0) || (file[0] == '\0'))
                throw new ArgumentException();

            string hashString = null;
            byte[] hash = null; 

            int r = file.LastIndexOf("#");
            if(r != -1 & r != (file.Length - 1)) {
                hashString = file.Substring(r+1);
                file = file.Substring(0, r);
                hash = DecodeHex(hashString);
            }

            
            // Find the URL of the executable. For now we assume the 
            // form to be http://blah/... with forward slashes. This
            // need to be update.
            string URL;
            string ConfigurationFile = null;
            int k = file.LastIndexOf('/');
            if(k == -1) {
                URL = file;
                ConfigurationFile = file;
            }
            else {
                URL = file.Substring(0,k+1);
                if(k+1 < file.Length) 
                    ConfigurationFile = file.Substring(k+1);
            }
            
            // Build up the configuration File name
            if(ConfigurationFile != null) {
                StringBuilder bld = new StringBuilder();
                bld.Append(ConfigurationFile);
                bld.Append(".config");
                ConfigurationFile = bld.ToString();
            }
            
            string friendlyName = GetSiteName(file);
            Evidence documentSecurity = null;

            documentSecurity = new Evidence();
            Zone zone= Zone.CreateFromUrl(file);
            if (zone.SecurityZone==SecurityZone.MyComputer)
                throw new ArgumentException();
            documentSecurity.AddHost(zone);
            if (file.Length<7||String.Compare(file.Substring(0,7),"file://",true, CultureInfo.InvariantCulture)!=0)
                documentSecurity.AddHost( System.Security.Policy.Site.CreateFromUrl(file) );
            else
                throw new ArgumentException();
            documentSecurity.AddHost( new Url(file) );

            AppDomainSetup properties = new AppDomainSetup();
            PermissionSet ps = SecurityManager.ResolvePolicy(documentSecurity);
            if(FailRebinds(ps)) {
                properties.DisallowBindingRedirects = true;
            }
            else {
                properties.DisallowBindingRedirects = false;
            }
            properties.ApplicationBase = URL;
            properties.PrivateBinPath = "bin";
            if(ConfigurationFile != null)
                properties.ConfigurationFile = ConfigurationFile;

            AppDomain proxy = AppDomain.CreateDomain(friendlyName,
                                                     documentSecurity,
                                                     properties);
            if(proxy != null) 
            {

                AssemblyName caller = Assembly.GetExecutingAssembly().GetName();
                AssemblyName remote = new AssemblyName();
                remote.Name = "IEExecRemote";
                remote.SetPublicKey(caller.GetPublicKey());
                remote.Version = caller.Version;
                remote.CultureInfo=CultureInfo.InvariantCulture; 
                proxy.SetData("APP_LAUNCH_URL",file);
                ObjectHandle handle = proxy.CreateInstance(remote.FullName, "IEHost.Execute.IEExecuteRemote");
                if (handle != null) 
                {
                    IEExecuteRemote execproxy = (IEExecuteRemote)handle.Unwrap();
                    if (execproxy != null)
                    {
                        int res= execproxy.ExecuteAsAssembly(file, documentSecurity, hash, AssemblyHashAlgorithm.SHA1);
                        Stream streamedexception =execproxy.Exception;
                        if(streamedexception!=null)
                        {
                                BinaryFormatter formatter = new BinaryFormatter();
                                Exception e =(Exception)formatter.Deserialize(streamedexception);
                                throw e;
                        }
                        return res;
                    }
                }
            } 
            return -1;           
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ieexec\ieexec\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "IEEXEC.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft IE Execute shell\0"
#define VER_ORIGFILENAME_STR    "IEExec.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\genpubcfg\genpubcfg.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// genpubcfg.cs:  
//                
// Author : Alan Shi (AlanShi)
// Date   : 12 Dec 00
//
// Description:
//    GenPubCfg will reads an input file containing a list of assemblies.
//    For each assembly listed in the input file, a specified directory is
//    searched to locate the assembly. The version information of the assembly
//    found in this directory is compared to a user-specified (or hard-coded
//    default) version. If the versions match, then nothing is done.
//
//    If the versions do not match, then a publisher policy configuration
//    file is created that redirects the user-specified version to the
//    version in the actual assembly. The config file is wrapped as an
//    assembly, and installed into the global assembly cache.
//
//    An output file list is generated containing the list of all publisher
//    policy assemblies created in the form:
//  
//    [publisherPolicyAssembly.dll]:[Display Name of Publisher Policy Assembly]
//
//    The default output filename is output.txt. This output file can later
//    be used for uninstall purposes (GenPubCfg -u).
//

using System;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using System.Text;
using System.Globalization;

namespace PolicyGenerator
{
    public class GenPubCfg
    {
        const string strDefaultVer = "1.0.2411.0";
        const string strOutputFileListDefault = "output.txt";
        const string strKeyFileDefault = "finalpublickey.snk";
        const string strAsmDirDefault = ".";
        const string strPubAsmVersionDefault = "1.0.0.0";
        
        const string strCfgHeader = "<configuration>\n" +
                                    "    <runtime>\n" +
                                    "        <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">";

        const string strCfgFooter = "        </assemblyBinding>\n" +
                                    "    </runtime>\n" +
                                    "</configuration>";

        const string strDepAsmStart = "          <dependentAssembly>";
        const string strDepAsmEnd   = "          </dependentAssembly>";
        const string strAsmIdentity = "              <assemblyIdentity name=\"{0}\" publicKeyToken=\"{1}\" culture=\"{2}\"/>";
        const string strRedir       = "              <bindingRedirect oldVersion=\"{0}-{1}\" newVersion=\"{1}\"/>";

        public static int Main(string[] args)
        {
            FileStream                          fStreamRead;
            FileStream                          fStreamWrite;
            StreamReader                        reader;
            StreamWriter                        writer = null;
            Encoding                            enc = new UTF8Encoding(false);
            bool                                bRet;
            string                              strFileList = "";
            string                              strAsmDir = "";
            string                              strOldVersion = "";
            string                              strCurAsm = "";
            string                              strPubAsmVersion = "";
            string                              strKeyFile = "";
            string                              strOutputFileName = "";
            bool                                bUninstall = false;

            bRet = ParseArgs(args, ref strFileList, ref strAsmDir, ref strOldVersion,
                             ref strKeyFile, ref strPubAsmVersion, ref strOutputFileName,
                             ref bUninstall);
            if (bRet == false) {
                Console.WriteLine("USAGE: genpubcfg [args]");
                Console.WriteLine(" *   -f:<input file list>");
                Console.WriteLine("     -d:<assemblies directory>");
                Console.WriteLine("     -k:<key file to sign publisher policy asm>");
                Console.WriteLine("     -v:<publisher policy assembly version>");
                Console.WriteLine("     -u:<uninstall from output file list>");
                Console.WriteLine("     -ov:<old version>");
                Console.WriteLine("     -out:<output file list>\n");
                Console.WriteLine("Options marked with a \"*\" are required parameters.\n");
                Console.WriteLine("Default values: -k:{0}", strKeyFileDefault);
                Console.WriteLine("                -out:{0}", strOutputFileListDefault);
                Console.WriteLine("                -d:{0}", strAsmDirDefault);
                Console.WriteLine("                -v:{0}", strPubAsmVersionDefault);
                Console.WriteLine("                -ov:{0}", strDefaultVer);
                return 0;
            }

            try {
                fStreamRead = new FileStream(strFileList, FileMode.Open);
                reader = new StreamReader(fStreamRead);
            }
            catch (FileNotFoundException) {
                Console.WriteLine("Unable to find input file: {0}", strFileList);
                return 0;
            }

            if (bUninstall == false) {
                fStreamWrite = new FileStream(strOutputFileName, FileMode.Create);
                writer = new StreamWriter(fStreamWrite, enc);
            }

            GetNextAssembly(reader, ref strCurAsm);

            while (strCurAsm != null) {
                if (bUninstall == false) {
                    bRet = WriteCfgFile(writer, strAsmDir, strCurAsm,
                                        strOldVersion, strKeyFile,
                                        strPubAsmVersion);
                    if (!bRet) {
                        Console.WriteLine("Failed to create publisher policy for {0}", strCurAsm);
                    }
                }
                else {
                    string[]                 strUninstall = strCurAsm.Split(':');

                    if (strUninstall.Length != 2) {
                        Console.WriteLine("Warning: Ignoring malformed uninstall data {0}", strCurAsm);
                    }
                    else {
                        bRet = UninstallAssembly(strUninstall[1]);
                        if (!bRet) {
                            Console.WriteLine("Failed to uninstall {0}", strCurAsm);
                        }
                        else {
                            Console.WriteLine("Successfully uninstalled publisher policy {0}", strCurAsm);
                        }
                    }
                }

                GetNextAssembly(reader, ref strCurAsm);
            }

            // Close reader/writer streams

            reader.Close();

            if (bUninstall == false) {
                writer.Close();
            }
            
            return 1;
        }

        public static bool UninstallAssembly(string strAsmDisplayName)
        {
            ProcessStartInfo                  psi;
            Process                           proc;
            bool                              bRet;
            string                            args;

            args = String.Format("-u {0}", strAsmDisplayName);

//            Console.WriteLine("executing: gacutil.exe {0}", args);
            
            psi = new ProcessStartInfo("gacutil.exe", args);
            psi.CreateNoWindow = true;
            psi.UseShellExecute = false;

            proc = Process.Start(psi);
            proc.WaitForExit();

            bRet = (proc.ExitCode == 0);

            return bRet;
        }

        public static bool InstallAssembly(string strAsmPath)
        {
            ProcessStartInfo                  psi;
            Process                           proc;
            bool                              bRet;
            string                            args;

            args = String.Format("-i {0}", strAsmPath);

//            Console.WriteLine("executing: gacutil.exe {0}", args);
            
            psi = new ProcessStartInfo("gacutil.exe", args);
            psi.CreateNoWindow = true;
            psi.UseShellExecute = false;

            proc = Process.Start(psi);
            proc.WaitForExit();

            bRet = (proc.ExitCode == 0);

            return bRet;
        }

        public static bool ExtractPath(string[] arg, ref string strOut)
        {
            if (arg.Length < 2) {
                 return false;
            }

            strOut = arg[1];

            if (arg.Length == 3) {
                strOut += ":";
                strOut += arg[2];
            }
            else if (arg.Length > 3) {
                // Invalid path. More than 1 colon in the path!
                return false;
            }

            return true;
        }

        public static void GetNextAssembly(StreamReader reader, ref string strNextAsm)
        {
            // For now, assume each line only contains the filename.

            strNextAsm = reader.ReadLine();
        }

        public static bool WriteCfgFile(StreamWriter writerOutput,
                                        string strAsmDir, string strAsmName,
                                        string strOldVersion, string strKeyFile,
                                        string strPubAsmVersion)
        {
            Assembly                          asmCur;
            AssemblyName                      anameCur;
            FileStream                        fStream;
            StreamWriter                      writer;
            Encoding                          enc = new UTF8Encoding(false);
            string                            strPolicyName;
            string                            strCfgName;
            string                            strPubAsmName;
            string                            strPKT;
            Version                           verOld = new Version(strOldVersion);
            Byte[]                            publicKeyToken;
            bool                              bRet = true;

            try {
                asmCur = Assembly.LoadFrom(strAsmDir + strAsmName);
                anameCur = asmCur.GetName();
                publicKeyToken = anameCur.GetPublicKeyToken();
    
                if (verOld.CompareTo(anameCur.Version) >= 0) {
                    // If compare==0, then nothing to do. If compare > 0, then
                    // we're downgrading (don't write the policy files in this
                    // case).

                    return true;
                }
    
                strPolicyName = String.Format("policy.{0}.{1}.{2}", anameCur.Version.Major, anameCur.Version.Minor, anameCur.Name);
                strCfgName = strPolicyName + ".cfg";
                strPubAsmName = strPolicyName + ".dll";
    
                strPKT = "";
                foreach (Byte curByte in publicKeyToken) {
                    strPKT += curByte.ToString("X02");
                }
    
                fStream = new FileStream(strCfgName, FileMode.Create);
                writer = new StreamWriter(fStream, enc);
    
                writer.WriteLine(strCfgHeader);
                writer.WriteLine(strDepAsmStart);
                writer.WriteLine(strAsmIdentity, anameCur.Name, strPKT, anameCur.CultureInfo);
                writer.WriteLine(strRedir, strOldVersion, anameCur.Version);
                writer.WriteLine(strDepAsmEnd);
                writer.WriteLine(strCfgFooter);
    
                writer.Close();
    
                bRet = CreateAssembly(strCfgName, strPubAsmName, strKeyFile, strPubAsmVersion);
                if (bRet == true) {
                    bRet = InstallAssembly(strPubAsmName);
                }
                
                if (bRet == true) {
                    try {
                        Assembly          asmPubPolicy = Assembly.LoadFrom(strPubAsmName);
                        string            strDisplayName = asmPubPolicy.ToString();
                        string            strDisplayNameTrimmed = strDisplayName.Replace(" ", "");
                        string            strOutput = strPubAsmName + ":" + strDisplayNameTrimmed;

                        writerOutput.WriteLine(strOutput);

                        Console.WriteLine("Installed publisher policy: {0}", strPubAsmName);
                    }
                    catch (FileNotFoundException) {
                        Console.WriteLine("Unable to load generated publisher policy assembly {0}", strPubAsmName);
                    }
                }
            }
            catch (FileNotFoundException) {
                Console.WriteLine("Unable to find : {0}", strAsmDir + strAsmName);
            }

            return bRet;
        }

        static bool CreateAssembly(string strCfgName, string strPubAsmName, string strKeyFile, string strPubAsmVersion)
        {
            ProcessStartInfo                  psi;
            Process                           proc;
            bool                              bRet;
            string                            args;

            args = String.Format("/delay+ /link:{0} /out:{1} /keyf:{2} /v:{3}", strCfgName, strPubAsmName, strKeyFile, strPubAsmVersion);

//            Console.WriteLine("executing: al.exe {0}", args);
            
            psi = new ProcessStartInfo("al.exe", args);
            psi.CreateNoWindow = true;
            psi.UseShellExecute = false;

            proc = Process.Start(psi);
            proc.WaitForExit();

            bRet = (proc.ExitCode == 0);

            return bRet;
        }
        
        public static bool ParseArgs(string[] args, ref string strFileList, ref string strAsmDir, ref string strOldVersion,
                                     ref string strKeyFile, ref string strPubAsmVersion,
                                     ref string strOutputFileName, ref bool bUninstall)
        {
            string[]                           curArg;
            Version                            v;

            strFileList = "";
            strAsmDir = "";
            strOldVersion = "";
            strKeyFile = "";
            strOutputFileName = "";
            strPubAsmVersion = "";
            bUninstall = false;

            for (int i = 0; i < args.Length; i++) {
                curArg = args[i].Split(':');

                switch (curArg[0].ToLower(CultureInfo.InvariantCulture)) {
                    case "-k":
                        if (strKeyFile != "") {
                            return false;
                        }

                        if (ExtractPath(curArg, ref strKeyFile) == false) {
                            return false;
                        }
                        
                        break;

                    case "-out":
                        if (strOutputFileName != "") {
                            return false;
                        }

                        if (ExtractPath(curArg, ref strOutputFileName) == false) {
                            return false;
                        }

                        break;

                    case "-v":
                        if (strPubAsmVersion != "") {
                            return false;
                        }

                        // Make sure version is ok by converting to version,
                        // and back to string
                        
                        v = new Version(curArg[1]);
                        strPubAsmVersion = v.ToString();

                        break;
                        
                    case "-f":
                        if (strFileList != "") {
                            return false;
                        }
                        
                        if (ExtractPath(curArg, ref strFileList) == false) {
                            return false;
                        }

                        break;

                    case "-d":
                        if (strAsmDir != "") {
                            return false;
                        }
                        
                        if (ExtractPath(curArg, ref strAsmDir) == false) {
                            return false;
                        }

                        break;

                    case "-ov":
                        if (strOldVersion != "") {
                            return false;
                        }
                        
                        if (curArg.Length != 2) {
                            return false;
                        }

                        strOldVersion = curArg[1];
                        v = new Version(strOldVersion);

//                        Console.WriteLine("version: {0}.{1}.{2}.{3}", v.Major, v.Minor, v.Revision, v.Build);

                        break;
                    case "-u":
                        if (bUninstall == true) {
                            return false;
                        }

                        bUninstall = true;
                        break;

                    default:
                        // Unknown option
                        return false;
                }
            }

            // Check if we are uninstalling. If so, no additional parameters
            // are allowed

            if (bUninstall == true) {
                if (strOutputFileName != "" || strAsmDir != "" || strKeyFile != "" ||
                    strPubAsmVersion != "") {

                    return false;
                }

                if (strFileList == "") {
                    strFileList = strOutputFileListDefault;
                }

                return true;
            }

            // Not uninstalling, continue to valid parameters

            if (strFileList == "") {
                return false;
            }

            // If no old version specified, use default

            if (strOldVersion == "") {
                strOldVersion = strDefaultVer;
            }

            // If no key file specified, use default

            if (strKeyFile == "") {
                strKeyFile = strKeyFileDefault;
            }

            // If no dir specified, use current default

            if (strAsmDir == "") {
                strAsmDir = strAsmDirDefault;
            }

            // If no publisher policy asm version specified, use default.

            if (strPubAsmVersion == "") {
                strPubAsmVersion = strPubAsmVersionDefault;
            }

            // If no output filename specified, pick a default name.

            if (strOutputFileName == "") {
                strOutputFileName = strOutputFileListDefault;
            }

            // Append trailing backslash to asm dir if necessary

            if (strAsmDir[strAsmDir.Length - 1] != '\\') {
                strAsmDir += "\\";
            }

            return true;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ieexec\ieexecremote\ieexecremote.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: IEExecuteStub
**
** Purpose: Used to setup the correct IE hosting environment before executing an
**          assembly
**
** Date: April 28, 1999
**
=============================================================================*/

[assembly:System.Security.AllowPartiallyTrustedCallersAttribute()]
[assembly: System.Runtime.InteropServices.ComCompatibleVersion(1,0,3300,0)]
[assembly: System.Runtime.InteropServices.TypeLibVersion(1,10)] 

namespace IEHost.Execute {

    using System;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using AssemblyHashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.IO;
	using System.Threading;

    public class IEExecuteRemote  : MarshalByRefObject
    {

        private MemoryStream exception;
        public Stream Exception
        {
	        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293" )]
	        get 
	        {
		        return exception;
	        }
        }
        // This method must be internal, since it asserts the
        // ControlEvidence permission.
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293" )]
        public int ExecuteAsAssembly(string file, Evidence evidence, byte[] hash, AssemblyHashAlgorithm id)
        {
            new PermissionSet(PermissionState.Unrestricted).Assert();
            try 
            {
	            Assembly assembly = Assembly.LoadFrom(file, null, hash, id);
	            
	            ApartmentState apt=ApartmentState.Unknown; 

	            Object[] Attr = assembly.EntryPoint.GetCustomAttributes(typeof(STAThreadAttribute),false);
	            if (Attr.Length > 0)
			            apt=ApartmentState.STA;
	            Attr = assembly.EntryPoint.GetCustomAttributes(typeof(MTAThreadAttribute),false);
	            if (Attr.Length > 0)
		            if(apt==ApartmentState.Unknown)
			            apt=ApartmentState.MTA;
		            else
			            apt=ApartmentState.Unknown; 

	            if(apt!=ApartmentState.Unknown)
		            Thread.CurrentThread.ApartmentState=apt;
                return AppDomain.CurrentDomain.ExecuteAssembly(file, null, null, hash, id);
            }
            catch (Exception e)
            {
	            exception=new MemoryStream();
	            BinaryFormatter formatter = new BinaryFormatter();
	            formatter.Serialize(exception , e );
	            exception.Position=0;
                return -1;
            }
        }

        // This method must be internal, since it asserts the
        // ControlEvidence permission.
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293" )]
        public int ExecuteAsDll(string file, Evidence evidence, Object pars)
        {
            return -2147467263;  //E_NOTIMPL
        }

        public override object InitializeLifetimeService()
        {
            return null; 
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ieexec\ieexecremote\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "IEExecRemote.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft IE Remote shell\0"
#define VER_ORIGFILENAME_STR    "IEExecRemote.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\iehost\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_link: $(TARGETPATH)\$(TARGETNAME)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
	copy iehost.vrg $(TARGETCOMPLUS)
	copy iehost_shared.vrg $(TARGETCOMPLUS)
!endif

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\IEHost.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\iehost\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "IEHOST.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft IE hosting interface\0"
#define VER_ORIGFILENAME_STR    "IEHost.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\iehost\iemanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: IEHost
**
** Purpose: Create and manage application domains.
**
** Date: April 28, 1999
**
=============================================================================*/
//[assembly: System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.RequestMinimum, Name="Everything")]
[assembly: System.Runtime.InteropServices.ComCompatibleVersion(1,0,3300,0)]
[assembly: System.Runtime.InteropServices.TypeLibVersion(1,10)] 
namespace Microsoft.IE {
    using System;
    using System.Collections;
    using System.IO;
    using System.Globalization;
    using System.Security.Util;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using Microsoft.Win32;
    using System.Runtime.InteropServices;
    
    // 
    // Note: IIEHost is a COM Class interface
    [Guid("CA35CB3D-0357-11D3-8729-00C04F79ED0D")] 
    public class Manager: IHostEx
    {
        static Hashtable _DomainsByID;
        static int count = 1;
        static StreamWriter logFile = null;
        static readonly RegistryKey debugKey;
        static bool debug = false;
        static bool fOpened = false;
        static string logFileName = null;
      
        static Manager()
        {
            new PermissionSet( PermissionState.Unrestricted ).Assert();
            debugKey = Registry.LocalMachine.OpenSubKey("software\\microsoft\\.NETFramework");
        }

        static char[] separators = { '\\', '/' };
        public enum URL_PART {
            NONE       = 0,
            SCHEME     = 1,
            HOSTNAME,
            USERNAME,
            PASSWORD,
            PORT,
            QUERY,
        };
         
        public enum URL_CANONFLAGS
        {
            URL_UNESCAPE                    =0x10000000,
            URL_ESCAPE_UNSAFE               =0x20000000,
            URL_PLUGGABLE_PROTOCOL          =0x40000000,
            URL_WININET_COMPATIBILITY       =(int)-0x80000000,
            URL_DONT_ESCAPE_EXTRA_INFO      =0x02000000,
            URL_DONT_UNESCAPE_EXTRA_INFO    =URL_DONT_ESCAPE_EXTRA_INFO,
            URL_BROWSER_MODE                =URL_DONT_ESCAPE_EXTRA_INFO,
            URL_ESCAPE_SPACES_ONLY          =0x04000000,
            URL_DONT_SIMPLIFY               =0x08000000,
            URL_NO_META                     =URL_DONT_SIMPLIFY,
            URL_UNESCAPE_INPLACE            =0x00100000,
            URL_CONVERT_IF_DOSPATH          =0x00200000,
            URL_UNESCAPE_HIGH_ANSI_ONLY     =0x00400000,
            URL_INTERNAL_PATH               =0x00800000,  // Will escape #'s in paths
            URL_FILE_USE_PATHURL            =0x00010000,
            URL_ESCAPE_PERCENT              =0x00001000,
            URL_ESCAPE_SEGMENT_ONLY         =0x00002000  // Treat the entire URL param as one URL segment.
        };

        public enum URL_IS
        {
            URLIS_URL,
            URLIS_OPAQUE,
            URLIS_NOHISTORY,
            URLIS_FILEURL,
            URLIS_APPLIABLE,
            URLIS_DIRECTORY,
            URLIS_HASQUERY
        };

        public static readonly int INTERNET_MAX_PATH_LENGTH = 2048;
        public static readonly int INTERNET_MAX_SCHEME_LENGTH = 32;
        public static readonly int INTERNET_MAX_URL_LENGTH = INTERNET_MAX_SCHEME_LENGTH+3+INTERNET_MAX_PATH_LENGTH;

        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern int PathCreateFromUrl(String pUrl, StringBuilder path, int[] pathLength, int flags);

        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern int UrlGetPart(String pUrl, StringBuilder path, int[] pathLength, int part, int flags);

        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern bool PathIsURL(String pUrl);

        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern String PathFindFileName(String pUrl);

        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern int UrlCompare(string pszURL1, string pszURL2, bool fIgnoreSlash);

        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern int UrlCanonicalize(string pszUrl, StringBuilder pszCanonicalized, int[] pcchCanonicalized, int dwFlags);
 
        [DllImport("SHLWAPI", CharSet=CharSet.Auto)]
        internal static extern bool UrlIs(string pszUrl, URL_IS UrlIs);
 


        public Manager()
        {
            if(fOpened == false) {
                new RegistryPermission(PermissionState.Unrestricted).Assert();
                Object o = 0;
                Object value = debugKey.GetValue("DebugIEHost", o);
                if(((Int32)value) != 0) debug = true;
                fOpened = true;
            }
        }
        
        private void InitializeTable()
        {
            if(_DomainsByID == null) 
                _DomainsByID= new Hashtable(32);
        }
        
        internal static void Log(object ob, bool test, string success, string failure)
        {
            if(debug) {
                if(logFile == null) StartUpLog();

                logFile.WriteLine(ob.ToString() + ": " + (test ? success: failure));
                logFile.Flush();
            }
        }

        private static void Log(bool test, string success, string failure)
        {
            if(debug) {
                if(logFile == null) StartUpLog();

                logFile.WriteLine("Microsoft.IE.Manager: " + (test ? success: failure));
                logFile.Flush();
            }
        }

        internal static void StartUpLog() 
        {
            if(debug && logFile == null) {
                logFileName = (string) debugKey.GetValue("IEHostLogFile", "IEHost.log");

                new FileIOPermission(PermissionState.Unrestricted).Assert();
                FileStream stream = new FileStream(logFileName+count, 
                                                   FileMode.Create, 
                                                   FileAccess.ReadWrite,
                                                   FileShare.ReadWrite, 
                                                   4048);
                logFile = new StreamWriter(stream, new UTF8Encoding());
                logFile.WriteLine("Creating security manager\n");
                logFile.Flush();
            }
        }
          
        internal AppDomain LocateDomain(byte[] id, string document)
        {
            InitializeTable();
            
            IDKey k = new IDKey(id, document);
            
            AppDomain result = (AppDomain) _DomainsByID[k];
            Log(this, result == null, "The domain does not exist.", "The domain does exist.");
            return result;
        }

        internal void AddDomain(byte[] id, string document, AppDomain app)
        {
            InitializeTable();
            
            IDKey k = new IDKey(id, document);
            _DomainsByID.Add(k, app);
        }
        
        public static string GetSiteName(string pURL) 
        {
            
            string siteName = null;
            if(pURL != null) {
                int j = pURL.IndexOf(':');  
                
                // If there is a protocal remove it. In a URL of the form
                // yyyy://xxxx/zzzz   where yyyy is the protocal, xxxx is
                // the site and zzzz is extra we want to get xxxx.
                if(j != -1 && 
                   j+3 < pURL.Length &&
                   pURL[j+1] == '/' &&
                   pURL[j+2] == '/') 
                    {
                        j+=3;
                        
                        // Remove characters after the
                        // next /.  
                        int i = pURL.IndexOf('/',j);
                        if(i > -1) 
                            siteName = pURL.Substring(j,i-j);
                        else 
                            siteName = pURL.Substring(j);
                    }
            
                if(siteName == null)
                    siteName = pURL;
            }
            return siteName;
        }
        
        public static bool IsValidURL (string pURL)
        {
            return UrlIs(pURL,URL_IS.URLIS_URL);
        }

        public static string CanonizeURL (string pURL,URL_CANONFLAGS flags)
        {
            if (pURL != null) {
                StringBuilder pRet=new StringBuilder(pURL.Length*3);
                int[] lgth = new int[1];
                lgth[0]=pURL.Length*3;
                int hr=UrlCanonicalize(pURL,pRet,lgth,(int)flags);
                Log(true, "UrlCanonicalize returned " + (hr.ToString("X")), "");
                if (lgth[0]!=0)
                    return pRet.ToString();
            }

            return pURL;
        }

        public static bool AreTheSame (string pURL1,string pURL2)
        {
            return UrlCompare(CanonizeURL(pURL1,URL_CANONFLAGS.URL_UNESCAPE),
                              CanonizeURL(pURL2,URL_CANONFLAGS.URL_UNESCAPE),
                              true)==0;
        }

        public static bool AreOnTheSameSite (string pURL1,string pURL2)
        {
            Log(true,GetSiteName(pURL1)+"   "+GetSiteName(pURL2),"");
            return AreTheSame(GetSiteName(pURL1),GetSiteName(pURL2));
        }

        public static bool GetCodeBase(string pURL, out string codeBase, out string application)
        {
            StartUpLog();
            Log(true, "Url = " + pURL, "");
            codeBase = null;
            application = null;

            bool result = false;
            if(PathIsURL(pURL)) {
                int hr;
                StringBuilder site = new StringBuilder(INTERNET_MAX_URL_LENGTH);
                int[] lgth = new int[1];
                lgth[0] = INTERNET_MAX_URL_LENGTH;

                hr = UrlGetPart(pURL, site, lgth, (int) URL_PART.HOSTNAME, 0);
                Log(true, "UrlGetPartW returned " + (hr.ToString("X")), "");
                if(lgth[0] > 0) {
                    String siteString = site.ToString();
                    int s = pURL.IndexOf(siteString);
                    if(s != -1) {
                        codeBase = pURL.Substring(0, s+lgth[0]);
                        if (pURL.Length>s+lgth[0])
                            application = pURL.Substring(s+lgth[0]+1);
                    }
                    result = true;
                }
                else {
                    lgth[0] = INTERNET_MAX_URL_LENGTH;
                    hr = PathCreateFromUrl(pURL, site, lgth, 0);
                    Log(true, "PathCreateFromUrlW returned " + (hr).ToString("X"), "");
                    application = site.ToString();
                }
            }
            else {
                Log(true, "PathIsURLW returned false", "");
                application = pURL;
            }

            if(application != null) {
                int z = application.LastIndexOfAny(separators);
                if(z > 1) 
                    application = application.Substring(0, z);
                else
                    application=null;
            }
            
            /*
            int j = pURL.IndexOf(':');
            int i = 0;
            application = null;
            codeBase = null;
            if(j != -1 && 
               j+3 < pURL.Length &&
               pURL[j+1] == '/' &&
               pURL[j+2] == '/') 
                {
                    j+=3;
                    i = pURL.IndexOf('/', j);
                    if(i > 0) {
                        codeBase = pURL.Substring(0,i);
                        i++;
                        if(i <  pURL.Length) {
                            int k = pURL.LastIndexOf('/');
                            k--;
                            if(k > i) {
                                application = pURL.Substring(i, k-i+1);
                            }
                        }
                        result = true;
                    }
                }
            */

            Log(true, "CodeBase = " + codeBase, "");
            Log(true, "Application = " + application, "");
            Log(result, "Found a codebase", "Did not find a codebase");
            return result;
        }
        
        public static bool GetConfigurationFile(string pURL, out string path, out string file)
        {
            StartUpLog();
            Log(true, "Configuration Url = " + pURL, "");
            
            bool result = false;
            file = pURL;
            path = null;

            if (pURL != null) {
                char[] delim={'/','\\'};
                int j = pURL.LastIndexOfAny(delim);
                if(j == 0)
                    file = pURL.Substring(j+1);
                else if (j > 0) {
                    file = pURL.Substring(j+1);
                    path = pURL.Substring(0, j+1);
                    result = true;
                }

                Log(true, "Configuration path = " + path, "");
                Log(true, "Configuration File = " + file, "");
            }

            return result;
        }
        public static string MakeFullLink(string link, string CodeBase, string Application)
        {
            link=CanonizeURL(link,URL_CANONFLAGS.URL_WININET_COMPATIBILITY);
            link = link.Replace('\\', '/');
            int j1 = link.IndexOf(':');
            if(j1 == -1 ||
               !(j1+3 < link.Length &&
                 link[j1+1] == '/' &&
                 link[j1+2] == '/')) {  //no protocol, so it is relative.
                //yes, UNC and DOS path are treated as relative
                string AppBase=CodeBase;
                if (CodeBase!=null) {
                    if (Application!=null) {
                        if (CodeBase[CodeBase.Length-1]=='/')
                            AppBase+=Application;
                        else
                            AppBase=AppBase+"/"+Application;
                    }
                }
                else
                    AppBase=Application;
                
                if (link[0]!='/')  { //just relative path
                    if (AppBase!=null && AppBase[0]!=0) {
                        if (AppBase[AppBase.Length-1]=='/')
                            link=AppBase+link;
                        else
                            link=AppBase+"/"+link;
                        Log(true,"Link is relative: replaced with "+link,"");
                    }
                }
                else {   // path is relative to root
                    if (AppBase!=null && AppBase[0]!=0) {
                        string sRoot=null;
                        int j = AppBase.IndexOf(':');
                        if(j != -1 &&
                           (j+3 < AppBase.Length &&
                            AppBase[j+1] == '/' &&
                            AppBase[j+2] == '/')) {  //protocol present

                            int i = AppBase.IndexOf('/', j+3);
                            if (i==-1)
                                sRoot=AppBase;
                            else
                                sRoot=AppBase.Substring(0,i);
                        }
                        else {
                            //no protocol
                            // Log(this,true,"Code base doesnot have a protocol - "+AppBase,"");
                            // no need to throw: the path is relative anyway, so there's no hazard
                            
                            j=AppBase.IndexOf('/');
                            if (j!=-1)
                                sRoot=AppBase.Substring(0,j); //take root
                            
                        }
                        if (sRoot!=null) {
                            link=sRoot+link;
                            Log(true,"Link is relative to the root: replaced with "+link,"");
                        }
                    }
                    
                }
                
            }
            else {
                // full path to cfg 
                // must be on the same site             
                if (!AreOnTheSameSite(link,CodeBase)) {
                    Log(true,"Security block: Config file is on another site "+CodeBase+": "+link,"");
                    throw new ArgumentException("Config file is on another site "+CodeBase+": "+link);
                }
                
            }
            return CanonizeURL(link,URL_CANONFLAGS.URL_WININET_COMPATIBILITY);
        }


    // See iiehost, we have a hacky way of making a numeric value a string
        private static int ConvertHexDigit(char val) {
            if (val <= '9') return (val - '0');
            return ((val - 'A') + 10);
        }
        
        public static byte[] DecodeDomainId(string hexString) {
            if (hexString != null)
            {
                if (hexString.Length%2!=0)
                    throw new ArgumentException("hexString");
                byte[] sArray = new byte[(hexString.Length / 2)];
                int digit;
                int rawdigit;
                for (int i = 0, j = 0; i < hexString.Length; i += 2, j++) {
                    digit = ConvertHexDigit(hexString[i]);
                    rawdigit = ConvertHexDigit(hexString[i+1]);
                    sArray[j] = (byte) (digit | (rawdigit << 4));
                }
                return(sArray);
            }

            return new byte[0];
        }
        
        // Create a class factory passing in security information retrieved
        // about the assembly. Typically, this information is obtained from
        // the InternetSecurityManager using the codebase of the assembly.
        public virtual ISecureFactory  GetSecuredClassFactory(int    flags,
                                                              int    zone,
                                                              string site,
                                                              string uniqueIdString,
                                                              string fileHashString,
                                                              string assemblyName,
                                                              string typeName)
        {
            byte[] uniqueId = null;
            byte[] fileHash = null;
            string parsing = null;
            try
            {
                parsing = "uniqueIdString";
                uniqueId = DecodeDomainId(uniqueIdString);

                if(fileHashString != null) {
                    parsing = "file hash";
                    fileHash = DecodeDomainId(fileHashString);
                }
                
            }
            catch
            {
                throw new ArgumentException(parsing);
            }
            
            StartUpLog();
            
            Log(this, uniqueId == null,
                "Microsoft.IE.Manager: unique id is null",
                "Microsoft.IE.Manager: unique id lgth = " + ((uniqueIdString == null) ? 0 : uniqueIdString.Length));
            
            SecureFactory ifact = new SecureFactory(this,
                                                    flags,
                                                    zone,
                                                    site,
                                                    uniqueId,
                                                    fileHash,
                                                    assemblyName,
                                                    typeName);
            
            Log(this, true, "Created secure factory", "");
            return ifact;
        }
        
        public virtual ISecureFactory GetClassFactory(string assemblyName,
                                                      string className)
        {
            return new SecureFactory(this,
                                     assemblyName,
                                     className);
        }
        
    }
    
    internal class IDKey
    {
        
        byte[] _Buffer;
        string  _Url;
        internal IDKey(byte[] data, string document)
        {
            Manager.Log(this, true, "Created key", "");
            _Buffer = data;
            _Url = document;
        }
        
        public override bool Equals(object obj)
        {
            Manager.Log(this, true, "IDKEy::Equals", "");
            if(obj == this) return true;
            IDKey other = (IDKey) obj;
            
            if(_Buffer == null) {
                if (other._Buffer != null) 
                    return false;
            }
            else {
                if(other._Buffer == null) return false;
            }
            
            Manager.Log(this, true, "Testing uniqueid", "");
            if(_Buffer != null) {
                if(other._Buffer.Length != _Buffer.Length) return false;
                for(int i = 0; i < _Buffer.Length; i++) {
                    if(other._Buffer[i] != _Buffer[i])
                        return false;
                }
            }
            Manager.Log(this, true, "Uniqueid's are the same", "");
            
            if(_Url == null) {
                if(other._Url == null)
                    return true;
                else
                    return false;
            }
            
            if(other._Url == null) return false;
            
            Manager.Log(this, true, "Others URL = " + other._Url, "");
            Manager.Log(this, true, "My URL = " + _Url, "");

            return (string.Compare(_Url, other._Url, true, CultureInfo.InvariantCulture) == 0);
            
        }
        
        
        public override int GetHashCode()
        {
            int result = 0;
            if(_Buffer != null && _Buffer.Length != 0) {
                for(int i = 0; i < _Buffer.Length; i++)
                    result ^= _Buffer[i];
            }
            
            if(_Url != null)
                result ^= _Url.GetHashCode();
            
            //Manager.Log(this, true, "Returned hash code = " + Int32.ToString(result),"");
            return result;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\iiehost\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "IIEHost.dll"
#define VER_FILEDESCRIPTION_STR "IE Remoting Interface\0"
#define VER_ORIGFILENAME_STR    "IIEHost.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\iiehost\makefile.inc ===
target_link :  $(TARGETPATH)\$(TARGETNAME)

$O\IIEhost.dll: $(TARGETPATH)\IIEHost.tlb
        perl $(CORENV)\bin\runtlbimp.pl $(TARGETPATH)\IIEHost.tlb /out:$O\IIEHost.dll /publickey:$(CORBASE)\bin\FinalPublicKey.snk 
        perl $(CORENV)\bin\GetBaseAddress.pl $O\IIEHost.dll IIEHost

$(TARGETPATH)\$(TARGETNAME) :  $O\iiehost.dll $O\iiehost.res
        -del $(TARGETPATH)\$(TARGETNAME) /q
        copy $O\IIEHost.dll $(TARGETPATH)\$(TARGETNAME)
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
        sn -T $(TARGETPATH)\$(TARGETNAME) > $(O)\pubkey.tmp
        sn -e $(TARGETPATH)\$(TARGETNAME)   $(O)\pubkey.snk
        -perl $(CORENV)\bin\genpubpol.pl pubkey.snk IIEHost $(O)\pubkey.tmp $(O)\al.rsp $(O)\placepol.bat
        $(CORENV)\Bin\devlkg\al.exe /delaysign+ /keyf:$(O)\pubkey.snk @$(O)\al.rsp
        $(O)\placepol.bat

!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\isymwrapper\makefile.inc ===
#
# Makefile for building ISymWrapper
#

BASE_OPT=-base:@$(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\coffbase.txt,$(MINORCOMP)

#
# if one of these commands fails, notice it
#
!CMDSWITCHES -I


#
# build the resource file
#
!IFDEF ISYMWRAPPER_RESOURCE_FILE
{$(ISYMWRAPPER_SOURCE_DIR)}.rc{}.res:
    set _oldinclude=$(include)
    set include=$(INCPATHRC)
    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINERC) $<
    set include=$(_oldinclude)
    set _oldinclude=
    $(MANAGED_VCDIR)\cvtres -nologo -machine:IX86 -readonly -out:$@ $(@R).tmp
    erase $(@R).tmp
!ENDIF


#
# build ISymWrapper: free and retail are