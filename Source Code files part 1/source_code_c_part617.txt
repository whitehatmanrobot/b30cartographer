*****************************************************************/

BOOL APIENTRY glsrvDeleteContext(__GLcontext *gc)
{
    __GLGENcontext *gengc;

    gengc = (__GLGENcontext *)gc;

    /* Free ancillary buffer related data.  Note that these calls do
    ** *not* free software ancillary buffers, just any related data
    ** stored in them.  The ancillary buffers are freed on window destruction
    */
    if (gc->modes.accumBits) {
        DBGLEVEL(LEVEL_ALLOC,
                "DestroyContext: Freeing accumulation buffer related data\n");
        __glFreeAccum64(gc, &gc->accumBuffer);
    }

    if (gc->modes.depthBits) {
        DBGLEVEL(LEVEL_ALLOC,
                "DestroyContext: Freeing depth buffer related data\n");
        __glFreeDepth32(gc, &gc->depthBuffer);
    }
    if (gc->modes.stencilBits) {
        DBGLEVEL(LEVEL_ALLOC,
                "DestroyContext: Freeing stencil buffer related data\n");
        __glFreeStencil8(gc, &gc->stencilBuffer);
    }

    /* Free Translate & Inverse Translate vectors */
    if ((gengc->pajTranslateVector != NULL) &&
        (gengc->pajTranslateVector != gengc->xlatPalette))
        GCFREE(gc, gengc->pajTranslateVector);

    if (gengc->pajInvTranslateVector != NULL)
        GCFREE(gc, gengc->pajInvTranslateVector);

    // Make sure that any cached GDI objects are freed
    // This is normally done in LoseCurrent but a context may be
    // left current and then cleaned up
    EmptyFillStrokeCache(gengc);

    /*
    /* Free the span dibs and storage.
    */

#ifndef _CLIENTSIDE_
    if (gengc->StippleBitmap)
        EngDeleteSurface((HSURF)gengc->StippleBitmap);
#endif

    wglDeleteScanlineBuffers(gengc);

    if (gengc->StippleBits)
        GCFREE(gc, gengc->StippleBits);

    // Free __GLGENbitmap front-buffer structure

    if (gc->frontBuffer.bitmap)
        GCFREE(gc, gc->frontBuffer.bitmap);

#ifndef _CLIENTSIDE_
    /*
     *  Free the buffers that may have been allocated by feedback
     *  or selection
     */

    if ( NULL != gengc->RenderState.SrvSelectBuffer )
    {
#ifdef NT
        // match the allocation function
        FREE(gengc->RenderState.SrvSelectBuffer);
#else
        GCFREE(gc, gengc->RenderState.SrvSelectBuffer);
#endif
    }

    if ( NULL != gengc->RenderState.SrvFeedbackBuffer)
    {
#ifdef NT
        // match the allocation function
        FREE(gengc->RenderState.SrvFeedbackBuffer);
#else
        GCFREE(gc, gengc->RenderState.SrvFeedbackBuffer);
#endif
    }
#endif  //_CLIENTSIDE_

#ifdef _CLIENTSIDE_
    /*
     * Cleanup logical palette copy if it exists.
     */
    if ( gengc->ppalBuf )
        FREE(gengc->ppalBuf);
#endif

    /* Destroy acceleration-specific context information */

    __glGenDestroyAccelContext(gc);
    
#ifdef _MCD_
    /* Free the MCD state structure and associated resources. */

    if (gengc->_pMcdState) {
        GenMcdDeleteContext(gengc->_pMcdState);
    }
#endif

    /* Free any temporay buffers in abnormal process exit */
    GC_TEMP_BUFFER_EXIT_CLEANUP(gc);

    // Release references to DirectDraw surfaces
    if (gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW)
    {
        GLWINDOWID gwid;
        GLGENwindow *pwnd;
        
        // Destroy window created for this context
        gwid.iType = GLWID_DDRAW;
        gwid.pdds = gengc->gsurf.dd.gddsFront.pdds;
        gwid.hdc = gengc->gsurf.hdc;
        gwid.hwnd = NULL;
        pwnd = pwndGetFromID(&gwid);
        ASSERTOPENGL(pwnd != NULL,
                     "Destroying DDraw context without window\n");
        pwndCleanup(pwnd);

        gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
            Release(gengc->gsurf.dd.gddsFront.pdds);
        if (gengc->gsurf.dd.gddsZ.pdds != NULL)
        {
            gengc->gsurf.dd.gddsZ.pdds->lpVtbl->
                Release(gengc->gsurf.dd.gddsZ.pdds);
        }

    }
    
    /* Destroy rest of software context (in soft code) */
    __glDestroyContext(gc);

    return TRUE;
}

/******************************Public*Routine******************************\
* glsrvLoseCurrent
*
* Releases the current context (makes it not current).
*
\**************************************************************************/

VOID APIENTRY glsrvLoseCurrent(__GLcontext *gc)
{
    __GLGENcontext *gengc;

    gengc = (__GLGENcontext *)gc;

    DBGENTRY("LoseCurrent\n");
    ASSERTOPENGL(gc == GLTEB_SRVCONTEXT(), "LoseCurrent not current!");

    /*
    ** Release lock if still held.
    */
    if (gengc->fsLocks != 0)
    {
        glsrvReleaseLock(gengc);
    }

    /*
    ** Unscale derived state that depends upon the color scales.  This
    ** is needed so that if this context is rebound to a memdc, it can
    ** then rescale all of those colors using the memdc color scales.
    */
    __glContextUnsetColorScales(gc);
    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));

    /*
    ** Clean up HDC-specific GDI objects
    */
    EmptyFillStrokeCache(gengc);

    /*
    ** Free up fake window for IC's
    */
    if ((gengc->dwCurrentFlags & GLSURF_METAFILE) && gengc->ipfdCurrent == 0)
    {
        GLGENwindow *pwnd;

        pwnd = gengc->pwndMakeCur;
        ASSERTOPENGL(pwnd != NULL,
                     "IC with no pixel format but no fake window\n");

        if (pwnd->buffers != NULL)
        {
            __glGenFreeBuffers(pwnd->buffers);
        }

        DeleteCriticalSection(&pwnd->sem);
        FREE(pwnd);
    }

    gengc->pwndMakeCur = NULL;
    
#ifdef _MCD_
    /*
    ** Disconnect MCD state.
    */
    gengc->pMcdState = (GENMCDSTATE *) NULL;
#endif

    gc->constants.width = 0;
    gc->constants.height = 0;

    // Set paTeb to NULL for debugging.
    gc->paTeb = NULL;
    GLTEB_SET_SRVCONTEXT(0);
}

/******************************Public*Routine******************************\
* glsrvSwapBuffers
*
* This uses the software implementation of double buffering.  An engine
* allocated bitmap is allocated for use as the back buffer.  The SwapBuffer
* routine copies the back buffer to the front buffer surface (which may
* be another DIB, a device surface in DIB format, or a device managed
* surface (with a device specific format).
*
* The SwapBuffer routine does not disturb the contents of the back buffer,
* though the defined behavior for now is undefined.
*
* Note: the caller should be holding the per-window semaphore.
*
* History:
*  19-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY glsrvSwapBuffers(HDC hdc, GLGENwindow *pwnd)
{
    DBGENTRY("glsrvSwapBuffers\n");

    if ( pwnd->buffers ) {
        __GLGENbuffers *buffers;
        __GLGENbitmap *genBm;

        buffers = pwnd->buffers;

        if (buffers->pMcdSurf) {
            return GenMcdSwapBuffers(hdc, pwnd);
        }

        genBm = &buffers->backBitmap;

        // Make sure the backbuffer exists

        if (genBm->hbm) {
            if (!RECTLISTIsEmpty(&buffers->rl) && !buffers->fMax) {
                wglCopyBufRECTLIST(
                    hdc,
                    genBm->hdc,
                    0,
                    0,
                    buffers->backBuffer.width,
                    buffers->backBuffer.height,
                    &buffers->rl
                    );
            } else {
                buffers->fMax = FALSE;
                wglCopyBuf(
                    hdc,
                    genBm->hdc,
                    0,
                    0,
                    buffers->backBuffer.width,
                    buffers->backBuffer.height
                    );
            }
            RECTLISTSetEmpty(&buffers->rl);
        }
        if( buffers->alphaBits 
            && buffers->alphaBackBuffer
            && buffers->alphaFrontBuffer) {

            ASSERTOPENGL(buffers->alphaFrontBuffer->size ==
                         buffers->alphaBackBuffer->size,
                         "Destination alpha buffer size mismatch\n");
            
            // Destination alpha values are kept in separate buffers.
            // If this buffer set has destination alpha buffers,
            // copy the back alpha values into the front alpha buffer.
            RtlCopyMemory(buffers->alphaFrontBuffer->base,
                          buffers->alphaBackBuffer->base,
                          buffers->alphaBackBuffer->size);
        }
        return TRUE;
    }

    return FALSE;
}

/******************************Public*Routine******************************\
* gdiCopyPixels
*
* Copy span [(x, y), (x + cx, y)) (inclusive-exclusive) to/from specified
* color buffer cfb from/to the scanline buffer.
*
* If bIn is TRUE, the copy is from the scanline buffer to the buffer.
* If bIn is FALSE, the copy is from the buffer to the scanline buffer.
*
\**************************************************************************/

void gdiCopyPixels(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                   GLint x, GLint y, GLint cx, BOOL bIn)
{
    wglCopyBits(gengc, gengc->pwndLocked, gengc->ColorsBitmap, x, y, cx, bIn);
}

/******************************Public*Routine******************************\
* dibCopyPixels
*
* Special case version of gdiCopyPixels that is used when cfb is a DIB,
* either a real DIB or a device surface which has a DIB format.
*
* This function *must* be used in lieu of gdiCopyPixels if we are
* directly accessing the screen as it is not safe to call GDI entry
* points with the screen locked
*
* History:
*  24-May-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void dibCopyPixels(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                      GLint x, GLint y, GLint cx, BOOL bIn)
{
    VOID *pvDib;
    UINT cjPixel = gengc->gsurf.pfd.cColorBits >> 3;
    ULONG ulSpanVisibility;
    GLint cWalls;
    GLint *pWalls;

// Don't handle VGA DIBs.
//
// We are not supposed to call GDI if directly accessing the screen.  However,
// we should be able to assume that 4bpp devices do not support
// direct access making it OK for us to punt this call to the GDI version.
// This is true for Win95 and, according to AndrewGo, will be
// true for WinNT SUR.

    if (gengc->gsurf.pfd.cColorBits <= 4)
    {
        ASSERTOPENGL(
                !((cfb->buf.flags & DIB_FORMAT) &&
                  !(cfb->buf.flags & MEMORY_DC)),
                "dibCopyPixels: unexpected 4bpp direct surface\n"
                );

        gdiCopyPixels(gengc, cfb, x, y, cx, bIn);
        return;
    }

// Find out clipping info.

    if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) ==
        (NO_CLIP | DIB_FORMAT))
    {
        ulSpanVisibility = WGL_SPAN_ALL;
    }
    else
    {
        ulSpanVisibility = wglSpanVisible(x, y, cx, &cWalls, &pWalls);
    }

// Completely clipped, nothing to do.

    if (ulSpanVisibility == WGL_SPAN_NONE)
        return;

// Completely visible.
//
// Actually, if bIn == FALSE (i.e., copy from screen to scanline buffer)
// we can cheat a little and ignore the clipping.

    else if ( (ulSpanVisibility == WGL_SPAN_ALL) || !bIn )
    {
    // Get pointer into DIB at position (x, y).

        pvDib = (VOID *) (((BYTE *) gengc->gc.front->buf.base) +
                          gengc->gc.front->buf.outerWidth * y +
                          cjPixel * x);

    // If bIn == TRUE, copy from scanline buffer to DIB.
    // Otherwise,  copy from DIB to scanline buffer.

        if (bIn)
            RtlCopyMemory_UnalignedDst(pvDib, gengc->ColorsBits, cjPixel * cx);
        else
            RtlCopyMemory_UnalignedSrc(gengc->ColorsBits, pvDib, cjPixel * cx);
    }

// Partially visible.

    else
    {
        GLint xEnd = x + cx;    // end of the span
        UINT cjSpan;          // size of the current portion of span to copy
        VOID *pvBits;           // current copy position in the scanline buf
        BYTE *pjScan;           // address of scan line in DIB

        ASSERTOPENGL( cWalls && pWalls, "dibCopyPixels(): bad wall array\n");

    // The walls are walked until either the end of the array is reached
    // or the walls exceed the end of the span.  The do..while loop
    // construct was choosen because the first iteration will always
    // copy something and after the first iteration we are guaranteed
    // to be in the "cWalls is even" case.  This makes the testing the
    // walls against the span end easier.
    //
    // If cWalls is even, clip the span to each pair of walls in pWalls.
    // If cWalls is odd, form the first pair with (x, pWalls[0]) and then
    // pair the remaining walls starting with pWalls[1].

        pjScan = (VOID *) (((BYTE *) gengc->gc.front->buf.base) +
                           gengc->gc.front->buf.outerWidth * y);

        do
        {
            //!!!XXX -- Make faster by pulling the odd case out of the loop

            if (cWalls & 0x1)
            {
                pvDib = (VOID *) (pjScan + (cjPixel * x));

                pvBits = gengc->ColorsBits;

                if ( pWalls[0] <= xEnd )
                    cjSpan = cjPixel * (pWalls[0] - x);
                else
                    cjSpan = cjPixel * cx;

                pWalls++;
                cWalls--;   // Now cWalls is even!
            }
            else
            {
                pvDib = (VOID *) (pjScan + (cjPixel * pWalls[0]));

                pvBits = (VOID *) (((BYTE *) gengc->ColorsBits) +
                                   cjPixel * (pWalls[0] - x));

                if ( pWalls[1] <= xEnd )
                    cjSpan = cjPixel * (pWalls[1] - pWalls[0]);
                else
                    cjSpan = cjPixel * (xEnd - pWalls[0]);

                pWalls += 2;
                cWalls -= 2;
            }

            // We are going to cheat and ignore clipping when copying from
            // the dib to the scanline buffer (i.e., we are going to handle
            // the !bIn case as if it were WGL_SPAN_ALL).  Thus, we can assume
            // that bIn == TRUE if we get to here.
            //
            // If clipping is needed to read the DIB, its trivial to turn it
            // back on.
            //
            // RtlCopyMemory(bIn ? pvDib : pvBits,
            //               bIn ? pvBits : pvDib,
            //               cjSpan);

        //!!!dbug -- Possible COMPILER BUG (compiler should check for
        //!!!dbug    alignment before doing the "rep movsd").  Keep around
        //!!!dbug    as a test case.
        #if 1
            RtlCopyMemory_UnalignedDst(pvDib, pvBits, cjSpan);
        #else
            RtlCopyMemory(pvDib, pvBits, cjSpan);
        #endif

        } while ( cWalls && (pWalls[0] < xEnd) );
    }
}

/******************************Public*Routine******************************\
* MaskFromBits
*
* Support routine for GetContextModes.  Computes a color mask given that
* colors bit count and shift position.
*
\**************************************************************************/

#define MaskFromBits(shift, count) \
    ((0xffffffff >> (32-(count))) << (shift))

/******************************Public*Routine******************************\
* GetContextModes
*
* Convert the information from Gdi into OpenGL format after checking that
* the formats are compatible and that the surface is compatible with the
* format.
*
* Called during a glsrvMakeCurrent().
*
\**************************************************************************/

void FASTCALL GetContextModes(__GLGENcontext *gengc)
{
    PIXELFORMATDESCRIPTOR *pfmt;
    __GLcontextModes *Modes;

    DBGENTRY("GetContextModes\n");

    Modes = &((__GLcontext *)gengc)->modes;

    pfmt = &gengc->gsurf.pfd;

    if (pfmt->iPixelType == PFD_TYPE_RGBA)
        Modes->rgbMode              = GL_TRUE;
    else
        Modes->rgbMode              = GL_FALSE;

    Modes->colorIndexMode       = !Modes->rgbMode;

    if (pfmt->dwFlags & PFD_DOUBLEBUFFER)
        Modes->doubleBufferMode     = GL_TRUE;
    else
        Modes->doubleBufferMode     = GL_FALSE;

    if (pfmt->dwFlags & PFD_STEREO)
        Modes->stereoMode           = GL_TRUE;
    else
        Modes->stereoMode           = GL_FALSE;

    Modes->accumBits        = pfmt->cAccumBits;
    Modes->haveAccumBuffer  = GL_FALSE;

    Modes->auxBits          = NULL;     // This is a pointer

    Modes->depthBits        = pfmt->cDepthBits;
    Modes->haveDepthBuffer  = GL_FALSE;

    Modes->stencilBits      = pfmt->cStencilBits;
    Modes->haveStencilBuffer= GL_FALSE;

    if (pfmt->cColorBits > 8)
        Modes->indexBits    = 8;
    else
        Modes->indexBits    = pfmt->cColorBits;

    Modes->indexFractionBits= 0;

    // The Modes->{Red,Green,Blue}Bits are used in soft
    Modes->redBits          = pfmt->cRedBits;
    Modes->greenBits        = pfmt->cGreenBits;
    Modes->blueBits         = pfmt->cBlueBits;
    Modes->alphaBits        = pfmt->cAlphaBits;
    Modes->redMask          = MaskFromBits(pfmt->cRedShift, pfmt->cRedBits);
    Modes->greenMask        = MaskFromBits(pfmt->cGreenShift, pfmt->cGreenBits);
    Modes->blueMask         = MaskFromBits(pfmt->cBlueShift, pfmt->cBlueBits);
    Modes->alphaMask        = MaskFromBits(pfmt->cAlphaShift, pfmt->cAlphaBits);
    Modes->rgbMask          = Modes->redMask | Modes->greenMask |
                              Modes->blueMask;
    Modes->allMask          = Modes->redMask | Modes->greenMask |
                              Modes->blueMask | Modes->alphaMask;
    Modes->maxAuxBuffers    = 0;

    Modes->isDirect         = GL_FALSE;
    Modes->level            = 0;

    #if DBG
    DBGBEGIN(LEVEL_INFO)
        DbgPrint("GL generic server get modes: rgbmode %d, cimode %d, index bits %d\n", Modes->rgbMode, Modes->colorIndexMode);
        DbgPrint("    redmask 0x%x, greenmask 0x%x, bluemask 0x%x\n", Modes->redMask, Modes->greenMask, Modes->blueMask);
        DbgPrint("    redbits %d, greenbits %d, bluebits %d\n", Modes->redBits, Modes->greenBits, Modes->blueBits);
        DbgPrint("GetContext Modes flags %X\n", gengc->gsurf.dwFlags);
    DBGEND
    #endif   /* DBG */
}

/******************************Public*Routine******************************\
* wglGetSurfacePalette
*
* Initialize the array of RGBQUADs to match the color table or palette
* of the DC's surface.
*
* Note:
*   Should be called only for 8bpp or lesser surfaces.
*
* History:
*  12-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
wglGetSurfacePalette( __GLGENcontext *gengc, RGBQUAD *prgbq,
                      BOOL bTranslateDdb )
{
    int nColors;
    BOOL bRet;
    BOOL bConvert;
    PALETTEENTRY ppe[256];
    int i;
    
    ASSERTOPENGL(gengc->gsurf.pfd.cColorBits <= 8,
                 "wglGetSurfacePalette called for deep surface\n");
    ASSERTOPENGL((gengc->dwCurrentFlags & GLSURF_METAFILE) == 0,
                 "wglGetSurfacePalette called for metafile\n");

    nColors = 1 << gengc->gsurf.pfd.cColorBits;
    
    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        LPDIRECTDRAWPALETTE pddp;
        HRESULT hr;
        
        // Retrieve DirectDraw palette from surface
        if (gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
            GetPalette(gengc->gsurf.dd.gddsFront.pdds, &pddp) != DD_OK ||
            pddp == NULL)
        {
            return FALSE;
        }
        
        hr = pddp->lpVtbl->GetEntries(pddp, 0, 0, nColors, ppe);

        pddp->lpVtbl->Release(pddp);

        bRet = hr == DD_OK;
        bConvert = TRUE;
    }
    else if (GLSURF_IS_DIRECTDC(gengc->dwCurrentFlags))
    {
        // Direct DC, so get the RGB values from the system palette.
        bRet = wglGetSystemPaletteEntries(gengc->gwidCurrent.hdc,
                                          0, nColors, ppe);
        bConvert = TRUE;
    }
    else if (gengc->dwCurrentFlags & GLSURF_DIRECT_ACCESS)
    {
        // DIB section, so copy the color table.
        bRet = GetDIBColorTable(gengc->gwidCurrent.hdc, 0, nColors, prgbq);
        bConvert = FALSE;
    }
    else
    {
        // DDB surface, so use the logical palette.
        bRet = GetPaletteEntries(GetCurrentObject(gengc->gwidCurrent.hdc,
                                                  OBJ_PAL),
                                 0, nColors, ppe);

        // For certain DDB surfaces we need the palette to be permuted
        // by the forward translation vector before use.
        if (bRet && bTranslateDdb)
        {
            BYTE *pjTrans;
            
            bConvert = FALSE;
            
            // Convert to RGBQUAD with forward translation permutation.
            pjTrans = gengc->pajTranslateVector;
            for (i = 0; i < nColors; i++)
            {
                prgbq[pjTrans[i]].rgbRed      = ppe[i].peRed;
                prgbq[pjTrans[i]].rgbGreen    = ppe[i].peGreen;
                prgbq[pjTrans[i]].rgbBlue     = ppe[i].peBlue;
                prgbq[pjTrans[i]].rgbReserved = 0;
            }
        }
        else
        {
            bConvert = TRUE;
        }
    }

    if (bRet && bConvert)
    {
        // Convert to RGBQUAD.
        for (i = 0; i < nColors; i++)
        {
            prgbq[i].rgbRed      = ppe[i].peRed;
            prgbq[i].rgbGreen    = ppe[i].peGreen;
            prgbq[i].rgbBlue     = ppe[i].peBlue;
            prgbq[i].rgbReserved = 0;
        }
    }
    
    return bRet;
}

/******************************Public*Routine******************************\
* SyncDibColorTables
*
* Setup the color table in each DIB associated with the specified
* GLGENcontext to match the system palette.
*
* Called only for <= 8bpp surfaces.
*
* History:
*  24-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
SyncDibColorTables(__GLGENcontext *gengc)
{
    __GLGENbuffers *buffers = gengc->pwndLocked->buffers;

    ASSERTOPENGL(gengc->gsurf.pfd.cColorBits <= 8,
                 "SyncDibColorTables(): bad surface type");

    if (gengc->ColorsBitmap || buffers->backBitmap.hbm)
    {
        RGBQUAD rgbq[256];
        
        if (wglGetSurfacePalette(gengc, rgbq, TRUE))
        {
            int nColors;
            
        // If color table was obtained, setup the DIBs.

            nColors = 1 << gengc->gsurf.pfd.cColorBits;
            
        // Scan-line DIB.
            if (gengc->ColorsBitmap)
                SetDIBColorTable(gengc->ColorsMemDC, 0, nColors, rgbq);

        // Back buffer
            if (buffers->backBitmap.hbm)
                SetDIBColorTable(buffers->backBitmap.hdc, 0, nColors, rgbq);
        }
        else
        {
            WARNING("SyncDibColorTables: Unable to get surface palette\n");
        }
    }
}

static BYTE vubSystemToRGB8[20] = {
    0x00,
    0x04,
    0x20,
    0x24,
    0x80,
    0x84,
    0xa0,
    0xf6,
    0xf6,
    0xf5,
    0xff,
    0xad,
    0xa4,
    0x07,
    0x38,
    0x3f,
    0xc0,
    0xc7,
    0xf8,
    0xff
};

// ComputeInverseTranslationVector
//      Computes the inverse translation vector for 4-bit and 8-bit.
//
// Synopsis:
//      void ComputeInverseTranslation(
//          __GLGENcontext *gengc   specifies the generic RC
//          int cColorEntries       specifies the number of color entries
//          BYTE iPixeltype         specifies the pixel format type
//
// Assumtions:
//      The inverse translation vector has been allocated and initialized with
//      zeros.
//
// History:
// 23-NOV-93 Eddie Robinson [v-eddier] Wrote it.
//
void FASTCALL ComputeInverseTranslationVector(__GLGENcontext *gengc,
                                              int cColorEntries,
                                              int iPixelType)
{
    BYTE *pXlate, *pInvXlate;
    int i, j;

    pInvXlate = gengc->pajInvTranslateVector;
    pXlate = gengc->pajTranslateVector;
    for (i = 0; i < cColorEntries; i++)
    {
        if (pXlate[i] == i) {       // Look for trivial mapping first
            pInvXlate[i] = (BYTE)i;
        }
        else
        {
            for (j = 0; j < cColorEntries; j++)
            {
                if (pXlate[j] == i) // Look for exact match
                {
                    pInvXlate[i] = (BYTE)j;
                    goto match_found;
                }
            }

            //
            // If we reach here, there is no exact match, so we should find the
            // closest fit.  These indices should match the system colors
            // for 8-bit devices.
            //
            // Note that these pixel values cannot be generated by OpenGL
            // drawing with the current foreground translation vector.
            //

            if (cColorEntries == 256)
            {
                if (i <= 9)
                {
                    if (iPixelType == PFD_TYPE_RGBA)
                        pInvXlate[i] = vubSystemToRGB8[i];
                    else
                        pInvXlate[i] = (BYTE)i;
                }
                else if (i >= 246)
                {
                    if (iPixelType == PFD_TYPE_RGBA)
                        pInvXlate[i] = vubSystemToRGB8[i-236];
                    else
                        pInvXlate[i] = i-236;
                }
            }
        }
match_found:;
    }
}

// er: similar to function in so_textu.c, but rounds up the result

/*
** Return the log based 2 of a number
**
** logTab1 returns (int)ceil(log2(index))
** logTab2 returns (int)log2(index)+1
*/


static GLubyte logTab1[256] = { 0, 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
                                4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                                5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};

static GLubyte logTab2[256] = { 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
                                5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};

static GLint FASTCALL Log2RoundUp(GLint i)
{
    if (i & 0xffff0000) {
        if (i & 0xff000000) {
            if (i & 0x00ffffff)
                return(logTab2[i >> 24] + 24);
            else
                return(logTab1[i >> 24] + 24);
        } else {
            if (i & 0x0000ffff)
                return(logTab2[i >> 16] + 16);
            else
                return(logTab1[i >> 16] + 16);
        }
    } else {
        if (i & 0xff00) {
            if (i & 0x00ff)
                return (logTab2[i >> 8] + 8);
            else
                return (logTab1[i >> 8] + 8);
        } else {
            return (logTab1[i]);
        }
    }
}

// default translation vector for 4-bit RGB

static GLubyte vujRGBtoVGA[16] = {
    0x0, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    0x0, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
};

// SetColorTranslationVector
//      Sets up the translation vector, which may take 2 forms:
//      - In all 8,4-bit surfaces, get the translation vector with
//        wglCopyTranslateVector(), with 2**numBits byte entries.
//      - For 16,24,32 ColorIndex, get the mapping from index to RGB
//        value with wglGetPalette().  All entries in the table are unsigned
//        longs, with the first entry being the number of entries. This table
//        always has (2**n) <= 4096 entries, because gl assumes n bits are
//        used for color index.
//
// Synopsis:
//      void SetColorTranslationVector
//          __GLGENcontext *gengc   generic RC
//          int cColorEntries       number of color entries
//          int cColorBits          number of color bits
//          int iPixelType          specifies RGB or ColorIndex
//
// History:
// Feb. 02 Eddie Robinson [v-eddier] Added support for 4-bit and 8-bit
// Jan. 29 Marc Fortier [v-marcf] Wrote it.
void
SetColorTranslationVector(__GLGENcontext *gengc, int cColorEntries,
                          int cColorBits, int iPixelType)
{
    int numEntries, numBits;
    __GLcontextModes *Modes;
    BYTE ajBGRtoRGB[256];
    BYTE ajTmp[256];

    Modes = &((__GLcontext *)gengc)->modes;

// Handle formats with a hardware palette (i.e., 4bpp and 8bpp).

    if ( cColorBits <= 8 )
    {
        int i;
        BYTE *pXlate;

    // Compute logical to system palette forward translation vector.

        if (!wglCopyTranslateVector(gengc, gengc->pajTranslateVector,
                                    cColorEntries))
        {
        // if foreground translation vector doesn't exist, build one

            pXlate = gengc->pajTranslateVector;

            if (cColorBits == 4)
            {
            // for RGB, map 1-1-1 to VGA colors.  For CI, just map 1 to 1
                if (iPixelType == PFD_TYPE_COLORINDEX)
                {
                    for (i = 0; i < 16; i++)
                        pXlate[i] = (BYTE)i;
                }
                else
                {
                    for (i = 0; i < 16; i++)
                        pXlate[i] = vujRGBtoVGA[i];
                }
            }
            else
            {
            // for RGB, map 1 to 1.  For CI display, 1 - 20 to system colors
            // for CI DIB, just map 1 to 1
                if ((iPixelType == PFD_TYPE_COLORINDEX) &&
                    GLSURF_IS_DIRECTDC(gengc->dwCurrentFlags))
                {
                    for (i = 0; i < 10; i++)
                        pXlate[i] = (BYTE)i;

                    for (i = 10; i < 20; i++)
                        pXlate[i] = i + 236;
                }
                else
                {
                    for (i = 0; i < cColorEntries; i++)
                        pXlate[i] = (BYTE)i;
                }
            }
        }

    // Some MCD pixelformats specify a 233BGR (i.e., 2-bits blue in least
    // significant bits, etc.) bit ordering.  Unfortunately, this is the
    // slow path for simulations.  For those formats, we force the ordering
    // to RGB internally and reorder the pajTranslateVector to convert it
    // back to BGR before writing to the surface.

        if (gengc->flags & GENGC_MCD_BGR_INTO_RGB)
        {
            pXlate = gengc->pajTranslateVector;

        // Compute a 233BGR to 332RGB translation vector.

            for (i = 0; i < 256; i++)
            {
                ajBGRtoRGB[i] = (((i & 0x03) << 6) |    // blue
                                 ((i & 0x1c) << 1) |    // green
                                 ((i & 0xe0) >> 5))     // red
                                & 0xff;
            }

        // Remap the tranlation vector to 332RGB.

            RtlCopyMemory(ajTmp, pXlate, 256);

            for (i = 0; i < 256; i++)
            {
                pXlate[ajBGRtoRGB[i]] = ajTmp[i];
            }
        }

//!!!XXX -- I think the code below to fixup 4bpp is no longer needed.
//!!!XXX    There is now special case code in wglCopyTranslateVector
#if 0
        // wglCopyTranslateVector = TRUE, and 4-bit: need some fixing up
        // For now, zero out upper nibble of returned xlate vector
        else if( cColorBits == 4 ) {
            pXlate = gengc->pajTranslateVector;
            for( i = 0; i < 16; i ++ )
                pXlate[i] &= 0xf;
        }
#endif
        ComputeInverseTranslationVector( gengc, cColorEntries, iPixelType );

#ifdef _CLIENTSIDE_
        SyncDibColorTables( gengc );
#endif
    }

// Handle formats w/o a hardware format (i.e., 16bpp, 24bpp, 32bpp).

    else
    {
        if( cColorEntries <= 256 ) {
            numEntries = 256;
            numBits = 8;
        }
        else
        {
            numBits = Log2RoundUp( cColorEntries );
            numEntries = 1 << numBits;
        }

        // We will always allocate 4096 entries for CI mode with > 8 bits
        // of color.  This enables us to use a constant (0xfff) mask for
        // color-index clamping.

        ASSERTOPENGL(numEntries <= MAXPALENTRIES,
                     "Maximum color-index size exceeded");

        if( (numBits == Modes->indexBits) &&
            (gengc->pajTranslateVector != NULL) )
        {
            // New palette same size as previous
            ULONG *pTrans;
            int i;

            // zero out some entries
            pTrans = (ULONG *)gengc->pajTranslateVector + cColorEntries + 1;
            for( i = cColorEntries + 1; i < MAXPALENTRIES; i ++ )
                *pTrans++ = 0;
        }
        else
        {
            __GLcontext *gc = (__GLcontext *) gengc;
            __GLcolorBuffer *cfb;

            // New palette has different size
            if( gengc->pajTranslateVector != NULL &&
                (gengc->pajTranslateVector != gengc->xlatPalette) )
                GCFREE(gc, gengc->pajTranslateVector );

            gengc->pajTranslateVector =
                GCALLOCZ(gc, (MAXPALENTRIES+1)*sizeof(ULONG));

            // Change indexBits
            Modes->indexBits = numBits;

            // For depths greater than 8 bits, cfb->redMax must change if the
            // number of entries in the palette changes.
            // Also, change the writemask so that if the palette grows, the
            // new planes will be enabled by default.

            if (cfb = gc->front)
            {
                GLint oldRedMax;

                oldRedMax = cfb->redMax;
                cfb->redMax = (1 << gc->modes.indexBits) - 1;
                gc->state.raster.writeMask |= ~oldRedMax;
                gc->state.raster.writeMask &= cfb->redMax;
            }
            if (cfb = gc->back)
            {
                GLint oldRedMax;

                oldRedMax = cfb->redMax;
                cfb->redMax = (1 << gc->modes.indexBits) - 1;
                gc->state.raster.writeMask |= ~oldRedMax;
                gc->state.raster.writeMask &= cfb->redMax;
            }

            // store procs may need to be picked based on the change in
            // palette size

            __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
            MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
        }

        // Compute index-to-color table from current palette information

        wglComputeIndexedColors( gengc,
                                 (unsigned long *) gengc->pajTranslateVector,
                                 MAXPALENTRIES );
    }
}

// HandlePaletteChanges
//      Check if palette has changed, update translation vectors
//      XXX add support for malloc failures at attention time
// Synopsis:
//      void HandlePaletteChanges(
//          __GLGENcontext *gengc   specifies the generic RC
//
// Assumtions:
//   x   wglPaletteChanged() will always return 0 when no palette is set
//      by the client.  This has proved to be not always true.
//
// History:
// Feb. 25 Fixed by rightful owner
// Feb. ?? Mutilated by others
// Jan. 29 Marc Fortier [v-marcf] Wrote it.
void HandlePaletteChanges( __GLGENcontext *gengc, GLGENwindow *pwnd )
{
    ULONG Timestamp;
    GLuint paletteSize;
    PIXELFORMATDESCRIPTOR *pfmt;

    // No palettes for IC's
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        return;
    }

    Timestamp = wglPaletteChanged(gengc, pwnd);
    if (Timestamp != gengc->PaletteTimestamp)
    {
        pfmt = &gengc->gsurf.pfd;

        if (pfmt->iPixelType == PFD_TYPE_COLORINDEX)
        {
            if (pfmt->cColorBits <= 8)
            {
                paletteSize = 1 << pfmt->cColorBits;
            }
            else
            {
                paletteSize = min(wglPaletteSize(gengc), MAXPALENTRIES);
            }
        }
        else
        {
#ifndef _CLIENTSIDE_
            /* Only update RGB at makecurrent time */
            if( (gengc->PaletteTimestamp == INITIAL_TIMESTAMP) &&
                    (pfmt->cColorBits <= 8) )
#else
            if (pfmt->cColorBits <= 8)
#endif
            {
                paletteSize = 1 << pfmt->cColorBits;
            }
            else
            {
                paletteSize = 0;
            }
        }

        if (paletteSize)
        {
            SetColorTranslationVector( gengc, paletteSize,
                                       pfmt->cColorBits, pfmt->iPixelType );
        }

        EmptyFillStrokeCache(gengc);

        gengc->PaletteTimestamp = Timestamp;
    }
}

#ifdef _CLIENTSIDE_

/******************************Public*Routine******************************\
* wglFillBitfields
*
* Return the Red, Green, and Blue color masks based on the DC surface
* format.  The masks are returned in the pdwColorFields array in the
* order: red mask, green mask, blue mask.
*
* Note:
*   Should be called only for 16bpp or greater surfaces.
*
* History:
*  12-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
wglFillBitfields(PIXELFORMATDESCRIPTOR *ppfd, DWORD *pdwColorFields)
{
    *pdwColorFields++ = MaskFromBits(ppfd->cRedShift,   ppfd->cRedBits  );
    *pdwColorFields++ = MaskFromBits(ppfd->cGreenShift, ppfd->cGreenBits);
    *pdwColorFields++ = MaskFromBits(ppfd->cBlueShift,  ppfd->cBlueBits );
}

/******************************Public*Routine******************************\
* wglCreateBitmap
*
* Create a DIB section and color table that matches the specified format.
*
* Returns:
*   A valid bitmap handle if sucessful, NULL otherwise.
*
* History:
*  20-Sep-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP
wglCreateBitmap( __GLGENcontext *gengc, SIZEL sizl, PVOID *ppvBits )
{
    BITMAPINFO *pbmi;
    HBITMAP    hbmRet = (HBITMAP) NULL;
    size_t     cjbmi;
    DWORD      dwCompression;
    DWORD      cjImage = 0;
    WORD       wBitCount;
    int        cColors = 0;

    *ppvBits = (PVOID) NULL;

// Figure out what kind of DIB needs to be created based on the
// DC format.

    switch ( gengc->gsurf.pfd.cColorBits )
    {
    case 4:
        cjbmi = sizeof(BITMAPINFO) + 16*sizeof(RGBQUAD);
        dwCompression = BI_RGB;
        wBitCount = 4;
        cColors = 16;
        break;
    case 8:
        cjbmi = sizeof(BITMAPINFO) + 256*sizeof(RGBQUAD);
        dwCompression = BI_RGB;
        wBitCount = 8;
        cColors = 256;
        break;
    case 16:
        cjbmi = sizeof(BITMAPINFO) + 3*sizeof(RGBQUAD);
        dwCompression = BI_BITFIELDS;
        cjImage = sizl.cx * sizl.cy * 2;
        wBitCount = 16;
        break;
    case 24:
        cjbmi = sizeof(BITMAPINFO);
        dwCompression = BI_RGB;
        wBitCount = 24;
        break;
    case 32:
        cjbmi = sizeof(BITMAPINFO) + 3*sizeof(RGBQUAD);
        dwCompression = BI_BITFIELDS;
        cjImage = sizl.cx * sizl.cy * 4;
        wBitCount = 32;
        break;
    default:
        WARNING1("wglCreateBitmap: unknown format 0x%lx\n",
                 gengc->gsurf.pfd.cColorBits);
        return (HBITMAP) NULL;
    }

// Allocate the BITMAPINFO structure and color table.

    pbmi = ALLOC(cjbmi);
    if (pbmi)
    {
        pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth         = sizl.cx;
        pbmi->bmiHeader.biHeight        = sizl.cy;
        pbmi->bmiHeader.biPlanes        = 1;
        pbmi->bmiHeader.biBitCount      = wBitCount;
        pbmi->bmiHeader.biCompression   = dwCompression;
        pbmi->bmiHeader.biSizeImage     = cjImage;
        pbmi->bmiHeader.biXPelsPerMeter = 0;
        pbmi->bmiHeader.biYPelsPerMeter = 0;
        pbmi->bmiHeader.biClrUsed       = 0;
        pbmi->bmiHeader.biClrImportant  = 0;

    // Initialize DIB color table.

        switch (gengc->gsurf.pfd.cColorBits)
        {
        case 4:
        case 8:
            if (!wglGetSurfacePalette(gengc, &pbmi->bmiColors[0], FALSE))
            {
                return NULL;
            }
            break;

        case 16:
        case 32:
            wglFillBitfields(&gengc->gsurf.pfd, (DWORD *) &pbmi->bmiColors[0]);
            break;

        case 24:
            // Color table is assumed to be BGR for 24BPP DIBs.  Nothing to do.
            break;
        }

    // Create DIB section.

        hbmRet = CreateDIBSection(gengc->gwidCurrent.hdc, pbmi, DIB_RGB_COLORS,
                                  ppvBits, NULL, 0);

        #if DBG
        if ( hbmRet == (HBITMAP) NULL )
            WARNING("wglCreateBitmap(): DIB section creation failed\n");
        #endif

        FREE(pbmi);
    }
    else
    {
        WARNING("wglCreateBitmap(): memory allocation error\n");
    }

    return hbmRet;
}
#endif

/******************************Public*Routine******************************\
* wglCreateScanlineBuffers
*
* Allocate the scanline buffers.  The scanline buffers are used by the
* generic implementation to write data to the target (display or bitmap)
* a span at a time when the target surface is not directly accessible.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken from CreateGDIObjects and made into function.
\**************************************************************************/

BOOL FASTCALL wglCreateScanlineBuffers(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;
    PIXELFORMATDESCRIPTOR *pfmt;
    UINT cBits;
    UINT cBytes;
    SIZEL size;
    int cColorEntries;
    __GLcontext *gc;

    gc = (__GLcontext *)gengc;
    pfmt = &gengc->gsurf.pfd;

    //
    // Bitmap must have DWORD sized scanlines.
    //

    cBits = BITS_ALIGNDWORD(__GL_MAX_WINDOW_WIDTH * pfmt->cColorBits);
    cBytes = cBits / 8;

    //
    // Create color scanline DIB buffer.
    //

    size.cx = cBits / pfmt->cColorBits;
    size.cy = 1;
    gengc->ColorsMemDC = CreateCompatibleDC(gengc->gwidCurrent.hdc);
    gengc->ColorsBitmap = wglCreateBitmap(gengc, size,
                                          &gengc->ColorsBits);

    if ( (NULL == gengc->ColorsMemDC) ||
         (NULL == gengc->ColorsBitmap) ||
         (NULL == gengc->ColorsBits) ||
         !SelectObject(gengc->ColorsMemDC, gengc->ColorsBitmap) )
    {
        #if DBG
        if (!gengc->ColorsMemDC)
            WARNING("wglCreateScanlineBuffers: dc creation failed, ColorsMemDC\n");
        if (!gengc->ColorsBitmap)
            WARNING("wglCreateScanlineBuffers: bitmap creation failed, ColorsBitmap\n");
        if (!gengc->ColorsBits)
            WARNING("wglCreateScanlineBuffers: bitmap creation failed, ColorsBits\n");
        #endif

        goto wglCreateScanlineBuffers_exit;
    }

    //
    // Screen to DIB BitBlt performance on Win95 is very poor.
    // By doing the BitBlt via an intermediate DDB, we can avoid
    // a lot of unnecessary overhead.  So create an intermediate
    // scanline DDB to match ColorsBitmap.
    //

    if ((gengc->dwCurrentFlags & GLSURF_DIRECTDRAW) == 0)
    {
        gengc->ColorsDdbDc = CreateCompatibleDC(gengc->gwidCurrent.hdc);
        gengc->ColorsDdb = CreateCompatibleBitmap(gengc->gwidCurrent.hdc,
                                                  size.cx, size.cy);

        //!!!Viper fix -- Diamond Viper (Weitek 9000) fails
        //!!!             CreateCompatibleBitmap for some (currently unknown)
        //!!!             reason

        if ( !gengc->ColorsDdb )
        {
            WARNING("wglCreateScanlineBuffers: "
                    "CreateCompatibleBitmap failed\n");
            if (gengc->ColorsDdbDc)
                DeleteDC(gengc->ColorsDdbDc);
            gengc->ColorsDdbDc = (HDC) NULL;
        }
        else
        {
            if ( (NULL == gengc->ColorsDdbDc) ||
                 !SelectObject(gengc->ColorsDdbDc, gengc->ColorsDdb) )
            {
#if DBG
                if (!gengc->ColorsDdbDc)
                    WARNING("wglCreateScanlineBuffers: "
                            "dc creation failed, ColorsDdbDc\n");
                if (!gengc->ColorsDdb)
                    WARNING("wglCreateScanlineBuffers: "
                            "bitmap creation failed, ColorsDdb\n");
#endif

                goto wglCreateScanlineBuffers_exit;
            }
        }
    }

    //
    // Success.
    //

    bRet = TRUE;

wglCreateScanlineBuffers_exit:

    if (!bRet)
    {
        //
        // Error case.  Delete whatever may have been allocated.
        //

        wglDeleteScanlineBuffers(gengc);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglDeleteScanlineBuffers
*
* Delete the scanline buffers.  The scanline buffers are used by the
* generic implementation to write data to the target (display or bitmap)
* a span at a time when the target surface is not directly accessible.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken from CreateGDIObjects and made into function.
\**************************************************************************/

VOID FASTCALL wglDeleteScanlineBuffers(__GLGENcontext *gengc)
{
    __GLcontext *gc = (__GLcontext *)gengc;

    //
    // Delete color scanline DIB buffer.
    //

    if (gengc->ColorsMemDC)
    {
        DeleteDC(gengc->ColorsMemDC);
        gengc->ColorsMemDC = NULL;
    }

    if (gengc->ColorsBitmap)
    {
        if (!DeleteObject(gengc->ColorsBitmap))
            ASSERTOPENGL(FALSE, "wglDeleteScanlineBuffers: DeleteObject failed");
        gengc->ColorsBitmap = NULL;
        gengc->ColorsBits = NULL;   // deleted for us when DIB section dies
    }

    //
    // Delete intermediate color scanline DDB buffer.
    //

    if (gengc->ColorsDdbDc)
    {
        if (!DeleteDC(gengc->ColorsDdbDc))
        {
            ASSERTOPENGL(FALSE, "wglDeleteScanlineBuffers: DDB DeleteDC failed");
        }
        gengc->ColorsDdbDc = NULL;
    }

    if (gengc->ColorsDdb)
    {
        if (!DeleteObject(gengc->ColorsDdb))
        {
            ASSERTOPENGL(FALSE, "wglDeleteScanlineBuffers: DDB DeleteObject failed");
        }
        gengc->ColorsDdb = NULL;
    }
}

/******************************Public*Routine******************************\
* wglInitializeColorBuffers
*
* Initialize the color buffer (front and/or back) information.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken out of glsrvCreateContext and made into function.
\**************************************************************************/

VOID FASTCALL wglInitializeColorBuffers(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;

    gc->front = &gc->frontBuffer;

    if ( gc->modes.doubleBufferMode)
    {
        gc->back = &gc->backBuffer;

        if (gc->modes.colorIndexMode)
        {
            __glGenInitCI(gc, gc->front, GL_FRONT);
            __glGenInitCI(gc, gc->back, GL_BACK);
        }
        else
        {
            __glGenInitRGB(gc, gc->front, GL_FRONT);
            __glGenInitRGB(gc, gc->back, GL_BACK);
        }
    }
    else
    {
        if (gc->modes.colorIndexMode)
        {
            __glGenInitCI(gc, gc->front, GL_FRONT);
        }
        else
        {
            __glGenInitRGB(gc, gc->front, GL_FRONT);
        }
    }
}

/******************************Public*Routine******************************\
* wglInitializeDepthBuffer
*
* Initialize the depth buffer information.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken out of glsrvCreateContext and made into function.
\**************************************************************************/

VOID FASTCALL wglInitializeDepthBuffer(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;

    if (gc->modes.depthBits)
    {
        if (gengc->_pMcdState) {
            // This is not the final initialization of the MCD depth buffer.
            // This is being done now so that the validate proc can be done
            // in glsrvCreateContext.  The real initialization will occur
            // during glsrvMakeCurrent.

            GenMcdInitDepth(gc, &gc->depthBuffer);
            gc->depthBuffer.scale = gengc->_pMcdState->McdRcInfo.depthBufferMax;
        } else if (gc->modes.depthBits == 16) {
            DBGINFO("CALLING: __glInitDepth16\n");
            __glInitDepth16(gc, &gc->depthBuffer);
            gc->depthBuffer.scale = 0x7fff;
        } else {
            DBGINFO("CALLING: __glInitDepth32\n");
            __glInitDepth32(gc, &gc->depthBuffer);
            gc->depthBuffer.scale = 0x7fffffff;
        }
        /*
         *  Note: scale factor does not use the high bit (this avoids
         *  floating point exceptions).
         */
        // XXX (mf) I changed 16 bit depth buffer to use high bit, since
        // there is no possibility of overflow on conversion to float.  For
        // 32-bit, (float) 0xffffffff overflows to 0.  I was able to avoid
        // overflow in this case by using a scale factor of 0xffffff7f, but
        // this is a weird number, and 31 bits is enough resolution anyways.
        // !! Note asserts in px_fast.c that have hardcoded depth scales.
    }
#ifdef _MCD_
    else
    {
        // This is not the final initialization of the MCD depth buffer.
        // This is being done now so that the validate proc can be done
        // in glsrvCreateContext.  The real initialization will occur
        // during glsrvMakeCurrent.

        GenMcdInitDepth(gc, &gc->depthBuffer);
        gc->depthBuffer.scale = 0x7fffffff;
    }
#endif
}

/******************************Public*Routine******************************\
* wglInitializePixelCopyFuncs
*
* Set the appropriate CopyPixels and PixelVisible functions in the context.
*
* History:
*  18-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken out of glsrvCreateContext and made into function.
\**************************************************************************/

VOID FASTCALL wglInitializePixelCopyFuncs(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;

    if ( gc->front->buf.flags & DIB_FORMAT )
        gengc->pfnCopyPixels = dibCopyPixels;
    else {
        if (gengc->pMcdState) {
            gengc->ColorsBits = gengc->pMcdState->pMcdSurf->McdColorBuf.pv;
            gengc->pfnCopyPixels = GenMcdCopyPixels;
        }
        else
            gengc->pfnCopyPixels = gdiCopyPixels;
    }
    gengc->pfnPixelVisible = wglPixelVisible;
}

/******************************Public*Routine******************************\
* CreateGDIObjects
*
* Create various buffers, and GDI objects that we will always need.
*
* Called from glsrvCreateContext().
*
* Returns:
*   TRUE if sucessful, FALSE if error.
*
\**************************************************************************/

BOOL FASTCALL CreateGDIObjects(__GLGENcontext *gengc)
{
    PIXELFORMATDESCRIPTOR *pfmt;
    UINT  cBytes;
    SIZEL size;
    int cColorEntries;
    __GLcontext *gc;

    gc = (__GLcontext *)gengc;
    pfmt = &gengc->gsurf.pfd;

    //
    // Palette translation vectors.
    //
    // If not a true color surface, need space for the foreground xlation
    //

    if (pfmt->cColorBits <= 8)
    {
        cColorEntries = 1 << pfmt->cColorBits;

        ASSERTOPENGL(NULL == gengc->pajTranslateVector, "have a xlate vector");

        //
        // Just set the translation vector to the cache space in the gc:
        //

        gengc->pajTranslateVector = gengc->xlatPalette;

        //
        // Allocate the inverse translation vector.
        //

        ASSERTOPENGL(NULL == gengc->pajInvTranslateVector, "have an inv xlate vector");
        gengc->pajInvTranslateVector = GCALLOCZ(gc, cColorEntries);
        if (NULL == gengc->pajInvTranslateVector)
        {
            WARNING("CreateGDIObjects: memory allocation failed, pajInvTrans\n");
            goto ERROR_EXIT;
        }
    }

    //
    // Scanline buffers.
    //
    // Always create engine bitmaps to provide a generic means of performing
    // pixel transfers using the ColorsBits and StippleBits buffers.
    //

    if (NULL == gengc->ColorsBits)
    {
        //
        // Color scanline buffer
        //

#ifdef _MCD_
        //
        // If MCD the ColorBits will be set when the MCD surface is
        // created, so nothing to do.
        //
        // Otherwise, create the generic scanline buffer.
        //
        //

        if (!gengc->_pMcdState)
#endif
        {
            //
            // Generic case.
            //

            if (!wglCreateScanlineBuffers(gengc))
            {
                WARNING("CreateGDIObjects: wglCreateScanlineBuffers failed\n");
                goto ERROR_EXIT;
            }
        }

        //
        // Stipple scanline buffer.
        //

        // Bitmap must have DWORD sized scanlines.  Note that stipple only
        // requires a 1 bit per pel bitmap.

        ASSERTOPENGL(NULL == gengc->StippleBits, "StippleBits not null");
        size.cx = BITS_ALIGNDWORD(__GL_MAX_WINDOW_WIDTH);
        cBytes = size.cx / 8;
        gengc->StippleBits = GCALLOCZ(gc, cBytes);
        if (NULL == gengc->StippleBits)
        {
            WARNING("CreateGDIObjects: memory allocation failed, StippleBits\n");
            goto ERROR_EXIT;
        }

        ASSERTOPENGL(NULL == gengc->StippleBitmap, "StippleBitmap not null");
#ifndef _CLIENTSIDE_
//!!!XXX -- why are we even bothering to make the stipple an engine bitmap?
//!!!XXX    It is never used as such (at least not yet).
        gengc->StippleBitmap = EngCreateBitmap(
                                size,
                                cBytes,
                                BMF_1BPP,
                                0,
                                gengc->StippleBits);
        if (NULL == gengc->StippleBitmap)
        {
            WARNING("CreateGDIObjects: memory allocation failed, StippleBitmap\n");
            goto ERROR_EXIT;
        }
#else
        gengc->StippleBitmap = (HBITMAP) NULL;
#endif
    }

    return TRUE;

ERROR_EXIT:

//
// Error cleanup --
// Destroy everything we might have created, return false so makecurrent fails.
//

    if (gengc->pajTranslateVector &&
        (gengc->pajTranslateVector != gengc->xlatPalette))
    {
        GCFREE(gc,gengc->pajTranslateVector);
        gengc->pajTranslateVector = NULL;
    }

    if (gengc->pajInvTranslateVector)
    {
        GCFREE(gc,gengc->pajInvTranslateVector);
        gengc->pajInvTranslateVector = NULL;
    }

    wglDeleteScanlineBuffers(gengc);

    if (gengc->StippleBits)
    {
        GCFREE(gc,gengc->StippleBits);
        gengc->StippleBits = NULL;
    }

#ifndef _CLIENTSIDE_
    if (gengc->StippleBitmap)
    {
        if (!EngDeleteSurface((HSURF)gengc->StippleBitmap))
            ASSERTOPENGL(FALSE, "EngDeleteSurface failed");
        gengc->StippleBitmap = NULL;
    }
#endif

    return FALSE;
}

/******************************Public*Routine******************************\
* ApplyViewport
*
* Recompute viewport state and clipbox.  May also be called via the
* applyViewport function pointer in the gc's proc table.
*
\**************************************************************************/

// This routine can be called because of a user vieport command, or because
// of a change in the size of the window

static void FASTCALL ApplyViewport(__GLcontext *gc)
{
    GLint xlow, ylow, xhigh, yhigh;
    GLint llx, lly, urx, ury;
    GLboolean lastReasonable;
    GLGENwindow *pwnd;
    GLint clipLeft, clipRight, clipTop, clipBottom;
    __GLGENcontext *gengc = (__GLGENcontext *) gc;

    DBGENTRY("ApplyViewport\n");

    ASSERTOPENGL(gengc->pwndLocked != NULL,
                 "ApplyViewport called without lock\n");
    
    pwnd = gengc->pwndLocked;
    if (pwnd)
    {
        gengc->visibleWidth = pwnd->rclBounds.right - pwnd->rclBounds.left;
        gengc->visibleHeight = pwnd->rclBounds.bottom - pwnd->rclBounds.top;
    }
    else
    {
        gengc->visibleWidth = 0;
        gengc->visibleHeight = 0;
    }

    // Sanity check the info from window.
    ASSERTOPENGL(
        gengc->visibleWidth <= __GL_MAX_WINDOW_WIDTH && gengc->visibleHeight <= __GL_MAX_WINDOW_HEIGHT,
        "ApplyViewport(): bad visible rect size\n"
        );

    /* If this viewport is fully contained in the window, we note this fact,
    ** and this can save us on scissoring tests.
    */
    if (gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE)
    {
        xlow  = gc->state.scissor.scissorX;
        xhigh = xlow + gc->state.scissor.scissorWidth;
        ylow  = gc->state.scissor.scissorY;
        yhigh = ylow + gc->state.scissor.scissorHeight;
    }
    else
    {
        xlow = 0;
        ylow = 0;
        xhigh = gc->constants.width;
        yhigh = gc->constants.height;
    }

    /*
    ** convert visible region to GL coords and intersect with scissor
    */
    if (pwnd)
    {
        clipLeft   = pwnd->rclBounds.left - pwnd->rclClient.left;
        clipRight  = pwnd->rclBounds.right - pwnd->rclClient.left;
        clipTop    = gc->constants.height -
                     (pwnd->rclBounds.top - pwnd->rclClient.top);
        clipBottom = gc->constants.height -
                     (pwnd->rclBounds.bottom - pwnd->rclClient.top);
    }
    else
    {
        clipLeft   = 0;
        clipRight  = 0;
        clipTop    = 0;
        clipBottom = 0;
    }

    if (xlow  < clipLeft)   xlow  = clipLeft;
    if (xhigh > clipRight)  xhigh = clipRight;
    if (ylow  < clipBottom) ylow  = clipBottom;
    if (yhigh > clipTop)    yhigh = clipTop;

// ComputeClipBox

    {
        if (xlow >= xhigh || ylow >= yhigh)
        {
            gc->transform.clipX0 = gc->constants.viewportXAdjust;
            gc->transform.clipX1 = gc->constants.viewportXAdjust;
            gc->transform.clipY0 = gc->constants.viewportYAdjust;
            gc->transform.clipY1 = gc->constants.viewportYAdjust;
        }
        else
        {
            gc->transform.clipX0 = xlow + gc->constants.viewportXAdjust;
            gc->transform.clipX1 = xhigh + gc->constants.viewportXAdjust;

            if (gc->constants.yInverted) {
                gc->transform.clipY0 = (gc->constants.height - yhigh) +
                    gc->constants.viewportYAdjust;
                gc->transform.clipY1 = (gc->constants.height - ylow) +
                    gc->constants.viewportYAdjust;
            } else {
                gc->transform.clipY0 = ylow + gc->constants.viewportYAdjust;
                gc->transform.clipY1 = yhigh + gc->constants.viewportYAdjust;
            }
        }
    }

    llx    = (GLint)gc->state.viewport.x;
    lly    = (GLint)gc->state.viewport.y;

    urx    = llx + (GLint)gc->state.viewport.width;
    ury    = lly + (GLint)gc->state.viewport.height;

#ifdef NT
    gc->transform.miny = (gc->constants.height - ury) +
            gc->constants.viewportYAdjust;
    gc->transform.maxy = gc->transform.miny + (GLint)gc->state.viewport.height;
    gc->transform.fminy = (__GLfloat)gc->transform.miny;
    gc->transform.fmaxy = (__GLfloat)gc->transform.maxy;

// The viewport xScale, xCenter, yScale and yCenter values are computed in
// first MakeCurrent and subsequent glViewport calls.  When the window is
// resized (i.e. gc->constatns.height changes), however, we need to recompute
// yCenter if yInverted is TRUE.

    if (gc->constants.yInverted)
    {
        __GLfloat hh, h2;

        h2 = gc->state.viewport.height * __glHalf;
        hh = h2 - gc->constants.viewportEpsilon;
        gc->state.viewport.yCenter =
            gc->constants.height - (gc->state.viewport.y + h2) +
            gc->constants.fviewportYAdjust;

#if 0
        DbgPrint("AV ys %.3lf, yc %.3lf (%.3lf)\n",
                 -hh, gc->state.viewport.yCenter,
                 gc->constants.height - (gc->state.viewport.y + h2));
#endif
    }
#else
    ww     = gc->state.viewport.width * __glHalf;
    hh     = gc->state.viewport.height * __glHalf;

    gc->state.viewport.xScale = ww;
    gc->state.viewport.xCenter = gc->state.viewport.x + ww +
        gc->constants.fviewportXAdjust;

    if (gc->constants.yInverted) {
        gc->state.viewport.yScale = -hh;
        gc->state.viewport.yCenter =
            (gc->constants.height - gc->constants.viewportEpsilon) -
            (gc->state.viewport.y + hh) +
            gc->constants.fviewportYAdjust;
    } else {
        gc->state.viewport.yScale = hh;
        gc->state.viewport.yCenter = gc->state.viewport.y + hh +
            gc->constants.fviewportYAdjust;
    }
#endif

    // Remember the current reasonableViewport.  If it changes, we may
    // need to change the pick procs.

    lastReasonable = gc->transform.reasonableViewport;

    // Is viewport entirely within the visible bounding rectangle (which
    // includes scissoring if it is turned on)?  reasonableViewport is
    // TRUE if so, FALSE otherwise.
    // The viewport must also have a non-zero size to be reasonable

    if (llx >= xlow && lly >= ylow && urx <= xhigh && ury <= yhigh &&
        urx-llx >= 1 && ury-lly >= 1)
    {
        gc->transform.reasonableViewport = GL_TRUE;
    } else {
        gc->transform.reasonableViewport = GL_FALSE;
    }

#if 0
    DbgPrint("%3X:Clipbox %4d,%4d - %4d,%4d, reasonable %d, g %p, w %p\n",
             GetCurrentThreadId(),
             gc->transform.clipX0, gc->transform.clipY0,
             gc->transform.clipX1, gc->transform.clipY1,
             gc->transform.reasonableViewport,
             gc, ((__GLGENcontext *)gc)->pwndLocked);
#endif

#ifdef NT
// To be safe than sorry.  The new poly array does not break up Begin/End pair.

    if (lastReasonable != gc->transform.reasonableViewport)
        __GL_DELAY_VALIDATE(gc);

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, VIEWPORT);
#endif

#else
    // Old code use to use __GL_DELAY_VALIDATE() macro, this would
    // blow up if resize/position changed and a flush occured between
    // a glBegin/End pair.  Only need to pick span, line, & triangle procs
    // since that is safe

    if (lastReasonable != gc->transform.reasonableViewport) {
        (*gc->procs.pickSpanProcs)(gc);
        (*gc->procs.pickTriangleProcs)(gc);
        (*gc->procs.pickLineProcs)(gc);
    }
#endif
}

/******************************Public*Routine******************************\
* __glGenFreeBuffers
*
* Free the __GLGENbuffers structure and its associated ancillary and
* back buffers.
*
\**************************************************************************/

void FASTCALL __glGenFreeBuffers(__GLGENbuffers *buffers)
{
    if (buffers == NULL)
    {
        return;
    }
    
#if DBG
    DBGBEGIN(LEVEL_INFO)
        DbgPrint("glGenFreeBuffers 0x%x, 0x%x, 0x%x, 0x%x\n",
                 buffers->accumBuffer.base,
                 buffers->stencilBuffer.base,
                 buffers->depthBuffer.base,
                 buffers);
    DBGEND;
#endif
        
    //
    // Free ancillary buffers
    //

    if (buffers->accumBuffer.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing accumulation buffer\n");
        FREE(buffers->accumBuffer.base);
    }
    if (buffers->stencilBuffer.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing stencil buffer\n");
        FREE(buffers->stencilBuffer.base);
    }

    //
    // Free alpha buffers
    //
    if (buffers->alphaBuffer0.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing alpha buffer 0\n");
        FREE(buffers->alphaBuffer0.base);
    }
    if (buffers->alphaBuffer1.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing alpha buffer 1\n");
        FREE(buffers->alphaBuffer1.base);
    }

    //
    // If its not an MCD managed depth buffer, free the depth
    // buffer.
    //

    if (buffers->resizeDepth != ResizeUnownedDepthBuffer)
    {
        if (buffers->depthBuffer.base)
        {
            DBGLEVEL(LEVEL_ALLOC,
                     "__glGenFreeBuffers: Freeing depth buffer\n");
            FREE(buffers->depthBuffer.base);
        }
    }

    //
    // Free back buffer if we allocated one
    //

    if (buffers->backBitmap.pvBits) {
        // Note: the DIB section deletion will delete
        //       buffers->backBitmap.pvBits for us
        
        if (!DeleteDC(buffers->backBitmap.hdc))
            WARNING("__glGenFreeBuffers: DeleteDC failed\n");
        DeleteObject(buffers->backBitmap.hbm);
    }

#ifdef _MCD_
    //
    // Free MCD surface.
    //

    if (buffers->pMcdSurf) {
        GenMcdDeleteSurface(buffers->pMcdSurf);
    }
#endif

    //
    // free up swap hint region
    //

    {
        PYLIST pylist;
        PXLIST pxlist;

        RECTLISTSetEmpty(&buffers->rl);

        //
        // Free up the free lists
        //

        pylist = buffers->pylist;
        while (pylist) {
            PYLIST pylistKill = pylist;
            pylist = pylist->pnext;
            FREE(pylistKill);
        }
        buffers->pylist = NULL;

        pxlist = buffers->pxlist;
        while (pxlist) {
            PXLIST pxlistKill = pxlist;
            pxlist = pxlist->pnext;
            FREE(pxlistKill);
        }
        buffers->pxlist = NULL;
    }

    //
    // Free the private structure
    //
    
    FREE(buffers);
}

/******************************Public*Routine******************************\
* __glGenAllocAndInitPrivateBufferStruct
*
* Allocates and initializes a __GLGENbuffers structure and saves it as
* the drawable private data.
*
* The __GLGENbuffers structure contains the shared ancillary and back
* buffers, as well as the cache of clip rectangles enumerated from the
* CLIPOBJ.
*
* The __GLGENbuffers structure and its data is freed by calling
* __glGenFreeBuffers.
*
* Returns:
*   NULL if error.
*
\**************************************************************************/

static __GLGENbuffers *
__glGenAllocAndInitPrivateBufferStruct(__GLcontext *gc)
{
    __GLGENbuffers *buffers;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;

    /* No private structure, no ancillary buffers */
    DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: No private struct existed\n");

    buffers = (__GLGENbuffers *)ALLOCZ(sizeof(__GLGENbuffers));
    if (NULL == buffers)
        return(NULL);

    buffers->resize = ResizeAncillaryBuffer;
    buffers->resizeDepth = ResizeAncillaryBuffer;

    buffers->accumBuffer.elementSize = gc->accumBuffer.buf.elementSize;
    buffers->depthBuffer.elementSize = gc->depthBuffer.buf.elementSize;
    buffers->stencilBuffer.elementSize = gc->stencilBuffer.buf.elementSize;

    buffers->stencilBits = ppfd->cStencilBits;
    buffers->depthBits   = ppfd->cDepthBits;
    buffers->accumBits   = ppfd->cAccumBits;
    buffers->colorBits   = ppfd->cColorBits;
    buffers->alphaBits   = ppfd->cAlphaBits;

    if (gc->modes.accumBits) {
        gc->accumBuffer.buf.base = 0;
        gc->accumBuffer.buf.size = 0;
        gc->accumBuffer.buf.outerWidth = 0;
    }
    buffers->alphaFrontBuffer = buffers->alphaBackBuffer = NULL;
    // These base values must *always* be set to 0, regardless of alphaBits,
    //  since base will be free'd if non-zero on buffer deletion
    buffers->alphaBuffer0.base = 0;
    buffers->alphaBuffer1.base = 0;
    if (gc->modes.alphaBits) {
        buffers->alphaBuffer0.size = 0;
        buffers->alphaBuffer0.outerWidth = 0;
        buffers->alphaFrontBuffer = &buffers->alphaBuffer0;
        if (gc->modes.doubleBufferMode) {
            buffers->alphaBuffer1.size = 0;
            buffers->alphaBuffer1.outerWidth = 0;
            buffers->alphaBackBuffer = &buffers->alphaBuffer1;
        }
    }
    if (gc->modes.depthBits) {
        gc->depthBuffer.buf.base = 0;
        gc->depthBuffer.buf.size = 0;
        gc->depthBuffer.buf.outerWidth = 0;
    }
    if (gc->modes.stencilBits) {
        gc->stencilBuffer.buf.base = 0;
        gc->stencilBuffer.buf.size = 0;
        gc->stencilBuffer.buf.outerWidth = 0;
    }

    // If double-buffered, initialize the fake window for the back buffer
    if (gc->modes.doubleBufferMode)
    {
        buffers->backBitmap.pwnd = &buffers->backBitmap.wnd;
        buffers->backBitmap.wnd.clipComplexity = DC_TRIVIAL;
        buffers->backBitmap.wnd.rclBounds.left = 0;
        buffers->backBitmap.wnd.rclBounds.top = 0;
        buffers->backBitmap.wnd.rclBounds.right = 0;
        buffers->backBitmap.wnd.rclBounds.bottom = 0;
        buffers->backBitmap.wnd.rclClient =
            buffers->backBitmap.wnd.rclBounds;
    }

#ifdef _MCD_
    if (gengc->_pMcdState &&
        !(gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC)) {
        if (bInitMcdSurface(gengc, gengc->pwndLocked, buffers)) {
            if (gengc->pMcdState->pDepthSpan) {
                gc->depthBuffer.buf.base = gengc->pMcdState->pDepthSpan;
                buffers->depthBuffer.base = gengc->pMcdState->pDepthSpan;
                buffers->resizeDepth = ResizeUnownedDepthBuffer;
            }
        } else {
            WARNING("__glGenAllocAndInitPrivateBufferStruct: bInitMcdSurface failed\n");
            FREE(buffers);
            return NULL;
        }
    }
    else
#endif

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        // DDraw surfaces provide their own depth buffers
        buffers->resizeDepth = ResizeUnownedDepthBuffer;
    }
    
    buffers->clip.WndUniq = -1;

   //
   // init swap hint region
   //

   buffers->pxlist = NULL;
   buffers->pylist = NULL;

   buffers->rl.buffers = buffers;
   buffers->rl.pylist  = NULL;

   buffers->fMax = FALSE;

   return buffers;
}

/******************************Public*Routine******************************\
* __glGenCheckBufferStruct
*
* Check if context and buffer struct are compatible.
*
* To satisfy this requirement, the attributes of the shared buffers
* (back, depth, stencil, and accum) must match.  Otherwise, the context
* cannot be used with the given set of buffers.
*
* Returns:
*   TRUE if compatible, FALSE otherwise.
*
* History:
*  17-Jul-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLboolean __glGenCheckBufferStruct(__GLcontext *gc, __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;

    if ((buffers->stencilBits == ppfd->cStencilBits) &&
        (buffers->depthBits   == ppfd->cDepthBits  ) &&
        (buffers->accumBits   == ppfd->cAccumBits  ) &&
        (buffers->colorBits   == ppfd->cColorBits  ) &&
        (buffers->alphaBits   == ppfd->cAlphaBits  ))
    {
        bRet = TRUE;
    }

    return (GLboolean)bRet;
}

/******************************Public*Routine******************************\
* glsrvMakeCurrent
*
* Make generic context current to this thread with specified DC.
*
* Returns:
*   TRUE if sucessful.
*
\**************************************************************************/

// Upper level code should make sure that this context is not current to
// any other thread, that we "lose" the old context first
// Called with DEVLOCK held, free to modify window
//
// FALSE will be returned if we cannot create the objects we need
// rcobj.cxx will set the error code to show we are out of memory

BOOL APIENTRY glsrvMakeCurrent(GLWINDOWID *pgwid, __GLcontext *gc,
                               GLGENwindow *pwnd)
{
    __GLGENcontext *gengc;
    __GLGENbuffers *buffers;
    GLint width, height;
    BOOL bFreePwnd = FALSE;
    BOOL bUninitSem = FALSE;

    DBGENTRY("Generic MakeCurrent\n");
    
    // Common initialization
    gengc = (__GLGENcontext *)gc;
    
    ASSERTOPENGL(GLTEB_SRVCONTEXT() == 0, "current context in makecurrent!");
    ASSERTOPENGL(gengc->pwndMakeCur == NULL &&
                 gengc->pwndLocked == NULL,
                 "Non-current context has window pointers\n");
    
    gengc->gwidCurrent = *pgwid;
    if (pwnd == NULL)
    {
        ASSERTOPENGL((gengc->gsurf.dwFlags & GLSURF_METAFILE),
                     "Non-metafile surface without a window\n");

        // Drawing on an IC, create a fake window with no visible area
        pwnd = (GLGENwindow *)ALLOC(sizeof(GLGENwindow));
        if (pwnd == NULL)
        {
            WARNING("glsrvMakeCurrent: memory allocation failure "
                    "(IC, window)\n");
            goto ERROR_EXIT;
        }
        bFreePwnd = TRUE;

        RtlZeroMemory(pwnd, sizeof(GLGENwindow));
        pwnd->clipComplexity = DC_TRIVIAL;

        // This window data is private so technically there'll never
        // be another thread accessing it so this critsec is unnecessary.
        // However, having it eliminates special cases where
        // window locks are taken or checked for ownership.
        __try
        {
            InitializeCriticalSection(&pwnd->sem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            goto ERROR_EXIT;
        }
        bUninitSem = TRUE;

        // Set this so CreateGDIObjects doesn't attempt to create
        // zero-size objects
        gengc->ColorsBits = (void *)1;

        gengc->dwCurrentFlags = gengc->gsurf.dwFlags;
    }
    else if (pgwid->iType == GLWID_DDRAW)
    {
        gengc->dwCurrentFlags = gengc->gsurf.dwFlags;
    }
    else
    {
        GLSURF gsurf;

        if (!InitDeviceSurface(pgwid->hdc, pwnd->ipfd, gengc->gsurf.iLayer,
                               wglObjectType(pgwid->hdc), FALSE, &gsurf))
        {
            goto ERROR_EXIT;
        }

        gengc->dwCurrentFlags = gsurf.dwFlags;
    }
    
    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        gengc->pgddsFront = &gengc->gsurf.dd.gddsFront;
    }
    else if (GLDIRECTSCREEN && GLSURF_IS_SCREENDC(gengc->dwCurrentFlags))
    {
        gengc->pgddsFront = &GLSCREENINFO->gdds;
    }
    else
    {
        gengc->pgddsFront = NULL;
    }

    // We need this field to tell whether we're using a fake window
    // or a real one.
    gengc->ipfdCurrent = pwnd->ipfd;

    gengc->pwndMakeCur = pwnd;
    ENTER_WINCRIT_GC(pwnd, gengc);

    width = pwnd->rclClient.right - pwnd->rclClient.left;
    height = pwnd->rclClient.bottom - pwnd->rclClient.top;
    gengc->errorcode = 0;

    // Sanity check the info from window.
    ASSERTOPENGL(
        width <= __GL_MAX_WINDOW_WIDTH && height <= __GL_MAX_WINDOW_HEIGHT,
        "glsrvMakeCurrrent(): bad window client size\n"
        );

    // Make our context current in the TEB.
    // If failures after this point, make sure to reset TEB entry
    // Set up this thread's paTeb pointer.
    gc->paTeb = GLTEB_CLTPOLYARRAY();
    GLTEB_SET_SRVCONTEXT(gc);

    buffers = pwnd->buffers;

    /* We inherit any drawable state */
    if (buffers)
    {
        gc->constants.width = buffers->width;
        gc->constants.height = buffers->height;

        if (!__glGenCheckBufferStruct(gc, buffers))
        {
            WARNING("glsrvMakeCurrent: __glGenCheckBufferStruct failed\n");
            goto ERROR_EXIT;
        }

#ifdef _MCD_
        if (GLSURF_IS_DIRECTDC(gengc->dwCurrentFlags))
        {
            if (!(gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC) &&
                !(buffers->flags & GLGENBUF_MCD_LOST))
            {
                gengc->pMcdState = gengc->_pMcdState;

            // Reset MCD scaling values since we're now using
            // MCD hardware acceleration:

                GenMcdSetScaling(gengc);

                if (gengc->pMcdState)
                {
                    gengc->pMcdState->pMcdSurf = buffers->pMcdSurf;
                    if (buffers->pMcdSurf)
                    {
                        gengc->pMcdState->pDepthSpan = buffers->pMcdSurf->pDepthSpan;
                    }
                    else
                    {
                        WARNING("glsrvMakeCurrent: MCD context, generic surface\n");
                        goto ERROR_EXIT;
                    }
                }
                else
                {
                // Generic context.  If the surface is an MCD surface, we
                // cannot continue.  The context is generic but the pixelfmt
                // is MCD, so what must have happened is that we  attempted
                // to create an MCD context, but failed, so we reverted
                // to generic.

                    if (buffers->pMcdSurf)
                    {
                        WARNING("glsrvMakeCurrent: generic context, MCD surface\n");
                        goto ERROR_EXIT;
                    }
                }
            }
            else
            {
                gengc->pMcdState = (GENMCDSTATE *)NULL;

            // Reset MCD scaling values since we've fallen back to
            // software:

                GenMcdSetScaling(gengc);

            // If MCD context (or former context), either surface or context
            // needs conversion.
            //
            // The only other way to get here is if this is a generic context
            // an a converted surface, which is perfectly OK and requires no
            // further conversion.

                //!!!SP1 -- should be able to skip this section if no conversion
                //!!!SP1    needed, but we miss out on the forced repick, which
                //!!!SP!    could be risky for NT4.0
                //if (gengc->_pMcdState &&
                //    (!(gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC) ||
                //     !(buffers->flags & GLGENBUF_MCD_LOST)))
                if (gengc->_pMcdState)
                {
                    BOOL bConverted;

                // Do conversion.  We must have color scales set to do the
                // conversion, but we must restore color scales afterwards.

                    __glContextSetColorScales(gc);
                    bConverted = GenMcdConvertContext(gengc, buffers);
                    __glContextUnsetColorScales(gc);

                // Fail makecurrent if conversion failed.

                    if (!bConverted)
                    {
                        WARNING("glsrvMakeCurrent: GenMcdConvertContext failed\n");
                        goto ERROR_EXIT;
                    }
                }
            }
        }
        else
            gengc->pMcdState = (GENMCDSTATE *)NULL;

#endif

        if (buffers->accumBuffer.base && gc->modes.accumBits)
        {
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Accumulation buffer existed\n");
            gc->accumBuffer.buf.base = buffers->accumBuffer.base;
            gc->accumBuffer.buf.size = buffers->accumBuffer.size;
            gc->accumBuffer.buf.outerWidth = buffers->width;
            gc->modes.haveAccumBuffer = GL_TRUE;
        }
        else
        {
            /* No Accum buffer at this point in time */
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Accum buffer doesn't exist\n");
            gc->accumBuffer.buf.base = 0;
            gc->accumBuffer.buf.size = 0;
            gc->accumBuffer.buf.outerWidth = 0;
        }
        if (buffers->depthBuffer.base && gc->modes.depthBits)
        {
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Depth buffer existed\n");
            gc->depthBuffer.buf.base = buffers->depthBuffer.base;
            gc->depthBuffer.buf.size = buffers->depthBuffer.size;
            gc->depthBuffer.buf.outerWidth = buffers->width;
            gc->modes.haveDepthBuffer = GL_TRUE;
        }
        else
        {
            /* No Depth buffer at this point in time */
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Depth buffer doesn't exist\n");
            gc->depthBuffer.buf.base = 0;
            gc->depthBuffer.buf.size = 0;
            gc->depthBuffer.buf.outerWidth = 0;
        }
        if (buffers->stencilBuffer.base && gc->modes.stencilBits)
        {
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Stencil buffer existed\n");
            gc->stencilBuffer.buf.base = buffers->stencilBuffer.base;
            gc->stencilBuffer.buf.size = buffers->stencilBuffer.size;
            gc->stencilBuffer.buf.outerWidth = buffers->width;
            gc->modes.haveStencilBuffer = GL_TRUE;
        }
        else
        {
            /* No Stencil buffer at this point in time */
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent:Stencil buffer doesn't exist\n");
            gc->stencilBuffer.buf.base = 0;
            gc->stencilBuffer.buf.size = 0;
            gc->stencilBuffer.buf.outerWidth = 0;
        }
    }
    else
    {
        gc->modes.haveStencilBuffer = GL_FALSE;
        gc->modes.haveDepthBuffer   = GL_FALSE;
        gc->modes.haveAccumBuffer   = GL_FALSE;
    }
    
    /*
    ** Allocate and initialize ancillary buffers structures if none were
    ** inherited.  This will happen if an RC has previously been current
    ** and is made current to a new window.
    */
    if (!buffers)
    {
        buffers = __glGenAllocAndInitPrivateBufferStruct(gc);
        if (NULL == buffers)
        {
            WARNING("glsrvMakeCurrent: __glGenAllocAndInitPrivateBufferStruct failed\n");
            goto ERROR_EXIT;
        }

        pwnd->buffers = buffers;
    }

    // Setup pointer to generic back buffer
    if ( gc->modes.doubleBufferMode)
    {
        gc->backBuffer.bitmap = &buffers->backBitmap;
        UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
    }

    // Setup alpha buffer pointers
    
    if ( buffers->alphaBits )
    {
        UpdateSharedBuffer( &gc->frontBuffer.alphaBuf.buf, 
                            buffers->alphaFrontBuffer );
        buffers->alphaFrontBuffer->elementSize = 
                                gc->frontBuffer.alphaBuf.buf.elementSize;
        if ( gc->modes.doubleBufferMode)
        {
            UpdateSharedBuffer( &gc->backBuffer.alphaBuf.buf, 
                                buffers->alphaBackBuffer );
            buffers->alphaBackBuffer->elementSize = 
                                gc->backBuffer.alphaBuf.buf.elementSize;
        }
    }

    if (gc->gcSig != GC_SIGNATURE)
    {
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_ALL);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ALL);
#endif

        // After initializing all of the individual buffer structures, make
        // sure we copy the element size back into the shared buffer.
        // This is a little clumsy,

        buffers->accumBuffer.elementSize = gc->accumBuffer.buf.elementSize;
        buffers->depthBuffer.elementSize = gc->depthBuffer.buf.elementSize;
        buffers->stencilBuffer.elementSize = gc->stencilBuffer.buf.elementSize;

        // We always need to initialize the MCD-related scaling values:

        GenMcdSetScaling(gengc);

        /*
        ** Need some stuff to exist before doing viewport stuff.
        */
        (*gc->procs.validate)(gc);

        /*
        ** The first time a context is made current the spec requires that
        ** the viewport be initialized.  The code below does it.
        ** The ApplyViewport() routine will be called inside Viewport()
        */

        __glim_Viewport(0, 0, width, height);
        __glim_Scissor(0, 0, width, height);

        /*
        ** Now that viewport is set, need to revalidate (initializes all
        ** the proc pointers).
        */
        (*gc->procs.validate)(gc);

        gc->gcSig = GC_SIGNATURE;
    }
    else        /* Not the first makecurrent for this RC */
    {
        /* This will check the window size, and recompute relevant state */
        ApplyViewport(gc);
    }

#ifdef _MCD_

    if (gengc->pMcdState)
    {
        // Now that we are assured that the mcd state is fully initialized,
        // configure the depth buffer.

        GenMcdInitDepth(gc, &gc->depthBuffer);
        if (gc->modes.depthBits)
        {
            gc->depthBuffer.scale =
                gengc->pMcdState->McdRcInfo.depthBufferMax;
        }
        else
        {
            gc->depthBuffer.scale = 0x7fffffff;
        }

        // Bind MCD context to window.

        if (!GenMcdMakeCurrent(gengc, pwnd))
        {
            goto ERROR_EXIT;
        }

        gengc->pMcdState->mcdFlags |=
            (MCD_STATE_FORCEPICK | MCD_STATE_FORCERESIZE);

        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_ALL);
        MCD_STATE_DIRTY(gc, ALL);
    }

#endif

    // Common initialization

    // Select correct pixel-copy function

    wglInitializePixelCopyFuncs(gengc);

    // Set front-buffer HDC, window to current HDC, window
    gc->front->bitmap->hdc = pgwid->hdc;
    ASSERT_WINCRIT(pwnd);
    gc->front->bitmap->pwnd = pwnd;

    // Make sure our GDI object cache is empty
    // It should always be empty at MakeCurrent time since
    // the objects in the cache are HDC-specific and so
    // they cannot be cached between MakeCurrents since the
    // HDC could change
    //
    // This should be done before HandlePaletteChanges since the
    // cache is used there
    ASSERTOPENGL(gengc->crFill == COLORREF_UNUSED &&
                 gengc->hbrFill == NULL &&
                 gengc->hdcFill == NULL,
                 "Fill cache inconsistent at MakeCurrent\n");
    ASSERTOPENGL(gengc->cStroke.r < 0.0f &&
                 gengc->hpenStroke == NULL &&
                 gengc->hdcStroke == NULL &&
                 gengc->fStrokeInvalid,
                 "Stroke cache inconsistent at MakeCurrent\n");

    // Get current xlation
    gengc->PaletteTimestamp = INITIAL_TIMESTAMP;
    HandlePaletteChanges(gengc, pwnd);

    // Force attention code to check if resize is needed
    gengc->WndUniq = -1;
    gengc->WndSizeUniq = -1;

    // Check for allocation failures during MakeCurrent
    if (gengc->errorcode)
    {
        WARNING1("glsrvMakeCurrent: errorcode 0x%lx\n", gengc->errorcode);
        goto ERROR_EXIT;
    }

    /*
    ** Default value for rasterPos needs to be yInverted.  The
    ** defaults are filled in during SoftResetContext
    ** we do the adjusting here.
    */

    if (gc->constants.yInverted) {
        gc->state.current.rasterPos.window.y = height +
        gc->constants.fviewportYAdjust - gc->constants.viewportEpsilon;
    }

    /*
    ** Scale all state that depends upon the color scales.
    */
    __glContextSetColorScales(gc);

    LEAVE_WINCRIT_GC(pwnd, gengc);
    
    return TRUE;

ERROR_EXIT:
    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));
    
    // Set paTeb to NULL for debugging.
    gc->paTeb = NULL;
    
    GLTEB_SET_SRVCONTEXT(0);

    // Remove window pointers.
    if (gengc->pwndLocked != NULL)
    {
        LEAVE_WINCRIT_GC(pwnd, gengc);
    }

    if (bFreePwnd)
    {
        if (bUninitSem)
        {
            DeleteCriticalSection(&pwnd->sem);
        }
        FREE(pwnd);
    }
    
    gengc->pwndMakeCur = NULL;
    
    return FALSE;
}

/******************************Public*Routine******************************\
* AddSwapHintRectWIN()
*
* 17-Feb-1995 mikeke    Created
\**************************************************************************/

void APIPRIVATE __glim_AddSwapHintRectWIN(
    GLint xs,
    GLint ys,
    GLint xe,
    GLint ye)
{
    __GLGENbuffers *buffers;

    __GL_SETUP();

    buffers = ((__GLGENcontext *)gc)->pwndLocked->buffers;

    if (xs < 0)                          xs = 0;
    if (xe > buffers->backBuffer.width)  xe = buffers->backBuffer.width;
    if (ys < 0)                          ys = 0;
    if (ye > buffers->backBuffer.height) ye = buffers->backBuffer.height;

    if (xs < xe && ys < ye) {
        if (gc->constants.yInverted) {
            RECTLISTAddRect(&buffers->rl,
                xs, buffers->backBuffer.height - ye,
                xe, buffers->backBuffer.height - ys);
        } else {
            RECTLISTAddRect(&buffers->rl, xs, ys, xe, ye);
        }
    }
}

/******************************Public*Routine******************************\
* wglFixupPixelFormat
*
* Fixes up certain MCD pixel format cases
*
* History:
*  21-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FASTCALL wglFixupPixelFormat(__GLGENcontext *gengc,
                                  PIXELFORMATDESCRIPTOR *ppfd)
{
// Some MCD pixelformats specify a 233BGR (i.e., 2-bits blue in least
// significant bits, etc.) bit ordering.  Unfortunately, this is the
// slow path for simulations.  For those formats, we force the ordering
// to RGB internally and reorder the pajTranslateVector to convert it
// back to BGR before writing to the surface.

    if (((ppfd->dwFlags & (PFD_NEED_SYSTEM_PALETTE | PFD_GENERIC_ACCELERATED))
         == (PFD_NEED_SYSTEM_PALETTE | PFD_GENERIC_ACCELERATED)) &&
        (ppfd->cRedBits   == 3) && (ppfd->cRedShift   == 5) &&
        (ppfd->cGreenBits == 3) && (ppfd->cGreenShift == 2) &&
        (ppfd->cBlueBits  == 2) && (ppfd->cBlueShift  == 0))
    {
        ppfd->cRedShift   = 0;
        ppfd->cGreenShift = 3;
        ppfd->cBlueShift  = 6;

        gengc->flags |= GENGC_MCD_BGR_INTO_RGB;
    }
    else
    {
        gengc->flags &= ~GENGC_MCD_BGR_INTO_RGB;
    }
}

/******************************Public*Routine******************************\
* glsrvCreateContext
*
* Create a generic context.
*
* Returns:
*   NULL for failure.
*
\**************************************************************************/

// hdc is the dc used to create the context,  hrc is how the server
// identifies the GL context,  the GLcontext pointer that is return is how
// the generic code identifies the context.  The server will pass that pointer
// in all calls.

PVOID APIENTRY glsrvCreateContext(GLWINDOWID *pgwid, GLSURF *pgsurf)
{
    __GLGENcontext *gengc;
    __GLcontext *gc;

    RANDOMDISABLE;

    DBGENTRY("__glsrvCreateContext\n");

    // Initialize the temporary memory allocation table
    if (!InitTempAlloc())
    {
        return NULL;
    }

    gengc = ALLOCZ(sizeof(*gengc));
    if (gengc == NULL)
    {
        WARNING("bad alloc\n");
        return NULL;
    }

    gengc->hrc = NULL;
    gc = (__GLcontext *)gengc;

    // Initialize cached objects to nothing
    gengc->crFill = COLORREF_UNUSED;
    gengc->hbrFill = NULL;
    gengc->hdcFill = NULL;
    gengc->cStroke.r = -1.0f;
    gengc->fStrokeInvalid = TRUE;
    gengc->hpenStroke = NULL;
    gengc->hdcStroke = NULL;

    gc->gcSig = 0;

    /*
     *  Add a bunch of constants to the context
     */

    gc->constants.maxViewportWidth        = __GL_MAX_WINDOW_WIDTH;
    gc->constants.maxViewportHeight       = __GL_MAX_WINDOW_HEIGHT;

    gc->constants.viewportXAdjust         = __GL_VERTEX_X_BIAS+
        __GL_VERTEX_X_FIX;
    gc->constants.viewportYAdjust         = __GL_VERTEX_Y_BIAS+
        __GL_VERTEX_Y_FIX;

    gc->constants.subpixelBits            = __GL_WGL_SUBPIXEL_BITS;

    gc->constants.numberOfLights          = __GL_WGL_NUMBER_OF_LIGHTS;
    gc->constants.numberOfClipPlanes      = __GL_WGL_NUMBER_OF_CLIP_PLANES;
    gc->constants.numberOfTextures        = __GL_WGL_NUMBER_OF_TEXTURES;
    gc->constants.numberOfTextureEnvs     = __GL_WGL_NUMBER_OF_TEXTURE_ENVS;
    gc->constants.maxTextureSize          = __GL_WGL_MAX_MIPMAP_LEVEL;/*XXX*/
    gc->constants.maxMipMapLevel          = __GL_WGL_MAX_MIPMAP_LEVEL;
    gc->constants.maxListNesting          = __GL_WGL_MAX_LIST_NESTING;
    gc->constants.maxEvalOrder            = __GL_WGL_MAX_EVAL_ORDER;
    gc->constants.maxPixelMapTable        = __GL_WGL_MAX_PIXEL_MAP_TABLE;
    gc->constants.maxAttribStackDepth     = __GL_WGL_MAX_ATTRIB_STACK_DEPTH;
    gc->constants.maxClientAttribStackDepth = __GL_WGL_MAX_CLIENT_ATTRIB_STACK_DEPTH;
    gc->constants.maxNameStackDepth       = __GL_WGL_MAX_NAME_STACK_DEPTH;

    gc->constants.pointSizeMinimum        =
                                (__GLfloat)__GL_WGL_POINT_SIZE_MINIMUM;
    gc->constants.pointSizeMaximum        =
                                (__GLfloat)__GL_WGL_POINT_SIZE_MAXIMUM;
    gc->constants.pointSizeGranularity    =
                                (__GLfloat)__GL_WGL_POINT_SIZE_GRANULARITY;
    gc->constants.lineWidthMinimum        =
                                (__GLfloat)__GL_WGL_LINE_WIDTH_MINIMUM;
    gc->constants.lineWidthMaximum        =
                                (__GLfloat)__GL_WGL_LINE_WIDTH_MAXIMUM;
    gc->constants.lineWidthGranularity    =
                                (__GLfloat)__GL_WGL_LINE_WIDTH_GRANULARITY;

#ifndef NT
    gc->dlist.optimizer = __glDlistOptimizer;
    gc->dlist.checkOp = __glNopGCListOp;
    gc->dlist.listExec = __gl_GenericDlOps;
    gc->dlist.baseListExec = __glListExecTable;
#endif
    gc->dlist.initState = __glNopGC;

    __glEarlyInitContext( gc );

    if (gengc->errorcode)
    {
        WARNING1("Context error is %d\n", gengc->errorcode);
        glsrvDeleteContext(gc);
        return NULL;
    }

    RANDOMREENABLE;

    // Many routines depend on a current surface so set it temporarily
    gengc->gwidCurrent = *pgwid;
    gengc->dwCurrentFlags = pgsurf->dwFlags;

    // Get copy of current pixelformat
    if (pgsurf->iLayer == 0 &&
        (pgsurf->pfd.dwFlags &
         (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED)) ==
        (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED))
    {
        wglFixupPixelFormat(gengc, &pgsurf->pfd);
    }
    gengc->gsurf = *pgsurf;

#ifdef _MCD_
    // Is the pixelformat compatible with the generic code, or is it some
    // weird h/w (MCD) format generic cannot handle?
    if (GenMcdGenericCompatibleFormat(gengc))
        gengc->flags |= GENGC_GENERIC_COMPATIBLE_FORMAT;
#endif

    // Extract information from pixel format to set up modes
    GetContextModes(gengc);

    ASSERTOPENGL(GLSURF_IS_MEMDC(gengc->dwCurrentFlags) ?
        !gc->modes.doubleBufferMode : 1, "Double buffered memdc!");

    // XXX! Reset buffer dimensions to force Bitmap resize call
    // We should eventually handle the Bitmap as we do ancilliary buffers
    gc->constants.width = 0;
    gc->constants.height = 0;

    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_ALL);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ALL);
#endif

    gc->constants.yInverted = GL_TRUE;
    gc->constants.ySign = -1;

    // Allocate GDI objects that we will need
    if (!CreateGDIObjects(gengc))
    {
        goto ERROR_EXIT;
    }

    // Allocate __GLGENbitmap front-buffer structure

    if (!(gc->frontBuffer.bitmap = GCALLOCZ(gc, sizeof(__GLGENbitmap))))
    {
        goto ERROR_EXIT;
    }

    // Create MCD rendering context, if MCD is available.

    if (gengc->gsurf.dwFlags & GLSURF_VIDEO_MEMORY)
    {
        GLGENwindow *pwnd;
        BOOL bMcdContext;

        // Validate layer index
        if (pgsurf->iLayer &&
            !ValidateLayerIndex(pgsurf->iLayer, &pgsurf->pfd))
        {
            WARNING("glsrvCreateContext: bad iLayer\n");
            goto ERROR_EXIT;
        }

        pwnd = pwndGetFromID(pgwid);
        if (pwnd == NULL)
        {
            goto ERROR_EXIT;
        }

        // If this fails, _pMcdState is NULL and we fall back on
        // the software-only implementation.
        //
        // Unless we were trying to create a layer context.  Generic
        // does not support layers, so fail if we cannot create an
        // MCD context.

        bMcdContext = bInitMcdContext(gengc, pwnd);

        if (!(gengc->flags & GENGC_GENERIC_COMPATIBLE_FORMAT) && !bMcdContext)
        {
            goto ERROR_EXIT;
        }

        pwndRelease(pwnd);
    }

    /*
     *  Initialize front/back color buffer(s)
     */

    wglInitializeColorBuffers(gengc);

    /*
     *  Initialize any other ancillary buffers
     */

    // Init accum buffer.
    if (gc->modes.accumBits)
    {
        switch (gc->modes.accumBits)
        {
        case 16:
        // We will now internally use a 32-bit accum for accumBits=16
        case 32:
            __glInitAccum32(gc, &gc->accumBuffer);
            break;
        case 64:
        default:
            __glInitAccum64(gc, &gc->accumBuffer);
            break;
        }
    }

    // Initialize depth buffer.
    wglInitializeDepthBuffer(gengc);

    // Init stencil buffer.
    if (gc->modes.stencilBits)
    {
        __glInitStencil8( gc, &gc->stencilBuffer);
    }

    // Look at REX code for procs to make CPU specific
    gc->procs.bitmap                      = __glDrawBitmap;
    gc->procs.clipPolygon                 = __glClipPolygon;
    gc->procs.validate                    = __glGenericValidate;

    gc->procs.pickAllProcs                = __glGenericPickAllProcs;
    gc->procs.pickBlendProcs              = __glGenericPickBlendProcs;
    gc->procs.pickFogProcs                = __glGenericPickFogProcs;
    gc->procs.pickParameterClipProcs      = __glGenericPickParameterClipProcs;
    gc->procs.pickStoreProcs              = __glGenPickStoreProcs;
    gc->procs.pickTextureProcs            = __glGenericPickTextureProcs;

    gc->procs.copyImage                   = __glGenericPickCopyImage;

    gc->procs.pixel.spanReadCI            = __glSpanReadCI;
    gc->procs.pixel.spanReadCI2           = __glSpanReadCI2;
    gc->procs.pixel.spanReadRGBA          = __glSpanReadRGBA;
    gc->procs.pixel.spanReadRGBA2         = __glSpanReadRGBA2;
    gc->procs.pixel.spanReadDepth         = __glSpanReadDepth;
    gc->procs.pixel.spanReadDepth2        = __glSpanReadDepth2;
    gc->procs.pixel.spanReadStencil       = __glSpanReadStencil;
    gc->procs.pixel.spanReadStencil2      = __glSpanReadStencil2;
    gc->procs.pixel.spanRenderCI          = __glSpanRenderCI;
    gc->procs.pixel.spanRenderCI2         = __glSpanRenderCI2;
    gc->procs.pixel.spanRenderRGBA        = __glSpanRenderRGBA;
    gc->procs.pixel.spanRenderRGBA2       = __glSpanRenderRGBA2;
    gc->procs.pixel.spanRenderDepth       = __glSpanRenderDepth;
    gc->procs.pixel.spanRenderDepth2      = __glSpanRenderDepth2;
    gc->procs.pixel.spanRenderStencil     = __glSpanRenderStencil;
    gc->procs.pixel.spanRenderStencil2    = __glSpanRenderStencil2;

    gc->procs.applyViewport               = ApplyViewport;

    gc->procs.pickBufferProcs             = __glGenericPickBufferProcs;
    gc->procs.pickColorMaterialProcs      = __glGenericPickColorMaterialProcs;
    gc->procs.pickPixelProcs              = __glGenericPickPixelProcs;

    gc->procs.pickClipProcs               = __glGenericPickClipProcs;
    gc->procs.pickLineProcs               = __fastGenPickLineProcs;
    gc->procs.pickSpanProcs               = __fastGenPickSpanProcs;
    gc->procs.pickTriangleProcs           = __fastGenPickTriangleProcs;
    gc->procs.pickRenderBitmapProcs       = __glGenericPickRenderBitmapProcs;
    gc->procs.pickPointProcs              = __glGenericPickPointProcs;
    gc->procs.pickVertexProcs             = __glGenericPickVertexProcs;
    gc->procs.pickDepthProcs              = __glGenericPickDepthProcs;
    gc->procs.convertPolygonStipple       = __glConvertStipple;

    /* Now reset the context to its default state */

    RANDOMDISABLE;

    __glSoftResetContext(gc);
    // Check for allocation failures during SoftResetContext
    if (gengc->errorcode)
    {
        goto ERROR_EXIT;
    }

    /* Create acceleration-specific context information */

    if (!__glGenCreateAccelContext(gc))
    {
        goto ERROR_EXIT;
    }
    
    /*
    ** Now that we have a context, we can initialize
    ** all the proc pointers.
    */
    (*gc->procs.validate)(gc);

    /*
    ** NOTE: now that context is initialized reset to use the global
    ** table.
    */

    RANDOMREENABLE;

    // We won't be fully initialized until the first MakeCurrent
    // so set the signature to uninitialized
    gc->gcSig = 0;

    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));
    gengc->dwCurrentFlags = 0;

    /*
     *  End stuff that may belong in the hardware context
     */

    return (PVOID)gc;

 ERROR_EXIT:
    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));
    gengc->dwCurrentFlags = 0;
    glsrvDeleteContext(gc);
    return NULL;
}

/******************************Public*Routine******************************\
* UpdateSharedBuffer
*
* Make the context buffer state consistent with the shared buffer state.
* This is called separately for each of the shared buffers.
*
\**************************************************************************/

void UpdateSharedBuffer(__GLbuffer *to, __GLbuffer *from)
{
    to->width       = from->width;
    to->height      = from->height;
    to->base        = from->base;
    to->outerWidth  = from->outerWidth;
}

/******************************Public*Routine******************************\
* ResizeUnownedDepthBuffer
*
* Resizes a general-purpose hardware depth buffer.  Just updates structure.
*
* Returns:
*   TRUE always.
*
\**************************************************************************/

GLboolean ResizeUnownedDepthBuffer(__GLGENbuffers *buffers,
                                   __GLbuffer *fb, GLint w, GLint h)
{
    fb->width = w;
    fb->height = h;
    return TRUE;
}


/******************************Public*Routine******************************\
* ResizeHardwareBackBuffer
*
* Resizes a general-purpose hardware color buffer.  Just updates structure.
*
* Returns:
*   TRUE always.
*
\**************************************************************************/

GLboolean ResizeHardwareBackBuffer(__GLGENbuffers *buffers,
                                   __GLcolorBuffer *cfb, GLint w, GLint h)
{
    __GLGENbitmap *genBm = cfb->bitmap;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;

    // Fake up some of the __GLGENbitmap information.  The window is required
    // for clipping of the hardware back buffer.  The hdc is required to
    // retrieve drawing data from GDI.

    ASSERT_WINCRIT(gengc->pwndLocked);
    genBm->pwnd = gengc->pwndLocked;
    genBm->hdc = gengc->gwidCurrent.hdc;

    buffers->backBuffer.width = w;
    buffers->backBuffer.height = h;
    UpdateSharedBuffer(&cfb->buf, &buffers->backBuffer);
    return TRUE;
}

/******************************Public*Routine******************************\
* ResizeAncillaryBuffer
*
* Resizes the indicated shared buffer via a realloc (to preserve as much of
* the existing data as possible).
*
* This is currently used for each of ancillary shared buffers except for
* the back buffer.
*
* Returns:
*   TRUE if successful, FALSE if error.
*
\**************************************************************************/

GLboolean ResizeAncillaryBuffer(__GLGENbuffers *buffers, __GLbuffer *fb,
                                GLint w, GLint h)
{
    size_t newSize = (size_t) (w * h * fb->elementSize);
    __GLbuffer oldbuf, *ofb;
    GLboolean result;
    GLint i, imax, rowsize;
    void *to, *from;

    ofb = &oldbuf;
    oldbuf = *fb;

    if (newSize > 0)
    {
        fb->base = ALLOC(newSize);
    }
    else
    {
        // Buffer has no size.  If we tried to allocate zero the debug alloc
        // would complain, so skip directly to the underlying allocator
        fb->base = HeapAlloc(GetProcessHeap(), 0, 0);
    }
    ASSERTOPENGL((ULONG_PTR)fb->base % 4 == 0, "base not aligned");
    fb->size = newSize;
    fb->width = w;
    fb->height = h;
    fb->outerWidth = w; // element size
    if (fb->base) {
        result = GL_TRUE;
        if (ofb->base) {
            if (ofb->width > fb->width)
                rowsize = fb->width * fb->elementSize;
            else
                rowsize = ofb->width * fb->elementSize;

            if (ofb->height > fb->height)
                imax = fb->height;
            else
                imax = ofb->height;

            from = ofb->base;
            to = fb->base;
            for (i = 0; i < imax; i++) {
                __GL_MEMCOPY(to, from, rowsize);
                (ULONG_PTR)from += (ofb->width * ofb->elementSize);
                (ULONG_PTR)to += (fb->width * fb->elementSize);
            }
        }
    } else {
        result = GL_FALSE;
    }
    if (ofb->base)
    {
        FREE(ofb->base);
    }
    return result;
}

/******************************Private*Routine******************************\
* ResizeBitmapBuffer
*
* Used to resize the backbuffer that is implemented as a bitmap.  Cannot
* use same code as ResizeAncillaryBuffer() because each scanline must be
* dword aligned.  We also have to create engine objects for the bitmap.
*
* This code handles the case of a bitmap that has never been initialized.
*
* History:
*  18-Nov-1993 -by- Gilman Wong [gilmanw]
*  Wrote it.
\**************************************************************************/

void
ResizeBitmapBuffer(__GLGENbuffers *buffers, __GLcolorBuffer *cfb,
                   GLint w, GLint h)
{
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENbitmap *genBm;
    UINT    cBytes;         // size of the bitmap in bytes
    LONG    cBytesPerScan;  // size of a scanline (DWORD aligned)
    SIZEL   size;           // dimensions of the bitmap
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    GLint cBitsPerScan;
#ifndef _CLIENTSIDE_
    void *newbits;
#endif

    DBGENTRY("Entering ResizeBitmapBuffer\n");

    genBm = cfb->bitmap;

    ASSERTOPENGL(
        &gc->backBuffer == cfb,
        "ResizeBitmapBuffer(): not back buffer!\n"
        );

    ASSERTOPENGL(
        genBm == &buffers->backBitmap,
        "ResizeBitmapBuffer(): bad __GLGENbitmap * in cfb\n"
        );

    // Compute the size of the bitmap.
    // The engine bitmap must have scanlines that are DWORD aligned.

    cBitsPerScan = BITS_ALIGNDWORD(w * pfmt->cColorBits);
    cBytesPerScan = cBitsPerScan / 8;
    cBytes = h * cBytesPerScan;

    // Setup size structure with dimensions of the bitmap.

    size.cx = cBitsPerScan / pfmt->cColorBits;
    size.cy = h;

#ifndef _CLIENTSIDE_
    // Malloc new buffer
    if ( (!cBytes) ||
         (NULL == (newbits = GCALLOC(gc, cBytes))) )
    {
        gengc->errorcode = GLGEN_OUT_OF_MEMORY;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

    // If old buffer existed:
    if ( genBm->pvBits )
    {
        GLint i, imax, rowsize;
        void *to, *from;

        // Transfer old contents to new buffer
        rowsize = min(-cfb->buf.outerWidth, cBytesPerScan);
        imax    = min(cfb->buf.height, h);

        from = genBm->pvBits;
        to = newbits;

        for (i = 0; i < imax; i++)
        {
            __GL_MEMCOPY(to, from, rowsize);
            (GLint) from -= cfb->buf.outerWidth;
            (GLint) to += cBytesPerScan;
        }

        // Free old bitmap and delete old surface
        EngDeleteSurface((HSURF) genBm->hbm);
        GCFREE(gc, genBm->pvBits);
    }
    genBm->pvBits = newbits;

    // Create new surface
    if ( (genBm->hbm = EngCreateBitmap(size,
                                   cBytesPerScan,
                                   gengc->iFormatDC,
                                   0,
                                   genBm->pvBits))
         == (HBITMAP) 0 )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        GCFREE(gc, genBm->pvBits);
        genBm->pvBits = (PVOID) NULL;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

#else
    // Zero sized bitmap.  The error case will set the dimensions to
    // zero, thereby preventing drawing operations.

    if ( !cBytes )
        goto ERROR_EXIT_ResizeBitmapBuffer;

    // Delete old back buffer.

    if ( genBm->hbm )
    {
        if (!DeleteDC(genBm->hdc))
            WARNING("ResizeBitmapBuffer: DeleteDC failed\n");
        genBm->hdc = (HDC) NULL;
        if (!DeleteObject(genBm->hbm))
            WARNING("ResizeBitmapBuffer: DeleteBitmap failed");
        genBm->hbm = (HBITMAP) NULL;
        genBm->pvBits = (PVOID) NULL;   // DIBsect deletion freed pvBits
    }

    if ( (genBm->hdc = CreateCompatibleDC(gengc->gwidCurrent.hdc)) == (HDC) 0 )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        genBm->pvBits = (PVOID) NULL;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

    // Create new surface
    if ( (genBm->hbm = wglCreateBitmap(gengc, size, &genBm->pvBits))
         == (HBITMAP) 0 )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        genBm->pvBits = (PVOID) NULL;   // DIBsect deletion freed pvBits
        DeleteDC(genBm->hdc);
        genBm->hdc = (HDC) NULL;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

    if ( !SelectObject(genBm->hdc, genBm->hbm) )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        DeleteDC(genBm->hdc);
        genBm->hdc = (HDC) NULL;
        DeleteObject(genBm->hbm);
        genBm->hbm = (HBITMAP) NULL;
        genBm->pvBits = (PVOID) NULL;   // DIBsect deletion freed pvBits
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }
#endif

    // Update buffer data structure
    // Setup the buffer to point to the DIB.  A DIB is "upside down"
    // from our perspective, so we will set buf.base to point to the
    // last scan of the buffer and set buf.outerWidth to be negative
    // (causing us to move "up" through the DIB with increasing y).

    buffers->backBuffer.outerWidth = -(cBytesPerScan);
    buffers->backBuffer.base =
            (PVOID) (((BYTE *)genBm->pvBits) + (cBytesPerScan * (h - 1)));


    buffers->backBuffer.xOrigin = 0;
    buffers->backBuffer.yOrigin = 0;
    buffers->backBuffer.width = w;
    buffers->backBuffer.height = h;
    buffers->backBuffer.size = cBytes;

    UpdateSharedBuffer(&cfb->buf, &buffers->backBuffer);

    // Update the dummy window for the back buffer
    ASSERTOPENGL(genBm->wnd.clipComplexity == DC_TRIVIAL,
                 "Back buffer complexity non-trivial\n");
    genBm->wnd.rclBounds.right  = w;
    genBm->wnd.rclBounds.bottom = h;
    genBm->wnd.rclClient = genBm->wnd.rclBounds;

    return;

ERROR_EXIT_ResizeBitmapBuffer:

// If we get to here, memory allocation or bitmap creation failed.

    #if DBG
    switch (gengc->errorcode)
    {
        case 0:
            break;

        case GLGEN_GRE_FAILURE:
            WARNING("ResizeBitmapBuffer(): object creation failed\n");
            break;

        case GLGEN_OUT_OF_MEMORY:
            if ( w && h )
                WARNING("ResizeBitmapBuffer(): mem alloc failed\n");
            break;

        default:
            WARNING1("ResizeBitmapBuffer(): errorcode = 0x%lx\n", gengc->errorcode);
            break;
    }
    #endif

// If we've blown away the bitmap, we need to set the back buffer info
// to a consistent state.

    if (!genBm->pvBits)
    {
        buffers->backBuffer.width  = 0;
        buffers->backBuffer.height = 0;
        buffers->backBuffer.base   = (PVOID) NULL;
    }

    cfb->buf.width      = 0;    // error state: empty buffer
    cfb->buf.height     = 0;
    cfb->buf.outerWidth = 0;

}

/* Lazy allocation of ancillary buffers */
void FASTCALL LazyAllocateDepth(__GLcontext *gc)
{
    GLint w = gc->constants.width;
    GLint h = gc->constants.height;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    __GLGENbuffers *buffers;
    GLint depthIndex = gc->state.depth.testFunc;

    ASSERTOPENGL(gc->modes.depthBits, "LazyAllocateDepth: zero depthBits\n");

    buffers = gengc->pwndLocked->buffers;
    buffers->createdDepthBuffer = GL_TRUE;

    // If we're using the DDI, we've already allocated depth buffers
    // on the device, so at this point we may simply assume that
    // our depth buffer is available.

#ifdef _MCD_
    // If we're using MCD, we allocated the depth buffer when we created
    // the MCD context.

    if ((gengc->pMcdState) && (gengc->pMcdState->pDepthSpan))
    {
        gc->modes.haveDepthBuffer = GL_TRUE;
        return;
    }
#endif

    // Depth buffer should never be touched because
    // no output should be generated
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        gc->modes.haveDepthBuffer = GL_TRUE;
        return;
    }

    if (buffers->depthBuffer.base) {
        /* buffer already allocated by another RC */
        UpdateSharedBuffer(&gc->depthBuffer.buf, &buffers->depthBuffer);
    } else {

        DBGLEVEL(LEVEL_ALLOC, "Depth buffer must be allocated\n");
        (*buffers->resize)(buffers, &buffers->depthBuffer, w, h);
        UpdateSharedBuffer(&gc->depthBuffer.buf, &buffers->depthBuffer);
    }

    if (gc->depthBuffer.buf.base) {
        gc->modes.haveDepthBuffer = GL_TRUE;
    } else {
        gc->modes.haveDepthBuffer = GL_FALSE;
        __glSetError(GL_OUT_OF_MEMORY);
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);

    // Note similar code in so_pick.c
    // Don't need to handle (depthBits == 0) case because LazyAllocateDepth
    // is not called unless depthBits is non-zero.
    depthIndex -= GL_NEVER;
    if( gc->state.depth.writeEnable == GL_FALSE ) {
        depthIndex += 8;
    }
    if( gc->depthBuffer.buf.elementSize == 2 )
        depthIndex += 16;
    (*gc->depthBuffer.pick)(gc, &gc->depthBuffer, depthIndex);
}

void FASTCALL LazyAllocateStencil(__GLcontext *gc)
{
    GLint w = gc->constants.width;
    GLint h = gc->constants.height;
    __GLGENbuffers *buffers;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    ASSERTOPENGL(gc->modes.stencilBits, "LazyAllocateStencil: zero stencilBits\n");

    buffers = gengc->pwndLocked->buffers;
    buffers->createdStencilBuffer = GL_TRUE;

    // Depth buffer should never be touched because
    // no output should be generated
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        gc->modes.haveStencilBuffer = GL_TRUE;
        return;
    }

    if (buffers->stencilBuffer.base) {
        /* buffer already allocated by another RC */
        UpdateSharedBuffer(&gc->stencilBuffer.buf, &buffers->stencilBuffer);
    } else {

        DBGLEVEL(LEVEL_ALLOC, "stencil buffer must be allocated\n");
        (*buffers->resize)(buffers, &buffers->stencilBuffer, w, h);
        UpdateSharedBuffer(&gc->stencilBuffer.buf, &buffers->stencilBuffer);
    }

    if (gc->stencilBuffer.buf.base) {
        gc->modes.haveStencilBuffer = GL_TRUE;
    } else {
        gc->modes.haveStencilBuffer = GL_FALSE;
        __glSetError(GL_OUT_OF_MEMORY);
    }
    __GL_DELAY_VALIDATE(gc);
    gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC | __GL_VALIDATE_STENCIL_OP);
    (*gc->stencilBuffer.pick)(gc, &gc->stencilBuffer);
}


void FASTCALL LazyAllocateAccum(__GLcontext *gc)
{
    GLint w = gc->constants.width;
    GLint h = gc->constants.height;
    __GLGENbuffers *buffers;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    ASSERTOPENGL(gc->modes.accumBits, "LazyAllocateAccum: zero accumBits\n");

    buffers = gengc->pwndLocked->buffers;
    buffers->createdAccumBuffer = GL_TRUE;

    // Depth buffer should never be touched because
    // no output should be generated
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        gc->modes.haveAccumBuffer = GL_TRUE;
        return;
    }

    if (buffers->accumBuffer.base) {
        /* buffer already allocated by another RC */
        UpdateSharedBuffer(&gc->accumBuffer.buf, &buffers->accumBuffer);
    } else {

        DBGLEVEL(LEVEL_ALLOC, "Accum buffer must be allocated\n");
        (*buffers->resize)(buffers, &buffers->accumBuffer, w, h);
        UpdateSharedBuffer(&gc->accumBuffer.buf, &buffers->accumBuffer);
    }

    if (gc->accumBuffer.buf.base) {
        gc->modes.haveAccumBuffer = GL_TRUE;
    } else {
        gc->modes.haveAccumBuffer = GL_FALSE;
        __glSetError(GL_OUT_OF_MEMORY);
    }
    __GL_DELAY_VALIDATE(gc);
    (*gc->accumBuffer.pick)(gc, &gc->accumBuffer);
}

/******************************Public*Routine******************************\
* glGenInitCommon
*
* Called from __glGenInitRGB and __glGenInitCI to handle the shared
* initialization chores.
*
\**************************************************************************/

void FASTCALL glGenInitCommon(__GLGENcontext *gengc, __GLcolorBuffer *cfb, GLenum type)
{
    __GLbuffer *bp;

    bp = &cfb->buf;

// If front buffer, we need to setup the buffer if we think its DIB format.

    if (type == GL_FRONT)
    {
#ifdef _MCD_
        if (gengc->_pMcdState)
        {
        // Assume that MCD surface is not accessible.  Accessibility
        // must be determined on a per-batch basis by calling
        // GenMcdUpdateBufferInfo.

            bp->flags &= ~(DIB_FORMAT | MEMORY_DC | NO_CLIP);
        }
#endif
        {
            if (gengc->dwCurrentFlags & GLSURF_DIRECT_ACCESS)
            {
                // These fields will be updated at attention time
                bp->base = NULL;
                bp->outerWidth = 0;
                cfb->buf.flags = DIB_FORMAT;
            }

            if (GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
            {
                bp->flags = bp->flags | (MEMORY_DC | NO_CLIP);
            }
            else if (gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW)
            {
                LPDIRECTDRAWCLIPPER pddc;
                HRESULT hr;
                
                hr = gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
                    GetClipper(gengc->gsurf.dd.gddsFront.pdds, &pddc);
                if (hr == DDERR_NOCLIPPERATTACHED)
                {
                    bp->flags = bp->flags | NO_CLIP;
                }
            }
        }
    }

// If back buffer, we assume its a DIB, or a hardware backbuffer.
// In the case of a DIB, the bitmap memory will be allocated via
// ResizeBitmapBuffer().

    else
    {
#ifdef _MCD_
        if (gengc->_pMcdState)
        {
        // Assume that MCD surface is not accessible.  Accessibility
        // must be determined on a per-batch basis by calling
        // GenMcdUpdateBufferInfo.

            cfb->resize = ResizeHardwareBackBuffer;
            bp->flags &= ~(DIB_FORMAT | MEMORY_DC | NO_CLIP);
        }
        else
#endif
        {
            cfb->resize = ResizeBitmapBuffer;
            bp->flags = DIB_FORMAT | MEMORY_DC | NO_CLIP;
        }
    }
}


/******************************Public*Routine******************************\
* glsrvCleanupWindow
*
* Called from wglCleanupWindow to remove the pwnd reference from the
* context.
*
* History:
*  05-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY glsrvCleanupWindow(__GLcontext *gc, GLGENwindow *pwnd)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;

// The window in gengc should be consistent with the one in the rc object.
// wglCleanupWindow should have already checked to see if the pwnd in the
// rc is one we need to remove, so we can just assert here.

    ASSERTOPENGL(gengc->pwndMakeCur == pwnd,
                 "glsrvCleanupWindow(): bad pwnd\n");

    gengc->pwndLocked = NULL;
    gengc->pwndMakeCur = NULL;
}


/*
** Fetch the data for a query in its internal type, then convert it to the
** type that the user asked for.
**
** This only handles the NT generic driver specific values (so far just the
** GL_ACCUM_*_BITS values).  All others fall back to the soft code function,
** __glDoGet().
*/

// These types are stolen from ..\soft\so_get.c.  To minimize changes to
// the soft code, we will pull them into here rather than moving them to
// a header file and changing so_get.c to use the header file.

#define __GL_FLOAT      0       /* __GLfloat */
#define __GL_FLOAT32    1       /* api 32 bit float */
#define __GL_FLOAT64    2       /* api 64 bit float */
#define __GL_INT32      3       /* api 32 bit int */
#define __GL_BOOLEAN    4       /* api 8 bit boolean */
#define __GL_COLOR      5       /* unscaled color in __GLfloat */
#define __GL_SCOLOR     6       /* scaled color in __GLfloat */

extern void __glDoGet(GLenum, void *, GLint, const char *);
extern void __glConvertResult(__GLcontext *, GLint, const void *, GLint,
                              void *, GLint);

void FASTCALL __glGenDoGet(GLenum sq, void *result, GLint type, const char *procName)
{
    GLint iVal;
    __GLGENcontext *gengc;
    __GL_SETUP_NOT_IN_BEGIN();

    gengc = (__GLGENcontext *) gc;

    switch (sq) {
      case GL_ACCUM_RED_BITS:
        iVal = gengc->gsurf.pfd.cAccumRedBits;
        break;
      case GL_ACCUM_GREEN_BITS:
        iVal = gengc->gsurf.pfd.cAccumGreenBits;
        break;
      case GL_ACCUM_BLUE_BITS:
        iVal = gengc->gsurf.pfd.cAccumBlueBits;
        break;
      case GL_ACCUM_ALPHA_BITS:
        iVal = gengc->gsurf.pfd.cAccumAlphaBits;
        break;
      default:
        __glDoGet(sq, result, type, procName);
        return;
    }

    __glConvertResult(gc, __GL_INT32, &iVal, type, result, 1);
}

/******************************Public*Routine******************************\
*
* glsrvCopyContext
*
* Copies state from one context to another
*
* History:
*  Mon Jun 05 16:53:42 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY glsrvCopyContext(__GLcontext *gcSource, __GLcontext *gcDest,
                               GLuint mask)
{
    return (BOOL)__glCopyContext(gcDest, gcSource, mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genpick.c ===
/*
** Copyright 1991,1992,1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#ifdef __GL_USEASMCODE
static void (*SDepthTestPixel[16])(void) = {
    NULL,
    __glDTS_LESS,
    __glDTS_EQUAL,
    __glDTS_LEQUAL,
    __glDTS_GREATER,
    __glDTS_NOTEQUAL,
    __glDTS_GEQUAL,
    __glDTS_ALWAYS,
    NULL,
    __glDTS_LESS_M,
    __glDTS_EQUAL_M,
    __glDTS_LEQUAL_M,
    __glDTS_GREATER_M,
    __glDTS_NOTEQUAL_M,
    __glDTS_GEQUAL_M,
    __glDTS_ALWAYS_M,
};
#endif

typedef void (FASTCALL *StoreProc)(__GLcolorBuffer *cfb, const __GLfragment *frag);

static StoreProc storeProcs[8] = {
    &__glDoStore,
    &__glDoStore_A,
    &__glDoStore_S,
    &__glDoStore_AS,
    &__glDoStore_D,
    &__glDoStore_AD,
    &__glDoStore_SD,
    &__glDoStore_ASD,
};

void FASTCALL __glGenPickStoreProcs(__GLcontext *gc)
{
    GLint ix = 0;
    GLuint enables = gc->state.enables.general;

    if ((enables & __GL_ALPHA_TEST_ENABLE) && gc->modes.rgbMode) {
	ix |= 1;
    }
    if (enables & __GL_STENCIL_TEST_ENABLE) {
	ix |= 2;
    }
    if (enables & __GL_DEPTH_TEST_ENABLE) {
	ix |= 4;
    }
    switch (gc->state.raster.drawBuffer) {
      case GL_NONE:
        gc->procs.store = storeProcs[ix];
	gc->procs.cfbStore = __glDoNullStore;
	break;
      case GL_FRONT_AND_BACK:
	if (gc->buffers.doubleStore) {
            gc->procs.store = storeProcs[ix];
	    gc->procs.cfbStore = __glDoDoubleStore;
	    break;
	}
	/*
	** Note that there is an intentional drop through here.  If double
	** store is not set, then storing to this buffer is no different
	** that storing to the front buffer.
	*/
      case GL_FRONT:
      case GL_BACK:
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
	/*
	** This code knows that gc->drawBuffer will point to the
	** current buffer as chosen by glDrawBuffer
	*/
	gc->procs.store = storeProcs[ix];
	gc->procs.cfbStore = gc->drawBuffer->store;
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genpxapi.c ===
#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

GLboolean __glGenCheckDrawPixelArgs(__GLcontext *gc,
        GLsizei width, GLsizei height, GLenum format, GLenum type)
{
    GLboolean index;

    if ((width < 0) || (height < 0)) {
        __glSetError(GL_INVALID_VALUE);
        return GL_FALSE;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
        if (!gc->modes.stencilBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveStencilBuffer) {
            LazyAllocateStencil(gc);
            if (!gc->stencilBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        index = GL_TRUE;
        break;
      case GL_COLOR_INDEX:
        index = GL_TRUE;
        break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
        if (gc->modes.colorIndexMode) {
            /* Can't convert RGB to color index */
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        index = GL_FALSE;
        break;
      case GL_DEPTH_COMPONENT:
        if (!gc->modes.depthBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveDepthBuffer) {
            LazyAllocateDepth(gc);
            if (!gc->depthBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        index = GL_FALSE;
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    switch (type) {
      case GL_BITMAP:
        if (!index) {
            __glSetError(GL_INVALID_ENUM);
            return GL_FALSE;
        }
        break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean __glGenCheckReadPixelArgs(__GLcontext *gc,
        GLsizei width, GLsizei height, GLenum format, GLenum type)
{
    if ((width < 0) || (height < 0)) {
        __glSetError(GL_INVALID_VALUE);
        return GL_FALSE;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
        if (!gc->modes.stencilBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveStencilBuffer) {
            LazyAllocateStencil(gc);
            if (!gc->stencilBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        break;
      case GL_COLOR_INDEX:
        if (gc->modes.rgbMode) {
            /* Can't convert RGB to color index */
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        break;
      case GL_DEPTH_COMPONENT:
        if (!gc->modes.depthBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveDepthBuffer) {
            LazyAllocateDepth(gc);
            if (!gc->depthBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    switch (type) {
      case GL_BITMAP:
        if (format != GL_STENCIL_INDEX && format != GL_COLOR_INDEX) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    return GL_TRUE;
}

#ifdef NT
void APIPRIVATE __glim_DrawPixels(GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid *pixels, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_DrawPixels(GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid *pixels)
#endif
{
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
        if (beginMode == __GL_NEED_VALIDATE) {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_DrawPixels(width, height, format,
                type, pixels, _IsDlist);
            return;
        } else {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if (!__glGenCheckDrawPixelArgs(gc, width, height, format, type)) return;
    if (!gc->state.current.validRasterPos) {
        return;
    }

    if (gc->renderMode == GL_FEEDBACK) {
        __glFeedbackDrawPixels(gc, &gc->state.current.rasterPos);
        return;
    }

    if (gc->renderMode != GL_RENDER)
        return;

#ifdef _MCD_
    // If MCD context, give driver first crack at call.  If it succeeds,
    // return.  Otherwise, continue on with the generic version.

    {
        __GLGENcontext *gengc = (__GLGENcontext *) gc;

        if (gengc->pMcdState) {
            if (GenMcdDrawPix(gengc, width, height, format, type,
                              (VOID *) pixels, _IsDlist))
                return;

        // If MCD kicked back, now is the time to grab the device lock if
        // needed.  If we can't, abandon the call.

            if (!glsrvLazyGrabSurfaces(gengc, RENDER_LOCK_FLAGS))
                return;

        // We may need to temporarily reset the viewport adjust values
        // before calling simulations.  If GenMcdResetViewportAdj returns
        // TRUE, the viewport is changed and we need restore later with
        // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }
#endif

#ifdef NT
    if (_IsDlist)
    {
        (*gc->procs.drawPixels)(gc, width, height, format, type, pixels, GL_TRUE);
    }
    else
    {
#endif
        (*gc->procs.drawPixels)(gc, width, height, format, type, pixels, GL_FALSE);
#ifdef NT
    }
#endif

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}

void APIPRIVATE __glim_ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                       GLenum format, GLenum type, GLvoid *buf)
{
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
        if (beginMode == __GL_NEED_VALIDATE) {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_ReadPixels(x,y,width,height,
                    format,type,buf);
            return;
        } else {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if (!__glGenCheckReadPixelArgs(gc, width, height, format, type))
        return;

#ifdef _MCD_
    // If MCD context, give driver first crack at call.  If it succeeds,
    // return.  Otherwise, continue on with the generic version.

    {
        __GLGENcontext *gengc = (__GLGENcontext *) gc;

        if (gengc->pMcdState) {
            if (GenMcdReadPix(gengc, x, y, width, height, format, type, buf))
                return;

        // If MCD kicked back, now is the time to grab the device lock if
        // needed.  If we can't, abandon the call.

            if (!glsrvLazyGrabSurfaces(gengc, 
				       COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS))
                return;

        // We may need to temporarily reset the viewport adjust values
        // before calling simulations.  If GenMcdResetViewportAdj returns
        // TRUE, the viewport is changed and we need restore later with
        // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }
#endif

    (*gc->procs.readPixels)(gc, x, y, width, height, format, type, buf);

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}

void APIPRIVATE __glim_CopyPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                       GLenum type)
{
    GLenum format;
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
        if (beginMode == __GL_NEED_VALIDATE) {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_CopyPixels(x,y,width,height,type);
            return;
        } else {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if ((width < 0) || (height < 0)) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    switch (type) {
      case GL_STENCIL:
        if (!gc->modes.stencilBits) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        if (!gc->modes.haveStencilBuffer) {
            LazyAllocateStencil(gc);
            if (!gc->stencilBuffer.buf.base) {
                return;
            }
        }
        format = GL_STENCIL_INDEX;
        break;
      case GL_COLOR:
        if (gc->modes.rgbMode) {
            format = GL_RGBA;
        } else {
            format = GL_COLOR_INDEX;
        }
        break;
      case GL_DEPTH:
        if (!gc->modes.depthBits) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        if (!gc->modes.haveDepthBuffer) {
            LazyAllocateDepth(gc);
            if (!gc->depthBuffer.buf.base) {
                return;
            }
        }
        format = GL_DEPTH_COMPONENT;
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    if (!gc->state.current.validRasterPos) {
        return;
    }

    if (gc->renderMode == GL_FEEDBACK) {
        __glFeedbackCopyPixels(gc, &gc->state.current.rasterPos);
        return;
    }

    if (gc->renderMode != GL_RENDER)
        return;

#ifdef _MCD_
    // If MCD context, give driver first crack at call.  If it succeeds,
    // return.  Otherwise, continue on with the generic version.

    {
        __GLGENcontext *gengc = (__GLGENcontext *) gc;

        if (gengc->pMcdState) {
            if (GenMcdCopyPix(gengc, x, y, width, height, type))
                return;

        // If MCD kicked back, now is the time to grab the device lock if
        // needed.  If we can't, abandon the call.

            if (!glsrvLazyGrabSurfaces(gengc, RENDER_LOCK_FLAGS))
                return;

        // We may need to temporarily reset the viewport adjust values
        // before calling simulations.  If GenMcdResetViewportAdj returns
        // TRUE, the viewport is changed and we need restore later with
        // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }
#endif

    (*gc->procs.copyPixels)(gc, x, y, width, height, format);

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genrgb.h ===
/******************************Module*Header*******************************\
* Module Name: genrgb.h
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GENRGB_H__
#define __GENRGB_H__

extern void FASTCALL __glGenInitRGB(__GLcontext *glGc, __GLcolorBuffer *Cfb , GLenum type );
extern void FASTCALL __glGenFreeRGB(__GLcontext *glGc, __GLcolorBuffer *Cfb );

#define DITHER_INC(i) (((__GLfloat) (((i) << 1) + 1)) / (__GLfloat) (2 * __GL_DITHER_PRECISION))

extern __GLfloat fDitherIncTable[];

#endif /* !__GENRGB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genrgb.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "genrgb.h"
#include "genclear.h"

#define STATIC

__GLfloat fDitherIncTable[16] = {
    DITHER_INC(0),  DITHER_INC(8),  DITHER_INC(2),  DITHER_INC(10),
    DITHER_INC(12), DITHER_INC(4),  DITHER_INC(14), DITHER_INC(6),
    DITHER_INC(3),  DITHER_INC(11), DITHER_INC(1),  DITHER_INC(9),
    DITHER_INC(15), DITHER_INC(7),  DITHER_INC(13), DITHER_INC(5)
};

/* No Dither,  No blend, No Write, No Nothing */
STATIC void FASTCALL Store_NOT(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
}

STATIC GLboolean FASTCALL StoreSpanNone(__GLcontext *gc)
{
    return GL_FALSE;
}

//
// Special case normal alpha blending (source alpha*src + dst*(1-sa))
// This case is used in antialiasing and actually jumping through
// the fetch and blend procs takes up a large amount of time.  Moving
// the code into the store proc removes this overhead
//
// The macro requires a standard store proc setup, with gc, cfb, frag,
// blendColor and so on.  It requires a dst_pix variable which
// will hold a pixel in the destination format.
// It also takes as an argument a statement which will set dst_pix.
// The reason it doesn't take the pixel itself is because only the special case
// actually needs the value.  In all the flags cases the pixel
// retrieval would be wasted.
//

extern void __glDoBlend_SA_MSA(__GLcontext *gc, const __GLcolor *source,
                               const __GLcolor *dest, __GLcolor *result);

#define SPECIAL_ALPHA_BLEND(dst_pix_gen)                                      \
    color = &blendColor;                                                      \
    if( (gc->procs.blendColor == __glDoBlend_SA_MSA) &&			      \
        !( ALPHA_WRITE_ENABLED( cfb )) ) \
    {									      \
        __GLfloat a, msa;						      \
                							      \
        a = frag->color.a * gc->frontBuffer.oneOverAlphaScale;		      \
        msa = __glOne - a;						      \
									      \
        dst_pix_gen;					                      \
        blendColor.r = frag->color.r*a + msa*(__GLfloat)		      \
            ((dst_pix & gc->modes.redMask) >> cfb->redShift);		      \
        blendColor.g = frag->color.g*a + msa*(__GLfloat)		      \
            ((dst_pix & gc->modes.greenMask) >> cfb->greenShift);	      \
        blendColor.b = frag->color.b*a + msa*(__GLfloat)		      \
            ((dst_pix & gc->modes.blueMask) >> cfb->blueShift);		      \
    }									      \
    else								      \
    {									      \
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );		      \
    }

#define SPECIAL_ALPHA_BLEND_SPAN(dst_pix_gen)				      \
    if( (gc->procs.blendColor == __glDoBlend_SA_MSA) &&			      \
        !( ALPHA_WRITE_ENABLED( cfb )) ) \
    {									      \
        __GLcolor *color = gc->polygon.shader.colors;   \
                                                         \
        for ( i = 0; i < w; i++, color++ )			      \
        {								      \
            __GLfloat a, msa;						      \
									      \
            a = color->a * gc->frontBuffer.oneOverAlphaScale;		      \
            msa = __glOne - a;						      \
									      \
            dst_pix_gen;						      \
            color->r = color->r*a + msa*(__GLfloat)			      \
                ((dst_pix & gc->modes.redMask) >> cfb->redShift);	      \
            color->g = color->g*a + msa*(__GLfloat)			      \
                ((dst_pix & gc->modes.greenMask) >> cfb->greenShift);	      \
            color->b = color->b*a + msa*(__GLfloat)			      \
                ((dst_pix & gc->modes.blueMask) >> cfb->blueShift);	      \
        }								      \
    }									      \
    else								      \
    {									      \
        (*gc->procs.blendSpan)( gc );         \
    }

#define DitheredRGBColorToBuffer(col, incr, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r+(incr)) << (cfb)->redShift) | \
                     ( FTOL((col)->g+(incr)) << (cfb)->greenShift) | \
                     ( FTOL((col)->b+(incr)) << (cfb)->blueShift)))
#define UnditheredRGBColorToBuffer(col, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r) << (cfb)->redShift) | \
                     ( FTOL((col)->g) << (cfb)->greenShift) | \
                     ( FTOL((col)->b) << (cfb)->blueShift)))
#define DitheredRGBAColorToBuffer(col, incr, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r+(incr)) << (cfb)->redShift) | \
                     ( FTOL((col)->g+(incr)) << (cfb)->greenShift) | \
                     ( FTOL((col)->b+(incr)) << (cfb)->blueShift) | \
                     ( FTOL((col)->a+(incr)) << (cfb)->alphaShift)))
#define UnditheredRGBAColorToBuffer(col, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r) << (cfb)->redShift) | \
                     ( FTOL((col)->g) << (cfb)->greenShift) | \
                     ( FTOL((col)->b) << (cfb)->blueShift) | \
                     ( FTOL((col)->a) << (cfb)->alphaShift)))

#define DitheredColorToBuffer(col, incr, cfb, dest, type) \
    if( ALPHA_PIXEL_WRITE( cfb ) ) \
        DitheredRGBAColorToBuffer(col, incr, cfb, dest, type); \
    else \
        DitheredRGBColorToBuffer(col, incr, cfb, dest, type);

#define UnditheredColorToBuffer(col, cfb, dest, type) \
    if( ALPHA_PIXEL_WRITE( cfb ) ) \
        UnditheredRGBAColorToBuffer(col, cfb, dest, type); \
    else \
        UnditheredRGBColorToBuffer(col, cfb, dest, type);

#define StoreColorAsRGB(col, dst) \
    (*(dst)++ = (BYTE) FTOL((col)->r), \
     *(dst)++ = (BYTE) FTOL((col)->g), \
     *(dst)++ = (BYTE) FTOL((col)->b) )
#define StoreColorAsBGR(col, dst) \
    (*(dst)++ = (BYTE) FTOL((col)->b), \
     *(dst)++ = (BYTE) FTOL((col)->g), \
     *(dst)++ = (BYTE) FTOL((col)->r) )

// Macro to read RGBA bitfield span, where alpha component has 3 possibilities:
// 1) No alpha buffer, so use constant alpha
// 2) Alpha is part of the pixel
// 3) Alpha is in the software alpha buffer
// Note, currently this is only used for 16 and 32bpp.

#define READ_RGBA_BITFIELD_SPAN(src_pix_gen)				      \
    if( !gc->modes.alphaBits ) { \
        for( ; w; w--, pResults++ ) \
        { \
            src_pix_gen; \
            pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift); \
            pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift); \
            pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift); \
            pResults->a = cfb->alphaScale; \
        } \
    } \
    else if( ALPHA_IN_PIXEL( cfb ) ) { \
        for( ; w; w--, pResults++ ) \
        { \
            src_pix_gen; \
            pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift); \
            pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift); \
            pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift); \
            pResults->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift); \
        } \
    } else { \
        (*cfb->alphaBuf.readSpan)(&cfb->alphaBuf, x, y, w, pResults); \
        for( ; w; w--, pResults++ ) \
        { \
            src_pix_gen; \
            pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift); \
            pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift); \
            pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift); \
        } \
    }

/*
 *  write all
 */
STATIC void FASTCALL DIBIndex4Store(__GLcolorBuffer *cfb,
                                    const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        incr = (enables & __GL_DITHER_ENABLE) ?
            fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x >> 1));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix = gengc->pajInvTranslateVector
                                 [(x & 1) ? (*puj & 0xf) : (*puj >> 4)]));
        }
        else
        {
            color = &(frag->color);
        }

        DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

        if (cfb->buf.flags & NEED_FETCH)
        {
            if( x & 1 )
            {
                dst_pix = (*puj & 0x0f);
            }
            else
            {
                dst_pix = (*puj & 0xf0) >> 4;
            }
            dst_pix = gengc->pajInvTranslateVector[dst_pix];

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = (GLubyte)
                    (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                     gc->modes.allMask);
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (GLubyte)
                    ((dst_pix & cfb->destMask) | (result & cfb->sourceMask));
            }
        }

        // now put it in
        result = gengc->pajTranslateVector[result];
        if (x & 1)
        {
            *puj = (*puj & 0xf0) | result;
        }
        else
        {
            result <<= 4;
            *puj = (*puj & 0x0f) | result;
        }
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}


STATIC void FASTCALL DIBIndex8Store(__GLcolorBuffer *cfb,
                                    const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        incr = (enables & __GL_DITHER_ENABLE) ?
            fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + x);

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix =
                                 gengc->pajInvTranslateVector[*puj]));
        }
        else
        {
            color = &(frag->color);
        }

        DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

        if (cfb->buf.flags & NEED_FETCH)
        {
            dst_pix = gengc->pajInvTranslateVector[*puj];

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = (GLubyte)
                    (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                     gc->modes.allMask);
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (GLubyte)
                    ((dst_pix & cfb->destMask) | (result & cfb->sourceMask));
            }
        }

        *puj = gengc->pajTranslateVector[result];

        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_24BPP in BGR format
STATIC void FASTCALL DIBBGRStore(__GLcolorBuffer *cfb,
                                 const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x * 3));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND(Copy3Bytes(&dst_pix, puj));
        }
        else
        {
            color = &(frag->color);
        }

        if (cfb->buf.flags & NEED_FETCH)
        {
            Copy3Bytes( &dst_pix, puj );

            UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                    gc->modes.allMask;
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result =
                    (result & cfb->sourceMask) | (dst_pix & cfb->destMask);
            }

            Copy3Bytes( puj, &result );
        }
        else
        {
            StoreColorAsBGR(color, puj);
        }
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_24BPP in RGB format
STATIC void FASTCALL DIBRGBAStore(__GLcolorBuffer *cfb,
                                 const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x * 3));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND(Copy3Bytes(&dst_pix, puj));
        }
        else
        {
            color = &(frag->color);
        }

        if (cfb->buf.flags & NEED_FETCH)
        {
            Copy3Bytes( &dst_pix, puj );
            UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                    gc->modes.allMask;
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result =
                    (result & cfb->sourceMask) | (dst_pix & cfb->destMask);
            }

            Copy3Bytes( puj, &result );
        }
        else
        {
            StoreColorAsRGB(color, puj);
        }
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_16BPP
STATIC void FASTCALL DIBBitfield16Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLushort result, *pus;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLushort dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        incr = (enables & __GL_DITHER_ENABLE) ?
            fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                           (y*cfb->buf.outerWidth) + (x << 1));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix = *pus));
        }
        else
        {
            color = &(frag->color);
        }

        DitheredColorToBuffer(color, incr, cfb, result, GLushort);

        if (cfb->buf.flags & NEED_FETCH)
        {
            dst_pix = *pus;

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = (GLushort)
                    (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                     gc->modes.allMask);
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (GLushort)((dst_pix & cfb->destMask) |
                              (result & cfb->sourceMask));
            }
        }
        *pus = result;

        if( ALPHA_BUFFER_WRITE( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_32BPP store
// each component is 8 bits or less
// XXX could special case if shifting by 8 or use the 24 bit RGB code
STATIC void FASTCALL DIBBitfield32Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLuint result, *pul;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix = *pul));
        }
        else
        {
            color = &(frag->color);
        }

        UnditheredColorToBuffer(color, cfb, result, GLuint);

        if (cfb->buf.flags & NEED_FETCH)
        {
            dst_pix = *pul;

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result =
                    DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                    gc->modes.allMask;
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (dst_pix & cfb->destMask) | (result & cfb->sourceMask);
            }
        }
        *pul = result;

        if( ALPHA_BUFFER_WRITE( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

static GLubyte vubRGBtoVGA[8] = {
    0x00,
    0x90,
    0xa0,
    0xb0,
    0xc0,
    0xd0,
    0xe0,
    0xf0
};

STATIC void FASTCALL DisplayIndex4Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    incr = (enables & __GL_DITHER_ENABLE) ?
        fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *puj >> 4;

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result = (GLubyte)
                (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                 gc->modes.allMask);
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (GLubyte)((dst_pix & cfb->destMask) |
                               (result & cfb->sourceMask));
        }
    }

    *puj = vubRGBtoVGA[result];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

// Put fragment into created DIB and call copybits for one pixel
STATIC void FASTCALL DisplayIndex8Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;

    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    incr = (enables & __GL_DITHER_ENABLE) ?
        fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = gengc->pajInvTranslateVector[*puj];

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result = (GLubyte)
                (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                 gc->modes.allMask);
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (GLubyte)((dst_pix & cfb->destMask) |
                               (result & cfb->sourceMask));
        }
    }

    *puj = gengc->pajTranslateVector[result];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayBGRStore(__GLcolorBuffer *cfb,
                                     const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *(GLuint *)puj;
        UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result =
                DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                gc->modes.allMask;
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (dst_pix & cfb->destMask) |
                (result & cfb->sourceMask);
        }

        Copy3Bytes( puj, &result );
    }
    else
    {
        StoreColorAsBGR(color, puj);
    }
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayRGBStore(__GLcolorBuffer *cfb,
                                     const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *(GLuint *)puj;
        UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result =
                DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                gc->modes.allMask;
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (dst_pix & cfb->destMask) |
                (result & cfb->sourceMask);
        }

        Copy3Bytes( puj, &result );
    }
    else
    {
        StoreColorAsRGB(color, puj);
    }
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayBitfield16Store(__GLcolorBuffer *cfb,
                                            const __GLfragment *frag)
{
    GLint x, y;
    GLushort result, *pus;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLushort dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    incr = (enables & __GL_DITHER_ENABLE) ?
        fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    pus = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    DitheredColorToBuffer(color, incr, cfb, result, GLushort);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *pus;

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result = (GLushort)
                (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                 gc->modes.allMask);
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (GLushort)((dst_pix & cfb->destMask) |
                                (result & cfb->sourceMask));
        }
    }

    *pus = result;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayBitfield32Store(__GLcolorBuffer *cfb,
                                            const __GLfragment *frag)
{
    GLint x, y;
    GLuint result, *pul;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    pul = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    UnditheredColorToBuffer(color, cfb, result, GLuint);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *pul;

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result =
                DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                gc->modes.allMask;
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (dst_pix & cfb->destMask) |
                (result & cfb->sourceMask);
        }
    }

    *pul = result;
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL AlphaStore(__GLcolorBuffer *cfb,
                                    const __GLfragment *frag)
{
    (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, &(frag->color) );
}

/******************************Public*Routine******************************\
* Index8StoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles 8-bit CI mode.  Blending and dithering are supported.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  15-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL Index8StoreSpan( __GLcontext *gc )
{
    GLint xFrag, yFrag;             // current fragment coordinates
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte result, *puj;           // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLfloat incr;                 // current dither adj.

    GLint w;                        // span width
    ULONG ulSpanVisibility;         // span visibility mode
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLboolean bDIB;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

// Get span position and length.

    w = gc->polygon.shader.length;
    xFrag = gc->polygon.shader.frag.x;
    yFrag = gc->polygon.shader.frag.y;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    if( !bDIB || (flags & NO_CLIP) )
    {
    // Device managed or unclipped surface
        ulSpanVisibility = WGL_SPAN_ALL;
    }
    else
    {
    // Device in BITMAP format
        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);
    }

// Proceed as long as the span is (partially or fully) visible.
    if (ulSpanVisibility  != WGL_SPAN_NONE)
    {
        GLboolean bCheckWalls = GL_FALSE;
        GLboolean bDraw;
        GLint NextWall;

        if (ulSpanVisibility == WGL_SPAN_PARTIAL)
        {
            bCheckWalls = GL_TRUE;
            if (cWalls & 0x01)
            {
                bDraw = GL_TRUE;
            }
            else
            {
                bDraw = GL_FALSE;
            }
            NextWall = *Walls++;
            cWalls--;
        }
    // Get pointers to fragment colors array and frame buffer.

        cp = gc->polygon.shader.colors;
        cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

        puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + xScr)
                     : gengc->ColorsBits;
        pujEnd = puj + w;

    // Case: no dithering, no masking, no blending
    //
    // Check for the common case (which we'll do the fastest).

        if ( !(enables & (__GL_DITHER_ENABLE)) &&
             !(cfb->buf.flags & NEED_FETCH) &&
             !(enables & __GL_BLEND_ENABLE ) )
        {
            //!!!XXX -- we can also opt. by unrolling the loops

            incr = __glHalf;
            for (; puj < pujEnd; puj++, cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE)
                        continue;
                }

                DitheredRGBColorToBuffer(cp, incr, cfb, result, GLubyte);
                *puj = gengc->pajTranslateVector[result];
            }
        }

    // Case: dithering, no masking, no blending
    //
    // Dithering is pretty common for 8-bit displays, so its probably
    // worth special case also.

        else if ( !(cfb->buf.flags & NEED_FETCH) &&
                  !(enables & __GL_BLEND_ENABLE) )
        {
            for (; puj < pujEnd; puj++, cp++, xFrag++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE)
                        continue;
                }
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

                DitheredRGBColorToBuffer(cp, incr, cfb, result, GLubyte);
                *puj = gengc->pajTranslateVector[result];
            }
        }

    // Case: general
    //
    // Otherwise, we'll do it slower.

        else
        {
            // Fetch pixels we will modify:

            if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
                (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE );

            // Blend.
            if (enables & __GL_BLEND_ENABLE)
            {
                int i;

                // this overwrites fragment colors array with blended values
                SPECIAL_ALPHA_BLEND_SPAN(
                        (dst_pix =
                         gengc->pajInvTranslateVector[*(puj+i)]));
            }

            for (; puj < pujEnd; puj++, cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE)
                        continue;
                }
            // Dither.

                if (enables & __GL_DITHER_ENABLE)
                {
                    incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                    xFrag++;
                }
                else
                {
                    incr = __glHalf;
                }

            // Convert the RGB color to color index.

                DitheredRGBColorToBuffer(cp, incr, cfb, result, GLubyte);

            // Color mask

                if (cfb->buf.flags & NEED_FETCH)
                {
                    dst_pix = gengc->pajInvTranslateVector[*puj];

                    if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                    {
                        result = (GLubyte)
                            (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                             gc->modes.allMask);
                    }

                    if (cfb->buf.flags & COLORMASK_ON)
                    {
                        result = (GLubyte)((dst_pix & cfb->destMask) |
                                           (result & cfb->sourceMask));
                    }
                }

                *puj = gengc->pajTranslateVector[result];
            }
        }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

        if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

        // Note that we ignore walls here for simplicity...
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    }

    return GL_FALSE;
}

/******************************Public*Routine******************************\
* Bitfield16StoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles general 16-bit BITFIELDS mode.  Blending is supported.  There
* is dithering.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  08-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL 
Bitfield16StoreSpanPartial(__GLcontext *gc, GLboolean bDIB, GLint cWalls, GLint *Walls )
{
    GLint xFrag, yFrag;             // current fragment coordinates
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLushort result, *pus;          // current pixel color, current pixel ptr
    GLushort *pusEnd;               // end of scan line
    __GLfloat incr;                 // current dither adj.

    GLint w;                        // span width
    GLboolean bDraw;
    GLint NextWall;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLushort dst_pix;

// Get span position and length.

    w = gc->polygon.shader.length;
    xFrag = gc->polygon.shader.frag.x;
    yFrag = gc->polygon.shader.frag.y;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;


    if (cWalls & 0x01)
    {
        bDraw = GL_TRUE;
    }
    else
    {
        bDraw = GL_FALSE;
    }
    NextWall = *Walls++;
    cWalls--;

    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<1))
                 : gengc->ColorsBits;
    pusEnd = pus + w;

    // Case: no masking, no dithering, no blending

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        incr = __glHalf;
        for (; pus < pusEnd; pus++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);
            *pus = result;
        }
    }

    // Case: dithering, no masking, no blending

    else if ( !(cfb->buf.flags & NEED_FETCH) &&
              !(enables & __GL_BLEND_ENABLE) )
    {
        for (; pus < pusEnd; pus++, cp++, xFrag++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);
            *pus = result;
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if ( enables & __GL_BLEND_ENABLE )
        {
            int i;

            // this overwrites fragment colors array with blended values
            // XXX is the +i handled properly by the optimizer ?
            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pus+i)));
        }

        for (; pus < pusEnd; pus++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            // Dither.

            if ( enables & __GL_DITHER_ENABLE )
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                incr = __glHalf;
            }

            // Convert color to 16BPP format.

            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);

            // Store result with optional masking.

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pus;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result = (GLushort)
                        (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                         gc->modes.allMask);
                }

                if ( cfb->buf.flags & COLORMASK_ON )
                {
                    result = (GLushort)((dst_pix & cfb->destMask) |
                                      (result & cfb->sourceMask));
                }
            }
            *pus = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );

    return GL_FALSE;
}

STATIC GLboolean FASTCALL Bitfield16StoreSpan(__GLcontext *gc)
{
    GLint xFrag, yFrag;             // current fragment coordinates
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer
    GLboolean   bDIB;

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLushort result, *pus;          // current pixel color, current pixel ptr
    GLushort *pusEnd;               // end of scan line
    __GLfloat incr;                 // current dither adj.

    GLint w;                        // span width
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLushort dst_pix;

    ASSERT_CHOP_ROUND();

// Get span position and length.

    w = gc->polygon.shader.length;
    xFrag = gc->polygon.shader.frag.x;
    yFrag = gc->polygon.shader.frag.y;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    // Check span visibility 
    if( bDIB && !(flags & NO_CLIP) )
    {
        // Device in BITMAP format
        ULONG ulSpanVisibility;         // span visibility mode

        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);

        if (ulSpanVisibility  == WGL_SPAN_NONE)
            return GL_FALSE;
        else if (ulSpanVisibility == WGL_SPAN_PARTIAL)
            return Bitfield16StoreSpanPartial( gc, bDIB, cWalls, Walls );
        // else span fully visible
    }

    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<1))
                 : gengc->ColorsBits;
    pusEnd = pus + w;

    // Case: no masking, no dithering, no blending

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        incr = __glHalf;
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for (; pus < pusEnd; pus++, cp++)
                DitheredRGBAColorToBuffer(cp, incr, cfb, *pus, GLushort);
        } else {
            for (; pus < pusEnd; pus++, cp++)
                DitheredRGBColorToBuffer(cp, incr, cfb, *pus, GLushort);
        }
    
    }

    // Case: dithering, no masking, no blending

    else if ( !(cfb->buf.flags & NEED_FETCH) &&
              !(enables & __GL_BLEND_ENABLE) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for (; pus < pusEnd; pus++, cp++, xFrag++)
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

                DitheredRGBAColorToBuffer(cp, incr, cfb, *pus, GLushort);
            }
        } else {
            for (; pus < pusEnd; pus++, cp++, xFrag++)
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

                DitheredRGBColorToBuffer(cp, incr, cfb, *pus, GLushort);
            }
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if ( enables & __GL_BLEND_ENABLE )
        {
            int i;

            // this overwrites fragment colors array with blended values
            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pus+i)));
        }

        for (; pus < pusEnd; pus++, cp++)
        {
            // Dither.

            if ( enables & __GL_DITHER_ENABLE )
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                incr = __glHalf;
            }

            // Convert color to 16BPP format.

            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);

            // Store result with optional masking.

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pus;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result = (GLushort)
                        (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                         gc->modes.allMask);
                }

                if ( cfb->buf.flags & COLORMASK_ON )
                {
                    result = (GLushort)((dst_pix & cfb->destMask) |
                                      (result & cfb->sourceMask));
                }
            }
            *pus = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    return GL_FALSE;
}

/******************************Public*Routine******************************\
* BGRStoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles GBR 24-bit mode.  Blending is supported.  There
* is no dithering.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  10-Jan-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL BGRStoreSpan(__GLcontext *gc )
{
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte *puj;                   // current pixel ptr
    GLuint *pul;                    // current pixel ptr
    GLuint result;                  // current pixel color
    GLubyte *pujEnd;                 // end of scan line

    GLint w;                        // span width
    ULONG ulSpanVisibility;         // span visibility mode
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLboolean   bDIB;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

// Get span position and length.

    w = gc->polygon.shader.length;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;

    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    if( !bDIB || (flags & NO_CLIP) )
    {
// Device managed or unclipped surface
        ulSpanVisibility = WGL_SPAN_ALL;
    }
    else
    {
// Device in BITMAP format
        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);
    }

// Proceed as long as the span is (partially or fully) visible.
    if (ulSpanVisibility  != WGL_SPAN_NONE)
    {
        GLboolean bCheckWalls = GL_FALSE;
        GLboolean bDraw;
        GLint NextWall;

        if (ulSpanVisibility == WGL_SPAN_PARTIAL)
        {
            bCheckWalls = GL_TRUE;
            if (cWalls & 0x01)
            {
                bDraw = GL_TRUE;
            }
            else
            {
                bDraw = GL_FALSE;
            }
            NextWall = *Walls++;
            cWalls--;
        }
    // Get pointers to fragment colors array and frame buffer.

        cp = gc->polygon.shader.colors;
        cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

        puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr*3))
                     : gengc->ColorsBits;
        pujEnd = puj + 3*w;

    // Case: no masking, no blending

        //!!!XXX -- do extra opt. for RGB and BGR cases

        //!!!XXX -- we can also opt. by unrolling the loops

        if ( !(cfb->buf.flags & NEED_FETCH) &&
             !(enables & __GL_BLEND_ENABLE) )
        {
            for (; puj < pujEnd; cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE) {
                        puj += 3;
                        continue;
                    }
                }
                StoreColorAsBGR(cp, puj);
            }
        }

    // All other cases

        else
        {
            if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
                (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

            if (enables & __GL_BLEND_ENABLE)
            {
                // this overwrites fragment colors array with blended values
                (*gc->procs.blendSpan)( gc );
            }

            for (; puj < pujEnd; cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE) {
                        puj += 3;
                        continue;
                    }
                }

                if (cfb->buf.flags & NEED_FETCH)
                {
                    Copy3Bytes(&dst_pix, puj);
                    UnditheredRGBColorToBuffer(cp, cfb, result, GLuint);

                    if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                    {
                        result =
                            DoLogicOp(gc->state.raster.logicOp, result,
                                      dst_pix) & gc->modes.allMask;
                    }

                    if (cfb->buf.flags & COLORMASK_ON)
                    {
                        result = (result & cfb->sourceMask) |
                            (dst_pix & cfb->destMask);
                    }

                    Copy3Bytes( puj, &result );
                    puj += 3;
                }
                else
                {
                    StoreColorAsBGR(cp, puj);
                }
            }
        }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

        if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    }

    return GL_FALSE;
}

/******************************Public*Routine******************************\
* Bitfield32StoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles general 32-bit BITFIELDS mode.  Blending is supported.  There
* is no dithering.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  15-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL 
Bitfield32StoreSpanPartial(__GLcontext *gc, GLboolean bDIB, GLint cWalls, GLint *Walls )
{
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLuint result, *pul;            // current pixel color, current pixel ptr
    GLuint *pulEnd;                 // end of scan line

    GLint w;                        // span width

    GLboolean bDraw;
    GLint NextWall;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLuint dst_pix;

// Get span position and length.

    w = gc->polygon.shader.length;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;

    flags = cfb->buf.flags;

    if (cWalls & 0x01)
    {
        bDraw = GL_TRUE;
    }
    else
    {
        bDraw = GL_FALSE;
    }
    NextWall = *Walls++;
    cWalls--;
    
    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<2))
                 : gengc->ColorsBits;
    pulEnd = pul + w;

    // Case: no masking, no blending

    //!!!XXX -- do extra opt. for RGB and BGR cases

    //!!!XXX -- we can also opt. by unrolling the loops

    if ( !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        for (; pul < pulEnd; pul++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            UnditheredColorToBuffer(cp, cfb, result, GLuint);
            *pul = result;
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if (enables & __GL_BLEND_ENABLE)
        {
            int i;

            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pul+i)));
        }

        for (; pul < pulEnd; pul++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;

            UnditheredColorToBuffer(cp, cfb, result, GLuint);

            //!!!XXX again, opt. by unrolling loop

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pul;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result =
                        DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                        gc->modes.allMask;
                }

                if (cfb->buf.flags & COLORMASK_ON)
                {
                    result = (dst_pix & cfb->destMask) |
                        (result & cfb->sourceMask);
                }
            }
            *pul = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );

    return GL_FALSE;
}

STATIC GLboolean FASTCALL Bitfield32StoreSpan( __GLcontext *gc )
{
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer
    GLboolean   bDIB;

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLuint result, *pul;            // current pixel color, current pixel ptr
    GLuint *pulEnd;                 // end of scan line

    GLint w;                        // span width
    ULONG ulSpanVisibility;         // span visibility mode
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    // Get span position and length.

    w = gc->polygon.shader.length;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    // Check span visibility 
    if( bDIB && !(flags & NO_CLIP) )
    {
        // Device in BITMAP format
        ULONG ulSpanVisibility;         // span visibility mode

        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);

        if (ulSpanVisibility  == WGL_SPAN_NONE)
            return GL_FALSE;
        else if (ulSpanVisibility == WGL_SPAN_PARTIAL)
            return Bitfield32StoreSpanPartial( gc, bDIB, cWalls, Walls );
        // else span fully visible
    }

    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<2))
                 : gengc->ColorsBits;
    pulEnd = pul + w;

    // Case: no masking, no blending

    //!!!XXX -- do extra opt. for RGB and BGR cases

    //!!!XXX -- we can also opt. by unrolling the loops

    if ( !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for (; pul < pulEnd; pul++, cp++)
            {
                UnditheredRGBAColorToBuffer(cp, cfb, result, GLuint);
                *pul = result;
            }
        } else {
            for (; pul < pulEnd; pul++, cp++)
            {
                UnditheredRGBColorToBuffer(cp, cfb, result, GLuint);
                *pul = result;
            }
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if (enables & __GL_BLEND_ENABLE)
        {
            int i;

            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pul+i)));
        }

        for (; pul < pulEnd; pul++, cp++)
        {
            UnditheredColorToBuffer(cp, cfb, result, GLuint);

            //!!!XXX again, opt. by unrolling loop

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pul;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result =
                        DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                        gc->modes.allMask;
                }

                if (cfb->buf.flags & COLORMASK_ON)
                {
                    result = (dst_pix & cfb->destMask) |
                        (result & cfb->sourceMask);
                }
            }
            *pul = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );

    return GL_FALSE;
}

STATIC GLboolean FASTCALL AlphaStoreSpan(__GLcontext *gc)
{
    __GLcolorBuffer *cfb = gc->drawBuffer;

    ASSERT_CHOP_ROUND();

    (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    return GL_FALSE;
}

STATIC GLboolean FASTCALL StoreMaskedSpan(__GLcontext *gc, GLboolean masked)
{
#ifdef REWRITE
    GLint x, y, len;
    int i;
    __GLcolor *cp;
    DWORD *pul;
    WORD *pus;
    BYTE *puj;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    len = gc->polygon.shader.length;
    x = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x);
    y = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y);

    cp = gc->polygon.shader.colors;

    switch (gengc->iFormatDC)
    {

    case BMF_8BPP:
        break;

    case BMF_16BPP:
        pus = gengc->ColorsBits;
        for (i = 0; i < len; i++) {
            *pus++ = __GL_COLOR_TO_BMF_16BPP(cp);
            cp++;
        }
        break;

    case BMF_24BPP:
        puj = gengc->ColorsBits;
        for (i = 0; i < len; i++) {
            *puj++ = (BYTE)cp->b;               // XXX check order
            *puj++ = (BYTE)cp->g;
            *puj++ = (BYTE)cp->r;
            cp++;
        }
        break;

    case BMF_32BPP:
        pul = gengc->ColorsBits;
        for (i = 0; i < len; i++) {
            *pul++ = __GL_COLOR_TO_BMF_32BPP(cp);
            cp++;
        }
        break;

    default:
        break;
    }
    if (masked == GL_TRUE)              // XXX mask is BigEndian!!!
    {
        unsigned long *pulstipple;
        unsigned long stip;
        GLint count;

        pul = gengc->StippleBits;
        pulstipple = gc->polygon.shader.stipplePat;
        count = (len+31)/32;
        for (i = 0; i < count; i++) {
            stip = *pulstipple++;
            *pul++ = (stip&0xff)<<24 | (stip&0xff00)<<8 | (stip&0xff0000)>>8 |
                (stip&0xff000000)>>24;
        }
        wglSpanBlt(CURRENT_DC, gengc->ColorsBitmap, gengc->StippleBitmap,
                   x, y, len);
    }
    else
    {
        wglSpanBlt(CURRENT_DC, gengc->ColorsBitmap, (HBITMAP)NULL,
                   x, y, len);
    }
#endif

    return GL_FALSE;
}

#ifdef TESTSTIPPLE
STATIC void FASTCALL MessUpStippledSpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (!(inMask & bit)) {
                cp->r = cfb->redMax;
                cp->g = cfb->greenMax;
                cp->b = cfb->blueMax;
            }

            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }
}
#endif

// From the PIXMAP code, calls store for each fragment
STATIC GLboolean FASTCALL SlowStoreSpan(__GLcontext *gc)
{
    int x, x1;
    int i;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint w;

    w = gc->polygon.shader.length;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    x1 = gc->polygon.shader.frag.x + w;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    for (i = x; i < x1; i++) {
        frag.x = i;
        frag.color = *cp++;

        (*cfb->store)(cfb, &frag);
    }

    return GL_FALSE;
}

// From the PIXMAP code, calls store for each fragment with mask test
STATIC GLboolean FASTCALL SlowStoreStippledSpan(__GLcontext *gc)
{
    int x;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = __GL_STIPPLE_SHIFT((__GLstippleWord)0);
        while (--count >= 0) {
            if (inMask & bit) {
                frag.x = x;
                frag.color = *cp;

                (*cfb->store)(cfb, &frag);
            }
            x++;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    return GL_FALSE;
}

//
//  Tables to convert 4-bit index to RGB component
//  These tables assume the VGA fixed palette
//  History:
//      22-NOV-93   Eddie Robinson [v-eddier] Wrote it.
//
#ifdef __GL_DOUBLE

static __GLfloat vfVGAtoR[16] = {
    0.0,    // black
    0.5,    // dim red
    0.0,    // dim green
    0.5,    // dim yellow
    0.0,    // dim blue
    0.5,    // dim magenta
    0.0,    // dim cyan
    0.5,    // dim grey
    0.75,   // medium grey
    1.0,    // bright red
    0.0,    // bright green
    1.0,    // bright yellow
    0.0,    // bright blue
    1.0,    // bright magenta
    0.0,    // bright cyan
    1.0     // white
};

static __GLfloat vfVGAtoG[16] = {
    0.0,    // black
    0.0,    // dim red
    0.5,    // dim green
    0.5,    // dim yellow
    0.0,    // dim blue
    0.0,    // dim magenta
    0.5,    // dim cyan
    0.5,    // dim grey
    0.75,   // medium grey
    0.0,    // bright red
    1.0,    // bright green
    1.0,    // bright yellow
    0.0,    // bright blue
    0.0,    // bright magenta
    1.0,    // bright cyan
    1.0     // white
};

static __GLfloat vfVGAtoB[16] = {
    0.0,    // black
    0.0,    // dim red
    0.0,    // dim green
    0.0,    // dim yellow
    0.5,    // dim blue
    0.5,    // dim magenta
    0.5,    // dim cyan
    0.5,    // dim grey
    0.75,   // medium grey
    0.0,    // bright red
    0.0,    // bright green
    0.0,    // bright yellow
    1.0,    // bright blue
    1.0,    // bright magenta
    1.0,    // bright cyan
    1.0     // white
};

#else

static __GLfloat vfVGAtoR[16] = {
    0.0F,   // black
    0.5F,   // dim red
    0.0F,   // dim green
    0.5F,   // dim yellow
    0.0F,   // dim blue
    0.5F,   // dim magenta
    0.0F,   // dim cyan
    0.5F,   // dim grey
    0.75F,  // medium grey
    1.0F,   // bright red
    0.0F,   // bright green
    1.0F,   // bright yellow
    0.0F,   // bright blue
    1.0F,   // bright magenta
    0.0F,   // bright cyan
    1.0F    // white
};

static __GLfloat vfVGAtoG[16] = {
    0.0F,   // black
    0.0F,   // dim red
    0.5F,   // dim green
    0.5F,   // dim yellow
    0.0F,   // dim blue
    0.0F,   // dim magenta
    0.5F,   // dim cyan
    0.5F,   // dim grey
    0.75F,  // medium grey
    0.0F,   // bright red
    1.0F,   // bright green
    1.0F,   // bright yellow
    0.0F,   // bright blue
    0.0F,   // bright magenta
    1.0F,   // bright cyan
    1.0F    // white
};

static __GLfloat vfVGAtoB[16] = {
    0.0F,   // black
    0.0F,   // dim red
    0.0F,   // dim green
    0.0F,   // dim yellow
    0.5F,   // dim blue
    0.5F,   // dim magenta
    0.5F,   // dim cyan
    0.5F,   // dim grey
    0.75F,  // medium grey
    0.0F,   // bright red
    0.0F,   // bright green
    0.0F,   // bright yellow
    1.0F,   // bright blue
    1.0F,   // bright magenta
    1.0F,   // bright cyan
    1.0F    // white
};

#endif


void
RGBFetchNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    result->r = 0.0F;
    result->g = 0.0F;
    result->b = 0.0F;
    if( cfb->buf.gc->modes.alphaBits )
        result->a = 0.0F;
    else
        result->a = cfb->alphaScale;
}

void
RGBReadSpanNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                GLint w)
{
    GLint i;
    __GLcolor *pResults;
    __GLfloat alphaVal;

    if( cfb->buf.gc->modes.alphaBits )
        alphaVal = 0.0F;
    else
        alphaVal = cfb->alphaScale;

    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        pResults->r = 0.0F;
        pResults->g = 0.0F;
        pResults->b = 0.0F;
        pResults->a = alphaVal;
    }
}

void
DIBIndex4RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    // Do alpha first, before x,y unbiased
    if( gc->modes.alphaBits ) {
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
    } else
        result->a = cfb->alphaScale;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                      (y*cfb->buf.outerWidth) + (x >> 1));

    pixel = *puj;
    if (!(x & 1))
        pixel >>= 4;

    pixel = gengc->pajInvTranslateVector[pixel&0xf];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
}

void
DIBIndex8RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DIBIndex8RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
}

void
DIBBGRFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DIBBGRAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
}

void
DIBRGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DIBRGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
}

void
DIBBitfield16RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                      (y*cfb->buf.outerWidth) + (x << 1));
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DIBBitfield16RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;
    GLint xScr, yScr;               // current screen (pixel) coordinates

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                      (yScr*cfb->buf.outerWidth) + (xScr << 1));
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

void
DIBBitfield32RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                    (y*cfb->buf.outerWidth) + (x << 2));
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DIBBitfield32RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                    (yScr*cfb->buf.outerWidth) + (xScr << 2));
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

void
DisplayIndex4RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    if( gc->modes.alphaBits ) {
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
    } else
        result->a = cfb->alphaScale;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = *puj >> 4;
    result->r = vfVGAtoR[pixel];
    result->g = vfVGAtoG[pixel];
    result->b = vfVGAtoB[pixel];
}

void
DisplayIndex8RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DisplayIndex8RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
}

void
DisplayBGRFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DisplayBGRAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
}

void
DisplayRGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DisplayRGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
}

void
DisplayBitfield16RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pus = gengc->ColorsBits;
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DisplayBitfield16RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;
    GLint xScr, yScr;               // current screen (pixel) coordinates

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pus = gengc->ColorsBits;
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

void
DisplayBitfield32RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;

    gengc = (__GLGENcontext *)gc;

    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pul = gengc->ColorsBits;
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DisplayBitfield32RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;

    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, 1, FALSE);
    pul = gengc->ColorsBits;
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

static void
ReadAlphaSpan( __GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults, 
               GLint w )
{
    __GLcontext *gc = cfb->buf.gc;

    if( gc->modes.alphaBits )
        (*cfb->alphaBuf.readSpan)(&cfb->alphaBuf, x, y, w, pResults);
    else {
        for( ; w ; w--, pResults++ )
            pResults->a = cfb->alphaScale;
    }
}

void
DIBIndex4RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                     GLint w)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;
    __GLcolor *pResults;

    ReadAlphaSpan( cfb, x, y, results, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) +
                      (x >> 1));

    pResults = results;
    if (x & 1)
    {
        pixel = *puj++;
        pixel = gengc->pajInvTranslateVector[pixel & 0xf];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
        pResults++;
        w--;
    }
    while (w > 1)
    {
        pixel = *puj >> 4;
        pixel = gengc->pajInvTranslateVector[pixel];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
        pResults++;
        pixel = *puj++;
        pixel = gengc->pajInvTranslateVector[pixel & 0xf];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
        pResults++;
        w -= 2;
    }
    if (w > 0)
    {
        pixel = *puj >> 4;
        pixel = gengc->pajInvTranslateVector[pixel];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    }
}

void
DisplayIndex4RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *results, GLint w)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;
    __GLcolor *pResults;

    ReadAlphaSpan( cfb, x, y, results, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
    puj = gengc->ColorsBits;
    pResults = results;
    while (w > 1)
    {
        pixel = *puj >> 4;
        pResults->r = vfVGAtoR[pixel];
        pResults->g = vfVGAtoG[pixel];
        pResults->b = vfVGAtoB[pixel];
        pResults++;
        pixel = *puj++ & 0xf;
        pResults->r = vfVGAtoR[pixel];
        pResults->g = vfVGAtoG[pixel];
        pResults->b = vfVGAtoB[pixel];
        pResults++;
        w -= 2;
    }
    if (w > 0)
    {
        pixel = *puj >> 4;
        pResults->r = vfVGAtoR[pixel];
        pResults->g = vfVGAtoG[pixel];
        pResults->b = vfVGAtoB[pixel];
    }
}

void
Index8RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults,
                  GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    ReadAlphaSpan( cfb, x, y, pResults, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for ( ; w; w--, pResults++)
    {
        pixel = gengc->pajInvTranslateVector[*puj++];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    }
}

void
BGRAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    ReadAlphaSpan( cfb, x, y, pResults, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }

    for ( ; w; w--, pResults++)
    {
        pResults->b = (__GLfloat) *puj++;
        pResults->g = (__GLfloat) *puj++;
        pResults->r = (__GLfloat) *puj++;
    }
}

void
RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults, GLint w )

{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;


    ReadAlphaSpan( cfb, x, y, pResults, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }

    for ( ; w; w--, pResults++)
    {
        pResults->r = (__GLfloat) *puj++;
        pResults->g = (__GLfloat) *puj++;
        pResults->b = (__GLfloat) *puj++;
    }
}

void
Bitfield16RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      __GLcolor *pResults, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (yScr*cfb->buf.outerWidth) + (xScr << 1));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);
        pus = gengc->ColorsBits;
    }
    READ_RGBA_BITFIELD_SPAN( (pixel = *pus++) );
}

void
Bitfield32RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      __GLcolor *pResults, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (yScr*cfb->buf.outerWidth) + (xScr << 2));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);
        pul = gengc->ColorsBits;
    }

    READ_RGBA_BITFIELD_SPAN( (pixel = *pul++) );
}

/************************************************************************/

// Used in accumulation

// Accumulation helper macros and functions 

// Clamp a color component between 0 and max
#define ACCUM_CLAMP_COLOR_COMPONENT( col, max ) \
    if ((col) < (__GLfloat) 0.0) \
        (col) = (__GLfloat) 0.0; \
    else if ((col) > max ) \
        (col) = max;

// Extract an accumulation buffer color component by shifting and masking, then
// multiply it by scale (Requires ap and icol defined).
#define ACCUM_SCALE_SIGNED_COLOR_COMPONENT( col, shift, sign, mask, scale ) \
        icol = (*ap >> shift) & mask; \
        if (icol & sign) \
            icol |= ~mask; \
        (col) = (icol * scale);

// Fetch and scale a span of rgba values from a 32-bit accumulation buffer
void GetClampedRGBAccum32Values( 
    __GLcolorBuffer *cfb,  GLuint *pac, __GLcolor *cDest, GLint width,
    __GLfloat scale )
{
    GLint w, i;
    GLint icol;
    __GLfloat rval, gval, bval, aval;
    __GLuicolor *shift, *mask, *sign;
    GLuint *ap;
    __GLcolor *cp;
    __GLcontext *gc = cfb->buf.gc;
    __GLaccumBuffer *afb = &gc->accumBuffer;

    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;
    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;

    for ( w = width, cp = cDest, ap = pac; w; w--, cp++, ap++ ) {
        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->r, shift->r, sign->r, mask->r, rval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->r, cfb->redScale );

        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->g, shift->g, sign->g, mask->g, gval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->g, cfb->greenScale );

        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->b, shift->b, sign->b, mask->b, bval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->b, cfb->blueScale );
    }

    if( ! ALPHA_WRITE_ENABLED( cfb ) )
        return;

    aval = scale * afb->oneOverAlphaScale;

    for ( w = width, cp = cDest, ap = pac; w; w--, cp++, ap++ ) {
        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->a, shift->a, sign->a, mask->a, aval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->a, cfb->alphaScale );
    }
}

// Fetch and scale a span of rgba values from a 64-bit accumulation buffer
void GetClampedRGBAccum64Values( 
    __GLcolorBuffer *cfb,  GLshort *pac, __GLcolor *cDest, GLint width,
    __GLfloat scale )
{
    GLint w;
    __GLcontext *gc = cfb->buf.gc;
    __GLaccumBuffer *afb = &gc->accumBuffer;
    __GLfloat rval, gval, bval, aval;
    __GLcolor *cp;
    GLshort *ap;

    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;

    for ( w = width, cp = cDest, ap = pac; w; w--, cp++, ap+=4 ) {
        cp->r = (ap[0] * rval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->r, cfb->redScale );
        cp->g = (ap[1] * gval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->g, cfb->greenScale );
        cp->b = (ap[2] * bval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->b, cfb->blueScale );
    }

    if( ! ALPHA_WRITE_ENABLED( cfb ) )
        return;

    aval = scale * afb->oneOverAlphaScale;

    // Offset the accumulation pointer to the alpha value:
    ap = pac + 3;

    for ( w = width, cp = cDest; w; w--, cp++, ap+=4 ) {
        cp->a = (*ap * rval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->a, cfb->alphaScale );
    }
}

/******************************Public*Routine******************************\
* Index4ReturnSpan
*   Reads from a 16-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*   Since accumulation of 4-bit RGB isn't very useful, this routine is very
*   general and calls through the store function pointers.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Index4ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      const __GLaccumCell *ac, __GLfloat scale, GLint w)
{
    __GLcontext *gc = cfb->buf.gc;
    GLuint *ap;                     // current accum entry
    __GLGENcontext *gengc;          // generic graphics context
    GLuint saveEnables;             // modes enabled in graphics context
    __GLaccumBuffer *afb;
    __GLfragment frag;
    __GLcolor *pAccumCol, *pac;

    afb = &gc->accumBuffer;
    ap = (GLuint *)ac;
    saveEnables = gc->state.enables.general;            // save current enables
    gc->state.enables.general &= ~__GL_BLEND_ENABLE;    // disable blend for store procs
    frag.x = x;
    frag.y = y;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum32Values( cfb, ap, pAccumCol, w, scale );

    for( pac = pAccumCol ; w; w--, pac++ )
    {
        frag.color = *pac;
        (*cfb->store)(cfb, &frag);
        frag.x++;
    }

    gc->state.enables.general = saveEnables;    // restore current enables
}

/******************************Public*Routine******************************\
* Index8ReturnSpan
*   Reads from a 32-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Index8ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLuint *ap;                     // current accum entry

    GLint xFrag, yFrag;             // current window (pixel) coordinates
    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte result, *puj;           // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLfloat inc;                  // current dither adj.
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;
    __GLaccumBuffer *afb;
    GLubyte dst_pix;
    __GLcolor *pAccumCol, *pac;
    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;

    ap = (GLuint *)ac;
    xFrag = x;
    yFrag = y;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + xScr)
                 : gengc->ColorsBits;
    pujEnd = puj + w;

    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum32Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no dithering, no masking
    //
    // Check for the common case (which we'll do the fastest).

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & COLORMASK_ON) )
    {
        //!!!XXX -- we can also opt. by unrolling the loops

        for ( ; puj < pujEnd; puj++, pac++ )
        {
            result = ((BYTE) FTOL(pac->r + __glHalf) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g + __glHalf) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b + __glHalf) << cfb->blueShift);
            *puj = gengc->pajTranslateVector[result];
        }
    }

    // Case: dithering, no masking, no blending
    //
    // Dithering is pretty common for 8-bit displays, so its probably
    // worth special case also.

    else if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        for ( ; puj < pujEnd; puj++, pac++, xFrag++)
        {
            inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

            result = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b + inc) << cfb->blueShift);
            *puj = gengc->pajTranslateVector[result];
        }
    }

    // Case: general
    //
    // Otherwise, we'll do it slower.

    else
    {
        // Color mask pre-fetch
        if ((cfb->buf.flags & COLORMASK_ON) && !bDIB) {
                (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE );
        }

        for ( ; puj < pujEnd; puj++, pac++ )
        {
            if (enables & __GL_DITHER_ENABLE)
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                inc = __glHalf;
            }
            result = ((BYTE)FTOL(pac->r + inc) << cfb->redShift) |
                     ((BYTE)FTOL(pac->g + inc) << cfb->greenShift) |
                     ((BYTE)FTOL(pac->b + inc) << cfb->blueShift);

            // Color mask
            if (cfb->buf.flags & COLORMASK_ON)
            {
                dst_pix = gengc->pajInvTranslateVector[*puj];
                result = (GLubyte)((dst_pix & cfb->destMask) |
                                   (result & cfb->sourceMask));
            }
            *puj = gengc->pajTranslateVector[result];

        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    // Store alpha values
    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

/******************************Public*Routine******************************\
* RGBReturnSpan
*   Reads from a 64-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void RGBReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                   const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLshort *ap;                    // current accum entry

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte *puj;                   // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;
    __GLaccumBuffer *afb;
    __GLcolor *pAccumCol, *pac;

    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    gengc = (__GLGENcontext *)gc;

    ap = (GLshort *)ac;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    puj = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr*3))
                 : gengc->ColorsBits;
    pujEnd = puj + w*3;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum64Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking

    if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        for ( ; puj < pujEnd; puj += 3, pac ++ )
        {
            puj[0] = (GLubyte) FTOL(pac->r);
            puj[1] = (GLubyte) FTOL(pac->g);
            puj[2] = (GLubyte) FTOL(pac->b);
        }
    }

    // All other cases
    else
    {
        GLboolean bRedMask, bGreenMask, bBlueMask;
        GLubyte *pujStart = puj;

        // Color mask pre-fetch
    	if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if( gc->state.raster.rMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->r);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.gMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->g);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.bMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->b);
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    // Store alpha values
    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

/******************************Public*Routine******************************\
* BGRReturnSpan
*   Reads from a 64-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void BGRReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                   const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLshort *ap;                    // current accum entry
    __GLcolor *pAccumCol, *pac;

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte *puj;                   // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;

    __GLfloat r, g, b;
    __GLfloat rval, gval, bval;
    __GLaccumBuffer *afb;

    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;
    gengc = (__GLGENcontext *)gc;

    ap = (GLshort *)ac;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    puj = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr*3))
                 : gengc->ColorsBits;
    pujEnd = puj + w*3;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum64Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking

    if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        for ( ; puj < pujEnd; puj += 3, pac ++ )
        {
            puj[0] = (GLubyte) FTOL(pac->b);
            puj[1] = (GLubyte) FTOL(pac->g);
            puj[2] = (GLubyte) FTOL(pac->r);
        }
    }

    // All other cases

    else
    {
        GLboolean bRedMask, bGreenMask, bBlueMask;
        GLubyte *pujStart = puj;

        // Color mask pre-fetch
    	if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if( gc->state.raster.bMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->b);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.gMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->g);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.rMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->r);
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    // Store alpha values
    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

/******************************Public*Routine******************************\
* Bitfield16ReturnSpan
*   Reads from a 32-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Bitfield16ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                          const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLuint *ap;                     // current accum entry

    GLint xFrag, yFrag;             // current fragment coordinates
    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLushort result, *pus;          // current pixel color, current pixel ptr
    GLushort *pusEnd;               // end of scan line
    __GLfloat inc;                  // current dither adj.
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;
    __GLcolor *pAccumCol, *pac;
    __GLaccumBuffer *afb;

    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    gengc = (__GLGENcontext *)gc;

    ap = (GLuint *)ac;
    xFrag = x;
    yFrag = y;
    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<1))
                 : gengc->ColorsBits;
    pusEnd = pus + w;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum32Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking, no dithering

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & COLORMASK_ON) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for ( ; pus < pusEnd; pus++, pac++ )
            {
                *pus = ((BYTE) FTOL(pac->r + __glHalf) << cfb->redShift) |
                       ((BYTE) FTOL(pac->g + __glHalf) << cfb->greenShift) |
                       ((BYTE) FTOL(pac->b + __glHalf) << cfb->blueShift) |
                       ((BYTE) FTOL(pac->a + __glHalf) << cfb->alphaShift);
            }
        } else {
            for ( ; pus < pusEnd; pus++, pac++ )
            {
                *pus = ((BYTE) FTOL(pac->r + __glHalf) << cfb->redShift) |
                       ((BYTE) FTOL(pac->g + __glHalf) << cfb->greenShift) |
                       ((BYTE) FTOL(pac->b + __glHalf) << cfb->blueShift);
            }
        }
    }

    // Case: dithering, no masking

    else if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for ( ; pus < pusEnd; pus++, pac++, xFrag++ )
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
    
                *pus   = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b + inc) << cfb->blueShift) |
                         ((BYTE) FTOL(pac->a + inc) << cfb->alphaShift);
            }
        } else {
            for ( ; pus < pusEnd; pus++, pac++, xFrag++ )
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
    
                *pus   = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b + inc) << cfb->blueShift);
            }
        }
    }

    // All other cases

    else
    {
        // Color mask pre-fetch
        if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        for ( ; pus < pusEnd; pus++, pac++ )
        {
            inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

        // Dither.

            if ( enables & __GL_DITHER_ENABLE )
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                inc = __glHalf;
            }

        // Convert color to 16BPP format.

            result = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b + inc) << cfb->blueShift);
            if( ALPHA_PIXEL_WRITE( cfb ) )
                result |= ((BYTE) FTOL(pac->a + inc) << cfb->alphaShift);

        // Store result with optional masking.

            *pus = (GLushort)((*pus & cfb->destMask) | (result & cfb->sourceMask));
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );

}

/******************************Public*Routine******************************\
* Bitfield32ReturnSpan
*   Reads from a 64-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Bitfield32ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                          const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLshort *ap;                    // current accum entry

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLuint result, *pul;            // current pixel color, current pixel ptr
    GLuint *pulEnd;                 // end of scan line

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;

    __GLfloat r, g, b;
    __GLfloat rval, gval, bval;
    __GLaccumBuffer *afb;
    __GLcolor *pAccumCol, *pac;
    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;
    gengc = (__GLGENcontext *)gc;

    ap = (GLshort *)ac;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<2))
                 : gengc->ColorsBits;
    pulEnd = pul + w;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum64Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking

    if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for ( ; pul < pulEnd; pul++, pac++ )
            {
                *pul   = ((BYTE) FTOL(pac->r) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b) << cfb->blueShift) |
                         ((BYTE) FTOL(pac->a) << cfb->alphaShift);
            }
        } else {
            for ( ; pul < pulEnd; pul++, pac++ )
            {
                *pul   = ((BYTE) FTOL(pac->r) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b) << cfb->blueShift);
            }
        }
    }

    // All other cases

    else
    {
        // Color mask pre-fetch
        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        for ( ; pul < pulEnd; pul++, pac++ )
        {
            result   = ((BYTE) FTOL(pac->r) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b) << cfb->blueShift);

            if( ALPHA_PIXEL_WRITE( cfb ) )
                result |= ((BYTE) FTOL(pac->a) << cfb->alphaShift);

            //!!!XXX again, opt. by unrolling loop
            *pul = (*pul & cfb->destMask) | (result & cfb->sourceMask);
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

STATIC void __glSetDrawBuffer(__GLcolorBuffer *cfb)
{

    DBGENTRY("__glSetDrawBuffer\n");
}

STATIC void setReadBuffer(__GLcolorBuffer *cfb)
{
    DBGENTRY("setReadBuffer\n");
}


/************************************************************************/

STATIC void Resize(__GLGENbuffers *buffers, __GLcolorBuffer *cfb,
                   GLint w, GLint h)
{

    DBGENTRY("Resize\n");

    cfb->buf.width = w;
    cfb->buf.height = h;
}

#define DBG_PICK    LEVEL_ENTRY

// Called at each validate (lots of times, whenever states change)
STATIC void FASTCALL PickRGB(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    __GLGENcontext *gengc;
    GLuint totalMask, sourceMask;
    GLboolean colormask;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLuint enables = gc->state.enables.general;

    sourceMask = 0;
    colormask = GL_FALSE;
    if (gc->state.raster.rMask) {
        sourceMask |= gc->modes.redMask;
    }
    if (gc->state.raster.gMask) {
        sourceMask |= gc->modes.greenMask;
    }
    if (gc->state.raster.bMask) {
        sourceMask |= gc->modes.blueMask;
    }

    totalMask = gc->modes.redMask | gc->modes.greenMask | gc->modes.blueMask;

    gengc = (__GLGENcontext *)gc;

    // If we have alpha bits, need to determine where they belong : for a 
    // generic pixel format, they live in the software alpha buffer, but for
    // an mcd type context they will be on the mcd device (or ALPHA_IN_PIXEL ).
    // This is used by all the 'slow' store/fetch procs.

    if( gc->modes.alphaBits && gengc->pMcdState ) {
        // Set bit in buf.flags indicating alpha is in the pixel
        cfb->buf.flags = cfb->buf.flags | ALPHA_IN_PIXEL_BIT;
    } else {
        // Alpha is not in the pixel, or there is no alpha
        cfb->buf.flags = cfb->buf.flags & ~ALPHA_IN_PIXEL_BIT;
    }

    if( ALPHA_IN_PIXEL( cfb ) ) {
        // There are alpha bits in the pixels, so need to include alpha in mask
        if (gc->state.raster.aMask) {
            sourceMask |= gc->modes.alphaMask;
        }
        totalMask |= gc->modes.alphaMask;
    }

    if (sourceMask == totalMask) {
        cfb->buf.flags = cfb->buf.flags & ~COLORMASK_ON;
    } else {
        cfb->buf.flags = cfb->buf.flags | COLORMASK_ON;
    }
    cfb->sourceMask = sourceMask;
    cfb->destMask = totalMask & ~sourceMask;

    // Determine whether writing alpha values is required
    if( gc->modes.alphaBits && gc->state.raster.aMask )
        cfb->buf.flags = cfb->buf.flags | ALPHA_ON;
    else
        cfb->buf.flags = cfb->buf.flags & ~ALPHA_ON;

    // If we're doing a logic op or there is a color mask we'll need
    // to fetch the destination value before we write
    if ((enables & __GL_COLOR_LOGIC_OP_ENABLE) ||
        (cfb->buf.flags & COLORMASK_ON))
    {
        cfb->buf.flags = cfb->buf.flags | NEED_FETCH;
    }
    else
        cfb->buf.flags = cfb->buf.flags & ~NEED_FETCH;

    // Figure out store routines
    if (gc->state.raster.drawBuffer == GL_NONE) {
        cfb->store = Store_NOT;
        cfb->fetch = RGBFetchNone;
        cfb->readSpan = RGBReadSpanNone;
        cfb->storeSpan = StoreSpanNone;
        cfb->storeStippledSpan = StoreSpanNone;
    } else {
        pfmt = &gengc->gsurf.pfd;

        // Pick functions that work for both DIB and Display formats

        switch(pfmt->cColorBits) {
        case 4:
            cfb->clear = Index4Clear;
            cfb->returnSpan = Index4ReturnSpan;
            break;
        case 8:
            cfb->storeSpan = Index8StoreSpan;
            cfb->readSpan = Index8RGBAReadSpan;
            cfb->returnSpan = Index8ReturnSpan;
            cfb->clear = Index8Clear;
            break;
        case 16:
            cfb->storeSpan = Bitfield16StoreSpan;
            cfb->readSpan = Bitfield16RGBAReadSpan;
            cfb->returnSpan = Bitfield16ReturnSpan;
            cfb->clear = Bitfield16Clear;
            break;
        case 24:
            if (cfb->redShift == 16)
            {
                cfb->storeSpan = BGRStoreSpan;
                cfb->readSpan = BGRAReadSpan;
                cfb->returnSpan = BGRReturnSpan;
            } else {
                // XXX why no RGBStoreSpan ?
                cfb->readSpan = RGBAReadSpan;
                cfb->returnSpan = RGBReturnSpan;
            }
            cfb->clear = RGBClear;
            break;
        case 32:
            cfb->storeSpan = Bitfield32StoreSpan;
            cfb->readSpan = Bitfield32RGBAReadSpan;
            cfb->returnSpan = Bitfield32ReturnSpan;
            cfb->clear = Bitfield32Clear;
            break;
        }

        // Pick specific functions for DIB or Display formats

        if (cfb->buf.flags & DIB_FORMAT) {

            switch(pfmt->cColorBits) {

            case 4:
                DBGLEVEL(DBG_PICK, "DIBIndex4Store\n");
                cfb->store = DIBIndex4Store;
                cfb->fetch = DIBIndex4RGBAFetch;
                cfb->readSpan = DIBIndex4RGBAReadSpan;
                break;

            case 8:
                DBGLEVEL(DBG_PICK, "DIBIndex8Store, "
                                   "Index8StoreSpan\n");
                cfb->store = DIBIndex8Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DIBIndex8RGBAFetch;
                else
                    cfb->fetch = DIBIndex8RGBFetch;
                break;

            case 16:
                DBGLEVEL(DBG_PICK, "DIBBitfield16Store\n");
                cfb->store = DIBBitfield16Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DIBBitfield16RGBAFetch;
                else
                    cfb->fetch = DIBBitfield16RGBFetch;
                break;

            case 24:
                if (cfb->redShift == 16)
                {
                    DBGLEVEL(DBG_PICK, "DIBBGRStore\n");
                    cfb->store = DIBBGRStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DIBBGRAFetch;
                    else
                        cfb->fetch = DIBBGRFetch;
                }
                else
                {
                    DBGLEVEL(DBG_PICK, "DIBRGBStore\n");
                    cfb->store = DIBRGBAStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DIBRGBAFetch;
                    else
                        cfb->fetch = DIBRGBFetch;
                }
                break;

            case 32:
                DBGLEVEL(DBG_PICK, "DIBBitfield32Store, "
                                   "Bitfield32StoreSpan\n");
                cfb->store = DIBBitfield32Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DIBBitfield32RGBAFetch;
                else
                    cfb->fetch = DIBBitfield32RGBFetch;
                break;

            }
        } else {
            switch(pfmt->cColorBits) {

            case 4:
                DBGLEVEL(DBG_PICK, "DisplayIndex4Store\n");
                cfb->store = DisplayIndex4Store;
                cfb->fetch = DisplayIndex4RGBAFetch;
                cfb->readSpan = DisplayIndex4RGBAReadSpan;
                break;

            case 8:
                DBGLEVEL(DBG_PICK, "DisplayIndex8Store, "
                                   "Index8StoreSpan\n");
                cfb->store = DisplayIndex8Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DisplayIndex8RGBAFetch;
                else
                    cfb->fetch = DisplayIndex8RGBFetch;
                break;

            case 16:
                DBGLEVEL(DBG_PICK, "DisplayBitfield16Store\n");
                cfb->store = DisplayBitfield16Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DisplayBitfield16RGBAFetch;
                else
                    cfb->fetch = DisplayBitfield16RGBFetch;
                break;

            case 24:
                // Must be RGB or BGR
                if (cfb->redShift == 16)
                {
                    DBGLEVEL(DBG_PICK, "DisplayBGRStore\n");
                    cfb->store = DisplayBGRStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DisplayBGRAFetch;
                    else
                        cfb->fetch = DisplayBGRFetch;
                }
                else
                {
                    DBGLEVEL(DBG_PICK, "DisplayRGBStore\n");
                    cfb->store = DisplayRGBStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DisplayRGBAFetch;
                    else
                        cfb->fetch = DisplayRGBFetch;
                }
                break;

            case 32:
                DBGLEVEL(DBG_PICK, "DisplayBitfield32Store, "
                                   "Bitfield32StoreSpan\n");
                cfb->store = DisplayBitfield32Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DisplayBitfield32RGBAFetch;
                else
                    cfb->fetch = DisplayBitfield32RGBFetch;
                break;
            }
        }
        // cfb->readColor is the same as cfb->fetch (so why do we need it ?)
        cfb->readColor = cfb->fetch;

        // If we are only writing alpha (rgb all masked), can further optimize:
        // Don't bother if logicOp or blending are enabled, and only if we
        // have a software alpha buffer
        if( gc->modes.alphaBits && 
            ! ALPHA_IN_PIXEL( cfb ) && 
            (sourceMask == 0) && 
            gc->state.raster.aMask &&
            !(enables & __GL_COLOR_LOGIC_OP_ENABLE) &&
            ! (enables & __GL_BLEND_ENABLE) ) 
        {
            cfb->store = AlphaStore;
            cfb->storeSpan = AlphaStoreSpan;
        }
    }
}

/************************************************************************/

void FASTCALL __glGenFreeRGB(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    DBGENTRY("__glGenFreeRGB\n");
}

/************************************************************************/

// Note: this used to be defined in generic\genrgb.h
#define __GL_GENRGB_COMPONENT_SCALE_ALPHA       255

// called at makecurrent time
// need to get info out of pixel format structure
void FASTCALL __glGenInitRGB(__GLcontext *gc, __GLcolorBuffer *cfb, GLenum type)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;

    __glInitGenericCB(gc, cfb);

    cfb->redMax      = (1 << gc->modes.redBits) - 1;
    cfb->greenMax    = (1 << gc->modes.greenBits) - 1;
    cfb->blueMax     = (1 << gc->modes.blueBits) - 1;

    gc->redVertexScale   = cfb->redScale    = (__GLfloat)cfb->redMax;
    gc->greenVertexScale = cfb->greenScale  = (__GLfloat)cfb->greenMax;
    gc->blueVertexScale  = cfb->blueScale   = (__GLfloat)cfb->blueMax;

    cfb->iRedScale   = cfb->redMax;
    cfb->iGreenScale = cfb->greenMax;
    cfb->iBlueScale  = cfb->blueMax;

    // Do any initialization related to alpha
    if( gc->modes.alphaBits ) {
        cfb->alphaMax        = (1 << gc->modes.alphaBits) - 1;
        cfb->iAlphaScale     = cfb->alphaMax;
        gc->alphaVertexScale = cfb->alphaScale  = (__GLfloat)cfb->alphaMax;
        // Initialize the software alpha buffer.  Actually, we may not need to
        // do this, since if an mcd pixel format supports alpha, we don't need
        // the software alpha buffer.  But this is the most convenient place to
        // do it, and no memory will be allocated anyways. just function ptrs
        // initialized.
        __glInitAlpha( gc, cfb ); 
    } else {
        cfb->alphaMax    = __GL_GENRGB_COMPONENT_SCALE_ALPHA;
        cfb->iAlphaScale = __GL_GENRGB_COMPONENT_SCALE_ALPHA;
        gc->alphaVertexScale = cfb->alphaScale  = (__GLfloat)cfb->redMax;
    }

    cfb->buf.elementSize = sizeof(GLubyte);     // XXX needed?

    cfb->pick              = PickRGB;           // called at each validate
    cfb->resize            = Resize;
    cfb->fetchSpan         = __glFetchSpan;
    cfb->fetchStippledSpan = __glFetchSpan;
    cfb->storeSpan         = SlowStoreSpan;
    cfb->storeStippledSpan = SlowStoreStippledSpan;

    pfmt = &gengc->gsurf.pfd;

    cfb->redShift = pfmt->cRedShift;
    cfb->greenShift = pfmt->cGreenShift;
    cfb->blueShift = pfmt->cBlueShift;
    cfb->alphaShift = pfmt->cAlphaShift;

    glGenInitCommon(gengc, cfb, type);

    DBGLEVEL3(LEVEL_INFO,"GeninitRGB: redMax %d, greenMax %d, blueMax %d\n",
        cfb->redMax, cfb->greenMax, cfb->blueMax);
    DBGLEVEL3(LEVEL_INFO,"    redShift %d, greenShift %d, blueShift %d\n",
        cfb->redShift, cfb->greenShift, cfb->blueShift);
    DBGLEVEL2(LEVEL_INFO,"    dwFlags %X, cColorBits %d\n",
        gengc->dwCurrentFlags, pfmt->cColorBits);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genspan.c ===
/******************************Module*Header*******************************\
* Module Name: genspan.c                                                   *
*                                                                          *
* This module accelerates common spans.                                    *
*                                                                          *
* Created: 24-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*******************************************************/

void FASTCALL __fastGenDeltaSpan(__GLcontext *gc, SPANREC *spanDelta)
{
    GLuint modeflags = gc->polygon.shader.modeFlags;
    GENACCEL *pGenAccel = (GENACCEL *)(((__GLGENcontext *)gc)->pPrivateArea);

    if (modeflags & __GL_SHADE_RGB) {
        if ((modeflags & __GL_SHADE_TEXTURE) && (pGenAccel->texImage)) {
            if (modeflags & __GL_SHADE_SMOOTH) {
                pGenAccel->spanDelta.r = spanDelta->r;
                pGenAccel->spanDelta.g = spanDelta->g;
                pGenAccel->spanDelta.b = spanDelta->b;
            } else {
                pGenAccel->spanDelta.r = 0;
                pGenAccel->spanDelta.g = 0;
                pGenAccel->spanDelta.b = 0;
            }
            pGenAccel->spanDelta.s = spanDelta->s;
            pGenAccel->spanDelta.t = spanDelta->t;

            pGenAccel->__fastSpanFuncPtr = pGenAccel->__fastTexSpanFuncPtr;

        } else if (modeflags & __GL_SHADE_SMOOTH) {
            if (   ((spanDelta->r | spanDelta->g | spanDelta->b) == 0)
                && ((pGenAccel->flags & GEN_FASTZBUFFER) == 0)
               ) {
                pGenAccel->spanDelta.r = 0;
                pGenAccel->spanDelta.g = 0;
                pGenAccel->spanDelta.b = 0;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastFlatSpanFuncPtr;
            } else {
                pGenAccel->spanDelta.r = spanDelta->r;
                pGenAccel->spanDelta.g = spanDelta->g;
                pGenAccel->spanDelta.b = spanDelta->b;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastSmoothSpanFuncPtr;
            }                
        } else {
            pGenAccel->__fastSpanFuncPtr = pGenAccel->__fastFlatSpanFuncPtr;
        } 
    } else {
        if (modeflags & __GL_SHADE_SMOOTH) {
            if (spanDelta->r == 0) {
                pGenAccel->spanDelta.r = 0;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastFlatSpanFuncPtr;
            } else {
                pGenAccel->spanDelta.r = spanDelta->r;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastSmoothSpanFuncPtr;
            }                
        } else {
            pGenAccel->__fastSpanFuncPtr = pGenAccel->__fastFlatSpanFuncPtr;
        } 
    }

#ifdef LATER
    pGenAccel->spanDelta.r = spanDelta->r;
    pGenAccel->spanDelta.g = spanDelta->g;
    pGenAccel->spanDelta.b = spanDelta->b;
    pGenAccel->spanDelta.s = spanDelta->s;
    pGenAccel->spanDelta.t = spanDelta->t;
    if (  modeflags & (__GL_SHADE_RGB | __GL_SHADE_TEXTURE | __GL_SHADE_SMOOTH) ==
          __GL_SHADE_RGB | __GL_SHADE_TEXTURE
       ) {
        pGenAccel->spanDelta.r = 0;
        pGenAccel->spanDelta.g = 0;
        pGenAccel->spanDelta.b = 0;
    } else
    if (  modeflags & (__GL_SHADE_RGB | __GL_SHADE_TEXTURE | __GL_SHADE_SMOOTH) ==
          __GL_SHADE_RGB | __GL_SHADE_SMOOTH
       ) {
        if ((spanDelta->r | spanDelta->g | spanDelta->b) == 0) {
            pGenAccel->__fastSpanFuncPtr =
                pGenAccel->__fastFlatSpanFuncPtr;
        } else {
            pGenAccel->__fastSpanFuncPtr =
                pGenAccel->__fastSmoothSpanFuncPtr;
        }
    }
#endif
}

/*******************************************************/

#define ZBUF_PROC(type, pass_cond) \
GLboolean FASTCALL __fastGenDepthTestSpan##type(__GLcontext *gc)\
{\
    register GLuint zAccum = gc->polygon.shader.frag.z;\
    register GLint zDelta = gc->polygon.shader.dzdx;\
    register GLuint *zbuf = gc->polygon.shader.zbuf;\
    register GLuint *pStipple = gc->polygon.shader.stipplePat;\
    register GLint cTotalPix = gc->polygon.shader.length;\
    register GLuint mask;\
    register GLint cPix;\
    register GLint zPasses = 0;\
    register GLuint maskBit;\
\
    for (;cTotalPix > 0; cTotalPix-=32) {\
        mask = 0;\
        maskBit = 0x80000000;\
        cPix = cTotalPix;\
        if (cPix > 32)\
            cPix = 32;\
\
        for (;cPix > 0; cPix --) {\
            if ((zAccum) pass_cond (*zbuf)) {\
                *zbuf = zAccum;\
                zPasses++;\
                mask |= maskBit;\
            }\
            *zbuf++;\
            zAccum += zDelta;\
            maskBit >>= 1;\
        }\
\
        *pStipple++ = mask;\
    }\
\
    if (zPasses == 0) {\
        gc->polygon.shader.done = TRUE;\
        return 1;\
    } else if (zPasses == gc->polygon.shader.length) {\
        return 0;\
    } else {\
        return 2;\
    }\
}

#define ZBUF16_PROC(type, pass_cond) \
GLboolean FASTCALL __fastGenDepth16TestSpan##type(__GLcontext *gc)\
{\
    register GLuint zAccum = gc->polygon.shader.frag.z;\
    register __GLz16Value z16Accum = (__GLz16Value) (zAccum >> Z16_SHIFT); \
    register GLint zDelta = gc->polygon.shader.dzdx;\
    register __GLz16Value *zbuf = (__GLz16Value *) (gc->polygon.shader.zbuf);\
    register GLuint *pStipple = gc->polygon.shader.stipplePat;\
    register GLint cTotalPix = gc->polygon.shader.length;\
    register GLuint mask;\
    register GLint cPix;\
    register GLint zPasses = 0;\
    register GLuint maskBit;\
\
    for (;cTotalPix > 0; cTotalPix-=32) {\
        mask = 0;\
        maskBit = 0x80000000;\
        cPix = cTotalPix;\
        if (cPix > 32)\
            cPix = 32;\
        \
        for (;cPix > 0; cPix --) {\
            if (((__GLz16Value)(zAccum >> Z16_SHIFT)) pass_cond (*zbuf)) {\
                *zbuf = ((__GLz16Value)(zAccum >> Z16_SHIFT));\
                zPasses++;\
                mask |= maskBit;\
            }\
            *zbuf++;\
            zAccum += zDelta;\
            maskBit >>= 1;\
        }\
\
        *pStipple++ = mask;\
    }\
\
    if (zPasses == 0) {\
        gc->polygon.shader.done = TRUE;\
        return 1;\
    } else if (zPasses == gc->polygon.shader.length) {\
        return 0;\
    } else {\
        return 2;\
    }\
}


ZBUF_PROC(LT, <);

ZBUF_PROC(EQ, ==);

ZBUF_PROC(LE, <=);

ZBUF_PROC(GT, >);

ZBUF_PROC(NE, !=);

ZBUF_PROC(GE, >=);

ZBUF_PROC(ALWAYS, || TRUE ||);

GLboolean FASTCALL __fastGenDepthTestSpanNEVER(__GLcontext *gc)
{
    return FALSE;
}

ZBUF16_PROC(LT, <);

ZBUF16_PROC(EQ, ==);

ZBUF16_PROC(LE, <=);

ZBUF16_PROC(GT, >);

ZBUF16_PROC(NE, !=);

ZBUF16_PROC(GE, >=);

ZBUF16_PROC(ALWAYS, || TRUE ||);

/*******************************************************/

__GLspanFunc __fastDepthFuncs[] =
    {__fastGenDepthTestSpanNEVER,
     __fastGenDepthTestSpanLT,
     __fastGenDepthTestSpanEQ,
     __fastGenDepthTestSpanLE,
     __fastGenDepthTestSpanGT,
     __fastGenDepthTestSpanNE,
     __fastGenDepthTestSpanGE,
     __fastGenDepthTestSpanALWAYS
    };

__GLspanFunc __fastDepth16Funcs[] =
    {__fastGenDepthTestSpanNEVER,
     __fastGenDepth16TestSpanLT,
     __fastGenDepth16TestSpanEQ,
     __fastGenDepth16TestSpanLE,
     __fastGenDepth16TestSpanGT,
     __fastGenDepth16TestSpanNE,
     __fastGenDepth16TestSpanGE,
     __fastGenDepth16TestSpanALWAYS
    };

/*******************************************************/

DWORD ditherShade[32] = {
    0x0800,
    0x8800,
    0x2800,
    0xa800,
    0x0800,
    0x8800,
    0x2800,
    0xa800,

    0xc800,
    0x4800,
    0xe800,
    0x6800,
    0xc800,
    0x4800,
    0xe800,
    0x6800,

    0x3800,
    0xb800,
    0x1800,
    0x9800,
    0x3800,
    0xb800,
    0x1800,
    0x9800,

    0xf800,
    0x7800,
    0xd800,
    0x5800,
    0xf800,
    0x7800,
    0xd800,
    0x5800,
};

DWORD ditherTexture[32] = {
    0x08,
    0x88,
    0x28,
    0xa8,
    0x08,
    0x88,
    0x28,
    0xa8,

    0xc8,
    0x48,
    0xe8,
    0x68,
    0xc8,
    0x48,
    0xe8,
    0x68,

    0x38,
    0xb8,
    0x18,
    0x98,
    0x38,
    0xb8,
    0x18,
    0x98,

    0xf8,
    0x78,
    0xd8,
    0x58,
    0xf8,
    0x78,
    0xd8,
    0x58,
};

static ULONG Dither_4x4[4] = {0xa8288808, 0x68e848c8, 0x9818b838, 0x58d878f8};

/*******************************************************/

#define STRCAT4R(s1, s2, s3, s4) s1 ## s2 ## s3 ## s4
#define STRCAT4(s1, s2, s3, s4) STRCAT4R(s1, s2, s3, s4)

#define STRCAT3R(s1, s2, s3) s1 ## s2 ## s3
#define STRCAT3(s1, s2, s3) STRCAT3R(s1, s2, s3)

#define STRCAT2R(s1, s2) s1 ## s2
#define STRCAT2(s1, s2) STRCAT2R(s1, s2)

/*******************************************************/

//
// create the generic span routine
//

#define GENERIC 1
#define ZBUFFER 1
#define RGBMODE 1
#define SHADE   1
#define DITHER  1
#define TEXTURE 1
#define BPP bpp

#include "span.h"

#undef GENERIC
#define GENERIC 0

/*******************************************************/

//
// now create the special case span routines
//

//
// first modes that are dithered
//

#undef DITHER
#define DITHER 1

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     332
#undef BPP
#define BPP		8

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2

#include "spanset.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     555
#undef BPP
#define BPP		16

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5

#include "spanset.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     565
#undef BPP
#define BPP		16

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5

#include "spanset.h"

/*******************************************************/

//
// undithered modes
//

#undef  DITHER
#define DITHER 0

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     24
#undef BPP
#define BPP		24

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          16
#define GSHIFT          8
#define BSHIFT          0
#define RBITS		8
#define GBITS		8
#define BBITS		8


#include "spanset.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     32
#undef BPP
#define BPP		32

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          16
#define GSHIFT          8
#define BSHIFT          0
#define RBITS		8
#define GBITS		8
#define BBITS		8

#include "spanset.h"

/*******************************************************/

#ifndef _X86_

//
// Create span routines for perspective-corrected textures
//

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define BPP             8

#define FAST_REPLACE 1
#include "texspans.h"
#undef FAST_REPLACE

#define SKIP_FAST_REPLACE 1
#define REPLACE 1
#include "texspans.h"
#undef REPLACE
#undef SKIP_FAST_REPLACE

#define FAST_REPLACE 1
#define PALETTE_ONLY 1
#include "texspans.h"
#undef FAST_REPLACE
#undef PALETTE_ONLY

#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define BPP             16

#define SKIP_FAST_REPLACE 1
#define REPLACE 1
#include "texspans.h"
#undef REPLACE
#undef SKIP_FAST_REPLACE

#define SKIP_FAST_REPLACE 1     // only need routines for alpha modes, since
#define FAST_REPLACE 1          // replace is identical otherwise with 565
#define PALETTE_ONLY 1
#include "texspans.h"
#undef FAST_REPLACE
#undef PALETTE_ONLY
#undef SKIP_FAST_REPLACE

#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define BPP             16

#define FAST_REPLACE 1
#include "texspans.h"
#undef FAST_REPLACE

#define SKIP_FAST_REPLACE 1
#define REPLACE 1
#include "texspans.h"
#undef REPLACE
#undef SKIP_FAST_REPLACE

#define FAST_REPLACE 1
#define PALETTE_ONLY 1
#include "texspans.h"
#undef FAST_REPLACE
#undef PALETTE_ONLY

#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          16
#define GSHIFT          8
#define BSHIFT          0
#define RBITS		8
#define GBITS		8
#define BBITS		8
#define BPP             32

#define REPLACE 1
#include "texspans.h"
#undef REPLACE

#define REPLACE 1
#define PALETTE_ONLY 1
#include "texspans.h"
#undef REPLACE
#undef PALETTE_ONLY


#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED

#endif  // _X86_


/*******************************************************/

//
// finally color index and flat spans
//

#undef TEXTURE
#undef SHADE
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     8
#undef BPP
#define BPP		8

#include "spanci.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     16
#undef BPP
#define BPP		16

#include "spanci.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     24
#undef BPP
#define BPP		24

#include "spanci.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     32
#undef BPP
#define BPP		32

#include "spanci.h"

/*******************************************************/

__genSpanFunc __fastGenRGBFlatFuncs[] =
    {
     __fastGenRGB24FlatSpan,
     __fastGenRGB32FlatSpan,
     __fastGenRGB8FlatSpan,
     __fastGenRGB16FlatSpan,
     __fastGenRGB16FlatSpan,

     __fastGenRGB24FlatSpan,
     __fastGenRGB32FlatSpan,
     __fastGenRGB8DithFlatSpan,
     __fastGenRGB16DithFlatSpan,
     __fastGenRGB16DithFlatSpan,

     __fastGenMaskRGB24FlatSpan,
     __fastGenMaskRGB32FlatSpan,
     __fastGenMaskRGB8FlatSpan,
     __fastGenMaskRGB16FlatSpan,
     __fastGenMaskRGB16FlatSpan,

     __fastGenMaskRGB24FlatSpan,
     __fastGenMaskRGB32FlatSpan,
     __fastGenMaskRGB8DithFlatSpan,
     __fastGenMaskRGB16DithFlatSpan,
     __fastGenMaskRGB16DithFlatSpan,
    };

__genSpanFunc __fastGenCIFlatFuncs[] =
    {
     __fastGenCI24FlatSpan,
     __fastGenCI32FlatSpan,
     __fastGenCI8FlatSpan,
     __fastGenCI16FlatSpan,
     __fastGenCI16FlatSpan,

     __fastGenCI24DithFlatSpan,
     __fastGenCI32DithFlatSpan,
     __fastGenCI8DithFlatSpan,
     __fastGenCI16DithFlatSpan,
     __fastGenCI16DithFlatSpan,

     __fastGenMaskCI24FlatSpan,
     __fastGenMaskCI32FlatSpan,
     __fastGenMaskCI8FlatSpan,
     __fastGenMaskCI16FlatSpan,
     __fastGenMaskCI16FlatSpan,

     __fastGenMaskCI24DithFlatSpan,
     __fastGenMaskCI32DithFlatSpan,
     __fastGenMaskCI8DithFlatSpan,
     __fastGenMaskCI16DithFlatSpan,
     __fastGenMaskCI16DithFlatSpan,
    };


__genSpanFunc __fastGenCIFuncs[] =
    {
     __fastGenCI24Span,
     __fastGenCI32Span,
     __fastGenCI8Span,
     __fastGenCI16Span,
     __fastGenCI16Span,

     __fastGenCI24DithSpan,
     __fastGenCI32DithSpan,
     __fastGenCI8DithSpan,
     __fastGenCI16DithSpan,
     __fastGenCI16DithSpan,

     __fastGenMaskCI24Span,
     __fastGenMaskCI32Span,
     __fastGenMaskCI8Span,
     __fastGenMaskCI16Span,
     __fastGenMaskCI16Span,

     __fastGenMaskCI24DithSpan,
     __fastGenMaskCI32DithSpan,
     __fastGenMaskCI8DithSpan,
     __fastGenMaskCI16DithSpan,
     __fastGenMaskCI16DithSpan,
    };

__genSpanFunc __fastGenRGBFuncs[] =
    {
     __fastGenRGB24Span,
     __fastGenRGB32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenRGB24Span,
     __fastGenRGB32Span,
     __fastGenRGB332DithSpan,
     __fastGenRGB555DithSpan,
     __fastGenRGB565DithSpan,

     __fastGenMaskRGB24Span,
     __fastGenMaskRGB32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenMaskRGB24Span,
     __fastGenMaskRGB32Span,
     __fastGenMaskRGB332DithSpan,
     __fastGenMaskRGB555DithSpan,
     __fastGenMaskRGB565DithSpan,
    };

__genSpanFunc __fastGenTexDecalFuncs[] =
    {
     __fastGenTexDecal24Span,
     __fastGenTexDecal32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenTexDecal24Span,
     __fastGenTexDecal32Span,
     __fastGenTexDecal332DithSpan,
     __fastGenTexDecal555DithSpan,
     __fastGenTexDecal565DithSpan,

     __fastGenMaskTexDecal24Span,
     __fastGenMaskTexDecal32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenMaskTexDecal24Span,
     __fastGenMaskTexDecal32Span,
     __fastGenMaskTexDecal332DithSpan,
     __fastGenMaskTexDecal555DithSpan,
     __fastGenMaskTexDecal565DithSpan,
    };

__genSpanFunc __fastGenTexFuncs[] =
    {
     __fastGenTex24Span,
     __fastGenTex32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenTex24Span,
     __fastGenTex32Span,
     __fastGenTex332DithSpan,
     __fastGenTex555DithSpan,
     __fastGenTex565DithSpan,

     __fastGenMaskTex24Span,
     __fastGenMaskTex32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenMaskTex24Span,
     __fastGenMaskTex32Span,
     __fastGenMaskTex332DithSpan,
     __fastGenMaskTex555DithSpan,
     __fastGenMaskTex565DithSpan,
    };


void FASTCALL __fastFastPerspReplace332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZlt332(__GLGENcontext *gc);

// Note the the compressed 555 and 565 formats are equivalent, so
// we'll just use the 565 version:

void FASTCALL __fastFastPerspReplace565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZlt565(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastPerspReplace332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspReplace555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspReplace565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspReplace888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt888(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastFastPerspPalReplace332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZlt332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlpha332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZlt332(__GLGENcontext *gc);

// Note the the compressed 555 and 565 formats are equivalent, so
// we'll just use the 565 version:

void FASTCALL __fastFastPerspPalReplace565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZlt565(__GLGENcontext *gc);

// With alpha, we have to provode pixel-format-specific code for 555 and
// 565, since there is a potential read-modify-write for which we will
// have to deal with the pixel format...

void FASTCALL __fastFastPerspPalReplaceAlpha555(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZlt555(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlpha565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZlt565(__GLGENcontext *gc);


void FASTCALL __fastPerspPalReplace332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspPalReplace555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspPalReplace565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspPalReplace888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt888(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastPerspFlat332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspFlat555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspFlat565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspFlat888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt888(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastPerspSmooth332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspSmooth555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspSmooth565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspSmooth888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt888(__GLGENcontext *gc);


__genSpanFunc __fastPerspTexReplaceFuncs[] = {

    __fastFastPerspReplace332,
    __fastFastPerspReplaceZle332,
    __fastFastPerspReplaceZlt332,
    __fastPerspReplaceAlpha332,
    __fastPerspReplaceAlphaZle332,
    __fastPerspReplaceAlphaZlt332,

    __fastFastPerspReplace565,
    __fastFastPerspReplaceZle565,
    __fastFastPerspReplaceZlt565,
    __fastPerspReplaceAlpha555,
    __fastPerspReplaceAlphaZle555,
    __fastPerspReplaceAlphaZlt555,

    __fastFastPerspReplace565,
    __fastFastPerspReplaceZle565,
    __fastFastPerspReplaceZlt565,
    __fastPerspReplaceAlpha565,
    __fastPerspReplaceAlphaZle565,
    __fastPerspReplaceAlphaZlt565,

    __fastPerspReplace888,
    __fastPerspReplaceZle888,
    __fastPerspReplaceZlt888,
    __fastPerspReplaceAlpha888,
    __fastPerspReplaceAlphaZle888,
    __fastPerspReplaceAlphaZlt888,
   
};

__genSpanFunc __fastPerspTexPalReplaceFuncs[] = {

    __fastFastPerspPalReplace332,
    __fastFastPerspPalReplaceZle332,
    __fastFastPerspPalReplaceZlt332,
    __fastFastPerspPalReplaceAlpha332,
    __fastFastPerspPalReplaceAlphaZle332,
    __fastFastPerspPalReplaceAlphaZlt332,

    __fastFastPerspPalReplace565,
    __fastFastPerspPalReplaceZle565,
    __fastFastPerspPalReplaceZlt565,
    __fastFastPerspPalReplaceAlpha555,
    __fastFastPerspPalReplaceAlphaZle555,
    __fastFastPerspPalReplaceAlphaZlt555,

    __fastFastPerspPalReplace565,
    __fastFastPerspPalReplaceZle565,
    __fastFastPerspPalReplaceZlt565,
    __fastFastPerspPalReplaceAlpha565,
    __fastFastPerspPalReplaceAlphaZle565,
    __fastFastPerspPalReplaceAlphaZlt565,

    __fastPerspPalReplace888,
    __fastPerspPalReplaceZle888,
    __fastPerspPalReplaceZlt888,
    __fastPerspPalReplaceAlpha888,
    __fastPerspPalReplaceAlphaZle888,
    __fastPerspPalReplaceAlphaZlt888,
   
};

__genSpanFunc __fastPerspTexFlatFuncs[] = {

    __fastPerspFlat332,
    __fastPerspFlatZle332,
    __fastPerspFlatZlt332,
    __fastPerspFlatAlpha332,
    __fastPerspFlatAlphaZle332,
    __fastPerspFlatAlphaZlt332,

    __fastPerspFlat555,
    __fastPerspFlatZle555,
    __fastPerspFlatZlt555,
    __fastPerspFlatAlpha555,
    __fastPerspFlatAlphaZle555,
    __fastPerspFlatAlphaZlt555,

    __fastPerspFlat565,
    __fastPerspFlatZle565,
    __fastPerspFlatZlt565,
    __fastPerspFlatAlpha565,
    __fastPerspFlatAlphaZle565,
    __fastPerspFlatAlphaZlt565,

    __fastPerspFlat888,
    __fastPerspFlatZle888,
    __fastPerspFlatZlt888,
    __fastPerspFlatAlpha888,
    __fastPerspFlatAlphaZle888,
    __fastPerspFlatAlphaZlt888,
   
};

__genSpanFunc __fastPerspTexSmoothFuncs[] = {

    __fastPerspSmooth332,
    __fastPerspSmoothZle332,
    __fastPerspSmoothZlt332,
    __fastPerspSmoothAlpha332,
    __fastPerspSmoothAlphaZle332,
    __fastPerspSmoothAlphaZlt332,

    __fastPerspSmooth555,
    __fastPerspSmoothZle555,
    __fastPerspSmoothZlt555,
    __fastPerspSmoothAlpha555,
    __fastPerspSmoothAlphaZle555,
    __fastPerspSmoothAlphaZlt555,

    __fastPerspSmooth565,
    __fastPerspSmoothZle565,
    __fastPerspSmoothZlt565,
    __fastPerspSmoothAlpha565,
    __fastPerspSmoothAlphaZle565,
    __fastPerspSmoothAlphaZlt565,

    __fastPerspSmooth888,
    __fastPerspSmoothZle888,
    __fastPerspSmoothZlt888,
    __fastPerspSmoothAlpha888,
    __fastPerspSmoothAlphaZle888,
    __fastPerspSmoothAlphaZlt888,
};

/*******************************************************/

GLboolean FASTCALL __fastGenStippleLt32Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register GLint zDelta = gc->polygon.shader.dzdx;
    register GLuint *zbuf = gc->polygon.shader.zbuf;
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    if (gc->constants.yInverted) {
	stipple = gc->polygon.stipple[(gc->constants.height - 
		(gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
		& (__GL_STIPPLE_BITS-1)];
    } else {
	stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
		(__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
	/* No point in continuing */
	return GL_FALSE;
    }
    
    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if ((zAccum) < (*zbuf))
                {
                    *zbuf = zAccum;
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}

GLboolean FASTCALL __fastGenStippleLt16Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register __GLz16Value z16Accum = (__GLz16Value) (zAccum >> Z16_SHIFT);
    register GLint zDelta = gc->polygon.shader.dzdx;
    register __GLz16Value *zbuf = (__GLz16Value *) (gc->polygon.shader.zbuf);
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    if (gc->constants.yInverted) {
	stipple = gc->polygon.stipple[(gc->constants.height - 
		(gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
		& (__GL_STIPPLE_BITS-1)];
    } else {
	stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
		(__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
	/* No point in continuing */
	return GL_FALSE;
    }
    
    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if (((__GLz16Value)(zAccum >> Z16_SHIFT)) < (*zbuf))
                {
                    *zbuf = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}

GLboolean FASTCALL __fastGenStippleAnyDepthTestSpan(__GLcontext *gc)
{
    // If the shader is done after this routine then
    // the stipple pattern is all zeroes so we can
    // skip the span
    __glStippleSpan(gc);
    if (gc->polygon.shader.done)
    {
        return GL_FALSE;
    }
                
    // If this returns true then all bits are off so
    // we can skip the span
    return !__glDepthTestStippledSpan(gc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

PUBLICINCS= $(SDK_INC_PATH)\gl\gl.h

PRIVATEINCS= ..\inc\types.h     \
             ..\inc\render.h    \
             ..\inc\buffers.h   \
             ..\inc\context.h   \
             ..\inc\attrib.h    \
             ..\inc\vertex.h    \
             ..\inc\xform.h     \
             ..\inc\procs.h     \
             ..\inc\pixel.h     \
             ..\inc\texture.h   \
             ..\inc\lighting.h  \
             ..\..\inc\parray.h \
             ..\inc\gencx.h

GLTGT = $(NTTARGETFILE0)

!if $(AMD64) || $(IA64)

#
# For AMD64 and IA64  use the M4 method of include file generation.
#

$(TARGET_DIRECTORY)\glconst.c: $(TARGET_DIRECTORY)\glconst.m4
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) < $** > $@

$(GLTGT):                                               \
                $(TARGET_DIRECTORY)\glconst.c           \
		$(PUBLICINCS)                           \
		$(PRIVATEINCS)                          \
		$(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
    -md $(_OBJ_DIR)\$(TARGET_DIRECTORY)
    nmake $(_OBJ_DIR)\$(TARGET_DIRECTORY)\glconst.obj USE_MSVCRT=1 NTNOPCH=1 NTDEBUG=ntsdnodbg FORCENATIVEOBJECT=1
    genxx $(_OBJ_DIR)\$(TARGET_DIRECTORY)\glconst.obj -s$(ASM_INCLUDE_SUFFIX) -o$@

!else

$(GLTGT):                                                          \
               $(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).c         \
               $(PUBLICINCS)                                       \
               $(PRIVATEINCS)
    set PASS0ONLY=
    nmake $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).obj USE_MSVCRT=1 NTNOPCH=1 $(HOST_TARGET_DEFINES) $(HOST_TOOLS) NTDEBUG=ntsdnodbg
    -link -out:$(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).exe @<<
-machine:$(HOST_TARGETCPU)
-base:@$(COFFBASE_TXT_FILE),usermode
-subsystem:console
-entry:mainCRTStartup
-nodefaultlib
-ignore:4078
-force
$(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).obj
$(SDK_LIB_DEST)\$(HOST_TARGETCPU)\msvcrt.lib
$(SDK_LIB_DEST)\$(HOST_TARGETCPU)\kernel32.lib
$(PERFLIBS)
<<
    -$(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).exe $@
    -erase $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).obj
    -erase $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).exe

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\mcdcx.c ===
/******************************Module*Header*******************************\
* Module Name: mcdcx.c
*
* GenMcdXXX layer between generic software implementation and MCD functions.
*
* Created: 05-Feb-1996 21:37:33
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef _MCD_

/******************************Public*Routine******************************\
* bInitMcd
*
* Load MCD32.DLL and initialize the MCD api function table.
*
* History:
*  11-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

MCDTABLE *gpMcdTable = (MCDTABLE *) NULL;
MCDTABLE McdTable;
MCDDRIVERINFOI McdDriverInfo;

// Checks MCD version to see if the driver can accept direct buffer
// access.  Direct access was introduced in 1.1.
#define SUPPORTS_DIRECT() \
    (McdDriverInfo.mcdDriverInfo.verMinor >= 0x10 || \
     McdDriverInfo.mcdDriverInfo.verMajor > 1)

// Checks MCD version for 2.0 or greater
#define SUPPORTS_20() \
    (McdDriverInfo.mcdDriverInfo.verMajor >= 2)

static char *pszMcdEntryPoints[] = {
    "MCDGetDriverInfo",
    "MCDDescribeMcdPixelFormat",
    "MCDDescribePixelFormat",
    "MCDCreateContext",
    "MCDDeleteContext",
    "MCDAlloc",
    "MCDFree",
    "MCDBeginState",
    "MCDFlushState",
    "MCDAddState",
    "MCDAddStateStruct",
    "MCDSetViewport",
    "MCDSetScissorRect",
    "MCDQueryMemStatus",
    "MCDProcessBatch",
    "MCDReadSpan",
    "MCDWriteSpan",
    "MCDClear",
    "MCDSwap",
    "MCDGetBuffers",
    "MCDAllocBuffers",
    "MCDLock",
    "MCDUnlock",
    "MCDBindContext",
    "MCDSync",
    "MCDCreateTexture",
    "MCDDeleteTexture",
    "MCDUpdateSubTexture",
    "MCDUpdateTexturePalette",
    "MCDUpdateTexturePriority",
    "MCDUpdateTextureState",
    "MCDTextureStatus",
    "MCDTextureKey",
    "MCDDescribeMcdLayerPlane",
    "MCDDescribeLayerPlane",
    "MCDSetLayerPalette",
    "MCDDrawPixels",
    "MCDReadPixels",
    "MCDCopyPixels",
    "MCDPixelMap",
    "MCDDestroyWindow",
    "MCDGetTextureFormats",
    "MCDSwapMultiple",
    "MCDProcessBatch2"
};
#define NUM_MCD_ENTRY_POINTS    (sizeof(pszMcdEntryPoints)/sizeof(char *))

#define STR_MCD32_DLL   "MCD32.DLL"

BOOL FASTCALL bInitMcd(HDC hdc)
{
    static BOOL bFirstTime = TRUE;

    ASSERTOPENGL(NUM_MCD_ENTRY_POINTS == sizeof(MCDTABLE)/sizeof(void *),
                 "MCD entry points mismatch\n");
    //
    // Note on multi-threaded initialization.
    //
    // Since the table memory exists in global memory and the pointer to
    // the table is always set to point to this, it doesn't matter if multiple
    // thread attempt to run the initialization routine.  The worse that
    // could happen is that we set the table multiple times.
    //

    if (bFirstTime && (gpMcdTable == (MCDTABLE *) NULL))
    {
        HMODULE hmod;
        PROC *ppfn;

        //
        // Attempt the load once and once only.  Otherwise application
        // initialization time could be significantly slowed if MCD32.DLL
        // does not exist.
        //
        // We could have attempted this in the DLL entry point in responce
        // to PROCESS_ATTACH, but then we might end up wasting working set
        // if MCD is never used.
        //
        // So instead we control the load attempt with this static flag.
        //

        bFirstTime = FALSE;

        hmod = LoadLibraryA(STR_MCD32_DLL);

        if (hmod)
        {
            MCDTABLE McdTableLocal;
            BOOL bLoadFailed = FALSE;
            BOOL bDriverValid = FALSE;
            int i;

            //
            // Get address for each of the MCD entry points.
            //
            // To be multi-thread safe, we store the pointers in a local
            // table.  Only after the *entire* table is successfully
            // initialized can we copy it to the global table.
            //

            ppfn = (PROC *) &McdTableLocal.pMCDGetDriverInfo;
            for (i = 0; i < NUM_MCD_ENTRY_POINTS; i++, ppfn++)
            {
                *ppfn = GetProcAddress(hmod, pszMcdEntryPoints[i]);

                if (!*ppfn)
                {
                    WARNING1("bInitMcd: missing entry point %s\n", pszMcdEntryPoints[i]);
                    bLoadFailed = TRUE;
                }
            }

            //
            // If all entry points successfully loaded, validate driver
            // by checking the MCDDRIVERINFO.
            //

            if (!bLoadFailed)
            {
                if ((McdTableLocal.pMCDGetDriverInfo)(hdc, &McdDriverInfo))
                {
                    //
                    // Validate MCD driver version, etc.
                    //

                    //!!!mcd -- what other types of validation can we do?
#ifdef ALLOW_NEW_MCD
                    if ((McdDriverInfo.mcdDriverInfo.verMajor == 1 &&
                         (McdDriverInfo.mcdDriverInfo.verMinor == 0 ||
                          McdDriverInfo.mcdDriverInfo.verMinor == 0x10)) ||
                        (McdDriverInfo.mcdDriverInfo.verMajor == 2 &&
                         McdDriverInfo.mcdDriverInfo.verMinor == 0))
#else
                    if (McdDriverInfo.mcdDriverInfo.verMajor == 1 &&
                        McdDriverInfo.mcdDriverInfo.verMinor == 0)
#endif
                    {
                        bDriverValid = TRUE;
                    }
                    else
                    {
                        WARNING("bInitMcd: bad version\n");
                    }
                }
            }

            //
            // It is now safe to call MCD entry points via the table.  Copy
            // local copy to the global table and set the global pointer.
            //

            if (bDriverValid)
            {
                McdTable   = McdTableLocal;
                gpMcdTable = &McdTable;
            }
            else
            {
                WARNING1("bInitMcd: unloading %s\n", STR_MCD32_DLL);
                FreeLibrary(hmod);
            }
        }
    }

    return (gpMcdTable != (MCDTABLE *) NULL);
}

/******************************Public*Routine******************************\
* vFlushDirtyState
*
* GENMCDSTATE maintains a set of dirty flags to track state changes.
* This function updates the MCD driver state that is marked dirty.
* The dirty flags are consequently cleared.
*
* History:
*  07-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FASTCALL vFlushDirtyState(__GLGENcontext *gengc)
{
    if (gengc->pMcdState)
    {
        //
        // Viewport, scissor, and texture each have separate update
        // functions/structures.  Check the dirty flags and update
        // these first.
        //

        if (MCD_STATE_DIRTYTEST(gengc, VIEWPORT))
        {
            GenMcdViewport(gengc);
            MCD_STATE_CLEAR(gengc, VIEWPORT);
        }

        if (MCD_STATE_DIRTYTEST(gengc, SCISSOR))
        {
            GenMcdScissor(gengc);

            //
            // DO NOT CLEAR.  Scissor is passed in two forms: a direct call
            // that affects clipping in MCDSRV32.DLL and a state call that
            // the MCD driver can optionally use for high performance h/w.
            // We need to leave the flag set so that the state call will
            // also be processed.
            //
            //MCD_STATE_CLEAR(gengc, SCISSOR);
        }

        if (MCD_STATE_DIRTYTEST(gengc, TEXTURE))
        {
            if (gengc->gc.texture.currentTexture)
            {
                __GLtextureObject *texobj;

                if (gengc->gc.state.enables.general & __GL_TEXTURE_2D_ENABLE)
                    texobj = __glLookUpTextureObject(&gengc->gc, GL_TEXTURE_2D);
                else if (gengc->gc.state.enables.general & __GL_TEXTURE_1D_ENABLE)
                    texobj = __glLookUpTextureObject(&gengc->gc, GL_TEXTURE_1D);
                else
                    texobj = (__GLtextureObject *) NULL;

                if (texobj && texobj->loadKey)
                {
                    ASSERTOPENGL(&texobj->texture.map == gengc->gc.texture.currentTexture,
                                 "vFlushDirtyState: texobj not current texture\n");

                    GenMcdUpdateTextureState(gengc,
                                             &texobj->texture.map,
                                             texobj->loadKey);
                    MCD_STATE_CLEAR(gengc, TEXTURE);
                }
            }
        }

        //
        // Take care of the other state.
        //

        if (MCD_STATE_DIRTYTEST(gengc, ALL))
        {
            //
            // Setup state command.
            //

            (gpMcdTable->pMCDBeginState)(&gengc->pMcdState->McdContext,
                                         gengc->pMcdState->McdCmdBatch.pv);

            //
            // Add MCDPIXELSTATE structure to state command if needed.
            //

            if (MCD_STATE_DIRTYTEST(gengc, PIXELSTATE))
            {
                GenMcdUpdatePixelState(gengc);
            }

            if (gengc->pMcdState->McdRcInfo.requestFlags &
                MCDRCINFO_FINE_GRAINED_STATE)
            {
                // Add front-end and rendering states.
                GenMcdUpdateFineState(gengc);
            }
            else
            {
                //
                // Add MCDRENDERSTATE structure to state command if needed.
                //

                if (MCD_STATE_DIRTYTEST(gengc, RENDERSTATE))
                {
                    GenMcdUpdateRenderState(gengc);
                }
            }

            //
            // Add MCDSCISSORSTATE structure to state command if needed.
            //

            if (MCD_STATE_DIRTYTEST(gengc, SCISSOR))
            {
                GenMcdUpdateScissorState(gengc);
            }

            //
            // Add MCDTEXENVSTATE structure to state command if needed.
            //

            if (MCD_STATE_DIRTYTEST(gengc, TEXENV))
            {
                GenMcdUpdateTexEnvState(gengc);
            }

            //
            // Send state command to MCD driver.
            //

            (gpMcdTable->pMCDFlushState)(gengc->pMcdState->McdCmdBatch.pv);

            //
            // Clear dirty flags.
            //

            MCD_STATE_RESET(gengc);
        }
    }
}

/******************************Public*Routine******************************\
* vInitPolyArrayBuffer
*
* Initialize the POLYARRAY/POLYDATA buffer pointed to by pdBuf.
*
* History:
*  12-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FASTCALL vInitPolyArrayBuffer(__GLcontext *gc, POLYDATA *pdBuf,
                                   UINT pdBufSizeBytes, UINT pdBufSize)
{
    UINT i;
    POLYDATA *pdBufSAVE;
    GLuint   pdBufSizeBytesSAVE;
    GLuint   pdBufSizeSAVE;

    //
    // Save current polyarray buffer.  We are going to temporarily
    // replace the current one with the new one for the purposes
    // of initializing the buffer.  However, it is too early to
    // replace the current polyarray.  The higher level code will
    // figure that out later.
    //

    pdBufSAVE          = gc->vertex.pdBuf;
    pdBufSizeBytesSAVE = gc->vertex.pdBufSizeBytes;
    pdBufSizeSAVE      = gc->vertex.pdBufSize;

    //
    // Set polyarray buffer to memory allocated by MCD.
    //

    gc->vertex.pdBuf          = pdBuf;
    gc->vertex.pdBufSizeBytes = pdBufSizeBytes;
    gc->vertex.pdBufSize      = pdBufSize;

    //
    // Initialize the vertex buffer.
    //

    PolyArrayResetBuffer(gc);

    //
    // Restore the polyarray buffer.
    //

    gc->vertex.pdBuf          = pdBufSAVE;
    gc->vertex.pdBufSizeBytes = pdBufSizeBytesSAVE;
    gc->vertex.pdBufSize      = pdBufSizeSAVE;
}

/******************************Public*Routine******************************\
* GenMcdSetScaling
*
* Set up the various scale values needed for MCD or generic operation.
*
* This should be called when toggling between accelerated/non-accelerated
* operation.
*
* Returns:
*   None.
*
* History:
*  03-May-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

VOID FASTCALL GenMcdSetScaling(__GLGENcontext *gengc)
{
    __GLcontext *gc = (__GLcontext *)gengc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    __GLviewport *vp = &gc->state.viewport;
    double scale;

    //
    // If we're using MCD, set up the desired scale value:
    //

    if (pMcdState) {
        if (pMcdState->McdRcInfo.requestFlags & MCDRCINFO_DEVZSCALE)
            gengc->genAccel.zDevScale = pMcdState->McdRcInfo.zScale;
        else
            gengc->genAccel.zDevScale = pMcdState->McdRcInfo.depthBufferMax;
    } else if (gengc->_pMcdState)
        gengc->genAccel.zDevScale = gengc->_pMcdState->McdRcInfo.depthBufferMax;
        
    if (pMcdState)
        scale = gengc->genAccel.zDevScale * __glHalf;
    else
        scale = gc->depthBuffer.scale * __glHalf;
    gc->state.viewport.zScale = (__GLfloat)((vp->zFar - vp->zNear) * scale);
    gc->state.viewport.zCenter = (__GLfloat)((vp->zFar + vp->zNear) * scale);

    if (pMcdState && pMcdState->McdRcInfo.requestFlags & MCDRCINFO_NOVIEWPORTADJUST) {
        gc->constants.viewportXAdjust = 0;
        gc->constants.viewportYAdjust = 0;
        gc->constants.fviewportXAdjust = (__GLfloat)0.0;
        gc->constants.fviewportYAdjust = (__GLfloat)0.0;
    } else {
        gc->constants.viewportXAdjust = __GL_VERTEX_X_BIAS + __GL_VERTEX_X_FIX;
        gc->constants.viewportYAdjust = __GL_VERTEX_Y_BIAS + __GL_VERTEX_Y_FIX;
        gc->constants.fviewportXAdjust = (__GLfloat)gc->constants.viewportXAdjust;
        gc->constants.fviewportYAdjust = (__GLfloat)gc->constants.viewportYAdjust;
    }

    //
    // The inverses for these are set in __glContextSetColorScales which is
    // called on each MakeCurrent:
    //

    if (pMcdState && pMcdState->McdRcInfo.requestFlags & MCDRCINFO_DEVCOLORSCALE) {
        gc->redVertexScale   = pMcdState->McdRcInfo.redScale;
        gc->greenVertexScale = pMcdState->McdRcInfo.greenScale;
        gc->blueVertexScale  = pMcdState->McdRcInfo.blueScale;
        gc->alphaVertexScale = pMcdState->McdRcInfo.alphaScale;
    } else {
        if (gc->modes.colorIndexMode) {
            gc->redVertexScale   = (MCDFLOAT)1.0;
            gc->greenVertexScale = (MCDFLOAT)1.0;
            gc->blueVertexScale  = (MCDFLOAT)1.0;
            gc->alphaVertexScale = (MCDFLOAT)1.0;
        } else {
            gc->redVertexScale   = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
            gc->greenVertexScale = (MCDFLOAT)((1 << gc->modes.greenBits) - 1);
            gc->blueVertexScale  = (MCDFLOAT)((1 << gc->modes.blueBits) - 1);
            if( gc->modes.alphaBits )
                gc->alphaVertexScale = (MCDFLOAT)((1 << gc->modes.alphaBits) - 1);
            else
                gc->alphaVertexScale = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
        }
    }

    gc->redClampTable[1] = gc->redVertexScale;
    gc->redClampTable[2] = (__GLfloat)0.0;
    gc->redClampTable[3] = (__GLfloat)0.0;
    gc->greenClampTable[1] = gc->greenVertexScale;
    gc->greenClampTable[2] = (__GLfloat)0.0;
    gc->greenClampTable[3] = (__GLfloat)0.0;
    gc->blueClampTable[1] = gc->blueVertexScale;
    gc->blueClampTable[2] = (__GLfloat)0.0;
    gc->blueClampTable[3] = (__GLfloat)0.0;
    gc->alphaClampTable[1] = gc->alphaVertexScale;
    gc->alphaClampTable[2] = (__GLfloat)0.0;
    gc->alphaClampTable[3] = (__GLfloat)0.0;

    if (pMcdState && pMcdState->McdRcInfo.requestFlags & MCDRCINFO_Y_LOWER_LEFT) {
        gc->constants.yInverted = GL_FALSE;
        gc->constants.ySign = 1;
    } else {
        gc->constants.yInverted = GL_TRUE;
        gc->constants.ySign = -1;
    }

}

/******************************Public*Routine******************************\
*
* McdPixelFormatFromPfd
*
* Fills out an MCDPIXELFORMAT from a PIXELFORMATDESCRIPTOR
*
* History:
*  Mon Sep 16 14:51:42 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

VOID FASTCALL McdPixelFormatFromPfd(PIXELFORMATDESCRIPTOR *pfd,
                                    MCDPIXELFORMAT *mpf)
{
    mpf->nSize = sizeof(MCDPIXELFORMAT);
    mpf->dwFlags = pfd->dwFlags & (PFD_DOUBLEBUFFER |
                                   PFD_NEED_PALETTE |
                                   PFD_NEED_SYSTEM_PALETTE |
                                   PFD_SWAP_EXCHANGE |
                                   PFD_SWAP_COPY |
                                   PFD_SWAP_LAYER_BUFFERS);
    mpf->iPixelType = pfd->iPixelType;
    mpf->cColorBits = pfd->cColorBits;
    mpf->cRedBits = pfd->cRedBits;
    mpf->cRedShift = pfd->cRedShift;
    mpf->cGreenBits = pfd->cGreenBits;
    mpf->cGreenShift = pfd->cGreenShift;
    mpf->cBlueBits = pfd->cBlueBits;
    mpf->cBlueShift = pfd->cBlueShift;
    mpf->cAlphaBits = pfd->cAlphaBits;
    mpf->cAlphaShift = pfd->cAlphaShift;
    mpf->cDepthBits = pfd->cDepthBits;
    mpf->cDepthShift = 0;
    mpf->cDepthBufferBits = pfd->cDepthBits;
    mpf->cStencilBits = pfd->cStencilBits;
    mpf->cOverlayPlanes = pfd->bReserved & 0xf;
    mpf->cUnderlayPlanes = pfd->bReserved >> 4;
    mpf->dwTransparentColor = pfd->dwVisibleMask;
}

/******************************Public*Routine******************************\
* GenMcdResetViewportAdj
*
* If an MCD driver that specifies MCDRCINFO_NOVIEWPORTADJUST kicks back
* for simulations, we need to change the viewport adjust values from
* 0, 0 back to the default values in order to run the software
* implementation.
*
* If biasType is VP_FIXBIAS, this function will set the viewport adjust
* values to their software default.
*
* If biasType is VP_NOBIAS, this function will set the viewport adjust
* values to zero.
*
* Returns:
*   TRUE is viewport is set, FALSE otherwise.
*
* Note:
*   The main reason for returning a BOOL is so that caller can check if
*   VP_FIXBIAS succeeds.  If it does, it needs to reset values back to
*   VP_NOBIAS.
*
*   Also note that it is safe for non-MCD and MCD that does not set
*   MCDRCINFO_NOVIEWPORTADJUST to call this function.  This function
*   will do nothing in these situations and will return FALSE.
*
* History:
*  22-May-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdResetViewportAdj(__GLcontext *gc, VP_BIAS_TYPE biasType)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    BOOL bRet = FALSE;

    if (gengc->pMcdState &&
        (gengc->pMcdState->McdRcInfo.requestFlags & MCDRCINFO_NOVIEWPORTADJUST))
    {
        switch (biasType)
        {
            case VP_FIXBIAS:
                if (gc->constants.viewportXAdjust == 0)
                {
                    //
                    // The state of viewportYAdjust should match
                    // viewportXAdjust.  If not, the test should be
                    // changed (perhaps state flag in the context to
                    // track biasing).
                    //

                    ASSERTOPENGL((gc->constants.viewportYAdjust == 0),
                                 "GenMcdResetViewportAdj: "
                                 "viewportYAdjust not zero\n");

                    gc->constants.viewportXAdjust = __GL_VERTEX_X_BIAS +
                                                    __GL_VERTEX_X_FIX;
                    gc->constants.viewportYAdjust = __GL_VERTEX_Y_BIAS +
                                                    __GL_VERTEX_Y_FIX;
                    gc->constants.fviewportXAdjust = (__GLfloat)gc->constants.viewportXAdjust;
                    gc->constants.fviewportYAdjust = (__GLfloat)gc->constants.viewportYAdjust;

                    //
                    // Apply new bias to the rasterPos.
                    //

                    gc->state.current.rasterPos.window.x += gc->constants.fviewportXAdjust;
                    gc->state.current.rasterPos.window.y += gc->constants.fviewportYAdjust;
                }
                bRet = TRUE;
                break;

            case VP_NOBIAS:
                if (gc->constants.viewportXAdjust != 0)
                {
                    //
                    // The state of viewportYAdjust should match
                    // viewportXAdjust.  If not, the test should be
                    // changed (perhaps state flag in the context to
                    // track biasing).
                    //

                    ASSERTOPENGL((gc->constants.viewportYAdjust != 0),
                                 "GenMcdResetViewportAdj: "
                                 "viewportYAdjust zero\n");

                    //
                    // Remove bias from the rasterPos before resetting.
                    //

                    gc->state.current.rasterPos.window.x -= gc->constants.fviewportXAdjust;
                    gc->state.current.rasterPos.window.y -= gc->constants.fviewportYAdjust;

                    gc->constants.viewportXAdjust = 0;
                    gc->constants.viewportYAdjust = 0;
                    gc->constants.fviewportXAdjust = (__GLfloat)0.0;
                    gc->constants.fviewportYAdjust = (__GLfloat)0.0;
                }
                bRet = TRUE;
                break;

            default:
                DBGPRINT("GenMcdResetViewportAdj: unknown type\n");
                break;
        }

        if (bRet)
        {
            __GLbeginMode beginMode = gc->beginMode;

            //
            // Why save/restore beginMode?
            //
            // Because we are playing around with the viewport values,
            // ApplyViewport may inadvertently set beginMode to
            // __GL_NEED_VALIDATE even though we will later restore the
            // original viewport values.  This can confuse glim_DrawPolyArray
            // which plays around with the beginMode settings.
            //

            __glUpdateViewport(gc);
            (gc->procs.applyViewport)(gc);
            __glUpdateViewportDependents(gc);

            gc->beginMode = beginMode;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bInitMcdContext
*
* Allocate and initialize the GENMCDSTATE structure.  Create MCD context
* and shared memory buffers used to pass vertex arrays, commands, and state.
*
* This state exists per-context.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*   In addition, the gengc->pMcdState is valid IFF successful.
*
* History:
*  05-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL bInitMcdContext(__GLGENcontext *gengc, GLGENwindow *pwnd)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = (GENMCDSTATE *) NULL;
    ULONG ulBytes;
    UINT  nVertices;
    UINT  pdBufSize;
    POLYDATA *pd;
    DWORD dwFlags;
    MCDRCINFOPRIV mriPriv;

    //
    // This functions cannot assume MCD entry point table is already
    // initialized.
    //

    if (!bInitMcd(gengc->gsurf.hdc))
    {
        goto bInitMcdContext_exit;
    }

    //
    // Fail if not an MCD pixelformat.
    //

    if (!(gengc->gsurf.pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        goto bInitMcdContext_exit;
    }

    //
    // Allocate memory for our MCD state.
    //

    pMcdState = (GENMCDSTATE *)ALLOCZ(sizeof(*gengc->pMcdState));

    if (pMcdState)
    {
        //
        // Create an MCD context.
        //

        //
        // Pickup viewportXAdjust and viewportYAdjust from the constants section
        // of the gc.
        //

        pMcdState->McdRcInfo.viewportXAdjust = gengc->gc.constants.viewportXAdjust;
        pMcdState->McdRcInfo.viewportYAdjust = gengc->gc.constants.viewportYAdjust;

        if (!gengc->gsurf.pfd.cDepthBits || (gengc->gsurf.pfd.cDepthBits >= 32))
            pMcdState->McdRcInfo.depthBufferMax = ~((ULONG)0);
        else
            pMcdState->McdRcInfo.depthBufferMax = (1 << gengc->gsurf.pfd.cDepthBits) - 1;

        //!!!
        //!!! This is broken since we can't use the full z-buffer range!
        //!!!

        pMcdState->McdRcInfo.depthBufferMax >>= 1;

        pMcdState->McdRcInfo.zScale = (MCDDOUBLE)pMcdState->McdRcInfo.depthBufferMax;

        //
        // This is also computed by initCi/initRGB, but this function
        // is called before the color buffers are initialized:
        //

        if (gc->modes.colorIndexMode)
        {
            pMcdState->McdRcInfo.redScale   = (MCDFLOAT)1.0;
            pMcdState->McdRcInfo.greenScale = (MCDFLOAT)1.0;
            pMcdState->McdRcInfo.blueScale  = (MCDFLOAT)1.0;
            pMcdState->McdRcInfo.alphaScale = (MCDFLOAT)1.0;
        }
        else
        {
            pMcdState->McdRcInfo.redScale   = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
            pMcdState->McdRcInfo.greenScale = (MCDFLOAT)((1 << gc->modes.greenBits) - 1);
            pMcdState->McdRcInfo.blueScale  = (MCDFLOAT)((1 << gc->modes.blueBits) - 1);
            pMcdState->McdRcInfo.alphaScale = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
        }

        dwFlags = 0;
            
        // Consider - Extract clipper-associated hwnds?  Whole clipping
	// scheme is broken until clipper data can be accessed in kernel.
        if ((gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW) == 0)
        {
            dwFlags |= MCDSURFACE_HWND;
        }
        else
        {
            // Cache kernel-mode surface handles for DirectDraw
            // This must occur before the call to MCDCreateContext
            pMcdState->hDdColor = (HANDLE)
                ((LPDDRAWI_DDRAWSURFACE_INT)gengc->gsurf.dd.gddsFront.pdds)->
                lpLcl->hDDSurface;
            if (gengc->gsurf.dd.gddsZ.pdds != NULL)
            {
                pMcdState->hDdDepth = (HANDLE)
                    ((LPDDRAWI_DDRAWSURFACE_INT)gengc->gsurf.dd.gddsZ.pdds)->
                    lpLcl->hDDSurface;
            }
        }

        if (SUPPORTS_DIRECT())
        {
            dwFlags |= MCDSURFACE_DIRECT;
        }
        
        mriPriv.mri = pMcdState->McdRcInfo;
        if (!(gpMcdTable->pMCDCreateContext)(&pMcdState->McdContext,
                                             &mriPriv,
                                             &gengc->gsurf,
                                             pwnd->ipfd - pwnd->ipfdDevMax,
                                             dwFlags))
        {
            WARNING("bInitMcdContext: MCDCreateContext failed\n");
            goto bInitMcdContext_exit;
        }

        pMcdState->McdRcInfo = mriPriv.mri;
        
        //
        // Get MCDPIXELFORMAT and cache in GENMCDSTATE.
        //

        if (gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW)
        {
            McdPixelFormatFromPfd(&gengc->gsurf.pfd, &pMcdState->McdPixelFmt);
        }
        else if (!(gpMcdTable->pMCDDescribeMcdPixelFormat)
                 (gengc->gsurf.hdc,
                  pwnd->ipfd - pwnd->ipfdDevMax,
                  &pMcdState->McdPixelFmt))
        {
            WARNING("bInitMcdContext: MCDDescribeMcdPixelFormat failed\n");
            goto bInitMcdContext_exit;
        }

        //
        // Allocate cmd/state buffer.
        //

        //!!!mcd -- How much memory should be allocated for cmd buffer?
        //!!!mcd    Use a page (4K) for now...
        ulBytes = 4096;
        pMcdState->McdCmdBatch.size = ulBytes;
        pMcdState->McdCmdBatch.pv =
            (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext, ulBytes,
                                    &pMcdState->McdCmdBatch.hmem, 0);

        if (!pMcdState->McdCmdBatch.pv)
        {
            WARNING("bInitMcdContext: state buf MCDAlloc failed\n");
            goto bInitMcdContext_exit;
        }

        //
        // Determine size of vertex buffer we should use with MCD driver.
        // This is calculated by taking the size the MCD driver requests
        // and computing the number of POLYDATA structure that will fit.
        // If the result is less than the minimum size required by the
        // generic software implementation, bump it up to the minimum.
        //

        ulBytes = McdDriverInfo.mcdDriverInfo.drvBatchMemSizeMax;
        nVertices = ulBytes / sizeof(POLYDATA);

        if (nVertices < MINIMUM_POLYDATA_BUFFER_SIZE)
        {
            ulBytes = MINIMUM_POLYDATA_BUFFER_SIZE * sizeof(POLYDATA);
            nVertices = MINIMUM_POLYDATA_BUFFER_SIZE;
        }

        //
        // Only n-1 vertices are used for the buffer.  The "extra" is
        // reserved for use by the polyarray code (see PolyArrayAllocBuf
        // in so_prim.c).
        //

        pdBufSize = nVertices - 1;

        //
        // Allocate vertex buffers.
        //

        if (McdDriverInfo.mcdDriverInfo.drvMemFlags & MCDRV_MEM_DMA)
        {
            pMcdState->McdBuf2.size = ulBytes;
            pMcdState->McdBuf2.pv =
                (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext, ulBytes,
                                        &pMcdState->McdBuf2.hmem, 0);

            if (pMcdState->McdBuf2.pv)
            {
                //
                // Configure memory buffer as a POLYDATA buffer.
                //

                vInitPolyArrayBuffer(gc, (POLYDATA *) pMcdState->McdBuf2.pv,
                                     ulBytes, pdBufSize);
            }
            else
            {
                WARNING("bInitMcdContext: 2nd MCDAlloc failed\n");
                goto bInitMcdContext_exit;
            }
        }

        pMcdState->McdBuf1.size = ulBytes;
        pMcdState->McdBuf1.pv =
            (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext, ulBytes,
                                    &pMcdState->McdBuf1.hmem, 0);

        if (pMcdState->McdBuf1.pv)
        {
            pMcdState->pMcdPrimBatch = &pMcdState->McdBuf1;

            //
            // Configure memory buffer as a POLYDATA buffer.
            //

            vInitPolyArrayBuffer(gc, (POLYDATA *) pMcdState->McdBuf1.pv,
                                 ulBytes, pdBufSize);

            //
            // Free current poly array buffer.
            //
            // If we fail after this, we must call PolyArrayAllocBuffer to
            // restore the poly array buffer.  Luckily, at this point we
            // are guaranteed not fail.
            //

            PolyArrayFreeBuffer(gc);

            //
            // Set poly array buffer to memory allocated by MCD.
            //

            gc->vertex.pdBuf = (POLYDATA *) pMcdState->pMcdPrimBatch->pv;
            gc->vertex.pdBufSizeBytes = ulBytes;
            gc->vertex.pdBufSize = pdBufSize;
        }
        else
        {
            WARNING("bInitMcdContext: MCDAlloc failed\n");
            goto bInitMcdContext_exit;
        }

        if (pwnd->dwMcdWindow == 0)
        {
            //
            // Save MCD server-side window handle in the GENwindow
            //

            pwnd->dwMcdWindow = mriPriv.dwMcdWindow;
        }
        else
        {
            ASSERTOPENGL(pwnd->dwMcdWindow == mriPriv.dwMcdWindow,
                         "dwMcdWindow mismatch\n");
        }

        //
        // Finally, success.
        //

        bRet = TRUE;
    }

bInitMcdContext_exit:

    //
    // If function failed, cleanup allocated resources.
    //

    if (!bRet)
    {
        if (pMcdState)
        {
            if (pMcdState->McdBuf1.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf1.pv);
            }

            if (pMcdState->McdBuf2.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf2.pv);
            }

            if (pMcdState->McdCmdBatch.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdCmdBatch.pv);
            }

            if (pMcdState->McdContext.hMCDContext)
            {
                (gpMcdTable->pMCDDeleteContext)(&pMcdState->McdContext);
            }

            FREE(pMcdState);
        }
        gengc->_pMcdState = (GENMCDSTATE *) NULL;
    }
    else
    {
        gengc->_pMcdState = pMcdState;

        //
        // For generic formats, the depth resolution (i.e., number of
        // active depth bits) and the depth "pixel stride" are the same.
        // So GetContextModes, which sets modes.depthBits, can use the
        // PIXELFORMATDESCRIPTOR.cDepthBits for generic pixel formats.
        //
        // However, these two quantities can differ for MCD, so we need
        // to set it to cDepthBufferBits once we know that this is an
        // MCD context.
        //

        if (gengc->_pMcdState)
            gengc->gc.modes.depthBits = gengc->_pMcdState->McdPixelFmt.cDepthBufferBits;
    }

    gengc->pMcdState = (GENMCDSTATE *) NULL;

    return bRet;
}

/******************************Public*Routine******************************\
* bInitMcdSurface
*
* Allocate and initialize the GENMCDSURFACE structure.  This includes
* creating shared span buffers to read/write the MCD front, back and depth
* buffers.
*
* The MCDBUFFERS structure, which describes the location of the MCD buffers
* (if directly accessible), is left zero-initialized.  The contents of this
* structure are only valid when the screen lock is held and must be reset each
* time direct screen access is started.
*
* This function, if successful, will also bind the MCD context to the MCD
* surface.
*
* This state exists per-window.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*   In addition, the gengc->pMcdState is valid IFF successful.
*
* History:
*  05-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL bInitMcdSurface(__GLGENcontext *gengc, GLGENwindow *pwnd,
                              __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf = (GENMCDSURFACE *) NULL;
    ULONG ulBytes;
    UINT  nVertices;
    POLYDATA *pd;

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "bInitMcdSurface: mcd32.dll not initialized\n");

    //
    // Fail if no MCD context.
    //

    if (!(pMcdState = gengc->_pMcdState))
    {
        goto bInitMcdSurface_exit;
    }

    //
    // Allocate memory for our MCD surface.
    //

    pMcdSurf = (GENMCDSURFACE *)ALLOCZ(sizeof(*buffers->pMcdSurf));

    if (pMcdSurf)
    {
        //
        // Remember the window this surface is bound to.
        //

        pMcdSurf->pwnd = pwnd;

        //
        // Allocate scanline depth buffer.  Used to read/write depth buffer
        // spans.
        //

        if (pMcdState->McdPixelFmt.cDepthBits)
        {
            pMcdSurf->McdDepthBuf.size =
                MCD_MAX_SCANLINE * ((pMcdState->McdPixelFmt.cDepthBufferBits + 7) >> 3);
            pMcdSurf->McdDepthBuf.pv =
                (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext,
                                        pMcdSurf->McdDepthBuf.size,
                                        &pMcdSurf->McdDepthBuf.hmem, 0);

            if (!pMcdSurf->McdDepthBuf.pv)
            {
                WARNING("bInitMcdSurface: MCDAlloc depth buf failed\n");
                goto bInitMcdSurface_exit;
            }

            //
            // A 32-bit depth span is required by generic implementation for
            // simulations.  If cDepthBufferBits < 32, then we need to allocate
            // a separate buffer to do the conversion.
            //

            if (pMcdState->McdPixelFmt.cDepthBufferBits < 32)
            {
                pMcdSurf->pDepthSpan =
                    (__GLzValue *)ALLOC(sizeof(__GLzValue) * MCD_MAX_SCANLINE);

                if (!pMcdSurf->pDepthSpan)
                {
                    WARNING("bInitMcdSurface: malloc depth buf failed\n");
                    goto bInitMcdSurface_exit;
                }
            }
            else
            {
                pMcdSurf->pDepthSpan = (__GLzValue *) pMcdSurf->McdDepthBuf.pv;
            }
        }
        else
        {
            pMcdSurf->McdDepthBuf.pv = (PVOID) NULL;
            pMcdSurf->pDepthSpan = (PVOID) NULL;
        }

        pMcdSurf->depthBitMask = (~0) << (32 - pMcdState->McdPixelFmt.cDepthBits);

        //
        // Allocate scanline color buffer.  Used to read/write front/back
        // buffer spans.
        //

        pMcdSurf->McdColorBuf.size =
            MCD_MAX_SCANLINE * ((pMcdState->McdPixelFmt.cColorBits + 7) >> 3);
        pMcdSurf->McdColorBuf.pv =
            (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext,
                                    pMcdSurf->McdColorBuf.size,
                                    &pMcdSurf->McdColorBuf.hmem, 0);

        if (!pMcdSurf->McdColorBuf.pv)
        {
            WARNING("bInitMcdSurface: MCDAlloc color buf failed\n");
            goto bInitMcdSurface_exit;
        }

        //
        // Finally, success.
        //

        bRet = TRUE;
    }

bInitMcdSurface_exit:

    //
    // If function failed, cleanup allocated resources.
    //

    if (!bRet)
    {
        if (pMcdSurf)
        {
            if (pMcdSurf->McdColorBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdSurf->McdColorBuf.pv);
            }

            if (pMcdSurf->pDepthSpan != pMcdSurf->McdDepthBuf.pv)
            {
                FREE(pMcdSurf->pDepthSpan);
            }

            if (pMcdSurf->McdDepthBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdSurf->McdDepthBuf.pv);
            }

            FREE(pMcdSurf);
            buffers->pMcdSurf = (GENMCDSURFACE *) NULL;
            pMcdState->pMcdSurf = (GENMCDSURFACE *) NULL;
        }
    }
    else
    {
        //
        // Surface created.  Save it in the __GLGENbuffers.
        //

        buffers->pMcdSurf = pMcdSurf;

        //
        // Bind the context to the surface.
        // Sounds fancy, but it really just means save a copy of pointer
        // (and a copy of the pDepthSpan for convenience).
        //

        pMcdState->pMcdSurf = pMcdSurf;
        pMcdState->pDepthSpan = pMcdSurf->pDepthSpan;

        //
        // MCD state is now fully created and bound to a surface.
        // OK to connect pMcdState to the _pMcdState.
        //

        gengc->pMcdState = gengc->_pMcdState;
        gengc->pMcdState->mcdFlags |= (MCD_STATE_FORCEPICK | MCD_STATE_FORCERESIZE);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdDeleteContext
*
* Delete the resources belonging to the MCD context (including the context).
*
* History:
*  16-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdDeleteContext(GENMCDSTATE *pMcdState)
{
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDeleteContext: mcd32.dll not initialized\n");

    if (pMcdState)
    {
        if (pMcdState->McdBuf1.pv)
        {
            (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf1.pv);
        }

        if (pMcdState->McdBuf2.pv)
        {
            (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf2.pv);
        }

        if (pMcdState->McdCmdBatch.pv)
        {
            (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdCmdBatch.pv);
        }

        if (pMcdState->McdContext.hMCDContext)
        {
            (gpMcdTable->pMCDDeleteContext)(&pMcdState->McdContext);
        }

        FREE(pMcdState);
    }
}

/******************************Public*Routine******************************\
* GenMcdDeleteSurface
*
* Delete the resources belonging to the MCD surface.
*
* History:
*  16-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdDeleteSurface(GENMCDSURFACE *pMcdSurf)
{
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDeleteSurface: mcd32.dll not initialized\n");

    if (pMcdSurf)
    {
        MCDCONTEXT McdContext;

    //
    // If a separate depth interchange buffer was allocated, delete it.
    //

        if (pMcdSurf->pDepthSpan != pMcdSurf->McdDepthBuf.pv)
        {
            FREE(pMcdSurf->pDepthSpan);
        }

    //
    // A valid McdContext is not guaranteed to exist at the time this function
    // is called.  Therefore, need to fake up an McdContext with which to call
    // MCDFree.  Currently, the only thing in the McdContext that needs to be
    // valid in order to call MCDFree is the hdc field.
    //

        memset(&McdContext, 0, sizeof(McdContext));

        if (pMcdSurf->pwnd->gwid.iType == GLWID_DDRAW)
        {
            McdContext.hdc = pMcdSurf->pwnd->gwid.hdc;
        }
        else
        {
            McdContext.hdc = GetDC(pMcdSurf->pwnd->gwid.hwnd);
        }
        if (McdContext.hdc)
        {
            if (pMcdSurf->McdColorBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&McdContext, pMcdSurf->McdColorBuf.pv);
            }

            if (pMcdSurf->McdDepthBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&McdContext, pMcdSurf->McdDepthBuf.pv);
            }

            if (pMcdSurf->pwnd->gwid.iType != GLWID_DDRAW)
            {
                ReleaseDC(pMcdSurf->pwnd->gwid.hwnd, McdContext.hdc);
            }
        }

    //
    // Delete the GENMCDSURFACE structure.
    //

        FREE(pMcdSurf);
    }
}

/******************************Public*Routine******************************\
* GenMcdMakeCurrent
*
* Call MCD driver to bind specified context to window.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  03-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdMakeCurrent(__GLGENcontext *gengc, GLGENwindow *pwnd)
{
    BOOL bRet;
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdMakeCurrent: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdMakeCurrent: mcd32.dll not initialized\n");

    bRet = (gpMcdTable->pMCDBindContext)(&pMcdState->McdContext,
                                         gengc->gwidCurrent.hdc, pwnd);

    //
    // Fake up some of the __GLGENbitmap information.  The WNDOBJ is required
    // for clipping of the hardware back buffer.  The hdc is required to
    // retrieve drawing data from GDI.
    //

    if (gengc->gc.modes.doubleBufferMode)
    {
        __GLGENbitmap *genBm = gengc->gc.back->bitmap;

        ASSERT_WINCRIT(gengc->pwndLocked);
        genBm->pwnd = gengc->pwndLocked;
        genBm->hdc = gengc->gwidCurrent.hdc;
    }

#if DBG
    if (!bRet)
    {
        WARNING2("GenMcdMakeCurrent: MCDBindContext failed\n"
                 "\tpMcdCx = 0x%08lx, pwnd = 0x%08lx\n",
                 &pMcdState->McdContext, pwnd);
    }
#endif

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdClear
*
* Call MCD driver to clear specified buffers.  The buffers are specified by
* the masked pointed to by pClearMask.
*
* There is no function return value, but the function will clear the mask
* bits of the buffers it successfully cleared.
*
* History:
*  06-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdClear(__GLGENcontext *gengc, ULONG *pClearMask)
{
    RECTL rcl;
    ULONG mask;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdClear: null pMcdState\n");

    //
    // If MCD format supports stencil, include GL_STENCIL_BUFFER_BIT in
    // the mask.
    //

    if (gengc->pMcdState->McdPixelFmt.cStencilBits)
    {
        mask = *pClearMask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                              GL_STENCIL_BUFFER_BIT);
    }
    else
    {
        mask = *pClearMask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdClear: mcd32.dll not initialized\n");

    if ( mask )
    {
        GLGENwindow *pwnd = gengc->pwndLocked;

        //
        // Determine the clear rectangle.  If there is any window clipping
        // or scissoring, the driver will have to handle it.
        //

        rcl.left   = 0;
        rcl.top    = 0;
        rcl.right  = pwnd->rclClient.right - pwnd->rclClient.left;
        rcl.bottom = pwnd->rclClient.bottom - pwnd->rclClient.top;

        if ((rcl.left != rcl.right) && (rcl.top != rcl.bottom))
        {
            //
            // Before calling MCD to draw, flush state.
            //

            vFlushDirtyState(gengc);

            if ( (gpMcdTable->pMCDClear)(&gengc->pMcdState->McdContext, rcl,
                                         mask) )
            {
                //
                // Successful, so clear the bits of the buffers we
                // handled.
                //

                *pClearMask &= ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

                //
                // Stencil buffer is supplied by generic if MCD does not
                // support it.  Therefore, clear this bit if and only if
                // supported by MCD.
                //

                if (gengc->pMcdState->McdPixelFmt.cStencilBits)
                    *pClearMask &= ~GL_STENCIL_BUFFER_BIT;
            }
        }
    }
}

/******************************Public*Routine******************************\
* GenMcdCopyPixels
*
* Copy span scanline buffer to/from display.  Direction is determined by
* the flag bIn (if bIn is TRUE, copy from color span buffer to display;
* otherwise, copy from display to color span buffer).
*
* History:
*  14-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void GenMcdCopyPixels(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                      GLint x, GLint y, GLint cx, BOOL bIn)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;
    ULONG ulType;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdCopyPixels: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdCopyPixels: mcd32.dll not initialized\n");

    pMcdState = gengc->pMcdState;
    pMcdSurf = pMcdState->pMcdSurf;

    //
    // Clip the length of the span to the scanline buffer size.
    //

    //!!!mcd -- should we just enforce the buffer limit?
    //cx = min(cx, MCD_MAX_SCANLINE);
#if DBG
    if (cx > gengc->gc.constants.width)
        WARNING2("GenMcdCopyPixels: cx (%ld) bigger than window width (%ld)\n", cx, gengc->gc.constants.width);
    ASSERTOPENGL(cx <= MCD_MAX_SCANLINE, "GenMcdCopyPixels: cx exceeds buffer width\n");
#endif

    //
    // Convert screen coordinates to window coordinates.
    //

    if (cfb == gengc->gc.front)
    {
        ulType = MCDSPAN_FRONT;
        x -= gengc->gc.frontBuffer.buf.xOrigin;
        y -= gengc->gc.frontBuffer.buf.yOrigin;
    }
    else
    {
        ulType = MCDSPAN_BACK;
        x -= gengc->gc.backBuffer.buf.xOrigin;
        y -= gengc->gc.backBuffer.buf.yOrigin;
    }

    //
    // If bIn, copy from the scanline buffer to the MCD buffer.
    // Otherwise, copy from the MCD buffer into the scanline buffer.
    //

    if ( bIn )
    {
        if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                          pMcdSurf->McdColorBuf.pv,
                                          x, y, cx, ulType) )
        {
            WARNING3("GenMcdCopyPixels: MCDWriteSpan failed (%ld, %ld) %ld\n", x, y, cx);
        }
    }
    else
    {
        if ( !(gpMcdTable->pMCDReadSpan)(&pMcdState->McdContext,
                                         pMcdSurf->McdColorBuf.pv,
                                         x, y, cx, ulType) )
        {
            WARNING3("GenMcdCopyPixels: MCDReadSpan failed (%ld, %ld) %ld\n", x, y, cx);
        }
    }
}

/******************************Public*Routine******************************\
* GenMcdUpdateRenderState
*
* Update MCD render state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* History:
*  08-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdateRenderState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDRENDERSTATE McdRenderState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateRenderState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateRenderState: mcd32.dll not initialized\n");

    //
    // Compute MCD state from the current OpenGL context state.
    //

    //
    // -=<< State Enables >>=-
    //

    McdRenderState.enables = gc->state.enables.general;

    //
    // -=<< Texture State >>=-
    //

    McdRenderState.textureEnabled = gc->texture.textureEnabled;

    //
    // -=<< Fog State >>=-
    //

    *((__GLcolor *) &McdRenderState.fogColor) = gc->state.fog.color;
    McdRenderState.fogIndex   = gc->state.fog.index;
    McdRenderState.fogDensity = gc->state.fog.density;
    McdRenderState.fogStart   = gc->state.fog.start;
    McdRenderState.fogEnd     = gc->state.fog.end;
    McdRenderState.fogMode    = gc->state.fog.mode;

    //
    // -=<< Shading Model State >>=-
    //

    McdRenderState.shadeModel = gc->state.light.shadingModel;

    //
    // -=<< Point Drawing State >>=-
    //

    McdRenderState.pointSize         = gc->state.point.requestedSize;

    //
    // -=<< Line Drawing State >>=-
    //

    McdRenderState.lineWidth          = gc->state.line.requestedWidth;
    McdRenderState.lineStipplePattern = gc->state.line.stipple;
    McdRenderState.lineStippleRepeat  = gc->state.line.stippleRepeat;

    //
    // -=<< Polygon Drawing State >>=-
    //

    McdRenderState.cullFaceMode         = gc->state.polygon.cull;
    McdRenderState.frontFace            = gc->state.polygon.frontFaceDirection;
    McdRenderState.polygonModeFront     = gc->state.polygon.frontMode;
    McdRenderState.polygonModeBack      = gc->state.polygon.backMode;
    memcpy(&McdRenderState.polygonStipple, &gc->state.polygonStipple.stipple,
           sizeof(McdRenderState.polygonStipple));
    McdRenderState.zOffsetFactor        = gc->state.polygon.factor;
    McdRenderState.zOffsetUnits         = gc->state.polygon.units;

    //
    // -=<< Stencil Test State >>=-
    //

    McdRenderState.stencilTestFunc  = gc->state.stencil.testFunc;
    McdRenderState.stencilMask      = (USHORT) gc->state.stencil.mask;
    McdRenderState.stencilRef       = (USHORT) gc->state.stencil.reference;
    McdRenderState.stencilFail      = gc->state.stencil.fail;
    McdRenderState.stencilDepthFail = gc->state.stencil.depthFail;
    McdRenderState.stencilDepthPass = gc->state.stencil.depthPass;

    //
    // -=<< Alpha Test State >>=-
    //

    McdRenderState.alphaTestFunc   = gc->state.raster.alphaFunction;
    McdRenderState.alphaTestRef    = gc->state.raster.alphaReference;

    //
    // -=<< Depth Test State >>=-
    //

    McdRenderState.depthTestFunc   = gc->state.depth.testFunc;

    //
    // -=<< Blend State >>=-
    //

    McdRenderState.blendSrc    = gc->state.raster.blendSrc;
    McdRenderState.blendDst    = gc->state.raster.blendDst;

    //
    // -=<< Logic Op State >>=-
    //

    McdRenderState.logicOpMode        = gc->state.raster.logicOp;

    //
    // -=<< Frame Buffer Control State >>=-
    //

    McdRenderState.drawBuffer         = gc->state.raster.drawBuffer;
    McdRenderState.indexWritemask     = gc->state.raster.writeMask;
    McdRenderState.colorWritemask[0]  = gc->state.raster.rMask;
    McdRenderState.colorWritemask[1]  = gc->state.raster.gMask;
    McdRenderState.colorWritemask[2]  = gc->state.raster.bMask;
    McdRenderState.colorWritemask[3]  = gc->state.raster.aMask;
    McdRenderState.depthWritemask     = gc->state.depth.writeEnable;

    // To be consistent, we will scale the clear color to whatever
    // the MCD driver specified:

    McdRenderState.colorClearValue.r = gc->state.raster.clear.r * gc->redVertexScale;
    McdRenderState.colorClearValue.g = gc->state.raster.clear.g * gc->greenVertexScale;
    McdRenderState.colorClearValue.b = gc->state.raster.clear.b * gc->blueVertexScale;
    McdRenderState.colorClearValue.a = gc->state.raster.clear.a * gc->alphaVertexScale;

    McdRenderState.indexClearValue    = gc->state.raster.clearIndex;
    McdRenderState.stencilClearValue  = (USHORT) gc->state.stencil.clear;

    McdRenderState.depthClearValue   = (MCDDOUBLE) (gc->state.depth.clear *
                                                 gengc->genAccel.zDevScale);

    //
    // -=<< Lighting >>=-
    //

    McdRenderState.twoSided = gc->state.light.model.twoSided;

    //
    // -=<< Clipping Control >>=-
    //

    memset(McdRenderState.userClipPlanes, 0, sizeof(McdRenderState.userClipPlanes));
    {
        ULONG i, mask, numClipPlanes;

        //
        // Number of user defined clip planes should match.  However,
        // rather than assume this, let's take the min and be robust.
        //

        ASSERTOPENGL(sizeof(__GLcoord) == sizeof(MCDCOORD),
            "GenMcdUpdateRenderState: coord struct mismatch\n");

        ASSERTOPENGL(MCD_MAX_USER_CLIP_PLANES == gc->constants.numberOfClipPlanes,
            "GenMcdUpdateRenderState: num clip planes mismatch\n");

        numClipPlanes = min(MCD_MAX_USER_CLIP_PLANES, gc->constants.numberOfClipPlanes);

        for (i = 0, mask = 1; i < numClipPlanes; i++, mask <<= 1)
        {
            if (mask & gc->state.enables.clipPlanes)
            {
                McdRenderState.userClipPlanes[i] =
                    *(MCDCOORD *)&gc->state.transform.eyeClipPlanes[i];
            }
        }
    }

    //
    // -=<< Hints >>=-
    //

    McdRenderState.perspectiveCorrectionHint = gc->state.hints.perspectiveCorrection;
    McdRenderState.pointSmoothHint           = gc->state.hints.pointSmooth;
    McdRenderState.lineSmoothHint            = gc->state.hints.lineSmooth;
    McdRenderState.polygonSmoothHint         = gc->state.hints.polygonSmooth;
    McdRenderState.fogHint                   = gc->state.hints.fog;

    //
    // Now that the complete MCD state is computed, add it to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_RENDER_STATE,
                                     &McdRenderState,
                                     sizeof(McdRenderState));
}

/******************************Public*Routine******************************\
* GenMcdViewport
*
* Set the viewport from the OpenGL state.
*
* History:
*  09-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdViewport(__GLGENcontext *gengc)
{
    MCDVIEWPORT mcdVP;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdViewport: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdViewport: mcd32.dll not initialized\n");

    //
    // We can copy directly from &viewport.xScale to a MCDVIEWPORT because the
    // structures are the same.  To be safe, assert the structure ordering.
    //

    ASSERTOPENGL(
           offsetof(MCDVIEWPORT, xCenter) ==
           (offsetof(__GLviewport, xCenter) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, yCenter) ==
           (offsetof(__GLviewport, yCenter) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, zCenter) ==
           (offsetof(__GLviewport, zCenter) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, yScale)  ==
           (offsetof(__GLviewport, yScale) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, zScale)  ==
           (offsetof(__GLviewport, zScale) - offsetof(__GLviewport, xScale)),
        "GenMcdViewport: structure mismatch\n");

    memcpy(&mcdVP.xScale, &gengc->gc.state.viewport.xScale,
           sizeof(MCDVIEWPORT));

    (gpMcdTable->pMCDSetViewport)(&gengc->pMcdState->McdContext,
                                  gengc->pMcdState->McdCmdBatch.pv, &mcdVP);
}

/******************************Public*Routine******************************\
* GenMcdScissor
*
* Set the scissor rectangle from the OpenGL state.
*
* History:
*  06-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static void FASTCALL vGetScissor(__GLGENcontext *gengc, RECTL *prcl)
{
    prcl->left  = gengc->gc.state.scissor.scissorX;
    prcl->right = gengc->gc.state.scissor.scissorX + gengc->gc.state.scissor.scissorWidth;

    if (gengc->gc.constants.yInverted)
    {
        prcl->bottom = gengc->gc.constants.height -
                       gengc->gc.state.scissor.scissorY;
        prcl->top    = gengc->gc.constants.height -
                       (gengc->gc.state.scissor.scissorY + gengc->gc.state.scissor.scissorHeight);
    }
    else
    {
        prcl->top    = gengc->gc.state.scissor.scissorY;
        prcl->bottom = gengc->gc.state.scissor.scissorY + gengc->gc.state.scissor.scissorHeight;
    }
}

void FASTCALL GenMcdScissor(__GLGENcontext *gengc)
{
    BOOL bEnabled;
    RECTL rcl;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdScissor: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdScissor: mcd32.dll not initialized\n");

    vGetScissor(gengc, &rcl);

    bEnabled = (gengc->gc.state.enables.general & __GL_SCISSOR_TEST_ENABLE)
               ? TRUE : FALSE;

    (gpMcdTable->pMCDSetScissorRect)(&gengc->pMcdState->McdContext, &rcl,
                                     bEnabled);
}

/******************************Public*Routine******************************\
* GenMcdUpdateScissorState
*
* Update MCD scissor state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* This is similar to but not quite the same as GenMcdScissor.  The
* GenMcdScissor only sets the scissor rect in the MCDSRV32.DLL to
* compute the scissored clip list it maintains.  This call is used
* to update the scissor rectangle state in the (MCD) display driver.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdateScissorState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    RECTL rcl;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateScissorState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateScissorState: mcd32.dll not initialized\n");

    //
    // Get the scissor rect.
    //

    vGetScissor(gengc, &rcl);

    //
    // Add MCDPIXELSTATE to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_SCISSOR_RECT_STATE,
                                     &rcl,
                                     sizeof(rcl));
}

/******************************Public*Routine******************************\
* GenMcdUpdateTexEnvState
*
* Update MCD texture environment state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* History:
*  21-Oct-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdateTexEnvState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDTEXENVSTATE McdTexEnvState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTexEnvState: "
                                   "null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateTexEnvState: "
                             "mcd32.dll not initialized\n");

    //
    // The texture environment array should have been initialized in
    // __glEarlyInitTextureState, but it does not have an error return
    // so it is possible that the array is NULL.
    //

    if (!gengc->gc.state.texture.env)
    {
        WARNING("GenMcdUpdateTexEnvState: null texture environment\n");
        return;
    }

    //
    // There is only one texture environment per-context.
    //
    // If multiple textures are added to a future version of OpenGL,
    // then we can define a new state structure for each new texture.
    // Or we can add a separate MCDTEXENVSTATE structure to the state
    // batch for each supported texture environment.  The first structure
    // is for the first environment, the second structure is for the
    // second environment, etc.  The driver can ignore any structures
    // over the number of texture environments it supports.  Of course,
    // these are just suggestions.  Depending on how multiple textures
    // are spec'd, we might have to do something totally different.
    //

    McdTexEnvState.texEnvMode = gengc->gc.state.texture.env[0].mode;
    *((__GLcolor *) &McdTexEnvState.texEnvColor) = gengc->gc.state.texture.env[0].color;

    //
    // Add MCDPIXELSTATE to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_TEXENV_STATE,
                                     &McdTexEnvState,
                                     sizeof(McdTexEnvState));
}

/******************************Public*Routine******************************\
* GenMcdDrawPrim
*
* Draw the primitives in the POLYARRAY/POLYDATA array pointed to by pa.
* The primitives are chained together as a linked list terminated by a
* NULL.  The return value is a pointer to the first unhandled primitive
* (NULL if the entire chain is successfully processed).
*
* Returns:
*   NULL if entire batch is processed; otherwise, return value is a pointer
*   to the unhandled portion of the chain.
*
* History:
*  09-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

POLYARRAY * FASTCALL GenMcdDrawPrim(__GLGENcontext *gengc, POLYARRAY *pa)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    int levels;
    LPDIRECTDRAWSURFACE *pdds;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdDrawPrim: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDrawPrim: mcd32.dll not initialized\n");

#if DBG
    {
        LONG lOffset;

        lOffset = (LONG) ((BYTE *) pa - (BYTE *) pMcdState->pMcdPrimBatch->pv);

        ASSERTOPENGL(
            (lOffset >= 0) &&
            (lOffset < (LONG) pMcdState->pMcdPrimBatch->size),
            "GenMcdDrawPrim: pa not in shared mem window\n");
    }
#endif

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

#ifdef AUTOMATIC_SURF_LOCK
    levels = gengc->gc.texture.ddtex.levels;
    if (levels > 0 &&
        gengc->gc.texture.ddtex.texobj.loadKey != 0)
    {
        pdds = gengc->gc.texture.ddtex.pdds;
    }
    else
#endif
    {
        levels = 0;
        pdds = NULL;
    }
    
    return (POLYARRAY *)
           (gpMcdTable->pMCDProcessBatch)(&pMcdState->McdContext,
                                          pMcdState->pMcdPrimBatch->pv,
                                          pMcdState->pMcdPrimBatch->size,
                                          (PVOID) pa,
                                          levels, pdds);
}

/******************************Public*Routine******************************\
* GenMcdSwapBatch
*
* If the MCD driver uses DMA, then as part of context creation TWO vertex
* buffers we allocated so that we could ping-pong or double buffer between
* the two buffers (i.e., while the MCD driver is busy processing the
* data in one vertex buffer, OpenGL can start filling the other vertex
* buffer).
*
* This function switches the MCD state and OpenGL context to the other
* buffer.  If the new buffer is still being processed by the MCD driver,
* we will periodically poll the status of the buffer until it becomes
* available.
*
* History:
*  08-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdSwapBatch(__GLGENcontext *gengc)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    GENMCDBUF *pNewBuf;
    ULONG ulMemStatus;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdSwapBatch: null pMcdState\n");

    ASSERTOPENGL(McdDriverInfo.mcdDriverInfo.drvMemFlags & MCDRV_MEM_DMA,
                 "GenMcdSwapBatch: error -- not using DMA\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSwapBatch: mcd32.dll not initialized\n");

    //
    // Determine which of McdBuf1 and McdBuf2 is the current buffer and
    // which is the new buffer.
    //

    if (pMcdState->pMcdPrimBatch == &pMcdState->McdBuf1)
        pNewBuf = &pMcdState->McdBuf2;
    else
        pNewBuf = &pMcdState->McdBuf1;

    //
    // Poll memory status of the new buffer until it is available.
    //

    do
    {
        ulMemStatus = (gpMcdTable->pMCDQueryMemStatus)(pNewBuf->pv);

        //
        // If status of the new buffer is MCD_MEM_READY, set it as the
        // current vertex buffer (both in the pMcdState and in the gengc.
        //

        if (ulMemStatus == MCD_MEM_READY)
        {
            pMcdState->pMcdPrimBatch = pNewBuf;
            gengc->gc.vertex.pdBuf = (POLYDATA *) pMcdState->pMcdPrimBatch->pv;
        }
        else if (ulMemStatus == MCD_MEM_INVALID)
        {
            //
            // This should not be possible, but to be robust let's handle
            // the case in which the new buffer has somehow become invalid
            // (in other words, "Beware of bad drivers!").
            //
            // We handle this by abandoning double buffering and simply
            // wait for the current buffer to become available again.
            // Not very efficient, but at least we recover gracefully.
            //

            RIP("GenMcdSwapBatch: vertex buffer invalid!\n");

            do
            {
                ulMemStatus = (gpMcdTable->pMCDQueryMemStatus)(pMcdState->pMcdPrimBatch->pv);

                //
                // The current buffer definitely should not become invalid!
                //

                ASSERTOPENGL(ulMemStatus != MCD_MEM_INVALID,
                             "GenMcdSwapBatch: current vertex buffer invalid!\n");

            } while (ulMemStatus == MCD_MEM_BUSY);
        }

    } while (ulMemStatus == MCD_MEM_BUSY);
}

/******************************Public*Routine******************************\
* GenMcdSwapBuffers
*
* Invoke the MCD swap buffers command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  19-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdSwapBuffers(HDC hdc, GLGENwindow *pwnd)
{
    BOOL bRet = FALSE;
    MCDCONTEXT McdContextTmp;

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSwapBuffers: mcd32.dll not initialized\n");

    McdContextTmp.hdc = hdc;
    McdContextTmp.hMCDContext = NULL;
    McdContextTmp.dwMcdWindow = pwnd->dwMcdWindow;

    bRet = (gpMcdTable->pMCDSwap)(&McdContextTmp, 0);

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdResizeBuffers
*
* Resize the buffers (front, back, and depth) associated with the MCD
* context bound to the specified GL context.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* Note:  If this functions fails, then MCD drawing for the MCD context
*        will fail.  Other MCD contexts are unaffected.
*
* History:
*  20-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdResizeBuffers(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdResizeBuffers: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdResizeBuffers: mcd32.dll not initialized\n");

    bRet = (gpMcdTable->pMCDAllocBuffers)(&gengc->pMcdState->McdContext,
                                          &gengc->pwndLocked->rclClient);

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdUpdateBufferInfo
*
* This function must be called on every screen access start to synchronize
* the GENMCDSURFACE to the current framebuffer pointer and stride.
*
* If we have direct access to any of the MCD buffers (front, back, depth),
* then setup pointers to the buffer and set flags indicating that they are
* accessible.
*
* Otherwise, mark them as inaccessible (which will force us to use
* MCDReadSpan or MCDWriteSpan to access the buffers).
*
* History:
*  20-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateBufferInfo(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = (__GLcontext *) gengc;
    __GLGENbuffers *buffers = gengc->pwndLocked->buffers;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDRECTBUFFERS McdBuffers;
    BOOL bForceValidate = FALSE;
    
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateBufferInfo: mcd32.dll not initialized\n");

    //
    // Does the flag in pMcdState indicate that a pick should be forced?
    // This is required, for example, for the first batch after an MCD
    // context has been made current.
    //

    if (pMcdState->mcdFlags & MCD_STATE_FORCEPICK)
    {
        bForceValidate = TRUE;
        pMcdState->mcdFlags &= ~MCD_STATE_FORCEPICK;
    }

    //
    // This is the currently active context.  Set the pointer in the
    // shared surface info.
    //

    buffers->pMcdState = pMcdState;

#ifdef MCD95
    //
    // Set the request flags.
    //

    McdBuffers.mcdRequestFlags = MCDBUF_REQ_MCDBUFINFO;
#endif

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        // Nothing to do
    }
    else if ((gengc->fsLocks & LOCKFLAG_FRONT_BUFFER)
        && (gpMcdTable->pMCDGetBuffers)(&pMcdState->McdContext, &McdBuffers))
    {
        BYTE *pbVideoBase;

        // If we're in this code block it shouldn't be possible
        // to have the DD_DEPTH lock since that should only
        // occur if the current surface is a DDraw surface.
        ASSERTOPENGL((gengc->fsLocks & LOCKFLAG_DD_DEPTH) == 0,
                     "DD_DEPTH lock unexpected\n");
        
#ifdef MCD95
        pbVideoBase = (BYTE *) McdBuffers.pvFrameBuf;
#else
        //
        // In order to compute the buffer pointers from the offsets returned by
        // MCDGetBuffers, we need to know the frame buffer pointer.
        // This implies direct screen access must be enabled.
        //

        if (gengc->pgddsFront != NULL)
        {
            pbVideoBase = (BYTE *)GLSCREENINFO->gdds.ddsd.lpSurface;
        }
#endif
    
        //
        // Front buffer.
        //

        if (McdBuffers.mcdFrontBuf.bufFlags & MCDBUF_ENABLED)
        {
            gc->frontBuffer.buf.xOrigin = gengc->pwndLocked->rclClient.left;
            gc->frontBuffer.buf.yOrigin = gengc->pwndLocked->rclClient.top;

            //
            // Since clipping is in screen coordinates, offset buffer pointer
            // by the buffer origin.
            //
            gc->frontBuffer.buf.base =
                (PVOID) (pbVideoBase + McdBuffers.mcdFrontBuf.bufOffset
                         - (McdBuffers.mcdFrontBuf.bufStride * gc->frontBuffer.buf.yOrigin)
                         - (gc->frontBuffer.buf.xOrigin * ((gengc->gsurf.pfd.cColorBits + 7) >> 3)));
            gc->frontBuffer.buf.outerWidth = McdBuffers.mcdFrontBuf.bufStride;
            gc->frontBuffer.buf.flags |= DIB_FORMAT;
        }
        else
        {
            gc->frontBuffer.buf.xOrigin = 0;
            gc->frontBuffer.buf.yOrigin = 0;

            gc->frontBuffer.buf.base = NULL;
            gc->frontBuffer.buf.flags &= ~DIB_FORMAT;
        }

        //
        // Back buffer.
        //

        if (McdBuffers.mcdBackBuf.bufFlags & MCDBUF_ENABLED)
        {
            gc->backBuffer.buf.xOrigin = gengc->pwndLocked->rclClient.left;
            gc->backBuffer.buf.yOrigin = gengc->pwndLocked->rclClient.top;

            //
            // Since clipping is in screen coordinates, offset buffer pointer
            // by the buffer origin.
            //
            gc->backBuffer.buf.base =
                (PVOID) (pbVideoBase + McdBuffers.mcdBackBuf.bufOffset
                         - (McdBuffers.mcdBackBuf.bufStride * gc->backBuffer.buf.yOrigin)
                         - (gc->backBuffer.buf.xOrigin * ((gengc->gsurf.pfd.cColorBits + 7) >> 3)));
            gc->backBuffer.buf.outerWidth = McdBuffers.mcdBackBuf.bufStride;
            gc->backBuffer.buf.flags |= DIB_FORMAT;
        }
        else
        {
            gc->backBuffer.buf.xOrigin = 0;
            gc->backBuffer.buf.yOrigin = 0;

            gc->backBuffer.buf.base = (PVOID) NULL;
            gc->backBuffer.buf.flags &= ~DIB_FORMAT;
        }
        if (McdBuffers.mcdBackBuf.bufFlags & MCDBUF_NOCLIP)
            gc->backBuffer.buf.flags |= NO_CLIP;
        else
            gc->backBuffer.buf.flags &= ~NO_CLIP;

        UpdateSharedBuffer(&buffers->backBuffer , &gc->backBuffer.buf);

        //
        // Depth buffer.
        //

        //!!!mcd -- No depth buffer clipping code, so if we have to clip
        //!!!mcd    depth buffer we need to revert back to span code.

        if ((McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED) &&
            (McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_NOCLIP))
        {
            gc->depthBuffer.buf.xOrigin = 0;
            gc->depthBuffer.buf.yOrigin = 0;

            gc->depthBuffer.buf.base =
                (PVOID) (pbVideoBase + McdBuffers.mcdDepthBuf.bufOffset);

            //
            // Depth code expects stride as a pixel count, not a byte count.
            //

            gc->depthBuffer.buf.outerWidth =
                McdBuffers.mcdDepthBuf.bufStride /
                ((pMcdState->McdPixelFmt.cDepthBufferBits + 7) >> 3);

            //!!!mcd dbug -- span code sets element size to 32bit.  should we
            //!!!mcd dbug    set according to cDepthBits when direct access is used?!?
        }
        else
        {
            //
            // If we ended up here because clipping is required, buffer
            // could still be marked as accessible.  We want the state change
            // detection code to treat this as an inaccessible buffer case,
            // so force the flags to 0.
            //

            McdBuffers.mcdDepthBuf.bufFlags = 0;

            gc->depthBuffer.buf.xOrigin = 0;
            gc->depthBuffer.buf.yOrigin = 0;

            gc->depthBuffer.buf.base = (PVOID) pMcdState->pDepthSpan;

            //!!!mcd dbug -- always force pick procs if no zbuf access
            //bForceValidate = TRUE;
        }

        UpdateSharedBuffer(&buffers->depthBuffer , &gc->depthBuffer.buf);

        bRet = TRUE;
    }
    else
    {
        //
        // MCDGetBuffers normally shouldn't fail.  However, let's gracefully
        // handle this odd case by falling back to the span buffer code.
        //

        gc->frontBuffer.buf.xOrigin = 0;
        gc->frontBuffer.buf.yOrigin = 0;
        gc->frontBuffer.buf.base = (PVOID) NULL;
        gc->frontBuffer.buf.flags &= ~DIB_FORMAT;

        gc->backBuffer.buf.xOrigin = 0;
        gc->backBuffer.buf.yOrigin = 0;
        gc->backBuffer.buf.base = (PVOID) NULL;
        gc->backBuffer.buf.flags &= ~DIB_FORMAT;

        gc->depthBuffer.buf.xOrigin = 0;
        gc->depthBuffer.buf.yOrigin = 0;
        gc->depthBuffer.buf.base = (PVOID) pMcdState->pDepthSpan;

        //
        // Extra paranoid code.  Zero out structure in case MCD driver
        // partially initialized McdBuffers.
        //

        memset(&McdBuffers, 0, sizeof(McdBuffers));
    }

    //
    // If state changed (i.e., access to any of the buffers gained or lost),
    // need to force pick procs.
    //

    if (   (pMcdState->McdBuffers.mcdFrontBuf.bufFlags !=
            McdBuffers.mcdFrontBuf.bufFlags)
        || (pMcdState->McdBuffers.mcdBackBuf.bufFlags !=
            McdBuffers.mcdBackBuf.bufFlags)
        || (pMcdState->McdBuffers.mcdDepthBuf.bufFlags !=
            McdBuffers.mcdDepthBuf.bufFlags) )
    {
        bForceValidate = TRUE;
    }

    //
    // Save a copy of current MCD buffers.
    //

    pMcdState->McdBuffers = McdBuffers;

    //
    // If needed, do pick procs.
    //

    if (bForceValidate)
    {
        gc->dirtyMask |= __GL_DIRTY_ALL;
        (*gc->procs.validate)(gc);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdSynchronize
*
* This function synchronizes to the MCD driver; i.e., it waits until the
* hardware is ready for direct access to the framebuffer and/or more
* hardware-accelerated operations.  This is needed because some (most?) 2D
* and 3D accelerator chips do not support simultaneous hardware operations
* and framebuffer access.
*
* This function must be called by any GL API that potentially touches any
* of the MCD buffers (front, back, or depth) without giving MCD first crack.
* For example, clears always go to MCDClear before the software clear is
* given a chance; therefore, glClear does not need to call GenMcdSychronize.
* On the other hand, glReadPixels does not have an equivalent MCD function
* so it immediately goes to the software implementation; therefore,
* glReadPixels does need to call GenMcdSynchronize.
*
* History:
*  20-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdSynchronize(__GLGENcontext *gengc)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdSynchronize: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSynchronize: mcd32.dll not initialized\n");

    //
    // Note: MCDSync returns a BOOL indicating success or failure.  This
    // is actually for future expansion.  Currently, the function is defined
    // to WAIT until the hardware is ready and then return success.  The
    // specification of the function behavior allows us to ignore the return
    // value for now.
    //
    // In the future, we may change this to a query function.  In which case
    // we should call this in a while loop.  I'd rather not do this at this
    // time though, as it leaves us vulnerable to an infinitely loop problem
    // if we have a bad MCD driver.
    //

    (gpMcdTable->pMCDSync)(&pMcdState->McdContext);
}


/******************************Public*Routine******************************\
* GenMcdConvertContext
*
* Convert the context from an MCD-based one to a generic one.
*
* This requires creating the buffers, etc. that are required for a generic
* context and releasing the MCD resources.
*
* IMPORTANT NOTE:
*   Because we modify the buffers struct, the WNDOBJ semaphore
*   should be held while calling this function.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* Side effects:
*   If successful, the MCD surface is freed and the context will use
*   only generic code.  However, the gengc->_pMcdState will still point to
*   a valid (but quiescent as gengc->pMcdState is disconnected) GENMCDSTATE
*   structure that needs to be deleted when the GLGENcontext is deleted.
*
*   If it fails, then the MCD resources are left allocated meaning that
*   we can try to realloc the MCD buffers later.  However, for the current
*   batch, drawing may not be possible (presumedly we were called because
*   GenMcdResizeBuffers failed).
*
* History:
*  18-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdConvertContext(__GLGENcontext *gengc,
                                   __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE   *pMcdStateSAVE;
    GENMCDSTATE   *_pMcdStateSAVE;
    GENMCDSTATE   *buffers_pMcdStateSAVE;
    GENMCDSURFACE *pMcdSurfSAVE;
    BOOL bConvertContext, bConvertSurface;

    ASSERTOPENGL(gengc->_pMcdState,
                 "GenMcdConvertContext: not an MCD context\n");

    //
    // Do not support conversion if not compatible with generic code.
    //

    if (!(gengc->flags & GENGC_GENERIC_COMPATIBLE_FORMAT))
        return FALSE;

    //
    // Determine if context needs conversion.  Do not need to create
    // scanline buffers if already converted.
    //

    if (gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC)
        bConvertContext = FALSE;
    else
        bConvertContext = TRUE;

    //
    // Determine if surface needs conversion.  Do not need to create
    // the generic shared buffers or destroy MCD surface if already
    // converted.
    //

    if (buffers->flags & GLGENBUF_MCD_LOST)
        bConvertSurface = FALSE;
    else
        bConvertSurface = TRUE;

    //
    // Early out if neither context or surface needs conversion.
    //

    //!!!SP1 -- should be able to early out, but risky for NT4.0
    //if (!bConvertContext && !bConvertSurface)
    //{
    //    return TRUE;
    //}

    //
    // Save current MCD context and surface info.
    //
    // Note that we grab the surface info from the buffers struct.
    // The copy in gengc->pMcdState->pMcdSurf is potentially stale
    // (i.e., may point to a surface already deleted by an earlier
    // call to GenMcdConvertContext for a context that shares the
    // same buffers struct).
    //
    // This allows us to use pMcdSurfSAVE as a flag.  If it is
    // NULL, we know that the MCD surface has already been deleted.
    //

    pMcdSurfSAVE          = buffers->pMcdSurf;
    buffers_pMcdStateSAVE = buffers->pMcdState;

    pMcdStateSAVE  = gengc->pMcdState;
    _pMcdStateSAVE = gengc->_pMcdState;

    //
    // First, remove the MCD information from the context and buffers structs.
    //

    buffers->pMcdSurf  = NULL;
    buffers->pMcdState = NULL;

    gengc->pMcdState  = NULL;
    gengc->_pMcdState = NULL;

    //
    // Create required buffers; initialize buffer info structs.
    //

    if (bConvertContext)
    {
        if (!wglCreateScanlineBuffers(gengc))
        {
            WARNING("GenMcdConvertContext: wglCreateScanlineBuffers failed\n");
            goto GenMcdConvertContext_exit;
        }
        wglInitializeColorBuffers(gengc);
        wglInitializeDepthBuffer(gengc);
        wglInitializePixelCopyFuncs(gengc);
    }

    //
    // *******************************************************************
    // None of the subsequent operations have failure cases, so at this
    // point success is guaranteed.  We no longer need to worry about
    // saving current values so that they can be restored in the failure
    // case.
    //
    // If code is added that may fail, it must be added before this point.
    // Otherwise, it is acceptable to add the code afterwards.
    // *******************************************************************
    //

    bRet = TRUE;

    //
    // Invalidate the context's depth buffer.
    //

    if (bConvertContext)
    {
        gc->modes.haveDepthBuffer = GL_FALSE;
        gc->depthBuffer.buf.base = 0;
        gc->depthBuffer.buf.size = 0;
        gc->depthBuffer.buf.outerWidth = 0;
    }

    //
    // Generic backbuffer doesn't care about the WNDOBJ, so connect the
    // backbuffer to the dummy backbuffer WNDOBJ rather than the real one.
    //

    if (gc->modes.doubleBufferMode)
    {
        gc->backBuffer.bitmap = &buffers->backBitmap;
        buffers->backBitmap.pwnd = &buffers->backBitmap.wnd;
    }

    //
    // Generic back buffers have origin of (0,0).
    //

    gc->backBuffer.buf.xOrigin = 0;
    gc->backBuffer.buf.yOrigin = 0;
    buffers->backBuffer.xOrigin = 0;
    buffers->backBuffer.yOrigin = 0;

GenMcdConvertContext_exit:

    if (bRet)
    {
        //
        // Delete MCD surface.
        //

        if (bConvertSurface && pMcdSurfSAVE)
        {
            GenMcdDeleteSurface(pMcdSurfSAVE);

            //
            // Invalidate the shared depth buffer.
            // Set depth resize routine to the generic version.
            //

            buffers->depthBuffer.base = 0;
            buffers->depthBuffer.size = 0;
            buffers->depthBuffer.outerWidth = 0;
            buffers->resizeDepth = ResizeAncillaryBuffer;

            //
            // Since we deleted MCD surface, we get to create the generic
            // buffers to replace it.
            //

            wglResizeBuffers(gengc, buffers->width, buffers->height);
        }
        else
        {
            //
            // Didn't need to create generic buffers, but we do need to
            // update the buffer info in the context.
            //

            wglUpdateBuffers(gengc, buffers);
        }

        //
        // Reconnect _pMcdState; it and the MCD context resources
        // will be deleted when the GLGENcontext is deleted
        // (but note that pMcdState remains NULL!).
        //
        // We need to keep it around because we are going to continue
        // to use the MCD allocated POLYARRAY buffer.
        //

        gengc->_pMcdState = _pMcdStateSAVE;
        gengc->_pMcdState->pMcdSurf   = (GENMCDSURFACE *) NULL;
        gengc->_pMcdState->pDepthSpan = (__GLzValue *) NULL;

        //
        // Mark buffers struct so that other contexts will know that the
        // MCD resources are gone.
        //

        buffers->flags |= GLGENBUF_MCD_LOST;

        //
        // Mark context as converted so we don't do it again.
        //

        gengc->flags |= GLGEN_MCD_CONVERTED_TO_GENERIC;
    }
    else
    {
        //
        // Delete generic resources if neccessary.
        //

        wglDeleteScanlineBuffers(gengc);

        //
        // Restore the MCD information.
        //

        buffers->pMcdSurf  = pMcdSurfSAVE;
        buffers->pMcdState = buffers_pMcdStateSAVE;

        gengc->pMcdState  = pMcdStateSAVE;
        gengc->_pMcdState = _pMcdStateSAVE;

        //
        // Resetting the MCD information requires that we
        // reinitialization the color, depth, and pixel copy
        // funcs.
        //

        wglInitializeColorBuffers(gengc);
        wglInitializeDepthBuffer(gengc);
        wglInitializePixelCopyFuncs(gengc);

        if (gengc->pMcdState && gengc->pMcdState->pDepthSpan)
        {
            gc->depthBuffer.buf.base = gengc->pMcdState->pDepthSpan;
            buffers->depthBuffer.base = gengc->pMcdState->pDepthSpan;
            buffers->resizeDepth = ResizeUnownedDepthBuffer;
        }

        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }

    //
    // Success or failure, we've messed around with enough data to
    // require revalidation.
    //

    (*gc->procs.applyViewport)(gc);
    //!!!SP1 -- GL_INVALIDATE (which only sets the __GL_DIRTY_GENERIC bit)
    //!!!SP1    should suffice now that __glGenericPickAllProcs has been
    //!!!SP1    modified to repick depth procs if GL_DIRTY_GENERIC is set.
    //!!!SP1    However, we are too close to ship to get good stress coverage,
    //!!!SP1    so leave it as is until after NT4.0 ships.
    //__GL_INVALIDATE(gc);
    gc->dirtyMask |= __GL_DIRTY_ALL;
    gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC |
                         __GL_VALIDATE_STENCIL_OP);
    (*gc->procs.validate)(gc);

    return bRet;
}


/******************************Public*Routine******************************\
* GenMcdCreateTexture
*
* Invoke the MCD texture creation command.
*
* Returns:
*   A non-NULL MCD handle if successful, NULL otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

MCDHANDLE FASTCALL GenMcdCreateTexture(__GLGENcontext *gengc, __GLtexture *tex,
                                       ULONG flags)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdCreateTexture: null pMcdState\n");
    ASSERTOPENGL(tex, "GenMcdCreateTexture: null texture pointer\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdCreateTexture: mcd32.dll not initialized\n");

    if ((flags & MCDTEXTURE_DIRECTDRAW_SURFACES) &&
        !SUPPORTS_DIRECT())
    {
        // Don't pass DirectDraw texture surfaces to the driver if it
        // doesn't support them.
        return 0;
    }
    
    return (gpMcdTable->pMCDCreateTexture)(&pMcdState->McdContext,
                                          (MCDTEXTUREDATA *)&tex->params,
                                          flags, NULL);
}


/******************************Public*Routine******************************\
* GenMcdDeleteTexture
*
* Invoke the MCD texture deletion command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdDeleteTexture(__GLGENcontext *gengc, MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdDeleteTexture: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdDeleteTexture: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDeleteTexture: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDDeleteTexture)(&pMcdState->McdContext,
                                                 (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdUpdateSubTexture
*
* Invoke the MCD subtexture update command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateSubTexture(__GLGENcontext *gengc, __GLtexture *tex,
                                     MCDHANDLE texHandle, GLint lod, 
                                     GLint xoffset, GLint yoffset, 
                                     GLsizei w, GLsizei h)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    RECTL rect;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateSubTexture: null pMcdState\n");

    ASSERTOPENGL(texHandle, "GenMcdUpdateSubTexture: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateSubTexture: mcd32.dll not initialized\n");

    rect.left = xoffset;
    rect.top = yoffset;
    rect.right = xoffset + w;
    rect.bottom = yoffset + h;

    return (BOOL)(gpMcdTable->pMCDUpdateSubTexture)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle,
                (ULONG)lod, &rect);
}


/******************************Public*Routine******************************\
* GenMcdUpdateTexturePalette
*
* Invoke the MCD texture palette update command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateTexturePalette(__GLGENcontext *gengc, __GLtexture *tex,
                                         MCDHANDLE texHandle, GLsizei start,
                                         GLsizei count)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTexturePalette: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdUpdateTexturePalette: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateTexturePalette: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDUpdateTexturePalette)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle,
                (ULONG)start, (ULONG)count);
}


/******************************Public*Routine******************************\
* GenMcdUpdateTexturePriority
*
* Invoke the MCD texture priority command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateTexturePriority(__GLGENcontext *gengc, __GLtexture *tex,
                                          MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTexturePriority: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdUpdateTexturePriority: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateTexturePriority: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDUpdateTexturePriority)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdTextureStatus
*
* Invoke the MCD texture status command.
*
* Returns:
*   The status for the specified texture.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

DWORD FASTCALL GenMcdTextureStatus(__GLGENcontext *gengc, MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdTextureStatus: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdTextureStatus: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdTextureStatus: mcd32.dll not initialized\n");

    return (DWORD)(gpMcdTable->pMCDTextureStatus)(&pMcdState->McdContext,
                                                  (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdUpdateTextureState
*
* Invoke the MCD texture state update command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateTextureState(__GLGENcontext *gengc, __GLtexture *tex,
                                       MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTextureState: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdUpdateTextureState: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdTextureStatus: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDUpdateTextureState)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdTextureKey
*
* Invoke the MCD texture key command.  Note that this call does not go to
* the display driver, but gets handled in the mcd server.
*
* Returns:
*   The driver-owned key for the specified texture.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

DWORD FASTCALL GenMcdTextureKey(__GLGENcontext *gengc, MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdTextureKey: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdTextureKey: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdTextureKey: mcd32.dll not initialized\n");

    return (DWORD)(gpMcdTable->pMCDTextureKey)(&pMcdState->McdContext,
                                               (MCDHANDLE)texHandle);
}

/******************************Public*Routine******************************\
* GenMcdDescribeLayerPlane
*
* Call the MCD driver to return information about the specified layer plane.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdDescribeLayerPlane(HDC hdc, int iPixelFormat,
                                       int iLayerPlane, UINT nBytes,
                                       LPLAYERPLANEDESCRIPTOR plpd)
{
    BOOL bRet = FALSE;

    //
    // Cannot assume that MCD is intialized.
    //

    if (gpMcdTable || bInitMcd(hdc))
    {
        //
        // Caller (wglDescribeLayerPlane in client\layer.c) validates
        // size.
        //

        ASSERTOPENGL(nBytes >= sizeof(LAYERPLANEDESCRIPTOR),
                     "GenMcdDescribeLayerPlane: bad size\n");

        bRet = (gpMcdTable->pMCDDescribeLayerPlane)(hdc, iPixelFormat,
                                                    iLayerPlane, plpd);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdSetLayerPaletteEntries
*
* Set the logical palette for the specified layer plane.
*
* The logical palette is cached in the GLGENwindow structure and is flushed
* to the driver when GenMcdRealizeLayerPalette is called.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int FASTCALL GenMcdSetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                          int iStart, int cEntries,
                                          CONST COLORREF *pcr)
{
    int iRet = 0;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    if (!pcr)
        return iRet;

    //
    // Need to find the window that has the layer palettes.
    //

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        GLGENlayerInfo *plyri;

        ENTER_WINCRIT(pwnd);

        //
        // Get the layer plane information.
        //

        plyri = plyriGet(pwnd, hdc, iLayerPlane);
        if (plyri)
        {
            //
            // Set the palette information in the layer plane structure.
            //

            iRet = min(plyri->cPalEntries - iStart, cEntries);
            memcpy(&plyri->pPalEntries[iStart], pcr, iRet * sizeof(COLORREF));
        }

        pwndUnlock(pwnd, NULL);
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GenMcdGetLayerPaletteEntries
*
* Get the logical palette from the specified layer plane.
*
* The logical palette is cached in the GLGENwindow structure and is flushed
* to the driver when GenMcdRealizeLayerPalette is called.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int FASTCALL GenMcdGetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                          int iStart, int cEntries,
                                          COLORREF *pcr)
{
    int iRet = 0;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    if (!pcr)
        return iRet;

    //
    // Need to find the window.
    //

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        GLGENlayerInfo *plyri;

        ENTER_WINCRIT(pwnd);

        //
        // Get the layer plane information.
        //

        plyri = plyriGet(pwnd, hdc, iLayerPlane);
        if (plyri)
        {
            //
            // Get the palette information from the layer plane structure.
            //

            iRet = min(plyri->cPalEntries - iStart, cEntries);
            memcpy(pcr, &plyri->pPalEntries[iStart], iRet * sizeof(COLORREF));
        }

        pwndUnlock(pwnd, NULL);
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GenMcdRealizeLayerPalette
*
* Send the logical palette of the specified layer plane to the MCD driver.
* If the bRealize flag is TRUE, the palette is mapped into the physical
* palette of the specified layer plane.  Otherwise, this is a signal to the
* driver that the physical palette is no longer needed.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int FASTCALL GenMcdRealizeLayerPalette(HDC hdc, int iLayerPlane,
                                        BOOL bRealize)
{
    int iRet = 0;
    GLWINDOWID gwid;

    //
    // Cannot assume that MCD is intialized.
    //

    if (gpMcdTable || bInitMcd(hdc))
    {
        GLGENwindow *pwnd;

        //
        // Need to find the window.
        //

        WindowIdFromHdc(hdc, &gwid);
        pwnd = pwndGetFromID(&gwid);
        if (pwnd)
        {
            GLGENlayerInfo *plyri;

            ENTER_WINCRIT(pwnd);

            //
            // Get the layer plane information.
            //

            plyri = plyriGet(pwnd, hdc, iLayerPlane);
            if (plyri)
            {
                //
                // Set the palette from the logical palette stored
                // in the layer plane structure.
                //

                iRet = (gpMcdTable->pMCDSetLayerPalette)
                            (hdc, iLayerPlane, bRealize,
                             plyri->cPalEntries,
                             &plyri->pPalEntries[0]);
            }

            pwndUnlock(pwnd, NULL);
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GenMcdSwapLayerBuffers
*
* Swap the individual layer planes specified in fuFlags.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdSwapLayerBuffers(HDC hdc, UINT fuFlags)
{
    BOOL bRet = FALSE;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    //
    // Need the window.
    //

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        MCDCONTEXT McdContextTmp;

        ENTER_WINCRIT(pwnd);

        //
        // From the window, we can get the buffers struct.
        //

        if (pwnd->buffers != NULL)
        {
            __GLGENbuffers *buffers = pwnd->buffers;

            //
            // Call MCDSwap if we can (MCD context is required).
            //

            if (buffers->pMcdSurf)
            {
                ASSERTOPENGL(gpMcdTable,
                             "GenMcdSwapLayerBuffers: "
                             "mcd32.dll not initialized\n");

                McdContextTmp.hdc = hdc;

                bRet = (gpMcdTable->pMCDSwap)(&McdContextTmp, fuFlags);
            }
        }

        //
        // Release the window.
        //

        pwndUnlock(pwnd, NULL);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdUpdatePixelState
*
* Update MCD pixel state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* Note: pixel maps (glPixelMap) are not updated by this function.  Because
* they are not used often, they are delayed but rather flushed to the driver
* immediately.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdatePixelState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDPIXELSTATE McdPixelState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdatePixelState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdatePixelState: mcd32.dll not initialized\n");

    //
    // Compute MCD pixel state from the current OpenGL context state.
    //

    //
    // Pixel transfer modes.
    //
    // MCDPIXELTRANSFER and __GLpixelTransferMode structures are the same.
    //

    McdPixelState.pixelTransferModes
        = *((MCDPIXELTRANSFER *) &gengc->gc.state.pixel.transferMode);

    //
    // Pixel pack modes.
    //
    // MCDPIXELPACK and __GLpixelPackMode structures are the same.
    //

    McdPixelState.pixelPackModes
        = *((MCDPIXELPACK *) &gengc->gc.state.pixel.packModes);

    //
    // Pixel unpack modes.
    //
    // MCDPIXELUNPACK and __GLpixelUnpackMode structures are the same.
    //

    McdPixelState.pixelUnpackModes
        = *((MCDPIXELUNPACK *) &gengc->gc.state.pixel.unpackModes);

    //
    // Read buffer.
    //

    McdPixelState.readBuffer = gengc->gc.state.pixel.readBuffer;

    //
    // Current raster position.
    //

    McdPixelState.rasterPos = *((MCDCOORD *) &gengc->gc.state.current.rasterPos.window);

    //
    // Send MCDPIXELSTATE to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_PIXEL_STATE,
                                     &McdPixelState,
                                     sizeof(McdPixelState));
}

/******************************Public*Routine******************************\
* GenMcdUpdateFineState
*
* Update fine-grained MCD state from the OpenGL state.
*
* This call only adds state structures to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* History:
*  13-Mar-1997 -by- Drew Bliss [drewb]
* Created.
\**************************************************************************/

void FASTCALL GenMcdUpdateFineState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDPIXELSTATE McdPixelState;

    ASSERTOPENGL(pMcdState, "GenMcdUpdateFineState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateFineState: "
                 "mcd32.dll not initialized\n");

    //
    // Compute MCD state from the current OpenGL context state.
    //

    if (MCD_STATE_DIRTYTEST(gengc, ENABLES))
    {
        MCDENABLESTATE state;

        state.enables = gc->state.enables.general;
        (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                         MCD_ENABLE_STATE,
                                         &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, TEXTURE))
    {
        MCDTEXTUREENABLESTATE state;

        state.textureEnabled = gc->texture.textureEnabled;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_TEXTURE_ENABLE_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, FOG))
    {
        MCDFOGSTATE state;

        *((__GLcolor *) &state.fogColor) = gc->state.fog.color;
        state.fogIndex   = gc->state.fog.index;
        state.fogDensity = gc->state.fog.density;
        state.fogStart   = gc->state.fog.start;
        state.fogEnd     = gc->state.fog.end;
        state.fogMode    = gc->state.fog.mode;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_FOG_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, SHADEMODEL))
    {
        MCDSHADEMODELSTATE state;

        state.shadeModel = gc->state.light.shadingModel;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_SHADEMODEL_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, POINTDRAW))
    {
        MCDPOINTDRAWSTATE state;

        state.pointSize = gc->state.point.requestedSize;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_POINTDRAW_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LINEDRAW))
    {
        MCDLINEDRAWSTATE state;

        state.lineWidth          = gc->state.line.requestedWidth;
        state.lineStipplePattern = gc->state.line.stipple;
        state.lineStippleRepeat  = gc->state.line.stippleRepeat;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LINEDRAW_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, POLYDRAW))
    {
        MCDPOLYDRAWSTATE state;

        state.cullFaceMode     = gc->state.polygon.cull;
        state.frontFace        = gc->state.polygon.frontFaceDirection;
        state.polygonModeFront = gc->state.polygon.frontMode;
        state.polygonModeBack  = gc->state.polygon.backMode;
        memcpy(&state.polygonStipple, &gc->state.polygonStipple.stipple,
               sizeof(state.polygonStipple));
        state.zOffsetFactor    = gc->state.polygon.factor;
        state.zOffsetUnits     = gc->state.polygon.units;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_POLYDRAW_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, ALPHATEST))
    {
        MCDALPHATESTSTATE state;

        state.alphaTestFunc = gc->state.raster.alphaFunction;
        state.alphaTestRef  = gc->state.raster.alphaReference;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_ALPHATEST_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, DEPTHTEST))
    {
        MCDDEPTHTESTSTATE state;

        state.depthTestFunc = gc->state.depth.testFunc;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_DEPTHTEST_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, BLEND))
    {
        MCDBLENDSTATE state;

        state.blendSrc = gc->state.raster.blendSrc;
        state.blendDst = gc->state.raster.blendDst;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_BLEND_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LOGICOP))
    {
        MCDLOGICOPSTATE state;

        state.logicOpMode = gc->state.raster.logicOp;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LOGICOP_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, FBUFCTRL))
    {
        MCDFRAMEBUFSTATE state;

        state.drawBuffer        = gc->state.raster.drawBuffer;
        state.indexWritemask    = gc->state.raster.writeMask;
        state.colorWritemask[0] = gc->state.raster.rMask;
        state.colorWritemask[1] = gc->state.raster.gMask;
        state.colorWritemask[2] = gc->state.raster.bMask;
        state.colorWritemask[3] = gc->state.raster.aMask;
        state.depthWritemask    = gc->state.depth.writeEnable;

        // To be consistent, we will scale the clear color to whatever
        // the MCD driver specified:

        state.colorClearValue.r =
            gc->state.raster.clear.r * gc->redVertexScale;
        state.colorClearValue.g =
            gc->state.raster.clear.g * gc->greenVertexScale;
        state.colorClearValue.b =
            gc->state.raster.clear.b * gc->blueVertexScale;
        state.colorClearValue.a =
            gc->state.raster.clear.a * gc->alphaVertexScale;

        state.indexClearValue   = gc->state.raster.clearIndex;
        state.stencilClearValue = (USHORT) gc->state.stencil.clear;

        state.depthClearValue   = (MCDDOUBLE) (gc->state.depth.clear *
                                               gengc->genAccel.zDevScale);
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_FRAMEBUF_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LIGHTMODEL))
    {
        MCDLIGHTMODELSTATE state;

        *((__GLcolor *)&state.ambient) = gc->state.light.model.ambient;
        state.localViewer = gc->state.light.model.localViewer;
        state.twoSided = gc->state.light.model.twoSided;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LIGHT_MODEL_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, HINTS))
    {
        MCDHINTSTATE state;

        state.perspectiveCorrectionHint =
            gc->state.hints.perspectiveCorrection;
        state.pointSmoothHint           = gc->state.hints.pointSmooth;
        state.lineSmoothHint            = gc->state.hints.lineSmooth;
        state.polygonSmoothHint         = gc->state.hints.polygonSmooth;
        state.fogHint                   = gc->state.hints.fog;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_HINT_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, CLIPCTRL))
    {
        MCDCLIPSTATE state;
        ULONG i, mask, numClipPlanes;

        memset(state.userClipPlanes, 0, sizeof(state.userClipPlanes));
        memset(state.userClipPlanesInv, 0, sizeof(state.userClipPlanesInv));

        //
        // Number of user defined clip planes should match.  However,
        // rather than assume this, let's take the min and be robust.
        //

        ASSERTOPENGL(sizeof(__GLcoord) == sizeof(MCDCOORD),
                     "GenMcdUpdateFineState: coord struct mismatch\n");

        ASSERTOPENGL(MCD_MAX_USER_CLIP_PLANES ==
                     gc->constants.numberOfClipPlanes,
                     "GenMcdUpdateFineState: num clip planes mismatch\n");

        numClipPlanes = min(MCD_MAX_USER_CLIP_PLANES,
                            gc->constants.numberOfClipPlanes);

        state.userClipEnables = gc->state.enables.clipPlanes;
        
        for (i = 0, mask = 1; i < numClipPlanes; i++, mask <<= 1)
        {
            if (mask & gc->state.enables.clipPlanes)
            {
                state.userClipPlanes[i] =
                    *(MCDCOORD *)&gc->state.transform.eyeClipPlanesSet[i];
                state.userClipPlanesInv[i] =
                    *(MCDCOORD *)&gc->state.transform.eyeClipPlanes[i];
            }
        }

        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_CLIP_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, STENCILTEST))
    {
        MCDSTENCILTESTSTATE state;

        state.stencilTestFunc  = gc->state.stencil.testFunc;
        state.stencilMask      = (USHORT) gc->state.stencil.mask;
        state.stencilRef       = (USHORT) gc->state.stencil.reference;
        state.stencilFail      = gc->state.stencil.fail;
        state.stencilDepthFail = gc->state.stencil.depthFail;
        state.stencilDepthPass = gc->state.stencil.depthPass;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_STENCILTEST_STATE,
                                          &state, sizeof(state));
    }

    //
    // The rest of the state is only interesting to a 2.0 driver,
    // so only send it to a 2.0 driver.
    //

    if (!SUPPORTS_20())
    {
        return;
    }
    
    if (MCD_STATE_DIRTYTEST(gengc, TEXTRANSFORM))
    {
        MCDTEXTURETRANSFORMSTATE state;

        ASSERTOPENGL(sizeof(gc->transform.texture->matrix) ==
                     sizeof(MCDMATRIX),
                     "Matrix size mismatch\n");
        
	memcpy(&state.transform, &gc->transform.texture->matrix,
               sizeof(state.transform));
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_TEXTURE_TRANSFORM_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, TEXGEN))
    {
        MCDTEXTUREGENERATIONSTATE state;

        ASSERTOPENGL(sizeof(__GLtextureCoordState) ==
                     sizeof(MCDTEXTURECOORDGENERATION),
                     "MCDTEXTURECOORDGENERATION mismatch\n");
        
        *(__GLtextureCoordState *)&state.s = gc->state.texture.s;
        *(__GLtextureCoordState *)&state.t = gc->state.texture.t;
        *(__GLtextureCoordState *)&state.r = gc->state.texture.r;
        *(__GLtextureCoordState *)&state.q = gc->state.texture.q;
        
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_TEXTURE_GENERATION_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, MATERIAL))
    {
        MCDMATERIALSTATE state;

        ASSERTOPENGL(sizeof(MCDMATERIAL) == sizeof(__GLmaterialState),
                     "Material size mismatch\n");
        
        *(__GLmaterialState *)&state.materials[MCDVERTEX_FRONTFACE] =
            gc->state.light.front;
        *(__GLmaterialState *)&state.materials[MCDVERTEX_BACKFACE] =
            gc->state.light.back;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_MATERIAL_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LIGHTS))
    {
        // Extra light is to hold the MCDLIGHTSTATE
        MCDLIGHT lights[MCD_MAX_LIGHTS+1];
        MCDLIGHT *light;
        MCDLIGHTSOURCESTATE *state;
        __GLlightSourceState *lss;
        ULONG bit;

        ASSERTOPENGL(sizeof(MCDLIGHTSOURCESTATE) <= sizeof(MCDLIGHT),
                     "MCDLIGHTSTATE too large\n");
        ASSERTOPENGL(gc->constants.numberOfLights <= MCD_MAX_LIGHTS,
                     "Too many lights\n");
        ASSERTOPENGL(sizeof(__GLlightSourceState) >= sizeof(MCDLIGHT),
                     "__GLlightSourceState too small\n");
        
        // We attempt to optimize this state request by only
        // sending down the lights that have changed.

        light = &lights[1];
        state = (MCDLIGHTSOURCESTATE *)
            ((BYTE *)light - sizeof(MCDLIGHTSOURCESTATE));
        
        state->enables = gc->state.enables.lights;
        state->changed = gc->state.light.dirtyLights;
        gc->state.light.dirtyLights = 0;

        bit = 1;
        lss = gc->state.light.source;
        while (bit < (1UL << gc->constants.numberOfLights))
        {
            if (state->changed & bit)
            {
                // MCDLIGHT is a subset of __GLlightSourceState.
                memcpy(light, lss, sizeof(MCDLIGHT));
                light++;
            }

            bit <<= 1;
            lss++;
        }
        
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LIGHT_SOURCE_STATE,
                                          state, (ULONG)((BYTE *)light-(BYTE *)state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, COLORMATERIAL))
    {
        MCDCOLORMATERIALSTATE state;

        state.face = gc->state.light.colorMaterialFace;
        state.mode = gc->state.light.colorMaterialParam;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_COLOR_MATERIAL_STATE,
                                          &state, sizeof(state));
    }
}

/******************************Public*Routine******************************\
* GenMcdDrawPix
*
* Stub to call MCDDrawPixels.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdDrawPix(__GLGENcontext *gengc, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels, BOOL packed)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdDrawPix: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDrawPix: mcd32.dll not initialized\n");

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

    return (gpMcdTable->pMCDDrawPixels)(&gengc->pMcdState->McdContext,
                                        width, height, format, type,
                                        pPixels, packed);
}

/******************************Public*Routine******************************\
* GenMcdReadPix
*
* Stub to call MCDReadPixels.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdReadPix(__GLGENcontext *gengc, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG format,
                             ULONG type, VOID *pPixels)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdReadPix: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdReadPix: mcd32.dll not initialized\n");

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

    return (gpMcdTable->pMCDReadPixels)(&gengc->pMcdState->McdContext,
                                        x, y, width, height, format, type,
                                        pPixels);
}

/******************************Public*Routine******************************\
* GenMcdCopyPix
*
* Stub to call MCDCopyPixels.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdCopyPix(__GLGENcontext *gengc, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG type)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdCopyPix: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdCopyPix: mcd32.dll not initialized\n");

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

    return (gpMcdTable->pMCDCopyPixels)(&gengc->pMcdState->McdContext,
                                        x, y, width, height, type);
}

/******************************Public*Routine******************************\
* GenMcdPixelMap
*
* Stub to call MCDPixelMap.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdPixelMap(__GLGENcontext *gengc, ULONG mapType,
                              ULONG mapSize, VOID *pMap)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdPixelMap: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdPixelMap: mcd32.dll not initialized\n");

    return (gpMcdTable->pMCDPixelMap)(&gengc->pMcdState->McdContext,
                                      mapType, mapSize, pMap);
}

/******************************Public*Routine******************************\
*
* GenMcdDestroyWindow
*
* Passes on GLGENwindow cleanup notifications
*
* History:
*  Thu Sep 19 12:01:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL GenMcdDestroyWindow(GLGENwindow *pwnd)
{
    HDC hdc;
    
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDestroyWindow: "
                 "mcd32.dll not initialized\n");

    // The HDC stored in the pwnd may no longer be valid, so if there's
    // a window associated with the pwnd get a fresh DC.
    if (pwnd->gwid.iType == GLWID_DDRAW ||
        pwnd->gwid.hwnd == NULL)
    {
        hdc = pwnd->gwid.hdc;
    }
    else
    {
        hdc = GetDC(pwnd->gwid.hwnd);
        if (hdc == NULL)
        {
            WARNING("GenMcdDestroyWindow unable to GetDC\n");
            return;
        }
    }
        
    (gpMcdTable->pMCDDestroyWindow)(hdc, pwnd->dwMcdWindow);

    if (pwnd->gwid.iType != GLWID_DDRAW &&
        pwnd->gwid.hwnd != NULL)
    {
        ReleaseDC(pwnd->gwid.hwnd, hdc);
    }
}

/******************************Public*Routine******************************\
*
* GenMcdGetTextureFormats
*
* History:
*  Thu Sep 26 18:34:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int FASTCALL GenMcdGetTextureFormats(__GLGENcontext *gengc, int nFmts,
                                     struct _DDSURFACEDESC *pddsd)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState,
                 "GenMcdGetMcdTextureFormats: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable,
                 "GenMcdGetMcdTextureFormats: mcd32.dll not initialized\n");

    return (gpMcdTable->pMCDGetTextureFormats)(&gengc->pMcdState->McdContext,
                                               nFmts, pddsd);
}

/******************************Public*Routine******************************\
*
* GenMcdSwapMultiple
*
* History:
*  Tue Oct 15 12:51:09 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD FASTCALL GenMcdSwapMultiple(UINT cBuffers, GENMCDSWAP *pgms)
{
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSwapMultiple: "
                 "mcd32.dll not initialized\n");

    return (gpMcdTable->pMCDSwapMultiple)(pgms[0].pwswap->hdc, cBuffers, pgms);
}

/******************************Public*Routine******************************\
* GenMcdProcessPrim
*
* Process the primitives in the POLYARRAY/POLYDATA array pointed to by pa.
* The primitives are chained together as a linked list terminated by a
* NULL.  The return value is a pointer to the first unhandled primitive
* (NULL if the entire chain is successfully processed).
*
* This routine differs from GenMcdProcessPrim in that it is the MCD 2.0
* entry point for front-end processors and so calls MCDrvProcess rather
* than MCDrvDraw.
*
* Returns:
*   NULL if entire batch is processed; otherwise, return value is a pointer
*   to the unhandled portion of the chain.
*
* History:
*  13-Mar-1997 -by- Drew Bliss [drewb]
* Created from GenMcdDrawPrim.
\**************************************************************************/

POLYARRAY * FASTCALL GenMcdProcessPrim(__GLGENcontext *gengc, POLYARRAY *pa,
                                       ULONG cmdFlagsAll, ULONG primFlags,
                                       MCDTRANSFORM *pMCDTransform,
                                       MCDMATERIALCHANGES *pMCDMatChanges)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    int levels;
    LPDIRECTDRAWSURFACE *pdds;

    if (!SUPPORTS_20())
    {
        return pa;
    }
    
    ASSERTOPENGL(gengc->pMcdState, "GenMcdProcessPrim: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable,
                 "GenMcdProcessPrim: mcd32.dll not initialized\n");

#if DBG
    {
        LONG lOffset;

        lOffset = (LONG) ((BYTE *) pa - (BYTE *) pMcdState->pMcdPrimBatch->pv);

        ASSERTOPENGL(
            (lOffset >= 0) &&
            (lOffset < (LONG) pMcdState->pMcdPrimBatch->size),
            "GenMcdProcessPrim: pa not in shared mem window\n");
    }
#endif

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

#ifdef AUTOMATIC_SURF_LOCK
    levels = gengc->gc.texture.ddtex.levels;
    if (levels > 0 &&
        gengc->gc.texture.ddtex.texobj.loadKey != 0)
    {
        pdds = gengc->gc.texture.ddtex.pdds;
    }
    else
#endif
    {
        levels = 0;
        pdds = NULL;
    }
    
    return (POLYARRAY *)
           (gpMcdTable->pMCDProcessBatch2)(&pMcdState->McdContext,
                                           pMcdState->McdCmdBatch.pv,
                                           pMcdState->pMcdPrimBatch->pv,
                                           (PVOID) pa, levels, pdds,
                                           cmdFlagsAll, primFlags,
                                           pMCDTransform, pMCDMatChanges);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genzippy.c ===
/******************************Module*Header*******************************\
* Module Name: zippy.c
*
* Triangle drawing fast path.
*
* 28-Oct-1994 mikeke    Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/**************************************************************************\
*
* Subtriangle functions
*
\**************************************************************************/

#define TEXTURE 1
    #define SHADE 1
    #define ZBUFFER 1
    #include "zippy.h"

    #undef ZBUFFER
    #define ZBUFFER 0
    #include "zippy.h"

    #undef SHADE
    #define SHADE 0
    #include "zippy.h"

#undef TEXTURE
#define TEXTURE 0
    #undef SHADE
    #define SHADE 1
    #include "zippy.h"

    #undef SHADE
    #define SHADE 0
    #include "zippy.h"


/**************************************************************************\
*
* Flat subtriangle function
*
\**************************************************************************/

void FASTCALL
__ZippyFSTCI8Flat
(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    __GLGENcontext  *gengc = (__GLGENcontext *)gc; 
    GENACCEL *pGenAccel = (GENACCEL *)(gengc->pPrivateArea);
    int scansize;
    ULONG color1;

    //
    // this function assumes all this stuff
    //
    ASSERTOPENGL((gc->drawBuffer->buf.flags & DIB_FORMAT) != 0,
		 "Zippy target must have DIB format\n");
    ASSERTOPENGL((gc->drawBuffer->buf.flags & NO_CLIP) != 0,
                 "Zippy doesn't support per-pixel clipping\n");
    ASSERTOPENGL(gc->state.raster.drawBuffer != GL_FRONT_AND_BACK,
                 "Zippy only handles one draw buffer\n");
    ASSERTOPENGL(gc->transform.reasonableViewport,
                 "Zippy requires reasonableViewport\n");
    ASSERTOPENGL(gc->transform.clipY0 <= iyBottom,
                 "Zippy requires unclipped area\n");
    ASSERTOPENGL(iyTop <= gc->transform.clipY1,
                 "Zippy requires unclipped area\n");

    //
    // calculate the color
    //

    color1 = gengc->pajTranslateVector[
        ((pGenAccel->spanValue.r + 0x0800) >> 16) & 0xff
    ];

    //
    // render the spans
    //

    scansize = gc->polygon.shader.cfb->buf.outerWidth;
    gc->polygon.shader.frag.x = gc->polygon.shader.ixLeft;
    for (gc->polygon.shader.frag.y = iyBottom;
         gc->polygon.shader.frag.y != iyTop;
         gc->polygon.shader.frag.y++
        ) {
	GLint spanWidth = gc->polygon.shader.ixRight - gc->polygon.shader.frag.x;

	if (spanWidth > 0) {
            RtlFillMemory(
                pGenAccel->pPix + gengc->gc.polygon.shader.frag.x,
                spanWidth,
                color1);
	}

        pGenAccel->pPix += scansize;

	gc->polygon.shader.ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (gc->polygon.shader.ixRightFrac < 0) {
	    /*
             * Carry/Borrow'd. Use large step
             */
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightBig;
	    gc->polygon.shader.ixRightFrac &= ~0x80000000;
	} else {
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightLittle;
	}

	gc->polygon.shader.ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (gc->polygon.shader.ixLeftFrac < 0) {
	    /*
             * Carry/Borrow'd.  Use large step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftBig;
	    gc->polygon.shader.ixLeftFrac &= ~0x80000000;
	} else {
	    /*
             * Use small step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftLittle;
	}
    }
    gc->polygon.shader.ixLeft = gc->polygon.shader.frag.x;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\mcddepth.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#ifdef _MCD_

void FASTCALL GenMcdClearDepthNOP(__GLdepthBuffer *dfb);

/******************************Public*Routine******************************\
* GenMcdReadZSpan
*
* Read specified span (starting from (x,y) and cx pels wide) of the depth
* buffer.  The read span is in the pMcdSurf->pDepthSpan buffer.
*
* Returns:
*   First depth value in the span.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

__GLzValue GenMcdReadZSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;
    LONG i;
    ULONG *pDest;
    ULONG shiftVal;
    ULONG maskVal;

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    ASSERTOPENGL(pMcdState, "GenMcdReadZSpan: null pMcdState\n");

    pMcdSurf = pMcdState->pMcdSurf;
    ASSERTOPENGL(pMcdSurf, "GenMcdReadZSpan: null pMcdSurf\n");

// Read MCD depth span.

    if ( !(gpMcdTable->pMCDReadSpan)(&pMcdState->McdContext,
                                     pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                     cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdReadZSpan: MCDReadSpan failed\n");
    }

// Shift and mask depth values so that they are in the most significant
// bits of the __GLzValue.
//
// If MCD has a 16-bit depth buffer, then we utilize a separate translation
// buffer (pDepthSpan).  If MCD has a 32-bit depth buffer (implying that
// pDepthSpan == McdDepthBuf.pv), then we do this in place.

    pDest = (ULONG *) pMcdState->pDepthSpan;
    shiftVal = pMcdState->McdPixelFmt.cDepthShift;
    maskVal = pMcdSurf->depthBitMask;

    if ( pDest == (ULONG *) pMcdSurf->McdDepthBuf.pv )
    {
        for (i = cx; i; i--, pDest++)
            *pDest = (*pDest << shiftVal) & maskVal;
    }
    else
    {
        USHORT *pSrc = (USHORT *) pMcdSurf->McdDepthBuf.pv;

        for (i = cx; i; i--)
            *pDest++ = ((ULONG)*pSrc++ << shiftVal) & maskVal;
    }

    return (*((__GLzValue *)pMcdState->pDepthSpan));
}

/******************************Public*Routine******************************\
* GenMcdWriteZSpan
*
* Write depth span buffer to the specificed span (starting from (x,y) and
* cx pels wide) of the MCD depth buffer.  The span to be written is in
* pMcdSurf->pDepthSpan.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

void GenMcdWriteZSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;
    LONG i;
    ULONG *pSrc;
    ULONG shiftVal;

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    ASSERTOPENGL(pMcdState, "GenMcdWriteZSpan: null pMcdState\n");

    pMcdSurf = pMcdState->pMcdSurf;
    ASSERTOPENGL(pMcdSurf, "GenMcdWriteZSpan: null pMcdSurf\n");

// Depth span buffer values are shifted into the most significant portion
// of the __GLzValue.  We need to shift these values back into position.
//
// Furthermore, the depth span buffer is always 32-bit.  If the MCD depth
// buffer is also 32-bit (implying that pDepthSpan == McdDepthBuf.pv),
// then we can shift in place.

    pSrc = (ULONG *) pMcdState->pDepthSpan;
    shiftVal = pMcdState->McdPixelFmt.cDepthShift;

    if ( pSrc == (ULONG *) pMcdSurf->McdDepthBuf.pv )
    {
        for (i = cx; i; i--, pSrc++)
            *pSrc >>= shiftVal;
    }
    else
    {
        USHORT *pDest = (USHORT *) pMcdSurf->McdDepthBuf.pv;

        for (i = cx; i; i--)
            *pDest++ = (USHORT)(*pSrc++ >> shiftVal);
    }

// Write MCD depth span.

    if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                      pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                      cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdWriteZSpan: MCDWriteSpan failed\n");
    }
}

/******************************Public*Routine******************************\
* GenMcdWriteZ
*
* Write a single depth value to the specificed location.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

void GenMcdWriteZ(__GLdepthBuffer *fb, GLint x, GLint y, __GLzValue z)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    ASSERTOPENGL(pMcdState, "GenMcdWriteZ: null pMcdState\n");

    pMcdSurf = pMcdState->pMcdSurf;
    ASSERTOPENGL(pMcdSurf, "GenMcdWriteZ: null pMcdSurf\n");

// If (pmcd->pDepthSpan == pmcd->McdDepthBuf.pv) then MCD has a 32-bit
// depth buffer; otherwise, 16-bit.

    if ( pMcdSurf->McdDepthBuf.pv == (PVOID) pMcdState->pDepthSpan )
        *((ULONG *)pMcdSurf->McdDepthBuf.pv)  = (ULONG)z >> pMcdState->McdPixelFmt.cDepthShift;
    else
        *((USHORT *)pMcdSurf->McdDepthBuf.pv) = (USHORT)(z >> pMcdState->McdPixelFmt.cDepthShift);

// Write depth value to MCD.

    if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                      pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                      1, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdWriteZ: MCDWriteSpan failed\n");
    }
}

/******************************Public*Routine******************************\
* GenMcdReadZRawSpan
*
* Unlike GenMcdReadZSpan, which reads the span from the MCD drivers into
* the 32-bit z span buffer, GenMcdReadZRawSpan reads the span in its
* native format and leaves it in the pMcdSurf->McdDepthBuf.pv buffer.
*
* History:
*  14-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID FASTCALL
GenMcdReadZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;

#if DBG
    if (cx > fb->buf.gc->constants.width)
        WARNING2("GenMcdReadZRawSpan: cx (%ld) bigger than window width (%ld)\n", cx, fb->buf.gc->constants.width);
    ASSERTOPENGL(cx <= MCD_MAX_SCANLINE, "GenMcdReadZRawSpan: cx exceeds buffer width\n");
#endif

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    pMcdSurf = pMcdState->pMcdSurf;

// Read MCD depth span.

    if ( !(gpMcdTable->pMCDReadSpan)(&pMcdState->McdContext,
                                     pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                     cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdReadZRawSpan: MCDReadSpan failed\n");
    }

    return (pMcdSurf->McdDepthBuf.pv);
}

/******************************Public*Routine******************************\
* GenMcdWriteZRawSpan
*
* Unlike GenMcdWriteZSpan, which writes the span in the 32-bit z span
* buffer to the MCD driver, GenMcdWriteZRawSpan writes the native format
* span in the pMcdSurf->McdDepthBuf.pv buffer to the driver.
*
* History:
*  14-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL
GenMcdWriteZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;

#if DBG
    if (cx > fb->buf.gc->constants.width)
        WARNING2("GenMcdWriteZRawSpan: cx (%ld) bigger than window width (%ld)\n", cx, fb->buf.gc->constants.width);
    ASSERTOPENGL(cx <= MCD_MAX_SCANLINE, "GenMcdWriteZRawSpan: cx exceeds buffer width\n");
#endif

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    pMcdSurf = pMcdState->pMcdSurf;

// Write MCD depth span.

    if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                      pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                      cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdWriteZRawSpan: MCDWriteSpan failed\n");
    }
}


/************************************************************************/
/* Fetch routines                                                       */

__GLzValue FASTCALL McdFetch(__GLdepthBuffer *fb, GLint x, GLint y)
{
    return GenMcdReadZSpan(fb, x, y, 1);
}

__GLzValue FASTCALL McdFetch16(__GLdepthBuffer *fb, GLint x, GLint y)
{
    return (GenMcdReadZSpan(fb, x, y, 1) >> 16);
}

__GLzValue FASTCALL McdFetchNEVER(__GLdepthBuffer *fb, GLint x, GLint y)
{
    return (__GLzValue) 0;
}


/************************************************************************/
/* 32-bit depth buffer store routines, depth write is enabled.          */
/*                                                                      */
/* Note: McdStoreNEVER is usable for 16- and 32-bit, write enabled or   */
/*       not.                                                           */

GLboolean McdStoreNEVER(__GLdepthBuffer *fb,
                            GLint x, GLint y, __GLzValue z)
{
    return GL_FALSE;
}

GLboolean McdStoreLESS(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreLEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreGREATER(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreNOTEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreGEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreALWAYS(__GLdepthBuffer *fb,
                             GLint x, GLint y, __GLzValue z)
{
    GenMcdWriteZ(fb, x, y, z);
    return GL_TRUE;
}


/************************************************************************/
/* 32-bit depth buffer store routines, depth write not enabled.         */
/*                                                                      */
/* Note: McdStoreALWAYS_W usable for both 16- and 32-bit.               */

GLboolean McdStoreLESS_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreLEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreGREATER_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreNOTEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreGEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreALWAYS_W(__GLdepthBuffer *fb,
                             GLint x, GLint y, __GLzValue z)
{
    return GL_TRUE;
}


/************************************************************************/
/* 16-bit depth buffer store routines, depth write enabled.             */

GLboolean McdStore16LESS(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16EQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16LEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16GREATER(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16NOTEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16GEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16ALWAYS(__GLdepthBuffer *fb,
                             GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    GenMcdWriteZ(fb, x, y, z);
    return GL_TRUE;
}


/************************************************************************/
/* 16-bit depth buffer store routines, depth write not enabled.         */

GLboolean McdStore16LESS_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16EQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16LEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16GREATER_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16NOTEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16GEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1);
}


/************************************************************************/
/* Store proc table                                                     */
/*                                                                      */
/* Functions are indexed by the depth function index (with offset of    */
/* GL_NEVER removed).  If depth write is not enabled, an additional     */
/* offset of 8 must be added.  If 16-bit depth, rather than 32-bit,     */
/* an additional offset of 16 must be added.                            */

GLboolean (*McdStoreProcs[32])(__GLdepthBuffer*, GLint, GLint, __GLzValue)
 = {
    McdStoreNEVER,      // 32-bit depth, write enabled
    McdStoreLESS,
    McdStoreEQUAL,
    McdStoreLEQUAL,
    McdStoreGREATER,
    McdStoreNOTEQUAL,
    McdStoreGEQUAL,
    McdStoreALWAYS,
    McdStoreNEVER,      // 32-bit depth, write disabled
    McdStoreLESS_W,
    McdStoreEQUAL_W,
    McdStoreLEQUAL_W,
    McdStoreGREATER_W,
    McdStoreNOTEQUAL_W,
    McdStoreGEQUAL_W,
    McdStoreALWAYS_W,
    McdStoreNEVER,      // 16-bit depth, write enabled
    McdStore16LESS,
    McdStore16EQUAL,
    McdStore16LEQUAL,
    McdStore16GREATER,
    McdStore16NOTEQUAL,
    McdStore16GEQUAL,
    McdStore16ALWAYS,
    McdStoreNEVER,      // 16-bit depth, write disabled
    McdStore16LESS_W,
    McdStore16EQUAL_W,
    McdStore16LEQUAL_W,
    McdStore16GREATER_W,
    McdStore16NOTEQUAL_W,
    McdStore16GEQUAL_W,
    McdStoreALWAYS_W
};

/******************************Public*Routine******************************\
* Pick
*
* Choose appropriate store proc for the MCD managed depth buffer.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

// Note: depthIndex param not used - for compatibility with Pick in so_depth.c
void FASTCALL GenMcdPickDepth(__GLcontext *gc, __GLdepthBuffer *fb,
                                     GLint depthIndex)
{
    GLint ix;

    ix = gc->state.depth.testFunc - GL_NEVER;

    if (gc->modes.depthBits) {
        if (!gc->state.depth.writeEnable) {
            ix += 8;
        }
        if (gc->depthBuffer.buf.elementSize == 2) {
            ix += 16;
        }
    } else {

    // No depthBits so force McdStoreALWAYS_W.

        ix = (GL_ALWAYS - GL_NEVER) + 8;
    }

    fb->store = McdStoreProcs[ix];

    if (ix < 16)
        fb->storeRaw = McdStoreProcs[ix];
    else
        fb->storeRaw = McdStoreProcs[ix-16];
}

/******************************Public*Routine******************************\
* __fastGenPickZStoreProc
*
\**************************************************************************/

void FASTCALL __fastGenPickZStoreProc(__GLcontext *gc)
{
    int index;

    index = gc->state.depth.testFunc - GL_NEVER;

    if (gc->modes.depthBits) {
        if (gc->state.depth.writeEnable == GL_FALSE)
            index += 8;

        if (gc->depthBuffer.buf.elementSize == 2)
            index += 16;
    } else {
        index = (GL_ALWAYS - GL_NEVER) + 8;
    }

#if DBG
    {
        GENMCDSTATE *pMcdState = ((__GLGENcontext *)gc)->pMcdState;
        ASSERTOPENGL(!pMcdState || (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED),
                     "__fastGenPickZStoreProc: bad state\n");
    }
#endif

    GENACCEL(gc).__fastGenZStore =  __glCDTPixel[index];
}

/******************************Public*Routine******************************\
* GenMcdInitDepth
*
* Initialize __GLdepthBuffer for MCD.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

void FASTCALL GenMcdInitDepth(__GLcontext *gc, __GLdepthBuffer *fb)
{
    GENMCDSTATE *pMcdState;
    ULONG zDepth;

    pMcdState = ((__GLGENcontext *)gc)->pMcdState;

    fb->buf.gc = gc;
    fb->scale = (__GLzValue) ~0;
    if (pMcdState)
        fb->writeMask = ((__GLzValue)~0) << (32 - pMcdState->McdPixelFmt.cDepthBits);
    else
        fb->writeMask = 0;
    fb->pick = GenMcdPickDepth;

    if (gc->modes.depthBits) {
        if (gc->modes.depthBits > 16)
        {
            fb->buf.elementSize = sizeof(__GLzValue);
            fb->clear = GenMcdClearDepth32;
            fb->store2 = McdStoreALWAYS;
            fb->fetch = McdFetch;
        } else {
            fb->buf.elementSize = sizeof(__GLz16Value);
            fb->clear = GenMcdClearDepth16;
            fb->store2 = McdStore16ALWAYS;
            fb->fetch = McdFetch16;
        }
    } else {
    // If no depth buffer, depth test always passes (according to spec).
    // However, writes must be masked.  Also, I don't want to leave the
    // clear function pointer unitialized (even though it should never
    // be called) so use the NOP clear

        fb->clear = GenMcdClearDepthNOP;
        fb->store = McdStoreALWAYS_W;
        fb->store2 = McdStoreALWAYS_W;
        fb->fetch = McdFetchNEVER;
    }
}

/******************************Public*Routine******************************\
* GenMcdFreeDepth
*
* Nothing to do.  MCD driver manages its own resources.
\**************************************************************************/

void FASTCALL GenMcdFreeDepth(__GLcontext *gc, __GLdepthBuffer *fb)
{
}

/******************************Public*Routine******************************\
* GenMcdClearDepthNOP
*
* Nothing to do.  This is used in the depthBits == 0 case.
\**************************************************************************/

void FASTCALL GenMcdClearDepthNOP(__GLdepthBuffer *dfb)
{
}

/******************************Public*Routine******************************\
* GenMcdClearDepth16
*
* MCD 16-bit depth buffer clear.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdClearDepth16(__GLdepthBuffer *dfb)
{
    __GLGENcontext *gengc = (__GLGENcontext *) dfb->buf.gc;
    GENMCDSTATE *pMcdState;
    RECTL rcl;
    GLint cWidthBytes;
    USHORT usFillZ;

    if (!gengc || !(pMcdState = gengc->pMcdState))
        return;

// No clipping to handle.  If MCDBUF_ENABLED is set there is
// no clipping to handle (see GenMcdUpdateBufferInfo in mcdcx.c).
// If MCDBUF_ENABLE is not set, then we use the MCD span call which
// will handle clipping for us.
//
// Therefore, the client rectangle from the WNDOBJ is the clear
// rectangle.

    rcl = gengc->pwndLocked->rclClient;
    cWidthBytes = (rcl.right - rcl.left) * sizeof(USHORT);

// Compute 16-bit z clear value.

    usFillZ = (USHORT)(gengc->gc.state.depth.clear * gengc->genAccel.zDevScale);

// If MCDBUF_ENABLED, write directly into frame buffer memory.

    if (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED)
    {
        USHORT *pus, *pusEnd;

    // Note: dfb->buf.base has a buffer origin offset of (0, 0).

        pus = (USHORT *) dfb->buf.base;
        pusEnd = pus + ((rcl.bottom - rcl.top) * dfb->buf.outerWidth);

        ASSERTOPENGL((((ULONG_PTR)pus) & 0x01) == 0,
                     "GenMcdClearDepth16: depth buffer not WORD aligned\n");

        for ( ; pus != pusEnd; pus += dfb->buf.outerWidth)
        {
            RtlFillMemoryUshort(pus, cWidthBytes, usFillZ);
        }
    }

// Otherwise, fill in one span's worth and write to MCD driver via
// MCDWriteSpan.

    else
    {
        GLint y;
        GLint cWidth = rcl.right - rcl.left;
        GENMCDSURFACE *pMcdSurf;

        pMcdSurf = pMcdState->pMcdSurf;
        ASSERTOPENGL(pMcdSurf, "GenMcdClearDepth16: no MCD surface\n");

    // Fill in one span into the shared memory buffer.

        ASSERTOPENGL((((ULONG_PTR)pMcdSurf->McdDepthBuf.pv) & 0x01) == 0,
                     "GenMcdClearDepth16: depth span buffer not WORD aligned\n");

        RtlFillMemoryUshort(pMcdSurf->McdDepthBuf.pv, cWidthBytes, usFillZ);

    // Write the span for each span in the clear rectangle.

        for (y = 0; y < (rcl.bottom - rcl.top); y++)
        {
            if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                              pMcdSurf->McdDepthBuf.pv,
                                              //__GL_UNBIAS_X(dfb->buf.gc, 0),
                                              //__GL_UNBIAS_Y(dfb->buf.gc, y),
                                              0, y,
                                              cWidth, MCDSPAN_DEPTH) )
            {
                WARNING("GenMcdClearDepth32: MCDWriteSpan failed\n");
            }
        }
    }
}

/******************************Public*Routine******************************\
* GenMcdClearDepth32
*
* MCD 16-bit depth buffer clear.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdClearDepth32(__GLdepthBuffer *dfb)
{
    __GLGENcontext *gengc = (__GLGENcontext *) dfb->buf.gc;
    GENMCDSTATE *pMcdState;
    RECTL rcl;
    GLint cWidthBytes;
    ULONG ulFillZ;

    if (!gengc || !(pMcdState = gengc->pMcdState))
        return;

// No clipping to handle.  If MCDBUF_ENABLED is set there is
// no clipping to handle (see GenMcdUpdateBufferInfo in mcdcx.c).
// If MCDBUF_ENABLE is not set, then we use the MCD span call which
// will handle clipping for us.
//
// Therefore, the client rectangle from the WNDOBJ is the clear
// rectangle.

    rcl = gengc->pwndLocked->rclClient;
    cWidthBytes = (rcl.right - rcl.left) * sizeof(ULONG);

// Compute 32-bit z clear value.

    ulFillZ = (ULONG)(gengc->gc.state.depth.clear * gengc->genAccel.zDevScale);

// If MCDBUF_ENABLED, write directly into frame buffer memory.

    if (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED)
    {
        ULONG *pul, *pulEnd;

    // Note: dfb->buf.base has a buffer origin offset of (0, 0).

        pul = (ULONG *) dfb->buf.base;
        pulEnd = pul + ((rcl.bottom - rcl.top) * dfb->buf.outerWidth);

        ASSERTOPENGL((((ULONG_PTR)pul) & 0x03) == 0,
                     "GenMcdClearDepth32: depth buffer not DWORD aligned\n");

        for ( ; pul != pulEnd; pul += dfb->buf.outerWidth)
        {
            RtlFillMemoryUlong(pul, cWidthBytes, ulFillZ);
        }
    }

// Otherwise, fill in one span's worth and write to MCD driver via
// MCDWriteSpan.

    else
    {
        GLint y;
        GLint cWidth = rcl.right - rcl.left;
        GENMCDSURFACE *pMcdSurf;

        pMcdSurf = pMcdState->pMcdSurf;
        ASSERTOPENGL(pMcdSurf, "GenMcdClearDepth32: no MCD surface\n");

    // Fill in one span into the shared memory buffer.

        ASSERTOPENGL((((ULONG_PTR)pMcdSurf->McdDepthBuf.pv) & 0x03) == 0,
                     "GenMcdClearDepth32: depth span buffer not DWORD aligned\n");

        RtlFillMemoryUlong(pMcdSurf->McdDepthBuf.pv, cWidthBytes, ulFillZ);

    // Write the span for each span in the clear rectangle.

        for (y = 0; y < (rcl.bottom - rcl.top); y++)
        {
            if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                              pMcdSurf->McdDepthBuf.pv,
                                              0, y,
                                              cWidth, MCDSPAN_DEPTH) )
            {
                WARNING("GenMcdClearDepth32: MCDWriteSpan failed\n");
            }
        }
    }
}


/************************************************************************/

GLboolean FASTCALL GenMcdDepthTestLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint failed, count;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;

            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                xStart += xBig;
                yStart += yBig;
            } else {
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}


GLboolean FASTCALL GenMcdDepthTestStippledLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint failed, count;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;

            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                fraction &= ~0x80000000;
                xStart += xBig;
                yStart += yBig;
            } else {
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean FASTCALL GenMcdDepthTestStencilLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    GLint failed, count;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
            gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                sfb[0] = zFailOp[sfb[0]];
                outMask &= ~bit;
                failed++;
            } else {
                sfb[0] = zPassOp[sfb[0]];
            }

            z += dzdx;
            fraction += dfraction;

            if (fraction < 0) {
                fraction &= ~0x80000000;
                sfb += dspBig;
                xStart += xBig;
                yStart += yBig;
            } else {
                sfb += dspLittle;
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL GenMcdDepthTestStencilStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    GLint failed, count;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
            gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                    sfb[0] = zFailOp[sfb[0]];
                    outMask &= ~bit;
                    failed++;
                } else {
                    sfb[0] = zPassOp[sfb[0]];
                }
            } else failed++;
            z += dzdx;

            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                sfb += dspBig;
                xStart += xBig;
                yStart += yBig;
            } else {
                sfb += dspLittle;
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }

    return GL_TRUE;
}


/************************************************************************/

/*
** Depth test a span, when stenciling is disabled.
*/
GLboolean FASTCALL GenMcdDepthTestSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    if (((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr) {
        GLboolean retVal;

        gc->polygon.shader.zbuf = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;

        retVal =
            (*(__GLspanFunc)((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr)(gc);

        if (gc->state.depth.writeEnable)
            GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                             gc->polygon.shader.frag.y,
                             gc->polygon.shader.length);

        return retVal;
    }

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            switch (testFunc) {
              case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
              case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
              case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
              case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
              case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
              case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
              case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
              case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
            }
            if (passed) {
                if (writeEnabled) {
                    zfb[0] = z;
                }
            } else {
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            zfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);


    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of depth test span, when stenciling is disabled.
*/
GLboolean FASTCALL GenMcdDepthTestStippledSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    sp = gc->polygon.shader.stipplePat;
    w = gc->polygon.shader.length;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                switch (testFunc) {
                  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
                  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
                  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
                  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
                  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
                  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
                  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
                  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
                }
                if (passed) {
                    if (writeEnabled) {
                        zfb[0] = z;
                    }
                } else {
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            zfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/*
** Depth test a span when stenciling is enabled.
*/
GLboolean FASTCALL GenMcdDepthTestStencilSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    sfb = gc->polygon.shader.sbuf;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            switch (testFunc) {
              case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
              case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
              case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
              case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
              case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
              case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
              case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
              case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
            }
            if (passed) {
                sfb[0] = zPassOp[sfb[0]];
                if (writeEnabled) {
                    zfb[0] = z;
                }
            } else {
                sfb[0] = zFailOp[sfb[0]];
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            zfb++;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of depth test span, when stenciling is enabled.
*/
GLboolean FASTCALL GenMcdDepthTestStencilStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    sfb = gc->polygon.shader.sbuf;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                switch (testFunc) {
                  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
                  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
                  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
                  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
                  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
                  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
                  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
                  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
                }
                if (passed) {
                    sfb[0] = zPassOp[sfb[0]];
                    if (writeEnabled) {
                        zfb[0] = z;
                    }
                } else {
                    sfb[0] = zFailOp[sfb[0]];
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            zfb++;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }

    return GL_TRUE;
}

/*
** MCD version of __fastGenStippleAnyDepthTestSpan.  See __fastGenPickSpanProcs
** in genaccel.c and __fastGenStippleAnyDepthTestSpan in genspan.c.
*/
GLboolean FASTCALL GenMcdStippleAnyDepthTestSpan(__GLcontext *gc)
{
    // If the shader is done after this routine then
    // the stipple pattern is all zeroes so we can
    // skip the span
    __glStippleSpan(gc);
    if (gc->polygon.shader.done)
    {
        return GL_FALSE;
    }

    // If this returns true then all bits are off so
    // we can skip the span
    return !GenMcdDepthTestStippledSpan(gc);
}

#ifdef NT_DEADCODE_GENMCDSTIPPLESPAN
//
// The code below works (it must be enabled in the __fastGenPickSpanProcs
// function), but it doesn't seem worth turning it on and increasing the
// DLL size to slightly speed up a rarely used MCD kickback case.
//
// Here are the prototypes for mcdcx.h if the code is turned on:
//
//  GLboolean FASTCALL GenMcdStippleLt32Span(__GLcontext *);
//  GLboolean FASTCALL GenMcdStippleLt16Span(__GLcontext *);
//

/*
** MCD version of __fastGenStippleLt32Span, a special case of
** GenMcdStippleAnyDepthTestSpan for 32-bit depth buffers and GL_LESS
** depth test.
**
** See __fastGenPickSpanProcs in genaccel.c and __fastGenStippleLt32Span in
** genspan.c.
*/
GLboolean FASTCALL GenMcdStippleLt32Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register GLint zDelta = gc->polygon.shader.dzdx;
    register GLuint *zbuf = (GLuint *)
                            ((__GLGENcontext *)gc)->pMcdState->pMcdSurf->McdDepthBuf.pv;
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    GenMcdReadZRawSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                       gc->polygon.shader.frag.y, gc->polygon.shader.length);

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height -
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1)
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y &
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        return GL_FALSE;
    }

    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if ((zAccum) < (*zbuf))
                {
                    *zbuf = zAccum;
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (gc->state.depth.writeEnable)
        GenMcdWriteZRawSpan(&gc->depthBuffer,
                            gc->polygon.shader.frag.x,
                            gc->polygon.shader.frag.y,
                            gc->polygon.shader.length);

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}

/*
** MCD version of __fastGenStippleLt16Span, a special case of
** GenMcdStippleAnyDepthTestSpan for 16-bit depth buffers and GL_LESS
** depth test.
**
** See __fastGenPickSpanProcs in genaccel.c and __fastGenStippleLt16Span in
** genspan.c.
*/
GLboolean FASTCALL GenMcdStippleLt16Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register GLint zDelta = gc->polygon.shader.dzdx;
    register __GLz16Value *zbuf = (__GLz16Value *)
                                  ((__GLGENcontext *)gc)->pMcdState->pMcdSurf->McdDepthBuf.pv;
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    GenMcdReadZRawSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                       gc->polygon.shader.frag.y, gc->polygon.shader.length);

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height -
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1)
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y &
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        return GL_FALSE;
    }

    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if (((__GLz16Value)(zAccum >> Z16_SHIFT)) < (*zbuf))
                {
                    *zbuf = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (gc->state.depth.writeEnable)
        GenMcdWriteZRawSpan(&gc->depthBuffer,
                            gc->polygon.shader.frag.x,
                            gc->polygon.shader.frag.y,
                            gc->polygon.shader.length);

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}
#endif

#endif //_MCD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IF PROFILE
EXTRN __penter:NEAR
	
PROF_ENTRY MACRO
	call __penter
	ENDM
ELSE
PROF_ENTRY MACRO
	ENDM
ENDIF
	
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <ddrawp.h>
#include <ddrawi.h>

#include <wingdip.h>
#define _NO_DDRAWINT_NO_COM
#include <winddi.h>

#include <glp.h>
#include <gencx.h>
#include <global.h>
#include <fixed.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\pixelfmt.c ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.c
*
* This contains the pixel format functions.
*
* Created: 15-Dec-1994 00:28:39
* Author: Gilman Wong [gilmanw]   --   ported from gdi\gre\pixelfmt.cxx
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

//#define DBG_WINDOW
//#define DBG_REFCOUNTS

#ifdef _CLIENTSIDE_
// Need for glsbAttention declaration
#include "glsbcltu.h"
#include "glscreen.h"
#endif

#ifdef _MCD_
#include "mcd.h"
#endif

#define SAVE_ERROR_CODE(x)  SetLastError((x))

// Number of generic pixel formats.  There are 5 pixel depths (4,8,16,24,32).
// This is to convert BMF constants into # bits per pel

#define BMF_COUNT (BMF_32BPP+1)

ULONG gaulConvert[BMF_COUNT] =
{
    0,
    1,
    4,
    8,
    16,
    24,
    32
};

#define MIN_GENERIC_PFD  1
#define MAX_GENERIC_PFD  36

LRESULT CALLBACK
wglWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

#define PALETTE_WATCHER_CLASS __TEXT("Palette Watcher")
static ATOM aPaletteWatcherClass = 0;

DWORD tidPaletteWatcherThread = 0;
ULONG ulPaletteWatcherCount = 0;
HANDLE hPaletteWatcherThread = 0;
HWND hwndPaletteWatcher = 0;
LONG lPaletteWatcherUsers = 0;

/******************************Public*Routine******************************\
* pwndNew
*
* Allocate a new GLGENwindow, initialize it (from input structure), and
* insert it into the global linked list.
*
* Returns:
*   Pointer to structure if successful, NULL otherwise.
*
* History:
*  01-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndNew(GLGENwindow *pwndInit)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    BOOL bDirectScreen = GLDIRECTSCREEN && pwndInit->gwid.hwnd;
    LPDIRECTDRAWCLIPPER pddClip = (LPDIRECTDRAWCLIPPER) NULL;

// If using direct access, retrieve or create a clipper object to track
// vis rgn changes.

    if (pwndInit->gwid.iType == GLWID_DDRAW)
    {
        HRESULT hr;
        
        hr = pwndInit->gwid.pdds->lpVtbl->
            GetClipper(pwndInit->gwid.pdds, &pddClip);
        if (hr != DD_OK && hr != DDERR_NOCLIPPERATTACHED)
        {
            return NULL;
        }
    }
        
    if ( !bDirectScreen ||
         pwndInit->gwid.iType == GLWID_DDRAW ||
         (GLSCREENINFO->pdd->lpVtbl->
          CreateClipper(GLSCREENINFO->pdd, 0, &pddClip, NULL) == DD_OK &&
          pddClip->lpVtbl->SetHWnd(pddClip, 0, pwndInit->gwid.hwnd) == DD_OK) )
    {
        pwndInit->pddClip = pddClip;
        
    // Allocate a new GLGENwindow.

        pwndRet = (GLGENwindow *)ALLOC(sizeof(GLGENwindow));
        if (pwndRet)
        {
            // Initialize from input structure.
            *pwndRet = *pwndInit;

            // Initialize per-window semaphore.
            __try
            {
                InitializeCriticalSection(&pwndRet->sem);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                FREE(pwndRet);
                pwndRet = NULL;
            }

            if (pwndRet)
            {
                // Set initial usage count to one
                pwndRet->lUsers = 1;

                // Insert into linked list.
                EnterCriticalSection(&gwndHeader.sem);
                {
                    pwndRet->pNext = gwndHeader.pNext;
                    gwndHeader.pNext = pwndRet;
                }
                LeaveCriticalSection(&gwndHeader.sem);
            }
        }
    }
    else
    {
       WARNING("pwndNew: Clipper setup failed\n");

       if (pddClip != NULL)
       {
           pddClip->lpVtbl->Release(pddClip);
       }
    }

#ifdef DBG_WINDOW
    if (pwndRet != NULL)
    {
        DbgPrint("Alloc window %p, type %d, hdc %p, hwnd %p, pdds %p\n",
                 pwndRet, pwndRet->gwid.iType, pwndRet->gwid.hdc,
                 pwndRet->gwid.hwnd, pwndRet->gwid.pdds);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
*
* pwndUnsubclass
*
* Removes OpenGL's subclassing set when windows are created
*
* History:
*  Mon May 20 14:05:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void pwndUnsubclass(GLGENwindow *pwnd, BOOL bProcessExit)
{
    WNDPROC wpCur;
        
    // We only restore the original WNDPROC if the current WNDPROC
    // is one of ours.  This prevents us from stomping on the WNDPROC
    // pointer if somebody else has changed it.

    if ((pwnd->ulFlags & GLGENWIN_OTHERPROCESS) == 0)
    {
        wpCur = (WNDPROC)GetWindowLongPtr(pwnd->gwid.hwnd, GWLP_WNDPROC);
        if (wpCur == wglWndProc)
        {
            SetWindowLongPtr(pwnd->gwid.hwnd, GWLP_WNDPROC,
                          (LONG_PTR) pwnd->pfnOldWndProc);
        }
    }
    else
    {
        // Clean up the palette watcher window if this is the last user.
        EnterCriticalSection(&gcsPaletteWatcher);

        ASSERTOPENGL(lPaletteWatcherUsers > 0,
                     "lPaletteWatcherUsers too low\n");
        
        if (--lPaletteWatcherUsers == 0)
        {
            if( PostMessage(hwndPaletteWatcher, WM_CLOSE, 0, 0) == FALSE)
            {
                DbgPrint( "PostMessage to hwnd: %08x failed with error: %08x\n",
                          hwndPaletteWatcher, GetLastError() );

                // Check if the thread is still alive
                
                if( WaitForSingleObject( hPaletteWatcherThread, 100 ) !=
                    WAIT_OBJECT_0 )
                {
                    // This means that the thread is still alive and 
                    // somehow the window is invalid.
                    // Kill this thread or else GL will keep waiting.
                    TerminateThread( hPaletteWatcherThread, 0 );
                }
                
                // Should be safe to do. If the thread is alive, it 
                // was killed above else, someone else killed it
                tidPaletteWatcherThread = 0;
            }
            CloseHandle( hPaletteWatcherThread );
            
            // We don't want to zero the palette watcher's thread ID
            // at process exit because we use it to wait for the
            // thread to die.
            if (!bProcessExit)
            {
                tidPaletteWatcherThread = 0;
            }
        }
        
        LeaveCriticalSection(&gcsPaletteWatcher);
    }
}

/******************************Public*Routine******************************\
* pwndFree
*
* Frees the specified GLGENwindow.
*
* Returns:
*   NULL if successful, pointer to structure otherwise
*
* History:
*  07-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndFree(GLGENwindow *pwndVictim, BOOL bProcessExit)
{
    BOOL bDirectScreen = GLDIRECTSCREEN && pwndVictim->gwid.hwnd;

#ifdef DBG_WINDOW
    DbgPrint("Free  window %p\n", pwndVictim);
#endif

    // Check for a stray screen lock and release if necessary.

    if (pwndVictim->ulFlags & GLGENWIN_DIRECTSCREEN)
        EndDirectScreenAccess(pwndVictim);

    // Free clipper object.

    if (bDirectScreen)
    {
        pwndVictim->pddClip->lpVtbl->Release(pwndVictim->pddClip);
    }

    // Cleanup visible region caches if they exist.

    if ( pwndVictim->prgndat )
        FREE(pwndVictim->prgndat);

    if ( pwndVictim->pscandat )
        FREE(pwndVictim->pscandat);
    
    // Restore original WNDPROC in window.
    if (pwndVictim->gwid.hwnd != NULL)
        pwndUnsubclass(pwndVictim, bProcessExit);

    // Cleanup GLGENlayers.

    if (pwndVictim->plyr)
    {
        int i;

        for (i = 0; i < 15; i++)
        {
            if (pwndVictim->plyr->overlayInfo[i])
                FREE(pwndVictim->plyr->overlayInfo[i]);

            if (pwndVictim->plyr->underlayInfo[i])
                FREE(pwndVictim->plyr->underlayInfo[i]);
        }

        FREE(pwndVictim->plyr);
    }

    // Notify MCD that this window has gone away
    if (pwndVictim->dwMcdWindow != 0)
    {
        GenMcdDestroyWindow(pwndVictim);
    }
        
    // Delete victim.

    DeleteCriticalSection(&pwndVictim->sem);
    FREE(pwndVictim);

    return NULL;
}

/******************************Public*Routine******************************\
*
* pwndCleanup
*
* Does all cleanup necessary for window destruction
*
* History:
*  Mon Mar 18 17:30:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY pwndCleanup(GLGENwindow *pwndVictim)
{
    GLGENwindow *pwnd, *pwndPrev;
#if DBG
    ULONG ulLoops;
#endif

#ifdef DBG_WINDOW
    DbgPrint("Clean window %p\n", pwndVictim);
#endif
    
    EnterCriticalSection(&gwndHeader.sem);

    // Search for victim.  Maintain a prev pointer so we can do
    // removal from linked list.

    for (
         pwndPrev = &gwndHeader, pwnd = pwndPrev->pNext;
         pwnd != &gwndHeader;
         pwndPrev = pwnd, pwnd = pwndPrev->pNext
         )
    {
        if (pwnd == pwndVictim)
            break;
    }

    // If victim was found, take it out.

    if (pwnd == pwndVictim)
    {
        // Excise victim from linked list.
        
        pwndPrev->pNext = pwnd->pNext;
    }
    
    LeaveCriticalSection(&gwndHeader.sem);

    if (pwnd == NULL)
    {
        WARNING("pwndFree: pwndVictim not found in list\n");
        return;
    }

    // If victim was found, it's out of the list so nobody
    // new can get access to it.
            
    // Wait for all current accessors to go away before cleaning up
    // the window

#if DBG
    ulLoops = 0;
#endif
    
    for (;;)
    {
        if (pwndVictim->lUsers == 1)
        {
            break;
        }

#if DBG
        if (++ulLoops == 1000)
        {
            DbgPrint("Spinning on window %p\n", pwndVictim);
#ifdef DBG_WINDOW
            DebugBreak();
#endif
        }
#endif
        
        // Wait on the critical section as a delay
        // Acquiring it doesn't guarantee that we're the last
        // accessor, but it does kill time in the case where
        // another accessor is already holding it
        EnterCriticalSection(&pwndVictim->sem);
        LeaveCriticalSection(&pwndVictim->sem);

        // Allow other threads time to run so we don't starve
        // anybody while we're waiting
        Sleep(0);
    }

    if (pwndVictim->buffers != NULL)
    {
        __glGenFreeBuffers(pwndVictim->buffers);
        wglCleanupWindow(pwndVictim);
    }
    
    if (pwndFree(pwndVictim, FALSE))
        WARNING("window deletion failed\n");
}

/******************************Public*Routine******************************\
* vCleanupWnd
*
* Removes and deletes all GLGENwindow structures from the linked list.
* Must *ONLY* be called from process detach (GLUnInitializeProcess).
*
* History:
*  25-Jul-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY vCleanupWnd()
{
    GLGENwindow *pwndNext;
    
    EnterCriticalSection(&gwndHeader.sem);

    while ( gwndHeader.pNext != &gwndHeader )
    {
        pwndNext = gwndHeader.pNext->pNext;
        pwndFree(gwndHeader.pNext, TRUE);
        gwndHeader.pNext = pwndNext;
    }

    LeaveCriticalSection(&gwndHeader.sem);

    // Wait for the palette watcher thread to die.  This ensures
    // that the palette watcher critical section can be deleted
    // safely in process detach.
    // We don't use a critical section at this point because of
    // the special critsec rules during DLL detach processing.
    while (tidPaletteWatcherThread != 0)
    {
        Sleep(50);
    }
    // Give the palette watcher thread some time to exit after
    // clearing the thread ID.
    Sleep(50);
}

/******************************Public*Routine******************************\
* pwndGetFromHWND
*
* Finds the corresponding GLGENwindow for the given window handle.
*
* Returns:
*   Pointer to GLGENwindow if sucessful; NULL otherwise.
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndGetFromHWND(HWND hwnd)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    GLGENwindow *pwnd = (GLGENwindow *) NULL;

    EnterCriticalSection(&gwndHeader.sem);
    {
        for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwnd->pNext)
            if (pwnd->gwid.hwnd == hwnd)
            {
                pwndRet = pwnd;
                InterlockedIncrement(&pwnd->lUsers);
                break;
            }
    }
    LeaveCriticalSection(&gwndHeader.sem);

#ifdef DBG_REFCOUNTS
    if (pwndRet != 0)
    {
        DbgPrint("GetHWND %p to %d\n", pwndRet, pwndRet->lUsers);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
* pwndGetFromMemDC
*
* Finds the corresponding GLGENwindow for the given mem DC handle.
*
* Returns:
*   Pointer to GLGENwindow if sucessful; NULL otherwise.
*
* History:
*  21-Jan-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndGetFromMemDC(HDC hdcMem)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    GLGENwindow *pwnd = (GLGENwindow *) NULL;

    EnterCriticalSection(&gwndHeader.sem);
    {
        for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwnd->pNext)
        {
            // If the pwnd has an HWND then the DC used at its
            // creation was associated with a window.  If we're
            // in this routine, though, that means hdcMem is
            // not associated with a window, so there's been
            // a reuse of the HDC handle and even though
            // we match DCs we can't return the pwnd.
            
            if (pwnd->gwid.hdc == hdcMem && pwnd->gwid.hwnd == NULL)
            {
                pwndRet = pwnd;
                InterlockedIncrement(&pwndRet->lUsers);
                break;
            }
        }
    }
    LeaveCriticalSection(&gwndHeader.sem);

#ifdef DBG_REFCOUNTS
    if (pwndRet != 0)
    {
        DbgPrint("GetDC   %p to %d\n", pwndRet, pwndRet->lUsers);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
*
* pwndGetFromDdraw
*
* Looks up a window by its DirectDraw surface
*
* History:
*  Wed Aug 28 18:15:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLGENwindow *pwndGetFromDdraw(LPDIRECTDRAWSURFACE pdds)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    GLGENwindow *pwnd = (GLGENwindow *) NULL;

    EnterCriticalSection(&gwndHeader.sem);
    {
        for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwnd->pNext)
            if (pwnd->gwid.pdds == pdds)
            {
                pwndRet = pwnd;
                InterlockedIncrement(&pwndRet->lUsers);
                break;
            }
    }
    LeaveCriticalSection(&gwndHeader.sem);

#ifdef DBG_REFCOUNTS
    if (pwndRet != 0)
    {
        DbgPrint("GetDD   %p to %d\n", pwndRet, pwndRet->lUsers);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
* pwndGetFromID
*
* Finds the corresponding GLGENwindow for the given window ID.
*
* Returns:
*   Pointer to GLGENwindow if sucessful; NULL otherwise.
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndGetFromID(GLWINDOWID *pgwid)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;

    switch (pgwid->iType)
    {
    case GLWID_HWND:
        pwndRet = pwndGetFromHWND(pgwid->hwnd);
        break;
    case GLWID_HDC:
        pwndRet = pwndGetFromMemDC(pgwid->hdc);
        break;
    case GLWID_DDRAW:
        pwndRet = pwndGetFromDdraw(pgwid->pdds);
        break;
    }

    return pwndRet;
}

/******************************Public*Routine******************************\
*
* pwndRelease
*
* Decrements the user count of a window
*
* History:
*  Mon Mar 18 19:35:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
void APIENTRY pwndRelease(GLGENwindow *pwnd)
{
    ASSERTOPENGL(pwnd->lUsers > 0, "Decrement lUsers below zero\n");
    
    InterlockedDecrement(&pwnd->lUsers);
    
#ifdef DBG_REFCOUNTS
    DbgPrint("Release %p to %d\n", pwnd, pwnd->lUsers);
#endif
}
#endif

/******************************Public*Routine******************************\
*
* pwndUnlock
*
* Releases an owner of a window
*
* History:
*  Mon Mar 18 17:25:56 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY pwndUnlock(GLGENwindow *pwnd, __GLGENcontext *gengc)
{
    ASSERTOPENGL(pwnd != NULL, "Unlocking NULL window\n");

    LEAVE_WINCRIT_GC(pwnd, gengc);
    pwndRelease(pwnd);
}


/******************************Public*Routine******************************\
*
* ENTER_WINCRIT_GC
* LEAVE_WINCRIT_GC
*
* Window lock tracking routines.  The pwnd and gengc are validated
* and updated to reflect current locks.
*
* If the gengc is non-NULL then recursion is not allowed.  This is
* to prevent difficulties with maintaining gengc->pwndLocked correctly
* during recursion.  Recursing with gengc == NULL is not a problem.
*
* No ASSERTOPENGL usage so these can be enabled on free builds.
*
* History:
*  Wed Jul 02 12:57:26 1997	-by-	Drew Bliss [drewb]
*
\**************************************************************************/

void ENTER_WINCRIT_GC(GLGENwindow *pwnd, __GLGENcontext *gengc)
{
    EnterCriticalSection(&pwnd->sem);

    if (pwnd->owningThread == 0)
    {
#if DBG || defined(TRACK_WINCRIT)
        if (pwnd->lockRecursion != 0)
        {
            DbgPrint("Unowned window 0x%08lX has recursion count %d\n",
                     pwnd, pwnd->lockRecursion);
            DebugBreak();
        }
        if (pwnd->gengc != NULL)
        {
            DbgPrint("Unowned window 0x%08lX has gengc 0x%08lX\n",
                     pwnd, pwnd->gengc);
            DebugBreak();
        }
        if (gengc != NULL && gengc->pwndLocked != NULL)
        {
            DbgPrint("gengc 0x%08lX has pwnd 0x%08lX while locking 0x%08lX\n",
                     gengc, gengc->pwndLocked, pwnd);
            DebugBreak();
        }
#endif

        pwnd->owningThread = GetCurrentThreadId();
        if (gengc != NULL)
        {
            gengc->pwndLocked = pwnd;
            pwnd->gengc = gengc;
        }
    }
    else
    {
        // Make sure this thread is really the one holding the lock.
        ASSERT_WINCRIT(pwnd);
        
#if DBG || defined(TRACK_WINCRIT)
        // Recursion is only allowed with gengc == NULL.
        if (gengc != NULL)
        {
            DbgPrint("Window 0x%08lX recursing with gengc 0x%08lX\n",
                     pwnd, gengc);
            DebugBreak();
        }
#endif
    }

    pwnd->lockRecursion++;
}

void LEAVE_WINCRIT_GC(GLGENwindow *pwnd, __GLGENcontext *gengc)
{
    ASSERT_WINCRIT(pwnd);
    
#if 0
// Currently turned off because of difference in RTL_CRITICAL_SECTION
// RecursionCount between x86 and Alpha
#if !defined(_WIN95_) && (DBG || defined(TRACK_WINCRIT))
    // Check and make sure that our tracking information is following
    // what the system thinks.
    if (pwnd->sem.OwningThread != (HANDLE)pwnd->owningThread ||
        (DWORD)pwnd->sem.RecursionCount != pwnd->lockRecursion)
    {
        DbgPrint("pwnd 0x%08lX critsec information mismatch\n", pwnd);
        DebugBreak();
    }
#endif
#endif

#if DBG || defined(TRACK_WINCRIT)
    if (gengc != NULL)
    {
        if (pwnd->gengc != gengc || gengc->pwndLocked != pwnd)
        {
            DbgPrint("pwnd 0x%08lX:%08lX mismatch with gengc 0x%08lX:%08lX\n",
                     pwnd, pwnd->gengc, gengc, gengc->pwndLocked);
            DebugBreak();
        }
        if (pwnd->lockRecursion != 1)
        {
            DbgPrint("gengc 0x%08lX leaving window 0x%08lX with "
                     "recursion count of %d\n",
                     gengc, pwnd, pwnd->lockRecursion);
            DebugBreak();
        }
    }
#endif
    
    if (--pwnd->lockRecursion == 0)
    {
        if (gengc != NULL)
        {
            gengc->pwndLocked = NULL;
        }

        pwnd->gengc = NULL;
        pwnd->owningThread = 0;
    }
    
    LeaveCriticalSection(&pwnd->sem);
}

/******************************Public*Routine******************************\
*
* wglValidateWindows
*
* Walks the window list and prunes away any DC-based windows with
* invalid DCs.  This is necessary because, unlike window-based
* windows, we usually aren't notified when a memory DC goes away
* so if it has a window it just hangs around
*
* History:
*  Thu May 02 17:44:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY wglValidateWindows(void)
{
    GLGENwindow *pwnd, *pwndNext;
    BOOL bValid;

    EnterCriticalSection(&gwndHeader.sem);
    for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwndNext)
    {
        pwndNext = pwnd->pNext;

        switch(pwnd->gwid.iType)
        {
        case GLWID_HDC:
            bValid = GetObjectType(pwnd->gwid.hdc) != 0;
            break;
            
        case GLWID_DDRAW:
            // Better validation?  Not really necessary since properly
            // behaved apps will have the genwin cleaned up on
            // context destruction.
            bValid = !IsBadReadPtr(pwnd->gwid.pdds, sizeof(void *)) &&
                *(void **)pwnd->gwid.pdds == pwnd->pvSurfaceVtbl;
            break;
            
        default:
            // No validation for HWNDs necessary
            bValid = TRUE;
            break;
        }

        if (!bValid)
        {
            // Increment so users count is one
            InterlockedIncrement(&pwnd->lUsers);
            pwndCleanup(pwnd);
        }
    }
    LeaveCriticalSection(&gwndHeader.sem);
}

/******************************Public*Routine******************************\
* plyriGet
*
* Returns the GLGENlayerInfo for the specified layer plane from the pwnd.
* If it doesn't yet exist, the GLGENlayer and/or GLGENlayerInfo structure(s)
* are allocated.
*
* Returns:
*   A non-NULL pointer if successful; NULL otherwise.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENlayerInfo * APIENTRY plyriGet(GLGENwindow *pwnd, HDC hdc, int iLayer)
{
    GLGENlayerInfo *plyriRet = (GLGENlayerInfo * ) NULL;
    GLGENlayerInfo **pplyri;

    ASSERTOPENGL(pwnd, "plyriGet: bad pwnd\n");

// Allocate plyr if needed.

    if (!pwnd->plyr)
    {
        pwnd->plyr = (GLGENlayers *) ALLOCZ(sizeof(GLGENlayers));

        if (!pwnd->plyr)
        {
            WARNING("plyriGet: alloc failed (GLGENlayers)\n");
            goto plyriGet_exit;
        }
    }

// Get info for the specified layer (positive values are overlay planes,
// negative values are underlay planes).

    if (iLayer > 0)
        pplyri = &pwnd->plyr->overlayInfo[iLayer - 1];
    else if (iLayer < 1)
        pplyri = &pwnd->plyr->underlayInfo[(-iLayer) - 1];
    else
    {
        WARNING("plyriGet: no layer plane info for main plane!\n");
        goto plyriGet_exit;
    }

// Allocate plyri if needed.

    if (!(*pplyri))
    {
        LAYERPLANEDESCRIPTOR lpd;

        if (!wglDescribeLayerPlane(hdc, pwnd->ipfd, iLayer, sizeof(lpd), &lpd))
        {
            WARNING("plyriGet: wglDescribeLayerPlane failed\n");
            goto plyriGet_exit;
        }

        *pplyri = (GLGENlayerInfo *)
            ALLOC((sizeof(COLORREF) * (1 << lpd.cColorBits))
                       + sizeof(GLGENlayerInfo));


        if (*pplyri)
        {
            int i;

        // Initialize the new GLGENlayerInfo.
        // Note that the palette is initialized with all white colors.

            (*pplyri)->cPalEntries = 1 << lpd.cColorBits;
            for (i = 0; i < (*pplyri)->cPalEntries; i++)
                (*pplyri)->pPalEntries[i] = RGB(255, 255, 255);
        }
        else
        {
            WARNING("plyriGet: alloc failed (GLGENlayerInfo)\n");
            goto plyriGet_exit;
        }
    }

// Success.

    plyriRet = *pplyri;

plyriGet_exit:

    return plyriRet;
}

/******************************Public*Routine******************************\
* GetScreenRect
*
* Get the screen rectangle by accessing the virtual screen metrics. 
*
* If the system does not understand multimon, such as old Win95 or NT,
* just use the device caps.  This code technically isn't necessary but
* it's useful.
*
\**************************************************************************/

static void GetScreenRect( HDC hdc, LPRECTL pRect )
{
    // If SM_CMONITORS is not understood the system returns zero,
    // so this if test works for both old and new systems.
    if (GetSystemMetrics(SM_CMONITORS) > 1)
    {
        pRect->left   = GetSystemMetrics( SM_XVIRTUALSCREEN );
        pRect->top    = GetSystemMetrics( SM_YVIRTUALSCREEN );
        pRect->right  = pRect->left + GetSystemMetrics( SM_CXVIRTUALSCREEN );
        pRect->bottom = pRect->top  + GetSystemMetrics( SM_CYVIRTUALSCREEN );
    }
    else
    {
        pRect->left   = 0;
        pRect->top    = 0;
        pRect->right  = GetDeviceCaps(hdc, HORZRES);
        pRect->bottom = GetDeviceCaps(hdc, VERTRES);
    }
}

/******************************Public*Routine******************************\
* bClipToScreen(prclDst, prclSrc)
*
* Clip source rectangle to screen bounds and store in destination rectangle.
*
* Returns:
*   TRUE if resultant prclDst == prclSrc; FALSE otherwise.
*
\**************************************************************************/

BOOL bClipToScreen(RECTL *prclDst, RECTL *prclSrc)
{
    BOOL bRet;
    HDC hdc;

    if (hdc = GetDC(NULL))
    {
        RECTL rclScreen;

        GetScreenRect( hdc, &rclScreen );

        prclDst->left   = max(prclSrc->left  , rclScreen.left  );
        prclDst->top    = max(prclSrc->top   , rclScreen.top   );
        prclDst->right  = min(prclSrc->right , rclScreen.right );
        prclDst->bottom = min(prclSrc->bottom, rclScreen.bottom);

        if ((prclDst->left >= prclDst->right) ||
            (prclDst->top >= prclDst->bottom))
        {
            prclDst->left   = 0;
            prclDst->top    = 0;
            prclDst->right  = 0;
            prclDst->bottom = 0;
        }

        ReleaseDC(NULL, hdc);
    }
    else
    {
        prclDst->left   = 0;
        prclDst->top    = 0;
        prclDst->right  = 0;
        prclDst->bottom = 0;
    }

    if ((prclDst->left   == prclSrc->left  ) &&
        (prclDst->top    == prclSrc->top   ) &&
        (prclDst->right  == prclSrc->right ) &&
        (prclDst->bottom == prclSrc->bottom))
        bRet = TRUE;
    else
        bRet = FALSE;

    return bRet;
}

/******************************Public*Routine******************************\
*
* PaletteWatcherProc
*
* Window proc for the palette watcher
*
* History:
*  Mon Oct 14 15:29:10 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

LRESULT WINAPI PaletteWatcherProc(HWND hwnd, UINT uiMsg,
                                  WPARAM wpm, LPARAM lpm)
{
    switch(uiMsg)
    {
    case WM_PALETTECHANGED:
        InterlockedIncrement((LONG *)&ulPaletteWatcherCount);
        return 0;
        
    default:
        return DefWindowProc(hwnd, uiMsg, wpm, lpm);
    }
}

/******************************Public*Routine******************************\
*
* PaletteWatcher
*
* Thread routine for the palette change monitor.  Creates a hidden
* top level window and looks for WM_PALETTECHANGED.
*
* History:
*  Mon Oct 14 15:16:02 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD WINAPI PaletteWatcher(LPVOID pvArg)
{
    HWND hwnd;

    hwnd = CreateWindow(PALETTE_WATCHER_CLASS,
                        PALETTE_WATCHER_CLASS,
                        WS_OVERLAPPED,
                        0, 0, 1, 1,
                        NULL,
                        NULL,
                        (HINSTANCE)GetModuleHandle(NULL),
                        NULL);
    if (hwnd != NULL)
    {
        HDC hdc;
        HPALETTE hpal;

        // Select a palette into the window DC.  This is necessary
        // to get around an optimization introduced into NT5 where
        // WM_PALETTECHANGED is only sent to windows that have selected
        // a palette.
        
        hpal = NULL;
        
        hdc = GetDC(hwnd);
        if (hdc != NULL)
        {
            hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
            ReleaseDC(hwnd, hdc);
        }

        if (hpal == NULL)
        {
            goto EH_Exit;
        }
            
        hwndPaletteWatcher = hwnd;
        
        for (;;)
        {
            MSG msg;

            if (GetMessage(&msg, hwnd, 0, 0) > 0)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                break;
            }
        }

    EH_Exit:
        DestroyWindow(hwnd);
        hwndPaletteWatcher = 0;
    }

    EnterCriticalSection(&gcsPaletteWatcher);
        
    // Some kind of problem occurred or this thread is dying.
    // Indicate that this thread is going away and that a
    // new watcher needs to be created.
    if (tidPaletteWatcherThread == GetCurrentThreadId())
    {
        tidPaletteWatcherThread = 0;
    }
        
    LeaveCriticalSection(&gcsPaletteWatcher);
    
    return 0;
}

/******************************Public*Routine******************************\
*
* StartPaletteWatcher
*
* Spins up a thread to watch for palette change events
*
* History:
*  Mon Oct 14 15:11:35 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL StartPaletteWatcher(void)
{
    BOOL bRet;
    
    EnterCriticalSection(&gcsPaletteWatcher);

    bRet = FALSE;
    if (tidPaletteWatcherThread == 0)
    {
        HANDLE h;

        if (aPaletteWatcherClass == 0)
        {
            WNDCLASS wc;

            wc.style = 0;
            wc.lpfnWndProc = PaletteWatcherProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = 0;
            wc.hInstance = (HINSTANCE)GetModuleHandle(NULL);
            wc.hIcon = NULL;
            wc.hCursor = NULL;
            wc.hbrBackground = NULL;
            wc.lpszMenuName = NULL;
            wc.lpszClassName = PALETTE_WATCHER_CLASS;

            aPaletteWatcherClass = RegisterClass(&wc);
        }
        
        if (aPaletteWatcherClass != 0)
        {
            h = CreateThread(NULL, 4096, PaletteWatcher,
                             NULL, 0, &tidPaletteWatcherThread);
            if (h != NULL)
            {
                hPaletteWatcherThread = h;
                bRet = TRUE;
            }
        }
    }
    else
    {
        bRet = TRUE;
    }

    if (bRet)
    {
        lPaletteWatcherUsers++;
    }
    
    LeaveCriticalSection(&gcsPaletteWatcher);
    
    // Make sure that the Palette watcher window is created.
    // Dont need to be in the CritSec for this.
    while( (hwndPaletteWatcher == 0) && 
           (tidPaletteWatcherThread != 0) ) Sleep( 100 );

    return bRet;
}

/******************************Public*Routine******************************\
* wglWndProc
*
* Handle window events for keeping GLGENwindows current
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LRESULT CALLBACK
wglWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    GLGENwindow *pwnd;
    LRESULT lRet = 0;
    WORD width, height;
    __GLGENcontext *gengc;

    pwnd = pwndGetFromHWND(hwnd);

    if (pwnd)
    {
        __GLGENbuffers *buffers = (__GLGENbuffers *) NULL;
        // Cache old WNDPROC because we may delete pwnd
        WNDPROC pfnWndProc = pwnd->pfnOldWndProc;

        // If WM_NCDESTROY, do OpenGL housekeeping after
        // calling original WndProc.
        // NOTE - We shouldn't really need this special case.
        // It's present in order to allow apps to do things like
        // wglDeleteContext in NCDESTROY which wouldn't work if
        // we cleaned up the window before we passed on the message
        // This used to be done in WM_DESTROY where apps do work,
        // but now that it's on NCDESTROY it's much less likely that
        // an app is doing anything.  We preserved the old behavior
        // for safety, though.

        if (uiMsg == WM_NCDESTROY)
        {
            // Subclassing is supposed to be removed during NCDESTROY
            // processing and order is important.  Remove our
            // subclassing before passing on the message.
            pwndUnsubclass(pwnd, FALSE);

            if (pfnWndProc)
            {
                lRet = CallWindowProc(pfnWndProc, hwnd,
                                      uiMsg, wParam, lParam);
            }
        }

    // OpenGL housekeeping in response to windowing system messages.

        switch (uiMsg)
        {
            case WM_SIZE:
                width  = LOWORD(lParam);
                height = HIWORD(lParam);
                gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();

                // Use the non-gc enter to allow recursion.
                ENTER_WINCRIT(pwnd);
                {
                    POINT pt;
                    
                    // Convert client coordinates to screen coordinates
                    // as genwin information is always in screen coordinates.
                    // The given lParam information may be parent-relative
                    // for child windows so it can't be used directly.
                    pt.x = 0;
                    pt.y = 0;
                    ClientToScreen(hwnd, &pt);

                    pwnd->rclClient.left   = pt.x;
                    pwnd->rclClient.right  = pt.x + width;
                    pwnd->rclClient.top    = pt.y;
                    pwnd->rclClient.bottom = pt.y + height;

#if 0
                    DbgPrint("size %d,%d - %d,%d\n",
                             pwnd->rclClient.left,
                             pwnd->rclClient.top,
                             pwnd->rclClient.right,
                             pwnd->rclClient.bottom);
#endif
                    
                    // At least clip to screen.

                    if (bClipToScreen(&pwnd->rclBounds,
                                      &pwnd->rclClient))
                        pwnd->clipComplexity = CLC_TRIVIAL;
                    else
                        pwnd->clipComplexity = CLC_RECT;

                    buffers = pwnd->buffers;
                    if (buffers)
                    {
                        buffers->WndUniq++;

                        buffers->WndSizeUniq++;

                    // Don't let it hit -1.  -1 is special and is used by
                    // MakeCurrent to signal that an update is required

                        if (buffers->WndUniq == -1)
                            buffers->WndUniq = 0;

                        if (buffers->WndSizeUniq == -1)
                            buffers->WndSizeUniq = 0;

                        if ((gengc != NULL) && (pwnd == gengc->pwndLocked))
                            UpdateWindowInfo(gengc);
                    }
                }
                LEAVE_WINCRIT(pwnd);

                break;

            case WM_MOVE:
                gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();
                
                // Use the non-gc enter to allow recursion.
                ENTER_WINCRIT(pwnd);
                {
                    POINT pt;
                    
                    // Convert client coordinates to screen coordinates
                    // as genwin information is always in screen coordinates.
                    // The given lParam information may be parent-relative
                    // for child windows so it can't be used directly.
                    pt.x = 0;
                    pt.y = 0;
                    ClientToScreen(hwnd, &pt);

                    width  = (WORD) (pwnd->rclClient.right -
                                     pwnd->rclClient.left);
                    height = (WORD) (pwnd->rclClient.bottom -
                                     pwnd->rclClient.top);

                    ASSERTOPENGL(
                        (pwnd->rclClient.right -
                         pwnd->rclClient.left) <= 0x0FFFF &&
                        (pwnd->rclClient.bottom -
                         pwnd->rclClient.top) <= 0x0FFFF,
                        "wglWndProc(): WM_MOVE - width/height overflow\n"
                        );

                    pwnd->rclClient.left   = pt.x;
                    pwnd->rclClient.right  = pt.x + width;
                    pwnd->rclClient.top    = pt.y;
                    pwnd->rclClient.bottom = pt.y + height;

#if 0
                    DbgPrint("move %d,%d - %d,%d\n",
                             pwnd->rclClient.left,
                             pwnd->rclClient.top,
                             pwnd->rclClient.right,
                             pwnd->rclClient.bottom);
#endif
                    
                    // At least clip to screen.

                    if (bClipToScreen(&pwnd->rclBounds,
                                      &pwnd->rclClient))
                        pwnd->clipComplexity = CLC_TRIVIAL;
                    else
                        pwnd->clipComplexity = CLC_RECT;

                    buffers = pwnd->buffers;
                    if (buffers)
                    {
                        buffers->WndUniq++;

                    // Don't let it hit -1.  -1 is special and is used by
                    // MakeCurrent to signal that an update is required

                        if (buffers->WndUniq == -1)
                            buffers->WndUniq = 0;

                        if ((gengc != NULL) && (pwnd == gengc->pwndLocked))
                            UpdateWindowInfo(gengc);
                    }
                }
                LEAVE_WINCRIT(pwnd);

                break;

            case WM_PALETTECHANGED:
                gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();
                
                // Use the non-gc enter to allow recursion.
                ENTER_WINCRIT(pwnd);
                {
                    pwnd->ulPaletteUniq++;
                    if ((gengc != NULL) && (pwnd == gengc->pwndLocked))
                        HandlePaletteChanges(gengc, pwnd);
                }
                LEAVE_WINCRIT(pwnd);

                break;

            case WM_NCDESTROY:
                pwndCleanup(pwnd);

            // WM_NCDESTROY (and WM_DESTROY) are sent after the window has
            // been removed from the screen.  The window area is invalid
            // but there is no API that allows us to dertermine that. This
            // allows multithreaded drawing to draw on the screen area
            // formerly occupied by the window.  On Win95, DirectDraw does
            // not force a repaint of the system when a window is destroyed.
            // Therefore, if we are running multiple threads on Win95,
            // we force a repaint of the desktop.  Note that multithreaded
            // does not mean that we are doing multithreaded drawing, but
            // its a reasonable approximation.

                if (WIN95_PLATFORM && (lThreadsAttached > 1))
                {
                    InvalidateRect(NULL, NULL, FALSE);
                }

                return lRet;

            default:
                break;
        }

    // If !WM_NCDESTROY, do OpenGL housekeeping before calling original
    // WndProc.

        ASSERTOPENGL(uiMsg != WM_NCDESTROY,
                     "WM_NCDESTROY processing didn't terminate\n");

        pwndRelease(pwnd);

        if (pfnWndProc)
            lRet = CallWindowProc(pfnWndProc, hwnd,
                                  uiMsg, wParam, lParam);
    }

    return lRet;
}

/******************************Public*Routine******************************\
*
* CreatePwnd
*
* Creates a window for the given surface
*
* History:
*  Thu Aug 29 10:33:59 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLGENwindow * APIENTRY CreatePwnd(GLWINDOWID *pgwid, int ipfd, int ipfdDevMax,
                                  DWORD dwObjectType, RECTL *prcl, BOOL *pbNew)
{
    GLGENwindow *pwnd;
    GLGENwindow wndInit;
    
    pwnd = pwndGetFromID(pgwid);

    if ( !pwnd )
    {
        memset(&wndInit, 0, sizeof(wndInit));

        wndInit.gwid = *pgwid;
        wndInit.ipfd = ipfd;
        wndInit.ipfdDevMax = ipfdDevMax;

        //!!!client driver
        //!!!dbug -- Move SetWindowLong call to pwndNew?!? Maybe move
        //!!!dbug    everything from this if.. clause to pwndNew?!?
        if ( wndInit.gwid.hwnd )
        {
            DWORD dwPid;

            if (GetWindowThreadProcessId(wndInit.gwid.hwnd,
                                         &dwPid) == 0xffffffff)
            {
                return NULL;
            }

            if (dwPid == GetCurrentProcessId())
            {
                wndInit.pfnOldWndProc =
                    (WNDPROC) SetWindowLongPtr(wndInit.gwid.hwnd,
                                            GWLP_WNDPROC, (LONG_PTR) wglWndProc);
            }
            else
            {
                wndInit.ulFlags |= GLGENWIN_OTHERPROCESS;

                // Start a thread to watch for palette changes
                if (!StartPaletteWatcher())
                {
                    return NULL;
                }
            }
            
            // Get *SCREEN* coordinates of client rectangle.

            GetClientRect(wndInit.gwid.hwnd, (LPRECT) &wndInit.rclClient);
            ClientToScreen(wndInit.gwid.hwnd, (LPPOINT) &wndInit.rclClient);
            wndInit.rclClient.right += wndInit.rclClient.left;
            wndInit.rclClient.bottom += wndInit.rclClient.top;
        }
        else if (dwObjectType == OBJ_DC)
        {
            // A direct DC without a window is treated like a DFB
            GetScreenRect( pgwid->hdc, &wndInit.rclClient );
        }
        else if (dwObjectType == OBJ_MEMDC)
        {
            DIBSECTION bmi;

        // Get bitmap dimensions.

            if ( !GetObject(GetCurrentObject(pgwid->hdc, OBJ_BITMAP),
                            sizeof(DIBSECTION), (LPVOID) &bmi) )
            {
                WARNING("wglSetPixelFormat(): GetObject failed\n");
                return NULL;
            }

            wndInit.rclClient.left   = 0;
            wndInit.rclClient.top    = 0;
            wndInit.rclClient.right  = bmi.dsBm.bmWidth;
            wndInit.rclClient.bottom = abs(bmi.dsBm.bmHeight);
        }
        else if (dwObjectType == OBJ_DDRAW)
        {
            // DirectDraw surface, use passed in rectangle
            ASSERTOPENGL(prcl != NULL, "NULL rect for DDraw surface\n");
            wndInit.rclClient = *prcl;

            // Record the surface vtbl pointer for later validation
            wndInit.pvSurfaceVtbl = *(void **)pgwid->pdds;
        }
        else
        {
            ASSERTOPENGL(dwObjectType == OBJ_ENHMETADC,
                         "Bad dwType in SetPixelFormat\n");
            
            // Initialize metafile DC's to have no size so all output
            // is clipped.  This is good because there's no surface
            // to draw on
            wndInit.rclClient.left   = 0;
            wndInit.rclClient.top    = 0;
            wndInit.rclClient.right  = 0;
            wndInit.rclClient.bottom = 0;
        }

        if (wndInit.gwid.hwnd)
        {
            // To be safe, at least clip bounds to screen.

            if (bClipToScreen(&wndInit.rclBounds,
                              &wndInit.rclClient))
                wndInit.clipComplexity = CLC_TRIVIAL;
            else
                wndInit.clipComplexity = CLC_RECT;
        }
        else
        {
            // Make bounds the same as client.
            wndInit.rclBounds = wndInit.rclClient;
            wndInit.clipComplexity = CLC_TRIVIAL;
        }

        pwnd = pwndNew(&wndInit);
        if (pwnd == NULL)
        {
            WARNING("wglSetPixelFormat: Unable to allocate new window\n");

            if ( wndInit.gwid.hwnd )
            {
                pwndUnsubclass(&wndInit, FALSE);
            }
        }

        *pbNew = TRUE;
    }
    else
    {
    // If the given pixel format is the same as the previous one, return
    // success.  Otherwise, as the pixel format can be set only once,
    // return error.

        if ( pwnd->ipfd != ipfd )
        {
            WARNING("wglSetPixelFormat: Attempt to set pixel format twice\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PIXEL_FORMAT);
            pwndRelease(pwnd);
            pwnd = NULL;
        }

        *pbNew = FALSE;
    }

    return pwnd;
}

/******************************Public*Routine******************************\
* wglGetPixelFormat
*
* Get the pixel format for the window or surface associated with the given
* DC.
*
* Returns:
*   0 if error or no pixel format was previously set in the window or
*   surface; current pixel format index otherwise
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI wglGetPixelFormat(HDC hdc)
{
    GLGENwindow *pwnd;
    int iRet = 0;
    GLWINDOWID gwid;

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);

    if (pwnd)
    {
        iRet = pwnd->ipfd;
        pwndRelease(pwnd);
    }
    else
    {
#if 0
	// Too noisy for normal operation
        WARNING("wglGetPixelFormat: No window for DC\n");
#endif
        SAVE_ERROR_CODE(ERROR_INVALID_PIXEL_FORMAT);
    }

    return iRet;
}

/*****************************Private*Routine******************************\
*
* EnterPixelFormatSection
*
* Enters pixel format exclusive code
*
* NOTE - Pixel format information is maintained in the client process
* so it is not synchronized between processes.  This means that two
* processes could successfully set the pixel format for a window.
* If the list becomes global, this synchronization code should also become
* cross-process aware.
*
* History:
*  Mon Jun 26 17:49:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define EnterPixelFormatSection() \
    (EnterCriticalSection(&gcsPixelFormat), TRUE)

/*****************************Private*Routine******************************\
*
* LeavePixelFormatSection
*
* Leaves pixel format exclusive code
*
* History:
*  Mon Jun 26 17:55:20 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define LeavePixelFormatSection() \
    LeaveCriticalSection(&gcsPixelFormat)

/******************************Public*Routine******************************\
* wglNumHardwareFormats
*
* Returns the number of hardware formats (ICD and MCD), supported on the
* specified hdc.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY wglNumHardwareFormats(HDC hdc, DWORD dwType,
                                    int *piMcd, int *piIcd)
{
// It is assumed that the caller has already validated the DC.

    ASSERTOPENGL((dwType == OBJ_DC) ||
                 (dwType == OBJ_MEMDC) ||
                 (dwType == OBJ_ENHMETADC) ||
                 (dwType == OBJ_DDRAW),
                 "wglNumHardwareFormats: bad hdc\n");

// Do not call MCD or ICD for enhanced metafile DCs.  In such a
// case, the code in ntgdi\client\output.c will return a non-zero value
// even if there are no ICD or MCD pixelformats.
#if _WIN32_WINNT >= 0x0501
    {
        BOOL wow64Process;

        if (IsWow64Process(GetCurrentProcess(), &wow64Process) && wow64Process)
            dwType = OBJ_ENHMETADC;
    }
#endif

    if ( dwType == OBJ_ENHMETADC )
    {
    // It's a metafile DC.  Therefore it cannot support MCD or ICD
    // (current OpenGL metafiling support would have to be modified
    // to allow this).

        *piIcd = 0;
        *piMcd = 0;
    }
    else
    {
    // Get ICD pixelformat count.

        *piIcd = __DrvDescribePixelFormat(hdc, 1, 0, NULL);

    // Get MCD pixelformat count.

#ifdef _MCD_
        if ( gpMcdTable || bInitMcd(hdc) )
            *piMcd = (gpMcdTable->pMCDDescribePixelFormat)(hdc, 1, NULL);
        else
            *piMcd = 0;
#else
        *piMcd = 0;
#endif
    }
}

/******************************Public*Routine******************************\
*
* GetCompatibleDevice
*
* Returns an HDC appropriate for making escape calls on.
* In the memdc case it returns a DC for the screen.
*
* History:
*  Wed Nov 20 17:48:57 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HDC GetCompatibleDevice(HDC hdc, DWORD dwObjectType)
{
    HDC hdcDriver;
    int iTech;
    
    hdcDriver = hdc;
    iTech = GetDeviceCaps(hdc, TECHNOLOGY);
    if ((dwObjectType == OBJ_MEMDC) && (iTech != DT_PLOTTER) &&
        (iTech != DT_RASPRINTER))
    {
        hdcDriver = GetDC(NULL);
    }

    return hdcDriver;
}

/******************************Public*Routine******************************\
* wglSetPixelFormat
*
* Set the pixel format for the window or surface associated with the given
* DC.
*
* Note:
* Since the pixel format is per-window data (per-DC for non-display DCs), a
* side effect of this call is to create a GLGENwindow structure.
*
* Note:
* For an installable client driver, a GLGENwindow structure is still created
* to track the pixel format and the driver structure (GLDRIVER).
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL WINAPI wglSetPixelFormat(HDC hdc, int ipfd,
                              CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    GLGENwindow *pwnd = NULL;
    int   ipfdDevMax, ipfdMcdMax;
    DWORD dwObjectType;
    BOOL  bRet = FALSE;
    GLWINDOWID gwid;
    BOOL  bNew;
    HDC hdcDriver;
    LPDIRECTDRAWSURFACE pdds;
    RECTL rcl, *prcl;
    DDSURFACEDESC ddsd;
        
//DBGPRINT1("wglSetPixelFormat: ipfd = %ld\n", ipfd);

// Validate DC.

    switch (dwObjectType = wglObjectType(hdc))
    {
    case OBJ_DC:
    case OBJ_MEMDC:
    case OBJ_ENHMETADC:
        break;
    default:
        WARNING1("wglSetPixelFormat: Attempt to set format of %d type DC\n",
                 dwObjectType);
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Take the pixel format mutex

    if (!EnterPixelFormatSection())
    {
        WARNING("wglSetPixelFormat: Unable to take pixel format mutex\n");
        return FALSE;
    }

// Get the number of hardware supported formats.

    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDriver) == DD_OK)
    {
        // Get the surface dimensions
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if (pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) != DD_OK)
        {
            goto LeaveSection;
        }

        rcl.left = 0;
        rcl.top = 0;
        rcl.right = ddsd.dwWidth;
        rcl.bottom = ddsd.dwHeight;
        prcl = &rcl;

        // Switch object type to identify this as a DirectDraw surface
        dwObjectType = OBJ_DDRAW;
    }
    else
    {
        pdds = NULL;
        prcl = NULL;
        
        hdcDriver = GetCompatibleDevice(hdc, dwObjectType);
        if (hdcDriver == NULL)
        {
            goto LeaveSection;
        }
    }
        
    wglNumHardwareFormats(hdcDriver, dwObjectType,
                          &ipfdMcdMax, &ipfdDevMax);

// Filter out invalid (out of range) pixel format indices.

    if ( (ipfd < 1) || (ipfd > (ipfdDevMax + ipfdMcdMax + MAX_GENERIC_PFD)) )
    {
        WARNING1("wglSetPixelFormat: ipfd %d out of range\n", ipfd);
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto LeaveSection;
    }

// If it exists, grab pwnd.  Otherwise, create one.

    WindowIdFromHdc(hdc, &gwid);
    pwnd = CreatePwnd(&gwid, ipfd, ipfdDevMax, dwObjectType, prcl, &bNew);
    if (pwnd == NULL)
    {
        goto LeaveSection;
    }

    if (bNew)
    {
// Dispatch driver formats.
// Driver is responsible for doing its own validation of the pixelformat.
// For generic formats, we call wglValidPixelFormat to validate.
// We do not send DirectDraw pixel format calls to the driver
// so that we avoid having new pixel format calls.

        if (dwObjectType != OBJ_DDRAW && ipfd <= ipfdDevMax)
        {
            bRet = __DrvSetPixelFormat(hdc, ipfd, (PVOID) pwnd);
#if DBG
            if (!bRet)
            {
                WARNING("__DrvSetPixelFormat failed\n");
            }
#endif
        }
        else
        {
            bRet = wglValidPixelFormat(hdc, ipfd, dwObjectType,
                                       pdds, &ddsd);
#if DBG
            if (!bRet)
            {
                WARNING("wglValidPixelFormat failed\n");
            }
#endif
        }

// If the pixel format is not valid or could not be set in the driver,
// cleanup and return error.

        if (!bRet)
        {
            goto FreeWnd;
        }
    }
    else
    {
        bRet = TRUE;
    }

    pwndRelease(pwnd);
    
LeaveSection:
    LeavePixelFormatSection();

    if (pdds != NULL)
    {
        pdds->lpVtbl->Release(pdds);
    }
    else if (hdcDriver != hdc)
    {
        ReleaseDC((HWND) NULL, hdcDriver);
    }
    
    return bRet;

FreeWnd:
    pwndCleanup(pwnd);
    goto LeaveSection;
}

/******************************Public*Routine******************************\
* wglChoosePixelFormat
*
* Choose the pixel format.
*
* Returns: 0 if error; best matching pixel format index otherwise
*
* History:
*
*  Sat Feb 10 11:55:22 1996     -by-    Hock San Lee    [hockl]
* Chose generic 16-bit depth buffer over 32-bit depth buffer.
* Added PFD_DEPTH_DONTCARE flag.
*
*  19-Oct-1994 Gilman Wong [gilmanw]
* Taken from GreChoosePixelFormat (gdi\gre\pixelfmt.cxx).
*
* History for gdi\gre\pixelfmt.cxx:
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

// Reserve some PFD_SUPPORT flags for other potential graphics systems
// such as PEX, HOOPS, Renderman etc.

#define PFD_SUPPORT_OTHER1         0x01000000
#define PFD_SUPPORT_OTHER2         0x02000000
#define PFD_SUPPORT_OTHER3         0x04000000
#define PFD_SUPPORT_OTHER4         0x08000000

// Scores for matching pixel formats

#define PFD_DRAW_TO_WINDOW_SCORE   0x10000    /* must match */
#define PFD_DRAW_TO_BITMAP_SCORE   0x01000
#define PFD_PIXEL_TYPE_SCORE       0x01000
#define PFD_SUPPORT_SCORE          0x01000
#define PFD_DOUBLEBUFFER_SCORE1    0x01000
#define PFD_DOUBLEBUFFER_SCORE2    0x00001
#define PFD_STEREO_SCORE1          0x01000
#define PFD_STEREO_SCORE2          0x00001
#define PFD_BUFFER_SCORE1          0x01010
#define PFD_BUFFER_SCORE2          0x01001
#define PFD_BUFFER_SCORE3          0x01000
// #define PFD_LAYER_TYPE_SCORE    0x01000
#define PFD_DEVICE_FORMAT_SCORE    0x00100
#define PFD_ACCEL_FORMAT_SCORE     0x00010
#define PFD_SUPPORT_DDRAW_SCORE    0x10000    /* must match */

//!!! Add code to choose overlays?

int WINAPI wglChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    PIXELFORMATDESCRIPTOR pfdIn = *ppfd;
    PIXELFORMATDESCRIPTOR pfdCurrent;

// Enumerate and find the best match.

    int ipfdBest = 1;           // assume the default is the best
    int iScoreBest = -1;
    int ipfdMax;
    int ipfd = 1;

    do
    {
        int iScore = 0;

        ipfdMax = wglDescribePixelFormat(hdc,ipfd,sizeof(PIXELFORMATDESCRIPTOR),&pfdCurrent);

        if (ipfdMax == 0)
            return(0);          // something went wrong

        if (pfdIn.iPixelType == pfdCurrent.iPixelType)
            iScore += PFD_PIXEL_TYPE_SCORE;

        if ((pfdIn.cColorBits == 0)
         || (pfdIn.cColorBits == pfdCurrent.cColorBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cColorBits < pfdCurrent.cColorBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cColorBits != 0)
            iScore += PFD_BUFFER_SCORE3;

        if (!(pfdIn.dwFlags & PFD_DRAW_TO_WINDOW)
         || (pfdCurrent.dwFlags & PFD_DRAW_TO_WINDOW))
            iScore += PFD_DRAW_TO_WINDOW_SCORE;

        if (!(pfdIn.dwFlags & PFD_DRAW_TO_BITMAP)
         || (pfdCurrent.dwFlags & PFD_DRAW_TO_BITMAP))
            iScore += PFD_DRAW_TO_BITMAP_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_GDI)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_GDI))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OPENGL)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OPENGL))
            iScore += PFD_SUPPORT_SCORE;

        if ((pfdIn.dwFlags & PFD_SUPPORT_DIRECTDRAW) == 0 ||
            (pfdCurrent.dwFlags & PFD_SUPPORT_DIRECTDRAW))
        {
            iScore += PFD_SUPPORT_DDRAW_SCORE;
        }
        
        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER1)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER1))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER2)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER2))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER3)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER3))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER4)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER4))
            iScore += PFD_SUPPORT_SCORE;

        if (pfdCurrent.dwFlags & PFD_GENERIC_ACCELERATED)
            iScore += PFD_ACCEL_FORMAT_SCORE;
        else if (!(pfdCurrent.dwFlags & PFD_GENERIC_FORMAT))
            iScore += PFD_DEVICE_FORMAT_SCORE;

        if ((pfdIn.dwFlags & PFD_DOUBLEBUFFER_DONTCARE)
         || ((pfdIn.dwFlags & PFD_DOUBLEBUFFER)
          == (pfdCurrent.dwFlags & PFD_DOUBLEBUFFER)))
            iScore += PFD_DOUBLEBUFFER_SCORE1;
        else if (pfdCurrent.dwFlags & PFD_DOUBLEBUFFER)
            iScore += PFD_DOUBLEBUFFER_SCORE2;

        if ((pfdIn.dwFlags & PFD_STEREO_DONTCARE)
         || ((pfdIn.dwFlags & PFD_STEREO)
          == (pfdCurrent.dwFlags & PFD_STEREO)))
            iScore += PFD_STEREO_SCORE1;
        else if (pfdCurrent.dwFlags & PFD_STEREO)
            iScore += PFD_STEREO_SCORE2;

        if ((pfdIn.cAlphaBits == 0)
         || (pfdIn.cAlphaBits == pfdCurrent.cAlphaBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cAlphaBits < pfdCurrent.cAlphaBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cAlphaBits != 0)
            iScore += PFD_BUFFER_SCORE3;

        if ((pfdIn.cAccumBits == 0)
         || (pfdIn.cAccumBits == pfdCurrent.cAccumBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cAccumBits < pfdCurrent.cAccumBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cAccumBits != 0)
            iScore += PFD_BUFFER_SCORE3;

// Some applications (e.g. GLview browser) specifies a 0-bit depth buffer
// but expect this function to return a pixel format with a depth buffer.
// This works in NT 3.51 since all pixel formats have a depth buffer.
// When pixel formats with no depth buffer were added in NT 4.0, these
// applications stopped working.  The flag PFD_DEPTH_DONTCARE is added to
// indicate that no depth buffer is required.  If this flags is not given,
// this function will attempt to select a pixel format with a depth buffer.

	if (pfdIn.dwFlags & PFD_DEPTH_DONTCARE)
	{
	    if (pfdCurrent.cDepthBits == 0)
		iScore += PFD_BUFFER_SCORE1;
	    else
		iScore += PFD_BUFFER_SCORE2;
	}
	else if (pfdCurrent.cDepthBits != 0)
	{
	    if ((pfdIn.cDepthBits == 0)
	     || (pfdIn.cDepthBits == pfdCurrent.cDepthBits))
		iScore += PFD_BUFFER_SCORE1;
	    else if (pfdIn.cDepthBits < pfdCurrent.cDepthBits)
		iScore += PFD_BUFFER_SCORE2;
	    else if (pfdCurrent.cDepthBits != 0)
		iScore += PFD_BUFFER_SCORE3;
	}

        if ((pfdIn.cStencilBits == 0)
         || (pfdIn.cStencilBits == pfdCurrent.cStencilBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cStencilBits < pfdCurrent.cStencilBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cStencilBits != 0)
            iScore += PFD_BUFFER_SCORE3;

        if ((pfdIn.cAuxBuffers == 0)
         || (pfdIn.cAuxBuffers == pfdCurrent.cAuxBuffers))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cAuxBuffers < pfdCurrent.cAuxBuffers)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cAuxBuffers != 0)
            iScore += PFD_BUFFER_SCORE3;

#if 0
        DbgPrint("%2d: score is %8X, best %8X (%2d)\n",
                 ipfd, iScore, iScoreBest, ipfdBest);
#endif
        
        if (iScore > iScoreBest)
        {
            iScoreBest = iScore;
            ipfdBest = ipfd;
        }
        else if (iScore == iScoreBest)
        {
// When everything is equal, we should choose the pixel format with a
// smaller depth size for better performance, provided that the smaller
// depth buffer satisfies the request.  The best way to do this is to
// order pixel formats such that one with smaller depth buffer comes
// first.  In NT 3.51, however, the generic pixel format was not ordered
// this way.  As a result, pixel formats with 32-bit depth buffer are
// choosen by default.  To maintain compatibility, we modify the selection
// here without reordering generic pixel formats.

            if ((pfdCurrent.dwFlags & PFD_GENERIC_FORMAT) &&
#ifdef _MCD_
                !(pfdCurrent.dwFlags & PFD_GENERIC_ACCELERATED) &&
#endif
                (pfdIn.cDepthBits < 16 || pfdIn.dwFlags & PFD_DEPTH_DONTCARE) &&
                (pfdCurrent.cDepthBits == 16) &&
                (ipfd == ipfdBest + 1))
            {
                ipfdBest = ipfd;
            }
        }

        ipfd++;
    } while (ipfd <= ipfdMax);

    return(ipfdBest);
}

/******************************Public*Routine******************************\
*
* MaskToBitsAndShift
*
* Counts bits in a mask and determines shift
* Set bits must be contiguous
*
* History:
*  Mon Aug 26 14:16:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY MaskToBitsAndShift(DWORD dwMask, BYTE *pbBits, BYTE *pbShift)
{
    DWORD dwBit;

    *pbBits = 0;
    *pbShift = 0;
    
    /* Determine first set bit and accumulate shift count */
    dwBit = 0x1;
    while ((dwMask & dwBit) == 0)
    {
        dwBit <<= 1;
        (*pbShift)++;
    }

    /* Count set bits */
    while ((dwMask & dwBit) != 0)
    {
        dwBit <<= 1;
        (*pbBits)++;
    }

    /* No other bits in the mask can be set */
    ASSERTOPENGL(((*pbBits+*pbShift) == (sizeof(dwMask)*8)) ||
                 ((dwMask >> (*pbBits+*pbShift)) == 0),
                 "Invalid mask\n");
}

/*****************************Private*Routine******************************\
*
* ComputeBitsFromMasks
*
* Determines the values for c*Bits and c*Shift from BI_BITFIELD
* channel masks
*
* History:
*  Tue Feb 14 10:50:10 1995     -by-    Drew Bliss [drewb]
*   Created by pulling out duplicated code
*
\**************************************************************************/

static void ComputeBitsFromMasks(PIXELFORMATDESCRIPTOR *ppfd,
                                 DWORD dwRedMask, DWORD dwGreenMask,
                                 DWORD dwBlueMask)
{
    /* Masks can't be zero and they can't overlap */
    ASSERTOPENGL(dwRedMask != 0 &&
                 dwGreenMask != 0 &&
                 dwBlueMask != 0,
                 "Bitfield mask is zero");
    ASSERTOPENGL((dwRedMask & dwGreenMask) == 0 &&
                 (dwRedMask & dwBlueMask) == 0 &&
                 (dwGreenMask & dwBlueMask) == 0,
                 "Bitfield masks overlap");

    MaskToBitsAndShift(dwRedMask, &ppfd->cRedBits, &ppfd->cRedShift);
    MaskToBitsAndShift(dwGreenMask, &ppfd->cGreenBits, &ppfd->cGreenShift);
    MaskToBitsAndShift(dwBlueMask, &ppfd->cBlueBits, &ppfd->cBlueShift);
}

/******************************Public*Routine******************************\
* __wglGetDdFormat
*
* Special case of __wglGetBitfieldColorFormat to support DirectDraw
* surfaces.  Fills in the cRedBits, cRedShift, cGreenBits, etc. fields
* of the PIXELFORMATDESCRIPTOR for 16, 24, and 32bpp direct surfaces.
*
* This is done by interpreting the given surface information
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void __wglGetDdFormat(DDSURFACEDESC *pddsd,
                      PIXELFORMATDESCRIPTOR *ppfd)
{
    // This routine should only be called for bitfield formats, but
    // random mode changes in the middle of certain calls could cause
    // it to be called with non-bitfield formats.
    //
    // When such a mode change occurs OpenGL should not crash but
    // does not necessarily have to produce correct output
    
    if ((pddsd->ddpfPixelFormat.dwFlags & DDPF_RGB) == 0 ||
        (pddsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                           DDPF_PALETTEINDEXED2 |
                                           DDPF_PALETTEINDEXED4 |
                                           DDPF_PALETTEINDEXED8)))
    {
        WARNING1("__wglGetDdFormat called with 0x%08lX ddpf flags\n",
                 pddsd->ddpfPixelFormat.dwFlags);
        
        ppfd->cRedBits = 8;
        ppfd->cRedShift = 0;
        ppfd->cGreenBits = 8;
        ppfd->cGreenShift = 0;
        ppfd->cBlueBits = 8;
        ppfd->cBlueShift = 0;
    }
    else
    {
        ComputeBitsFromMasks(ppfd,
                             pddsd->ddpfPixelFormat.dwRBitMask,
                             pddsd->ddpfPixelFormat.dwGBitMask,
                             pddsd->ddpfPixelFormat.dwBBitMask);
    }
}

/******************************Public*Routine******************************\
* __wglGetBitfieldColorFormat
*
* Fills in the cRedBits, cRedShift, cGreenBits, etc. fields of the
* PIXELFORMATDESCRIPTOR for 16, 24, and 32bpp surfaces (either device
* or bitmap surfaces).
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* This function is used to describe the color format for both the underlying
* surface and for the device.  This is the same thing if the DC is a
* display DC.  However, for a memory DC, the surface and the device may have
* different formats.  The bDescribeSurf flag indicates whether the caller
* wants the decription of the device (FALSE) or the surface (TRUE).
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
__wglGetBitfieldColorFormat(HDC hdc, UINT cColorBits, PIXELFORMATDESCRIPTOR *ppfd,
                            BOOL bDescribeSurf)
{
    HBITMAP hbm = (HBITMAP) NULL;
    BOOL    bRet = FALSE;
    HDC hdcDriver;

#if DBG
// Dynamic color depth changes can cause this.  It will not cause us to crash,
// but drawing (color) may be incorrect.

    if ((GetObjectType(hdc) == OBJ_DC) &&
        (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        WARNING("Palette managed device that is greater than 8 bits\n");
    }

    if (cColorBits < 16)
    {
        WARNING("__wglGetBitfieldColorFormat with cColorBits < 16\n");
    }
#endif

// Handle direct case.

    if ( GLDIRECTSCREEN && wglIsDirectDevice(hdc) )
    {
        __wglGetDdFormat(&GLSCREENINFO->gdds.ddsd, ppfd);
        return TRUE;
    }

// Create a dummy bitmap from which we can query color format info.
//
// If we want a device format AND its a MEM_DC AND NOT a printer or plotter,
// then we need to create a compatible bitmap from a display DC (not the mem
// DC passed into this function).
//
// Otherwise, the format of the surface (whether bitmap or device) associated
// with the DC passed in will suffice.
//
// WinNT does not care, but the Win95 GetDIBits call might
// fail if we use a memory DC.  Specifically, if the memory
// DC contains a surface that does not match the display
// (remember, the new bitmap is compatible with the display)
// the Win95 GetDIBits call will fail.
//
// So use the display DC.  It works on both platforms.

    if (!bDescribeSurf)
    {
        hdcDriver = GetCompatibleDevice(hdc, GetObjectType(hdc));
        if (hdcDriver == NULL)
        {
            return FALSE;
        }
    }
    else
    {
        hdcDriver = hdc;
    }
    
    hbm = CreateCompatibleBitmap(hdcDriver, 1, 1);
    if ( !hbm )
    {
        WARNING("__wglGetBitfieldColorFormat: "
                "CreateCompatibleBitmap failed\n");
    }

// Get the color format by calling GetDIBits.

    else
    {
        BYTE ajBitmapInfo[sizeof(BITMAPINFO) + 3*sizeof(DWORD)];
        BITMAPINFO *pbmi = (BITMAPINFO *) ajBitmapInfo;
        int iRet;

        //!!!dbug -- Init masks to zero so we can
        // tell if they are set by GetDIBits.
        memset(pbmi, 0, sizeof(ajBitmapInfo));
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        // Call first time to fill in BITMAPINFO header.
        iRet = GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

#if DBG
        if (pbmi->bmiHeader.biBitCount != cColorBits)
            WARNING2("__wglGetBitfieldColorFormat: bit count != BITSPIXEL "
                     " (%ld, %ld)\n", pbmi->bmiHeader.biBitCount, cColorBits);
#endif

        switch ( pbmi->bmiHeader.biCompression )
        {
        case BI_RGB:

#if DBG
        // Dynamic color depth changes can cause this.  It will not cause
        // us to crash, but drawing (color) may be incorrect.

            if (pbmi->bmiHeader.biBitCount != cColorBits)
            {
                WARNING("__wglGetBitfieldColorFormat(): bit count mismatch\n");
            }
#endif

        // Default DIB format.  Color masks are implicit for each bit depth.

            switch ( pbmi->bmiHeader.biBitCount )
            {
            case 16:
                // 16bpp default is 555 BGR-ordering
                ppfd->cRedBits   = 5; ppfd->cRedShift   = 10;
                ppfd->cGreenBits = 5; ppfd->cGreenShift =  5;
                ppfd->cBlueBits  = 5; ppfd->cBlueShift  =  0;
                bRet = TRUE;
                break;

            case 24:
            case 32:
                // 24 and 32bpp default is 888 BGR-ordering
                ppfd->cRedBits   = 8; ppfd->cRedShift   = 16;
                ppfd->cGreenBits = 8; ppfd->cGreenShift =  8;
                ppfd->cBlueBits  = 8; ppfd->cBlueShift  =  0;
                bRet = TRUE;
                break;

            default:
                break;
            }

            break;

        case BI_BITFIELDS:

        // Some drivers seem to return bitfields for everything that's
        // not paletted.  They return correct BGR bitfields so we
        // operate correctly, so remove this assert
#ifdef STRICT_BITFIELD_CHECK
            ASSERTOPENGL(
                    cColorBits == 16 || cColorBits == 32,
                    "__wglGetBitfieldColorFormat(): "
                    "BI_BITFIELDS surface not 16 or 32bpp\n"
                );
#endif

            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            iRet = GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL,
                             pbmi, DIB_RGB_COLORS);

            ComputeBitsFromMasks(ppfd,
                                 *(DWORD *)&pbmi->bmiColors[0],
                                 *(DWORD *)&pbmi->bmiColors[1],
                                 *(DWORD *)&pbmi->bmiColors[2]);

            bRet = TRUE;
            break;

        default:
            RIP("__wglGetBitfieldColorFormat(): bad biCompression\n");
            break;
        }

        DeleteObject(hbm);
    }

    if ( hdcDriver != hdc )
    {
        ReleaseDC((HWND) NULL, hdcDriver);
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* wglGetDeviceDepth
*
* Returns the depth of the given HDC
* Primarily used to workaround potential problems with printers
* that lie about their depth in GetDeviceCaps
*
* History:
*  Tue Apr 09 16:52:47 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int wglGetDeviceDepth(HDC hdc)
{
    int iTech;

    // If this is an enhanced metafile it should return the technology
    // of the reference device
    iTech = GetDeviceCaps(hdc, TECHNOLOGY);
    if (iTech == DT_PLOTTER || iTech == DT_RASPRINTER)
    {
        HBITMAP hbm;
        BYTE ajBitmapInfo[sizeof(BITMAPINFO) + 3*sizeof(DWORD)];
        BITMAPINFO *pbmi = (BITMAPINFO *) ajBitmapInfo;
        int iRet;
        
        // We're dealing with a printer or a metafile that has a printer
        // as a reference device
        // Find out the true depth by creating a compatible
        // bitmap and querying its format
        if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
        {
            memset(pbmi, 0, sizeof(ajBitmapInfo));
            pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            iRet = GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);
            
            DeleteObject(hbm);
            
            return iRet != 0 ? pbmi->bmiHeader.biBitCount : -1;
        }

        // Failure
        return -1;
    }
    else
    {
        // We're dealing with a well-behaved DC so just return
        // the normal depth
        return GetDeviceCaps(hdc, BITSPIXEL)*GetDeviceCaps(hdc, PLANES);
    }
}

/******************************Public*Routine******************************\
* wglDescribePixelFormat
*
* Describe the pixel format.
* If cjpfd is 0, just return the maximum pixel format index.
*
* Returns: 0 if error; maximum pixel format index otherwise
*
* History:
*  19-Oct-1994 Gilman Wong [gilmanw]
* Adapted from GreDescribePixelFormat (gdi\gre\pixelfmt.cxx).
*
* History for gdi\gre\pixelfmt.cxx:
*  Mon Apr 25 15:34:32 1994     -by-    Hock San Lee    [hockl]
* Added 16-bit Z buffer formats and removed double buffered formats for bitmaps.
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

// Here are the generic formats that we enumerate.  ChoosePixelFormat code
// assumes that generic pixel formats with z32 comes before z16 as given below:
//
// I. Native formats:
//
//   1. rgb.sb.z32.a0
//   2. rgb.sb.z16.a0
//   3. rgb.db.z32.a0
//   4. rgb.db.z16.a0
//   5. rgb.sb.z32.a8
//   6. rgb.sb.z16.a8
//   7. rgb.db.z32.a8
//   8. rgb.db.z16.a8
//   9.  ci.sb.z32
//   10. ci.sb.z16
//   11. ci.db.z32
//   12. ci.db.z16
//
// II. Other formats:
//
//   1. rgb.sb.z32.a0
//   2. rgb.sb.z16.a0
//   3. rgb.sb.z32.a8
//   4. rgb.sb.z16.a8
//   5.  ci.sb.z32
//   6.  ci.sb.z16
//
// We always enumerate the native formats first followed by other formats
// in the BPP order {24, 32, 16, 8, 4} for a total of 1 * 12 + 4 * 6 = 36
// pixel formats.

// Highest native format generic pixel format index.
#define MAX_NATIVE_GENERIC_PFD 12
// Number of non-native formats in a non-native group.
#define NON_NATIVE_PFD_GROUP 6

static BYTE aabPixelBits[BMF_COUNT][4] =
{
    {24, 32, 16, 8},    // error
    {24, 32, 16, 8},    // 1 bpp
    {24, 32, 16, 8},    // 4 bpp
    {24, 32, 16, 4},    // 8 bpp
    {24, 32,  8, 4},    // 16 bpp
    {32, 16,  8, 4},    // 24 bpp
    {24, 16,  8, 4}     // 32 bpp
};

static BYTE abPixelType[MAX_GENERIC_PFD] =
{
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX,PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX
};

int WINAPI InternalDescribePixelFormat(HDC hdc, HDC hdcDriver,
                                       int ipfd, UINT cjpfd,
                                       LPPIXELFORMATDESCRIPTOR ppfd,
                                       int ipfdDevMax, int ipfdMcdMax,
                                       LPDIRECTDRAWSURFACE pdds,
                                       DDSURFACEDESC *pddsd)
{
    int iRet = 0;
    int ipfdGen;
    UINT iDitherFormat;
    BYTE cColorBitsNative;
    
// If cjpfd is 0, just return the maximum pixel format index.

    if (cjpfd == 0 || ppfd == NULL)
    {
        iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;
        goto wglDescribePixelFormat_cleanup;
    }

// Validate the size of the pixel format descriptor.

    if (cjpfd < sizeof(PIXELFORMATDESCRIPTOR))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto wglDescribePixelFormat_cleanup;
    }

// Validate pixel format index.
// If a driver support device pixel formats 1..ipfdDevMax, the generic
// pixel formats will be (ipfdDevMax+1)..(ipfdDevMax+MAX_GENERIC_PFD).
// Otherwise, ipfdDevMax is 0 and the generic pixel formats are
// 1..MAX_GENERIC_PFD.

    if ((ipfd < 1) || (ipfd > ipfdDevMax + ipfdMcdMax + MAX_GENERIC_PFD))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto wglDescribePixelFormat_cleanup;
    }

// Dispatch ICD driver formats.

    if (ipfd <= ipfdDevMax)
    {
        int iDrvRet = __DrvDescribePixelFormat(hdcDriver,ipfd,cjpfd,ppfd);
        if (iDrvRet)
        {
            ASSERTOPENGL(iDrvRet == ipfdDevMax,
                         "wglDescribePixelFornat: Bad ipfdDevMax");
            iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;
        }

        goto wglDescribePixelFormat_cleanup;
    }

#ifdef _MCD_
// Dispatch MCD driver formats.

    ipfdGen = ipfd - ipfdDevMax;
    if (ipfdGen <= ipfdMcdMax)
    {
        int iMcdRet;

    // Note: don't need to check if gpMcdTable is valid because we can't get
    // here unless ipfdDevMax is non-zero and that can't happen unless the
    // the table is valid.

        ASSERTOPENGL(gpMcdTable, "wglDescribePixelFormat: bad MCD table\n");

        iMcdRet = (gpMcdTable->pMCDDescribePixelFormat)(hdcDriver, ipfdGen,
                                                        ppfd);
        if (iMcdRet)
        {
            ASSERTOPENGL(iMcdRet == ipfdMcdMax,
                         "wglDescribePixelFornat: Bad ipfdMcdMax");
            iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;
        }

        goto wglDescribePixelFormat_cleanup;
    }

// Generic implementation.
// Normalize the generic pixel format index to 0..(MAX_GENERIC_PFD-1).

    ipfdGen = ipfdGen - ipfdMcdMax - 1;
#else
// Generic implementation.
// Normalize the generic pixel format index to 0..(MAX_GENERIC_PFD-1).

    ipfdGen = ipfd - ipfdDevMax - 1;
#endif

// Get the native BPP format.

    if (pdds != NULL)
    {
        cColorBitsNative = DdPixelDepth(pddsd);
    }
    else
    {
        cColorBitsNative = (BYTE)wglGetDeviceDepth(hdc);
    }
    
    if (cColorBitsNative < 1)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto wglDescribePixelFormat_cleanup;
    }

    if (cColorBitsNative <= 1)
    {
        cColorBitsNative = 1;
        iDitherFormat = BMF_1BPP;
    }
    else if (cColorBitsNative <= 4)
    {
        cColorBitsNative = 4;
        iDitherFormat = BMF_4BPP;
    }
    else if (cColorBitsNative <= 8)
    {
        cColorBitsNative = 8;
        iDitherFormat = BMF_8BPP;
    }
    else if (cColorBitsNative <= 16)
    {
        cColorBitsNative = 16;
        iDitherFormat = BMF_16BPP;
    }
    else if (cColorBitsNative <= 24)
    {
        cColorBitsNative = 24;
        iDitherFormat = BMF_24BPP;
    }
    else
    {
        cColorBitsNative = 32;
        iDitherFormat = BMF_32BPP;
    }

// Fill in the pixel format descriptor.

    ppfd->nSize      = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion   = 1;
    ppfd->iPixelType = abPixelType[ipfdGen];

    if (ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        ppfd->cColorBits = max(cColorBitsNative, 4);    // 1 bpp not supported
    }
    else
    {
        ppfd->cColorBits = aabPixelBits[iDitherFormat]
            [(ipfdGen - MAX_NATIVE_GENERIC_PFD) / NON_NATIVE_PFD_GROUP];
    }

// If the color format is compatible to that of the device and the
// color bits is 16 or greater, use the device description.
// Otherwise, use the generic format.

    if (ipfdGen < MAX_NATIVE_GENERIC_PFD && cColorBitsNative >= 16)
    {
// Handle compatible formats that are greater than 16-bits.

        if (pdds != NULL)
        {
            __wglGetDdFormat(pddsd, ppfd);
        }
        else if ( !__wglGetBitfieldColorFormat(hdc, cColorBitsNative,
                                               ppfd, FALSE) )
        {
        // Don't know how to deal with this device!

            WARNING("Unknown device format");
            SAVE_ERROR_CODE(ERROR_NOT_SUPPORTED);
            goto wglDescribePixelFormat_cleanup;
        }
    }
    else
    {
// Handle generic formats.

        switch (ppfd->cColorBits)
        {
        case 4:
            ppfd->cRedBits   = 1; ppfd->cRedShift   = 0;
            ppfd->cGreenBits = 1; ppfd->cGreenShift = 1;
            ppfd->cBlueBits  = 1; ppfd->cBlueShift  = 2;
            break;
        case 8:
            ppfd->cRedBits   = 3; ppfd->cRedShift   = 0;
            ppfd->cGreenBits = 3; ppfd->cGreenShift = 3;
            ppfd->cBlueBits  = 2; ppfd->cBlueShift  = 6;
            break;
        case 16:
            /*
            ** Even though Win95 allows arbitrary bitfield definitions
            ** for 16bpp DIBs, only 555BGR is usable by Win95's GDI.
            */
            ppfd->cRedBits   = 5; ppfd->cRedShift   = 10;   // 555BGR
            ppfd->cGreenBits = 5; ppfd->cGreenShift =  5;
            ppfd->cBlueBits  = 5; ppfd->cBlueShift  =  0;
            break;
        case 24:
        case 32:
            /*
            ** Even though Win95 allows arbitrary bitfield definitions
            ** for 32bpp, only 888BGR is usable by Win95's GDI.  Similarly,
            ** NT has the concept of a RGB 24bpp DIB, but Win95 does not.
            */
            ppfd->cRedBits   = 8; ppfd->cRedShift   = 16;   // 888BGR
            ppfd->cGreenBits = 8; ppfd->cGreenShift =  8;
            ppfd->cBlueBits  = 8; ppfd->cBlueShift  =  0;
            break;
        default:
            ASSERTOPENGL(FALSE, "wglDescribePixelFornat: Unknown format");
            break;
        }
    }

    ppfd->cAlphaBits    = 0;
    ppfd->cAlphaShift   = 0;
    if ( ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        // Only report alpha bits if the DirectDraw surface has them.
        if (pdds != NULL)
        {
            if (pddsd->ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)
            {
                ASSERTOPENGL(pddsd->dwFlags & DDSD_ALPHABITDEPTH,
                             "Surface with alpha but no bit depth set\n");
                
                ppfd->cAlphaBits = (BYTE)pddsd->dwAlphaBitDepth;
            }
        }
        else if ( (ipfdGen > 3) && (ipfdGen < 8) )
        {
            ppfd->cAlphaBits = 8;
        }
    }
    else
    {
        int ipfd = (ipfdGen - MAX_NATIVE_GENERIC_PFD) % NON_NATIVE_PFD_GROUP;
        if ( (ipfd == 2) || (ipfd == 3) )
        {
            ppfd->cAlphaBits = 8;
        }
    }

    if (ppfd->iPixelType == PFD_TYPE_RGBA)
    {
        if (ppfd->cColorBits <= 16)
        {
            if (ppfd->cColorBits < 8)
            {
                // !!! Internally now, we will actually be using a 32-bit accum
                // buffer, but the user will think it's 16 (This is for 
                // backwards compatibility).
                ppfd->cAccumBits = 16;
                if( ppfd->cAlphaBits )
                {
                    ppfd->cAccumRedBits   = 4;
                    ppfd->cAccumGreenBits = 4;
                    ppfd->cAccumBlueBits  = 4;
                    ppfd->cAccumAlphaBits = 4;
                }
                else
                {
                    ppfd->cAccumRedBits   = 5;
                    ppfd->cAccumGreenBits = 6;
                    ppfd->cAccumBlueBits  = 5;
                    ppfd->cAccumAlphaBits = 0;
                }
            }
            else 
            {
                ppfd->cAccumBits = 32;
                if( ppfd->cAlphaBits )
                {
                    ppfd->cAccumRedBits   = 8;
                    ppfd->cAccumGreenBits = 8;
                    ppfd->cAccumBlueBits  = 8;
                    ppfd->cAccumAlphaBits = 8;
                }
                else
                {
                    ppfd->cAccumRedBits   = 11;
                    ppfd->cAccumGreenBits = 11;
                    ppfd->cAccumBlueBits  = 10;
                    ppfd->cAccumAlphaBits = 0;
                }
            }
        }
        else
        {
            ppfd->cAccumBits = 64;

            if( ppfd->cAlphaBits )
            {
                ppfd->cAccumRedBits   = 16;
                ppfd->cAccumGreenBits = 16;
                ppfd->cAccumBlueBits  = 16;
                ppfd->cAccumAlphaBits = 16;
            }
            else
            {
                ppfd->cAccumRedBits   = 16;
                ppfd->cAccumGreenBits = 16;
                ppfd->cAccumBlueBits  = 16;
                ppfd->cAccumAlphaBits = 0;
            }
        }
    }
    else
    {
        ppfd->cAccumBits      = 0;
        ppfd->cAccumRedBits   = 0;
        ppfd->cAccumGreenBits = 0;
        ppfd->cAccumBlueBits  = 0;
        ppfd->cAccumAlphaBits = 0;
    }

// Generic formats alternate between 16- and 32-bit depth buffer.  Evens
// are 32-bit, odds are 16-bit.
// DirectDraw surfaces always report the depth of the attached Z buffer
// for the native format indices.

    if (pdds != NULL && ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        DDSCAPS ddscaps;
        LPDIRECTDRAWSURFACE pddsZ;
        
        // DDraw surfaces may not have attached Z buffers, in which case
        // we should not report depth bits.  If one is attached, its
        // depth should be reported.
        // We only do this processing for native pixel formats.
        
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_ZBUFFER;
        if (pdds->lpVtbl->
            GetAttachedSurface(pdds, &ddscaps, &pddsZ) == DD_OK)
        {
            HRESULT hr;
            DDSURFACEDESC ddsdZ;
                
            memset(&ddsdZ, 0, sizeof(ddsdZ));
            ddsdZ.dwSize = sizeof(ddsdZ);
                
            hr = pddsZ->lpVtbl->GetSurfaceDesc(pddsZ, &ddsdZ);
            
            pddsZ->lpVtbl->Release(pddsZ);

            if (hr != DD_OK)
            {
                goto wglDescribePixelFormat_cleanup;
            }

            ppfd->cDepthBits =
                (BYTE)DdPixDepthToCount(ddsdZ.ddpfPixelFormat.
                                        dwZBufferBitDepth);
        }
        else
        {
            ppfd->cDepthBits = 0;
        }
    }
    else if (ipfdGen & 0x1)
    {
        ppfd->cDepthBits = 16;
    }
    else
    {
        ppfd->cDepthBits = 32;
    }
    
    ppfd->cStencilBits  = 8;
    ppfd->cAuxBuffers   = 0;
    ppfd->iLayerType    = PFD_MAIN_PLANE;
    ppfd->bReserved     = 0;
    ppfd->dwLayerMask   = 0;
    ppfd->dwVisibleMask = 0;
    ppfd->dwDamageMask  = 0;

// Compute the buffer flags.
// Support OpenGL in all generic formats.

    ppfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_GENERIC_FORMAT;

    // Indicate DirectDraw support on native pixel formats for DD surfaces.
    if (pdds != NULL && ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        ppfd->dwFlags |= PFD_SUPPORT_DIRECTDRAW;
    }
    
// Bitmaps and GDI drawing are available in single buffered mode only.

    if (pdds == NULL &&
        (ipfdGen == 2 || ipfdGen == 3 || ipfdGen == 6 || ipfdGen == 7 ||
         ipfdGen == 10 || ipfdGen == 11))
    {
        ppfd->dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_COPY;
    }
    else
    {
        ppfd->dwFlags |= PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI;
    }

// Draw to window or device surface only if the format is compatible.

    if (ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        ppfd->dwFlags |= PFD_DRAW_TO_WINDOW;

// Need a palette if it is a RGBA pixel type on a palette managed device.

        if (ppfd->cColorBits == 8 && ppfd->iPixelType == PFD_TYPE_RGBA)
        {
            ppfd->dwFlags |= PFD_NEED_PALETTE;
        }
    }

// If this is a 1 bpp surface, we don't support drawing to window and
// double buffered mode.  Re-set the buffer flags.

    if (cColorBitsNative < 4)
    {
#ifndef GL_METAFILE
        ASSERTOPENGL(ppfd->cColorBits == 4,
            "wglDescribePixelFormat: bad cColorBits for 1 bpp surface\n");
#endif

        ppfd->dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI |
            PFD_SUPPORT_OPENGL | PFD_GENERIC_FORMAT;
    }

// To support other potential graphics systems, we reserve the following
// flags in the pixel format descriptor.  For example, PEX may use
// PFD_SUPPORT_OTHER1 on the system that supports PEX.  Since we don't
// support these other systems in the generic implementation, they belong
// to the device pixel format descriptor.

    ASSERTOPENGL(!(ppfd->dwFlags & (PFD_SUPPORT_OTHER1 | PFD_SUPPORT_OTHER2 |
                                    PFD_SUPPORT_OTHER3 | PFD_SUPPORT_OTHER4)),
                 "dwFlags reserved for device formats\n");

    iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;

wglDescribePixelFormat_cleanup:

    return iRet;
}

int WINAPI wglDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                  LPPIXELFORMATDESCRIPTOR ppfd)
{
    int iRet = 0;
    int ipfdDevMax, ipfdMcdMax;
    DWORD dwObjectType;
    HDC hdcDriver = NULL;
    LPDIRECTDRAWSURFACE pdds;
    DDSURFACEDESC ddsd;

// Validate DC.

    switch (dwObjectType = wglObjectType(hdc))
    {
    case OBJ_DC:
    case OBJ_MEMDC:
    case OBJ_ENHMETADC:
        break;
    default:
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Check to see if this is a DirectDraw DC.  If it is, use the
    // device DC returned from DirectDraw.
    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDriver) == DD_OK)
    {
        // pdds reference must be released before exiting this function.

        // Retrieve surface description for later use.
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if (pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) != DD_OK)
        {
            goto wglDescribePixelFormat_cleanup;
        }
    }
    else
    {
        pdds = NULL;
        
        hdcDriver = GetCompatibleDevice(hdc, dwObjectType);
        if (hdcDriver == NULL)
        {
            goto wglDescribePixelFormat_cleanup;
        }

        // NOTE: From this point on, all exit cases must cleanup hdcDriver
    }

// Get the number of hardware supported formats.

    wglNumHardwareFormats(hdcDriver, dwObjectType, &ipfdMcdMax, &ipfdDevMax);

    iRet = InternalDescribePixelFormat(hdc, hdcDriver, ipfd, cjpfd, ppfd,
                                       ipfdDevMax, ipfdMcdMax,
                                       pdds, &ddsd);
    
wglDescribePixelFormat_cleanup:

    if (pdds != NULL)
    {
        pdds->lpVtbl->Release(pdds);
    }
    else if (hdcDriver != hdc)
    {
        ReleaseDC((HWND) NULL, hdcDriver);
    }

    return iRet;
}

#ifdef _MCD_
/******************************Public*Routine******************************\
* GenMcdGenericCompatibleFormat
*
* Determines if pixelformat in gengc can be supported by generic code.
*
* Note:
*   The implication of not being compatible is that generic cannot be
*   used for driver kickbacks and MCD contexts cannot be converted.
*
* Returns:
*   TRUE if compatible, FALSE otherwise.
*
* History:
*  04-Jun-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdGenericCompatibleFormat(__GLGENcontext *gengc)
{
    PIXELFORMATDESCRIPTOR *ppfd;

// Software-only formats are definitely supported.

    ppfd = &gengc->gsurf.pfd;
    if ((ppfd->dwFlags & (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED))
        == PFD_GENERIC_FORMAT)
        return TRUE;

// Layer planes are not supported.

    if (gengc->iLayerPlane)
        return FALSE;

// Generic is PFD_SWAP_COPY only.  There can't be many apps that rely
// on PFD_SWAP_EXCHANGE behavior (usually they look for PFD_SWAP_COPY
// so the back buffer can be used as backing store), but for now I think
// we should be conservative.
//
// Note: most MGA cards will set PFD_SWAP_COPY or neither (i.e., either
// style might be used depending on window size).

    if (ppfd->dwFlags & PFD_SWAP_EXCHANGE)
        return FALSE;

// Can only support 8bpp stencils.

    if ((ppfd->cStencilBits != 0) && (ppfd->cStencilBits != 8))
        return FALSE;

// Passed all the checks, we're compatible.

    return TRUE;
}
#endif

/******************************Public*Routine******************************\
* wglSwapBuffers
*
\**************************************************************************/

BOOL WINAPI wglSwapBuffers(HDC hdc)
{
    int  ipfd;
    BOOL bRet = FALSE;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

// Validate the DC.

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    switch ( wglObjectType(hdc) )
    {
    case OBJ_DC:
        break;
    case OBJ_MEMDC:
        return(TRUE);           // early out -- nothing to do if memory DC
    default:
        WARNING("wglSwapBuffers(): invalid hdc\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Validate pixel format.

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if ( pwnd )
    {
        if (pwnd->ipfd > 0)
        {
            // Dispatch to driver or generic.  Which one can be determined by
            // the pixel format.

            if ( pwnd->ipfd <= pwnd->ipfdDevMax )
            {
                // Some ICDs do not need glFinish synchronization so
                // we don't do it here.  __DrvSwapBuffers will call
                // it if necessary.
                bRet = __DrvSwapBuffers(hdc, TRUE);
            }
            else
            {
                // Finish OpenGL calls in this thread before doing the swap.
                // We use glFinish instead of glFlush to ensure that all
                // OpenGL operations are completed.
                glFinish();

                ENTER_WINCRIT(pwnd);
                
                // Can't rely on the pwnd's HDC because it may have
                // been released since SetPixelFormat.  Always use
                // the DC passed in as the target.
                bRet = glsrvSwapBuffers(hdc, pwnd);

                LEAVE_WINCRIT(pwnd);
            }
        }

        pwndRelease(pwnd);
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\wglsup.c ===
/******************************Module*Header*******************************\
* Module Name: wglsup.c                                                    *
*                                                                          *
* WGL support routines.                                                    *
*                                                                          *
* Created: 15-Dec-1994                                                     *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

#define DONTUSE(x)  ( (x) = (x) )

//!!!XXX -- Patrick says is necessary, but so far we seem OK.  I think
//          it is really the apps responsibility.
//!!!dbug
#if 1
#define REALIZEPALETTE(hdc) RealizePalette((hdc))
#else
#define REALIZEPALETTE(hdc)
#endif

//!!!XXX -- BitBlt's involving DIB sections are batched.
//          A GdiFlush is required, but perhaps can be taken out when
//          GDI goes to kernel-mode.  Can probably take out for Win95.
//#ifdef _OPENGL_NT_
#if 1
#define GDIFLUSH    GdiFlush()
#else
#define GDIFLUSH
#endif

/******************************Public*Routine******************************\
* wglPixelVisible
*
* Determines if the pixel (x, y) is visible in the window associated with
* the given DC.  The determination is made by checking the coordinate
* against the visible region data cached in the GLGENwindow structure for
* this winodw.
*
* Returns:
*   TRUE if pixel (x, y) is visible, FALSE if clipped out.
*
\**************************************************************************/

BOOL APIENTRY wglPixelVisible(LONG x, LONG y)
{
    BOOL bRet = FALSE;
    __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();
    GLGENwindow *pwnd = gengc->pwndLocked;

    // If direct screen access isn't active we shouldn't call this function
    // since there's no need to do any visibility clipping ourselves
    ASSERTOPENGL(GLDIRECTSCREEN,
                 "wglPixelVisible called without direct access\n");

// Quick test against bounds.

    if (
            pwnd->prgndat && pwnd->pscandat &&
            x >= pwnd->prgndat->rdh.rcBound.left   &&
            x <  pwnd->prgndat->rdh.rcBound.right  &&
            y >= pwnd->prgndat->rdh.rcBound.top    &&
            y <  pwnd->prgndat->rdh.rcBound.bottom
       )
    {
        ULONG cScans = pwnd->pscandat->cScans;
        GLGENscan *pscan = pwnd->pscandat->aScans;

    // Find right scan.

        for ( ; cScans; cScans--, pscan = pscan->pNext )
        {
        // Check if point is above scan.

            if ( pscan->top > y )
            {
            // Since scans are ordered top-down, we can conclude that
            // point is also above subsequent scans.  Therefore intersection
            // must be NULL and we can terminate search.

                break;
            }

        // Check if point is within scan.

            else if ( pscan->bottom > y )
            {
                LONG *plWalls = pscan->alWalls;
                LONG *plWallsEnd = plWalls + pscan->cWalls;

            // Check x against each pair of walls.

                for ( ; plWalls < plWallsEnd; plWalls+=2 )
                {
                // Each pair of walls (inclusive-exclusive) defines
                // a non-NULL interval in the span that is visible.

                    ASSERTOPENGL(
                        plWalls[0] < plWalls[1],
                        "wglPixelVisible(): bad walls in span\n"
                        );

                // Check if x is within current interval.

                    if ( x >= plWalls[0] && x < plWalls[1] )
                    {
                        bRet = TRUE;
                        break;
                    }
                }

                break;
            }

        // Point is below current scan. Try next scan.
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglSpanVisible
*
* Determines the visibility of the span [(x, y), (x+w, y)) (test is
* inclusive-exclusive) in the current window.  The span is either
* completely visible, partially visible (clipped), or completely
* clipped out (WGL_SPAN_ALL, WGL_SPAN_PARTIAL, and WGL_SPAN_NONE,
* respectively).
*
* WGL_SPAN_ALL
* ------------
* The entire span is visible.  *pcWalls and *ppWalls are not set.
*
* WGL_SPAN_NONE
* -------------
* The span is completely obscured (clipped out).  *pcWalls and *ppWalls
* are not set.
*
* WGL_SPAN_PARTIAL
* ----------------
* If the span is WGL_SPAN_PARTIAL, the function also returns a pointer
* to the wall array (starting with the first wall actually intersected
* by the span) and a count of the walls at this pointer.
*
* If the wall count is even, then the span starts outside the visible
* region and the first wall is where the span enters a visible portion.
*
* If the wall count is odd, then the span starts inside the visible
* region and the first wall is where the span exits a visible portion.
*
* The span may or may not cross all the walls in the array, but definitely
* does cross the first wall.
*
* Return:
*   Returns WGL_SPAN_ALL, WGL_SPAN_NONE, or WGL_SPAN_PARTIAL.  In
*   addition, if return is WGL_SPAN_PARTIAL, pcWalls and ppWalls will
*   be set (see above).
*
* History:
*  06-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG APIENTRY
wglSpanVisible(LONG x, LONG y, ULONG w, LONG *pcWalls, LONG **ppWalls)
{
    ULONG ulRet = WGL_SPAN_NONE;
    __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();
    GLGENwindow *pwnd = gengc->pwndLocked;
    LONG xRight = x + w;        // Right edge of span (exclusive)

    // If direct access is not active we shouldn't call this function since
    // there's no need to do any visibility clipping ourselves
    ASSERTOPENGL(GLDIRECTSCREEN,
                 "wglSpanVisible called without direct access\n");

// Quick test against bounds.

    if (
            pwnd->prgndat && pwnd->pscandat &&
            (x      <  pwnd->prgndat->rdh.rcBound.right ) &&
            (xRight >  pwnd->prgndat->rdh.rcBound.left  ) &&
            (y      >= pwnd->prgndat->rdh.rcBound.top   ) &&
            (y      <  pwnd->prgndat->rdh.rcBound.bottom)
       )
    {
        ULONG cScans = pwnd->pscandat->cScans;
        GLGENscan *pscan = pwnd->pscandat->aScans;

    // Find right scan.

        for ( ; cScans; cScans--, pscan = pscan->pNext )
        {
        // Check if span is above scan.

            if ( pscan->top > y )           // Scans have gone past span
            {
            // Since scans are ordered top-down, we can conclude that
            // span will aslo be above subsequent scans.  Therefore
            // intersection must be NULL and we can terminate search.

                goto wglSpanVisible_exit;
            }

        // Span is below top of scan.  If span is also above bottom,
        // span vertically intersects this scan and only this scan.

            else if ( pscan->bottom > y )
            {
                LONG *plWalls = pscan->alWalls;
                ULONG cWalls = pscan->cWalls;

                ASSERTOPENGL(
                    (cWalls & 0x1) == 0,
                    "wglSpanVisible(): wall count must be even!\n"
                    );

            // Check span against each pair of walls.  Walls are walked
            // from left to right.
            //
            // Possible intersections where "[" is inclusive
            // and ")" is exclusive:
            //                         left wall        right wall
            //                             [                )
            //      case 1a     [-----)    [                )
            //           1b          [-----)                )
            //                             [                )
            //      case 2a             [-----)             )       return
            //           2b             [-------------------)       left wall
            //                             [                )
            //      case 3a                [-----)          )
            //           3b                [    [-----)     )
            //           3c                [          [-----)
            //           3d                [----------------)
            //                             [                )
            //      case 4a                [             [-----)    return
            //           4b                [-------------------)    right wall
            //                             [                )
            //      case 5a                [                [-----)
            //           5b                [                )    [-----)
            //                             [                )
            //      case 6              [----------------------)    return
            //                             [                )       left wall

                for ( ; cWalls; cWalls-=2, plWalls+=2 )
                {
                // Each pair of walls (inclusive-exclusive) defines
                // a non-NULL interval in the span that is visible.

                    ASSERTOPENGL(
                        plWalls[0] < plWalls[1],
                        "wglSpanVisible(): bad walls in span\n"
                        );

                // Checking right end against left wall will partition the
                // set into case 1 vs. case 2 thru 6.

                    if ( plWalls[0] >= xRight )
                    {
                    // Case 1 -- span outside interval on the left.
                    //
                    // The walls are ordered from left to right (i.e., low
                    // to high).  So if span is left of this interval, it
                    // must also be left of all subsequent intervals and
                    // we can terminate the search.

                        goto wglSpanVisible_exit;
                    }

                // Cases 2 thru 6.
                //
                // Checking left end against right wall will partition subset
                // into case 5 vs. cases 2, 3, 4, 6.

                    else if ( plWalls[1] > x )
                    {
                    // Cases 2, 3, 4, and 6.
                    //
                    // Checking left end against left wall will partition
                    // subset into cases 2, 6 vs. cases 3, 4.

                        if ( plWalls[0] <= x )
                        {
                        // Cases 3 and 4.
                        //
                        // Checking right end against right wall will
                        // distinguish between the two cases.

                            if ( plWalls[1] >= xRight )
                            {
                            // Case 3 -- completely visible.

                                ulRet = WGL_SPAN_ALL;
                            }
                            else
                            {
                            // Case 4 -- partially visible, straddling the
                            // right wall.

                                ulRet = WGL_SPAN_PARTIAL;

                                *ppWalls = &plWalls[1];
                                *pcWalls = cWalls - 1;
                            }
                        }
                        else
                        {
                        // Cases 2 and 6 -- in either case its a partial
                        // intersection where the first intersection is with
                        // the left wall.

                            ulRet = WGL_SPAN_PARTIAL;

                            *ppWalls = &plWalls[0];
                            *pcWalls = cWalls;
                        }

                        goto wglSpanVisible_exit;
                    }

                // Case 5 -- span outside interval to the right. Try
                // next pair of walls.
                }

            // A span can intersect only one scan.  We don't need to check
            // any other scans.

                goto wglSpanVisible_exit;
            }

        // Span is below current scan.  Try next scan.
        }
    }

wglSpanVisible_exit:

    return ulRet;
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bComputeLogicalToSurfaceMap(HPALETTE hpal, HDC hdc, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = wglObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

// Determine number of colors in each palette.

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if (dwDcType == OBJ_DC)
        cSysEntries = wglGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

// Dynamic color depth changing can cause this.

    if ((cSysEntries > 256) || (cEntries > 256))
    {
        WARNING("wglCopyTranslationVector(): palette on > 8BPP device\n");

    // Drawing will have corrupted colors, but at least we should not crash.

        cSysEntries = min(cSysEntries, 256);
        cEntries = min(cEntries, 256);
    }

// Get the logical palette entries.

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

// Get the surface palette entries.

    if (dwDcType == OBJ_DC)
    {
        cSysEntries = wglGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

    // First get RGBQUADs from DIB color table...

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

    // ...then convert RGBQUADs into PALETTEENTRIES.

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while (lppeTmp < lppeEnd)
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

// Construct a translation vector by using GetNearestPaletteIndex to
// map each entry in the logical palette to the surface palette.

    if (cEntries && cSysEntries)
    {
    // Create a temporary logical palette that matches the surface
    // palette retrieved above.

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
        // Translate each logical palette entry into a surface palette index.

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );

                ASSERTOPENGL(
                    *pajVector != CLR_INVALID,
                    "bComputeLogicalToSurfaceMap: GetNearestPaletteIndex failed\n"
                    );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            WARNING("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        WARNING("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglCopyTranslateVector
*
* Create a logical palette index to system palette index translation
* vector.
*
* This is done by first reading both the logical palette and system palette
* entries.  A temporary palette is created from the read system palette
* entries.  This will be passed to GetNearestPaletteIndex to translate
* each logical palette entry into the desired system palette entry.
*
* Note: when GetNearestColor was called instead, very unstable results
* were obtained.  GetNearestPaletteIndex is definitely the right way to go.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  25-Oct-1994 -by- Gilman Wong [gilmanw]
* Ported from gdi\gre\wglsup.cxx.
\**************************************************************************/

static GLubyte vubRGBtoVGA[8] = {
    0x0,
    0x9,
    0xa,
    0xb,
    0xc,
    0xd,
    0xe,
    0xf
};

BOOL APIENTRY wglCopyTranslateVector(__GLGENcontext *gengc, BYTE *pajVector,
                                     ULONG cEntries)
{
    BOOL bRet = FALSE;
    ULONG i;
    HDC hdc;

    CHECKSCREENLOCKOUT();

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        // DirectDraw palettes are set directly into the hardware so
        // the translation vector is always identity
        for (i = 0; i < cEntries; i++)
        {
            *pajVector++ = (BYTE)i;
        }

        return TRUE;
    }

    hdc = gengc->gwidCurrent.hdc;
    
    if (GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
    {
        HBITMAP hbm, hbmSave;
        
        // Technically this assert is invalid
        // because we can't be sure that cEntries will be one
        // of these two cases.  To fix this we'd have to add
        // another parameter to this function indicating the
        // bit depth desired and go by that.
        ASSERTOPENGL(cEntries == 16 || cEntries == 256,
                     "wglCopyTranslateVector: Unknown cEntries\n");

        if (gengc->dwCurrentFlags & GLSURF_DIRECT_ACCESS)
        {
            // For compatibility, do not do this if the stock palette is
            // selected.  The old behavior assumed that the logical palette
            // can be ignored because the bitmap will have a color table
            // that exactly corresponds to the format specified by the
            // pixelformat.  Thus, if no palette is selected into the memdc,
            // OpenGL would still render properly since it assumed 1-to-1.
            //
            // However, to enable using optimized DIB sections (i.e., DIBs
            // whose color tables match the system palette exactly), we need
            // to be able to specify the logical palette in the memdc.
            //
            // Therefore the hack is to assume 1-to-1 iff the stock
            // palette is selected into the memdc.  Otherwise, we will
            // compute the logical to surface mapping.

            if ( gengc->gc.modes.rgbMode &&
                 (GetCurrentObject(hdc, OBJ_PAL) !=
                  GetStockObject(DEFAULT_PALETTE)) )
            {
                // If an RGB DIB section, compute a mapping from logical
                // palette to surface (DIB color table).

                bRet = bComputeLogicalToSurfaceMap(
                        GetCurrentObject(hdc, OBJ_PAL),
                        hdc,
                        pajVector
                        );
            }

            return bRet;
        }

        // 4bpp has a fixed color table so we can just copy the standard
        // translation into the output vector.

        if (cEntries == 16)
        {
            // For RGB mode, 4bpp uses a 1-1-1 format.  We want to utilize
            // bright versions which exist in the upper 8 entries.

            if ( gengc->gc.modes.rgbMode )
            {
                memcpy(pajVector, vubRGBtoVGA, 8);

                // Set the other mappings to white to make problems show up
                memset(pajVector+8, 15, 8);

                bRet = TRUE;
            }

            // For CI mode, just return FALSE and use the trivial vector.

            return bRet;
        }
        
        // For bitmaps, we can determine the forward translation vector by
        // filling a compatible bitmap with palette index specifiers from
        // 1 to 255 and reading the bits back with GetBitmapBits.
        
        hbm = CreateCompatibleBitmap(hdc, cEntries, 1);
        if (hbm)
        {
            LONG cBytes;
            
            hbmSave = SelectObject(hdc, hbm);
            RealizePalette(hdc);
            
            for (i = 0; i < cEntries; i++)
                SetPixel(hdc, i, 0, PALETTEINDEX(i));
            
            cBytes = 256;
            
            if ( GetBitmapBits(hbm, cBytes, (LPVOID) pajVector) >= cBytes )
                bRet = TRUE;
#if DBG
            else
                WARNING("wglCopyTranslateVector: GetBitmapBits failed\n");
#endif
            
            SelectObject(hdc, hbmSave);
            DeleteObject(hbm);
            RealizePalette(hdc);
        }
        
        return bRet;
    }

// Determine number of colors in logical and system palettes, respectively.

    cEntries = min(GetPaletteEntries(GetCurrentObject(hdc, OBJ_PAL),
                                     0, cEntries, NULL),
                   cEntries);

    if (cEntries == 16)
    {
        // For 16-color displays we are using RGB 1-1-1 since the
        // full 16-color palette doesn't make for very good mappings
        // Since we're only using the first eight of the colors we
        // want to map them to the bright colors in the VGA palette
        // rather than having them map to the dark colors as they would
        // if we ran the loop below

        if ( gengc->gc.modes.rgbMode )
        {
            memcpy(pajVector, vubRGBtoVGA, 8);

            // Set the other mappings to white to make problems show up
            memset(pajVector+8, 15, 8);

            bRet = TRUE;
        }

        // For CI mode, return FALSE and use the trivial translation vector.

        return bRet;
    }

// Compute logical to surface palette mapping.

    bRet = bComputeLogicalToSurfaceMap(GetCurrentObject(hdc, OBJ_PAL), hdc,
                                       pajVector);

    return bRet;
}

/******************************Public*Routine******************************\
* wglCopyBits
*
* Calls DrvCopyBits to copy scanline bits into or out of the driver surface.
*
\**************************************************************************/

VOID APIENTRY wglCopyBits(
    __GLGENcontext *gengc,
    GLGENwindow *pwnd,
    HBITMAP hbm,            // ignore
    LONG x,                 // screen coordinate of scan
    LONG y,
    ULONG cx,               // width of scan
    BOOL bIn)               // if TRUE, copy from bm to dev; otherwise, dev to bm
{
    CHECKSCREENLOCKOUT();

// Convert screen coordinates to window coordinates.

    x -= pwnd->rclClient.left;
    y -= pwnd->rclClient.top;

// this shouldn't happen, but better safe than sorry

    if (y < 0)
        return;

    //!!!XXX
    REALIZEPALETTE(gengc->gwidCurrent.hdc);

// Copy from bitmap to device.

    if (bIn)
    {
        LONG xSrc, x0Dst, x1Dst;
        if (x < 0)
        {
            xSrc  = -x;
            x0Dst = 0;
            x1Dst = x + (LONG)cx;
        }
        else
        {
            xSrc  = 0;
            x0Dst = x;
            x1Dst = x + (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        BitBlt(gengc->gwidCurrent.hdc, x0Dst, y, cx, 1,
               gengc->ColorsMemDC, xSrc, 0, SRCCOPY);
    }

// Copy from device to bitmap.

    else
    {
        LONG xSrc, x0Dst, x1Dst;

        if (x < 0)
        {
            xSrc  = 0;
            x0Dst = -x;
            x1Dst = (LONG)cx;
        }
        else
        {
            xSrc  = x;
            x0Dst = 0;
            x1Dst = (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        if (dwPlatformId == VER_PLATFORM_WIN32_NT ||
            GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
        {
            BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                   gengc->gwidCurrent.hdc, xSrc, y, SRCCOPY);
        }
        else
        {
            /* If we're copying from the screen,
               copy through a DDB to avoid some layers of unnecessary
               code in Win95 that deals with translating between
               different bitmap layouts */
            if (gengc->ColorsDdbDc)
            {
                BitBlt(gengc->ColorsDdbDc, 0, 0, cx, 1,
                       gengc->gwidCurrent.hdc, xSrc, y, SRCCOPY);

                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       gengc->ColorsDdbDc, 0, 0, SRCCOPY);
            }
            else
            {
                //!!!Viper fix -- Diamond Viper (Weitek 9000) fails
                //!!!             CreateCompatibleBitmap for some
                //!!!             (currently unknown) reason.  Thus,
                //!!!             the DDB does not exist and we will
                //!!!             have to incur the perf. hit.

                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       gengc->gwidCurrent.hdc, xSrc, y, SRCCOPY);
            }
        }
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglCopyBits2
*
* Calls DrvCopyBits to copy scanline bits into or out of the driver surface.
*
\**************************************************************************/

VOID APIENTRY wglCopyBits2(
    HDC hdc,        // dst/src device
    GLGENwindow *pwnd,   // clipping
    __GLGENcontext *gengc,
    LONG x,         // screen coordinate of scan
    LONG y,
    ULONG cx,       // width of scan
    BOOL bIn)       // if TRUE, copy from bm to dev; otherwise, dev to bm
{
    CHECKSCREENLOCKOUT();

// Convert screen coordinates to window coordinates.

    x -= pwnd->rclClient.left;
    y -= pwnd->rclClient.top;

// this shouldn't happen, but better safe than sorry

    if (y < 0)
        return;

    //!!!XXX
    REALIZEPALETTE(hdc);

// Copy from bitmap to device.

    if (bIn)
    {
        LONG xSrc, x0Dst, x1Dst;
        if (x < 0)
        {
            xSrc  = -x;
            x0Dst = 0;
            x1Dst = x + (LONG)cx;
        }
        else
        {
            xSrc  = 0;
            x0Dst = x;
            x1Dst = x + (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        BitBlt(hdc, x0Dst, y, cx, 1,
               gengc->ColorsMemDC, xSrc, 0, SRCCOPY);
    }

// Copy from device to bitmap.

    else
    {
        LONG xSrc, x0Dst, x1Dst;

        if (x < 0)
        {
            xSrc  = 0;
            x0Dst = -x;
            x1Dst = (LONG)cx;
        }
        else
        {
            xSrc  = x;
            x0Dst = 0;
            x1Dst = (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        if (dwPlatformId == VER_PLATFORM_WIN32_NT ||
            GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
        {
            BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                   hdc, xSrc, y, SRCCOPY);
        }
        else
        {
            /* If we're copying from the screen,
               copy through a DDB to avoid some layers of unnecessary
               code in Win95 that deals with translating between
               different bitmap layouts */
            if (gengc->ColorsDdbDc)
            {
                BitBlt(gengc->ColorsDdbDc, 0, 0, cx, 1,
                       hdc, xSrc, y, SRCCOPY);
                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       gengc->ColorsDdbDc, 0, 0, SRCCOPY);
            }
            else
            {
                //!!!Viper fix -- Diamond Viper (Weitek 9000) fails
                //!!!             CreateCompatibleBitmap for some
                //!!!             (currently unknown) reason.  Thus,
                //!!!             the DDB does not exist and we will
                //!!!             have to incur the perf. hit.

                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       hdc, xSrc, y, SRCCOPY);
            }
        }
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
*
* wglTranslateColor
*
* Transforms a GL logical color into a Windows COLORREF
*
* Note: This is relatively expensive so it should be avoided if possible
*
* History:
*  Tue Aug 15 15:23:29 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

COLORREF wglTranslateColor(COLORREF crColor,
                           HDC hdc,
                           __GLGENcontext *gengc,
                           PIXELFORMATDESCRIPTOR *ppfd)
{
    //!!!XXX
    REALIZEPALETTE(hdc);

// If palette managed, then crColor is actually a palette index.

    if ( ppfd->cColorBits <= 8 )
    {
        PALETTEENTRY peTmp;

        ASSERTOPENGL(
            crColor < (COLORREF) (1 << ppfd->cColorBits),
            "TranslateColor(): bad color\n"
            );

    // If rendering to a bitmap, we need to do different things depending
    // on whether it's a DIB or DDB

        if ( gengc->gc.drawBuffer->buf.flags & MEMORY_DC )
        {
            DIBSECTION ds;
            
            // Check whether we're drawing to a DIB or a DDB
            if (GetObject(GetCurrentObject(hdc, OBJ_BITMAP),
                          sizeof(ds), &ds) == sizeof(ds) && ds.dsBm.bmBits)
            {
                RGBQUAD rgbq;
                
                // Drawing to a DIB so retrieve the color from the
                // DIB color table
                if (GetDIBColorTable(hdc, crColor, 1, &rgbq))
                {
                    crColor = RGB(rgbq.rgbRed, rgbq.rgbGreen,
                                  rgbq.rgbBlue);
                }
                else
                {
                    WARNING("TranslateColor(): GetDIBColorTable failed\n");
                    crColor = RGB(0, 0, 0);
                }
            }
            else
            {
                // Reverse the forward translation so that we get back
                // to a normal palette index
                crColor = gengc->pajInvTranslateVector[crColor];

                // Drawing to a DDB so we can just use the palette
                // index directly since going through the inverse
                // translation table has given us an index into
                // the logical palette
                crColor = PALETTEINDEX((WORD) crColor);
            }
        }

    // Otherwise...

        else
        {
        // I hate to have to confess this, but I don't really understand
        // why this needs to be this way.  Either way should work regardless
        // of the bit depth.
        //
        // The reality is that 4bpp we *have* to go into the system palette
        // and fetch an RGB value.  At 8bpp on the MGA driver (and possibly
        // others), we *have* to specify PALETTEINDEX.

            if ( ppfd->cColorBits == 4 )
            {
                if ( wglGetSystemPaletteEntries(hdc, crColor, 1, &peTmp) )
                {
                    crColor = RGB(peTmp.peRed, peTmp.peGreen, peTmp.peBlue);
                }
                else
                {
                    WARNING("TranslateColor(): wglGetSystemPaletteEntries failed\n");
                    crColor = RGB(0, 0, 0);
                }
            }
            else
            {
                if (!(gengc->flags & GENGC_MCD_BGR_INTO_RGB))
                    crColor = gengc->pajInvTranslateVector[crColor];
                crColor = PALETTEINDEX((WORD) crColor);
            }
        }
    }

// If 24BPP DIB section, BGR ordering is implied.

    else if ( ppfd->cColorBits == 24 )
    {
        crColor = RGB((crColor & 0xff0000) >> 16,
                      (crColor & 0x00ff00) >> 8,
                      (crColor & 0x0000ff));
    }

// Win95 and 16 BPP case.
//
// On Win95, additional munging is necessary to get a COLORREF value
// that will result in a non-dithered brush.

    else if ( (dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
         (ppfd->cColorBits == 16) )
    {
        HBITMAP hbmTmp;
        HDC hdcTmp;

        if (hdcTmp = CreateCompatibleDC(hdc))
        {
            if (hbmTmp = CreateCompatibleBitmap(hdc, 1, 1))
            {
                HBITMAP hbmOld;

                hbmOld = SelectObject(hdcTmp, hbmTmp);

                if (SetBitmapBits(hbmTmp, 2, (VOID *) &crColor))
                {
                    crColor = GetPixel(hdcTmp, 0, 0);
                }
                else
                {
                    WARNING("TranslateColor(): SetBitmapBits failed\n");
                }

                SelectObject(hdcTmp, hbmOld);
                DeleteObject(hbmTmp);
            }
            else
            {
                WARNING("TranslateColor(): CreateCompatibleBitmap failed\n");
            }
            
            DeleteDC(hdcTmp);
        }
        else
        {
            WARNING("TranslateColor(): CreateCompatibleDC failed\n");
        }
    }

// Bitfield format (16BPP or 32BPP).

    else
    {
        // Shift right to position bits at zero and then scale into
        // an 8-bit quantity

        //!!!XXX -- use rounding?!?
        crColor =
            RGB(((crColor & gengc->gc.modes.redMask) >> ppfd->cRedShift) *
                255 / ((1 << ppfd->cRedBits) - 1),
                ((crColor & gengc->gc.modes.greenMask) >> ppfd->cGreenShift) *
                255 / ((1 << ppfd->cGreenBits) - 1),
                ((crColor & gengc->gc.modes.blueMask) >> ppfd->cBlueShift) *
                255 / ((1 << ppfd->cBlueBits) - 1));

    }

    return crColor;
}

/******************************Public*Routine******************************\
* wglFillRect
*
* Calls DrvBitBlt to fill a rectangle area of a driver surface with a
* given color.
*
\**************************************************************************/

VOID APIENTRY wglFillRect(
    __GLGENcontext *gengc,
    GLGENwindow *pwnd,
    PRECTL prcl,        // screen coordinate of the rectangle area
    COLORREF crColor)   // color to set
{
    HBRUSH hbr;
    PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;

    CHECKSCREENLOCKOUT();

// If the rectangle is empty, return.

    if ( (prcl->left >= prcl->right) || (prcl->top >= prcl->bottom) )
    {
        WARNING("wglFillRect(): bad or empty rectangle\n");
        return;
    }

// Convert from screen to window coordinates.

    prcl->left   -= pwnd->rclClient.left;
    prcl->right  -= pwnd->rclClient.left;
    prcl->top    -= pwnd->rclClient.top;
    prcl->bottom -= pwnd->rclClient.top;

// Make a solid color brush and fill the rectangle.

    // If the fill color is the same as the last one, we can reuse
    // the cached brush rather than creating a new one
    if (crColor == gengc->crFill &&
        gengc->gwidCurrent.hdc == gengc->hdcFill)
    {
        hbr = gengc->hbrFill;
        ASSERTOPENGL(hbr != NULL, "Cached fill brush is null\n");
    }
    else
    {
        if (gengc->hbrFill != NULL)
        {
            DeleteObject(gengc->hbrFill);
        }
        
        gengc->crFill = crColor;
        
        crColor = wglTranslateColor(crColor, gengc->gwidCurrent.hdc, gengc, ppfd);
        hbr = CreateSolidBrush(crColor);
        gengc->hbrFill = hbr;
        
        if (hbr == NULL)
        {
            gengc->crFill = COLORREF_UNUSED;
            return;
        }

        gengc->hdcFill = gengc->gwidCurrent.hdc;
    }
    
    FillRect(gengc->gwidCurrent.hdc, (RECT *) prcl, hbr);
    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglCopyBuf
*
* Calls DrvCopyBits to copy a bitmap into the driver surface.
*
\**************************************************************************/

//!!!XXX -- change to a macro

VOID APIENTRY wglCopyBuf(
    HDC hdc,            // dst/src DCOBJ
    HDC hdcBmp,         // scr/dst bitmap
    LONG x,             // dst rect (UL corner) in window coord.
    LONG y,
    ULONG cx,           // width of dest rect
    ULONG cy            // height of dest rect
    )
{
    CHECKSCREENLOCKOUT();

    //!!!XXX
    REALIZEPALETTE(hdc);

    if (!BitBlt(hdc, x, y, cx, cy, hdcBmp, 0, 0, SRCCOPY))
    {
        WARNING1("wglCopyBuf BitBlt failed %d\n", GetLastError());
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglCopyBufRECTLIST
*
* Calls DrvCopyBits to copy a bitmap into the driver surface.
*
\**************************************************************************/

VOID APIENTRY wglCopyBufRECTLIST(
    HDC hdc,            // dst/src DCOBJ
    HDC hdcBmp,         // scr/dst bitmap
    LONG x,             // dst rect (UL corner) in window coord.
    LONG y,
    ULONG cx,           // width of dest rect
    ULONG cy,           // height of dest rect
    PRECTLIST prl
    )
{
    PYLIST pylist;

    CHECKSCREENLOCKOUT();

    //!!!XXX
    REALIZEPALETTE(hdc);

    for (pylist = prl->pylist; pylist != NULL; pylist = pylist->pnext)
    {
        PXLIST pxlist;
        
        for (pxlist = pylist->pxlist; pxlist != NULL; pxlist = pxlist->pnext)
        {
            int xx  = pxlist->s;
            int cxx = pxlist->e - pxlist->s;
            int yy  = pylist->s;
            int cyy = pylist->e - pylist->s;

            if (!BitBlt(hdc, xx, yy, cxx, cyy, hdcBmp, xx, yy, SRCCOPY))
            {
                WARNING1("wglCopyBufRL BitBlt failed %d\n", GetLastError());
            }
        }
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglPaletteChanged
*
* Check if the palette changed.
*
*    If the surface for the DC is palette managed we care about the
*    foreground realization, so, return iUniq
*
*    If the surface is not palette managed, return ulTime
*
\**************************************************************************/

ULONG APIENTRY wglPaletteChanged(__GLGENcontext *gengc,
                                 GLGENwindow *pwnd)
{
    ULONG ulRet = 0;
    HDC hdc;

    // Palette must stay fixed for DirectDraw after initialization
    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        if (gengc->PaletteTimestamp == 0xffffffff)
        {
            return 0;
        }
        else
        {
            return gengc->PaletteTimestamp;
        }
    }

    hdc = gengc->gwidCurrent.hdc;
    
    // Technically we shouldn't be making these GDI calls while we
    // have a screen lock but currently it would be very difficult
    // to fix because we're actually invoking this routine in
    // glsrvGrabLock in order to ensure that we have stable information
    // while we have the lock
    // We don't seem to be having too many problems so for the moment
    // this will be commented out
    // CHECKSCREENLOCKOUT();

    if (pwnd)
    {
        PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;
        BYTE cBitsThreshold;

        // WM_PALETTECHANGED messages are sent for 8bpp on Win95 when the
        // palette is realized.  This allows us to update the palette time.
        //
        // When running WinNT on >= 8bpp or running Win95 on >= 16bpp,
        // WM_PALETTECHANGED is not sent so we need to manually examine
        // the contents of the logical palette and compare it with a previously
        // cached copy to look for a palette change.

        cBitsThreshold = ( dwPlatformId == VER_PLATFORM_WIN32_NT ) ? 8 : 16;

        if (((ppfd->cColorBits >= cBitsThreshold) &&
             (ppfd->iPixelType == PFD_TYPE_COLORINDEX)) )
        {
            if ( !gengc->ppalBuf )
            {
                UINT cjPal, cjRgb;

                // Allocate buffer space for *two* copies of the palette.
                // That way we don't need to dynamically allocate space
                // for temp storage of the palette.  Also,we don't need
                // to copy the current palette to the save buffer if we
                // keep two pointers (one for the temp storage and one for
                // the saved copy) and swap them.

                cjRgb = 0;
                cjPal = sizeof(LOGPALETTE) +
                    (MAXPALENTRIES * sizeof(PALETTEENTRY));

                gengc->ppalBuf = (LOGPALETTE *)
                    ALLOC((cjPal + cjRgb) * 2);

                if ( gengc->ppalBuf )
                {
                    // Setup the logical palette buffers.
                    
                    gengc->ppalSave = gengc->ppalBuf;
                    gengc->ppalTemp = (LOGPALETTE *)
                        (((BYTE *) gengc->ppalBuf) + cjPal);
                    gengc->ppalSave->palVersion = 0x300;
                    gengc->ppalTemp->palVersion = 0x300;

                    // How many palette entries?  Note that only the first
                    // MAXPALENTRIES are significant to generic OpenGL.  The
                    // rest are ignored.

                    gengc->ppalSave->palNumEntries =
                        (WORD) GetPaletteEntries(
                                GetCurrentObject(hdc, OBJ_PAL),
                                0, 0, (LPPALETTEENTRY) NULL
                                );
                    gengc->ppalSave->palNumEntries =
                        min(gengc->ppalSave->palNumEntries, MAXPALENTRIES);

                    gengc->ppalSave->palNumEntries =
                        (WORD) GetPaletteEntries(
                                GetCurrentObject(hdc, OBJ_PAL),
                                0, gengc->ppalSave->palNumEntries,
                                gengc->ppalSave->palPalEntry
                                );

                    // Since we had to allocate buffer, this must be the
                    // first time wglPaletteChanged was called for this
                    // context.

                    pwnd->ulPaletteUniq++;
                }
            }
            else
            {
                BOOL bNewPal = FALSE;   // TRUE if log palette is different

                // How many palette entries?  Note that only the first
                // MAXPALENTRIES are significant to generic OpenGL.  The
                // rest are ignored.
                
                gengc->ppalTemp->palNumEntries =
                    (WORD) GetPaletteEntries(
                            GetCurrentObject(hdc, OBJ_PAL),
                            0, 0, (LPPALETTEENTRY) NULL
                            );
                gengc->ppalTemp->palNumEntries =
                    min(gengc->ppalTemp->palNumEntries, MAXPALENTRIES);
                
                gengc->ppalTemp->palNumEntries =
                    (WORD) GetPaletteEntries(
                            GetCurrentObject(hdc, OBJ_PAL),
                            0, gengc->ppalTemp->palNumEntries,
                            gengc->ppalTemp->palPalEntry
                            );
                
                // If number of entries differ, know the palette has changed.
                // Otherwise, need to do the hard word of comparing each entry.
                
                ASSERTOPENGL(
                        sizeof(PALETTEENTRY) == sizeof(ULONG),
                        "wglPaletteChanged(): PALETTEENTRY should be 4 bytes\n"
                        );
                
                // If color table comparison already detected a change, no
                // need to do logpal comparison.
                //
                // However, we will still go ahead and swap logpal pointers
                // below because we want the palette cache to stay current.
                
                if ( !bNewPal )
                {
                    bNewPal = (gengc->ppalSave->palNumEntries != gengc->ppalTemp->palNumEntries);
                    if ( !bNewPal )
                    {
                        bNewPal = !LocalCompareUlongMemory(
                                gengc->ppalSave->palPalEntry,
                                gengc->ppalTemp->palPalEntry,
                                gengc->ppalSave->palNumEntries * sizeof(PALETTEENTRY)
                                );
                    }
                }
                
                // So, if palette is different, increment uniqueness and
                // update the saved copy.
                
                if ( bNewPal )
                {
                    LOGPALETTE *ppal;
                    
                    pwnd->ulPaletteUniq++;
                    
                    // Update saved palette by swapping pointers.
                    
                    ppal = gengc->ppalSave;
                    gengc->ppalSave = gengc->ppalTemp;
                    gengc->ppalTemp = ppal;
                }
            }
        }
    
        ulRet = pwnd->ulPaletteUniq;
    }

    return ulRet;
}

/******************************Public*Routine******************************\
* wglPaletteSize
*
* Return the size of the current palette
*
\**************************************************************************/

//!!!XXX -- make into a macro?
ULONG APIENTRY wglPaletteSize(__GLGENcontext *gengc)
{
    CHECKSCREENLOCKOUT();

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        DWORD dwCaps;
        LPDIRECTDRAWPALETTE pddp = NULL;
        HRESULT hr;
        
        if (gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
            GetPalette(gengc->gsurf.dd.gddsFront.pdds, &pddp) != DD_OK ||
            pddp == NULL)
        {
            return 0;
        }

        hr = pddp->lpVtbl->GetCaps(pddp, &dwCaps);

        pddp->lpVtbl->Release(pddp);

        if (hr != DD_OK)
        {
            return 0;
        }

        if (dwCaps & DDPCAPS_1BIT)
        {
            return 1;
        }
        else if (dwCaps & DDPCAPS_2BIT)
        {
            return 4;
        }
        else if (dwCaps & DDPCAPS_4BIT)
        {
            return 16;
        }
        else if (dwCaps & DDPCAPS_8BIT)
        {
            return 256;
        }
        else
            return 0;
    }
    else
    {
        return GetPaletteEntries(GetCurrentObject(gengc->gwidCurrent.hdc,
                                                  OBJ_PAL), 0, 0, NULL);
    }
}

/******************************Public*Routine******************************\
* wglComputeIndexedColors
*
* Copy current index-to-color table to the supplied array.  Colors are
* formatted as specified in the current pixelformat and are put into the
* table as DWORDs (i.e., DWORD alignment) starting at the second DWORD.
* The first DWORD in the table is the number of colors in the table.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Ported from gdi\gre\wglsup.cxx.
\**************************************************************************/

BOOL APIENTRY wglComputeIndexedColors(__GLGENcontext *gengc, ULONG *rgbTable,
                                      ULONG cEntries)
{
    UINT cColors = 0;
    LPPALETTEENTRY lppe, lppeTable;
    UINT i;
    LPDIRECTDRAWPALETTE pddp = NULL;

    CHECKSCREENLOCKOUT();

    // first element in table is number of entries
    rgbTable[0] = min(wglPaletteSize(gengc), cEntries);

    lppeTable = (LPPALETTEENTRY)
                ALLOC(sizeof(PALETTEENTRY) * rgbTable[0]);

    if (lppeTable)
    {
        int rScale, gScale, bScale;
        int rShift, gShift, bShift;

        rScale = (1 << gengc->gsurf.pfd.cRedBits  ) - 1;
        gScale = (1 << gengc->gsurf.pfd.cGreenBits) - 1;
        bScale = (1 << gengc->gsurf.pfd.cBlueBits ) - 1;
        rShift = gengc->gsurf.pfd.cRedShift  ;
        gShift = gengc->gsurf.pfd.cGreenShift;
        bShift = gengc->gsurf.pfd.cBlueShift ;

        if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
        {
            if (gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
                GetPalette(gengc->gsurf.dd.gddsFront.pdds, &pddp) != DD_OK ||
                pddp == NULL)
            {
                return 0;
            }
            
            if (pddp->lpVtbl->GetEntries(pddp, 0, 0,
                                         rgbTable[0], lppeTable) != DD_OK)
            {
                cColors = 0;
            }
            else
            {
                cColors = rgbTable[0];
            }
        }
        else
        {
            cColors = GetPaletteEntries(GetCurrentObject(gengc->gwidCurrent.hdc,
                                                         OBJ_PAL),
                                        0, rgbTable[0], lppeTable);
        }

        for (i = 1, lppe = lppeTable; i <= cColors; i++, lppe++)
        {
        // Whack the PALETTEENTRY color into proper color format.  Store as
        // ULONG.

            //!!!XXX -- use rounding?!?
            rgbTable[i] = (((ULONG)lppe->peRed   * rScale / 255) << rShift) |
                          (((ULONG)lppe->peGreen * gScale / 255) << gShift) |
                          (((ULONG)lppe->peBlue  * bScale / 255) << bShift);
        }

        FREE(lppeTable);
    }

    if (pddp != NULL)
    {
        pddp->lpVtbl->Release(pddp);
    }
           
    return(cColors != 0);
}

/******************************Public*Routine******************************\
* wglValidPixelFormat
*
* Determines if a pixelformat is usable with the DC specified.
*
\**************************************************************************/

BOOL APIENTRY wglValidPixelFormat(HDC hdc, int ipfd, DWORD dwObjectType,
                                  LPDIRECTDRAWSURFACE pdds,
                                  DDSURFACEDESC *pddsd)
{
    BOOL bRet = FALSE;
    PIXELFORMATDESCRIPTOR pfd, pfdDC;

    if ( wglDescribePixelFormat(hdc, ipfd, sizeof(pfd), &pfd) )
    {
        if ( dwObjectType == OBJ_DC )
        {
        // We have a display DC; make sure the pixelformat allows drawing
        // to the window.

            bRet = ( (pfd.dwFlags & PFD_DRAW_TO_WINDOW) != 0 );
            if (!bRet)
            {
                SetLastError(ERROR_INVALID_FLAGS);
            }
        }
        else if ( dwObjectType == OBJ_MEMDC )
        {
            // We have a memory DC.  Make sure pixelformat allows drawing
            // to a bitmap.

            if ( pfd.dwFlags & PFD_DRAW_TO_BITMAP )
            {
                // Make sure that the bitmap and pixelformat have the same
                // color depth.

                HBITMAP hbm;
                BITMAP bm;
                ULONG cBitmapColorBits;

                hbm = CreateCompatibleBitmap(hdc, 1, 1);
                if ( hbm )
                {
                    if ( GetObject(hbm, sizeof(bm), &bm) )
                    {
                        cBitmapColorBits = bm.bmPlanes * bm.bmBitsPixel;
                        
                        bRet = ( cBitmapColorBits == pfd.cColorBits );
                        if (!bRet)
                        {
                            SetLastError(ERROR_INVALID_FUNCTION);
                        }
                    }
                    else
                    {
                        WARNING("wglValidPixelFormat: GetObject failed\n");
                    }
                    
                    DeleteObject(hbm);
                }
                else
                {
                    WARNING("wglValidPixelFormat: Unable to create cbm\n");
                }
            }
        }
        else if (dwObjectType == OBJ_ENHMETADC)
        {
            // We don't know anything about what surfaces this
            // metafile will be played back on so allow any kind
            // of pixel format
            bRet = TRUE;
        }
        else if (dwObjectType == OBJ_DDRAW)
        {
            DDSCAPS ddscaps;
            LPDIRECTDRAWSURFACE pddsZ;
            DDSURFACEDESC ddsdZ;
            
            // We have a DDraw surface.

            // Check that DDraw is supported and that double buffering
            // is not defined.
            if ((pfd.dwFlags & PFD_SUPPORT_DIRECTDRAW) == 0 ||
                (pfd.dwFlags & PFD_DOUBLEBUFFER))
            {
                WARNING1("DDSurf pfd has bad flags 0x%08lX\n", pfd.dwFlags);
                SetLastError(ERROR_INVALID_FLAGS);
                return FALSE;
            }
            
            // We only understand 4 and 8bpp paletted formats plus RGB
            // We don't support alpha-only or Z-only surfaces
            if ((pddsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED4 |
                                                   DDPF_PALETTEINDEXED8 |
                                                   DDPF_RGB)) == 0 ||
                (pddsd->ddpfPixelFormat.dwFlags & (DDPF_ALPHA |
                                                   DDPF_ZBUFFER)) != 0)
            {
                WARNING1("DDSurf ddpf has bad flags, 0x%08lX\n",
                         pddsd->ddpfPixelFormat.dwFlags);
                SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                return FALSE;
            }

            if (DdPixelDepth(pddsd) != pfd.cColorBits)
            {
                WARNING2("DDSurf pfd cColorBits %d "
                         "doesn't match ddsd depth %d\n",
                         pfd.cColorBits, DdPixelDepth(pddsd));
                SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                return FALSE;
            }

            // Check for alpha
            if (pfd.cAlphaBits > 0)
            {
                // Interleaved destination alpha is not supported.
                if (pddsd->ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)
                {
                    WARNING("DDSurf has alpha pixels\n");
                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                    return FALSE;
                }
            }

            // Check for an attached Z buffer
            memset(&ddscaps, 0, sizeof(ddscaps));
            ddscaps.dwCaps = DDSCAPS_ZBUFFER;
            if (pdds->lpVtbl->
                GetAttachedSurface(pdds, &ddscaps, &pddsZ) == DD_OK)
            {
                HRESULT hr;
                
                memset(&ddsdZ, 0, sizeof(ddsdZ));
                ddsdZ.dwSize = sizeof(ddsdZ);
                
                hr = pddsZ->lpVtbl->GetSurfaceDesc(pddsZ, &ddsdZ);
                
                pddsZ->lpVtbl->Release(pddsZ);

                if (hr != DD_OK)
                {
                    WARNING("Unable to get Z ddsd\n");
                    return FALSE;
                }

                // Ensure that the Z surface depth is the same as the
                // one in the pixel format
                if (pfd.cDepthBits !=
                    (BYTE)DdPixDepthToCount(ddsdZ.ddpfPixelFormat.
                                            dwZBufferBitDepth))
                {
                    WARNING2("DDSurf pfd cDepthBits %d doesn't match "
                             "Z ddsd depth %d\n", pfd.cDepthBits,
                             DdPixDepthToCount(ddsdZ.ddpfPixelFormat.
                                               dwZBufferBitDepth));
                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                    return FALSE;
                }
            }
            else
            {
                // No Z so make sure the pfd doesn't ask for it
                if (pfd.cDepthBits > 0)
                {
                    WARNING("DDSurf pfd wants depth with no Z attached\n");
                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                    return FALSE;
                }
            }

            bRet = TRUE;
        }
        else
        {
            WARNING("wglValidPixelFormat: not a valid DC!\n");
        }
    }
    else
    {
        WARNING("wglValidPixelFormat: wglDescribePixelFormat failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglMakeScans
*
* Converts the visible rectangle list in the provided GLGENwindow to a
* scan-based data structure.  The scan-data is put into the GLGENwindow
* structure.
*
* Note: this function assumes that the rectangles are already organized
* top-down, left-right in scans.  This is true for Windows NT 3.5 and
* Windows 95.  This is because the internal representation of regions
* in both systems is already a scan-based structure.  When the APIs
* (such as GetRegionData) convert the scans to rectangles, the rectangles
* automatically have this property.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*   Note: if failure, clipping info is invalid.
*
* History:
*  05-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY wglMakeScans(GLGENwindow *pwnd)
{
    RECT *prc, *prcEnd;
    LONG lPrevScanTop;
    ULONG cScans = 0;
    UINT cjNeed;
    GLGENscan *pscan;
    LONG *plWalls;

    ASSERTOPENGL(
        pwnd->prgndat,
        "wglMakeScans(): NULL region data\n"
        );

    ASSERTOPENGL(
        pwnd->prgndat->rdh.iType == RDH_RECTANGLES,
        "wglMakeScans(): not RDH_RECTANGLES!\n"
        );

// Bail out if no rectangles.

    if (pwnd->prgndat->rdh.nCount == 0)
        return TRUE;

// First pass: determine the number of scans.

    lPrevScanTop = -(LONG) 0x7FFFFFFF;
    prc = (RECT *) pwnd->prgndat->Buffer;
    prcEnd = prc + pwnd->prgndat->rdh.nCount;

    for ( ; prc < prcEnd; prc++)
    {
        if (prc->top != lPrevScanTop)
        {
            lPrevScanTop = prc->top;
            cScans++;
        }
    }

// Determine the size needed: 1 GLGENscanData PLUS a GLGENscan per scan PLUS
// two walls per rectangle.

    cjNeed = offsetof(GLGENscanData, aScans) +
             cScans * offsetof(GLGENscan, alWalls) +
             pwnd->prgndat->rdh.nCount * sizeof(LONG) * 2;

// Allocate the scan structure.

    if ( cjNeed > pwnd->cjscandat || !pwnd->pscandat )
    {
        if ( pwnd->pscandat )
            FREE(pwnd->pscandat);

        pwnd->pscandat = ALLOC(pwnd->cjscandat = cjNeed);
        if ( !pwnd->pscandat )
        {
            WARNING("wglMakeScans(): memory failure\n");
            pwnd->cjscandat = 0;
            return FALSE;
        }
    }

// Second pass: fill the scan structure.

    pwnd->pscandat->cScans = cScans;

    lPrevScanTop = -(LONG) 0x7FFFFFFF;
    prc = (RECT *) pwnd->prgndat->Buffer;    // need to reset prc but prcEnd OK
    plWalls = (LONG *) pwnd->pscandat->aScans;
    pscan = (GLGENscan *) NULL;

    for ( ; prc < prcEnd; prc++ )
    {
    // Do we need to start a new scan?

        if ( prc->top != lPrevScanTop )
        {
        // Scan we just finished needs pointer to the next scan.  Next
        // will start just after this scan (which, conveniently enough,
        // plWalls is pointing at).

            if ( pscan )
                pscan->pNext = (GLGENscan *) plWalls;

            lPrevScanTop = prc->top;

        // Start the new span.

            pscan = (GLGENscan *) plWalls;
            pscan->cWalls = 0;
            pscan->top = prc->top;
            pscan->bottom = prc->bottom;
            plWalls = pscan->alWalls;
        }

        pscan->cWalls+=2;
        *plWalls++ = prc->left;
        *plWalls++ = prc->right;
    }

    if ( pscan )
        pscan->pNext = (GLGENscan *) NULL;  // don't leave ptr unitialized in
                                            // the last scan

#if DBG
    DBGLEVEL1(LEVEL_INFO, "\n-----\nwglMakeScans(): cScans = %ld\n", pwnd->pscandat->cScans);

    cScans = pwnd->pscandat->cScans;
    pscan = pwnd->pscandat->aScans;

    for ( ; cScans; cScans--, pscan = pscan->pNext )
    {
        LONG *plWalls = pscan->alWalls;
        LONG *plWallsEnd = plWalls + pscan->cWalls;

        DBGLEVEL3(LEVEL_INFO, "Scan: top = %ld, bottom = %ld, walls = %ld\n", pscan->top, pscan->bottom, pscan->cWalls);

        for ( ; plWalls < plWallsEnd; plWalls+=2 )
        {
            DBGLEVEL2(LEVEL_INFO, "\t%ld, %ld\n", plWalls[0], plWalls[1]);
        }
    }
#endif

    return TRUE;
}

/******************************Public*Routine******************************\
* wglGetClipList
*
* Gets the visible region in the form of a list of rectangles,
* for the window associated with the given window.  The data is placed
* in the GLGENwindow structure.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  01-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY wglGetClipList(GLGENwindow *pwnd)
{
    UINT cj;
    RECT rc;

// Set clipping to empty.  If an error occurs getting clip information,
// all drawing will be clipped.

    pwnd->clipComplexity = CLC_RECT;
    pwnd->rclBounds.left   = 0;
    pwnd->rclBounds.top    = 0;
    pwnd->rclBounds.right  = 0;
    pwnd->rclBounds.bottom = 0;

// Make sure we have enough memory to cache the clip list.

    if (pwnd->pddClip->lpVtbl->
        GetClipList(pwnd->pddClip, NULL, NULL, &cj) == DD_OK)
    {
        if ( cj > pwnd->cjrgndat || !pwnd->prgndat )
        {
            if ( pwnd->prgndat )
                FREE(pwnd->prgndat);

            pwnd->prgndat = ALLOC(pwnd->cjrgndat = cj);
            if ( !pwnd->prgndat )
            {
                WARNING("wglGetClipList(): memory failure\n");
                pwnd->cjrgndat = 0;
                return FALSE;
            }
        }
    }
    else
    {
        WARNING("wglGetClipList(): clipper failed to return size\n");
        return FALSE;
    }

// Get the clip list (RGNDATA format).

    if ( pwnd->pddClip->lpVtbl->
         GetClipList(pwnd->pddClip, NULL, pwnd->prgndat, &cj) == DD_OK )
    {
    // Compose the scan version of the clip list.

        if (!wglMakeScans(pwnd))
        {
            WARNING("wglGetClipList(): scan conversion failed\n");
            return FALSE;
        }
    }
    else
    {
        WARNING("wglGetClipList(): clipper failed\n");
        return FALSE;
    }

// Fixup the protected portions of the window.

    ASSERT_WINCRIT(pwnd);
    
    {
        __GLGENbuffers *buffers;

    // Update rclBounds to match RGNDATA bounds.

        pwnd->rclBounds = *(RECTL *) &pwnd->prgndat->rdh.rcBound;

    // Update rclClient to match client area.  We cannot do this from the
    // information in RGNDATA as the bounds may be smaller than the window
    // client area.  We will have to call GetClientRect().

        GetClientRect(pwnd->gwid.hwnd, (LPRECT) &pwnd->rclClient);
        ClientToScreen(pwnd->gwid.hwnd, (LPPOINT) &pwnd->rclClient);
        pwnd->rclClient.right += pwnd->rclClient.left;
        pwnd->rclClient.bottom += pwnd->rclClient.top;

    //
    // Setup window clip complexity
    //
        if ( pwnd->prgndat->rdh.nCount > 1 )
        {
	    // Clip list will be used for clipping.
            pwnd->clipComplexity = CLC_COMPLEX;
        }
        else if ( pwnd->prgndat->rdh.nCount == 1 )
        {
            RECT *prc = (RECT *) pwnd->prgndat->Buffer;

        // Recently, DirectDraw has been occasionally returning rclBounds
        // set to the screen dimensions.  This is being investigated as a
        // bug on DDraw's part, but let us protect ourselves in any case.
        //
        // When there is only a single clip rectangle, it should be
        // the same as the bounds.

            pwnd->rclBounds = *((RECTL *) prc);

        // If bounds rectangle is smaller than client area, we need to
        // clip to the bounds rectangle.  Otherwise, clip to the window
        // client area.

            if ( (pwnd->rclBounds.left   <= pwnd->rclClient.left  ) &&
                 (pwnd->rclBounds.right  >= pwnd->rclClient.right ) &&
                 (pwnd->rclBounds.top    <= pwnd->rclClient.top   ) &&
                 (pwnd->rclBounds.bottom >= pwnd->rclClient.bottom) )
                pwnd->clipComplexity = CLC_TRIVIAL;
            else
                pwnd->clipComplexity = CLC_RECT;
        }
        else
        {
        // Clip count is zero.  Bounds should be an empty rectangle.

            pwnd->clipComplexity = CLC_RECT;

            pwnd->rclBounds.left   = 0;
            pwnd->rclBounds.top    = 0;
            pwnd->rclBounds.right  = 0;
            pwnd->rclBounds.bottom = 0;
        }

    // Finally, the window has changed, so change the uniqueness number.

        if ((buffers = pwnd->buffers))
        {
            buffers->WndUniq++;

        // Don't let it hit -1.  -1 is special and is used by
        // MakeCurrent to signal that an update is required

            if (buffers->WndUniq == -1)
                buffers->WndUniq = 0;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* wglCleanupWindow
*
* Removes references to the specified window from
* all contexts by running through the list of RCs in the handle manager
* table.
*
* History:
*  05-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY wglCleanupWindow(GLGENwindow *pwnd)
{
    if (pwnd)
    {
    //!!!XXX -- For now remove reference from current context.  Need to
    //!!!XXX    scrub all contexts for multi-threaded cleanup to work.
    //!!!XXX    We need to implement a gengc tracking mechanism.

        __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();

        if ( gengc && (gengc->pwndMakeCur == pwnd) )
        {
        // Found a victim.  Must NULL out the pointer both in the RC
        // and in the generic context.

            glsrvCleanupWindow(gengc, pwnd);
        }
    }
}

/******************************Public*Routine******************************\
* wglGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This wgl version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

UINT APIENTRY wglGetSystemPaletteEntries(
    HDC hdc,
    UINT iStartIndex,
    UINT nEntries,
    LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\fastpoly.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winddi.h>

#include "render.h"
#include "context.h"
#include "global.h"
#include "gencx.h"
#include "..\inc\wglp.h"

#define FLT_TO_FIX(value) \
    *((GLint *)&value) = (GLint)(*((__GLfloat *)&(value)) * (__GLfloat)65536.0)

/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

void __fastTriangleSetup(__GLcontext *gc)
{
    SPANREC deltaRec;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
        if (gc->polygon.shader.modeFlags & __GL_SHADE_DITHER) {
            __fastRGBSmoothSpanSetup(gc);
            __fastRGBFlatSpanSetup(gc);
        } else {
            __fastRGBNDSmoothSpanSetup(gc);
            __fastRGBNDFlatSpanSetup(gc);
        }
    } else {
        if (gc->polygon.shader.modeFlags & __GL_SHADE_DITHER) {
            __fastCISmoothSpanSetup(gc);
            __fastCIFlatSpanSetup(gc);
        } else {
            __fastCINDSmoothSpanSetup(gc);
            __fastCINDFlatSpanSetup(gc);
        }
    }

    deltaRec.r = 0;
    deltaRec.g = 0;
    deltaRec.b = 0;
    deltaRec.a = 0;
    deltaRec.z = 0;

    __fastDeltaSpan(gc, &deltaRec);     // Set up initial delta values
}

/*static*/ void fastFillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint dxLeftFrac, dxRightFrac;
    GLint dxLeftLittle, dxRightLittle;
    GLint dxLeftBig, dxRightBig;
    GLint spanWidth, clipY0, clipY1;
    GLuint modeFlags;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    GLuint maxWidth;
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif
    __GLspanFunc spanFunc = 
        ((FASTFUNCS *)(*((VOID **)(gengc->pPrivateArea))))->__fastSpanFuncPtr;

#ifdef NT
    maxWidth = (gc->transform.clipX1 - gc->transform.clipX0) + 31;
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = __wglTempAlloc(gc, (maxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
#endif
    
    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;
    dxLeftFrac = gc->polygon.shader.dxLeftFrac;
    dxLeftBig = gc->polygon.shader.dxLeftBig;
    dxLeftLittle = gc->polygon.shader.dxLeftLittle;
    dxRightFrac = gc->polygon.shader.dxRightFrac;
    dxRightBig = gc->polygon.shader.dxRightBig;
    dxRightLittle = gc->polygon.shader.dxRightLittle;
    modeFlags = gc->polygon.shader.modeFlags;
    gc->polygon.shader.stipplePat = words;

    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
	gc->polygon.shader.zbuf =
	    __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
			    ixLeft, iyBottom);
    }
    gc->polygon.shader.cfb = gc->drawBuffer;
    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
	    gc->polygon.shader.length = spanWidth;

            if (gc->state.raster.drawBuffer == GL_FRONT_AND_BACK) {
                gc->polygon.shader.cfb = &gc->frontBuffer;
                (*spanFunc)(gc);

                if (!((GLint)gc->polygon.shader.cfb->buf.other & DIB_FORMAT))
                    wglCopyBits(gengc->pdco, gengc->pwo, gengc->ColorsBitmap,
                                __GL_UNBIAS_X(gc, ixLeft) + 
                                              gc->drawBuffer->buf.xOrigin,
                                __GL_UNBIAS_Y(gc, iyBottom) + 
                                              gc->drawBuffer->buf.yOrigin,
                                spanWidth, TRUE);


                gc->polygon.shader.cfb = &gc->backBuffer;
                (*spanFunc)(gc);
            } else {

                (*spanFunc)(gc);

                if (!((GLint)gc->drawBuffer->buf.other & DIB_FORMAT))
                    wglCopyBits(gengc->pdco, gengc->pwo, gengc->ColorsBitmap,
                                __GL_UNBIAS_X(gc, ixLeft) + 
                                              gc->drawBuffer->buf.xOrigin,
                                __GL_UNBIAS_Y(gc, iyBottom) + 
                                              gc->drawBuffer->buf.yOrigin,
                                spanWidth, TRUE);
            }
	}

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

	    if (modeFlags & __GL_SHADE_RGB) {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rBig);
		    *((GLint *)&gc->polygon.shader.frag.color.g) += 
                        *((GLint *)&gc->polygon.shader.gBig);
		    *((GLint *)&gc->polygon.shader.frag.color.b) += 
                        *((GLint *)&gc->polygon.shader.bBig);
		    *((GLint *)&gc->polygon.shader.frag.color.a) += 
                        *((GLint *)&gc->polygon.shader.aBig);
		}
	    } else {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rBig);
		}
	    }
	    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
		gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
	    }

	    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
		/* The implicit multiply is taken out of the loop */
		gc->polygon.shader.zbuf = (__GLzValue*)
		    ((GLubyte*) gc->polygon.shader.zbuf
		     + gc->polygon.shader.zbufBig);
	    }
	} else {
	    /* Use small step */
	    ixLeft += dxLeftLittle;
	    if (modeFlags & __GL_SHADE_RGB) {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rLittle);
		    *((GLint *)&gc->polygon.shader.frag.color.g) += 
                        *((GLint *)&gc->polygon.shader.gLittle);
		    *((GLint *)&gc->polygon.shader.frag.color.b) += 
                        *((GLint *)&gc->polygon.shader.bLittle);
		    *((GLint *)&gc->polygon.shader.frag.color.a) += 
                        *((GLint *)&gc->polygon.shader.aLittle);
		}
	    } else {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rLittle);
		}
            }
	    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
		gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
	    }
	    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
		/* The implicit multiply is taken out of the loop */
		gc->polygon.shader.zbuf = (__GLzValue*)
		    ((GLubyte*) gc->polygon.shader.zbuf
		     + gc->polygon.shader.zbufLittle);
	    }
	}
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;

#ifdef NT
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        __wglTempFree(gc, words);
    }
#endif
}

#define __TWO_31 ((__GLfloat) 2147483648.0)

#define __FRACTION(result,f) \
    result = (GLint) ((f) * __TWO_31)

static void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    __GLfloat little, dx;
    GLint ixLeft, ixLeftFrac, frac, lineBytes, elementSize, ilittle, ibig;

    ixLeft = (GLint) xLeft;
    dx = xLeft - ixLeft;
    __FRACTION(ixLeftFrac,dx);

    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixLeftFrac += 0x40000000;
    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);
    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;

    /* Compute big and little steps */
    ilittle = (GLint) dxdyLeft;
    little = (__GLfloat) ilittle;
    if (dxdyLeft < 0) {
	ibig = ilittle - 1;
	dx = little - dxdyLeft;
	__FRACTION(frac,dx);
	gc->polygon.shader.dxLeftFrac = -frac;
    } else {
	ibig = ilittle + 1;
	dx = dxdyLeft - little;
	__FRACTION(frac,dx);
	gc->polygon.shader.dxLeftFrac = frac;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
	/*
	** Compute the big and little depth buffer steps.  We walk the
	** memory pointers for the depth buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
	elementSize = gc->depthBuffer.buf.elementSize;
	lineBytes = elementSize * gc->depthBuffer.buf.outerWidth;
	gc->polygon.shader.zbufLittle = lineBytes + ilittle * elementSize;
	gc->polygon.shader.zbufBig = lineBytes + ibig * elementSize;
    }
    gc->polygon.shader.dxLeftLittle = ilittle;
    gc->polygon.shader.dxLeftBig = ibig;
}

static void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight)
{
    __GLfloat little, big, dx;
    GLint ixRight, ixRightFrac, frac;

    ixRight = (GLint) xRight;
    dx = xRight - ixRight;
    __FRACTION(ixRightFrac,dx);

    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixRightFrac += 0x40000000;
    sh->ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);
    sh->ixRightFrac = ixRightFrac & ~0x80000000;

    /* Compute big and little steps */
    little = (__GLfloat) ((GLint) dxdyRight);
    if (dxdyRight < 0) {
	big = little - 1;
	dx = little - dxdyRight;
	__FRACTION(frac,dx);
	sh->dxRightFrac = -frac;
    } else {
	big = little + 1;
	dx = dxdyRight - little;
	__FRACTION(frac,dx);
	sh->dxRightFrac = frac;
    }
    sh->dxRightLittle = (GLint) little;
    sh->dxRightBig = (GLint) big;
}

static void SetInitialParameters(__GLshade *sh, const __GLvertex *a,
				 const __GLcolor *ac, __GLfloat aFog,
				 __GLfloat dx, __GLfloat dy)
{
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    GLuint modeFlags = sh->modeFlags;

    if (big > little) {
	if (modeFlags & __GL_SHADE_RGB) {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle + sh->drdx;

		sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
		sh->gLittle = sh->dgdy + little * sh->dgdx;
		sh->gBig = sh->gLittle + sh->dgdx;

		sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
		sh->bLittle = sh->dbdy + little * sh->dbdx;
		sh->bBig = sh->bLittle + sh->dbdx;

		sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
		sh->aLittle = sh->dady + little * sh->dadx;
		sh->aBig =sh->aLittle + sh->dadx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->frag.color.g);
                FLT_TO_FIX(sh->frag.color.b);
                FLT_TO_FIX(sh->frag.color.a);

                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->gLittle);
                FLT_TO_FIX(sh->bLittle);
                FLT_TO_FIX(sh->aLittle);

                FLT_TO_FIX(sh->rBig);
                FLT_TO_FIX(sh->gBig);
                FLT_TO_FIX(sh->bBig);
                FLT_TO_FIX(sh->aBig);

	    }
	} else {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle + sh->drdx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->rBig);
            }
	}
	if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    __GLfloat zLittle;

	    sh->frag.z = (__GLzValue)
		(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf);
	    zLittle = sh->dzdyf + little * sh->dzdxf;
	    sh->zLittle = (GLint)zLittle;
	    sh->zBig = (GLint)(zLittle + sh->dzdxf);
	}
	if (modeFlags & __GL_SHADE_SLOW_FOG) {
	    sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
	    sh->fLittle = sh->dfdy + little * sh->dfdx;
	    sh->fBig = sh->fLittle + sh->dfdx;

            FLT_TO_FIX(sh->frag.f);
            FLT_TO_FIX(sh->fLittle);
            FLT_TO_FIX(sh->fBig);
	}
    } else {	
	if (modeFlags & __GL_SHADE_RGB) {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle - sh->drdx;

		sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
		sh->gLittle = sh->dgdy + little * sh->dgdx;
		sh->gBig = sh->gLittle - sh->dgdx;

		sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
		sh->bLittle = sh->dbdy + little * sh->dbdx;
		sh->bBig = sh->bLittle - sh->dbdx;

		sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
		sh->aLittle = sh->dady + little * sh->dadx;
		sh->aBig =sh->aLittle - sh->dadx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->frag.color.g);
                FLT_TO_FIX(sh->frag.color.b);
                FLT_TO_FIX(sh->frag.color.a);

                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->gLittle);
                FLT_TO_FIX(sh->bLittle);
                FLT_TO_FIX(sh->aLittle);

                FLT_TO_FIX(sh->rBig);
                FLT_TO_FIX(sh->gBig);
                FLT_TO_FIX(sh->bBig);
                FLT_TO_FIX(sh->aBig);
	    }
	} else {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle - sh->drdx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->rBig);
	    }
	}
	if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    __GLfloat zLittle;
	    sh->frag.z = (__GLzValue)
		(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf);
	    zLittle = sh->dzdyf + little * sh->dzdxf;
	    sh->zLittle = (GLint)zLittle;
	    sh->zBig = (GLint)(zLittle - sh->dzdxf);
	}
	if (modeFlags & __GL_SHADE_SLOW_FOG) {
	    sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
	    sh->fLittle = sh->dfdy + little * sh->dfdx;
	    sh->fBig = sh->fLittle - sh->dfdx;

            FLT_TO_FIX(sh->frag.f);
            FLT_TO_FIX(sh->fLittle);
            FLT_TO_FIX(sh->fBig);
	}
    }
}


void __fastFillTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                        __GLvertex *c, GLboolean ccw)

{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLfloat aFog, bFog;
    __GLfloat dxAB, dyAB;
    __GLfloat dx, dy, dxdyLeft, dxdyRight;
    __GLcolor *ac, *bc;
    GLint aIY, bIY, cIY;
    GLuint modeFlags;
    SPANREC deltaRec;


    /* Pre-compute one over polygon area */

    oneOverArea = __glOne / gc->polygon.shader.area;

    /* Fetch some stuff we are going to reuse */
    modeFlags = gc->polygon.shader.modeFlags;
    dxAC = gc->polygon.shader.dxAC;
    dxBC = gc->polygon.shader.dxBC;
    dyAC = gc->polygon.shader.dyAC;
    dyBC = gc->polygon.shader.dyBC;
    ac = a->color;
    bc = b->color;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */
    t1 = dyAC * oneOverArea;
    t2 = dyBC * oneOverArea;
    t3 = dxAC * oneOverArea;
    t4 = dxBC * oneOverArea;
    if (modeFlags & __GL_SHADE_RGB) {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	    dgAC = ac->g - cc->g;
	    dgBC = bc->g - cc->g;
	    gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
	    gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
	    dbAC = ac->b - cc->b;
	    dbBC = bc->b - cc->b;
	    gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
	    gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;
	    daAC = ac->a - cc->a;
	    daBC = bc->a - cc->a;
	    gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
	    gc->polygon.shader.dady = daBC * t3 - daAC * t4;

            RtlCopyMemory(&deltaRec.r, &gc->polygon.shader.drdx, 
                          4 * sizeof(__GLfloat));

            FLT_TO_FIX(deltaRec.r);
            FLT_TO_FIX(deltaRec.g);
            FLT_TO_FIX(deltaRec.b);
            FLT_TO_FIX(deltaRec.a);
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color.r = flatColor->r;
	    gc->polygon.shader.frag.color.g = flatColor->g;
	    gc->polygon.shader.frag.color.b = flatColor->b;
	    gc->polygon.shader.frag.color.a = flatColor->a;

            FLT_TO_FIX(gc->polygon.shader.frag.color.r);
            FLT_TO_FIX(gc->polygon.shader.frag.color.g);
            FLT_TO_FIX(gc->polygon.shader.frag.color.b);
            FLT_TO_FIX(gc->polygon.shader.frag.color.a);
	}
    } else {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;

            deltaRec.r = *((GLint *)&gc->polygon.shader.drdx);
            FLT_TO_FIX(deltaRec.r);
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color.r = flatColor->r;
            FLT_TO_FIX(gc->polygon.shader.frag.color.r);
	}
    }
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	__GLfloat dzAC, dzBC;

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;
	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
	deltaRec.z = gc->polygon.shader.dzdx = (GLint) gc->polygon.shader.dzdxf;
    }

    __fastDeltaSpan(gc, &deltaRec);     // Set up span delta values


    /* Snap each y coordinate to its pixel center */
    aIY = (GLint) (a->window.y + __glHalf);
    bIY = (GLint) (b->window.y + __glHalf);
    cIY = (GLint) (c->window.y + __glHalf);

    /*
    ** This algorithim always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */
    dxAB = a->window.x - b->window.x;
    dyAB = a->window.y - b->window.y;
    if (ccw) {
	dxdyLeft = dxAC / dyAC;
	dy = (aIY + __glHalf) - a->window.y;
	SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
	if (aIY != bIY) {
	    dxdyRight = dxAB / dyAB;
	    SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight,
		       dxdyRight);
	    fastFillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyRight = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXRight(&gc->polygon.shader, b->window.x + dy*dxdyRight,
		       dxdyRight);
	    fastFillSubTriangle(gc, bIY, cIY);
	}
    } else {
	dxdyRight = dxAC / dyAC;
	dy = (aIY + __glHalf) - a->window.y;
	SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight, dxdyRight);
	if (aIY != bIY) {
	    dxdyLeft = dxAB / dyAB;
	    SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	    SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
	    fastFillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyLeft = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXLeft(gc, b->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
	    SetInitialParameters(&gc->polygon.shader, b, bc, bFog, dx, dy);
	    fastFillSubTriangle(gc, bIY, cIY);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\gli386.c ===
/******************************Module*Header*******************************\
* Module Name: gli386.c                                                    *
*                                                                          *
* This module implements a program which generates structure offset        *
* definitions for OpenGL structures that are accessed in assembly code.    *
*                                                                          *
* Created: 24-Aug-1992 01:24:49                                            *
* Author: Charles Whitmer [chuckwh]                                        *
* Ported for OpenGL 4/1/1994 Otto Berkes [ottob]                           *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <windows.h>
#include <ddraw.h>

#include <glp.h>
#include "types.h"
#include "context.h"
#include "render.h"
#include "attrib.h"
#include "gencx.h"
#define __BUILD_GLI386__
#include "..\..\dlist\dl_pdata.h"


#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     fprintf(outfh,"\n")

// pstruct defines an empty structure with the correct size.

#define pstruct(n,c) fprintf(outfh,                           \
                     "%s  struc\n  db %d dup(0)\n%s  ends\n", \
                     n,c,n);

// pstr prints a string.

#define pstr(s)  fprintf(outfh,"%s\n",s)


// pcomment prints a comment.

#define pcomment(s)  fprintf(outfh,"; %s\n",s)

// pequate prints an equate statement.

#define pequate(m,v) fprintf(outfh,"%s equ 0%lXH\n",m,v);

void CreateInc(FILE *outfh)
{
    __GLmatrix *m = 0;
    __GLfloat one = (__GLfloat)1;
    
    pblank();
    pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: gli386.inc");
    pcomment("");
    pcomment(" Defines OpenGL assembly-language structures.");
    pcomment("");
    pcomment(" Copyright (c) 1994, 1995 Microsoft Corporation");
    pcomment("------------------------------------------------------------------");
    pblank();
    pblank();
    pblank();

    pcomment("Matrix structure offsets");
    pblank();
    pequate("__MATRIX_M00           ", &m->matrix[0][0]);
    pequate("__MATRIX_M01           ", &m->matrix[0][1]);
    pequate("__MATRIX_M02           ", &m->matrix[0][2]);
    pequate("__MATRIX_M03           ", &m->matrix[0][3]);
    pequate("__MATRIX_M10           ", &m->matrix[1][0]);
    pequate("__MATRIX_M11           ", &m->matrix[1][1]);
    pequate("__MATRIX_M12           ", &m->matrix[1][2]);
    pequate("__MATRIX_M13           ", &m->matrix[1][3]);
    pequate("__MATRIX_M20           ", &m->matrix[2][0]);
    pequate("__MATRIX_M21           ", &m->matrix[2][1]);
    pequate("__MATRIX_M22           ", &m->matrix[2][2]);
    pequate("__MATRIX_M23           ", &m->matrix[2][3]);
    pequate("__MATRIX_M30           ", &m->matrix[3][0]);
    pequate("__MATRIX_M31           ", &m->matrix[3][1]);
    pequate("__MATRIX_M32           ", &m->matrix[3][2]);
    pequate("__MATRIX_M33           ", &m->matrix[3][3]);
    pblank();

    // GLGENwindow

    pcomment("GLGENwindow structure");
    pblank();
    pequate("GENWIN_sem             ", OFFSET(GLGENwindow, sem));
    pequate("GENWIN_lUsers          ", OFFSET(GLGENwindow, lUsers));
    pequate("GENWIN_gengc           ", OFFSET(GLGENwindow, gengc));
    pequate("GENWIN_owningThread    ", OFFSET(GLGENwindow, owningThread));
    pequate("GENWIN_lockRecursion   ", OFFSET(GLGENwindow, lockRecursion));
    pblank();

// Stuff from: \nt\private\windows\gdi\opengl\server\inc\gencx.h

    pcomment("__GLGENcontextRec structure");
    pblank();
    pstruct("GLGENcontextRec",sizeof(struct __GLGENcontextRec));
    pblank();
    pequate("GENCTX_hrc               ",OFFSET(struct __GLGENcontextRec,hrc       ));
    pequate("GENCTX_pajTranslateVector",OFFSET(struct __GLGENcontextRec,pajTranslateVector));
    pequate("GENCTX_pPrivateArea      ",OFFSET(struct __GLGENcontextRec,pPrivateArea));
    pequate("GENGC_ColorsBits         ",OFFSET(struct __GLGENcontextRec,ColorsBits));
    pequate("GENGC_SPAN_r             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.r));
    pequate("GENGC_SPAN_g             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.g));
    pequate("GENGC_SPAN_b             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.b));
    pequate("GENGC_SPAN_a             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.a));
    pequate("GENGC_SPAN_s             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.s));
    pequate("GENGC_SPAN_t             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.t));
    pequate("GENGC_SPAN_dr            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.r));
    pequate("GENGC_SPAN_dg            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.g));
    pequate("GENGC_SPAN_db            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.b));
    pequate("GENGC_SPAN_da            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.a));
    pequate("GENGC_SPAN_ds            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.s));
    pequate("GENGC_SPAN_dt            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.t));
    pequate("GENGC_SPAN_z             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.z));
    pequate("GENGC_SPAN_dz            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dzdx));
    pequate("GENGC_SPAN_zbuf          ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.zbuf));
    pequate("GENGC_SPAN_ppix          ",OFFSET(struct __GLGENcontextRec,genAccel.pPix));
    pequate("GENGC_SPAN_x             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.x));
    pequate("GENGC_SPAN_y             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.y));
    pequate("GENGC_SPAN_length        ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.length));
    pequate("GENGC_rAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.rAccum));
    pequate("GENGC_gAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.gAccum));
    pequate("GENGC_bAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.bAccum));
    pequate("GENGC_aAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.aAccum));
    pequate("GENGC_zAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.zAccum));
    pequate("GENGC_sAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.sAccum));
    pequate("GENGC_tAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.tAccum));
    pequate("GENGC_pixAccum           ",OFFSET(struct __GLGENcontextRec,genAccel.pixAccum));
    pequate("GENGC_ditherAccum        ",OFFSET(struct __GLGENcontextRec,genAccel.ditherAccum));
    pequate("GENGC_sResult            ",OFFSET(struct __GLGENcontextRec,genAccel.sResult[0]));
    pequate("GENGC_tResult            ",OFFSET(struct __GLGENcontextRec,genAccel.tResult[0]));
    pequate("GENGC_sResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.sResultNew[0]));
    pequate("GENGC_tResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.tResultNew[0]));
    pequate("GENGC_sMask              ",OFFSET(struct __GLGENcontextRec,genAccel.sMask));
    pequate("GENGC_tMaskSubDiv        ",OFFSET(struct __GLGENcontextRec,genAccel.tMaskSubDiv));
    pequate("GENGC_tShiftSubDiv       ",OFFSET(struct __GLGENcontextRec,genAccel.tShiftSubDiv));
    pequate("GENGC_texImage           ",OFFSET(struct __GLGENcontextRec,genAccel.texImage));
    pequate("GENGC_texImageReplace    ",OFFSET(struct __GLGENcontextRec,genAccel.texImageReplace));
    pequate("GENGC_texPalette         ",OFFSET(struct __GLGENcontextRec,genAccel.texPalette));
    pequate("GENGC_qwAccum            ",OFFSET(struct __GLGENcontextRec,genAccel.qwAccum));
    pequate("GENGC_SPAN_dqwdx         ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dqwdx));
    pequate("GENGC_SPAN_qw            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.qw));
    pequate("GENGC_xlatPalette        ",OFFSET(struct __GLGENcontextRec,xlatPalette));
    pequate("GENGC_sStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.sStepX));
    pequate("GENGC_tStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.tStepX));
    pequate("GENGC_qwStepX            ",OFFSET(struct __GLGENcontextRec,genAccel.qwStepX));
    pequate("GENGC_subDs              ",OFFSET(struct __GLGENcontextRec,genAccel.subDs));
    pequate("GENGC_subDt              ",OFFSET(struct __GLGENcontextRec,genAccel.subDt));
    pequate("GENGC_rDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[0]));
    pequate("GENGC_gDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[1]));
    pequate("GENGC_bDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[2]));
    pequate("GENGC_aDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[3]));
    pequate("GENGC_bytesPerPixel      ",OFFSET(struct __GLGENcontextRec,genAccel.xMultiplier));
    pequate("GENGC_bpp                ",OFFSET(struct __GLGENcontextRec,genAccel.bpp));
    pequate("GENGC_flags              ",OFFSET(struct __GLGENcontextRec,genAccel.flags));
    pequate("GENGC_pInvTranslateVector",OFFSET(struct __GLGENcontextRec,pajInvTranslateVector));
    pequate("GENGC_pwndMakeCur        ", OFFSET(__GLGENcontext, pwndMakeCur));
    pequate("GENGC_pwndLocked         ", OFFSET(__GLGENcontext, pwndLocked));
    pequate("GENGC_fsLocks            ", OFFSET(__GLGENcontext, fsLocks));
    pequate("GENGC_fsGenLocks         ", OFFSET(__GLGENcontext, fsGenLocks));
    pblank();
    
    pequate("COLOR_r                ",OFFSET(struct __GLcolorRec,r  ));
    pequate("COLOR_g                ",OFFSET(struct __GLcolorRec,g  ));
    pequate("COLOR_b                ",OFFSET(struct __GLcolorRec,b  ));
    pequate("COLOR_a                ",OFFSET(struct __GLcolorRec,a  ));
    pblank();

// Stuff from: \nt\private\windows\gdi\opengl\server\inc\gencx.h

    pcomment("__GLcontextRec structure");
    pblank();
    pblank();
    pequate("GC_paTeb                   ",OFFSET(struct __GLcontextRec,paTeb));
    pequate("GC_oneOverRedVertexScale   ",OFFSET(struct __GLcontextRec,oneOverRedVertexScale));
    pequate("GC_oneOverGreenVertexScale ",OFFSET(struct __GLcontextRec,oneOverGreenVertexScale));
    pequate("GC_oneOverBlueVertexScale  ",OFFSET(struct __GLcontextRec,oneOverBlueVertexScale));
    pequate("GC_redVertexScale          ",OFFSET(struct __GLcontextRec,redVertexScale));
    pequate("GC_greenVertexScale        ",OFFSET(struct __GLcontextRec,greenVertexScale));
    pequate("GC_blueVertexScale         ",OFFSET(struct __GLcontextRec,blueVertexScale));
    pequate("GC_alphaVertexScale        ",OFFSET(struct __GLcontextRec,alphaVertexScale));
    pequate("GC_redClampTable           ",OFFSET(struct __GLcontextRec,redClampTable[0]));
    pequate("GC_greenClampTable         ",OFFSET(struct __GLcontextRec,greenClampTable[0]));
    pequate("GC_blueClampTable          ",OFFSET(struct __GLcontextRec,blueClampTable[0]));
    pequate("GC_alphaClampTable         ",OFFSET(struct __GLcontextRec,alphaClampTable[0]));


    pequate("GC_SHADER_R            ", OFFSET(__GLcontext, polygon.shader.frag.color.r));
    pequate("GC_SHADER_G            ", OFFSET(__GLcontext, polygon.shader.frag.color.g));
    pequate("GC_SHADER_B            ", OFFSET(__GLcontext, polygon.shader.frag.color.b));
    pequate("GC_SHADER_A            ", OFFSET(__GLcontext, polygon.shader.frag.color.a));
    pequate("GC_SHADER_DRDX         ", OFFSET(__GLcontext, polygon.shader.drdx));
    pequate("GC_SHADER_DGDX         ", OFFSET(__GLcontext, polygon.shader.dgdx));
    pequate("GC_SHADER_DBDX         ", OFFSET(__GLcontext, polygon.shader.dbdx));
    pequate("GC_SHADER_DADX         ", OFFSET(__GLcontext, polygon.shader.dadx));
    pblank();

    pequate("GC_LIGHT_front         ", OFFSET(__GLcontext, light.front));
    pequate("GC_LIGHT_back          ", OFFSET(__GLcontext, light.back));
    pblank();

    pequate("GC_mInv                ", OFFSET(__GLcontext, mInv));
    pblank();


    pcomment("Other constants");
    pblank();
    pequate("__FLOAT_ONE                 ", *(long*)&one);
    pblank();
    pequate("SURFACE_TYPE_DIB            ", SURFACE_TYPE_DIB);
    pequate("GEN_TEXTURE_ORTHO           ", GEN_TEXTURE_ORTHO);
    pequate("PANEEDS_NORMAL              ", PANEEDS_NORMAL);
    pequate("__GL_CLIP_USER0             ", __GL_CLIP_USER0);
    pequate("__GL_FRONTFACE              ", __GL_FRONTFACE);
    pequate("__GL_BACKFACE               ", __GL_BACKFACE);
    pequate("__GL_NORMALIZE_ENABLE       ", __GL_NORMALIZE_ENABLE);
    pequate("__GL_SPEC_LOOKUP_TABLE_SIZE ", __GL_SPEC_LOOKUP_TABLE_SIZE);
    pequate("__GL_MATERIAL_AMBIENT       ", __GL_MATERIAL_AMBIENT);
    pequate("__GL_MATERIAL_DIFFUSE       ", __GL_MATERIAL_DIFFUSE);
    pequate("__GL_MATERIAL_SPECULAR      ", __GL_MATERIAL_SPECULAR);
    pequate("__GL_MATERIAL_EMISSIVE      ", __GL_MATERIAL_EMISSIVE);
    
    pblank();
    pequate("GC_SHADE_rLittle       ",OFFSET(__GLcontext, polygon.shader.rLittle));
    pequate("GC_SHADE_gLittle       ",OFFSET(__GLcontext, polygon.shader.gLittle));
    pequate("GC_SHADE_bLittle       ",OFFSET(__GLcontext, polygon.shader.bLittle));
    pequate("GC_SHADE_aLittle       ",OFFSET(__GLcontext, polygon.shader.aLittle));

    pblank();
    pequate("GC_SHADE_drdy          ",OFFSET(__GLcontext, polygon.shader.drdy));
    pequate("GC_SHADE_dgdy          ",OFFSET(__GLcontext, polygon.shader.dgdy));
    pequate("GC_SHADE_dbdy          ",OFFSET(__GLcontext, polygon.shader.dbdy));
    pequate("GC_SHADE_dady          ",OFFSET(__GLcontext, polygon.shader.dady));

    pblank();
    pequate("GC_SHADE_drdx          ",OFFSET(__GLcontext, polygon.shader.drdx           ));
    pequate("GC_SHADE_dgdx          ",OFFSET(__GLcontext, polygon.shader.dgdx           ));
    pequate("GC_SHADE_dbdx          ",OFFSET(__GLcontext, polygon.shader.dbdx           ));
    pequate("GC_SHADE_dadx          ",OFFSET(__GLcontext, polygon.shader.dadx           ));

    pblank();
    pequate("GC_VIEWPORT_xScale     ", OFFSET(__GLcontext, state.viewport.xScale));
    pequate("GC_VIEWPORT_yScale     ", OFFSET(__GLcontext, state.viewport.yScale));
    pequate("GC_VIEWPORT_zScale     ", OFFSET(__GLcontext, state.viewport.zScale));
    pequate("GC_VIEWPORT_xCenter    ", OFFSET(__GLcontext, state.viewport.xCenter));
    pequate("GC_VIEWPORT_yCenter    ", OFFSET(__GLcontext, state.viewport.yCenter));
    pequate("GC_VIEWPORT_zCenter    ", OFFSET(__GLcontext, state.viewport.zCenter));

    pblank();
    pequate("GC_STATE_clipPlanes0       ",OFFSET(__GLcontext, state.transform.eyeClipPlanes));
    pequate("GC_STATE_enablesClipPlanes ",OFFSET(__GLcontext, state.enables.clipPlanes));
    pequate("GC_STATE_enablesGeneral    ",OFFSET(__GLcontext, state.enables.general));
    pequate("GC_STATE_lightModelAmbient ",OFFSET(__GLcontext, state.light.model.ambient));

    pblank();
    pequate("GC_LIGHT_sources       ",OFFSET(__GLcontext, light.sources));

    pblank();
    pequate("GC_VERTEX_paNeeds      ",OFFSET(__GLcontext, vertex.paNeeds));

    pblank();
    pequate("VERTEX_color           ", OFFSET(__GLvertex, color));

    pblank();
#ifndef _WIN95_
    pequate("TeglPaTeb              ", TeglPaTeb);
    pequate("TeglSectionInfo        ", TeglSectionInfo);
#else
    pequate("GtiPaTeb               ", OFFSET(GLTEBINFO, glReserved1));
    pequate("GtiSectionInfo         ", OFFSET(GLTEBINFO, glSectionInfo));
#endif

    pblank();
    pequate("sizeof_MATERIAL                ", sizeof(__GLmaterialMachine));
    pequate("MATERIAL_scale                 ", OFFSET(__GLmaterialMachine, scale));
    pequate("MATERIAL_threshold             ", OFFSET(__GLmaterialMachine, threshold));
    pequate("MATERIAL_specTable             ", OFFSET(__GLmaterialMachine, specTable));
    pequate("MATERIAL_alpha                 ", OFFSET(__GLmaterialMachine, alpha));
    pequate("MATERIAL_paSceneColor          ", OFFSET(__GLmaterialMachine, paSceneColor));
    pequate("MATERIAL_colorMaterialChange   ", OFFSET(__GLmaterialMachine, colorMaterialChange));
    pequate("MATERIAL_cachedEmissiveAmbient ", OFFSET(__GLmaterialMachine, cachedEmissiveAmbient));
    pequate("MATERIAL_cachedNonLit          ", OFFSET(__GLmaterialMachine, cachedNonLit));

    pblank();
    pequate("sizeof_LIGHTSOURCE     ", sizeof(__GLlightSourceMachine));
    pequate("LIGHTSOURCE_next       ", OFFSET(__GLlightSourceMachine, next));
    pequate("LIGHTSOURCE_front      ", OFFSET(__GLlightSourceMachine, front));
    pequate("LIGHTSOURCE_back       ", OFFSET(__GLlightSourceMachine, back));
    pequate("LIGHTSOURCE_unitVPpli  ", OFFSET(__GLlightSourceMachine, unitVPpli.x));
    pequate("LIGHTSOURCE_hHat       ", OFFSET(__GLlightSourceMachine, hHat.x));
    pequate("LIGHTSOURCE_state      ", OFFSET(__GLlightSourceMachine, state));

    pblank();
    pequate("sizeof_LIGHTSOURCESTATE   ", sizeof(__GLlightSourceState));
    pequate("LIGHTSOURCESTATE_ambient  ", OFFSET(__GLlightSourceState, ambient));
    pequate("LIGHTSOURCESTATE_diffuse  ", OFFSET(__GLlightSourceState, diffuse));
    pequate("LIGHTSOURCESTATE_specular ", OFFSET(__GLlightSourceState, specular));
   
    pblank();
    pequate("sizeof_LIGHTSOURCEPERMATERIAL   ", sizeof(__GLlightSourcePerMaterialMachine));
    pequate("LIGHTSOURCEPERMATERIAL_ambient  ", OFFSET(__GLlightSourcePerMaterialMachine, ambient.r));
    pequate("LIGHTSOURCEPERMATERIAL_specular ", OFFSET(__GLlightSourcePerMaterialMachine, specular.r));
    pequate("LIGHTSOURCEPERMATERIAL_diffuse  ", OFFSET(__GLlightSourcePerMaterialMachine, diffuse.r));
    
    pblank();
    pequate("PA_flags               ", OFFSET(POLYARRAY, flags));
    pequate("PA_pdNextVertex        ", OFFSET(POLYARRAY, pdNextVertex));
    pequate("PA_pdFlush             ", OFFSET(POLYARRAY, pdFlush));
    pequate("PA_pdCurNormal         ", OFFSET(POLYARRAY, pdCurNormal));
    pequate("PA_pdCurTexture        ", OFFSET(POLYARRAY, pdCurTexture));
    pequate("PA_pdCurColor          ", OFFSET(POLYARRAY, pdCurColor));
    pequate("PA_pd0                 ", OFFSET(POLYARRAY, pd0));
    pequate("PA_andClipCodes        ", OFFSET(POLYARRAY, andClipCodes));
    pequate("PA_orClipCodes         ", OFFSET(POLYARRAY, orClipCodes));
    pequate("POLYARRAY_IN_BEGIN     ", POLYARRAY_IN_BEGIN);
    pequate("POLYARRAY_VERTEX3      ", POLYARRAY_VERTEX3);
    pequate("POLYARRAY_VERTEX2      ", POLYARRAY_VERTEX2);
    pequate("POLYARRAY_TEXTURE2     ", POLYARRAY_TEXTURE2);
    pequate("POLYARRAY_TEXTURE3     ", POLYARRAY_TEXTURE3);
    pequate("POLYARRAY_CLAMP_COLOR  ", POLYARRAY_CLAMP_COLOR);
#ifdef GL_EXT_cull_vertex
    pequate("POLYARRAY_HAS_CULLED_VERTEX", POLYARRAY_HAS_CULLED_VERTEX);
    pequate("GL_EXT_cull_vertex", 1);
    pequate("NOT_GL_CLIP_CULL_VERTEX", ~__GL_CLIP_CULL_VERTEX);
#endif // GL_EXT_cull_vertex

    pblank();
    pequate("PD_flags               ", OFFSET(POLYDATA, flags));
    pequate("PD_obj                 ", OFFSET(POLYDATA, obj.x));
    pequate("PD_normal              ", OFFSET(POLYDATA, normal.x));
    pequate("PD_texture             ", OFFSET(POLYDATA, texture.x));
    pequate("PD_colors0             ", OFFSET(POLYDATA, colors[0].r));
    pequate("PD_clip                ", OFFSET(POLYDATA, clip.x));
    pequate("PD_window              ", OFFSET(POLYDATA, window.x));
    pequate("PD_eye                 ", OFFSET(POLYDATA, eye.x));
    pequate("PD_clipCode            ", OFFSET(POLYDATA, clipCode));
    pequate("POLYDATA_VERTEX3       ", POLYDATA_VERTEX3);
    pequate("POLYDATA_VERTEX2       ", POLYDATA_VERTEX2);
    pequate("POLYDATA_DLIST_TEXTURE2", POLYDATA_DLIST_TEXTURE2);
    pequate("POLYDATA_DLIST_TEXTURE3", POLYDATA_DLIST_TEXTURE3);
    pequate("POLYDATA_NORMAL_VALID  ", POLYDATA_NORMAL_VALID);
    pequate("POLYDATA_TEXTURE_VALID ", POLYDATA_TEXTURE_VALID);
    pequate("POLYDATA_COLOR_VALID   ", POLYDATA_COLOR_VALID);
    pequate("POLYDATA_NORMAL_VALID  ", POLYDATA_NORMAL_VALID);
    pequate("POLYDATA_DLIST_COLOR_4 ", POLYDATA_DLIST_COLOR_4);
    pequate("sizeof_POLYDATA        ", sizeof(POLYDATA));
#ifdef GL_EXT_cull_vertex
    pequate("PD_color               ", OFFSET(POLYDATA, color));
    pequate("POLYDATA_VERTEX_USED   ", POLYDATA_VERTEX_USED);
#endif // GL_EXT_cull_vertex

    pblank();
    pequate("GLMATRIX_xfNorm        ", OFFSET(__GLmatrix, xfNorm));

// Stuff from: \nt\private\windows\gdi\opengl\dlist\dl_pdata.h

    pblank();
    pblank();
    pequate("__PDATA_SIZE_T2F       ", __PDATA_SIZE_T2F);
    pequate("__PDATA_SIZE_C3F       " , __PDATA_SIZE_C3F);
    pequate("__PDATA_SIZE_C4F       ", __PDATA_SIZE_C4F);
    pequate("__PDATA_SIZE_N3F       ", __PDATA_SIZE_N3F);
    pequate("__PDATA_SIZE_V3F       ", __PDATA_SIZE_V3F);
    pequate("__PDATA_PD_FLAGS_T2F   ", __PDATA_PD_FLAGS_T2F);
    pequate("__PDATA_PD_FLAGS_C3F   ", __PDATA_PD_FLAGS_C3F);
    pequate("__PDATA_PD_FLAGS_C4F   ", __PDATA_PD_FLAGS_C4F);
    pequate("__PDATA_PD_FLAGS_N3F   ", __PDATA_PD_FLAGS_N3F);
    pequate("__PDATA_PD_FLAGS_V3F   ", __PDATA_PD_FLAGS_V3F);
    pequate("__PDATA_PA_FLAGS_T2F   ", __PDATA_PA_FLAGS_T2F);
    pequate("__PDATA_PA_FLAGS_C3F   ", __PDATA_PA_FLAGS_C3F);
    pequate("__PDATA_PA_FLAGS_C4F   ", __PDATA_PA_FLAGS_C4F);
    pequate("__PDATA_PA_FLAGS_N3F   ", __PDATA_PA_FLAGS_N3F);
    pequate("__PDATA_PA_FLAGS_V3F   ", __PDATA_PA_FLAGS_V3F);
}

#undef pstruct

// pcomment prints a comment.

#undef pcomment
#define pcomment(s)  fprintf(outfh,"// %s\n",s)

// pequate prints an equate statement.

#undef pequate
#define pequate(m,v) fprintf(outfh,"#define %s 0x%lX\n",m,v);

void CreateH(FILE *outfh)
{
    __GLmatrix *m = 0;
    __GLfloat one = (__GLfloat)1;
    
    pblank();
    pcomment("");
    pcomment(" Module Name: gli386.h");
    pcomment("");
    pcomment(" Defines OpenGL inline assembly structures.");
    pcomment("");
    pcomment(" Copyright (c) 1994-1996 Microsoft Corporation");
    pcomment("");
    pblank();
    pblank();
    pblank();

    pcomment("Matrix structure offsets");
    pblank();
    pequate("__MATRIX_M00", &m->matrix[0][0]);
    pequate("__MATRIX_M01", &m->matrix[0][1]);
    pequate("__MATRIX_M02", &m->matrix[0][2]);
    pequate("__MATRIX_M03", &m->matrix[0][3]);
    pequate("__MATRIX_M10", &m->matrix[1][0]);
    pequate("__MATRIX_M11", &m->matrix[1][1]);
    pequate("__MATRIX_M12", &m->matrix[1][2]);
    pequate("__MATRIX_M13", &m->matrix[1][3]);
    pequate("__MATRIX_M20", &m->matrix[2][0]);
    pequate("__MATRIX_M21", &m->matrix[2][1]);
    pequate("__MATRIX_M22", &m->matrix[2][2]);
    pequate("__MATRIX_M23", &m->matrix[2][3]);
    pequate("__MATRIX_M30", &m->matrix[3][0]);
    pequate("__MATRIX_M31", &m->matrix[3][1]);
    pequate("__MATRIX_M32", &m->matrix[3][2]);
    pequate("__MATRIX_M33", &m->matrix[3][3]);
    pblank();

    pcomment("__GLGENcontextRec structure");
    pblank();
    pblank();
    pequate("GENCTX_hrc               ",OFFSET(struct __GLGENcontextRec,hrc       ));
    pequate("GENCTX_pajTranslateVector",OFFSET(struct __GLGENcontextRec,pajTranslateVector));
    pequate("GENCTX_pPrivateArea      ",OFFSET(struct __GLGENcontextRec,pPrivateArea));
    pequate("GENGC_ColorsBits         ",OFFSET(struct __GLGENcontextRec,ColorsBits));
    pequate("GENGC_SPAN_r             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.r));
    pequate("GENGC_SPAN_g             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.g));
    pequate("GENGC_SPAN_b             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.b));
    pequate("GENGC_SPAN_a             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.a));
    pequate("GENGC_SPAN_s             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.s));
    pequate("GENGC_SPAN_t             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.t));
    pequate("GENGC_SPAN_dr            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.r));
    pequate("GENGC_SPAN_dg            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.g));
    pequate("GENGC_SPAN_db            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.b));
    pequate("GENGC_SPAN_da            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.a));
    pequate("GENGC_SPAN_ds            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.s));
    pequate("GENGC_SPAN_dt            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.t));
    pequate("GENGC_SPAN_z             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.z));
    pequate("GENGC_SPAN_dz            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dzdx));
    pequate("GENGC_SPAN_zbuf          ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.zbuf));
    pequate("GENGC_SPAN_ppix          ",OFFSET(struct __GLGENcontextRec,genAccel.pPix));
    pequate("GENGC_SPAN_x             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.x));
    pequate("GENGC_SPAN_y             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.y));
    pequate("GENGC_SPAN_length        ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.length));
    pequate("GENGC_rAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.rAccum));
    pequate("GENGC_gAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.gAccum));
    pequate("GENGC_bAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.bAccum));
    pequate("GENGC_aAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.aAccum));
    pequate("GENGC_zAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.zAccum));
    pequate("GENGC_sAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.sAccum));
    pequate("GENGC_tAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.tAccum));
    pequate("GENGC_pixAccum           ",OFFSET(struct __GLGENcontextRec,genAccel.pixAccum));
    pequate("GENGC_ditherAccum        ",OFFSET(struct __GLGENcontextRec,genAccel.ditherAccum));
    pequate("GENGC_sResult            ",OFFSET(struct __GLGENcontextRec,genAccel.sResult[0]));
    pequate("GENGC_tResult            ",OFFSET(struct __GLGENcontextRec,genAccel.tResult[0]));
    pequate("GENGC_sResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.sResultNew[0]));
    pequate("GENGC_tResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.tResultNew[0]));
    pequate("GENGC_sMask              ",OFFSET(struct __GLGENcontextRec,genAccel.sMask));
    pequate("GENGC_tMaskSubDiv        ",OFFSET(struct __GLGENcontextRec,genAccel.tMaskSubDiv));
    pequate("GENGC_tShiftSubDiv       ",OFFSET(struct __GLGENcontextRec,genAccel.tShiftSubDiv));
    pequate("GENGC_texImage           ",OFFSET(struct __GLGENcontextRec,genAccel.texImage));
    pequate("GENGC_texImageReplace    ",OFFSET(struct __GLGENcontextRec,genAccel.texImageReplace));
    pequate("GENGC_texPalette         ",OFFSET(struct __GLGENcontextRec,genAccel.texPalette));
    pequate("GENGC_qwAccum            ",OFFSET(struct __GLGENcontextRec,genAccel.qwAccum));
    pequate("GENGC_SPAN_dqwdx         ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dqwdx));
    pequate("GENGC_SPAN_qw            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.qw));
    pequate("GENGC_xlatPalette        ",OFFSET(struct __GLGENcontextRec,xlatPalette));
    pequate("GENGC_sStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.sStepX));
    pequate("GENGC_tStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.tStepX));
    pequate("GENGC_qwStepX            ",OFFSET(struct __GLGENcontextRec,genAccel.qwStepX));
    pequate("GENGC_subDs              ",OFFSET(struct __GLGENcontextRec,genAccel.subDs));
    pequate("GENGC_subDt              ",OFFSET(struct __GLGENcontextRec,genAccel.subDt));
    pequate("GENGC_rDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[0]));
    pequate("GENGC_gDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[1]));
    pequate("GENGC_bDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[2]));
    pequate("GENGC_aDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[3]));
    pequate("GENGC_bytesPerPixel      ",OFFSET(struct __GLGENcontextRec,genAccel.xMultiplier));
    pequate("GENGC_bpp                ",OFFSET(struct __GLGENcontextRec,genAccel.bpp));
    pequate("GENGC_flags              ",OFFSET(struct __GLGENcontextRec,genAccel.flags));
    pequate("GENGC_pInvTranslateVector",OFFSET(struct __GLGENcontextRec,pajInvTranslateVector));
    pblank();
    
    pequate("COLOR_r                  ",OFFSET(struct __GLcolorRec,r  ));
    pequate("COLOR_g                  ",OFFSET(struct __GLcolorRec,g  ));
    pequate("COLOR_b                  ",OFFSET(struct __GLcolorRec,b  ));
    pequate("COLOR_a                  ",OFFSET(struct __GLcolorRec,a  ));
    pblank();

    pequate("GC_SHADER_R              ", OFFSET(__GLcontext, polygon.shader.frag.color.r));
    pequate("GC_SHADER_G              ", OFFSET(__GLcontext, polygon.shader.frag.color.g));
    pequate("GC_SHADER_B              ", OFFSET(__GLcontext, polygon.shader.frag.color.b));
    pequate("GC_SHADER_A              ", OFFSET(__GLcontext, polygon.shader.frag.color.a));
    
    pblank();
    pequate("GC_SHADE_rLittle         ",OFFSET(__GLcontext, polygon.shader.rLittle        ));
    pequate("GC_SHADE_gLittle         ",OFFSET(__GLcontext, polygon.shader.gLittle        ));
    pequate("GC_SHADE_bLittle         ",OFFSET(__GLcontext, polygon.shader.bLittle        ));
    pequate("GC_SHADE_aLittle         ",OFFSET(__GLcontext, polygon.shader.aLittle        ));

    pblank();
    pequate("GC_SHADE_drdy            ",OFFSET(__GLcontext, polygon.shader.drdy           ));
    pequate("GC_SHADE_dgdy            ",OFFSET(__GLcontext, polygon.shader.dgdy           ));
    pequate("GC_SHADE_dbdy            ",OFFSET(__GLcontext, polygon.shader.dbdy           ));
    pequate("GC_SHADE_dady            ",OFFSET(__GLcontext, polygon.shader.dady           ));

    pblank();
    pequate("GC_SHADE_drdx            ",OFFSET(__GLcontext, polygon.shader.drdx           ));
    pequate("GC_SHADE_dgdx            ",OFFSET(__GLcontext, polygon.shader.dgdx           ));
    pequate("GC_SHADE_dbdx            ",OFFSET(__GLcontext, polygon.shader.dbdx           ));
    pequate("GC_SHADE_dadx            ",OFFSET(__GLcontext, polygon.shader.dadx           ));

    pblank();
    pequate("VERTEX_color             ", OFFSET(__GLvertex, color));
    
    pblank();
    pequate("GC_VIEWPORT_xScale       ", OFFSET(__GLcontext, state.viewport.xScale));
    pequate("GC_VIEWPORT_yScale       ", OFFSET(__GLcontext, state.viewport.yScale));
    pequate("GC_VIEWPORT_zScale       ", OFFSET(__GLcontext, state.viewport.zScale));
    pequate("GC_VIEWPORT_xCenter      ", OFFSET(__GLcontext, state.viewport.xCenter));
    pequate("GC_VIEWPORT_yCenter      ", OFFSET(__GLcontext, state.viewport.yCenter));
    pequate("GC_VIEWPORT_zCenter      ", OFFSET(__GLcontext, state.viewport.zCenter));

    pblank();
    pequate("__FLOAT_ONE", *(long*)&one);
    
    pblank();
    pequate("VCLIP_x", OFFSET(__GLvertex, clip.x));
    pequate("VFCOL_r", OFFSET(__GLvertex, colors[__GL_FRONTFACE].r));
    pequate("VBCOL_r", OFFSET(__GLvertex, colors[__GL_BACKFACE].r));
    pequate("VTEX_x", OFFSET(__GLvertex, texture.x));
    pequate("VNOR_x", OFFSET(__GLvertex, normal.x));
    pequate("VEYE_x", OFFSET(__GLvertex, eyeX));

    pblank();
    pequate("PA_flags           ", OFFSET(POLYARRAY, flags));
    pequate("PA_pdNextVertex    ", OFFSET(POLYARRAY, pdNextVertex));
    pequate("PA_pdFlush         ", OFFSET(POLYARRAY, pdFlush));
    pequate("PA_pdCurNormal     ", OFFSET(POLYARRAY, pdCurNormal));
    pequate("PA_pdCurTexture    ", OFFSET(POLYARRAY, pdCurTexture));
    pequate("PA_pdCurColor      ", OFFSET(POLYARRAY, pdCurColor));
    
    pblank();
    pequate("PD_flags           ", OFFSET(POLYDATA, flags));
    pequate("PD_obj             ", OFFSET(POLYDATA, obj.x));
    pequate("PD_normal          ", OFFSET(POLYDATA, normal.x));
    pequate("PD_texture         ", OFFSET(POLYDATA, texture.x));
    pequate("PD_colors0         ", OFFSET(POLYDATA, colors[0].r));
    pequate("PD_clip            ", OFFSET(POLYDATA, clip.x));
    pequate("PD_window          ", OFFSET(POLYDATA, window.x));
    pequate("sizeof_POLYDATA    ", sizeof(POLYDATA));
}

/******************************Public*Routine******************************\
* GLi386                                                                   *
*                                                                          *
* This is how we make structures consistent between C and ASM for OpenGL.  *
*                                                                          *
\**************************************************************************/

int __cdecl main(int argc,char *argv[])
{
    FILE *outfh;
    char *outName;
    char *dot;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s file_name\n", argv[0]);
        exit(1);

    }

    outfh = fopen(argv[1], "w");
    if (NULL == outfh) {
        fprintf(stderr, "Cannot open %s\n", argv[1]);
        exit(1);
    }
    CreateInc(outfh);
    fclose(outfh);

    dot = strrchr(argv[1], '.');
    if (dot == NULL)
    {
        fprintf(stderr, "Cannot create H\n", argv[1]);
        exit(1);
    }
    *(++dot) = 'h';
    *(++dot) = 0;
    outfh = fopen(argv[1], "w");
    if (NULL == outfh) {
        fprintf(stderr, "Cannot open %s\n", argv[1]);
        exit(1);
    }

    CreateH(outfh);
    fclose(outfh);
    
    // UNUSED
#if 0
// Stuff from: \nt\public\sdk\inc\gl\gl.h

    pcomment("Pixel Format Descriptor");
    pblank();
    pequate("PFD_cColorBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cColorBits ));
    pequate("PFD_iPixelType     ",OFFSET(PIXELFORMATDESCRIPTOR,iPixelType ));
    pequate("PFD_cDepthBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cDepthBits ));


    pcomment("GL Test Functions");
    pblank();

    pequate("GL_NEVER           ",GL_NEVER   );
    pequate("GL_LESS            ",GL_LESS    );
    pequate("GL_EQUAL           ",GL_EQUAL   );
    pequate("GL_LEQUAL          ",GL_LEQUAL  );
    pequate("GL_GREATER         ",GL_GREATER );
    pequate("GL_NOTEQUAL        ",GL_NOTEQUAL);
    pequate("GL_GEQUAL          ",GL_GEQUAL  );
    pequate("GL_ALWAYS          ",GL_ALWAYS  );
    pblank();
    pblank();

    pcomment("GL Mode Flags");
    pblank();
    pequate("__GL_SHADE_RGB         ",__GL_SHADE_RGB        );
    pequate("__GL_SHADE_SMOOTH      ",__GL_SHADE_SMOOTH     );
    pequate("__GL_SHADE_DEPTH_TEST  ",__GL_SHADE_DEPTH_TEST );
    pequate("__GL_SHADE_DITHER      ",__GL_SHADE_DITHER     );
    pequate("__GL_SHADE_LOGICOP     ",__GL_SHADE_LOGICOP    );
    pequate("__GL_SHADE_MASK        ",__GL_SHADE_MASK       );
    pblank();
    pblank();

    pcomment("GL Type Sizes");
    pblank();
    pequate("GLbyteSize             ",sizeof(GLbyte));
    pequate("GLshortSize            ",sizeof(GLshort));
    pequate("GLintSize              ",sizeof(GLint));
    pequate("GLfloatSize            ",sizeof(GLfloat));
    pequate("__GLfloatSize          ",sizeof(__GLfloat));
    pequate("__GLzValueSize         ",sizeof(__GLzValue));
    pblank();
    pblank(); 

// Stuff from: \nt\private\windows\gdi\opengl\server\inc\render.h

    pcomment("__GLfragmentRec structure");
    pblank();

    pstruct("GLfragmentRec",sizeof(struct __GLfragmentRec));
    pblank();
    pequate("FRAG_x             ",OFFSET(struct __GLfragmentRec,x       ));
    pequate("FRAG_y             ",OFFSET(struct __GLfragmentRec,y       ));
    pequate("FRAG_z             ",OFFSET(struct __GLfragmentRec,z       ));
    pequate("FRAG_color         ",OFFSET(struct __GLfragmentRec,color   ));
    pequate("FRAG_s             ",OFFSET(struct __GLfragmentRec,s       ));
    pequate("FRAG_t             ",OFFSET(struct __GLfragmentRec,t       ));
    pequate("FRAG_qw            ",OFFSET(struct __GLfragmentRec,qw      ));
    pequate("FRAG_f             ",OFFSET(struct __GLfragmentRec,f       ));
    pblank();

    pcomment("__GLshadeRec structure");
    pblank();
    pstruct("__GLshadeRec",sizeof(struct __GLshadeRec));
    pblank();
    pequate("SHADE_dxLeftLittle ",OFFSET(struct __GLshadeRec,dxLeftLittle   ));
    pequate("SHADE_dxLeftBig    ",OFFSET(struct __GLshadeRec,dxLeftBig      ));
    pequate("SHADE_dxLeftFrac   ",OFFSET(struct __GLshadeRec,dxLeftFrac     ));
    pequate("SHADE_ixLeft       ",OFFSET(struct __GLshadeRec,ixLeft         ));
    pequate("SHADE_ixLeftFrac   ",OFFSET(struct __GLshadeRec,ixLeftFrac     ));

    pequate("SHADE_dxRightLittle",OFFSET(struct __GLshadeRec,dxRightLittle  ));
    pequate("SHADE_dxRightBig   ",OFFSET(struct __GLshadeRec,dxRightBig     ));
    pequate("SHADE_dxRightFrac  ",OFFSET(struct __GLshadeRec,dxRightFrac    ));
    pequate("SHADE_ixRight      ",OFFSET(struct __GLshadeRec,ixRight        ));
    pequate("SHADE_ixRightFrac  ",OFFSET(struct __GLshadeRec,ixRightFrac    ));

    pequate("SHADE_area         ",OFFSET(struct __GLshadeRec,area           ));
    pequate("SHADE_dxAC         ",OFFSET(struct __GLshadeRec,dxAC           ));
    pequate("SHADE_dxBC         ",OFFSET(struct __GLshadeRec,dxBC           ));
    pequate("SHADE_dyAC         ",OFFSET(struct __GLshadeRec,dyAC           ));
    pequate("SHADE_dyBC         ",OFFSET(struct __GLshadeRec,dyBC           ));

    pequate("SHADE_frag         ",OFFSET(struct __GLshadeRec,frag           ));
    pequate("SHADE_spanLength   ",OFFSET(struct __GLshadeRec,length         ));

    pequate("SHADE_rBig         ",OFFSET(struct __GLshadeRec,rBig           ));
    pequate("SHADE_gBig         ",OFFSET(struct __GLshadeRec,gBig           ));
    pequate("SHADE_bBig         ",OFFSET(struct __GLshadeRec,bBig           ));
    pequate("SHADE_aBig         ",OFFSET(struct __GLshadeRec,aBig           ));

    pequate("SHADE_zLittle      ",OFFSET(struct __GLshadeRec,zLittle        ));
    pequate("SHADE_zBig         ",OFFSET(struct __GLshadeRec,zBig           ));
    pequate("SHADE_dzdx         ",OFFSET(struct __GLshadeRec,dzdx           ));
    pequate("SHADE_dzdyf        ",OFFSET(struct __GLshadeRec,dzdyf          ));
    pequate("SHADE_dzdxf        ",OFFSET(struct __GLshadeRec,dzdxf          ));

    pequate("SHADE_sLittle      ",OFFSET(struct __GLshadeRec,sLittle        ));
    pequate("SHADE_tLittle      ",OFFSET(struct __GLshadeRec,tLittle        ));
    pequate("SHADE_qwLittle     ",OFFSET(struct __GLshadeRec,qwLittle       ));

    pequate("SHADE_sBig         ",OFFSET(struct __GLshadeRec,sBig           ));
    pequate("SHADE_tBig         ",OFFSET(struct __GLshadeRec,tBig           ));
    pequate("SHADE_qwBig        ",OFFSET(struct __GLshadeRec,qwBig          ));

    pequate("SHADE_dsdx         ",OFFSET(struct __GLshadeRec,dsdx           ));
    pequate("SHADE_dtdx         ",OFFSET(struct __GLshadeRec,dtdx           ));
    pequate("SHADE_dqwdx        ",OFFSET(struct __GLshadeRec,dqwdx          ));

    pequate("SHADE_dsdy         ",OFFSET(struct __GLshadeRec,dsdy           ));
    pequate("SHADE_dtdy         ",OFFSET(struct __GLshadeRec,dtdy           ));
    pequate("SHADE_dqwdy        ",OFFSET(struct __GLshadeRec,dqwdy          ));

    pequate("SHADE_fLittle      ",OFFSET(struct __GLshadeRec,fLittle        ));
    pequate("SHADE_fBig         ",OFFSET(struct __GLshadeRec,fBig           ));
    pequate("SHADE_dfdy         ",OFFSET(struct __GLshadeRec,dfdy           ));
    pequate("SHADE_dfdx         ",OFFSET(struct __GLshadeRec,dfdx           ));

    pequate("SHADE_modeFlags    ",OFFSET(struct __GLshadeRec,modeFlags      ));

    pequate("SHADE_zbuf         ",OFFSET(struct __GLshadeRec,zbuf           ));
    pequate("SHADE_zbufBig      ",OFFSET(struct __GLshadeRec,zbufBig        ));
    pequate("SHADE_zbufLittle   ",OFFSET(struct __GLshadeRec,zbufLittle     ));

    pequate("SHADE_sbuf         ",OFFSET(struct __GLshadeRec,sbuf           ));
    pequate("SHADE_sbufBig      ",OFFSET(struct __GLshadeRec,sbufBig        ));
    pequate("SHADE_sbufLittle   ",OFFSET(struct __GLshadeRec,sbufLittle     ));

    pequate("SHADE_colors       ",OFFSET(struct __GLshadeRec,colors         ));
    pequate("SHADE_fbcolors     ",OFFSET(struct __GLshadeRec,fbcolors       ));
    pequate("SHADE_stipplePat   ",OFFSET(struct __GLshadeRec,stipplePat     ));
    pequate("SHADE_done         ",OFFSET(struct __GLshadeRec,done           ));
    pequate("SHADE_cfb          ",OFFSET(struct __GLshadeRec,cfb            ));
    pblank();
    pblank();


    pcomment("__GLpolygonMachineRec structure");
    pblank();
    pstruct("GLpolygonMachineRec",sizeof(struct __GLpolygonMachineRec));
    pblank();
    pequate("POLY_stipple       ",OFFSET(struct __GLpolygonMachineRec,stipple));
    pequate("POLY_shader        ",OFFSET(struct __GLpolygonMachineRec,shader ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\buffers.h

    pequate("DIB_FORMAT         ",DIB_FORMAT);

    pcomment("__GLbufferRec structure");
    pblank();
    pstruct("GLbufferRec",sizeof(struct __GLbufferRec));
    pblank();
    pequate("BUF_gc             ",OFFSET(struct __GLbufferRec,gc          ));
    pequate("BUF_width          ",OFFSET(struct __GLbufferRec,width       ));
    pequate("BUF_height         ",OFFSET(struct __GLbufferRec,height      ));
    pequate("BUF_depth          ",OFFSET(struct __GLbufferRec,depth       ));
    pequate("BUF_base           ",OFFSET(struct __GLbufferRec,base        ));
    pequate("BUF_size           ",OFFSET(struct __GLbufferRec,size        ));
    pequate("BUF_elementSize    ",OFFSET(struct __GLbufferRec,elementSize ));
    pequate("BUF_outerWidth     ",OFFSET(struct __GLbufferRec,outerWidth  ));
    pequate("BUF_xOrigin        ",OFFSET(struct __GLbufferRec,xOrigin     ));
    pequate("BUF_yOrigin        ",OFFSET(struct __GLbufferRec,yOrigin     ));
    pequate("BUF_other          ",OFFSET(struct __GLbufferRec,other       ));
    pblank();
    pblank();


    pcomment("__GLcolorBufferRec structure");
    pblank();
    pstruct("GLcolorBufferRec",sizeof(struct __GLcolorBufferRec));
    pblank();
    pequate("CBUF_redMax        ",OFFSET(struct __GLcolorBufferRec,redMax     ));
    pequate("CBUF_greenMax      ",OFFSET(struct __GLcolorBufferRec,greenMax   ));
    pequate("CBUF_blueMax       ",OFFSET(struct __GLcolorBufferRec,blueMax    ));
    pequate("CBUF_iRedScale     ",OFFSET(struct __GLcolorBufferRec,iRedScale  ));
    pequate("CBUF_iGreenScale   ",OFFSET(struct __GLcolorBufferRec,iGreenScale));
    pequate("CBUF_iBlueScale    ",OFFSET(struct __GLcolorBufferRec,iBlueScale ));
    pequate("CBUF_iAlphaScale   ",OFFSET(struct __GLcolorBufferRec,iAlphaScale));
    pequate("CBUF_iRedShift     ",OFFSET(struct __GLcolorBufferRec,redShift  ));
    pequate("CBUF_iGreenShift   ",OFFSET(struct __GLcolorBufferRec,greenShift));
    pequate("CBUF_iBlueShift    ",OFFSET(struct __GLcolorBufferRec,blueShift ));
    pequate("CBUF_iAlphaShift   ",OFFSET(struct __GLcolorBufferRec,alphaShift));
    pequate("CBUF_sourceMask    ",OFFSET(struct __GLcolorBufferRec,sourceMask ));
    pequate("CBUF_destMask      ",OFFSET(struct __GLcolorBufferRec,destMask   ));
    pequate("CBUF_other         ",OFFSET(struct __GLcolorBufferRec,other      ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\attrib.h


    pcomment("__GLdepthStateRec structure");
    pblank();
    pstruct("GLdepthStateRec",sizeof(struct __GLdepthStateRec));
    pblank();
    pequate("DEPTH_testFunc     ",OFFSET(struct __GLdepthStateRec,testFunc   ));
    pequate("DEPTH_writeEnable  ",OFFSET(struct __GLdepthStateRec,writeEnable));
    pblank();
    pblank();

    pcomment("__GLattributeRec structure");
    pblank();
    pstruct("GLattributeRec",sizeof(struct __GLattributeRec));
    pblank();
    pequate("ATTR_polygonStipple",OFFSET(struct __GLattributeRec,polygonStipple));
    pequate("ATTR_depth         ",OFFSET(struct __GLattributeRec,depth));
    pequate("ATTR_enables       ",OFFSET(struct __GLattributeRec,enables));
    pequate("ATTR_raster        ",OFFSET(struct __GLattributeRec,raster));
    pequate("ATTR_hints         ",OFFSET(struct __GLattributeRec,hints));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\context.h

    pcomment("__GLcontextConstantsRec structure");
    pblank();
    pstruct("GLcontextConstantsRec",sizeof(struct __GLcontextConstantsRec));
    pblank();
    pequate("CTXCONST_viewportXAdjust",OFFSET(struct __GLcontextConstantsRec,viewportXAdjust));
    pequate("CTXCONST_viewportYAdjust",OFFSET(struct __GLcontextConstantsRec,viewportYAdjust));
    pequate("CTXCONST_width          ",OFFSET(struct __GLcontextConstantsRec,width));
    pequate("CTXCONST_height         ",OFFSET(struct __GLcontextConstantsRec,height));


    pcomment("__GLcontextRec structure");
    pblank();
    pstruct("GLcontextRec",sizeof(struct __GLcontextRec));
    pblank();
    pequate("CTX_gcState        ",OFFSET(struct __GLcontextRec,gcState    ));
    pequate("CTX_state          ",OFFSET(struct __GLcontextRec,state      ));
    pequate("CTX_renderMode     ",OFFSET(struct __GLcontextRec,renderMode ));
    pequate("CTX_modes          ",OFFSET(struct __GLcontextRec,modes      ));
    pequate("CTX_constants      ",OFFSET(struct __GLcontextRec,constants  ));
    pequate("CTX_drawBuffer     ",OFFSET(struct __GLcontextRec,drawBuffer ));
    pequate("CTX_readBuffer     ",OFFSET(struct __GLcontextRec,readBuffer ));
    pequate("CTX_polygon        ",OFFSET(struct __GLcontextRec,polygon    ));
    pequate("CTX_pixel          ",OFFSET(struct __GLcontextRec,pixel      ));
    pblank();
    pblank();

    pcomment("SPANREC structure");
    pblank();
    pstruct("SPANREC",sizeof(SPANREC));
    pblank();
    pequate("SPANREC_r               ",OFFSET(SPANREC,r       ));
    pequate("SPANREC_g               ",OFFSET(SPANREC,g       ));
    pequate("SPANREC_b               ",OFFSET(SPANREC,b       ));
    pequate("SPANREC_a               ",OFFSET(SPANREC,a       ));
    pequate("SPANREC_z               ",OFFSET(SPANREC,z       ));
    pblank();
    pblank();

    pcomment("GENACCEL structure");
    pblank();
    pstruct("GENACCEL",sizeof(GENACCEL));
    pblank();
    pequate("SURFACE_TYPE_DIB   ",SURFACE_TYPE_DIB);
    pblank();
    pequate("GENACCEL_spanDelta             ",
        OFFSET(GENACCEL,spanDelta                ));
    pequate("GENACCEL_flags                 ",
        OFFSET(GENACCEL,flags                    ));
    pequate("GENACCEL_fastSpanFuncPtr       ",
        OFFSET(GENACCEL,__fastSpanFuncPtr ));
    pequate("GENACCEL_fastFlatSpanFuncPtr   ",
        OFFSET(GENACCEL,__fastFlatSpanFuncPtr ));
    pequate("GENACCEL_fastSmoothSpanFuncPtr ",
        OFFSET(GENACCEL,__fastSmoothSpanFuncPtr ));
    pequate("GENACCEL_fastZSpanFuncPtr      ",
        OFFSET(GENACCEL,__fastZSpanFuncPtr));
    pblank();
    pblank();
#endif
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


x 	equ DWORD PTR 8[ebp]
num 	equ DWORD PTR -8[ebp]

@__FastInvSqrt@4 PROC NEAR

	push	ebp
	mov	ebp, esp
	sub	esp, 8
        push    ecx

        mov     eax, x
        mov     ecx, eax
        shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
        and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
        and     ecx, TABLE_MASK		;; (8 bytes)/(table entry)
        or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
        mov     num, eax
        fld     num
        fmul    [invSqrtTab+ecx]        ;; find mx
        mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
        sub     eax, x                  ;; divide exponent by 2
        fadd    [invSqrtTab+ecx+4]      ;; get mx + b
        shr     eax, 1
        and     eax, EXPONENT_MASK     	;; mask exponent
        mov     num, eax
        fmul    num                     ;; now adjust for exponent

        pop     ecx
	mov	esp, ebp
	pop	ebp
	ret     4

@__FastInvSqrt@4 endp

len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@__glNormalize@8 PROC NEAR

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
        mov     edi, eax
        shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
        and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
        and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
        or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
        mov     num, eax
        fld     num
        fmul    [invSqrtTab+edi]        ;; find mx
        mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
        sub     eax, len                ;; divide exponent by 2
        fadd    [invSqrtTab+edi+4]      ;; get mx + b
        shr     eax, 1
        and     eax, EXPONENT_MASK     	;; mask exponent
        mov     num, eax
        fmul    num                     ;; now adjust for exponent

	fld	DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@__glNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\soprim.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: so_prim.asm
;
; xform routines.
;
; Created: 10/14/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc
	
.data

extrn	___glClipCodes :DWORD
extrn	___glOne:DWORD
extrn	___glHalf:DWORD
extrn	___glZero:DWORD

;------------------------------------------------------------------------------------------
; Internal definitions:
;
_R_ 	= 0
_G_ 	= 4
_B_ 	= 8
_A_ 	= 12

_X_	= 0
_Y_	= 4
_Z_	= 8
_W_	= 12


;------------------------------------------------------------------------------------------
; pdLast is passed as parameter
;
pdLast      equ [ebp+8]

;
; Temporary data
;
gc        equ -4[ebp]
pa        equ -8[ebp]

.code

extrn    @__glNormalize@8:NEAR

;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; General case
;
; Input:
;   edx        = pointer to POLYARRAY
;   ecx        = pointer to graphics context
;   pdLast     = pointer to the last vertex 
;   pa         = pointer to POLYARRAY
;   gc         = pointer to graphics context
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
PAClipCheckFrustum MACRO ReuseClipCode

        mov     edx, DWORD PTR [edx+PA_pd0]

vertexLoop:

        mov     esi, DWORD PTR [edx+PD_clip+_W_]   ; esi = clipW
        or      esi, esi                           ; if (clipW == 0) go to special case
        jz      @WEqZero
	    
        fld     ___glOne
        fdiv    DWORD PTR [edx+PD_clip+_W_]     ; start division

; edi will accumulate index to clip table
; bit 6  - 1 if clipW < 0
; bit 5  - 1 if clipX < 0
; bit 4  - 1 if abs(clipX) < abs(clipW)
; bit 3  - 1 if clipY < 0
; bit 2  - 1 if abs(clipY) < abs(clipW)
; bit 1  - 1 if clipZ < 0
; bit 0  - 1 if abs(clipZ) < abs(clipW)
        xor     edi, edi	
        add     esi, esi			; esi = abs(clipW) shifted left 1 bit
        mov     ebx, [edx+PD_clip+_X_]		; ebx = clipX
        adc     edi, edi			; edi = sign clipW 
        add     esi, 1                          ; X-W bit should be set when X-W <= 0 !!!

        add     ebx, ebx							; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi                        ; edi = edi << 1 + sign(clipX)

        sub     ebx, esi
        adc     edi, edi                        ; edi = edi << 1 + sign(abs(clipX) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa

        add     ebx, ebx
        adc     edi, edi			; edi = edi << 1 + sign(clipY)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipY) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Z_]
        add     edx, sizeof_POLYDATA            ; advance vertex ptr

        add     ebx, ebx                        ; edi = edi << 1 + sign(clipZ)
        adc     edi, edi

        sub     ebx, esi
        adc     edi, edi                        ; edi = edi << 1 + sign(abs(clipZ) - abs(clipW))

        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code

        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                         ; compute prim OR
        and     ebx, ecx                         ; "          " AND
        mov     [edi+PA_orClipCodes],  esi       ; store prim OR
        mov     [edi+PA_andClipCodes], ebx       ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:

        fstp DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]

        or      ecx, ecx
        jnz     @Done

        fld     DWORD PTR [edx+PD_clip+_X_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_xScale]
        fld     DWORD PTR [edx+PD_clip+_Y_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_yScale]
        fld     DWORD PTR [edx+PD_clip+_Z_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_zScale]                 ; z y x
        fxch    st(2)                                              ; x y z
        fmul    DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]    ; X y z
        fxch    st(1)                                              ; y X z
        fmul    DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]    ; Y X z
        fxch    st(2)                                              ; z X Y
        fmul    DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]    ; Z X Y
        fxch    st(1)                                              ; X Z Y
        fadd    DWORD PTR [ebx+GC_VIEWPORT_xCenter]                ; x Z Y
        fxch    st(2)                                              ; Y Z x
        fadd    DWORD PTR [ebx+GC_VIEWPORT_yCenter]                ; y Z x
        fxch    st(1)                                              ; Z y x
        fadd    DWORD PTR [ebx+GC_VIEWPORT_zCenter]                ; z y x	    
        fxch    st(2)                                              ; x y z
        fstp    DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA]

@Done:

        cmp     edx, edi                           ; pd > pdLast?
        jbe     vertexLoop                         ; yes -> process next vertex

@Exit:

        mov     edx, pa
        pop	edi
        pop	esi
        pop	ebx
        mov	esp, ebp
        pop	ebp
        mov     eax, [edx + PA_andClipCodes]       ; return value
        ret	4
;
; W == 0
;
@WEqZero:
        xor     edi, edi	
        mov     ebx, [edx+PD_clip+_X_]          ; ebx = clipX
        add     ebx, ebx			; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi			; edi = edi << 1 + sign(clipX)
        add     edi, edi			; edi = edi << 1
        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa
        add     ebx, ebx
        adc     edi, edi                        ; edi = edi << 1 + sign(clipY)
        add     edi, edi                        ; edi = edi << 1
        mov     ebx, [edx+PD_clip+_Z_]
        add     edx, sizeof_POLYDATA            ; advance vertex ptr
        add     ebx, ebx                        ; edi = edi << 1 + sign(clipZ)
        adc     edi, edi
        add     edi, edi                        ; edi = edi << 1
        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code
        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                        ; compute prim OR
        and     ebx, ecx                        ; "          " AND
        mov     [edi+PA_orClipCodes],  esi      ; store prim OR
        mov     [edi+PA_andClipCodes], ebx      ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:
        mov     DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA], 0

        or      ecx, ecx
        jnz     @Done

        mov     ecx, DWORD PTR [ebx+GC_VIEWPORT_xCenter]
        mov     ebx, DWORD PTR [ebx+GC_VIEWPORT_yCenter]
        mov     DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA], ecx
        mov     ecx, DWORD PTR [ebx+GC_VIEWPORT_zCenter]
        mov     DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA], ebx
        mov     DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA], ecx
        jmp     @Done

ENDM
;------------------------------------------------------------------------------------------
; Make clip code for frustum clip planes
; General case
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
;                                      POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   andClipCodes for POLYARRAY
;
@PAClipCheckFrustum@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 12
        mov     DWORD PTR pa, edx
        mov     DWORD PTR gc, ecx
        push    ebx
        push    esi
        push    edi
        PAClipCheckFrustum 0

@PAClipCheckFrustum@12 ENDP
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0
;
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   pa         = pointer to POLYARRAY
;   gc         = pointer to graphics context
;   pdLast     = pointer to the last vertex 
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
PAClipCheckFrustumWOne MACRO ReuseClipCode

        mov     edx, DWORD PTR [edx+PA_pd0]

vertexLoop:

; edi will accumulate index to clip table
; bit 6  - 1 if clipW < 0   --- always 0 for this case
; bit 5  - 1 if clipX < 0
; bit 4  - 1 if abs(clipX) < abs(clipW)
; bit 3  - 1 if clipY < 0
; bit 2  - 1 if abs(clipY) < abs(clipW)
; bit 1  - 1 if clipZ < 0
; bit 0  - 1 if abs(clipZ) < abs(clipW)
        xor     edi, edi	
        mov     ebx, [edx+PD_clip+_X_]          ; ebx = clipX
        mov     esi, (__FLOAT_ONE*2) + 1

        add     ebx, ebx                        ; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi			; edi = edi << 1 + sign(clipX)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipX) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa

        add     ebx, ebx
        adc     edi, edi			; edi = edi << 1 + sign(clipY)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipY) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Z_]
        add     edx, sizeof_POLYDATA            ; advance vertex ptr

        add     ebx, ebx			; edi = edi << 1 + sign(clipZ)
        adc     edi, edi

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipZ) - abs(clipW))

        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code

        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                         ; compute prim OR
        and     ebx, ecx                         ; "          " AND
        mov     [edi+PA_orClipCodes],  esi       ; store prim OR
        mov     [edi+PA_andClipCodes], ebx       ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:

        mov     DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA], __FLOAT_ONE

        or      ecx, ecx
        jnz     @Done

        fld     DWORD PTR [edx+PD_clip+_X_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_xScale]
        fld     DWORD PTR [edx+PD_clip+_Y_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_yScale]
        fld     DWORD PTR [edx+PD_clip+_Z_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_zScale]                 ; z y x
        fxch    st(2)                                              ; x y z
        fadd    DWORD PTR [ebx+GC_VIEWPORT_xCenter]                ; x y z
        fxch    st(1)                                              ; y x z
        fadd    DWORD PTR [ebx+GC_VIEWPORT_yCenter]                ; y x z
        fxch    st(2)                                              ; z x y
        fadd    DWORD PTR [ebx+GC_VIEWPORT_zCenter]                ; z x y	    
        fxch    st(1)                                              ; x z y
        fstp    DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA]
@Done:
        cmp     edx, edi                           ; pd > pdLast?
        jbe     vertexLoop                         ; yes -> process next vertex
@Exit:
    mov  edx, pa
	pop	 edi
	pop	 esi
	pop	 ebx
	mov	 esp, ebp
	pop	 ebp
	mov  eax, [edx + PA_andClipCodes]       ; return value
	ret	 4

ENDM
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustumWOne(__GLcontext *gc, POLYARRAY *pa,
;                                          POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
@PAClipCheckFrustumWOne@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 12
        mov     DWORD PTR pa, edx
        mov     DWORD PTR gc, ecx
        push    ebx
        push    esi
        push    edi
        PAClipCheckFrustumWOne 0

@PAClipCheckFrustumWOne@12 ENDP
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0 and Z == 0.0
;
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   pa         = pointer to POLYARRAY
;   gc         = pointer to graphics context
;   pdLast     = pointer to the last vertex 
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
PAClipCheckFrustum2D MACRO ReuseClipCode

        mov     edx, DWORD PTR [edx+PA_pd0]

vertexLoop:

; edi will accumulate index to clip table
; bit 6  - 1 if clipW < 0   --- always 0 for this case
; bit 5  - 1 if clipX < 0
; bit 4  - 1 if abs(clipX) < abs(clipW)
; bit 3  - 1 if clipY < 0
; bit 2  - 1 if abs(clipY) < abs(clipW)
; bit 1  - 1 if clipZ < 0
; bit 0  - 1 if abs(clipZ) < abs(clipW)
        xor     edi, edi	
        mov     ebx, [edx+PD_clip+_X_]          ; ebx = clipX
        mov     esi, (__FLOAT_ONE*2) + 1        

        add     ebx, ebx			; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi			; edi = edi << 1 + sign(clipX)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipX) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa

        add     ebx, ebx
        adc     edi, edi			; edi = edi << 1 + sign(clipY)

        sub     ebx, esi
        adc     edi, edi                        ; edi = edi << 1 + sign(abs(clipY) - abs(clipW))

        add     edx, sizeof_POLYDATA            ; advance vertex ptr
        add     edi, edi                        ; sign(clipZ) = 0
        lea     edi, [edi+edi+1]                ; sign(abs(clipZ) - abs(clipW)) = 0

        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code

        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                        ; compute prim OR
        and     ebx, ecx                        ; "          " AND
        mov     [edi+PA_orClipCodes],  esi      ; store prim OR
        mov     [edi+PA_andClipCodes], ebx      ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:

        mov  DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA], __FLOAT_ONE

        or      ecx, ecx
        jnz     @Done

        fld     DWORD PTR [edx+PD_clip+_X_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_xScale]
        fld     DWORD PTR [edx+PD_clip+_Y_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_yScale]
        fxch    st(1)                                              ; x y
        fadd    DWORD PTR [ebx+GC_VIEWPORT_xCenter]                ; x y
        fxch    st(1)                                              ; y x
        fadd    DWORD PTR [ebx+GC_VIEWPORT_yCenter]                ; y x
        fxch    st(1)                                              ; x y
        mov     ecx, DWORD PTR [ebx+GC_VIEWPORT_zCenter]           	    
        mov     DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA], ecx
        fstp    DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA]
@Done:
        cmp     edx, edi                        ; pd > pdLast?
        jbe     vertexLoop                      ; yes -> process next vertex
@Exit:
        mov     edx, pa
        pop     edi
        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
        mov     eax, [edx + PA_andClipCodes]    ; return value
        ret     4

ENDM
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
;                                        POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
@PAClipCheckFrustum2D@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 12
        xor     eax, eax
        mov     pa, edx
        mov     [edx+PA_orClipCodes], eax       ; PA orClipCodes = 0
        dec     eax
        push    ebx
        mov     [edx+PA_andClipCodes], eax      ; PA andClipCodes = -1
        push    esi
        mov     DWORD PTR gc, ecx
        push    edi
        PAClipCheckFrustum2D 0

@PAClipCheckFrustum2D@12 ENDP
;------------------------------------------------------------------------------------------
; Makes clip code for user planes
;
; Input:
;   edx     = pa
;   ecx     = gc
;   pdLast  = pointer to the last vertex 
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
PAClipCheckUser MACRO ReuseClipCode

result          equ -16[ebp]
cwSave	        equ -20[ebp]
cwTemp	        equ -24[ebp]
clipPlaneMask   equ -28[ebp]
firstPlane      equ -32[ebp]

	;; We have to turn on rounding with double precision.  There is
	;; too much error in the dot product otherwise (test with tlogo).

        fnstcw  WORD PTR cwSave
        mov	edi, DWORD PTR cwSave
        and     edi, 0f0ffh
        or      edi, 00200h
        mov	cwTemp, edi	
        fldcw   WORD PTR cwTemp

        mov	edi, pdLast                     ; edi will store POLYARRAY pointer
        mov	edx, DWORD PTR [edx+PA_pd0]
        mov     esi, DWORD PTR [ecx+GC_STATE_enablesClipPlanes]     ; esi = clipPlaneMask
        mov	ebx, [ecx+GC_STATE_clipPlanes0] ; ebx points to the current user plane
        or      esi, esi
        jz      @Exit1                          ; No user planes

        mov     clipPlaneMask, esi              ; save clipPlaneMask
        mov     firstPlane, ebx                 ; save pointer to the first clip plane

@vertexLoop:

        mov     esi, clipPlaneMask              ; reload clipPlaneMask
        xor     eax, eax                        ; prepare clip code
        mov	ecx, __GL_CLIP_USER0            ; ecx stores  __GL_CLIP_USER bits
        mov     ebx, firstPlane                 ; reload pointer to the first clip plane

@doAnotherPlane:

        test    esi, 1                          ; if (clipPlanesMask & 1 == 0) skip the  plane
        je      SHORT @noClipTest

;
; Dot the vertex clip coordinate against the clip plane and see
; if the sign is negative.  If so, then the point is out.
;	     
; 	    if (x * plane->x + y * plane->y + z * plane->z + w * plane->w <
;		 __glZero)
;
	fld     DWORD PTR [ebx+_X_]
	fmul    DWORD PTR [edx+PD_eye+_X_]
	fld     DWORD PTR [ebx+_Y_]
	fmul    DWORD PTR [edx+PD_eye+_Y_]
	fld     DWORD PTR [ebx+_Z_]
	fmul    DWORD PTR [edx+PD_eye+_Z_]    ; z y x
	fxch    ST(2)                         ; x y z
	faddp   ST(1), ST(0)                  ; xy z
	fld	DWORD PTR [ebx+_W_]           ; w xy z
	fmul    DWORD PTR [edx+PD_eye+_W_]
	fxch    ST(2)                         ; z xy w
	faddp   ST(1), ST(0)                  ; zxy w
	faddp   ST(1), ST(0)                  ; zxyw

	fstp    DWORD PTR result
	cmp	result, 0
	jge	@noClipTest

	or	eax, ecx                      ; 	code |= bit;

@noClipTest:

	add	ecx, ecx                      ; bit <<= 1;
	add	ebx, 16                       ; plane++;
	shr	esi, 1                        ; clipPlanesMask >>= 1;
	jne	SHORT @doAnotherPlane

if ReuseClipCode eq 1
        or      [edx+PD_clipCode], eax        ; store vertex clip code
else
        mov     [edx+PD_clipCode], eax        ; store vertex clip code
endif

        add     edx, sizeof_POLYDATA          ; advance vertex ptr
        cmp     edx, edi
        jbe     @vertexLoop                   ; process next vertex

;; restore FP state:

        fldcw   WORD PTR cwSave

@Exit1:

ENDM

;-------------------------------------------------------------------------------------------
; Make clip code when user clip planes are present
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustumAll(__GLcontext *gc, POLYARRAY *pa,
;                                         POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
@PAClipCheckAll@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 32
        mov     DWORD PTR pa, edx
        mov     DWORD PTR gc, ecx
        push    ebx
        push    esi
        push    edi

        PAClipCheckUser 0       ; Check user clip planes first
        mov     edx, pa    
        PAClipCheckFrustum 1    ; Check frustum clip planes. We have to use OR when 
                                ; updating vertex clip code

@PAClipCheckAll@12 ENDP
;--------------------------------------------------------------------------------------------

pd 	    equ -4[ebp]
pdLast  equ -8[ebp]

@PolyArrayPropagateSameColor@8 PROC NEAR

	push	ebp
	mov	eax, DWORD PTR [edx+PA_pdNextVertex]
	mov	ebp, esp
	sub	eax, sizeof_POLYDATA
	sub	esp, 8
	mov	DWORD PTR pdLast, eax
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [edx+PA_pd0]
	push	edi

; EAX = pdLast = pa->pdNextVertex-1;
; EBX = pd = pa->pd0;

	mov	DWORD PTR pd, ebx

; if (pd > pdLast)

	cmp	eax, ebx
	jb	@Done

	mov	eax, [edx+PA_flags]
	lea	edi, DWORD PTR [ebx+PD_colors0]

;     if (pa->flags & POLYARRAY_CLAMP_COLOR) {

	test	eax, POLYARRAY_CLAMP_COLOR
	je	@ClampDone

	mov	eax, [edi+_R_]
	mov	ebx, [ecx+GC_redVertexScale]
	sub	ebx, eax
        mov     [ecx+GC_redClampTable], eax
	shr	eax, 31
	add	ebx, ebx

	mov	edx, [edi+_G_]
	adc	eax, eax
	mov	ebx, [ecx+GC_greenVertexScale]
	sub	ebx, edx

 	mov	eax, [4*eax+ecx+GC_redClampTable]

        mov     [ecx+GC_greenClampTable], edx
	shr	edx, 31
	add	ebx, ebx

	mov	[edi+_R_], eax

	adc	edx, edx

	mov	eax, [edi+_B_]
	mov	ebx, [ecx+GC_blueVertexScale]
	sub	ebx, eax

	mov	edx, [4*edx+ecx+GC_greenClampTable]

        mov     [ecx+GC_blueClampTable], eax
	shr	eax, 31
	add	ebx, ebx

	mov	[edi+_G_], edx

	adc	eax, eax

	mov	edx, [edi+_A_]
	mov	ebx, [ecx+GC_alphaVertexScale]
	sub	ebx, edx

 	mov	eax, [4*eax+ecx+GC_blueClampTable]

        mov     [ecx+GC_alphaClampTable], edx
	shr	edx, 31
	add	ebx, ebx
	adc	edx, edx

	mov	[edi+_B_], eax

 	mov	edx, [4*edx+ecx+GC_alphaClampTable]
	mov	[edi+_A_], edx

@ClampDone:

;; Register usage.
;; EAX: r, EBX: g, ECX: b, EDX: a
;; ESI: &pdLast->colors[0]
;; EDI: &pd->colors[0]

	mov     edi, pd
	mov     esi, pdLast
	lea     edi, [edi+PD_colors0+sizeof_POLYDATA]
	lea     esi, [esi+PD_colors0]
		
	mov     eax, [edi+_R_-sizeof_POLYDATA]
	cmp     edi, esi
	ja      @Done
	mov     ebx, [edi+_G_-sizeof_POLYDATA]
	mov     ecx, [edi+_B_-sizeof_POLYDATA]
	mov     edx, [edi+_A_-sizeof_POLYDATA]
@DoLoop:
	mov     [edi+_R_], eax
	mov     [edi+_G_], ebx
	mov     [edi+_B_], ecx
	mov     [edi+_A_], edx
	add     edi, sizeof_POLYDATA
	cmp     edi, esi
	jbe     @DoLoop
@Done:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
@PolyArrayPropagateSameColor@8 ENDP
;------------------------------------------------------------------------
; Copy cached non lit color from GC to a polydata
;
; Input:
;       PDreg           - register with POLYDATA address
;       GCreg           - register with GC address
;       GC_LIGHT_value  - front or back light (0 or 1)
;       face            - 0 for front face, 1 for back face
;       tmpreg1,
;       tmpreg2         - temporary registers       
;
COPY_CACHED_NON_LIT MACRO PDreg, GCreg, GC_LIGHT_value, face, tmpreg1, tmpreg2

	mov	eax, [ebx+GC_LIGHT_value+MATERIAL_cachedNonLit+_R_]
	mov	ecx, [ebx+GC_LIGHT_value+MATERIAL_cachedNonLit+_G_]
	mov	[esi+PD_colors0+(face*16)+_R_], eax
	mov	[esi+PD_colors0+(face*16)+_G_], ecx
	mov	eax, [ebx+GC_LIGHT_value+MATERIAL_cachedNonLit+_B_]
	mov	ecx, [ebx+GC_LIGHT_value+MATERIAL_alpha]
	mov	[esi+PD_colors0+(face*16)+_B_], eax
	mov	[esi+PD_colors0+(face*16)+_A_], ecx

ENDM
;------------------------------------------------------------------------
; No lights case
;
POLYARRAYZIPPYCALCRGBCOLOR0 MACRO GC_LIGHT_value, face

	push	ebp
	mov	ebp, esp
	sub	esp, 56
	push	ebx
	push	esi
	push	edi

	mov	esi, pdFirst
	mov	edi, pdLast
	mov	ebx, ecx                ; ebx = gc
;
; for (pd = pdFirst; pd <= pdLast; pd++)
;
@lightVertexLoop:

        COPY_CACHED_NON_LIT <esi>, <ebx>, GC_LIGHT_value, face, <eax>, <ecx>

	add	esi, sizeof_POLYDATA
	cmp	edi, esi
	jae	@lightVertexLoop

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12
ENDM
;------------------------------------------------------------------------
; Parameters:
;
;       ecx                     -  GC
;       NUMBER_OF_LIGHTS        - 1 for one light, 2 for more than one light
;

pdFirst equ 12[ebp]
pdLast  equ 16[ebp]
pd	equ pdFirst

face 	equ -4[ebp]
nonBack	equ -4[ebp]
nxi 	equ DWORD PTR -8[ebp]
nyi 	equ DWORD PTR -12[ebp]
nzi 	equ DWORD PTR -16[ebp]
n1  	equ DWORD PTR -20[ebp]
n2  	equ DWORD PTR -24[ebp]
ifx 	equ -28[ebp]
msm	equ -32[ebp]
baseEmissiveAmbientR	equ DWORD PTR -36[ebp]
baseEmissiveAmbientG	equ DWORD PTR -40[ebp]
baseEmissiveAmbientB	equ DWORD PTR -44[ebp]
rsi	equ DWORD PTR -48[ebp]
gsi	equ DWORD PTR -52[ebp]
bsi	equ DWORD PTR -56[ebp]

;;
;; We will handle infinite lights with special cases for front and
;; back faces.
;;

POLYARRAYZIPPYCALCRGBCOLOR MACRO GC_LIGHT_value, LIGHTSOURCE_value, face, NUMBER_OF_LIGHTS

;; GL_LIGHT_value = GL_LIGHT_front or GC_LIGHT_back
;; LIGHTSOURCE_value = LIGHTSOURCE_front or LIGHTSOURCE_back
;; face = __GL_FRONTFACE or __GL_BACKFACE

	push	ebp
	mov	ebp, esp
	sub	esp, 56
if NUMBER_OF_LIGHTS eq 2
	xor	eax, eax
endif
	push	ebx
	push	esi
	push	edi

;; NOTE: esi, ebx held constant in this routine.
;; esi = pd
;; ebx = gc

	mov	esi, pdFirst
	mov	ebx, ecx

;; Start the vertex-processing loop
;;
;; for (pd = pdFirst; pd <= pdLast; pd++)

@lightVertexLoop:

;; If normal has not changed for this vertex, use the previously computed color.
;;	if (!(pd->flags & POLYDATA_NORMAL_VALID))

	mov	edx, [esi+PD_flags]
	test    edx, POLYDATA_NORMAL_VALID
	jne     @normalIsValid

	mov	eax, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_R_]
	mov	ecx, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_G_]
	mov	[(face*16) + esi + PD_colors0+_R_], eax
	mov	[(face*16) + esi + PD_colors0+_G_], ecx
	mov	eax, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_B_]
	mov	ecx, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_A_]
	mov	[(face*16) + esi + PD_colors0+_B_], eax
	mov     [(face*16) + esi + PD_colors0+_A_], ecx

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
if NUMBER_OF_LIGHTS eq 2
	xor	eax, eax
endif
	cmp	edi, esi
	jae	@lightVertexLoop
	jmp     @lightsDone

@normalIsValid:

if NUMBER_OF_LIGHTS eq 2
	mov	nonBack, eax
endif

	mov	edi, [ebx+GC_LIGHT_sources]

if face eq __GL_FRONTFACE

else
	mov	eax, [esi+PD_normal+_X_]
	mov	ecx, [esi+PD_normal+_Y_]
	mov	edx, [esi+PD_normal+_Z_]

	xor	eax, 80000000h
	xor	ecx, 80000000h
	xor	edx, 80000000h

	mov	nxi, eax
	mov	nyi, ecx
	mov	nzi, edx
endif

if NUMBER_OF_LIGHTS eq 2

	test	edi, edi
	je	@lightSourcesDone
@lightSourcesLoop:

endif

;; 	for (lsm = gc->light.sources; lsm; lsm = lsm->next)

	;; edi = lsm (light source pointer)
	
;;	n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
;;	     nzi * lsm->unitVPpli.z;

if face eq __GL_FRONTFACE
	fld     DWORD PTR [esi+PD_normal+_X_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_X_]
	fld     DWORD PTR [esi+PD_normal+_Y_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Y_]
	fld     DWORD PTR [esi+PD_normal+_Z_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Z_]
else
	fld     nxi
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_X_]
	fld     nyi
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Y_]
	fld     nzi
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Z_]
endif
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n1

;;	    if (__GL_FLOAT_GTZ(n1))

if NUMBER_OF_LIGHTS eq 2
	mov	ecx, nonBack
endif

	cmp	n1, 0
	jg	@f

if NUMBER_OF_LIGHTS eq 2
	mov	edi, [edi+LIGHTSOURCE_next]
	test	edi, edi
	je	@lightSourcesDone
	jmp	@lightSourcesLoop
else
        COPY_CACHED_NON_LIT <esi>, <ebx>, GC_LIGHT_value, face, <eax>, <ecx>

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
	cmp	edi, esi
	jae	@lightVertexLoop
	jmp     @lightsDone
endif

@@:

if NUMBER_OF_LIGHTS eq 2
	test	ecx, ecx                ; Has lighting been computed
	jne	@f
endif
	
	fld	DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_cachedEmissiveAmbient+_B_]
if NUMBER_OF_LIGHTS eq 2
	inc	ecx
endif
	fld	DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_cachedEmissiveAmbient+_G_]
if NUMBER_OF_LIGHTS eq 2
	mov	nonBack, ecx
endif
	fld	DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_cachedEmissiveAmbient+_R_]
@@:

;;		n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
;;                      - msm_threshold;

if face eq __GL_FRONTFACE
	fld     DWORD PTR [esi+PD_normal+_X_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_X_]
	fld     DWORD PTR [esi+PD_normal+_Y_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Y_]
	fxch    ST(1)
	fsub    DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_threshold]
	fld     DWORD PTR [esi+PD_normal+_Z_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Z_]
else
	fld     nxi
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_X_]
	fld     nyi
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Y_]
	fxch    ST(1)
	fsub    DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_threshold]
	fld     nzi
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Z_]
endif
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n2

;;	if (__GL_FLOAT_GEZ(n2))

	mov	eax, n2
	or	eax, eax
	js	@noSpecularEffect

;;	     ifx = (GLint)(n2 * msm_scale + __glHalf);


	fld     n2
	fmul    DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_scale]
	mov	edx, __FLOAT_ONE
;; Note: we don't have to do this add since we can assume that rounding
;; enabled:
;;	fadd    ___glHalf
	mov	ecx, [ebx+GC_LIGHT_value+MATERIAL_specTable]
	fistp   DWORD PTR ifx

;;	    if (ifx < __GL_SPEC_LOOKUP_TABLE_SIZE )

	mov	eax, ifx
	cmp	eax, __GL_SPEC_LOOKUP_TABLE_SIZE
	jge	@specularSaturate

;; 		n2 = msm_specTable[ifx];

	mov	edx, DWORD PTR [ecx+eax*4]

@specularSaturate:
	mov	n2, edx

	fld     n2
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_specular+_R_]
	fld     n2
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_specular+_G_]
	fld     n2
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_specular+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
	faddp	ST(3), ST	; b R G B
	faddp	ST(3), ST	; R G B

@noSpecularEffect:

	;; now handle diffuse affect:

	fld     n1
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_diffuse+_R_]
	fld     n1
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_diffuse+_G_]
	fld     n1
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_diffuse+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
if NUMBER_OF_LIGHTS eq 2
	mov	edi, [edi+LIGHTSOURCE_next]
endif
	faddp	ST(3), ST	; b R G B
if NUMBER_OF_LIGHTS eq 2
	test	edi, edi
endif
	faddp	ST(3), ST	; R G B

if NUMBER_OF_LIGHTS eq 2
	jne	@lightSourcesLoop

@lightSourcesDone:

	mov	eax, nonBack
	test	eax,eax
	jne	@f
        COPY_CACHED_NON_LIT <esi>, <ebx>, GC_LIGHT_value, face, <eax>, <ecx>

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
	xor	eax, eax
	cmp	edi, esi
	jae	@lightVertexLoop
	jmp     @lightsDone
@@:

endif ; NUMBER_OF_LIGHTS eq 2

	;; OK, we had some lighting for this vertex. Now, handle clamping:

	fstp	rsi
	mov	eax, [ebx+GC_redVertexScale]
	fstp	gsi
	mov	edx, rsi
	fstp	bsi
	
	mov	ecx, [ebx+GC_greenVertexScale]
	mov	edi, gsi
	sub	eax, edx
	sub	ecx, edi
	or	eax, edx
	or	ecx, edi
	mov	edx, [ebx+GC_blueVertexScale]
	or	eax, ecx
	mov	edi, bsi
	or	eax, edi
	sub	edx, edi
	or	eax, edx
	jns	@noClamp

	mov	eax, rsi
	mov	ecx, [ebx+GC_redVertexScale]
	sub	ecx, eax
        mov     [ebx+GC_redClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	edx, gsi
	adc	eax, eax
	mov	ecx, [ebx+GC_greenVertexScale]
	sub	ecx, edx

 	mov	eax, [4*eax+ebx+GC_redClampTable]

       	mov     [ebx+GC_greenClampTable], edx
	shr	edx, 31
	add	ecx, ecx
	mov	rsi, eax
	adc	edx, edx

	mov	eax, bsi
	mov	ecx, [ebx+GC_blueVertexScale]
	sub	ecx, eax

	mov	edx, [4*edx+ebx+GC_greenClampTable]

        mov     [ebx+GC_blueClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	gsi, edx

	adc	eax, eax
 	mov	eax, [4*eax+ebx+GC_blueClampTable]
	mov	bsi, eax

@noClamp:

	;; store colors

	mov	eax, [ebx+GC_LIGHT_value+MATERIAL_alpha]
	mov	ecx, rsi
	mov	edx, gsi
	mov	edi, bsi
	mov	[esi+PD_colors0+(face*16)+_A_], eax
	mov	[esi+PD_colors0+(face*16)+_R_], ecx
	mov	[esi+PD_colors0+(face*16)+_G_], edx
	mov	[esi+PD_colors0+(face*16)+_B_], edi

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
	xor	eax, eax
	cmp	edi, esi
	jae	@lightVertexLoop

@lightsDone:

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12

ENDM
;--------------------------------------------------------------------------------
@PolyArrayZippyCalcRGBColorFront@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_front, LIGHTSOURCE_front, __GL_FRONTFACE, 2
@PolyArrayZippyCalcRGBColorFront@20 ENDP

@PolyArrayZippyCalcRGBColorBack@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_back, LIGHTSOURCE_back, __GL_BACKFACE, 2
@PolyArrayZippyCalcRGBColorBack@20 ENDP
;
; Functions for the one light source
;
@PolyArrayZippyCalcRGBColorFront1@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_front, LIGHTSOURCE_front, __GL_FRONTFACE, 1
@PolyArrayZippyCalcRGBColorFront1@20 ENDP

@PolyArrayZippyCalcRGBColorBack1@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_back, LIGHTSOURCE_back, __GL_BACKFACE, 1
@PolyArrayZippyCalcRGBColorBack1@20 ENDP
;
; Functions for the no light sources
;
@PolyArrayZippyCalcRGBColorFront0@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR0 GC_LIGHT_front, __GL_FRONTFACE
@PolyArrayZippyCalcRGBColorFront0@20 ENDP

@PolyArrayZippyCalcRGBColorBack0@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR0 GC_LIGHT_back, __GL_BACKFACE
@PolyArrayZippyCalcRGBColorBack0@20 ENDP
;--------------------------------------------------------------------------------
; void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext* gc, int face, POLYARRAY* pa, 
;                                          POLYDATA* pdFirst, POLYDATA* pdLast)
;
; Input:
;       ecx             = gc
;       edx             = face (0 - front, 1 - back)
;       [esp+4]         = pa 
;       [esp+8]         = pdFirst
;       [esp+12]        = pdLast
;
@PolyArrayZippyCalcRGBColor@20 PROC NEAR

        push    edi
	mov	edi, [ecx+GC_LIGHT_sources]
        or      edi, edi
        jz      @noLights
        cmp     [edi+LIGHTSOURCE_next], 0
        jne     @multipleLights 
;
; one lignt case
;
        pop     edi
	test	edx, edx
	je	@PolyArrayZippyCalcRGBColorFront1@20
	jmp	@PolyArrayZippyCalcRGBColorBack1@20
                
@noLights:
        pop     edi
	test	edx, edx
	je	@PolyArrayZippyCalcRGBColorFront0@20
	jmp	@PolyArrayZippyCalcRGBColorBack0@20

@multipleLights:
        pop     edi

	test	edx, edx
	je	@PolyArrayZippyCalcRGBColorFront@20
	jmp	@PolyArrayZippyCalcRGBColorBack@20

@PolyArrayZippyCalcRGBColor@20 ENDP
;--------------------------------------------------------------------------------
; void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext* gc, int face, POLYARRAY* pa, 
;                                          POLYDATA* pdFirst, POLYDATA* pdLast)
;
; Input:
;       ecx             = gc
;       edx             = face (0 - front, 1 - back)
;       [esp+4]         = pa 
;       [esp+8]         = pdFirst
;       [esp+12]        = pdLast
;
emissiveAmbientR	equ DWORD PTR -60[ebp]
emissiveAmbientG	equ DWORD PTR -64[ebp]
emissiveAmbientB	equ DWORD PTR -68[ebp]
colorMaterialChange	equ           -72[ebp]
alpha			equ DWORD PTR -76[ebp]
ri			equ DWORD PTR -80[ebp]
gi			equ DWORD PTR -84[ebp]
bi			equ DWORD PTR -88[ebp]
diffuseSpecularR	equ DWORD PTR -92[ebp]
diffuseSpecularG	equ DWORD PTR -96[ebp]
diffuseSpecularB	equ DWORD PTR -100[ebp]

@PolyArrayFastCalcRGBColor@20 PROC NEAR
	mov	eax, [ecx+GC_LIGHT_front+MATERIAL_colorMaterialChange]
	test	edx, edx
	je	@f
	mov	eax, [ecx+GC_LIGHT_back+MATERIAL_colorMaterialChange]
@@:
	test	eax, eax
	je	@PolyArrayZippyCalcRGBColor@20

	push	ebp
	mov	ebp, esp
	sub	esp, 100
	test	edx, edx
	push	ebx
	mov	ebx, ecx
	push	esi

;; if (face == __GL_FRONTFACE)
;;     msm = &gc->light.front;
;;         else
;;     msm = &gc->light.back;

	lea	ecx, DWORD PTR [ebx+GC_LIGHT_front]
	je	short @f
	lea	ecx, DWORD PTR [ebx+GC_LIGHT_back]
@@:
	push	edi
	mov	DWORD PTR face, edx
	mov	msm, ecx
	mov	eax, [ecx+MATERIAL_colorMaterialChange]
	mov	colorMaterialChange, eax
	test	eax, __GL_MATERIAL_AMBIENT

	jne	@baseEmissiveSimple

	mov	eax, [ecx+MATERIAL_cachedEmissiveAmbient+_R_]
	mov	edx, [ecx+MATERIAL_cachedEmissiveAmbient+_G_]
	mov	baseEmissiveAmbientR, eax
	mov	emissiveAmbientR, eax
	mov	baseEmissiveAmbientG, edx
	mov	emissiveAmbientG, edx

	mov	eax, [ecx+MATERIAL_cachedEmissiveAmbient+_B_]
	mov	esi, pdFirst
	mov	edi, pdLast
	mov	baseEmissiveAmbientB, eax
	cmp	edi, esi
	mov	emissiveAmbientB, eax
	jb	@lightsDone

	jmp	@baseEmissiveDone

@baseEmissiveSimple:

	mov	eax, [ecx+MATERIAL_paSceneColor+_R_]
	mov	edx, [ecx+MATERIAL_paSceneColor+_G_]
	mov	baseEmissiveAmbientR, eax
	mov	emissiveAmbientR, eax
	mov	baseEmissiveAmbientG, edx
	mov	emissiveAmbientG, edx

	mov	eax, [ecx+MATERIAL_paSceneColor+_B_]
	mov	esi, pdFirst
	mov	edi, pdLast
	mov	baseEmissiveAmbientB, eax
	cmp	edi, esi
	mov	emissiveAmbientB, eax
	jb	@lightsDone

@baseEmissiveDone:

; If there is no emissive or ambient color material change, this
; will be the emissive and ambient components.
;
;    emissiveAmbientI.r = baseEmissiveAmbient.r;
;    emissiveAmbientI.g = baseEmissiveAmbient.g;
;    emissiveAmbientI.b = baseEmissiveAmbient.b;

;;
;;
;; Vertex loop follows:
;;
;;

;; for (pd = pdFirst; pd <= pdLast; pd++)

@lightVertexLoop:

        ;; If normal has not changed for this vertex, use the previously 
        ;; computed color.
        ;; [if !(pd->flags & (POLYDATA_NORMAL_VALID | POLYDATA_COLOR_VALID))]

        mov	edx, [esi+PD_flags]
        test	edx, POLYDATA_NORMAL_VALID OR POLYDATA_COLOR_VALID
        jne	@normalOrColorIsValid
        mov	eax, face
        shl	eax, 4
        lea	edi, [eax + esi + PD_colors0]
        lea	esi, [eax + esi + (PD_colors0 - sizeof_POLYDATA)]
        movsd
        movsd
        movsd
        movsd

        mov	esi, pd
        mov	edi, pdLast
        add	esi, sizeof_POLYDATA
        cmp	edi, esi
        mov	pd, esi
        jae	@lightVertexLoop
        jmp	@lightsDone

@normalOrColorIsValid:

        ;; if (pd->flags & POLYDATA_COLOR_VALID)
        ;;     ri = pd->colors[0].r * gc->oneOverRedVertexScale;
        ;;     gi = pd->colors[0].g * gc->oneOverGreenVertexScale;
        ;;     bi = pd->colors[0].b * gc->oneOverBlueVertexScale;
        ;;     alpha = pd->colors[0].a;

        test	edx, POLYDATA_COLOR_VALID
        je	@usePreviousColors

        mov	eax, [esi+PD_colors0+_A_]
        mov	alpha, eax
        mov	eax, colorMaterialChange
        fld	DWORD PTR [esi+PD_colors0+_R_]
        fmul	DWORD PTR [ebx+GC_oneOverRedVertexScale]
        fld	DWORD PTr [esi+PD_colors0+_G_]
        fmul	DWORD PTR [ebx+GC_oneOverGreenVertexScale]
        fld	DWORD PTR [esi+PD_colors0+_B_]
        fmul	DWORD PTR [ebx+GC_oneOverBlueVertexScale]	;; b g r
        fxch	ST(2)						;; r g b
        fstp	ri
        fstp	gi
        fstp	bi	;; FPU stack empty

        test	eax, __GL_MATERIAL_AMBIENT
        je	@noMaterialAmbient

	
        ;; 
        ;; Handle ambient color changes:
        ;;
        ;;	if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT) {
        ;;	    emissiveAmbient.r = baseEmissiveAmbient.r + ri * lm_ambient.r;
        ;;	    emissiveAmbient.g = baseEmissiveAmbient.g + gi * lm_ambient.g;
        ;;	    emissiveAmbient.b = baseEmissiveAmbient.b + bi * lm_ambient.b;
        ;;	}

        fld	ri
        fmul	DWORD PTR [ebx+GC_STATE_lightModelAmbient+_R_]
        fld	gi
        mov	edi, [ebx+GC_LIGHT_sources]
        fmul	DWORD PTR [ebx+GC_STATE_lightModelAmbient+_G_]
        fld	bi
        test	edi, edi
        fmul	DWORD PTR [ebx+GC_STATE_lightModelAmbient+_B_]	; b g r
        fxch	ST(1)						; g b r
        fadd	baseEmissiveAmbientG				; G b r
        fxch	ST(1)						; b G r
        fadd	baseEmissiveAmbientB				; B G r
        fxch	ST(2)						; r G B
        fadd	baseEmissiveAmbientR				; R G B

        jne	@ambientLoop

        fstp	emissiveAmbientR	;; If we don't have to process
        fstp	emissiveAmbientG	;; the lights, pop the FPU stack
        fstp	emissiveAmbientB	;; and continue
        jmp	@emissiveAmbientDone

@ambientLoop:

	;; Add per-light per-material ambient values.
	;; We will start with the current basEmissiveAmbient values
	;; already on the stack.

	;; for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	;;     emissiveAmbientI.r += ri * lsm->state.ambient.r;
	;;     emissiveAmbientI.g += gi * lsm->stats.ambient.g;
	;;     emissiveAmbientI.b += bi * lsm->state.ambient.b;
	;; }


        mov     edx, [edi+LIGHTSOURCE_state]		; lss
                
        fld     ri
        fmul    DWORD PTR [edx+LIGHTSOURCESTATE_ambient+_R_]
        fld     gi
        fmul    DWORD PTR [edx+LIGHTSOURCESTATE_ambient+_G_]
        fld     bi
        fmul    DWORD PTR [edx+LIGHTSOURCESTATE_ambient+_B_]	;; b g r R G B
        fxch    ST(2)						;; r g b R G B
        faddp   ST(3), ST(0)
        mov     edi, [edi+LIGHTSOURCE_next]
        faddp   ST(3), ST(0)
        test    edi, edi
        faddp   ST(3), ST(0)
        jne     @ambientLoop

        ;; There are no lights, so pop the emissive result at this point 
        ;; and continue:

        fstp	emissiveAmbientR
        fstp	emissiveAmbientG
        fstp	emissiveAmbientB
        jmp	@emissiveAmbientDone

@noMaterialAmbient:
	
	;;
	;; Handle emissive material changes if needed:
	;;

	test	eax, __GL_MATERIAL_EMISSIVE
	je	@emissiveAmbientDone

	;; emissiveAmbientR = baseEmissiveAmbientR + pd->colors[0].r;
	;; emissiveAmbientG = baseEmissiveAmbientG + pd->colors[0].g;
	;; emissiveAmbientB = baseEmissiveAmbientB + pd->colors[0].b;
	
	fld	baseEmissiveAmbientR
	fadd	DWORD PTR [esi+PD_colors0+_R_]
	fld	baseEmissiveAmbientG
	fadd	DWORD PTR [esi+PD_colors0+_G_]
	fld	baseEmissiveAmbientB
	fadd	DWORD PTR [esi+PD_colors0+_B_]	; b g r
	fxch	ST(2)				; r g b
	fstp	emissiveAmbientR
	fstp	emissiveAmbientG
	fstp	emissiveAmbientB

@emissiveAmbientDone:
@usePreviousColors:

	;;
	;; OK, we're done handling emissive and diffuse color changes, or
	;; we're simply using the previous values.  Now, handle portion of
	;; lighting which depends on the vertex normals (diffuse + specular):
	;;
	
	;; if (pd->flags & POLYDATA_NORMAL_VALID)

	mov	edx, [esi+PD_flags]
	test	edx, POLYDATA_NORMAL_VALID
	je	@normalNotValid

	mov	eax, face

;;	if (face == __GL_FRONTFACE)

	mov	ecx, [esi+PD_normal+_X_]
	mov	edx, [esi+PD_normal+_Y_]
	mov	esi, [esi+PD_normal+_Z_]

	test	eax, eax
	je	@notBackFace

	;; negate the floating-point normal values

	xor	ecx, 80000000h
	xor	edx, 80000000h
	xor	esi, 80000000h

@notBackFace:

	mov	nxi, ecx
	mov	nyi, edx
	mov	nzi, esi

	jmp	@calcColor


@normalNotValid:

;;	if (!(msm_colorMaterialChange & (__GL_MATERIAL_SPECULAR | __GL_MATERIAL_DIFFUSE)))
;;	    goto store_color;
	
	test	eax, __GL_MATERIAL_SPECULAR OR __GL_MATERIAL_DIFFUSE
	je	@storeColor

@calcColor:


	fld	___glZero
	mov	esi, [ebx+GC_LIGHT_sources]
	fld	___glZero
	test	esi, esi
	fld	___glZero
	je	@lightSourcesDone

@lightSourcesLoop:

;; 	for (lsm = gc->light.sources; lsm; lsm = lsm->next)


	mov	eax, face

;; 	    lspmm = &lsm->front + face;

	lea	ecx, [esi+LIGHTSOURCE_front]
	test	eax, eax
	je	@f
	lea	ecx, [esi+LIGHTSOURCE_back]
@@:

	;; esi = lsm
	;; ecx = lspmm
	
;;	    n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
;;		nzi * lsm->unitVPpli.z;


	fld     nxi
	mov	edi, msm
	fmul    DWORD PTR [esi+LIGHTSOURCE_unitVPpli+_X_]
	fld     nyi
	fmul    DWORD PTR [esi+LIGHTSOURCE_unitVPpli+_Y_]
	fld     nzi
	fmul    DWORD PTR [esi+LIGHTSOURCE_unitVPpli+_Z_]
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n1

;;	    if (__GL_FLOAT_GTZ(n1))

	mov	eax, n1
	cmp	eax, 0
	jg	@f
	mov	esi, [esi+LIGHTSOURCE_next]
	test	esi, esi
	jne	@lightSourcesLoop
	jmp	@lightSourcesDone
@@:

;;		n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
;;                      - msm_threshold;

	fld     nxi
	fmul    DWORD PTR [esi+LIGHTSOURCE_hHat+_X_]
	fld     nyi
	fmul    DWORD PTR [esi+LIGHTSOURCE_hHat+_Y_]
	fxch    ST(1)
	fsub    DWORD PTR [edi+MATERIAL_threshold]
	fld     nzi
	fmul    DWORD PTR [esi+LIGHTSOURCE_hHat+_Z_]
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n2

;;	if (__GL_FLOAT_GEZ(n2))

	mov	eax, n2
	or	eax, eax
	js	@noSpecularEffect

;;	     ifx = (GLint)(n2 * msm_scale + __glHalf);


	fld     n2
	fmul    DWORD PTR [edi+MATERIAL_scale]
	mov	edx, __FLOAT_ONE
;; Note: we don't have to do this add since we can assume that rounding
;; enabled:
;;	fadd    ___glHalf
	mov	edi, [edi+MATERIAL_specTable]
	fistp   DWORD PTR ifx

;;	    if (ifx < __GL_SPEC_LOOKUP_TABLE_SIZE )

	mov	eax, ifx
	cmp	eax, __GL_SPEC_LOOKUP_TABLE_SIZE
	jge	@specularSaturate

;; 		n2 = msm_specTable[ifx];

	mov	edx, DWORD PTR [edi+eax*4]

@specularSaturate:
	mov	eax, colorMaterialChange
	mov	n2, edx
	test	eax, __GL_MATERIAL_SPECULAR
	je	@noSpecularMaterialChange
	
	fld	n2
	mov	edx, [esi+LIGHTSOURCE_state]
	fmul	ri
	fld	n2
	fmul	gi
	fld	n2
	fmul	bi		; b g r
	fxch	ST(2)		; r g b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_specular+_R_]
	fxch	ST(1)		; g r b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_specular+_G_]
	fxch	ST(2)		; b r g
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_specular+_B_]
	fxch	ST(1)		; r b g R G B
	faddp	ST(3), ST(0)	; b g R G B
	fxch	ST(1)		; g b R G B
	faddp	ST(3), ST(0)	; b R G B
	faddp	ST(3), ST(0)	; R G B
	jmp	short @noSpecularEffect
	

@noSpecularMaterialChange:


	fld     n2
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_specular+_R_]
	fld     n2
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_specular+_G_]
	fld     n2
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_specular+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
	faddp	ST(3), ST	; b R G B
	faddp	ST(3), ST	; R G B

@noSpecularEffect:
	;; now handle diffuse affect:
	mov	eax, colorMaterialChange
	test	eax, __GL_MATERIAL_DIFFUSE
	je	@noDiffuseMaterialChange
	fld	n1
	mov	edx, [esi+LIGHTSOURCE_state]
	fmul	ri
	fld	n1
	fmul	gi
	fld	n1
	fmul	bi		; b g r
	fxch	ST(2)		; r g b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_diffuse+_R_]
	fxch	ST(1)		; g r b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_diffuse+_G_]
	fxch	ST(2)		; b r g
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_diffuse+_B_]
	fxch	ST(1)		; r b g R G B
	faddp	ST(3), ST(0)	; b g R G B
	fxch	ST(1)		; g b R G B
	faddp	ST(3), ST(0)	; b R G B
	faddp	ST(3), ST(0)	; R G B
	jmp	short @lightSourcesDone

@noDiffuseMaterialChange:

	fld     n1
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_diffuse+_R_]
	fld     n1
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_diffuse+_G_]
	fld     n1
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_diffuse+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
	mov	esi, [esi+LIGHTSOURCE_next]
	faddp	ST(3), ST	; b R G B
	test	esi, esi
	faddp	ST(3), ST	; R G B
	jne	@lightSourcesLoop
	
@lightSourcesDone:

	fst	diffuseSpecularR
        fadd    emissiveAmbientR    ; R g b
        fxch    ST(1)               ; g R b
	fst	diffuseSpecularG
        fadd    emissiveAmbientG    ; G R b
        fxch    ST(2)               ; b R G
	fst	diffuseSpecularB
        fadd    emissiveAmbientB    ; B R G
        fxch    ST(1)               ; R B G
	fstp	rsi
        mov	eax, [ebx+GC_redVertexScale]
	fstp	bsi
        mov	ecx, [ebx+GC_greenVertexScale]
	fstp	gsi
        mov	edx, rsi

        jmp     short @handleClamp

@storeColor:

	;; Now add emissiveAmbient (on FP stack) and diffuseSpecular.
	;; Interleave with start of clamping:

        fld     emissiveAmbientR
        mov	eax, [ebx+GC_redVertexScale]
        fadd    diffuseSpecularR
        mov	ecx, [ebx+GC_greenVertexScale]
        fld     emissiveAmbientG
        fadd    diffuseSpecularG
        fld     emissiveAmbientB
        fadd    diffuseSpecularB
        fxch    ST(2)               ; r g b
        fstp    rsi
        fstp    gsi
        mov	edx, rsi
        fstp    bsi

@handleClamp:

	;; handle clamping:

	mov	edi, gsi
	sub	eax, edx
	sub	ecx, edi
	or	eax, edx
	or	ecx, edi
	mov	edx, [ebx+GC_blueVertexScale]
	or	eax, ecx
	mov	edi, bsi
	or	eax, edi
	sub	edx, edi
	or	eax, edx
	jns	@noClamp

	mov	eax, rsi
	mov	ecx, [ebx+GC_redVertexScale]
	sub	ecx, eax
        mov     [ebx+GC_redClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	edx, gsi
	adc	eax, eax
	mov	ecx, [ebx+GC_greenVertexScale]
	sub	ecx, edx

 	mov	eax, [4*eax+ebx+GC_redClampTable]

       	mov     [ebx+GC_greenClampTable], edx
	shr	edx, 31
	add	ecx, ecx
	mov	rsi, eax
	adc	edx, edx

	mov	eax, bsi
	mov	ecx, [ebx+GC_blueVertexScale]
	sub	ecx, eax

        mov	edx, [4*edx+ebx+GC_greenClampTable]

        mov     [ebx+GC_blueClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	gsi, edx

	adc	eax, eax
 	mov	eax, [4*eax+ebx+GC_blueClampTable]
	mov	bsi, eax

@noClamp:

        ;; ecx = pd->colors[face]

	mov	edx, msm

	mov	eax, face
	mov	esi, pd
	shl	eax, 4
	lea	ecx, [esi+PD_colors0]
	mov	edi, colorMaterialChange
	add	ecx, eax

	test	edi, __GL_MATERIAL_DIFFUSE
	je	@noAlphaChange

	mov	edx, alpha
	mov	eax, [ebx+GC_alphaVertexScale]
	test	edx, edx
	jns	@f
	xor	edx, edx
@@:
	sub	eax, edx
	jge	@alphaDone
	mov	edx, [ebx+GC_alphaVertexScale]
	jmp	short @alphaDone

@noAlphaChange:

	mov	edx, [edx+MATERIAL_alpha]

@alphaDone:
	
	mov	edi, pdLast
	add	esi, sizeof_POLYDATA

	;; store colors

	mov	[ecx+_A_], edx
	mov	eax, rsi
	mov	edx, gsi
	mov	[ecx+_R_], eax
	mov	pd, esi
	mov	eax, bsi
	mov	[ecx+_G_], edx
	mov	[ecx+_B_], eax

	;; loop to next pd

	cmp	edi, esi
	jae	@lightVertexLoop
	
@lightsDone:

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12
@PolyArrayFastCalcRGBColor@20 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\span_f.asm ===
;----------------------------------------------------------------------
; Module name: span_f.asm
;
; Created: 2/3/94
; Author:  Otto Berkes [ottob]
;
; Draw fast flat-shaded, z-buffered scanlines.
;----------------------------------------------------------------------


.code


;----------------------------------------------------------------------
; __fastxxxFlatSpan
;
; Draw a flat-shaded span.
;----------------------------------------------------------------------

XNAME <begin::>

PROCNAME <FlatSpan  PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL xlatAddr: dword
	LOCAL rAccum: dword
	LOCAL gAccum: dword
	LOCAL bAccum: dword
	LOCAL aAccum: dword
	LOCAL zAccum: dword
	LOCAL zDelta: dword
	LOCAL ditherVals: dword
	LOCAL ditherVals2: dword
	LOCAL ditherVals3: dword
	LOCAL ditherVals4: dword

	mov	esi, GLCONTEXT
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_r
	mov	rAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_g
	mov	gAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_b
	mov	bAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_a
	mov	aAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_z
	mov	zAccum, eax

	mov	ebx, [esi].GENCTX_pPrivateArea
	mov	ebx, [ebx]
	mov	eax, [ebx].SPANREC_z
	mov	zDelta, eax

	mov	edi, [esi].GENCTX_ColorsBits
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_cfb
	test	dword ptr [edx].BUF_other, DIB_FORMAT
	je	@no_dib
	mov	edi, [edx].BUF_base
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	sub	eax, [esi].CTX_constants.CTXCONST_viewportYAdjust
	add	eax, [edx].BUF_yOrigin
	mov	ebx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	sub	ebx, [esi].CTX_constants.CTXCONST_viewportXAdjust
	add	ebx, [edx].BUF_xOrigin
	mul	dword ptr [edx].BUF_outerWidth
XNAME <bpp::>
	shl	ebx, 2
	add	eax, ebx
	add	edi, eax
@no_dib:
	mov	eax, [esi].GENCTX_pajTranslateVector
if RGBMODE eq 0
XNAME <cixlat_ofs::>
	add	eax, GLintSize		; for color-index modes, the first
endif					; entry is the # of entries!
	mov	xlatAddr, eax

					; calculate dither values for span
if DITHER
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	and	edx, 03h
	shl	edx, 2
	mov	edx, Dither_4x4[edx]
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	and	ecx, 03h
	shl	ecx, 3
	ror	edx, cl		;edx has x-aligned dither entries for span
endif

if RGBMODE ;>>>>>>>>>>>>>>>> RGBMODE RGB case

;; Pre-calculate 4 dither values along scanline since the color is constant

	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	lea	esi, ditherVals
	cmp	ecx, 0
	jle	@fastSpanDone

if DITHER ;>>>>>>>>>>>>>>>> RGB dither case
	cmp	ecx, 4
	jle	@genDitherLoop
	mov	ecx, 4

@genDitherLoop:

;; Blue component

	mov	eax, bAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <bmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
XNAME <bshift::>
	shl	eax, 11
	mov	ebx, eax

;; Green component

	mov	eax, gAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <gmax::>
	mov	al, 0111111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
XNAME <gshift::>
	shl	eax, 5
	or	ebx, eax

;; Red component

	mov	eax, rAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <rmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
XNAME <rshift::>
	shl	eax, 0
	or	ebx, eax

	xchg	ebx, eax

	mov	ebx, xlatAddr		;translate to physical color
XNAME <xlat::>
	xlatb

XNAME <write_dither1::>			;write result into dither buffer
	mov	[esi], ax
XNAME <write_dither2::>
	add	esi, 2

	ror	edx, 8			;advance dither to next x-address
	dec	ecx
	jg	@genDitherLoop

else ;>>>>>>>>>>>>>>>> RGB no-dither case

	mov	eax, bAccum
	shr	eax, 16
XNAME <bshift::>
	shl	eax, 11
	mov	edx, eax

	mov	eax, gAccum
	shr	eax, 16
XNAME <gshift::>
	shl	eax, 5
	or	edx, eax

	mov	eax, rAccum
	shr	eax, 16
XNAME <rshift::>
	shl	eax, 0
	or	edx, eax

	mov	eax, edx
	mov	ebx, xlatAddr		;translate to physical color
XNAME <xlat::>
	xlatb
	mov	dl, al


endif ;<<<<<<<<<<<<<<<< end RGB DITHER cases

else  ;>>>>>>>>>>>>>>>> RGBMODE color-index case

	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	lea	esi, ditherVals
	cmp	ecx, 0
	jle	@fastSpanDone

if DITHER ;>>>>>>>>>>>>>>>> dithered color-index case
	cmp	ecx, 4
	jle	@genDitherLoop
	mov	ecx, 4

@genDitherLoop:
	mov	eax, rAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
	mov	al, ah
	xor	ah, ah
XNAME <cixlat_shift::>
	shl	eax, 2			; 4 or 1 byte/entry
	add	eax, xlatAddr
	mov	eax, [eax]
XNAME <write_dither1::>			;write result into dither buffer
	mov	[esi], ax
XNAME <write_dither2::>
	add	esi, 2
	
	ror	edx, 8
	dec	ecx
	jg	@genDitherLoop

else ;>>>>>>>>>>>>>>>> solid color-index case

	mov	eax, rAccum
	shr	eax, 16
XNAME <cixlat_shift::>
	shl	eax, 2			; 4 or 1 byte/entry
	add	eax, xlatAddr
	mov	eax, [eax]
	mov	edx, eax		; we store pre-computed value in edx
endif ;<<<<<<<<<<<<<<<< end color-index DITHER cases


endif ;<<<<<<<<<<<<<<<< end RGBMODE cases


;; load up interpolation/count registers

	mov	esi, GLCONTEXT
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	mov	eax, zAccum
	mov	esi, [esi].CTX_polygon.POLY_shader.SHADE_zbuf
if DITHER
	xor	ebx, ebx
endif


;; start of z-buffer/color-interpolation loop

	;;ztest-pass case

align 4
@ztest_pass:
XNAME <ztest_begin::>
	cmp	eax, [esi]
XNAME <ztest_pass::>
	jae	near ptr @ztest_fail_cont
@ztest_pass_cont:
XNAME <zwrite::>
	mov	[esi],eax
	add	eax, zDelta
	add	esi, __GLzValueSize	
XNAME <ztest_end::>

if DITHER
XNAME <and_dither::>
	and	ebx, 7h
	lea	edx, ditherVals
XNAME <get_dither::>
	mov	dx, [edx + ebx]
endif

XNAME <write_pix::>
	mov	[edi], dx
XNAME <dest_inc1::>
if DITHER
	add	ebx, 2
endif
	add	edi, 2
	dec	ecx
XNAME <ztest_jmp::>
	jg	near ptr @ztest_pass
	jmp	short @fastSpanDone

	;;ztest-fail case
	;; not much to do here except advance adresses, dither
align 4
@ztest_fail:
	cmp	eax, [esi]
XNAME <ztest_fail::>
	jb	near ptr @ztest_pass_cont
@ztest_fail_cont:
	add	eax, zDelta
	add	esi, __GLzValueSize	
XNAME <dest_inc2::>
if DITHER
	add	ebx, 2
endif
	add	edi, 2
	dec	ecx
	jg	short @ztest_fail

@fastSpanDone:
	ret

PROCNAME <FlatSpan  ENDP>

XNAME <end::>



;----------------------------------------------------------------------
; __fastxxxFlatSpanSetup(GLCONTEXT *)
;
; Copy the span routine from the template and modify it to reflect
; the current state.
;----------------------------------------------------------------------


PROCNAME <FlatSpanSetup PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL funcAddr: dword

	COPYPROC

	mov	esi, GLCONTEXT
	mov	edx, [esi].CTX_drawBuffer

	; ecx = bytes/pixel

	xor	ecx, ecx
	mov	cl, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	cl, 7
	shr	cl, 3

	; ebx is index for byte-per-pixel modifications

	mov	ebx, ecx
	and	ebx, 0eh
	shl	ebx, 1

;; bytes/pixel adjustment (shifts)

	mov	al, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	al, 7
	shr	al, 4
	XOFS	bpp
	mov	[edi]+2, al


if RGBMODE ;>>>>>>>>>>>>>>>> RGB case

	;; blue max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_blueMax
	XOFS	bmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iBlueShift
	XOFS	bshift
	mov	[edi]+2, al
	

	;; green max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_greenMax
	XOFS	gmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iGreenShift
	XOFS	gshift
	mov	[edi]+2, al
	

	;; red max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_redMax
	XOFS	rmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iRedShift
	XOFS	rshift
	mov	[edi]+2, al
	
	;; paletted-device color-translation

	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	je	@doTranslate

	XOFS	xlat
	mov	byte ptr [edi], NOP_CODE

@doTranslate:

else ;>>>>>>>>>>>>>>>> color-index case

				; no offset or address-shift needed
	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	jg	@longXlat		; for 8-bit CI mode
	XOFS	cixlat_ofs
	mov	byte ptr [edi]+2, 0
	XOFS	cixlat_shift
	mov	byte ptr [edi]+2, 0
@longXlat:

endif ;>>>>>>>>>>>>>>>> end RGB cases


if DITHER
	;; dither-write

	mov	ax, word ptr write_dither_ops[ebx]
	XOFS	write_dither1
	mov	[edi], ax
	mov	al, byte ptr write_dither_ops[ebx+2]
	mov	[edi]+2, al

	; account for pixel size

	XOFS	write_dither2
	mov	[edi]+2, cl

endif

	;; pixel-write

	mov	ax, word ptr write_fpix_ops[ebx]
	XOFS	write_pix
	mov	[edi], ax
	mov	al, byte ptr write_fpix_ops[ebx+2]
	mov	[edi]+2, al

if DITHER
	;; dither-value fetch

	mov	eax, dword ptr read_dither_ops[ebx]
	XOFS	get_dither
	mov	[edi], eax
endif

	;; z-test conditions

	mov	eax, [esi].CTX_state.ATTR_depth.DEPTH_testFunc
	and	eax, 3
	mov	ebx, eax
	shl	ebx, 2
	shl	eax, 1
	add	ebx, eax	; 6 bytes/jump

	;; z-test pass condition
	
	mov	ax, word ptr ztest_pass_functions[ebx]
	XOFS	ztest_pass
	mov	[edi], ax

	;; z-test fail condition

	mov	ax, word ptr ztest_fail_functions[ebx]
	XOFS	ztest_fail
	mov	[edi], ax


	;; z write-enable

	test  	dword ptr [esi].CTX_state.ATTR_depth.DEPTH_writeEnable, 1
	jne	@zwriteEnabled

	XOFS	zwrite
	mov	byte ptr [edi], NOP_CODE
	mov	byte ptr [edi]+1, NOP_CODE

@zwriteEnabled:

	;; destination-offset increment

	XOFS	dest_inc1
	mov	[edi]+2, cl
if DITHER
	mov	[edi]+5, cl
endif
	XOFS	dest_inc2
	mov	[edi]+2, cl
if DITHER
	mov	[edi]+5, cl

	shl	cl, 2		; 4 dither entries used
	dec	cl
	XOFS	and_dither
	mov	[edi]+2, cl
endif	

	;; z-buffer enable

	test	dword ptr [esi].CTX_polygon.POLY_shader.SHADE_modeFlags,__GL_SHADE_DEPTH_TEST
	jne	@depthTestEnabled

	XOFS	ztest_end
	mov	eax, edi
	XOFS	ztest_begin
	sub	eax, edi	
	mov	ebx, eax

	;if z-buffer is not enabled so jump around initial z test...

	XOFS	ztest_begin
	mov	[edi], JMP_CODE
	sub	bl, 2		;account for instruction encoding
	add	[edi]+1, bl

	;and continue to loop "under" z test

	XOFS	ztest_jmp
	add	[edi]+2, eax
@depthTestEnabled:
	ret




;; Enumerate the needed read/write operations for the various pixel
;; sizes.  The byte and dword versions have an extra NOP since the
;; 16-bit operation takes 3 bytes due to the 066h prefix.  Alternatively,
;; we could get around this by fixing up the addresses.  The other NOP
;; pads is not embedded in code; it simply keeps things dword-aligned


align 4
write_fpix_ops:		
write_fpix_byte:		
	mov	[edi], dl
	nop
	nop
write_fpix_word:	
	mov	[edi], dx
	nop
write_fpix_dword:	
	mov	[edi], edx
	nop
	nop


align 4
write_dither_ops:		
write_dither_byte:		
	mov	[esi], al
	nop
	nop
write_dither_word:	
	mov	[esi], ax
	nop
write_dither_dword:	
	mov	[esi], eax
	nop
	nop


align 4
read_dither_ops:			
read_dither_byte:			
	mov	dl, [edx+ebx]
	nop
read_dither_word:	
	mov	dx, [edx+ebx]
read_dither_dword:	
	mov	edx, [edx+ebx]
	nop


PROCNAME <FlatSpanSetup ENDP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\span.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: span.asm
;
; Created: 2/3/94
; Author:  Otto Berkes [ottob]
;
; Get serious about drawing scanlines.
;
; Copyright (c) 1994 Microsoft Corporation
;----------------------------------------------------------------------;


.386

.model  small,c

assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
assume fs:nothing,gs:nothing

.xlist
include gli386.inc
.list


.data

NOP_CODE = 090h		;nop
JMP_CODE = 0EBh		;short jump

;; 4x4 (Bayer) dither matrix (Foley & van Dam 13.15) biased for
;; fractional values between 0 and 0ffh

Dither_4x4	dd	0008020a0h
 	   	dd	0c040e060h
	   	dd	030b01090h
	   	dd	0f070d050h

.code

;; Z-test function opcodes.  The assembled operands required for the
;; selected z-comparison are inserted into the loaded span routine 


ztest_fail_functions_short::
psZtest_never:
	db	2 dup (NOP_CODE)
psZtest_l:
	jb	short @target
psZtest_e:
	je	short @target
psZtest_le:
	jbe	short @target
psZtest_g:
	ja	short @target
psZtest_ne:
	jne	short @target
psZtest_ge:
	jae	short @target
psZtest_always:
	jmp	short $+2


ztest_pass_functions_short::
fsZtest_never:
	db	2 dup (NOP_CODE)
fsZtest_ge:
	jae	short @target
fsZtest_ne:
	jne	short @target
fsZtest_g:
	ja	short @target
fsZtest_le:
	jbe	short @target
fsZtest_e:
	je	short @target
fsZtest_l:
	jb	short @target
fsZtest_always:
	jmp	short $+2

@target:

ztest_fail_functions::
pZtest_never:
	db	6 dup (NOP_CODE)
pZtest_l:
	jb	near ptr @target
pZtest_e:
	je	near ptr @target
pZtest_le:
	jbe	near ptr @target
pZtest_g:
	ja	near ptr @target
pZtest_ne:
	jne	near ptr @target
pZtest_ge:
	jae	near ptr @target
pZtest_always:
	jmp	$+6


ztest_pass_functions::
fZtest_never:
	db	6 dup (NOP_CODE)
fZtest_ge:
	jae	near ptr @target
fZtest_ne:
	jne	near ptr @target
fZtest_g:
	ja	near ptr @target
fZtest_le:
	jbe	near ptr @target
fZtest_e:
	je	near ptr @target
fZtest_l:
	jb	near ptr @target
fZtest_always:
	jmp	$+6


;----------------------------------------------------------------------
; int __fastProcsSize
;
; Returns size needed for function/data storage.  This could be done as
; a global...
;----------------------------------------------------------------------

__fastProcsSize	PROC
	mov	eax, size __FASTFUNCSINTERNAL
	ret
__fastProcsSize	ENDP


;----------------------------------------------------------------------
; __fastDepthTestSpan
;
; Run the z interpolation for the supplied span.
;----------------------------------------------------------------------


zspan_begin::

__fastDepthTestSpan	PROC	uses ebx edx esi edi, GLCONTEXT: ptr
	LOCAL deltazx:	dword
	LOCAL scan_len: dword
	LOCAL scan_len_org: dword
	LOCAL mask_addr: dword

	mov	esi, GLCONTEXT

	mov	edi, [esi].CTX_polygon.POLY_shader.SHADE_zbuf	; edi points to z-buffer
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	mov	scan_len, eax
	mov	scan_len_org, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_dzdx
	mov	deltazx, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_stipplePat
	mov	mask_addr, eax
						; eax is initial z value
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_z
	xor	esi, esi			; esi maintains "fail" count

align 4
z_loop:
	mov	ecx, scan_len
	sub	scan_len, 32
	test	ecx, ecx
	jle	z_done

	cmp	ecx, 32
	jle	short small_zfrag
	mov	ecx, 32
small_zfrag:

;; alternative for above?	
;;	mov	eax, 32		; ecx = min(ecx-1, 31)
;;	cmp	eax, ecx
;;	sbb	ah, 0
;;	dec	ecx
;;	or	cl, ch
;;	and	ecx, 01fh

	mov	edx, 07fffffffh	; mask bit
	mov	ebx, -1		; initial mask value is all 1's
	
align 4
zrep_pass:			; case for test pass
	cmp	eax, [edi]
zspan_pass_op::
	jae	short zcmp_fail_r1
zspan_write::
zcmp_pass_r1:
	mov	[edi],eax
	add	eax, deltazx
	add	edi, __GlzValueSize	
	ror	edx, 1
	dec	ecx
	jg	short zrep_pass

	mov	ecx, mask_addr
	mov	[ecx], ebx
	add	ecx, 4
	mov	mask_addr, ecx
	jmp	short z_loop

align 4
zrep_fail:			; case for test fail
	cmp	eax, [edi]
zspan_fail_op::
	jb	short zcmp_pass_r1
zcmp_fail_r1:
	add	eax, deltazx
	and	ebx, edx
	inc	esi		; increment fail count
	add	edi, __GLzValueSize	
	ror	edx, 1
	dec	ecx
	jg	short zrep_fail

	mov	ecx, mask_addr
	mov	[ecx], ebx
	add	ecx, 4
	mov	mask_addr, ecx
	jmp	short z_loop

z_done:
	xor	eax, eax
	cmp	esi, 0
	jne	z_fails
	ret
z_fails:
	inc	eax
	xor	ebx, ebx
	cmp	esi, scan_len_org
	jne	z_fails_some
	mov	esi, GLCONTEXT
	mov	dword ptr [esi].CTX_polygon.POLY_shader.SHADE_done, 1
z_fails_some:
	ret

__fastDepthTestSpan	ENDP

zspan_end::


XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset target - offset zspan_begin
ENDM

;----------------------------------------------------------------------
; __fastDepthTestSpanSetup(GLCONTEXT *)
;
; Copy the span depth-test span routine from the template and modify it 
; to reflect the current z mode.
;----------------------------------------------------------------------


__fastDepthTestSpanSetup  PROC	uses ebx edx esi edi, GLCONTEXT: ptr
	LOCAL funcAddr: dword

	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanZFunc
	mov	funcAddr, edi
	mov	esi, offset __fastDepthTestSpan
	mov	ecx, (zspan_end - zspan_begin + 3) / 4
	rep	movsd

	mov	esi, GLCONTEXT
	mov	edx, [esi].CTX_drawBuffer

	;; z-test conditions

	mov	ebx, [esi].CTX_state.ATTR_depth.DEPTH_testFunc
	and	ebx, 3
	add	ebx, ebx		; 2 bytes/short jump

	;; z-test pass condition
	
	mov	al, byte ptr ztest_pass_functions_short[ebx]
	XOFS	zspan_pass_op
	mov	[edi], al

	;; z-test fail condition

	mov	al, byte ptr ztest_fail_functions_short[ebx]
	XOFS	zspan_fail_op
	mov	[edi], al


	;; z write-enable

	test  	dword ptr [esi].CTX_state.ATTR_depth.DEPTH_writeEnable, 1
	jne	@zwriteEnabled

	XOFS	zspan_write
	mov	byte ptr [edi], NOP_CODE
	mov	byte ptr [edi]+1, NOP_CODE

        mov     eax, funcAddr
@zwriteEnabled:
	ret
__fastDepthTestSpanSetup ENDP


;----------------------------------------------------------------------
; __fastDeltaSpan(GLCONTEXT *)
;
; Set up the scan x delta values for subsequent spans.
;----------------------------------------------------------------------


__fastDeltaSpan	PROC	uses ebx esi edi, GLCONTEXT: ptr, SCANDELTA: ptr

	mov	esi, GLCONTEXT
	mov	ebx, [esi].CTX_polygon.POLY_shader.SHADE_modeFlags
	mov	edi, [esi].GENCTX_pPrivateArea
        mov     edi, [edi]
	mov	esi, SCANDELTA

	test	ebx, __GL_SHADE_RGB
        jne	@doRGB

	mov	eax, __spanFlatFunc
        test	ebx, __GL_SHADE_SMOOTH
	je	@flatI
	mov	ecx, [esi].SPANREC_r
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_r, ecx
	cmp	ecx, 0
	je	@flatI
	mov	eax, __spanSmoothFunc
@flatI:
	mov	ecx, [esi].SPANREC_z
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_z, ecx
	mov	esi, GLCONTEXT
	add	eax, [esi].GENCTX_pPrivateArea
	mov	[edi].FASTFUNCS_fastSpanFuncPtr, eax
	ret

@doRGB:
	mov	eax, __spanFlatFunc
        test	ebx, __GL_SHADE_SMOOTH
	je	@flatRGB
	mov	ecx, [esi].SPANREC_r
	mov	edx, ecx
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_r, ecx
	mov	ecx, [esi].SPANREC_g
	or	edx, ecx
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_g, ecx
	mov	ecx, [esi].SPANREC_b
	or	edx, ecx
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_b, ecx
	je	@flatRGB
	mov	eax, offset __spanSmoothFunc
@flatRGB:
	mov	ecx, [esi].SPANREC_z
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_z, ecx
	mov	esi, GLCONTEXT
	add	eax, [esi].GENCTX_pPrivateArea
	mov	[edi].FASTFUNCS_fastSpanFuncPtr, eax
	ret

__fastDeltaSpan ENDP


;======================================================================
; Smooth-shaded dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGB&name
ENDM

XNAME	MACRO	name
	pix_ssrgb_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBSmoothSpan
	mov	ecx, (pix_ssrgb_end - pix_ssrgb_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_ssrgb_&target - offset pix_ssrgb_begin
;;	Note:  the assembler produces an error if we try to combine the
;;	above into a single operation due to "mismatched segments".  Arg!
ENDM

DITHER = 1
RGBMODE = 1

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGB&name
ENDM

XNAME	MACRO	name
	pix_fsrgb_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBFlatSpan
	mov	ecx, (pix_fsrgb_end - pix_fsrgb_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fsrgb_&target - offset pix_fsrgb_begin
ENDM

DITHER = 1
RGBMODE = 1

;=================
INCLUDE	span_f.asm
;=================


;======================================================================
; Smooth-shaded dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCI&name
ENDM

XNAME	MACRO	name
	pix_ssci_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCISmoothSpan
	mov	ecx, (pix_ssci_end - pix_ssci_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr	
	add	edi, offset pix_ssci_&target - offset pix_ssci_begin
ENDM

DITHER = 1
RGBMODE = 0

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCI&name
ENDM

XNAME	MACRO	name
	pix_fsci_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCIFlatSpan
	mov	ecx, (pix_fsci_end - pix_fsci_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fsci_&target - offset pix_fsci_begin
ENDM

DITHER = 1
RGBMODE = 0

;=================
INCLUDE	span_f.asm
;=================


;======================================================================
;======================================================================
;
; Non-dithered routines
;
;======================================================================
;======================================================================


;======================================================================
; Smooth-shaded non-dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGBND&name
ENDM

XNAME	MACRO	name
	pix_ssrgbnd_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBNDSmoothSpan
	mov	ecx, (pix_ssrgbnd_end - pix_ssrgbnd_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_ssrgbnd_&target - offset pix_ssrgbnd_begin
;;	Note:  the assembler produces an error if we try to combine the
;;	above into a single operation due to "mismatched segments".  Arg!
ENDM

DITHER = 0
RGBMODE = 1

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded non-dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGBND&name
ENDM

XNAME	MACRO	name
	pix_fsrgbnd_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBNDFlatSpan
	mov	ecx, (pix_fsrgbnd_end - pix_fsrgbnd_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fsrgbnd_&target - offset pix_fsrgbnd_begin
ENDM

DITHER = 0
RGBMODE = 1

;=================
INCLUDE	span_f.asm
;=================


;======================================================================
; Smooth-shaded non-dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCIND&name
ENDM

XNAME	MACRO	name
	pix_sscind_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCINDSmoothSpan
	mov	ecx, (pix_sscind_end - pix_sscind_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_sscind_&target - offset pix_sscind_begin
ENDM

DITHER = 0
RGBMODE = 0

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded non-dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCIND&name
ENDM

XNAME	MACRO	name
	pix_fscind_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCINDFlatSpan
	mov	ecx, (pix_fscind_end - pix_fscind_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fscind_&target - offset pix_fscind_begin
ENDM

DITHER = 0
RGBMODE = 0

;=================
INCLUDE	span_f.asm
;=================


.data


__FASTFUNCSINTERNAL struct
	__funcsPtr		dd      ?
align 4
	__spanZFunc		db (zspan_end - zspan_begin + 3) dup (0)
align 4
	__spanSmoothFunc	db (pix_ssrgb_end - pix_ssrgb_begin + 3) dup (0)
align 4
	__spanFlatFunc		db (pix_fsrgb_end - pix_fsrgb_begin + 3) dup (0)
align	4
	__pad			dd	?
__FASTFUNCSINTERNAL ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\span_s.asm ===
;----------------------------------------------------------------------
; Module name: span_s.asm
;
; Created: 2/3/94
; Author:  Otto Berkes [ottob]
;
; Draw fast smooth-shaded, z-buffered scanlines.
;----------------------------------------------------------------------


.code


;----------------------------------------------------------------------
; __fastxxxSmoothSpan
;
; Draw a smooth-shaded span.
;----------------------------------------------------------------------

XNAME <begin::>

PROCNAME <SmoothSpan  PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL xlatAddr: dword
	LOCAL rAccum: dword
	LOCAL gAccum: dword
	LOCAL bAccum: dword
	LOCAL aAccum: dword
	LOCAL zAccum: dword
	LOCAL rDelta: dword
	LOCAL gDelta: dword
	LOCAL bDelta: dword
	LOCAL aDelta: dword
	LOCAL zDelta: dword

	; all this copying is needed for multi-threaded operation.  We could
	; optimize for color-index...

	mov	esi, GLCONTEXT
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_r
	mov	rAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_g
	mov	gAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_b
	mov	bAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_a
	mov	aAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_z
	mov	zAccum, eax

	mov	ebx, [esi].GENCTX_pPrivateArea
	mov	ebx, [ebx]
	mov	eax, [ebx].SPANREC_r
	mov	rDelta, eax
	mov	eax, [ebx].SPANREC_g
	mov	gDelta, eax
	mov	eax, [ebx].SPANREC_b
	mov	bDelta, eax
	mov	eax, [ebx].SPANREC_a
	mov	aDelta, eax
	mov	eax, [ebx].SPANREC_z
	mov	zDelta, eax


	mov	edi, [esi].GENCTX_ColorsBits
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_cfb
	test	dword ptr [edx].BUF_other, DIB_FORMAT
	je	@no_dib
	mov	edi, [edx].BUF_base
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	sub	eax, [esi].CTX_constants.CTXCONST_viewportYAdjust
	add	eax, [edx].BUF_yOrigin
	mov	ebx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	sub	ebx, [esi].CTX_constants.CTXCONST_viewportXAdjust
	add	ebx, [edx].BUF_xOrigin
	mul	dword ptr [edx].BUF_outerWidth
XNAME <bpp::>
	shl	ebx, 2
	add	eax, ebx
	add	edi, eax
@no_dib:
	mov	eax, [esi].GENCTX_pajTranslateVector
if RGBMODE eq 0
XNAME <cixlat_ofs::>
	add	eax, GLintSize		; for color-index modes, the first
endif					; entry is the # of entries!
	mov	xlatAddr, eax
					; calculate dither values for span
if DITHER
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	and	edx, 03h
	shl	edx, 2
	mov	edx, Dither_4x4[edx]
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	and	ecx, 03h
	shl	ecx, 3
	ror	edx, cl		;edx has x-aligned dither entries for span
endif
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	cmp	ecx, 0
	jle	@fastSpanDone
				;esi now points to z-buffer
	mov	esi, [esi].CTX_polygon.POLY_shader.SHADE_zbuf
if DITHER eq 0
	mov	edx, zAccum	
endif

if RGBMODE eq 0
	mov	ebx, rAccum	
endif


;; start of z-buffer/color-interpolation loop

	;;ztest-pass case

align 4
@ztest_pass:
XNAME <ztest_begin::>

if DITHER
	mov	eax, zAccum		; perform z test
	cmp	eax, [esi]
else
	cmp	edx, [esi]
endif

XNAME <ztest_pass::>				; check condition
	jae	near ptr @ztest_fail_cont

@ztest_pass_cont:				; test passed->write the z value
XNAME <zwrite::>
	mov	[esi],eax

if DITHER					; increment z interpolation
	add	eax, zDelta		; and address
	mov	zAccum, eax
else
	add	edx, zDelta
endif
	add	esi, __GLzValueSize	

XNAME <ztest_end::>


if RGBMODE ;>>>>>>>>>>>>>>>> RGBMODE RGB case

;; Red component (r bits)			; calculate color value for RGB

	mov	eax, rAccum
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <rmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <rshift::>
	shl	eax, 0
	mov	ebx, eax


;; Green component (g bits)

	mov	eax, gAccum
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <gmax::>
	mov	al, 0111111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <gshift::>
	shl	eax, 5
	or	ebx, eax


;; Blue component (b bits)

	mov	eax, bAccum
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <bmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <bshift::>
	shl	eax, 11
	or	ebx, eax

	xchg	ebx, eax
	mov	ebx, xlatAddr		;translate to physical color
XNAME <xlat::>
	xlatb


else ;>>>>>>>>>>>>>>>> RGBMODE color-index case


;; Red component (r bits)		; calculate color value for indexed
					; mode
	mov	eax, ebx
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <cixlat_shift::>
	shl	eax, 2			; 4 or 1 bytes/entry
	add	eax, xlatAddr
	mov	eax, [eax]

endif  ;<<<<<<<<<<<<<<<< end RGBMODE cases


XNAME <write_pix::>			; write the color value
	mov	[edi], ax
XNAME <dest_inc1::>
	add	edi, 2

if DITHER				; increment color values, dither
	ror	edx, 8
endif
if RGBMODE
	mov	ebx, rDelta
	add	rAccum, ebx
	mov	ebx, gDelta
	add	gAccum, ebx
	mov	ebx, bDelta
	add	bAccum, ebx
else
	add	ebx, rDelta
endif

	dec	ecx
XNAME <ztest_jmp::>
	jg	near ptr @ztest_pass
	jmp	short @fastSpanDone


	;;ztest-fail case
	;; not much to do here except advance interpolation values
align 4
@ztest_fail:
if DITHER
	cmp	eax, [esi]			; perform z test
else
	cmp	edx, [esi]
endif
XNAME <ztest_fail::>
	jb	near ptr @ztest_pass_cont	; check condition
@ztest_fail_cont:
if DITHER
	add	eax, zDelta		; increment z interpolator
else
	add	edx, zDelta
endif
	add	esi, __GLzValueSize
if RGBMODE
	mov	ebx, rDelta		; increment color interpolators
	add	rAccum, ebx
	mov	ebx, gDelta
	add	gAccum, ebx
	mov	ebx, bDelta
	add	bAccum, ebx
else
	add	ebx, rDelta
endif
XNAME <dest_inc2::>
	add	edi, 2
if DITHER
	ror	edx, 8
endif
	dec	ecx
	jg	short @ztest_fail

@fastSpanDone:
	ret

PROCNAME <SmoothSpan  ENDP>

XNAME <end::>



;----------------------------------------------------------------------
; __fastxxxSmoothSpanSetup(GLCONTEXT *)
;
; Copy the span routine from the template and modify it to reflect
; the current state.
;----------------------------------------------------------------------

 
PROCNAME <SmoothSpanSetup  PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL funcAddr: dword

	COPYPROC

	mov	esi, GLCONTEXT
	mov	edx, [esi].CTX_drawBuffer

;; bytes/pixel adjustment (shifts)

	mov	al, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	al, 7
	shr	al, 4
	XOFS	bpp
	mov	[edi]+2, al

;; z-test conditions

	mov	eax, [esi].CTX_state.ATTR_depth.DEPTH_testFunc
	and	eax, 3
	mov	ebx, eax
	shl	ebx, 2
	shl	eax, 1
	add	ebx, eax	; 6 bytes/jump

	;; z-test pass condition
	
	mov	ax, word ptr ztest_pass_functions[ebx]
	XOFS	ztest_pass
	mov	[edi], ax

	;; z-test fail condition

	mov	ax, word ptr ztest_fail_functions[ebx]
	XOFS	ztest_fail
	mov	[edi], ax


	;; z write-enable

	test  	dword ptr [esi].CTX_state.ATTR_depth.DEPTH_writeEnable, 1
	jne	@zwriteEnabled

	XOFS	zwrite
	mov	byte ptr [edi], NOP_CODE
	mov	byte ptr [edi]+1, NOP_CODE

@zwriteEnabled:

if RGBMODE

	;; blue max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_blueMax
	XOFS	bmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iBlueShift
	XOFS	bshift
	mov	[edi]+2, al
	

	;; green max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_greenMax
	XOFS	gmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iGreenShift
	XOFS	gshift
	mov	[edi]+2, al
	

	;; red max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_redMax
	XOFS	rmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iRedShift
	XOFS	rshift
	mov	[edi]+2, al

	
	;; color-translation

	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	je	@doTranslate

	XOFS	xlat
	mov	byte ptr [edi], NOP_CODE

@doTranslate:
else ;>>>>>>>>>>>>>>>> color-index case
			; no offset or address-shift needed for 8-bit color
	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	jg	@longXlat		; for 8-bit CI mode
	XOFS	cixlat_ofs
	mov	byte ptr [edi]+2, 0
	XOFS	cixlat_shift
	mov	byte ptr [edi]+2, 0
@longXlat:
endif ;>>>>>>>>>>>>>>>> end RGB cases

	;; pixel-write

	xor	ebx, ebx
	mov	bl, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	bl, 7
	shr	bl, 3
	mov	ecx, ebx
	and	ebx, 0eh
	shl	ebx, 1
	mov	ax, word ptr write_pixel_ops[ebx]
	XOFS	write_pix
	mov	[edi], ax
	mov	al, byte ptr write_pixel_ops[ebx+2]
	mov	[edi]+2, al

	;; destination-offset increment

	XOFS	dest_inc1
	mov	[edi]+2, cl
	XOFS	dest_inc2
	mov	[edi]+2, cl

	;; z-buffer enable

	test	dword ptr [esi].CTX_polygon.POLY_shader.SHADE_modeFlags,__GL_SHADE_DEPTH_TEST
	jne	@depthTestEnabled

	XOFS	ztest_end
	mov	eax, edi
	XOFS	ztest_begin
	sub	eax, edi	
	mov	ebx, eax

	;if z-buffer is not enabled so jump around initial z test...

	XOFS	ztest_begin
	mov	[edi], JMP_CODE
	sub	bl, 2		;account for instruction encoding
	add	[edi]+1, bl

	;and continue to loop "under" z test

	XOFS	ztest_jmp
	add	[edi]+2, eax
@depthTestEnabled:
	ret

align 4
write_pixel_ops:		
write_pix_byte:			
	mov	[edi], al
	nop
	nop
write_pix_word:	
	mov	[edi], ax
	nop
write_pix_dword:	
	mov	[edi], eax
	nop
	nop

PROCNAME <SmoothSpanSetup  ENDP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\texspanr.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: texspanr.asm
;
; Fast replace-mode texturing. 
;
; Created: 011/15/1995
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;


rMask = ((1 SHL rBits) - 1) SHL rShift
gMask = ((1 SHL gBits) - 1) SHL gShift
bMask = ((1 SHL bBits) - 1) SHL bShift

rRightShiftAdj	= 16 - (rShift + rBits)
gRightShiftAdj	= 16 - (gShift + gBits)
bRightShiftAdj	= 16 - (bShift + bBits)

TMASK_SUBDIV equ [esi].GENGC_tMaskSubDiv
TSHIFT_SUBDIV equ [esi].GENGC_tShiftSubDiv

if FAST_REPLACE
    TEXPALETTE equ [esi].GENGC_texImageReplace
    if (PALETTE_ONLY)
        TEXIMAGE equ [esi].GENGC_texImage
    else
        TEXIMAGE equ [esi].GENGC_texImageReplace
    endif
    if PALETTE_ONLY
        TEX_BPP_LOG2 = 0
    elseif (BPP eq 8)
        TEX_BPP_LOG2 = 0
    else
        TEX_BPP_LOG2 = 1
    endif
else

.error

endif

if PALETTE_ONLY

HANDLE_PALETTE MACRO
mov	bl, [edx]				; V
and	ebx, 0ffh				;U
mov	edx, TEXPALETTE				; V
lea	edx, [edx+4*ebx]			;U
ENDM


HANDLE_PALETTEX MACRO
mov	al, [edx]				; V
and	eax, 0ffh				;U
mov	ebx, TEXPALETTE				; V
mov	edx, TEMP2				;U
lea	ebx, [ebx+4*eax]			; V
mov	TEMP2, edx				;U
GET_TEXEL_ACCUM					; V
						;U
ENDM

else

HANDLE_PALETTE MACRO
ENDM

endif

TEMP	equ [esi].GENGC_sResult

;;
;;
;; Macros for advancing a single pixel unit
;;
;;


if (BPP eq 8)
PIXADVANCE MACRO var
inc	var
ENDM
elseif (BPP eq 16)
PIXADVANCE MACRO var
add	var, (BPP / 8)
ENDM
else
PIXADVANCE MACRO var
add	var, [esi].GENGC_bytesPerPixel
ENDM
endif

;;
;; Get pointer to current texel value in EDX:
;;

GET_TEXEL_ADDRESS MACRO

mov     eax, TMASK_SUBDIV                       ;U
mov     edx, [esi].GENGC_tResult                ; V
mov     ebx, [esi].GENGC_sResult                ;U
and     edx, eax                                ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
mov     ecx, [esi].GENGC_sMask                  ; V
and     ebx, ecx                                ;U
mov	eax, DWORD PTR [esi].GENGC_sResult      ; V
shr     ebx, (16-TEX_BPP_LOG2)                  ;U
mov	ecx, [esi].GENGC_subDs                  ; V
add	eax, ecx				;U
add     edx, ebx			        ; V
mov     ecx, TEXIMAGE                           ;U
mov	ebx, [esi].GENGC_subDt                  ; V
add     edx, ecx                                ;U
mov	ecx, DWORD PTR [esi].GENGC_tResult      ; V
add	ecx, ebx				;U
mov     DWORD PTR [esi].GENGC_sResult, eax      ; V
mov     DWORD PTR [esi].GENGC_tResult, ecx      ;U
HANDLE_PALETTE

ENDM

if (BPP eq 8)
GET_TEXEL MACRO
mov	al, [edx]				; V get texel value
ENDM
elseif (BPP eq 16)
GET_TEXEL MACRO
mov	ax, [edx]
ENDM
endif


GET_TEXEL_ADDRESS2 MACRO count

;; input : ecx = GENGC_tResult, edi = GENGC_sResult
;; output: edx = final texel address
;; free  : ebx, edx are free

mov     ebx, TMASK_SUBDIV			;U
mov     edx, ecx				; V
mov	TEMP, eax				;U
and     edx, ebx                                ; V
mov	eax, edi				;U
mov	ebx, [esi].GENGC_sMask                  ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
and	eax, ebx				; V
shr	eax, (16-TEX_BPP_LOG2)			;U
mov	ebx, TEXIMAGE				; V
add     edx, eax			        ;U
mov	eax, [esi].GENGC_subDs			; V
add	edx, ebx				;U
add	edi, eax				; V
mov	ebx, [esi].GENGC_subDt			;U
mov	eax, TEMP				; V
add	ecx, ebx				;U
HANDLE_PALETTE

ENDM

if (BPP eq 8)
GET_TEXEL_ACCUM MACRO
mov	al, [edx]				; V get texel value
ror	eax, BPP				;U
ENDM
elseif (BPP eq 16)
GET_TEXEL_ACCUM MACRO
mov	ax, [edx]
ror	eax, BPP
ENDM
endif


if (BPP eq 8)
WRITE_TEXEL_DECEBP MACRO
mov	al, [edx]
dec	ebp
mov	[edi-1], al
ENDM
elseif (BPP eq 16)
WRITE_TEXEL_DECEBP MACRO
mov	ax, [edx]
dec	ebp
mov	[edi-2], ax
ENDM
endif



;;----------------------------------------------------------------------
;;
;; This is the start of the texture routine.  Kick off the divide, and use
;; the dead time to set up all of the accumulators and other variables.
;;
;;----------------------------------------------------------------------

;;
;; Start the divide:
;;

mov	eax, [ecx].GENGC_flags
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum qwAccum
test	eax, GEN_TEXTURE_ORTHO
jne	@f
  fdivr	__One			                        ;1/qw qwAccum
@@:

;;
;; Save the registers that we need to:
;;

push	ebx						;U
push	esi						; V
push	edi						;U
push	ebp						; V

mov	esi, ecx					;U

;;
;; Set up accumulators:
;;

mov     eax, [ecx].GENGC_SPAN_s				; V
mov     ebx, [ecx].GENGC_SPAN_t				;U
mov     [ecx].GENGC_sAccum, eax				; V
mov     [esi].GENGC_tAccum, ebx				;U
mov     ecx, [esi].GENGC_SPAN_qw                        ; V
mov	edi, [esi].GENGC_SPAN_ppix			;U
mov     [esi].GENGC_qwAccum, ecx			; V
mov	eax, [esi].GENGC_flags                          ;U
mov	ebx, [esi].GENGC_SPAN_x				; V
test	eax, SURFACE_TYPE_DIB		                ;U
jne	@f						; V
mov	edi, [esi].GENGC_ColorsBits			;U
jmp	short @pixAccumDone
@@:
if (BPP eq 8)
add	edi, ebx                                        ; V
elseif (BPP eq 16)
lea	edi, [edi + 2*ebx]
endif

@pixAccumDone:

mov	ebp, [esi].GENGC_SPAN_length			;U

;;
;; Before we get into the main loop, do pixel-by-pixel writes until
;; we're DWORD aligned:
;;

test	edi, 3
je	alignmentDone

getAligned:

test    eax, GEN_TEXTURE_ORTHO
je      @f

mov     edx, [esi].GENGC_sAccum
mov     eax, [esi].GENGC_tAccum
mov     DWORD PTR [esi].GENGC_sResult, edx
mov     DWORD PTR [esi].GENGC_tResult, eax
jmp     short @stResultDone1

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResult	; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResult	; qwAccum
  fadd	DWORD PTR [esi].GENGC_SPAN_dqwdx; qwAccum
  fld	ST(0)				; qwAccum qwAccum
  fdivr	__One			        ; 1/qw qwAccum

@stResultDone1:

mov	cl, TSHIFT_SUBDIV       		;U
mov	edx, [esi].GENGC_tResult		; V
sar	edx, cl					;UV (4)
and	edx, NOT 7				;U
mov     ebx, [esi].GENGC_sResult        	; V
mov	[esi].GENGC_tResult, edx		;U
and     edx, TMASK_SUBDIV                       ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
and     ebx, [esi].GENGC_sMask                  ; V
shr     ebx, (16-TEX_BPP_LOG2)                  ;U
mov	ecx, TEXIMAGE				; V
add     edx, ecx    	                        ;U
PIXADVANCE edi					; V
add     edx, ebx			        ;U
HANDLE_PALETTE


mov	eax, [esi].GENGC_sAccum			; V
mov	ebx, [esi].GENGC_tAccum			;U
add	eax, [esi].GENGC_SPAN_ds		; V
add	ebx, [esi].GENGC_SPAN_dt		;U
mov	[esi].GENGC_sAccum, eax			; V
mov	[esi].GENGC_tAccum, ebx			;U

WRITE_TEXEL_DECEBP

jle	spanExit			; V
test	edi, 3
mov     eax, [esi].GENGC_flags
jne	getAligned

alignmentDone:

;;
;; Kick off the next divide:
;;

test    eax, GEN_TEXTURE_ORTHO
je      @f

mov     edx, [esi].GENGC_sAccum
mov     eax, [esi].GENGC_tAccum
mov     DWORD PTR [esi].GENGC_sResult, edx
mov     DWORD PTR [esi].GENGC_tResult, eax
jmp     short @stResultDone2

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResult	; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResult	; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum
  fld	ST(0)				; qwAccum qwAccum
  fdivr	__One			        ; 1/qw qwAccum

@stResultDone2:

mov	eax, [esi].GENGC_sAccum				; V
mov	ebx, [esi].GENGC_tAccum				;U
add	eax, [esi].GENGC_sStepX				; V
add	ebx, [esi].GENGC_tStepX				;U
mov	[esi].GENGC_sAccum, eax				; V
mov	[esi].GENGC_tAccum, ebx				;U
mov	eax, [esi].GENGC_sResult			; V
mov	ebx, [esi].GENGC_tResult			;U
mov	cl, TSHIFT_SUBDIV       			; V
sar	ebx, cl						;UV (4)
and	ebx, NOT 7					;U
mov     ecx, [esi].GENGC_flags                     	; V
mov	[esi].GENGC_tResult, ebx			;U
test    ecx, GEN_TEXTURE_ORTHO                          ; V
je      @f

mov     ecx, [esi].GENGC_sAccum
mov     edx, [esi].GENGC_tAccum
mov     DWORD PTR [esi].GENGC_sResultNew, ecx
mov     DWORD PTR [esi].GENGC_tResultNew, edx
jmp     short @stResultDone3


;; We may have to burn some cycles here...

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum

@stResultDone3:

mov	cl, TSHIFT_SUBDIV       			;U
mov	edx, [esi].GENGC_tResultNew			; V
sar	edx, cl						;UV (4)
and	edx, NOT 7					;U
mov	ecx, [esi].GENGC_sResultNew			; V
mov	[esi].GENGC_tResultNew, edx			;U
sub	ecx, eax					; V
sar	ecx, 3						;U
sub	edx, ebx					; V
sar	edx, 3						;U
mov	[esi].GENGC_subDs, ecx				; V
mov	[esi].GENGC_subDt, edx				;U

;;
;; 
;;

;; If we have fewer than 4 (or 2) pixels, just do right edge...

if (BPP eq 8)
test	ebp, 0fffch			;U
else
test	ebp, 0fffeh			;U
endif
je	singlePixels

add	ebp, 070000h

mov	[esi].GENGC_pixAccum, edi
mov	ecx, [esi].GENGC_tResult
mov	eax, [esi].GENGC_flags
mov	edi, [esi].GENGC_sResult

loopTop:

;;
;; This is the start of the outer loop.  We come back here on each
;; subdivision.  The key thing is to kick off the next divide:
;;

test	eax, GEN_TEXTURE_ORTHO
jne	@f

  fld	ST(0)				; qwAccum qwAccum    
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum+ qwAccum
  fxch	ST(1)				; qwAccum qwAccum+
  fdivr	__One				; 1/qw qwAccum+  -- let the divide rip!

@@:

loopTopNoDiv:

;; If we have fewer than 4 (or 2) pixels, just do right edge...

if (BPP eq 8)

GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
mov	ebx, [esi].GENGC_pixAccum	; V
add	ebx, 4				;U
GET_TEXEL_ACCUM				; V
					;U
sub	ebp, 040004h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	[ebx-4], eax			; V

else

GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
mov	ebx, [esi].GENGC_pixAccum
add	ebx, 4
GET_TEXEL_ACCUM
sub	ebp, 020002h
mov	[esi].GENGC_pixAccum, ebx
mov	[ebx-4], eax

endif


jle	doSubDiv			;U
if (BPP eq 8)
test	ebp, 0fffch			; V
else
test	ebp, 0fffeh
endif
je	doRightEdgePixels		;U
jmp	loopTopNoDiv                    ; V


doRightEdgePixels:

test	ebp, 0ffffh			; V
je	spanExit			;U

mov	[esi].GENGC_sResult, edi
mov	[esi].GENGC_tResult, ecx
mov	edi, [esi].GENGC_pixAccum

rightEdgePixels:

PIXADVANCE edi				;U

GET_TEXEL_ADDRESS
GET_TEXEL

if (BPP eq 8)
sub	ebp, 010001h			;U
mov	[edi-1], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edi-2], ax
endif

test	ebp, 0ffffh			;U
jne	rightEdgePixels			; V

;;
;; This is the exit point.  We need to pop the unused floating-point
;; registers off the stack, and return:
;;

spanExit:

fstp	ST(0)
fstp	ST(0)

pop	ebp
pop	edi
pop	esi
pop	ebx

ret	0


singlePixels:

PIXADVANCE edi				;U

GET_TEXEL_ADDRESS
GET_TEXEL

dec	ebp

if (BPP eq 8)
mov	[edi-1], al			; V
elseif (BPP eq 16)
mov	[edi-2], ax
endif

jg	singlePixels			; V

;;
;; This is the exit point.  We need to pop the unused floating-point
;; registers off the stack, and return:
;;

fstp	ST(0)
mov	eax, [esi].GENGC_flags
pop	ebp
pop	edi
pop	esi
pop	ebx
test	eax, GEN_TEXTURE_ORTHO
je	@f
fstp	ST(0)
@@:

ret	0



;;
;; This is the subdivision code.  After the required number of steps, the
;; routine will jump here to calculate the next set of interpolants based
;; on subdivision:
;;

doSubDiv:

add	ebp, 080000h

mov	eax, [esi].GENGC_sAccum

if (BPP eq 8)
test	ebp, 0fffch			; V
else
test	ebp, 0fffeh
endif
je	doRightEdgePixels		;U

test	ebp, 0ffffh
je	spanExit

mov	ecx, [esi].GENGC_flags

mov	ebx, [esi].GENGC_tAccum

;;
;; Increment the big S and T steps:
;;

add	eax, [esi].GENGC_sStepX
add	ebx, [esi].GENGC_tStepX
mov	[esi].GENGC_sAccum, eax
mov	[esi].GENGC_tAccum, ebx
mov	edi, [esi].GENGC_sResultNew
mov	ebx, [esi].GENGC_tResultNew

test	ecx, GEN_TEXTURE_ORTHO
je	@f

;;
;; Handle ortho case (easy)
;;

mov	edx, DWORD PTR [esi].GENGC_tAccum
mov	DWORD PTR [esi].GENGC_sResultNew, eax
mov	DWORD PTR [esi].GENGC_tResultNew, edx
jmp	short @stResultDone4

;;
;; Do the floating-point computation for perspective:
;;

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum

@stResultDone4:

;;
;; Now, calculate the per-pixel deltas:
;;

mov	cl, TSHIFT_SUBDIV       	;U
mov	edx, [esi].GENGC_tResultNew	; V
sar	edx, cl				;UV (4)
mov	ecx, [esi].GENGC_sResultNew	;U
and	edx, NOT 7			; V
sub	ecx, edi			;U
mov	[esi].GENGC_tResultNew, edx	; V
sar	ecx, 3				;U
sub	edx, ebx			; V
sar	edx, 3				;U
mov	[esi].GENGC_subDs, ecx		; V
mov	[esi].GENGC_subDt, edx		;U
mov	ecx, ebx			; V
mov	eax, [esi].GENGC_flags		;U
jmp	loopTop                         ; V
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\texspans.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: texspans.asm
;
; Generator file for texture routines. 
;
; Created: 011/15/1995
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;

        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc

	.data

extrn	_gbMulTable:BYTE

__One	dd	__FLOAT_ONE

dither0 dd 	0a8288808h
dither1 dd	068e848c8h
dither2	dd	09818b838h
dither3	dd	058d878f8h

rBits 		= 3
gBits 		= 3
bBits 		= 2

rShift		= 0
gShift		= 3
bShift		= 6


FAST_REPLACE = 0
REPLACE = 0
FLAT_SHADING = 0
SMOOTH_SHADING = 0

ALPHA = 0
ZBUFFER = 0
ZCMP_L = 0

.code

PROCSTART	MACRO	base, subset
	public @&base&subset&@4
@&base&subset&@4 PROC
	PROF_ENTRY
ENDM

PROCEND	MACRO	base, subset
@&base&subset&@4 ENDP
ENDM

PALETTE_ENABLED = 0
PALETTE_ONLY = 0


;;----------------------------------------------------------------------
;;
;; FAST REPLACE MODES
;;
;;----------------------------------------------------------------------


FAST_REPLACE = 1

;;------------------------------
;; 8bpp 332 texture fast-replace
;;------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspReplace>,<332>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspReplace>,<332>

ZBUFFER = 1

PROCSTART <__fastFastPerspReplaceZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZle>,<332>

ZCMP_L = 1

PROCSTART <__fastFastPerspReplaceZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZlt>,<332>

;;-------------------------------
;; 16bpp 565 texture fast-replace
;;-------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspReplace>,<565>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspReplace>,<565>

ZBUFFER = 1

PROCSTART <__fastFastPerspReplaceZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZle>,<565>

ZCMP_L = 1

PROCSTART <__fastFastPerspReplaceZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZlt>,<565>

FAST_REPLACE = 0


;;----------------------------------------------------------------------
;;
;; REPLACE MODES - RGB(A)
;;
;;----------------------------------------------------------------------


REPLACE = 1

;;----------------------------
;; 8bpp 332 texture replace
;;----------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<332>

;;----------------------------
;; 16bpp 555 texture replace
;;----------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<555>


;;----------------------------
;; 16bpp 565 texture replace
;;----------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<565>


;;----------------------------
;; 32bpp 888 texture replace
;;----------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspReplace>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplace>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<888>

;;----------------------------------------------------------------------
;;
;; REPLACE MODES - PALETTE
;;
;;----------------------------------------------------------------------

PALETTE_ONLY = 1
FAST_REPLACE = 1

;;----------------------------------
;; 8bpp 332 texture replace, palette
;;----------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspPalReplace>,<332>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspPalReplace>,<332>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZle>,<332>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZlt>,<332>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastFastPerspPalReplaceAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZlt>,<332>

;;-----------------------------------
;; 16bpp 555 texture replace, palette
;;-----------------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastFastPerspPalReplaceAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZlt>,<555>


;;-----------------------------------
;; 16bpp 565 texture replace, palette
;;-----------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspPalReplace>,<565>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspPalReplace>,<565>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZle>,<565>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZlt>,<565>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastFastPerspPalReplaceAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZlt>,<565>

FAST_REPLACE = 0

;;-----------------------------------
;; 32bpp 888 texture replace, palette
;;-----------------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspPalReplace>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplace>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspPalReplaceZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspPalReplaceZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspPalReplaceAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspPalReplaceAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspPalReplaceAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceAlphaZlt>,<888>

PALETTE_ONLY = 0

REPLACE = 0


;; For all of the modes below, enable the palette path:


PALETTE_ENABLED = 1


;;----------------------------------------------------------------------
;;
;; FLAT-SHADING MODES
;;
;;----------------------------------------------------------------------


FLAT_SHADING = 1

;;------------------------------
;; 8bpp 332 texture flat-shading
;;------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<332>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<332>

;;-------------------------------
;; 16bpp 555 texture flat-shading
;;-------------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<555>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<555>


;;-------------------------------
;; 16bpp 565 texture flat-shading
;;-------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<565>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<565>


;;-------------------------------
;; 32bpp 888 texture flat-shading
;;-------------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<888>

FLAT_SHADING = 0






;;----------------------------------------------------------------------
;;
;; SMOOTH-SHADING MODES
;;
;;----------------------------------------------------------------------


SMOOTH_SHADING = 1

;;--------------------------------
;; 8bpp 332 texture smooth-shading
;;--------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<332>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<332>

;;---------------------------------
;; 16bpp 555 texture smooth-shading
;;---------------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<555>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<555>


;;---------------------------------
;; 16bpp 565 texture smooth-shading
;;---------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<565>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<565>


;;---------------------------------
;; 32bpp 888 texture smooth-shading
;;---------------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<888>

FLAT_SHADING = 0


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\texspan.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: texspan.asm
;
; Include file for "body" of texture routines. 
;
; Created: 011/15/1995
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;


rMask = ((1 SHL rBits) - 1) SHL rShift
gMask = ((1 SHL gBits) - 1) SHL gShift
bMask = ((1 SHL bBits) - 1) SHL bShift


if REPLACE

rRightShiftAdj	= 16 - (rShift + rBits)
gRightShiftAdj	= 16 - (gShift + gBits)
bRightShiftAdj	= 16 - (bShift + bBits)

else

rRightShiftAdj	= 16 - (rShift)
gRightShiftAdj	= 16 - (gShift)
bRightShiftAdj	= 16 - (bShift)

endif

TMASK_SUBDIV equ [esi].GENGC_tMaskSubDiv
TSHIFT_SUBDIV equ [esi].GENGC_tShiftSubDiv

if FAST_REPLACE
    TEXPALETTE equ [esi].GENGC_texImageReplace
    if (PALETTE_ONLY)
        TEXIMAGE equ [esi].GENGC_texImage
    else
        TEXIMAGE equ [esi].GENGC_texImageReplace
    endif
    if PALETTE_ONLY
        TEX_BPP_LOG2 = 0
    elseif (BPP eq 8)
        TEX_BPP_LOG2 = 0
    else
        TEX_BPP_LOG2 = 1
    endif
else
TEXPALETTE equ [esi].GENGC_texPalette
TEXIMAGE equ [esi].GENGC_texImage
if PALETTE_ONLY
    TEX_BPP_LOG2 = 0
else
    TEX_BPP_LOG2 = 2
endif
endif

;;
;;
;; Macros for alpha modulation, and alpha reads
;;
;;


ALPHAMODULATE MACRO

mov	ah, [esi].GENGC_aAccum+2
mov	al, [edx+3]
and	eax, 0ffffh
mov	ch, _gbMulTable[eax]
mov	[esi].GENGC_aDisplay, ch

ENDM


ALPHANOMODULATE MACRO

mov	ch, [edx+3]
mov	[esi].GENGC_aDisplay, ch

ENDM


;; There are AGIs and other nasties in the alpha-read code.  There's
;; not much we can really do, unfortunately...


if (BPP eq 8)

ALPHAREAD MACRO

xor	eax, eax
mov	al, [ebx]
mov	ebx, [esi].GENGC_pInvTranslateVector
mov	cl, 0ffh
mov	al, [ebx+eax]
mov	ebx, eax
and	ebx, rMask
sub	cl, ch 
shl	ebx, gBits + bBits
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_rDisplay, ch
and	ebx, gMask
shl	ebx, bBits
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_gDisplay, ch
and	ebx, bMask
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	[esi].GENGC_bDisplay, ch

ENDM

endif

if (BPP eq 16)

ALPHAREAD MACRO

mov	ax, [ebx]
mov	cl, 0ffh
mov	ebx, eax
and	ebx, rMask
sub	cl, ch
shr	ebx, rShift - (8 - rBits)
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_rDisplay, ch
and	ebx, gMask
shr	ebx, gShift - (8 - gBits)
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_gDisplay, ch
and	ebx, bMask
shl	ebx, (8 - bBits)
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	[esi].GENGC_bDisplay, ch

ENDM

elseif (BPP eq 32)

ALPHAREAD MACRO

xor	eax, eax
mov	cl, 0ffh
mov	al, [ebx+2]
sub	cl, ch
mov	ah, cl
mov	al, _gbMulTable[eax]
mov	[esi].GENGC_rDisplay, al
mov	al, [ebx+1]
mov	ah, cl
mov	al, _gbMulTable[eax]
mov	[esi].GENGC_gDisplay, al
mov	al, [ebx]
mov	ah, cl
mov	al, _gbMulTable[eax]
mov	[esi].GENGC_bDisplay, al

ENDM

endif


;;
;;
;; Macros for advancing a single pixel unit
;;
;;


if (BPP eq 8)
PIXADVANCE MACRO var
inc	var
ENDM
elseif (BPP eq 16)
PIXADVANCE MACRO var
add	var, (BPP / 8)
ENDM
else
PIXADVANCE MACRO var
add	var, [esi].GENGC_bytesPerPixel
ENDM
endif

if (BPP le 16)
PIXADVANCE2 MACRO var1, var2
lea	var1, [var2 + (BPP / 8)]
ENDM
else
PIXADVANCE2 MACRO var1, var2
mov	var1, var2
add	var1, [esi].GENGC_bytesPerPixel
ENDM
endif

;;
;;
;; Macros for advancing the accumulators if the z-buffer test fails:
;;
;;


if FAST_REPLACE

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
mov	ebx, [esi].GENGC_pixAccum	;U
add	edi, 2				; V
add	ecx, eax			;U
PIXADVANCE ebx				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_zAccum, ecx		; V
mov	[esi].GENGC_pixAccum, ebx	;U
jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V
jmp	spanExit
ENDM

elseif REPLACE

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
add	edi, 2				;U
add	ecx, eax			; V
mov	eax, [esi].GENGC_ditherAccum	;U
mov	ebx, [esi].GENGC_pixAccum	; V
ror	eax, 8				;U
mov	[esi].GENGC_zAccum, ecx		; V
PIXADVANCE ebx				;U
sub	ebp, 010001h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	[esi].GENGC_ditherAccum, eax	; V
jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit			; V
ENDM

elseif FLAT_SHADING

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
add	edi, 2				;U
add	ecx, eax			; V
mov	ebx, [esi].GENGC_pixAccum	;U
mov	eax, [esi].GENGC_ditherAccum	; V
mov	[esi].GENGC_zAccum, ecx		;U
PIXADVANCE ebx				; V
ror	eax, 8				;U
sub	ebp, 010001h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	[esi].GENGC_ditherAccum, eax	; V
jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit
ENDM

elseif SMOOTH_SHADING

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
add	edi, 2				;U
add	ecx, eax			; V
mov	eax, [esi].GENGC_rAccum		;U
mov	[esi].GENGC_zAccum, ecx		; V
mov	ebx, [esi].GENGC_SPAN_dr	;U
mov	ecx, [esi].GENGC_gAccum		; V
add	eax, ebx			;U
mov	edx, [esi].GENGC_SPAN_dg	; V
mov	[esi].GENGC_rAccum, eax		;U
add	ecx, edx			; V
mov	eax, [esi].GENGC_bAccum		;U
mov	ebx, [esi].GENGC_SPAN_db	; V
mov	[esi].GENGC_gAccum, ecx		;U
add	ebx, eax			; V
mov	eax, [esi].GENGC_ditherAccum	;U
mov	[esi].GENGC_bAccum, ebx		; V
ror	eax, 8				;U
if ALPHA
mov	ecx, [esi].GENGC_aAccum
endif
mov	ebx, [esi].GENGC_pixAccum	;U
if ALPHA
add	ecx, [esi].GENGC_SPAN_da
endif
PIXADVANCE ebx				;U
if ALPHA
mov	[esi].GENGC_aAccum, ecx
endif
mov	[esi].GENGC_pixAccum, ebx	; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_ditherAccum, eax	; V
jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit			; V
ENDM

endif

;;----------------------------------------------------------------------
;;
;; This is the start of the texture routine.  Kick off the divide, and use
;; the dead time to set up all of the accumulators and other variables.
;;
;;----------------------------------------------------------------------

ZBUFFER_EARLY_OUT = 1

if ZBUFFER
push	ebx						;U
push	esi						; V
push	edi						;U
push	ebp						; V

if ZBUFFER_EARLY_OUT

mov	edi, [ecx].GENGC_SPAN_zbuf			;U
mov	esi, [ecx].GENGC_SPAN_z				; V
mov	edx, [ecx].GENGC_SPAN_length			;U
mov	ebp, [ecx].GENGC_SPAN_dz	                ; V

@zLoop:

mov	ebx, esi			;U
mov	eax, [edi]			; V
shr	ebx, 16				;U
and	eax, 0ffffh			; V
cmp	ebx, eax			;U
if ZCMP_L
jl	@zFirstWrite			; V
else
jle	@zFirstWrite			; V
endif
add	edi, 2				;U
add	esi, ebp			; V
dec	edx				;U
jne	@zLoop				; V

pop	ebp
pop	edi
pop	esi
pop	ebx

ret	0

@zFirstWrite:

endif	;; ZBUFFER_EARLY_OUT

endif	;; ZBUFFER


;;
;; Start the divide:
;;
mov	eax, [ecx].GENGC_flags
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum qwAccum
test	eax, GEN_TEXTURE_ORTHO
jne	@f
  fdivr	__One			                        ;1/qw qwAccum
@@:

;;
;; Save the registers that we need to:
;;

if ZBUFFER
else
push	ebx						;U
push	esi						; V
push	edi						;U
push	ebp						; V
endif

mov	esi, ecx					;U

;;
;; Set up accumulators:
;;

if FAST_REPLACE

if ZBUFFER
mov     eax, [esi].GENGC_SPAN_z				; V
endif
mov     ebx, [esi].GENGC_SPAN_s				;U
mov     ecx, [esi].GENGC_SPAN_t				; V
if ZBUFFER
mov     [esi].GENGC_zAccum, eax				;U
endif
mov     [esi].GENGC_sAccum, ebx				; V
mov     [esi].GENGC_tAccum, ecx				;U
mov     ebx, [esi].GENGC_SPAN_qw                        ; V
mov	eax, [esi].GENGC_SPAN_y				;U
mov     [esi].GENGC_qwAccum, ebx			; V
mov	edx, [esi].GENGC_SPAN_ppix			;U
mov	edi, [esi].GENGC_flags				; V
mov	ebx, [esi].GENGC_SPAN_x				;U
test	edi, SURFACE_TYPE_DIB				; V
jne	@f						;U
mov	edx, [esi].GENGC_ColorsBits			; V
jmp	short @pixAccumDone
@@:
if (BPP eq 8)
add	edx, ebx                                        ;U
elseif (BPP eq 16)
lea	edx, [edx + 2*ebx]
else
lea	edx, [edx + 4*ebx]
cmp	[esi].GENGC_bpp, 32
je	@f
sub	edx, ebx
@@:
endif

@pixAccumDone:

test	edi, GEN_TEXTURE_ORTHO				; V
mov	ebp, [esi].GENGC_SPAN_length			;U
je	@f						; V

else


if REPLACE
else

;; Handle RGB accumulators

if FLAT_SHADING
mov     eax, [ecx].GENGC_SPAN_r                         ;U
mov     ebx, [ecx].GENGC_SPAN_g				; V
shr     eax, rBits                                      ;U
mov	ecx, [esi].GENGC_SPAN_b				; V
shr     ebx, gBits                                      ;U
and     eax, 0ff00h                                     ; V
shr     ecx, bBits                                      ;U
and     ebx, 0ff00h                                     ; V
and     ecx, 0ff00h                                     ;U
mov     [esi].GENGC_rAccum, eax				; V
mov	[esi].GENGC_gAccum, ebx				;U
mov	[esi].GENGC_bAccum, ecx				; V
else
mov     eax, [ecx].GENGC_SPAN_r                         ;U
mov     ebx, [ecx].GENGC_SPAN_g				; V
mov	ecx, [esi].GENGC_SPAN_b				;U
mov     [esi].GENGC_rAccum, eax				; V
mov	[esi].GENGC_gAccum, ebx				;U
mov	[esi].GENGC_bAccum, ecx				; V
endif	;; FLAT_SHADING

endif	;; NOT REPLACE

if ZBUFFER
mov     eax, [esi].GENGC_SPAN_z				; V
endif
mov     ebx, [esi].GENGC_SPAN_s				;U
mov     ecx, [esi].GENGC_SPAN_t				; V
if ZBUFFER
mov     [esi].GENGC_zAccum, eax				;U
endif
mov     [esi].GENGC_sAccum, ebx				; V
mov     [esi].GENGC_tAccum, ecx				;U
mov     ebx, [esi].GENGC_SPAN_qw                        ; V
mov	eax, [esi].GENGC_SPAN_y				;U
mov     [esi].GENGC_qwAccum, ebx			; V
and	eax, 03h					;U
mov	ecx, [esi].GENGC_SPAN_x				; V
lea	eax, [eax*4 + offset dither0]			;U
lea	ecx, [ecx*8]					; V
mov	edx, [esi].GENGC_SPAN_ppix			;U
mov	edi, [esi].GENGC_flags				; V
mov	ebx, [esi].GENGC_SPAN_x				;U
test	edi, SURFACE_TYPE_DIB				; V
jne	@f						;U
mov	edx, [esi].GENGC_ColorsBits			; V
jmp	short @pixAccumDone
@@:
if (BPP eq 8)
add	edx, ebx                                        ;U
elseif (BPP eq 16)
lea	edx, [edx + 2*ebx]
else
lea	edx, [edx + 4*ebx]
cmp	[esi].GENGC_bpp, 32
je	@f
sub	edx, ebx
@@:
endif

@pixAccumDone:

mov	eax, [eax]					; V
and	ecx, 018h					;U
test	edi, GEN_TEXTURE_ORTHO				; V
mov	ebp, [esi].GENGC_SPAN_length			;U
je	@f						; V

endif

mov	edi, [esi].GENGC_sAccum				; V
mov	ebx, [esi].GENGC_tAccum				;U
mov	DWORD PTR [esi].GENGC_sResult, edi		; V
mov	DWORD PTR [esi].GENGC_tResult, ebx		;U
mov	edi, [esi].GENGC_flags				; V
jmp	short @stResultDone1				;U

;;
;; Kick off the next divide:
;;

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResult	; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResult	; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum
  fld	ST(0)				; qwAccum qwAccum
  fdivr	__One			        ; 1/qw qwAccum

@stResultDone1:

ror	eax, cl						;UV (4)
add	ebp, 070000h					;U
mov	[esi].GENGC_ditherAccum, eax			; V
dec	ebp						;U
mov	[esi].GENGC_pixAccum, edx			; V
mov	eax, [esi].GENGC_sAccum				;U
mov	ebx, [esi].GENGC_tAccum				; V
add	eax, [esi].GENGC_sStepX				;U
add	ebx, [esi].GENGC_tStepX				; V
mov	[esi].GENGC_sAccum, eax				;U
mov	[esi].GENGC_tAccum, ebx				; V
mov	eax, [esi].GENGC_sResult			;U
mov	ebx, [esi].GENGC_tResult			; V
mov	cl, TSHIFT_SUBDIV       			;U
sar	ebx, cl						;UV (4)
and	ebx, NOT 7					;U

if ALPHA
mov	ecx, [esi].GENGC_SPAN_a
endif

test	edi, GEN_TEXTURE_ORTHO				; V
mov	[esi].GENGC_tResult, ebx			;U

if ALPHA
mov	[esi].GENGC_aAccum, ecx
endif

je	@f
mov	ecx, [esi].GENGC_sAccum				; V
mov	edx, [esi].GENGC_tAccum				;U
mov	DWORD PTR [esi].GENGC_sResultNew, ecx		; V
mov	DWORD PTR [esi].GENGC_tResultNew, edx		;U
jmp	short @stResultDone2				; V

@@:

;; We may have to burn some cycles here...

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum

@stResultDone2:

mov	cl, TSHIFT_SUBDIV       			;U
mov	edx, [esi].GENGC_tResultNew			; V
sar	edx, cl						;UV (4)
and	edx, NOT 7					;U
mov	ecx, [esi].GENGC_sResultNew			; V
mov	[esi].GENGC_tResultNew, edx			;U
sub	ecx, eax					; V
sar	ecx, 3						;U
sub	edx, ebx					; V
sar	edx, 3						;U
mov	[esi].GENGC_subDs, ecx				; V
mov	[esi].GENGC_subDt, edx				;U
mov	eax, [esi].GENGC_flags				; V
mov	edi, [esi].GENGC_SPAN_zbuf			;U

loopTop:

;;
;; This is the start of the outer loop.  We come back here on each
;; subdivision.  The key thing is to kick off the next divide:
;;

test	eax, GEN_TEXTURE_ORTHO				; V
jne	@f						;U

  fld	ST(0)				; qwAccum qwAccum    
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum+ qwAccum
  fxch	ST(1)				; qwAccum qwAccum+
  fdivr	__One				; 1/qw qwAccum+  -- let the divide rip!

@@:

loopTopNoDiv:

;;
;; This is the start of the inner loop.  This is where the pixel-level
;; work happens:
;;

;;
;; First, do z-buffering is enabled:
;;

if ZBUFFER

mov	eax, [edi]			;U
mov	ebx, [esi].GENGC_zAccum		; V
shr	ebx, 16				;U
and	eax, 0ffffh			; V
cmp	ebx, eax			;U
if ZCMP_L
jl	@zWrite				; V
else
jle	@zWrite				; V
endif

ZBUFFER_FAIL_ADVANCE

@zWrite:
mov	[edi], bx			;UV

endif  ;;ZBUFFER

;;
;; Now, get pointer to current texel value in EDX.  There are two cases,
;; one if there is a palette-lookup, and one if we index straight into
;; the texture.
;;


if PALETTE_ENABLED

mov     ecx, TEXPALETTE                         ;U
mov     eax, TMASK_SUBDIV                       ; V
test    ecx, ecx                                ;U
je      @noPalette				; V

mov     edx, [esi].GENGC_tResult                ; V
mov     ebx, [esi].GENGC_sResult                ;U
and     edx, eax                                ; V
mov     eax, [esi].GENGC_sMask                  ;U
and     ebx, eax	                        ; V
shr     edx, 6		                        ;U
mov     eax, DWORD PTR [esi].GENGC_sResult      ; V
shr     ebx, 16		                        ;U
mov     ecx, TEXIMAGE                           ; V
add     edx, ecx                                ;U
add     eax, [esi].GENGC_subDs                  ; V
mov     ecx, DWORD PTR [esi].GENGC_tResult      ;U
add     edx, ebx			        ; V
add     ecx, [esi].GENGC_subDt                  ;U
mov     DWORD PTR [esi].GENGC_sResult, eax      ; V
xor	eax, eax				;U
mov	ebx, TEXPALETTE         		; V
mov     DWORD PTR [esi].GENGC_tResult, ecx      ;U
mov	al, [edx]				; V
lea	edx, [ebx+4*eax]			;U
jmp	short @paletteDone                      ; V

@noPalette:

endif ;;PALETTE_ENABLED

mov     eax, TMASK_SUBDIV                       ;U
mov     edx, [esi].GENGC_tResult                ; V
mov     ebx, [esi].GENGC_sResult                ;U
and     edx, eax                                ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
mov     ecx, [esi].GENGC_sMask                  ; V
and     ebx, ecx                                ;U
mov	eax, DWORD PTR [esi].GENGC_sResult      ; V
shr     ebx, (16-TEX_BPP_LOG2)                  ;U
mov	ecx, [esi].GENGC_subDs                  ; V
add	eax, ecx				;U
add     edx, ebx			        ; V
mov     ecx, TEXIMAGE                           ;U
mov	ebx, [esi].GENGC_subDt                  ; V
add     edx, ecx                                ;U
mov	ecx, DWORD PTR [esi].GENGC_tResult      ; V
add	ecx, ebx				;U
mov     DWORD PTR [esi].GENGC_sResult, eax      ; V
mov     DWORD PTR [esi].GENGC_tResult, ecx      ;U

if (PALETTE_ONLY)
mov	al, [edx]				; V
and	eax, 0ffh				;U
mov	ebx, TEXPALETTE         		; V
lea	edx, [ebx+4*eax]			;U
endif


@paletteDone:


;;
;; We are now ready to handle each of the 4 basic modes on a case-by-case
;; basis.  We will generally try to adhere to the following register
;; usage:
;;	eax - red
;;	ebx - green
;;	ecx - blue
;;	ebx, edx - framebuffer pointers
;;

if FAST_REPLACE

;;----------------------------------------------------------------------
;;
;; ** Replace mode (compressed)
;;
;;----------------------------------------------------------------------


if ALPHA

cmp	BYTE PTR [edx+3], 0ffh		;U
je	@noAlpha			; V
mov	ebx, [esi].GENGC_pixAccum	;U	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		; V
jne	@alphaRead			;U

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		;U
	add	edi, 2				; V
	add	ecx, [esi].GENGC_SPAN_dz	;U
endif

PIXADVANCE ebx					;U

if ZBUFFER
	mov	[esi].GENGC_zAccum, ecx		;U
endif

ror	eax, 8				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_pixAccum, ebx	; V
mov	[esi].GENGC_ditherAccum, eax	;U

;; Finish incrementing all of our accumulators

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

@alphaRead:

;;
;; Get pixel value and calculate total effect with alpha
;;

;; To make this easy on ourselves, we'll use the uncompressed palette
;; to do the alpha modulation:


ALPHANOMODULATE
sub	edx, [esi].GENGC_texImageReplace
add	edx, [esi].GENGC_texPalette
ALPHAREAD

mov	al, [edx+2]			;U get texel value
mov	ah, [esi].GENGC_aDisplay
mov	bl, [edx+1]			;U
mov	bh, [esi].GENGC_aDisplay
mov	cl, [edx]			; V
mov	ch, [esi].GENGC_aDisplay
and	eax, 0ffffh
and	ebx, 0ffffh
and	ecx, 0ffffh
mov	ah, _gbMulTable[eax]
mov	bh, _gbMulTable[ebx]
mov	ch, _gbMulTable[ecx]
add	ah, [esi].GENGC_rDisplay
add	bh, [esi].GENGC_gDisplay
add	ch, [esi].GENGC_bDisplay

if (BPP eq 32)
shl	eax, -rRightShiftAdj
else
shr	eax, rRightShiftAdj		;U
endif
mov	edx, [esi].GENGC_pixAccum	; V
shr	ebx, gRightShiftAdj		;U
and	eax, rMask			; V
shr	ecx, bRightShiftAdj		;U
and	ebx, gMask			; V
and	ecx, bMask			;U
or	eax, ebx			; V
or	eax, ecx			;U
PIXADVANCE2 ebx, edx			; V

if ZBUFFER
mov	ecx, [esi].GENGC_zAccum		; V
add	edi, 2				;U
add	ecx, [esi].GENGC_SPAN_dz	; V
endif

mov	[esi].GENGC_pixAccum, ebx	;U

if ZBUFFER
mov	[esi].GENGC_zAccum, ecx		;U
endif

if (BPP eq 8)
sub	ebp, 010001h			; V
mov	al, [esi].GENGC_xlatPalette[eax];U	;; AGI without z-buffering
mov	[edx], al			;U
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], ax
else
mov	[edx], ax
shr	eax, 16
sub	ebp, 010001h
mov	[edx+2], al
endif

;; Finish the loop:

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

endif  ;;ALPHA

@noAlpha:

mov	ebx, [esi].GENGC_pixAccum	;U

if (BPP eq 8)
mov	al, [edx]			; V get texel value
elseif (BPP eq 16)
mov	ax, [edx]
else
mov	eax, [edx]
endif

PIXADVANCE2 ecx, ebx			;U

if ZBUFFER
	mov	edx, [esi].GENGC_zAccum		; V
	add	edi, 2				;U
	add	edx, [esi].GENGC_SPAN_dz	; V
	mov	[esi].GENGC_zAccum, edx		;U
endif

mov	[esi].GENGC_pixAccum, ecx	; V

if (BPP eq 8)
sub	ebp, 010001h			;U
mov	[ebx], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[ebx], ax
else
mov	[ebx], ax
shr	eax, 16
sub	ebp, 010001h
mov	[ebx+2], al
endif

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U

jmp	spanExit

elseif REPLACE


;;----------------------------------------------------------------------
;;
;; ** Replace mode (non-compressed)
;;
;;----------------------------------------------------------------------

if ALPHA

cmp	BYTE PTR [edx+3], 0ffh		;U
je	@noAlpha			; V
mov	ebx, [esi].GENGC_pixAccum	;U	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		; V
jne	@alphaRead			;U

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		;U
	add	edi, 2				; V
	add	ecx, [esi].GENGC_SPAN_dz	;U
endif

mov	eax, [esi].GENGC_ditherAccum	; V

if ZBUFFER
	mov	[esi].GENGC_zAccum, ecx		;U
endif

PIXADVANCE ebx				;U
ror	eax, 8				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_pixAccum, ebx	; V
mov	[esi].GENGC_ditherAccum, eax	;U

;; Finish incrementing all of our accumulators

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

@alphaRead:

;;
;; Get pixel value and calculate total effect with alpha
;;

ALPHANOMODULATE
ALPHAREAD

mov	al, [edx+2]			;U get texel value
mov	ah, [esi].GENGC_aDisplay
mov	bl, [edx+1]			;U
mov	bh, [esi].GENGC_aDisplay
mov	cl, [edx]			; V
mov	ch, [esi].GENGC_aDisplay
and	eax, 0ffffh
and	ebx, 0ffffh
and	ecx, 0ffffh
mov	ah, _gbMulTable[eax]
mov	bh, _gbMulTable[ebx]
mov	ch, _gbMulTable[ecx]
add	ah, [esi].GENGC_rDisplay
add	bh, [esi].GENGC_gDisplay
add	ch, [esi].GENGC_bDisplay

if (BPP eq 32)
shl	eax, -rRightShiftAdj
else
shr	eax, rRightShiftAdj		;U
endif
mov	edx, [esi].GENGC_pixAccum	; V
shr	ebx, gRightShiftAdj		;U
and	eax, rMask			; V
shr	ecx, bRightShiftAdj		;U
and	ebx, gMask			; V
and	ecx, bMask			;U
or	eax, ebx			; V
or	eax, ecx			;U
PIXADVANCE2 ebx, edx			; V

if ZBUFFER
mov	ecx, [esi].GENGC_zAccum		; V
add	edi, 2				;U
add	ecx, [esi].GENGC_SPAN_dz	; V
endif

mov	[esi].GENGC_pixAccum, ebx	;U

if ZBUFFER
mov	[esi].GENGC_zAccum, ecx		;U
endif

if (BPP eq 8)
sub	ebp, 010001h			; V
mov	al, [esi].GENGC_xlatPalette[eax];U	;; AGI without z-buffering
mov	[edx], al			;U
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], ax
else
mov	[edx], ax
shr	eax, 16
sub	ebp, 010001h
mov	[edx+2], al
endif

;; Finish the loop:

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

endif  ;;ALPHA

@noAlpha:

mov	ah, [edx+2]			;U get texel value
mov	bh, [edx+1]			; V
if (BPP eq 32)
shl	eax, -rRightShiftAdj
else
shr	eax, rRightShiftAdj		;U
endif
mov	ch, [edx]			; V
shr	ebx, gRightShiftAdj		;U
and	eax, rMask			; V
shr	ecx, bRightShiftAdj		;U
and	ebx, gMask			; V
or	eax, ebx			;U
and	ecx, bMask			; V
mov	edx, [esi].GENGC_pixAccum	;U
or	eax, ecx			; V
PIXADVANCE2 ebx, edx			;U

if ZBUFFER
mov	ecx, [esi].GENGC_zAccum		; V
add	edi, 2				;U
add	ecx, [esi].GENGC_SPAN_dz	; V
mov	[esi].GENGC_zAccum, ecx		;U
endif

if (BPP eq 8)
sub	ebp, 010001h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	al, [esi].GENGC_xlatPalette[eax]; V
mov	[edx], al			;U
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[esi].GENGC_pixAccum, ebx
mov	[edx], ax
else
mov	[edx], ax
shr	eax, 16
mov	[esi].GENGC_pixAccum, ebx
sub	ebp, 010001h
mov	[edx+2], al
endif

;; Finish the loop:

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit


elseif FLAT_SHADING

;;----------------------------------------------------------------------
;;
;; ** Flat shading
;;
;;----------------------------------------------------------------------


if ALPHA

mov	ebx, [esi].GENGC_pixAccum	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		
jne	@alphaRead			

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		
	mov	eax, [esi].GENGC_SPAN_dz	
	add	edi, 2				
	add	ecx, eax			
endif

mov	eax, [esi].GENGC_ditherAccum		

if ZBUFFER
	mov	[esi].GENGC_zAccum, ecx		
endif

ror	eax, 8				;U
PIXADVANCE ebx				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_pixAccum, ebx	; V
mov	[esi].GENGC_ditherAccum, eax	;U

;; Finish incrementing all of our accumulators

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V
jmp	spanExit

@alphaRead:

cmp	BYTE PTR [edx+3], 0ffh
jne	@doAlpha
cmp	BYTE PTR [esi].GENGC_aAccum+2, 0ffh
jne	@doAlpha

;; Set mix color to 1, 0, 0, 0

mov	DWORD PTR [esi].GENGC_rDisplay, 0ff000000h
jmp	short @doneAlpha

;;
;; Get pixel value and calculate total effect with alpha
;;

@doAlpha:

ALPHAMODULATE
ALPHAREAD

@doneAlpha:

endif  ;;ALPHA

mov	ebx, [edx]                      ;U
mov     ecx, ebx                        ; V
shr     ebx, 16                         ;U
mov     edx, ecx                        ; V
shr     ecx, 8                          ;U
mov     eax, [esi].GENGC_rAccum		; V
and     ebx, 0ffh                       ;U
and     ecx, 0ffh                       ; V
or      ebx, eax                        ;U
mov     eax, [esi].GENGC_gAccum		; V
and     edx, 0ffh                       ;U
or      ecx, eax                        ; V
mov     eax, [esi].GENGC_bAccum		;U
or      edx, eax                        ; V
mov	ebx, DWORD PTR _gbMulTable[ebx]	;U
mov	ecx, DWORD PTR _gbMulTable[ecx]	; V
mov	edx, DWORD PTR _gbMulTable[edx]	;U


if ALPHA

mov	bh, [esi].GENGC_aDisplay
mov	ch, bh
mov	dh, bh

and	ebx, 0ffffh
and	ecx, 0ffffh
and	edx, 0ffffh

mov	bl, _gbMulTable[ebx]
mov	cl, _gbMulTable[ecx]
mov	dl, _gbMulTable[edx]

add	bl, [esi].GENGC_rDisplay
add	cl, [esi].GENGC_gDisplay
add	dl, [esi].GENGC_bDisplay

endif

;; do the dithering

shl	ebx, (rBits+8)			;U
mov	eax, [esi].GENGC_ditherAccum	; V
shl	ecx, (gBits+8)			;U
and	eax, 0f800h			; V
shl	edx, (bBits+8)			;U
add	ebx, eax			; V
add	ecx, eax			;U
add	edx, eax			; V

;;
;; Compose the final pixel:
;;

if (BPP eq 32)
shl	ebx, -rRightShiftAdj
else
shr	ebx, rRightShiftAdj		;U
endif
mov	eax, [esi].GENGC_ditherAccum	; V
ror	eax, 8				;U
and	ebx, rMask			; V
shr	ecx, gRightShiftAdj		;U
mov	[esi].GENGC_ditherAccum, eax	; V
shr	edx, bRightShiftAdj		;U
and	ecx, gMask			; V
or	ebx, ecx			;U
and	edx, bMask			; V
or	ebx, edx			;U

;;
;; Advance the frame buffer pointer:
;;

mov	ecx, [esi].GENGC_pixAccum	; V
mov	edx, ecx			;U
if (BPP le 16)
add     ecx, (BPP / 8)                  ; V
else
add     ecx, [esi].GENGC_bytesPerPixel  ; V
endif
mov	[esi].GENGC_pixAccum, ecx	;U

;;
;; A good time to start incrementing all of our accumulators:
;;

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		; V
	mov	eax, [esi].GENGC_SPAN_dz	;U
	add	ecx, eax			; V
	add	edi, 2				;U
	mov	[esi].GENGC_zAccum, ecx		; V
endif

;;
;; Write the pixel into the frame buffer
;;

if (BPP eq 8)
mov	al, [esi].GENGC_xlatPalette[ebx]; V
sub	ebp, 010001h			;U
mov	[edx], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], bx
else
mov	[edx], bx
shr	ebx, 16
sub	ebp, 010001h
mov	[edx+2], bl
endif

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U

elseif SMOOTH_SHADING

;;----------------------------------------------------------------------
;;
;; ** Smooth shading
;;
;;----------------------------------------------------------------------

if ALPHA

mov	ebx, [esi].GENGC_pixAccum	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		
jne	@alphaRead			

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		
	mov	eax, [esi].GENGC_SPAN_dz	
	add	eax, ecx			
	add	edi, 2				
	mov	[esi].GENGC_zAccum, eax		
endif

mov	eax, [esi].GENGC_rAccum		
mov	ebx, [esi].GENGC_gAccum		
mov	ecx, [esi].GENGC_bAccum		
add	eax, [esi].GENGC_SPAN_dr	
add	ebx, [esi].GENGC_SPAN_dg	
add	ecx, [esi].GENGC_SPAN_db	
mov	[esi].GENGC_rAccum, eax		
mov	[esi].GENGC_gAccum, ebx		
mov	[esi].GENGC_bAccum, ecx		

mov	eax, [esi].GENGC_ditherAccum	
mov	ecx, [esi].GENGC_aAccum		

ror	eax, 8				
mov	ebx, [esi].GENGC_pixAccum	
add	ecx, [esi].GENGC_SPAN_da	
PIXADVANCE ebx				
mov	[esi].GENGC_aAccum, ecx		
mov	[esi].GENGC_pixAccum, ebx	
sub	ebp, 010001h			
mov	[esi].GENGC_ditherAccum, eax	

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit

@alphaRead:

cmp	BYTE PTR [edx+3], 0ffh
jne	@doAlpha
cmp	BYTE PTR [esi].GENGC_aAccum+2, 0ffh
jne	@doAlpha

;; Set mix color to 1, 0, 0, 0

mov	DWORD PTR [esi].GENGC_rDisplay, 0ff000000h
jmp	short @doneAlpha

;;
;; Get pixel value and calculate total effect with alpha
;;

@doAlpha:

ALPHAMODULATE
ALPHAREAD

@doneAlpha:

endif  ;;ALPHA

mov	ebx, [esi].GENGC_rAccum		;U
mov	eax, [edx]			; V
shr     ebx, rBits                      ;U
and     eax, 0ff0000h                   ; V
shr	eax, 16				;U
mov	ecx, [esi].GENGC_gAccum		; V
shr	ecx, gBits			;U
and     ebx, 0ff00h                     ; V
or      ebx, eax                        ;U
mov	eax, [edx]			; V
shr     eax, 8                          ;U
mov	edx, [edx]			; V
and     eax, 0ffh                       ;U
and	ecx, 0ff00h			; V
or      ecx, eax                        ;U
mov     eax, [esi].GENGC_bAccum		; V
shr     eax, bBits                      ;U
and     edx, 0ffh                       ; V
and     eax, 0ff00h                     ;U
mov	ebx, DWORD PTR _gbMulTable[ebx]	; V get multiplied 8-bit R value
or      edx, eax                        ;U
mov	ecx, DWORD PTR _gbMulTable[ecx]	; V get multiplied 8-bit G value
mov	eax, [esi].GENGC_ditherAccum	;U
mov	edx, DWORD PTR _gbMulTable[edx]	; V get multiplied 8-bit B value


if ALPHA

mov	bh, [esi].GENGC_aDisplay
mov	ch, bh
mov	dh, bh

and	ebx, 0ffffh
and	ecx, 0ffffh
and	edx, 0ffffh

mov	bl, _gbMulTable[ebx]
mov	cl, _gbMulTable[ecx]
mov	dl, _gbMulTable[edx]

add	bl, [esi].GENGC_rDisplay
add	cl, [esi].GENGC_gDisplay
add	dl, [esi].GENGC_bDisplay

endif

shl	ebx, (rBits+8)			;U
and	eax, 0f800h			; V
shl	ecx, (gBits+8)			;U
add	ebx, eax			; V
shl	edx, (bBits+8)			;U
add	ecx, eax			; V

if (BPP eq 32)
shl	ebx, -rRightShiftAdj
else
shr	ebx, rRightShiftAdj		;U
endif
add	edx, eax			; V
shr	ecx, gRightShiftAdj		;U
and	ebx, rMask			; V
shr	edx, bRightShiftAdj		;U
and	ecx, gMask			; V
or	ebx, ecx			;U
and	edx, bMask			; V
or	ebx, edx			;U

;;
;; A good time to start incrementing all of our accumulators
;;

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		; V
	mov	eax, [esi].GENGC_SPAN_dz	;U
	add	eax, ecx			; V
	add	edi, 2				;U
	mov	[esi].GENGC_zAccum, eax		; V
endif

mov	eax, [esi].GENGC_rAccum		;U
mov	ecx, [esi].GENGC_SPAN_dr	; V
mov	edx, [esi].GENGC_gAccum		;U
add     eax, ecx                        ; V
mov     ecx, [esi].GENGC_SPAN_dg        ;U
mov     [esi].GENGC_rAccum, eax         ; V
add     edx, ecx                        ;U
mov     eax, [esi].GENGC_bAccum         ; V
mov	ecx, [esi].GENGC_SPAN_db        ;U
add     eax, ecx                        ; V
mov     [esi].GENGC_gAccum, edx         ;U
mov     [esi].GENGC_bAccum, eax         ; V

mov	eax, [esi].GENGC_ditherAccum	;U
mov	ecx, [esi].GENGC_pixAccum	; V
ror	eax, 8				;U
mov	edx, ecx			; V
if (BPP le 16)
add	ecx, (BPP / 8)			;U
else
add	ecx, [esi].GENGC_bytesPerPixel	;U
endif
mov	[esi].GENGC_ditherAccum, eax	; V
mov	[esi].GENGC_pixAccum, ecx	;U

if ALPHA
mov	ecx, [esi].GENGC_aAccum
add	ecx, [esi].GENGC_SPAN_da
mov	[esi].GENGC_aAccum, ecx
endif

if (BPP eq 8)
mov	al, [esi].GENGC_xlatPalette[ebx]; V
sub	ebp, 010001h			;U
mov	[edx], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], bx
else
mov	[edx], bx
shr	ebx, 16
sub	ebp, 010001h
mov	[edx+2], bl
endif

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U

endif  ;;SMOOTH_SHADING

;;
;; This is the exit point.  We need to pop the unused floating-point
;; registers off the stack, and return:
;;

spanExit:

fstp	ST(0)
fstp	ST(0)

pop	ebp
pop	edi
pop	esi
pop	ebx

ret	0

;;
;; This is the subdivision code.  After the required number of steps, the
;; routine will jump here to calculate the next set of interpolants based
;; on subdivision:
;;

doSubDiv:

add	ebp, 080000h

mov	ecx, [esi].GENGC_flags

;;
;; Increment the big S and T steps:
;;

mov	edx, [esi].GENGC_sAccum

test	ebp, 08000h
jne	short spanExit

mov	ebx, [esi].GENGC_tAccum

add	edx, [esi].GENGC_sStepX
add	ebx, [esi].GENGC_tStepX
mov	[esi].GENGC_sAccum, edx
mov	[esi].GENGC_tAccum, ebx
mov	eax, [esi].GENGC_sResultNew
mov	ebx, [esi].GENGC_tResultNew

test	ecx, GEN_TEXTURE_ORTHO
je	@f

mov	ecx, DWORD PTR [esi].GENGC_tAccum
mov	DWORD PTR [esi].GENGC_sResultNew, edx
mov	DWORD PTR [esi].GENGC_tResultNew, ecx
jmp	short @stResultDone3

;;
;; Do the floating-point computation for perspective:
;;

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum

@stResultDone3:

;;
;; Now, calculate the per-pixel deltas:
;;

mov	cl, TSHIFT_SUBDIV       	;U
mov	edx, [esi].GENGC_tResultNew	; V
sar	edx, cl				;UV (4)
mov	ecx, [esi].GENGC_sResultNew	;U
and	edx, NOT 7			; V
sub	ecx, eax			;U
mov	[esi].GENGC_tResultNew, edx	; V
sar	ecx, 3				;U
sub	edx, ebx			; V
sar	edx, 3				;U
mov	[esi].GENGC_subDs, ecx		; V
mov	[esi].GENGC_subDt, edx		;U
mov	[esi].GENGC_sResult, eax	; V
mov	[esi].GENGC_tResult, ebx	;U
mov	eax, [esi].GENGC_flags		; V
jmp	loopTop				;U
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\attrib.h ===
#ifndef __glattrib_h_
#define __glattrib_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.14 $
** $Date: 1993/10/07 18:34:31 $
*/
#include "lighting.h"
#include "pixel.h"
#include "texture.h"
#include "eval.h"
#include "vertex.h"
#include "glarray.h"

typedef struct __GLcurrentStateRec {
    __GLvertex rasterPos;

    /*
    ** Raster pos valid bit.
    */
    GLboolean validRasterPos;

    /*
    ** Edge tag state.
    */
    GLboolean edgeTag;

    /*
    ** Current color and colorIndex.  These variables are also used for
    ** the current rasterPos color and colorIndex as set by the user.
    */
    __GLcolor userColor;
    __GLfloat userColorIndex;

    __GLcoord normal;
    __GLcoord texture;
} __GLcurrentState;

/************************************************************************/

typedef struct __GLpointStateRec {
    __GLfloat requestedSize;
    __GLfloat smoothSize;
    GLint aliasedSize;
} __GLpointState;

/************************************************************************/

/*
** Line state.  Contains all the client controllable line state.
*/
typedef struct {
    __GLfloat requestedWidth;
    __GLfloat smoothWidth;
    GLint aliasedWidth;
    GLushort stipple;
    GLshort stippleRepeat;
} __GLlineState;

/************************************************************************/

/*
** Polygon state.  Contains all the user controllable polygon state
** except for the stipple state.
*/
typedef struct __GLpolygonStateRec {
    GLenum frontMode;
    GLenum backMode;

    /*
    ** Culling state.  Culling can be enabled/disabled and set to cull
    ** front or back faces.  The FrontFace call determines whether clockwise
    ** or counter-clockwise oriented vertices are front facing.
    */
    GLenum cull;
    GLenum frontFaceDirection;

    /*
    ** Polygon offset state
    */
    __GLfloat factor;
    __GLfloat units;
} __GLpolygonState;

/************************************************************************/

/*
** Polygon stipple state.
*/
typedef struct __GLpolygonStippleStateRec {
    GLubyte stipple[4*32];
} __GLpolygonStippleState;

/************************************************************************/

typedef struct __GLfogStateRec {
    GLenum mode;
#ifdef NT
    GLuint flags;
#endif
    __GLcolor color;
#ifdef NT
    __GLfloat density2neg;
#endif
    __GLfloat density, start, end;
    __GLfloat oneOverEMinusS;
    __GLfloat index;
} __GLfogState;

// fog flags
// __GL_FOG_GRAY_RGB is set when the clamped and scaled fog color contains
// identical R, G, and B values
#define __GL_FOG_GRAY_RGB   0x0001

/************************************************************************/

/*
** Depth state.  Contains all the user settable depth state.
*/
typedef struct __GLdepthStateRec __GLdepthState;
struct __GLdepthStateRec {
    /*
    ** Depth buffer test function.  The z value is compared using zFunction
    ** against the current value in the zbuffer.  If the comparison
    ** succeeds the new z value is written into the z buffer masked
    ** by the z write mask.
    */
    GLenum testFunc;

    /*
    ** Writemask enable.  When GL_TRUE writing to the depth buffer is
    ** allowed.
    */
    GLboolean writeEnable;

    /*
    ** Value used to clear the z buffer when glClear is called.
    */
    GLdouble clear;
};

/************************************************************************/

typedef struct __GLaccumStateRec {
    __GLcolor clear;
} __GLaccumState;

/************************************************************************/

/*
** Stencil state.  Contains all the user settable stencil state.
*/
typedef struct __GLstencilStateRec {
    /*
    ** Stencil test function.  When the stencil is enabled this
    ** function is applied to the reference value and the stored stencil
    ** value as follows:
    **		result = ref comparision (mask & stencilBuffer[x][y])
    ** If the test fails then the fail op is applied and rendering of
    ** the pixel stops.
    */
    GLenum testFunc;

    /*
    ** Stencil clear value.  Used by glClear.
    */
    GLshort clear;

    /*
    ** Reference stencil value.
    */
    GLshort reference;

    /*
    ** Stencil mask.  This is anded against the contents of the stencil
    ** buffer during comparisons.
    */
    GLshort mask;

    /*
    ** Stencil write mask
    */
    GLshort writeMask;

    /*
    ** When the stencil comparison fails this operation is applied to
    ** the stencil buffer.
    */
    GLenum fail;

    /*
    ** When the stencil comparison passes and the depth test
    ** fails this operation is applied to the stencil buffer.
    */
    GLenum depthFail;

    /*
    ** When both the stencil comparison passes and the depth test
    ** passes this operation is applied to the stencil buffer.
    */
    GLenum depthPass;
} __GLstencilState;

/************************************************************************/

typedef struct __GLviewportRec {
    /*
    ** Viewport parameters from user, as integers.
    */
    GLint x, y;
    GLsizei width, height;

    /*
    ** Depthrange parameters from user.
    */
    GLdouble zNear, zFar;

/*XXX move me */
    /*
    ** Internal form of viewport and depth range used to compute
    ** window coordinates from clip coordinates.
    */
    __GLfloat xScale, xCenter;
    __GLfloat yScale, yCenter;
    __GLfloat zScale, zCenter;
} __GLviewport;

/************************************************************************/

typedef struct __GLtransformStateRec {
    /*
    ** Current mode of the matrix stack.  This determines what effect
    ** the various matrix operations (load, mult, scale) apply to.
    */
    GLenum matrixMode;

    /*
    ** User clipping planes in eye space.  These are the user clip planes
    ** projected into eye space.  
    */
/* XXX BUG! stacking of eyeClipPlanes is busted! */
    __GLcoord *eyeClipPlanes;
    __GLcoord *eyeClipPlanesSet;
} __GLtransformState;

/************************************************************************/

/*
** Enable structures.  Anything that can be glEnable'd or glDisable'd is
** contained in this structure.  The enables are kept as single bits
** in a couple of bitfields.
*/

/* Bits in "general" enable word */
#define __GL_ALPHA_TEST_ENABLE			(1 <<  0)
#define __GL_BLEND_ENABLE			(1 <<  1)
#define __GL_INDEX_LOGIC_OP_ENABLE		(1 <<  2)
#define __GL_DITHER_ENABLE			(1 <<  3)
#define __GL_DEPTH_TEST_ENABLE			(1 <<  4)
#define __GL_FOG_ENABLE				(1 <<  5)
#define __GL_LIGHTING_ENABLE			(1 <<  6)
#define __GL_COLOR_MATERIAL_ENABLE		(1 <<  7)
#define __GL_LINE_STIPPLE_ENABLE		(1 <<  8)
#define __GL_LINE_SMOOTH_ENABLE			(1 <<  9)
#define __GL_POINT_SMOOTH_ENABLE		(1 << 10)
#define __GL_POLYGON_SMOOTH_ENABLE		(1 << 11)
#define __GL_CULL_FACE_ENABLE			(1 << 12)
#define __GL_POLYGON_STIPPLE_ENABLE		(1 << 13)
#define __GL_SCISSOR_TEST_ENABLE		(1 << 14)
#define __GL_STENCIL_TEST_ENABLE		(1 << 15)
#define __GL_TEXTURE_1D_ENABLE			(1 << 16)
#define __GL_TEXTURE_2D_ENABLE			(1 << 17)
#define __GL_TEXTURE_GEN_S_ENABLE		(1 << 18)
#define __GL_TEXTURE_GEN_T_ENABLE		(1 << 19)
#define __GL_TEXTURE_GEN_R_ENABLE		(1 << 20)
#define __GL_TEXTURE_GEN_Q_ENABLE		(1 << 21)
#define __GL_NORMALIZE_ENABLE			(1 << 22)
#define __GL_AUTO_NORMAL_ENABLE			(1 << 23)
#define __GL_POLYGON_OFFSET_POINT_ENABLE        (1 << 24)
#define __GL_POLYGON_OFFSET_LINE_ENABLE         (1 << 25)
#define __GL_POLYGON_OFFSET_FILL_ENABLE         (1 << 26)
#define __GL_COLOR_LOGIC_OP_ENABLE              (1 << 27)
#ifdef GL_EXT_flat_paletted_lighting
// NOTE: Not currently enabled, can be reused if necessary
#define __GL_PALETTED_LIGHTING_ENABLE           (1 << 28)
#endif // GL_EXT_flat_paletted_lighting
#ifdef GL_WIN_specular_fog
#define __GL_FOG_SPEC_TEX_ENABLE                (1 << 29)
#endif //GL_WIN_specular_fog
#ifdef GL_WIN_multiple_textures
#define __GL_TEXCOMBINE_CLAMP_ENABLE            (1 << 30)
#endif // GL_WIN_multiple_textures

/*
** Composities of the above bits for each glPushAttrib group that has
** multiple enables, except for those defined below
*/
#define __GL_COLOR_BUFFER_ENABLES				       \
    (__GL_ALPHA_TEST_ENABLE | __GL_BLEND_ENABLE | __GL_INDEX_LOGIC_OP_ENABLE \
     | __GL_DITHER_ENABLE | __GL_COLOR_LOGIC_OP_ENABLE)

#define __GL_LIGHTING_ENABLES \
    (__GL_LIGHTING_ENABLE | __GL_COLOR_MATERIAL_ENABLE)

#define __GL_LINE_ENABLES \
    (__GL_LINE_STIPPLE_ENABLE | __GL_LINE_SMOOTH_ENABLE)

#define __GL_POLYGON_ENABLES				\
    (__GL_POLYGON_SMOOTH_ENABLE | __GL_CULL_FACE_ENABLE	\
     | __GL_POLYGON_STIPPLE_ENABLE | __GL_POLYGON_OFFSET_POINT_ENABLE \
     | __GL_POLYGON_OFFSET_LINE_ENABLE | __GL_POLYGON_OFFSET_FILL_ENABLE)

#define __GL_TEXTURE_ENABLES				      \
    (__GL_TEXTURE_1D_ENABLE | __GL_TEXTURE_2D_ENABLE	      \
     | __GL_TEXTURE_GEN_S_ENABLE | __GL_TEXTURE_GEN_T_ENABLE  \
     | __GL_TEXTURE_GEN_R_ENABLE | __GL_TEXTURE_GEN_Q_ENABLE)

/* Bits in "eval1" enable word */
#define __GL_MAP1_VERTEX_3_ENABLE		(1 << __GL_V3)
#define __GL_MAP1_VERTEX_4_ENABLE		(1 << __GL_V4)
#define __GL_MAP1_COLOR_4_ENABLE		(1 << __GL_C4)
#define __GL_MAP1_INDEX_ENABLE			(1 << __GL_I)
#define __GL_MAP1_NORMAL_ENABLE			(1 << __GL_N3)
#define __GL_MAP1_TEXTURE_COORD_1_ENABLE	(1 << __GL_T1)
#define __GL_MAP1_TEXTURE_COORD_2_ENABLE	(1 << __GL_T2)
#define __GL_MAP1_TEXTURE_COORD_3_ENABLE	(1 << __GL_T3)
#define __GL_MAP1_TEXTURE_COORD_4_ENABLE	(1 << __GL_T4)

/* Bits in "eval2" enable word */
#define __GL_MAP2_VERTEX_3_ENABLE		(1 << __GL_V3)
#define __GL_MAP2_VERTEX_4_ENABLE		(1 << __GL_V4)
#define __GL_MAP2_COLOR_4_ENABLE		(1 << __GL_C4)
#define __GL_MAP2_INDEX_ENABLE			(1 << __GL_I)
#define __GL_MAP2_NORMAL_ENABLE			(1 << __GL_N3)
#define __GL_MAP2_TEXTURE_COORD_1_ENABLE	(1 << __GL_T1)
#define __GL_MAP2_TEXTURE_COORD_2_ENABLE	(1 << __GL_T2)
#define __GL_MAP2_TEXTURE_COORD_3_ENABLE	(1 << __GL_T3)
#define __GL_MAP2_TEXTURE_COORD_4_ENABLE	(1 << __GL_T4)

/* Bits in "clipPlanes" enable word */
#define __GL_CLIP_PLANE0_ENABLE			(1 << 0)
#define __GL_CLIP_PLANE1_ENABLE			(1 << 1)
#define __GL_CLIP_PLANE2_ENABLE			(1 << 2)
#define __GL_CLIP_PLANE3_ENABLE			(1 << 3)
#define __GL_CLIP_PLANE4_ENABLE			(1 << 4)
#define __GL_CLIP_PLANE5_ENABLE			(1 << 5)

/* Bits in "lights" enable word */
#define __GL_LIGHT0_ENABLE			(1 << 0)
#define __GL_LIGHT1_ENABLE			(1 << 1)
#define __GL_LIGHT2_ENABLE			(1 << 2)
#define __GL_LIGHT3_ENABLE			(1 << 3)
#define __GL_LIGHT4_ENABLE			(1 << 4)
#define __GL_LIGHT5_ENABLE			(1 << 5)
#define __GL_LIGHT6_ENABLE			(1 << 6)
#define __GL_LIGHT7_ENABLE			(1 << 7)

typedef struct __GLenableStateRec __GLenableState;
struct __GLenableStateRec {
    GLuint general;
    GLuint lights;
    GLuint clipPlanes;
    GLushort eval1, eval2;
};

/************************************************************************/

typedef struct __GLrasterStateRec __GLrasterState;
struct __GLrasterStateRec {
    /*
    ** Alpha function.  The alpha function is applied to the alpha color
    ** value and the reference value.  If it fails then the pixel is
    ** not rendered.
    */
    GLenum alphaFunction;
    __GLfloat alphaReference;

    /*
    ** Alpha blending source and destination factors.
    */
    GLenum blendSrc;
    GLenum blendDst;

    /*
    ** Logic op.  Logic op is only used during color index mode.
    */
    GLenum logicOp;

    /*
    ** Color to fill the color portion of the framebuffer when clear
    ** is called.
    */
    __GLcolor clear;
    __GLfloat clearIndex;

    /*
    ** Color index write mask.  The color values are masked with this
    ** value when writing to the frame buffer so that only the bits set
    ** in the mask are changed in the frame buffer.
    */
    GLint writeMask;

    /*
    ** RGB write masks.  These booleans enable or disable writing of
    ** the r, g, b, and a components.
    */
    GLboolean rMask, gMask, bMask, aMask;

    /*
    ** This state variable tracks which buffer(s) is being drawn into.
    */
    GLenum drawBuffer;

    /*
    ** Draw buffer specified by user.  May be different from drawBuffer
    ** above.  If the user specifies GL_FRONT_LEFT, for example, then 
    ** drawBuffer is set to GL_FRONT, and drawBufferReturn to 
    ** GL_FRONT_LEFT.
    */
    GLenum drawBufferReturn;
};

/************************************************************************/

/*
** Hint state.  Contains all the user controllable hint state.
*/
typedef struct {
    GLenum perspectiveCorrection;
    GLenum pointSmooth;
    GLenum lineSmooth;
    GLenum polygonSmooth;
    GLenum fog;
#ifdef GL_WIN_phong_shading
    GLenum phong;
#endif
} __GLhintState;

/************************************************************************/

/*
** All stackable list state.
*/
typedef struct __GLdlistStateRec {
    GLuint listBase;
} __GLdlistState;

/************************************************************************/

/*
** Scissor state from user.
*/
typedef struct __GLscissorRec {
    GLint scissorX, scissorY, scissorWidth, scissorHeight;
} __GLscissor;

/************************************************************************/

struct __GLattributeRec {
    /*
    ** Mask of which fields in this structure are valid.
    */
    GLuint mask;

    __GLcurrentState current;
    __GLpointState point;
    __GLlineState line;
    __GLpolygonState polygon;
    __GLpolygonStippleState polygonStipple;
    __GLpixelState pixel;
    __GLlightState light;
    __GLfogState fog;
    __GLdepthState depth;
    __GLaccumState accum;
    __GLstencilState stencil;
    __GLviewport viewport;
    __GLtransformState transform;
    __GLenableState enables;
    __GLrasterState raster;
    __GLhintState hints;
    __GLevaluatorState evaluator;
    __GLdlistState list;
    __GLtextureState texture;
    __GLscissor scissor;
};

/************************************************************************/

/*
** Attribution machine state.  This manages the stack of attributes.
*/
typedef struct {
    /*
    ** Attribute stack.  The attribute stack keeps track of the
    ** attributes that have been pushed.
    */
    __GLattribute **stack;

    /*
    ** Attribute stack pointer.
    */
    __GLattribute **stackPointer;
} __GLattributeMachine;

extern void FASTCALL __glFreeAttributeState(__GLcontext *gc);
extern GLboolean FASTCALL __glCopyContext(__GLcontext *dst, const __GLcontext *src,
				 GLuint mask);
extern GLenum __glErrorCheckMaterial(GLenum face, GLenum p, GLfloat pv0);

/************************************************************************/
// Client attribute states.
typedef struct __GLclientAttributeRec {
    // Mask of which fields in this structure are valid.
    GLbitfield          mask;

    __GLpixelPackMode   pixelPackModes;
    __GLpixelUnpackMode pixelUnpackModes;
    __GLvertexArray     vertexArray;
} __GLclientAttribute;

/*
** Client attribution machine state.  This manages the stack of client
** attributes.
*/
typedef struct {
    /*
    ** Client attribute stack.  The client attribute stack keeps track of the
    ** client attributes that have been pushed.
    */
    __GLclientAttribute **stack;

    /*
    ** Client attribute stack pointer.
    */
    __GLclientAttribute **stackPointer;
} __GLclientAttributeMachine;

extern void FASTCALL __glFreeClientAttributeState(__GLcontext *gc);

extern GLuint FASTCALL __glInternalPopAttrib(__GLcontext *, GLboolean);
extern GLuint FASTCALL __glInternalPopClientAttrib(__GLcontext *, GLboolean,
                                                   GLboolean);

#endif /* __glattrib_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\ia64\glia64.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: glia64.c                                                    *
*                                                                          *
* This module implements a program which generates structure offset        *
* definitions for OpenGL structures that are accessed in assembly code.    *
*                                                                          *
* Created: 24-Aug-1992 01:24:49                                            *
* Author: Charles Whitmer [chuckwh]                                        *
* Ported for OpenGL 4/1/1994 Otto Berkes [ottob]                           *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <windows.h>
#include <ddraw.h>
#include <glp.h>

// #include <winddi.h>

#include "types.h"
#include "render.h"
#include "context.h"
#include "attrib.h"
#include "gencx.h"


#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pcomment prints a comment.

#define pcomment(s)  fprintf(outfh,"// %s\n",s)

// pequate prints an equate statement.

#define pequate(m,v) fprintf(outfh,"%s == 0x%lX\n",m,v);

// pblank prints a blank line.

#define pblank()     fprintf(outfh,"\n")

// pstruct defines an empty structure with the correct size.

#define pstruct(n,c) fprintf(outfh,                           \
                     ".size  %s  %d\n", \
                     n,c);

// pstr prints a string.

#define pstr(s)  fprintf(outfh,"%s\n",s)

//extern __cdecl exit(int);

/******************************Public*Routine******************************\
* GLia64                                                                  *
*                                                                          *
* This is how we make structures consistent between C and ASM for OpenGL.  *
*                                                                          *
\**************************************************************************/

int __cdecl main(int argc,char *argv[])
{
    FILE *outfh;
    char *outName;

    if (argc == 2) {
        outName = argv[ 1 ];
    } else {
#ifdef TREE2
        outName = "\\nt\\private\\windows\\gdi\\opengl2\\server\\soft\\ia64\\oglia64.inc";
#else
        outName = "\\nt\\private\\windows\\gdi\\opengl\\server\\soft\\ia64\\oglia64.inc";
#endif
    }
    outfh = fopen( outName, "w" );
    if (outfh == NULL) {
        fprintf(stderr, "GENia64: Could not create output file '%s'.\n", outName);
        exit (1);
    }

    fprintf( stderr, "GLia64: Writing %s header file.\n", outName );

    pblank();
    pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: glia64.inc");
    pcomment("");
    pcomment(" Defines OpenGL assembly-language structures.");
    pcomment("");
    pcomment(" Copyright (c) 1994 Microsoft Corporation");
    pcomment("------------------------------------------------------------------");
    pblank();
    pblank();
    pblank();

    // UNUSED
#if 0
// Stuff from: \nt\public\sdk\inc\gl\gl.h

    pcomment("Pixel Format Descriptor");
    pblank();
    pequate("PFD_cColorBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cColorBits ));
    pequate("PFD_iPixelType     ",OFFSET(PIXELFORMATDESCRIPTOR,iPixelType ));
    pequate("PFD_cDepthBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cDepthBits ));


    pcomment("GL Test Functions");
    pblank();

    pequate("GL_NEVER           ",GL_NEVER   );
    pequate("GL_LESS            ",GL_LESS    );
    pequate("GL_EQUAL           ",GL_EQUAL   );
    pequate("GL_LEQUAL          ",GL_LEQUAL  );
    pequate("GL_GREATER         ",GL_GREATER );
    pequate("GL_NOTEQUAL        ",GL_NOTEQUAL);
    pequate("GL_GEQUAL          ",GL_GEQUAL  );
    pequate("GL_ALWAYS          ",GL_ALWAYS  );
    pblank();
    pblank();

    pcomment("GL Mode Flags");
    pblank();
    pequate("__GL_SHADE_RGB         ",__GL_SHADE_RGB        );
    pequate("__GL_SHADE_SMOOTH      ",__GL_SHADE_SMOOTH     );
    pequate("__GL_SHADE_DEPTH_TEST  ",__GL_SHADE_DEPTH_TEST );
    pequate("__GL_SHADE_DITHER      ",__GL_SHADE_DITHER     );
    pequate("__GL_SHADE_LOGICOP     ",__GL_SHADE_LOGICOP    );
    pequate("__GL_SHADE_MASK        ",__GL_SHADE_MASK       );
    pblank();
    pblank();

    pcomment("GL Type Sizes");
    pblank();
    pequate("GLbyteSize             ",sizeof(GLbyte));
    pequate("GLshortSize            ",sizeof(GLshort));
    pequate("GLintSize              ",sizeof(GLint));
    pequate("GLfloatSize            ",sizeof(GLfloat));
    pequate("__GLfloatSize          ",sizeof(__GLfloat));
    pequate("__GLzValueSize         ",sizeof(__GLzValue));
    pblank();
    pblank(); 


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\types.h

    pcomment("__GLcolorRec structure");
    pblank();
    pstruct("GLcolorRec",sizeof(struct __GLcolorRec));
    pblank();
    pequate("COLOR_r            ",OFFSET(struct __GLcolorRec,r  ));
    pequate("COLOR_g            ",OFFSET(struct __GLcolorRec,g  ));
    pequate("COLOR_b            ",OFFSET(struct __GLcolorRec,b  ));
    pequate("COLOR_a            ",OFFSET(struct __GLcolorRec,a  ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\render.h

    pcomment("__GLfragmentRec structure");
    pblank();

    pstruct("GLfragmentRec",sizeof(struct __GLfragmentRec));
    pblank();
    pequate("FRAG_x             ",OFFSET(struct __GLfragmentRec,x       ));
    pequate("FRAG_y             ",OFFSET(struct __GLfragmentRec,y       ));
    pequate("FRAG_z             ",OFFSET(struct __GLfragmentRec,z       ));
    pequate("FRAG_color         ",OFFSET(struct __GLfragmentRec,color   ));
    pequate("FRAG_s             ",OFFSET(struct __GLfragmentRec,s       ));
    pequate("FRAG_t             ",OFFSET(struct __GLfragmentRec,t       ));
    pequate("FRAG_qw            ",OFFSET(struct __GLfragmentRec,qw      ));
    pequate("FRAG_f             ",OFFSET(struct __GLfragmentRec,f       ));
    pblank();

    pcomment("__GLshadeRec structure");
    pblank();
    pstruct("__GLshadeRec",sizeof(struct __GLshadeRec));
    pblank();
    pequate("SHADE_dxLeftLittle ",OFFSET(struct __GLshadeRec,dxLeftLittle   ));
    pequate("SHADE_dxLeftBig    ",OFFSET(struct __GLshadeRec,dxLeftBig      ));
    pequate("SHADE_dxLeftFrac   ",OFFSET(struct __GLshadeRec,dxLeftFrac     ));
    pequate("SHADE_ixLeft       ",OFFSET(struct __GLshadeRec,ixLeft         ));
    pequate("SHADE_ixLeftFrac   ",OFFSET(struct __GLshadeRec,ixLeftFrac     ));

    pequate("SHADE_dxRightLittle",OFFSET(struct __GLshadeRec,dxRightLittle  ));
    pequate("SHADE_dxRightBig   ",OFFSET(struct __GLshadeRec,dxRightBig     ));
    pequate("SHADE_dxRightFrac  ",OFFSET(struct __GLshadeRec,dxRightFrac    ));
    pequate("SHADE_ixRight      ",OFFSET(struct __GLshadeRec,ixRight        ));
    pequate("SHADE_ixRightFrac  ",OFFSET(struct __GLshadeRec,ixRightFrac    ));

    pequate("SHADE_area         ",OFFSET(struct __GLshadeRec,area           ));
    pequate("SHADE_dxAC         ",OFFSET(struct __GLshadeRec,dxAC           ));
    pequate("SHADE_dxBC         ",OFFSET(struct __GLshadeRec,dxBC           ));
    pequate("SHADE_dyAC         ",OFFSET(struct __GLshadeRec,dyAC           ));
    pequate("SHADE_dyBC         ",OFFSET(struct __GLshadeRec,dyBC           ));

    pequate("SHADE_frag         ",OFFSET(struct __GLshadeRec,frag           ));
    pequate("SHADE_spanLength   ",OFFSET(struct __GLshadeRec,length         ));

    pequate("SHADE_rLittle      ",OFFSET(struct __GLshadeRec,rLittle        ));
    pequate("SHADE_gLittle      ",OFFSET(struct __GLshadeRec,gLittle        ));
    pequate("SHADE_bLittle      ",OFFSET(struct __GLshadeRec,bLittle        ));
    pequate("SHADE_aLittle      ",OFFSET(struct __GLshadeRec,aLittle        ));

    pequate("SHADE_rBig         ",OFFSET(struct __GLshadeRec,rBig           ));
    pequate("SHADE_gBig         ",OFFSET(struct __GLshadeRec,gBig           ));
    pequate("SHADE_bBig         ",OFFSET(struct __GLshadeRec,bBig           ));
    pequate("SHADE_aBig         ",OFFSET(struct __GLshadeRec,aBig           ));

    pequate("SHADE_drdx         ",OFFSET(struct __GLshadeRec,drdx           ));
    pequate("SHADE_dgdx         ",OFFSET(struct __GLshadeRec,dgdx           ));
    pequate("SHADE_dbdx         ",OFFSET(struct __GLshadeRec,dbdx           ));
    pequate("SHADE_dadx         ",OFFSET(struct __GLshadeRec,dadx           ));

    pequate("SHADE_drdy         ",OFFSET(struct __GLshadeRec,drdy           ));
    pequate("SHADE_dgdy         ",OFFSET(struct __GLshadeRec,dgdy           ));
    pequate("SHADE_dbdy         ",OFFSET(struct __GLshadeRec,dbdy           ));
    pequate("SHADE_dady         ",OFFSET(struct __GLshadeRec,dady           ));

    pequate("SHADE_zLittle      ",OFFSET(struct __GLshadeRec,zLittle        ));
    pequate("SHADE_zBig         ",OFFSET(struct __GLshadeRec,zBig           ));
    pequate("SHADE_dzdx         ",OFFSET(struct __GLshadeRec,dzdx           ));
    pequate("SHADE_dzdyf        ",OFFSET(struct __GLshadeRec,dzdyf          ));
    pequate("SHADE_dzdxf        ",OFFSET(struct __GLshadeRec,dzdxf          ));

    pequate("SHADE_sLittle      ",OFFSET(struct __GLshadeRec,sLittle        ));
    pequate("SHADE_tLittle      ",OFFSET(struct __GLshadeRec,tLittle        ));
    pequate("SHADE_qwLittle     ",OFFSET(struct __GLshadeRec,qwLittle       ));

    pequate("SHADE_sBig         ",OFFSET(struct __GLshadeRec,sBig           ));
    pequate("SHADE_tBig         ",OFFSET(struct __GLshadeRec,tBig           ));
    pequate("SHADE_qwBig        ",OFFSET(struct __GLshadeRec,qwBig          ));

    pequate("SHADE_dsdx         ",OFFSET(struct __GLshadeRec,dsdx           ));
    pequate("SHADE_dtdx         ",OFFSET(struct __GLshadeRec,dtdx           ));
    pequate("SHADE_dqwdx        ",OFFSET(struct __GLshadeRec,dqwdx          ));

    pequate("SHADE_dsdy         ",OFFSET(struct __GLshadeRec,dsdy           ));
    pequate("SHADE_dtdy         ",OFFSET(struct __GLshadeRec,dtdy           ));
    pequate("SHADE_dqwdy        ",OFFSET(struct __GLshadeRec,dqwdy          ));

    pequate("SHADE_fLittle      ",OFFSET(struct __GLshadeRec,fLittle        ));
    pequate("SHADE_fBig         ",OFFSET(struct __GLshadeRec,fBig           ));
    pequate("SHADE_dfdy         ",OFFSET(struct __GLshadeRec,dfdy           ));
    pequate("SHADE_dfdx         ",OFFSET(struct __GLshadeRec,dfdx           ));

    pequate("SHADE_modeFlags    ",OFFSET(struct __GLshadeRec,modeFlags      ));

    pequate("SHADE_zbuf         ",OFFSET(struct __GLshadeRec,zbuf           ));
    pequate("SHADE_zbufBig      ",OFFSET(struct __GLshadeRec,zbufBig        ));
    pequate("SHADE_zbufLittle   ",OFFSET(struct __GLshadeRec,zbufLittle     ));

    pequate("SHADE_sbuf         ",OFFSET(struct __GLshadeRec,sbuf           ));
    pequate("SHADE_sbufBig      ",OFFSET(struct __GLshadeRec,sbufBig        ));
    pequate("SHADE_sbufLittle   ",OFFSET(struct __GLshadeRec,sbufLittle     ));

    pequate("SHADE_colors       ",OFFSET(struct __GLshadeRec,colors         ));
    pequate("SHADE_fbcolors     ",OFFSET(struct __GLshadeRec,fbcolors       ));
    pequate("SHADE_stipplePat   ",OFFSET(struct __GLshadeRec,stipplePat     ));
    pequate("SHADE_done         ",OFFSET(struct __GLshadeRec,done           ));
    pequate("SHADE_cfb          ",OFFSET(struct __GLshadeRec,cfb            ));
    pblank();
    pblank();


    pcomment("__GLpolygonMachineRec structure");
    pblank();
    pstruct("GLpolygonMachineRec",sizeof(struct __GLpolygonMachineRec));
    pblank();
    pequate("POLY_stipple       ",OFFSET(struct __GLpolygonMachineRec,stipple));
    pequate("POLY_shader        ",OFFSET(struct __GLpolygonMachineRec,shader ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\buffers.h

    pequate("DIB_FORMAT         ",DIB_FORMAT);

    pcomment("__GLbufferRec structure");
    pblank();
    pstruct("GLbufferRec",sizeof(struct __GLbufferRec));
    pblank();
    pequate("BUF_gc             ",OFFSET(struct __GLbufferRec,gc          ));
    pequate("BUF_width          ",OFFSET(struct __GLbufferRec,width       ));
    pequate("BUF_height         ",OFFSET(struct __GLbufferRec,height      ));
    pequate("BUF_depth          ",OFFSET(struct __GLbufferRec,depth       ));
    pequate("BUF_base           ",OFFSET(struct __GLbufferRec,base        ));
    pequate("BUF_size           ",OFFSET(struct __GLbufferRec,size        ));
    pequate("BUF_elementSize    ",OFFSET(struct __GLbufferRec,elementSize ));
    pequate("BUF_outerWidth     ",OFFSET(struct __GLbufferRec,outerWidth  ));
    pequate("BUF_xOrigin        ",OFFSET(struct __GLbufferRec,xOrigin     ));
    pequate("BUF_yOrigin        ",OFFSET(struct __GLbufferRec,yOrigin     ));
    pequate("BUF_other          ",OFFSET(struct __GLbufferRec,other       ));
    pblank();
    pblank();


    pcomment("__GLcolorBufferRec structure");
    pblank();
    pstruct("GLcolorBufferRec",sizeof(struct __GLcolorBufferRec));
    pblank();
    pequate("CBUF_redMax        ",OFFSET(struct __GLcolorBufferRec,redMax     ));
    pequate("CBUF_greenMax      ",OFFSET(struct __GLcolorBufferRec,greenMax   ));
    pequate("CBUF_blueMax       ",OFFSET(struct __GLcolorBufferRec,blueMax    ));
    pequate("CBUF_iRedScale     ",OFFSET(struct __GLcolorBufferRec,iRedScale  ));
    pequate("CBUF_iGreenScale   ",OFFSET(struct __GLcolorBufferRec,iGreenScale));
    pequate("CBUF_iBlueScale    ",OFFSET(struct __GLcolorBufferRec,iBlueScale ));
    pequate("CBUF_iAlphaScale   ",OFFSET(struct __GLcolorBufferRec,iAlphaScale));
    pequate("CBUF_iRedShift     ",OFFSET(struct __GLcolorBufferRec,redShift  ));
    pequate("CBUF_iGreenShift   ",OFFSET(struct __GLcolorBufferRec,greenShift));
    pequate("CBUF_iBlueShift    ",OFFSET(struct __GLcolorBufferRec,blueShift ));
    pequate("CBUF_iAlphaShift   ",OFFSET(struct __GLcolorBufferRec,alphaShift));
    pequate("CBUF_sourceMask    ",OFFSET(struct __GLcolorBufferRec,sourceMask ));
    pequate("CBUF_destMask      ",OFFSET(struct __GLcolorBufferRec,destMask   ));
    pequate("CBUF_other         ",OFFSET(struct __GLcolorBufferRec,other      ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\attrib.h


    pcomment("__GLdepthStateRec structure");
    pblank();
    pstruct("GLdepthStateRec",sizeof(struct __GLdepthStateRec));
    pblank();
    pequate("DEPTH_testFunc     ",OFFSET(struct __GLdepthStateRec,testFunc   ));
    pequate("DEPTH_writeEnable  ",OFFSET(struct __GLdepthStateRec,writeEnable));
    pblank();
    pblank();

    pcomment("__GLattributeRec structure");
    pblank();
    pstruct("GLattributeRec",sizeof(struct __GLattributeRec));
    pblank();
    pequate("ATTR_polygonStipple",OFFSET(struct __GLattributeRec,polygonStipple));
    pequate("ATTR_depth         ",OFFSET(struct __GLattributeRec,depth));
    pequate("ATTR_enables       ",OFFSET(struct __GLattributeRec,enables));
    pequate("ATTR_raster        ",OFFSET(struct __GLattributeRec,raster));
    pequate("ATTR_hints         ",OFFSET(struct __GLattributeRec,hints));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\context.h

    pcomment("__GLcontextConstantsRec structure");
    pblank();
    pstruct("GLcontextConstantsRec",sizeof(struct __GLcontextConstantsRec));
    pblank();
    pequate("CTXCONST_viewportXAdjust",OFFSET(struct __GLcontextConstantsRec,viewportXAdjust));
    pequate("CTXCONST_viewportYAdjust",OFFSET(struct __GLcontextConstantsRec,viewportYAdjust));
    pequate("CTXCONST_width          ",OFFSET(struct __GLcontextConstantsRec,width));
    pequate("CTXCONST_height         ",OFFSET(struct __GLcontextConstantsRec,height));


    pcomment("__GLcontextRec structure");
    pblank();
    pstruct("GLcontextRec",sizeof(struct __GLcontextRec));
    pblank();
    pequate("CTX_gcState        ",OFFSET(struct __GLcontextRec,gcState    ));
    pequate("CTX_state          ",OFFSET(struct __GLcontextRec,state      ));
    pequate("CTX_renderMode     ",OFFSET(struct __GLcontextRec,renderMode ));
    pequate("CTX_modes          ",OFFSET(struct __GLcontextRec,modes      ));
    pequate("CTX_constants      ",OFFSET(struct __GLcontextRec,constants  ));
    pequate("CTX_drawBuffer     ",OFFSET(struct __GLcontextRec,drawBuffer ));
    pequate("CTX_readBuffer     ",OFFSET(struct __GLcontextRec,readBuffer ));
    pequate("CTX_polygon        ",OFFSET(struct __GLcontextRec,polygon    ));
    pequate("CTX_pixel          ",OFFSET(struct __GLcontextRec,pixel      ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\gencx.h

    pcomment("__GLGENcontextRec structure");
    pblank();
    pstruct("GLGENcontextRec",sizeof(struct __GLGENcontextRec));
    pblank();
    pequate("GENCTX_hrc               ",OFFSET(struct __GLGENcontextRec,hrc       ));
    pequate("GENCTX_CurrentDC         ",OFFSET(struct __GLGENcontextRec,CurrentDC ));
    pequate("GENCTX_CurrentFormat     ",OFFSET(struct __GLGENcontextRec,CurrentFormat ));    
    pequate("GENCTX_iDCType           ",OFFSET(struct __GLGENcontextRec,iDCType   ));
    pequate("GENCTX_iSurfType         ",OFFSET(struct __GLGENcontextRec,iSurfType ));
    pequate("GENCTX_ColorsBits        ",OFFSET(struct __GLGENcontextRec,ColorsBits));
    pequate("GENCTX_pajTranslateVector",OFFSET(struct __GLGENcontextRec,pajTranslateVector));
    pequate("GENCTX_pPrivateArea      ",OFFSET(struct __GLGENcontextRec,pPrivateArea));
    pblank();
    pblank();

    pcomment("SPANREC structure");
    pblank();
    pstruct("SPANREC",sizeof(SPANREC));
    pblank();
    pequate("SPANREC_r               ",OFFSET(SPANREC,r       ));
    pequate("SPANREC_g               ",OFFSET(SPANREC,g       ));
    pequate("SPANREC_b               ",OFFSET(SPANREC,b       ));
    pequate("SPANREC_a               ",OFFSET(SPANREC,a       ));
    pequate("SPANREC_z               ",OFFSET(SPANREC,z       ));
    pblank();
    pblank();

    pcomment("GENACCEL structure");
    pblank();
    pstruct("GENACCEL",sizeof(GENACCEL));
    pblank();
    pequate("SURFACE_TYPE_DIB   ",SURFACE_TYPE_DIB);
    pblank();
    pequate("GENACCEL_spanDelta             ",
        OFFSET(GENACCEL,spanDelta                ));
    pequate("GENACCEL_flags                 ",
        OFFSET(GENACCEL,flags                    ));
    pequate("GENACCEL_fastSpanFuncPtr       ",
        OFFSET(GENACCEL,__fastSpanFuncPtr ));
    pequate("GENACCEL_fastFlatSpanFuncPtr   ",
        OFFSET(GENACCEL,__fastFlatSpanFuncPtr ));
    pequate("GENACCEL_fastSmoothSpanFuncPtr ",
        OFFSET(GENACCEL,__fastSmoothSpanFuncPtr ));
    pequate("GENACCEL_fastZSpanFuncPtr      ",
        OFFSET(GENACCEL,__fastZSpanFuncPtr));
    pblank();
    pblank();
#endif
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\i386\xform.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: xform.asm
;
; xform routines.
;
; Created: 09/28/1995
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc
	
	.data

extrn _invSqrtTable: DWORD


;; This debug equate will enable printf-type tracking of the transform calls--
;; quite handy for conformance-type failures.  '2' will always print, '1' will
;; only print the first time...

;;DEBUG EQU	2

ifdef DEBUG

str1	db	'xform1  ',0
str2	db	'xform2  ',0
str3	db	'xform3  ',0
str4	db	'xform4  ',0
str5	db	'xform5  ',0
str6	db	'xform6  ',0
str7	db	'xform7  ',0
str8	db	'xform8  ',0
str9	db	'xform9  ',0
str10	db	'xform10 ',0
str11	db	'xform11 ',0
str12	db	'xform12 ',0
str13	db	'xform13 ',0
str14	db	'xform14 ',0
str15	db	'xform15 ',0

endif
        .code

ifdef DEBUG

if DEBUG eq 1

DBGPRINTID MACRO idNum

	push	ecx
	push	edx
	mov	edx, offset idNum
	cmp	byte ptr [edx][0], 0
	je	@@1
	push	offset idNum
	call	DWORD PTR __imp__OutputDebugStringA@4
	mov	edx, offset idNum
	mov	byte ptr [edx][0], 0
	@@1:
	pop	edx
	pop	ecx

	ENDM

elseif DEBUG eq 2

DBGPRINTID MACRO idNum

	push	ecx
	push	edx
	push	offset idNum
	call	DWORD PTR __imp__OutputDebugStringA@4
	pop	edx
	pop	ecx

	ENDM

endif

else

DBGPRINTID MACRO idNum
	ENDM

endif

        align   4

EXTRN	__imp__OutputDebugStringA@4:NEAR
;
; Note: These xform routines must allow for the case where the result
; vector is equal to the source vector.
;

; The basic assumptions below are that multiplies and adds have a 3-cycle
; latency that can be hidden using pipelining, fxch is free when paired with
; fadd and fmul, and that the latency for fld is always 1.
;
; The goal is to have each line below consume either 1 or 0 cycles (fxch).
; There's not much we can do at the end of the routine, since we have no
; choice but to wait for the last couple of intructions to get through the
; pipeline.
;
;
; The comments show the age and position of the elements in the pipeline
; (when relevant). Items with higher numbers are newer (in the pipeline)
; than items with lower numbers.  The entries are ordered from stack
; positions 0-7, left to right.
;
; Note that computetions for the terms are intermixed to allow eliminate
; latency where possible.  Unfortunately, this makes the code hard to
; follow.  That's probably why the compiler won't generate code like
; this...
;
;							--- Otto ---
;

_X_	EQU	0
_Y_	EQU	4
_Z_	EQU	8
_W_	EQU	12	


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0] 
;	   + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;          + m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;          + m->matrix[3][2];
; res->w = x*m->matrix[0][3] + y*m->matrix[1][3] + z*m->matrix[2][3]
;          + m->matrix[3][3];
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fxch	ST(2)					; x1 x2 x3
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x3 x1 x2

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x  x
	faddp	ST(2),ST(0)				; y1 x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x
	fxch	ST(1)					; y1 y3 y2 x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y3 y2 y1 x
;

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; y  z1 y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x
; 
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  x
	fxch	ST(1)					; z1 z3 z2 y  x
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z3 z1 z2 y  x
;


;---------------------------------------------------------------------------
; Start computation for w term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M03]		; w1 z  z  z  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; z  w1 z  z  y  x
	faddp	ST(2),ST(0)				; w1 z  z  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M13]		; w2 w1 z  z  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; z w1 w2 z  y   x
	faddp	ST(3),ST(0)				; w1 w2 z y  x
;
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M23]		; w3 w1 w2 z  y  x
	fxch	ST(1)					; w1 w3 w2 z  y  x
	fadd	DWORD PTR [eax][__MATRIX_M33]		; w3 w2 w1 z  y  x
	fxch	ST(1)					; w2 w3 w1 z  y  x
	faddp	ST(2),ST(0)				; w1 w2 z  y  x
;
; OVERLAP -- store final x
;
	fxch	ST(4)					; x  w2 z  y  w1
	fstp	DWORD PTR [result][_X_]			; w2 z  y  w1
;
	faddp	ST(3),ST(0)				; z  y  w
;
; store final z, y, w
;
	fstp	DWORD PTR [result][_Z_]			; y  w
	fstp	DWORD PTR [result][_Y_]			; w
	fstp	DWORD PTR [result][_W_]			; (empty)

ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0]
;               + w*m->matrix[3][0];
;     res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;               + w*m->matrix[3][1];
;     res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;               + w*m->matrix[3][2];
;     res->w = x*m->matrix[0][3] + y*m->matrix[1][3] + z*m->matrix[2][3]
;               + w*m->matrix[3][3];
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fld	DWORD PTR [input][_W_]			; x4 x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; x  y1 x  x  x
	faddp	ST(2),ST(0)				; y1 x  x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; x  y1 y2 x  x
	faddp	ST(3),ST(0)				; y1 y2 x  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(3)					; x  y1 y2 y3 x
	faddp	ST(4),ST(0)				; y1 y2 y3 x
;
	fld	DWORD PTR [input][_W_]			; y4 y1 y2 y3 x
	fmul	DWORD PTR [eax][__MATRIX_M31]
;

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  y  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; y  z1 y  y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  y  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; y  z1 z2 y  y  x
	faddp	ST(3),ST(0)				; z1 z2 y  y  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  y  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(3)					; y  z1 z2 z3 y  x
	faddp	ST(4),ST(0)				; z1 z2 z3 y  x
;
	fld	DWORD PTR [input][_W_]			; z4 z1 z2 z3 y  x
	fmul	DWORD PTR [eax][__MATRIX_M32]

;---------------------------------------------------------------------------
; Start computation for w term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M03]		; w1 z  z  z  z  y  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; z  w1 z  z  z  y  x
	faddp	ST(2),ST(0)				; w1 z  z  z  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M13]		; w2 w1 z  z  z  y  x
;
; OVERLAP -- compute second add for previous term
; 
	fxch	ST(2)					; z  w1 w2 z  z  y  x
	faddp	ST(3),ST(0)				; w1 w2 z  z  y  x

	faddp	ST(1), ST(0)				; w1 z z  y  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M23]		; w2 w1 z  z  y  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; z  w1 w2 z  y  x
	faddp	ST(3),ST(0)				; w1 w2 z  y  x

	faddp	ST(1), ST(0)				; w  z  y  x

;
	fld	DWORD PTR [input][_W_]			; w2 w1 z  y  x
	fmul	DWORD PTR [eax][__MATRIX_M33]

;
; OVERLAP -- store final x
;
	fxch	ST(4)					; x  w1 z  y  w2
	fstp	DWORD PTR [result][_X_]			; w1 z  y  w2

;
	faddp	ST(3),ST(0)				; z  y  w
;
; store final z, y, w
;
	fstp	DWORD PTR [result][_Z_]			; y  w
	fstp	DWORD PTR [result][_Y_]			; w
	fstp	DWORD PTR [result][_W_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + m->matrix[3][2];
; res->w = x*m->matrix[0][3] + y*m->matrix[1][3] + m->matrix[3][3];
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y1 x

	fxch	ST(1)					; y1 x  x
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z1 y  x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y  z1 y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 y  z1 y  x

	fxch	ST(1)					; y  z2 z1 y  x
	faddp	ST(3),ST(0)				; z2 z1 y  x


;---------------------------------------------------------------------------
; Start computation for w term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M03]		; w1 z  z  y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z  w1 z  y  x
;
	fxch	ST(1)					; w1 z  z  y  x
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M13]		; w2 w1 z  z  y  x
;
; OVERLAP -- compute final z
;
	fxch	ST(2)					; z  w1 w2 z  y  x
	faddp	ST(3), ST(0)				; w1 w2 z  y  x
;
;
; OVERLAP -- store final x
;
	fxch	ST(4)					; x  w2 z  y  w1
	fstp	DWORD PTR [result][_X_]
;
; OVERLAP -- compute add for previous result
;
	fadd	DWORD PTR [eax][__MATRIX_M33]		; w2 z  y  w1
	fxch	ST(2)					; y  z  w2 w1
;
; OVERLAP -- store final y
;
	fstp	DWORD PTR [result][_Y_]			; z  w2 w1
;
; finish up
;
	fxch	ST(1)					; w2 z  w1
	faddp	ST(2), ST(0)				; z  w

	fstp	DWORD PTR [result][_Z_]			; w
	fstp	DWORD PTR [result][_W_]			; (empty)

ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1.  The w column of the matrix is [0 0 0 1].
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2_W MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y1 x

	fxch	ST(1)					; y1 x  x
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y2 y1 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z1 y  x
	faddp	ST(2),ST(0)				; z1 y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  x
	fxch	ST(1)					; z1 z2 y  x
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z2 z1 y  x

; 
; OVERLAP -- finish up
;
	fxch	ST(2)					; y  z1 z2 x
	fstp	DWORD PTR [result][_Y_]			; z1 z2 x
	faddp	ST(1),ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
        mov     DWORD PTR [result][_W_], __FLOAT_ONE
	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.  The w column of the matrix is [0 0 0 1].
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0]
;	+ m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;	+ m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;	+ m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3_W MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fxch	ST(2)					; x1 x2 x3
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x3 x1 x2

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x  x
	faddp	ST(2),ST(0)				; y1 x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x
	fxch	ST(1)					; y1 y3 y2 x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y3 y2 y1 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; y  z1 y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x
;
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  x
	fxch	ST(1)					; z1 z3 z2 y  x
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z3 z2 z1 y  x
	fxch	ST(1)					; z2 z3 z1 y  x
	faddp	ST(2),ST(0)				; z1 z2 y  x
;
; finish up
;
	fxch	ST(2)					; y  z2 z1 x
	fstp	DWORD PTR [result][_Y_]			; z2 z1 x
	faddp	ST(1), ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
        mov     DWORD PTR [result][_W_], __FLOAT_ONE
	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that we're
; only doing the 3x3 used for normals.
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2];
;
; History:
;  Fri 29-July-1996 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3x3 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x  x
	faddp	ST(2),ST(0)				; y1 x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; y  z1 y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x
;
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  x
	fxch	ST(1)					; z1 z3 z2 y  x
	faddp	ST(2),ST(0)				; z1 z2 y  x
;
; finish up
;
	fxch	ST(2)					; y  z2 z1 x
	fstp	DWORD PTR [result][_Y_]			; z2 z1 x
	faddp	ST(1), ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.  The w column of the matrix is [0 0 0 1].
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3_W(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0]
;	    + w*m->matrix[3][0];
;     res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;	    + w*m->matrix[3][1];
;     res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;	    + w*m->matrix[3][2];
;     res->w = w;
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4_W MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fld	DWORD PTR [input][_W_]			; x4 x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; x  y1 x  x  x
	faddp	ST(2),ST(0)				; y1 x  x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; x  y1 y2 x  x
	faddp	ST(3),ST(0)				; y1 y2 x  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(3)					; x  y1 y2 y3 x
	faddp	ST(4),ST(0)				; y1 y2 y3 x
;
	fld	DWORD PTR [input][_W_]			; y4 y1 y2 y3 x
	fmul	DWORD PTR [eax][__MATRIX_M31]

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  y  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; y  z1 y  y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  y  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; y  z1 z2 y  y  x
	faddp	ST(3),ST(0)				; z1 z2 y  y  x

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  y  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(1)					; z1 z3 z2 y  y  x
	faddp	ST(2), ST(0)				; z1 z2 y  y  x
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x

;
	fld	DWORD PTR [input][_W_]			; z3 z2 z1 y  x
	fmul	DWORD PTR [eax][__MATRIX_M32]

	fxch	ST(1)					; z2 z3 z1 y  x
	faddp	ST(2), ST(0)				; z1 z2 y  x

;
; OVERLAP -- store final y
;
	fxch	ST(2)					; y  z1 z2 x
	fstp	DWORD PTR [result][_Y_]			; z1 z2 x
	faddp	ST(1), ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
	push	DWORD PTR [input][_W_]
	fstp	DWORD PTR [result][_Z_]			; (empty)
	pop	DWORD PTR [result][_W_]
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1.
;
; The matrix looks like:
; | . . 0 0 |
; | . . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2_2DW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fxch	ST(1)					; x1 x2
	fadd	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y1 x
	faddp	ST(2),ST(0)				; w1 z
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x
;
; OVERLAP -- store final x
;
	fxch	ST(2)					; x  y1 y2 
	fstp	DWORD PTR [result][_X_]			; y1 y2
;
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y2 y1
;
; Not much we can do for the last term in the pipe...

	push	DWORD PTR [eax][__MATRIX_M32]
	faddp	ST(1),ST(0)				; y
	pop	DWORD PTR [result][_Z_]
        mov     DWORD PTR [result][_W_], __FLOAT_ONE	
	fstp	DWORD PTR [result][_Y_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.
;
; The matrix looks like:
; | . . 0 0 |
; | . . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = z*m->matrix[2][2] + m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3_2DW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fxch	ST(1)					; x1 x2
	fadd	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y1 x
	faddp	ST(2),ST(0)				; w1 z
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x
;
; OVERLAP -- store final x
;
	fxch	ST(2)					; x  y1 y2 
	fstp	DWORD PTR [result][_X_]			; y1 y2
;
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y2 y1

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z  y  y
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z  y
	faddp	ST(2),ST(0)				; z  y

	fadd	DWORD PTR [eax][__MATRIX_M32]		; z y
        mov     DWORD PTR [result][_W_], __FLOAT_ONE
	fstp	DWORD PTR [result][_Z_]			; y
	fstp	DWORD PTR [result][_Y_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.
;
; The matrix looks like:
; | . . 0 0 |
; | . . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3_2DW(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + w*m->matrix[3][0];
;     res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + w*m->matrix[3][1];
;     res->z = z*m->matrix[2][2] + w*m->matrix[3][2];
;     res->w = w;
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4_2DW MACRO input, result

;EAX = m->matrix
;EDX = v[]


;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
        fld     DWORD PTR [input][_W_]                  ; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M30]
        fxch    ST(2)                                   ; x1 x2 x3
        faddp   ST(1), ST                               ; x1+x2 x3

	fld	DWORD PTR [input][_X_]			; y1 x1+x2 x3
	fmul	DWORD PTR [eax][__MATRIX_M01]
	fld	DWORD PTR [input][_Y_]			; y2 y1 x1+x2 x3
	fmul	DWORD PTR [eax][__MATRIX_M11]
        fxch    ST(2)                                   ; x1+x2 y1 y2 x3
        faddp   ST(3), ST                               ; y1 y2 X

        fld     DWORD PTR [input][_W_]                  ; y3 y1 y2 X
	fmul	DWORD PTR [eax][__MATRIX_M31]
        fxch    ST(1)                                   ; y1 y3 y2 X
        faddp   ST(2), ST                               ; y3 y1+y2 X

        fld     DWORD PTR [input][_Z_]                  ; z1 y3 y1+y2 X
	fmul	DWORD PTR [eax][__MATRIX_M22]
        fld     DWORD PTR [input][_W_]                  ; z2 z1 y3 y1+y2 X
	fmul	DWORD PTR [eax][__MATRIX_M32]
        fxch    ST(2)                                   ; y3 z1 z2 y1+y2 X
        faddp   ST(3), ST                               ; z1 z2 Y X
        fxch    ST(3)                                   ; X z2 Y z1
        fstp    DWORD PTR [result][_X_]                 ; z2 Y z2
        faddp   ST(2), ST                               ; Y Z
        fstp    DWORD PTR [result][_Y_]
        fstp    DWORD PTR [result][_Z_]
        push    DWORD PTR [input][_W_]
        pop     DWORD PTR [result][_W_]

ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1.
;
; The matrix looks like:
; | . 0 0 0 |
; | 0 . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + m->matrix[3][0];
; res->y = y*m->matrix[1][1] + m->matrix[3][1];
; res->z = m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2_2DNRW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x
	fmul	DWORD PTR [eax][__MATRIX_M00]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y

	fxch	ST(1)					; y  x
        mov     DWORD PTR [result][_W_], __FLOAT_ONE	
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y  x

; Not much we can do for the last term in the pipe...

	push	DWORD PTR [eax][__MATRIX_M32]

	fstp	DWORD PTR [result][_Y_]			; x
	fstp	DWORD PTR [result][_X_]			; (empty)
	pop	DWORD PTR [result][_Z_]
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.
;
; The matrix looks like:
; | . 0 0 0 |
; | 0 . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + m->matrix[3][0];
; res->y = y*m->matrix[1][1] + m->matrix[3][1];
; res->z = z*m->matrix[2][2] + m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3_2DNRW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x
	fmul	DWORD PTR [eax][__MATRIX_M00]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y
	fxch	ST(1)					; y  x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z  y  x

;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z  x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y  z  x

	fxch	ST(2)					; x  z  y
	fstp	DWORD PTR [result][_X_]			; z  y
	
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z  y

	fxch	ST(1)					; y  z
	fstp	DWORD PTR [result][_Y_]			; z

        mov     DWORD PTR [result][_W_], __FLOAT_ONE	

	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.
;
; The matrix looks like:
; | . 0 0 0 |
; | 0 . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3_2DNRW(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + w*m->matrix[3][0];
;     res->y = y*m->matrix[1][1] + w*m->matrix[3][1];
;     res->z = z*m->matrix[2][2] + w*m->matrix[3][2];
;     res->w = w;
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4_2DNRW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_W_]			; x  x
	fmul	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y  x  x

;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y  x
	faddp	ST(2),ST(0)				; y  x

	fld	DWORD PTR [input][_W_]
	fmul	DWORD PTR [eax][__MATRIX_M31]		; y  y  x

	fxch	ST(2)					; x  y  y
	fstp	DWORD PTR [result][_X_]			; y  y

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z  y  y

	fxch	ST(1)					; y  z  y
	faddp	ST(2), ST(0)				; z  y

	fld	DWORD PTR [input][_W_]			; z  z  y
	fmul	DWORD PTR [eax][__MATRIX_M32]

	fxch	ST(2)					; y  z  z
	fstp	DWORD PTR [result][_Y_]			; z  z

	faddp	ST(1), ST(0)				; z

	push	DWORD PTR [input][_W_]
	fstp	DWORD PTR [result][_Z_]			; (empty)
        pop     DWORD PTR [result][_W_]
ENDM

SINGLE_COORD_NEEDED = 1

ifdef SINGLE_COORD_NEEDED

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Generate single-coordinate matrix routines.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; ifdef __GL_ASM_XFORM3

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3@12
@__glXForm3@12 proc near

	PROF_ENTRY
DBGPRINTID str1

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3 <edx>, <ecx>

	ret	4
@__glXForm3@12 endp

;; endif ; __GL_ASM_XFORM3


;; ifdef __GL_ASM_XFORM4

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4(__GLcoord *res, const __GLfloat v[4],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm4@12
@__glXForm4@12 proc near

	PROF_ENTRY
DBGPRINTID str2

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE		; special case w = 1
	je	@__glXForm3@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4 <edx>, <ecx>

	ret	4
@__glXForm4@12 endp

;; endif ; __GL_ASM_XFORM4

;; ifdef __GL_ASM_XFORM2

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2(__GLcoord *res, const __GLfloat v[2],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2@12
@__glXForm2@12 proc near

	PROF_ENTRY
DBGPRINTID str3

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2 <edx>, <ecx>

	ret	4
@__glXForm2@12 endp

;; endif ; __GL_ASM_XFORM2

;; ifdef __GL_ASM_XFORM2_W

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_W(__GLcoord *res, const __GLfloat v[2],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2_W@12
@__glXForm2_W@12 proc near

	PROF_ENTRY
DBGPRINTID str4

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2_W <edx>, <ecx>

	ret	4
@__glXForm2_W@12 endp

;; endif ; __GL_ASM_XFORM2_W

;; ifdef __GL_ASM_XFORM3_W

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_W(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3_W@12
@__glXForm3_W@12 proc near

	PROF_ENTRY
DBGPRINTID str5

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3_W <edx>, <ecx>

	ret	4
@__glXForm3_W@12 endp

;; endif ; __GL_ASM_XFORM3_W

;; ifdef __GL_ASM_XFORM3x3

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3x3@12
@__glXForm3x3@12 proc near

	PROF_ENTRY
DBGPRINTID str15

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3x3 <edx>, <ecx>

	ret	4
@__glXForm3x3@12 endp

;; endif ; __GL_ASM_XFORM3X3

;; ifdef __GL_ASM_XFORM4_W

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_W(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm4_W@12
@__glXForm4_W@12 proc near

	PROF_ENTRY
DBGPRINTID str6

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE		; special case w = 1
	je	@__glXForm3_W@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4_W <edx>, <ecx>

	ret	4
@__glXForm4_W@12 endp

;; endif ; __GL_ASM_XFORM4_W

;; ifdef __GL_ASM_XFORM2_2DW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DW(__GLcoord *res, const __GLfloat v[2],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2_2DW@12
@__glXForm2_2DW@12 proc near

	PROF_ENTRY
DBGPRINTID str7

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2_2DW <edx>, <ecx>

	ret	4
@__glXForm2_2DW@12 endp

;; endif ; __GL_ASM_XFORM2_2DW

;; ifdef __GL_ASM_XFORM3_2DW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DW(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3_2DW@12
@__glXForm3_2DW@12 proc near

	PROF_ENTRY
DBGPRINTID str8

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3_2DW <edx>, <ecx>

	ret	4
@__glXForm3_2DW@12 endp

;; endif ; __GL_ASM_XFORM3_2DW

;; ifdef __GL_ASM_XFORM4_2DW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DW(__GLcoord *res, const __GLfloat v[4],
;		    const __GLmatrix *m)
;--------------------------------------------------------------------------

        public @__glXForm4_2DW@12
@__glXForm4_2DW@12 proc near

	PROF_ENTRY
DBGPRINTID str9

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE		; special case w = 1
	je	@__glXForm3_2DW@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4_2DW <edx>, <ecx>

	ret	4
@__glXForm4_2DW@12 endp

;; endif ; __GL_ASM_XFORM4_2DW

;; ifdef __GL_ASM_XFORM2_2DNRW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DNRW(__GLcoord *res, const __GLfloat v[2],
;		      const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2_2DNRW@12
@__glXForm2_2DNRW@12 proc near

	PROF_ENTRY
DBGPRINTID str10

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2_2DNRW <edx>, <ecx>

	ret	4
@__glXForm2_2DNRW@12 endp

;; endif ; __GL_ASM_XFORM2_2DNRW


;; ifdef __GL_ASM_XFORM3_2DNRW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRW(__GLcoord *res, const __GLfloat v[3],
;		      const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3_2DNRW@12
@__glXForm3_2DNRW@12 proc near

	PROF_ENTRY
DBGPRINTID str11

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3_2DNRW <edx>, <ecx>

	ret	4
@__glXForm3_2DNRW@12 endp

;; endif ; __GL_ASM_XFORM3_2DNRW

;; ifdef __GL_ASM_XFORM4_2DNRW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DNRW(__GLcoord *res, const __GLfloat v[4],
;		      const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm4_2DNRW@12
@__glXForm4_2DNRW@12 proc near

	PROF_ENTRY
DBGPRINTID str12

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE	; special case w = 1
	je	@__glXForm3_2DNRW@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4_2DNRW <edx>, <ecx>

	ret	4
@__glXForm4_2DNRW@12 endp

;; endif ; __GL_ASM_XFORM4_2DNRW

endif ;;SINGLE_COORD_NEEDED


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Now, generate batched-coordinate matrix routines.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;------------------------------Public-Routine------------------------------
; Macro used in all batch routines
;
; ecx     = coordinate address
; edx     = coordinate address for last vertex
; [esp+4] = matrix 
;
; name    = function name
; func    = function name to transform a single vertex
;
; Used registers: 
;   eax, ecx, edx
;
glXFormBatch  MACRO name, func

        public @&name&@12

@&name&@12 PROC NEAR

	PROF_ENTRY
DBGPRINTID str1

        mov     eax, DWORD PTR [esp + 4]
vertexLoop:
        func    <ecx>, <ecx>
	add	ecx, sizeof_POLYDATA
	cmp	ecx, edx
	jbe	vertexLoop
	ret     4

@&name&@12 ENDP

ENDM
;-------------------------------------------------------------------------
;
; Macro to normalize a normal
;
; Input:
;       regPD   - register with POLYDATA address
;       reg2    - any register (will be destroed)
;       reg3    - any register (will be destroed)
;       tmpmem1 - memory offset for temporary data
;       tmpmem2 - memory offset for temporary data
;
; Algoriphm
;
; Computation of 1/sqrt(x), where x is a positive floating point number
;
; x = 2^(E-127)*M,    E - exponent (8 bits), M - mantissa (23 bits)
;
; 1/sqrt(x) = 1/sqrt(2^(E-127)*M)
;
; if E is odd, i.e. E = 2*n + 1 then we have
;
; x = 1/sqrt(2^(2*n + 1 - 127)*M) = 1/sqrt(2^(2*(n-63))*M) = 1/[2^(n-63)*sqrt(M)] = 
;
;   = 2^(63-n)/sqrt(M) 
;
; if E is even, i.e. E = 2*n then we have
;
; x = 1/sqrt(2^(2*n - 127)*M) = 1/sqrt(2^(2*n-126)*M/2) = 1/[2^(n-63)*sqrt(M/2)] = 
;
;   = 2^(63-n)/sqrt(M/2) 
;
; Using K bits of M and 1 lowest bit of E we can make a K+1 bits index (I) into a table.
; Actually mantissa will have K+1 bits, because of one hidden bit. 
;
; Table will store 1/sqrt(mantissa) or 1/sqrt(mantissa/2), depending on lowest E bit. 
;
; if I == 0 .. 2^(K+1)-1, then
;
; Table[I] = (float)(1.0/sqrt(((i & (2^K - 1))/(2^K)+1.0))),   if I & 2^(K) != 0
;
; Table[I] = (float)(1.0/sqrt(((i & (2^K - 1))/(2^K)+1.0)/2.0)),   if I & 2^(K) == 0
;
; 1.0 is added because of the hidden bit in mantissa.
;
;
;
; 31               23 22                           0
;---------------------------------------------------
;!                 !  !   K bits      !            !
;--------------------------------------------------- 
;                   !
;                   -------------- bit from exponent    
;
; Bit from the exponent and K bits from mantissa are shifted right by 23 - K bits and 
; this is the index to a table.
;
; n = E div 2
;
; To multiply by 2^(63-n) we can just add (63-n) << MANTISSA_BITS to a result
; from the table. (Or we can substruct (n-63) << MANTISSA_BITS).
;
; void FASTCALL __glNormalize(float* result, float* source)
;
; edx = result
; ecx = source
;

MANTISSA_SIZE   equ     24          ; number if mantissa bits in fp value
MANTISSA_BITS   equ     (MANTISSA_SIZE - 1)
MANTISSA_MASK   equ     ((1 SHL MANTISSA_BITS) - 1)
EXPONENT_MASK   equ     (-1 AND (NOT MANTISSA_MASK))
K               equ     9           ; K used bits of mantissa

NORMALIZE macro regPD, reg2, reg3, tmpmem1, tmpmem2

	fld	DWORD PTR [regPD+PD_normal]
	fmul	DWORD PTR [regPD+PD_normal]     ;; x
	fld	DWORD PTR [regPD+PD_normal+4]
	fmul	DWORD PTR [regPD+PD_normal+4]   ;; y x
	fld	DWORD PTR [regPD+PD_normal+8]
	fmul	DWORD PTR [regPD+PD_normal+8]   ;; z y x
	fxch	ST(2)			        ;; x y z
	faddp	ST(1), ST		        ;; xy z
	faddp	ST(1), ST		        ;; xyz
	fstp	tmpmem1                         ;; length

	mov	reg2, tmpmem1
	cmp	reg2, __FLOAT_ONE
	je	@continue
        mov     reg3, reg2
        and     reg3, MANTISSA_MASK SHL 1 + 1
        shr     reg2, 1
        shr     reg3, MANTISSA_BITS - K
        and     reg2, EXPONENT_MASK
        mov     reg3, [_invSqrtTable + reg3*4]
        sub     reg2, 63 SHL MANTISSA_BITS
        sub     reg3, reg2
        mov     tmpmem2, reg3                   ;; 1/sqrt(length)
	fld	DWORD PTR [regPD+PD_normal]	
	fmul	tmpmem2                         ;; x
        fld	DWORD PTR [regPD+PD_normal+4]       
	fmul	tmpmem2                         ;; y x
	fld	DWORD PTR [regPD+PD_normal+8]       
	fmul	tmpmem2                         ;; z y x 
	fxch	ST(2)			        ;; x y z 
	fstp	DWORD PTR [regPD+PD_normal]
	fstp	DWORD PTR [regPD+PD_normal+4]
	fstp	DWORD PTR [regPD+PD_normal+8]
@continue:
ENDM
;------------------------------------------------------------
; Macro used in all batch routines for normal transformation
;
; ecx     = pointer to a polyarray 
; edx     = matrix 
;
; name    = function name
; func    = function name to transform a single vertex
;
; Used registers: 
;   eax, ecx, edx
;
glXFormBatchNormal  MACRO name, func

        public @&name&@8

@&name&@8 PROC NEAR

	PROF_ENTRY
DBGPRINTID str1

        mov     eax, edx                ; matrix pointer
        mov     edx, [ecx+PA_pdNextVertex]
        mov     ecx, [ecx+PA_pd0]
@vertexLoop:
        test    DWORD PTR [ecx+PD_flags], POLYDATA_NORMAL_VALID
        jz      @nextVertex
        func    <ecx+PD_normal>, <ecx+PD_normal>
@nextVertex:
        add	ecx, sizeof_POLYDATA
        cmp	ecx, edx
        jl	@vertexLoop

        ret

@&name&@8 ENDP

ENDM
;------------------------------------------------------------
; Macro used in all batch routines for normal transformation
; with normalization
;
; ecx     = pointer to a polyarray 
; edx     = matrix 
;
; name    = function name
; func    = function name to transform a single vertex
;
; Used registers: 
;   eax, ecx, edx
;
glXFormBatchNormalN  MACRO name, func

        public @&name&@8

@&name&@8 PROC NEAR

	PROF_ENTRY
DBGPRINTID str1
        push    ebp
        mov     ebp, esp
        sub     esp, 8
        push    ebx
        push    esi

        mov     eax, edx                ; matrix pointer
        mov     edx, [ecx+PA_pdNextVertex]
        mov     ecx, [ecx+PA_pd0]
@vertexLoop:
        test    DWORD PTR [ecx+PD_flags], POLYDATA_NORMAL_VALID
        jz      @nextVertex
        func    <ecx+PD_normal>, <ecx+PD_normal>

        NORMALIZE <ecx>, <ebx>, <esi>, <DWORD PTR -4[ebp]>, <DWORD PTR -8[ebp]>

@nextVertex:
        add	ecx, sizeof_POLYDATA
        cmp	ecx, edx
	jl	@vertexLoop

        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
	ret

@&name&@8 ENDP

ENDM
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3

    glXformBatch __glXForm3Batch, __GL_ASM_XFORM3

;; endif ; __GL_ASM_XFORM3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM4

    glXformBatch __glXForm4Batch, __GL_ASM_XFORM4

;; endif ; __GL_ASM_XFORM4
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2

    glXformBatch __glXForm2Batch, __GL_ASM_XFORM2

;; endif ; __GL_ASM_XFORM2
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_WBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2_W

    glXformBatch __glXForm2_WBatch, __GL_ASM_XFORM2_W

;; endif ; __GL_ASM_XFORM2_W
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_WBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_W

    glXformBatch __glXForm3_WBatch, __GL_ASM_XFORM3_W

;; endif ; __GL_ASM_XFORM3_W
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3x3

    glXformBatch __glXForm3x3Batch, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3X3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3BatchNormal(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3x3Normal

    glXformBatchNormal __glXForm3x3BatchNormal, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3X3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3BatchNormalN(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3x3Normal

    glXformBatchNormalN __glXForm3x3BatchNormalN, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3X3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_WBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM4_W

    glXformBatch __glXForm4_WBatch, __GL_ASM_XFORM4_W

;; endif ; __GL_ASM_XFORM4_W
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DWBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2_2DW

    glXformBatch __glXForm2_2DWBatch, __GL_ASM_XFORM2_2DW

;; endif ; __GL_ASM_XFORM2_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DWBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DW

    glXformBatch __glXForm3_2DWBatch, __GL_ASM_XFORM3_2DW

;; endif ; __GL_ASM_XFORM3_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DWBatchNormal(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DW

    glXformBatchNormal __glXForm3_2DWBatchNormal, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DWBatchNormalN(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DW

    glXformBatchNormalN __glXForm3_2DWBatchNormalN, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DWBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;; ifdef __GL_ASM_XFORM4_2DW

    glXformBatch __glXForm4_2DWBatch, __GL_ASM_XFORM4_2DW

;; endif ; __GL_ASM_XFORM4_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DNRWBatch(__GLcoord *start, __GLcoord *end,
;		      const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2_2DNRW

    glXformBatch __glXForm2_2DNRWBatch, __GL_ASM_XFORM2_2DNRW

;; endif ; __GL_ASM_XFORM2_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRWBatch(__GLcoord *start, __GLcoord *end,
;		      const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DNRW

    glXformBatch __glXForm3_2DNRWBatch, __GL_ASM_XFORM3_2DNRW

;; endif ; __GL_ASM_XFORM3_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRWBatchNormal(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DNRW

    glXformBatchNormal __glXForm3_2DNRWBatchNormal, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRWBatchNormalN(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DNRW

    glXformBatchNormalN __glXForm3_2DNRWBatchNormalN, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DNRWBatch(__GLcoord *start, __GLcoord *end,
;		      const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM4_2DNRW

    glXformBatch __glXForm4_2DNRWBatch, __GL_ASM_XFORM4_2DNRW

;; endif ; __GL_ASM_XFORM4_2DNRW

;-------------------------------------------------------------------------
;
; void FASTCALL __glNormalizeBatch(POLYARRAY* pa)
;
; ecx = POLYARRAY
;
@__glNormalizeBatch@4 PROC NEAR

	push	ebp
	mov	ebp, esp
        sub     esp, 8
        push    ebx
        push    edx

        mov     edx, DWORD PTR [ecx+PA_pd0]
        mov     ebx, DWORD PTR [ecx+PA_pdNextVertex]

vertexLoop:
        test    [edx+PD_flags], POLYDATA_NORMAL_VALID
        jz      nextVertex

        NORMALIZE <edx>, <eax>, <ecx>, <DWORD PTR -4[ebp]>, <DWORD PTR -8[ebp]>

nextVertex:

        add     edx, sizeof_POLYDATA
        cmp     edx, ebx
        jl      vertexLoop

        pop     edx
        pop     ebx
	mov	esp, ebp
	pop	ebp
	ret	0

@__glNormalizeBatch@4 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\asm.h ===
#ifndef __glasm_h_
#define __glasm_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

/*
** Add defines to this file when routines are written in assembler.  This is
** so that the functions written in C will not be compiled.  If the name is
** not defined, then the functions written in assembler will not be assembled
**
** The "GROUP" defines turn on a number of functions.  See the code in soft
** for details.
**
** SGI code originally used __GL_USEASMCODE as one big switch.
** This method allows finer control over what is written in assembler.
*/

/* Define the following to disable all asm code and test the C code */
#ifndef __GL_ASM_DISABLE_ALL_ASM

#if defined(_X86_)
#define __GL_ASM_XFORM2
#define __GL_ASM_XFORM2BATCH
#define __GL_ASM_XFORM3
#define __GL_ASM_XFORM3BATCH
#define __GL_ASM_XFORM4
#define __GL_ASM_XFORM4BATCH
#define __GL_ASM_XFORM2_W
#define __GL_ASM_XFORM2_WBATCH
#define __GL_ASM_XFORM3_W
#define __GL_ASM_XFORM3_WBATCH
#define __GL_ASM_XFORM3x3
#define __GL_ASM_XFORM3x3BATCH
#define __GL_ASM_XFORM4_W
#define __GL_ASM_XFORM4_WBATCH
#define __GL_ASM_XFORM2_2DW
#define __GL_ASM_XFORM2_2DWBATCH
#define __GL_ASM_XFORM3_2DW
#define __GL_ASM_XFORM3_2DWBATCH
#define __GL_ASM_XFORM4_2DW
#define __GL_ASM_XFORM4_2DWBATCH
#define __GL_ASM_XFORM2_2DNRW
#define __GL_ASM_XFORM2_2DNRWBATCH
#define __GL_ASM_XFORM3_2DNRW
#define __GL_ASM_XFORM3_2DNRWBATCH
#define __GL_ASM_XFORM4_2DNRW
#define __GL_ASM_XFORM4_2DNRWBATCH
#define __GL_ASM_POLYARRAYPROPAGATESAMECOLOR
#define __GL_ASM_POLYARRAYFASTCALCRGBCOLOR
#define __GL_ASM_POLYARRAYZIPPYCALCRGBCOLOR
#define __GL_ASM_PACLIPCHECKFRUSTUM
#define __GL_ASM_PACLIPCHECKFRUSTUM2D
#define __GL_ASM_PACLIPCHECKALL
#define __GL_ASM_FAST_DLIST_PLAYBACK
#define __GL_ASM_GLCLTNORMAL3F
#define __GL_ASM_GLCLTNORMAL3FV
#define __GL_ASM_GLCLTTEXCOORD2F
#define __GL_ASM_GLCLTTEXCOORD2FV
#define __GL_ASM_GLCLTTEXCOORD3F
#define __GL_ASM_GLCLTTEXCOORD3FV
#define __GL_ASM_GLCLTVERTEX2F
#define __GL_ASM_GLCLTVERTEX2FV
#define __GL_ASM_GLCLTVERTEX3F
#define __GL_ASM_GLCLTVERTEX3FV
#define __GL_ASM_GLCLTCOLOR3F_INRGBA
#define __GL_ASM_GLCLTCOLOR3FV_INRGBA
#define __GL_ASM_GLCLTCOLOR4F_INRGBA
#define __GL_ASM_GLCLTCOLOR4FV_INRGBA
#define __GL_ASM_NORMALIZE
#define __GL_ASM_NORMAL_BATCH
#endif /* X86 */

#if defined(_MIPS_)
#define __GL_ASM_NORMALIZE
#define __GL_ASM_MULTMATRIX
#define __GL_ASM_CLAMPANDSCALECOLOR
#define __GL_ASM_XFORM2
#define __GL_ASM_XFORM3
#define __GL_ASM_XFORM4
#define __GL_ASM_XFORM2_W
#define __GL_ASM_XFORM3_W
#define __GL_ASM_XFORM4_W
#define __GL_ASM_XFORM2_2DW
#define __GL_ASM_XFORM3_2DW
#define __GL_ASM_XFORM4_2DW
#define __GL_ASM_XFORM2_2DNRW
#define __GL_ASM_XFORM3_2DNRW
#define __GL_ASM_XFORM4_2DNRW
#if 0
    #define __GL_ASM_POINT
    #define __GL_ASM_POINTFAST
    #define __GL_ASM_OTHERLSTRIPVERTEXFAST
    #define __GL_ASM_FASTCALCRGBCOLOR
    #define __GL_ASM_SAVEN
    #define __GL_ASM_SAVECI
    #define __GL_ASM_SAVEC
    #define __GL_ASM_SAVET
    #define __GL_ASM_SAVECT
    #define __GL_ASM_SAVENT
    #define __GL_ASM_SAVECIALL
    #define __GL_ASM_SAVECALL
    #define __GL_ASM_VALIDATEVERTEX2
    #define __GL_ASM_VALIDATEVERTEX3
    #define __GL_ASM_VALIDATEVERTEX4
#endif
#endif /* MIPS */

#if defined(_PPC_)
#define __GL_ASM_NORMALIZE
#define __GL_ASM_MULTMATRIX
#define __GL_ASM_CLAMPANDSCALECOLOR
#define __GL_ASM_XFORM2
#define __GL_ASM_XFORM3
#define __GL_ASM_XFORM4
#define __GL_ASM_XFORM2_W
#define __GL_ASM_XFORM3_W
#define __GL_ASM_XFORM4_W
#define __GL_ASM_XFORM2_2DW
#define __GL_ASM_XFORM3_2DW
#define __GL_ASM_XFORM4_2DW
#define __GL_ASM_XFORM2_2DNRW
#define __GL_ASM_XFORM3_2DNRW
#define __GL_ASM_XFORM4_2DNRW
#if 0
#define __GL_ASM_POINT
#define __GL_ASM_POINTFAST
#define __GL_ASM_OTHERLSTRIPVERTEXFAST
#define __GL_ASM_FASTCALCRGBCOLOR
#define __GL_ASM_SAVEN
#define __GL_ASM_SAVECI
#define __GL_ASM_SAVEC
#define __GL_ASM_SAVET
#define __GL_ASM_SAVECT
#define __GL_ASM_SAVENT
#define __GL_ASM_SAVECIALL
#define __GL_ASM_SAVECALL
#define __GL_ASM_VALIDATEVERTEX2
#define __GL_ASM_VALIDATEVERTEX3
#define __GL_ASM_VALIDATEVERTEX4
#endif
#endif /* PPC */

#if defined(_ALPHA_)
//#define __GL_ASM_PACLIPCHECKFRUSTUM
//#define __GL_ASM_POLYARRAYFASTCALCRGBCOLOR
#define __GL_ASM_NORMALIZE
#define __GL_ASM_VECSUB4
//#define __GL_ASM_XFORM1		
//#define __GL_ASM_XFORM1BATCH		
//#define __GL_ASM_XFORM2		
//#define __GL_ASM_XFORM2BATCH		
//#define __GL_ASM_XFORM3	
#define __GL_ASM_XFORM3BATCH	
//#define __GL_ASM_XFORM4		
#define __GL_ASM_XFORM4BATCH		
//#define __GL_ASM_XFORM1_W	
//#define __GL_ASM_XFORM1_WBATCH	
//#define __GL_ASM_XFORM2_W	
//#define __GL_ASM_XFORM2_WBATCH	
//#define __GL_ASM_XFORM3_W	
#define __GL_ASM_XFORM3_WBATCH	
//#define __GL_ASM_XFORM3x3
#define __GL_ASM_XFORM3x3BATCH
//#define __GL_ASM_XFORM4_W	
#define __GL_ASM_XFORM4_WBATCH	
//#define __GL_ASM_XFORM1_2DW	
//#define __GL_ASM_XFORM1_2DWBATCH	
//#define __GL_ASM_XFORM2_2DW	
//#define __GL_ASM_XFORM2_2DWBATCH	
//#define __GL_ASM_XFORM3_2DW	
#define __GL_ASM_XFORM3_2DWBATCH	
//#define __GL_ASM_XFORM4_2DW	
//#define __GL_ASM_XFORM4_2DWBATCH	
//#define __GL_ASM_XFORM1_2DNRW	
//#define __GL_ASM_XFORM1_2DNRWBATCH	
//#define __GL_ASM_XFORM2_2DNRW	
//#define __GL_ASM_XFORM2_2DNRWBATCH	
//#define __GL_ASM_XFORM3_2DNRW	
#define __GL_ASM_XFORM3_2DNRWBATCH	
//#define __GL_ASM_XFORM4_2DNRW	
//#define __GL_ASM_XFORM4_2DNRWBATCH	
#if 0
#define __GL_ASM_SAVEN
#define __GL_ASM_SAVECI
#define __GL_ASM_SAVEC
#define __GL_ASM_SAVET
#define __GL_ASM_SAVECT
#define __GL_ASM_SAVENT
#define __GL_ASM_SAVECIALL
#define __GL_ASM_SAVECALL
#endif
#endif /* ALPHA */

#endif /* __GL_ASM_DISABLE_ALL_ASM */

#endif /* __glasm_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\buffers.h ===
#ifndef __glbuffers_h_
#define	__glbuffers_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "render.h"
#include "parray.h"
#include "procs.h"

typedef struct __GLbufferMachineRec {
    /*
    ** GL_TRUE if store procs need to call gc->front->store and 
    ** gc->back->store in order to store one fragment (only TRUE if 
    ** drawBuffer is GL_FRONT_AND_BACK).  This is needed because many
    ** frame buffers can draw to both front and back under some conditions
    ** (like when not blending), but not under other conditions.
    */
    GLboolean doubleStore;
} __GLbufferMachine;

/************************************************************************/

/*
** Generic buffer description.  This description is used for software
** and hardware buffers of all kinds.
*/
struct __GLbufferRec {
    /*
    ** Which context is using this buffer.
    */
    __GLcontext *gc;

    /*
    ** Dimensions of the buffer.
    */
    GLint width, height, depth;

    /*
    ** Base of framebuffer.
    */
    void* base;

    /*
    ** Number of bytes consumed by the framebuffer.
    */
    GLuint size;

    /*
    ** Size of each element in the framebuffer.
    */
    GLuint elementSize;

    /*
    ** If this buffer is part of a larger (say full screen) buffer
    ** then this is the size of that larger buffer.  Otherwise it is
    ** just a copy of width.
    */
    GLint outerWidth;

    /*
    ** If this buffer is part of a larger (say full screen) buffer
    ** then these are the location of this buffer in the larger
    ** buffer.
    */
    GLint xOrigin, yOrigin;

    /*
    ** Flags.
    */
    GLuint flags;
};

/*
** Generic address macro for a buffer.  Coded to assume that
** the buffer is not part of a larger buffer.
** The input coordinates x,y are biased by the x & y viewport
** adjusts in gc->transform, and thus they need to be de-adjusted
** here.
*/
#define	__GL_FB_ADDRESS(fb,cast,x,y) \
    ((cast (fb)->buf.base) \
	+ ((y) - (fb)->buf.gc->constants.viewportYAdjust) \
            * (fb)->buf.outerWidth \
	+ (x) - (fb)->buf.gc->constants.viewportXAdjust)

extern void __glResizeBuffer(__GLGENbuffers *buffers, __GLbuffer *buf,
			     GLint w, GLint h);
extern void FASTCALL __glInitGenericCB(__GLcontext *gc, __GLcolorBuffer *cfb);

/************************************************************************/

struct __GLalphaBufferRec {
    __GLbuffer buf;
    __GLfloat alphaScale;
    void (FASTCALL *store)
        (__GLalphaBuffer *afb, GLint x, GLint y, const __GLcolor *color);
    void (FASTCALL *storeSpan) (__GLalphaBuffer *afb);
    void (FASTCALL *storeSpan2)
        (__GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *colors );
    void (FASTCALL *fetch)
        (__GLalphaBuffer *afb, GLint x, GLint y, __GLcolor *result);
    void (FASTCALL *readSpan)
        (__GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *results);
    void (FASTCALL *clear)(__GLalphaBuffer *afb);
};

/************************************************************************/

struct __GLcolorBufferRec {
    __GLbuffer buf;
    __GLalphaBuffer alphaBuf;

    GLint redMax;
    GLint greenMax;
    GLint blueMax;
    GLint alphaMax; // XXX not used, just here for consistency with rgb

    /*
    ** Color component scale factors.  Given a component value between
    ** zero and one, this scales the component into a zero-N value
    ** which is suitable for usage in the color buffer.  Note that these
    ** values are not necessarily the same as the max values above,
    ** which define precise bit ranges for the buffer.  These values
    ** are never zero, for instance.
    **/
    __GLfloat redScale;
    __GLfloat greenScale;
    __GLfloat blueScale;

    /* Integer versions of above */
    GLint iRedScale;
    GLint iGreenScale;
    GLint iBlueScale;

    /* Used primarily by pixmap code */
    GLint redShift;
    GLint greenShift;
    GLint blueShift;
    GLint alphaShift;
#ifdef NT
    GLuint allShifts;
#endif

    /*
    ** Alpha is treated a little bit differently.  alphaScale and
    ** iAlphaScale are used to define a range of alpha values that are
    ** generated during various rendering steps.  These values will then
    ** be used as indices into a lookup table to see if the alpha test
    ** passes or not.  Because of this, the number should be fairly large
    ** (e.g., one is not good enough).
    */
    __GLfloat alphaScale;
    GLint iAlphaScale;

    __GLfloat oneOverRedScale;
    __GLfloat oneOverGreenScale;
    __GLfloat oneOverBlueScale;
    __GLfloat oneOverAlphaScale;

    /*
    ** Color mask state for the buffer.  When writemasking is enabled
    ** the source and dest mask will contain depth depedent masking.
    */
    GLuint sourceMask, destMask;

    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLcolorBuffer *cfb);

    /*
    ** When the buffer needs resizing this procedure should be called.
    */
    void (*resize)(__GLGENbuffers *buffers, __GLcolorBuffer *cfb, 
		   GLint w, GLint h);

    /*
    ** Store a fragment into the buffer.  For color buffers, the
    ** procedure will optionally dither, writemask, blend and logic op
    ** the fragment before final storage.
    */
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /*
    ** Fetch a color from the buffer.  This returns the r, g, b and a
    ** values for an RGB buffer.  For an index buffer the "r" value
    ** returned is the index.
    */
    void (*fetch)(__GLcolorBuffer *cfb, GLint x, GLint y,
		  __GLcolor *result);

    /*
    ** Similar to fetch, except that the data is always read from
    ** the current read buffer, not from the current draw buffer.
    */
    void (*readColor)(__GLcolorBuffer *cfb, GLint x, GLint y,
		      __GLcolor *result);
    void (*readSpan)(__GLcolorBuffer *cfb, GLint x, GLint y,
		          __GLcolor *results, GLint w);

    /*
    ** Return a span of data from the accumulation buffer into the
    ** color buffer(s), multiplying by "scale" before storage.
    */
    void (*returnSpan)(__GLcolorBuffer *cfb, GLint x, GLint y,
		       const __GLaccumCell *acbuf, __GLfloat scale, GLint w);

    /*
    ** Store a span (line) of colors into the color buffer.  A minimal
    ** implementation need only copy the values directly into
    ** the framebuffer, assuming that the PickSpanProcs is providing
    ** software implementations of all of the modes.
    */
    __GLspanFunc storeSpan;
    __GLstippledSpanFunc storeStippledSpan;
    __GLspanFunc storeLine; 
    __GLstippledSpanFunc storeStippledLine;

    /*
    ** Read a span (line) of colors from the color buffer.  The returned
    ** format is in the same format used for storage.
    */
    __GLspanFunc fetchSpan;
    __GLstippledSpanFunc fetchStippledSpan;
    __GLspanFunc fetchLine;
    __GLstippledSpanFunc fetchStippledLine;

    /*
    ** Clear the scissor area of the color buffer, clipped to
    ** the window size.  Apply dithering if enabled.
    */
    void (FASTCALL *clear)(__GLcolorBuffer *cfb);

    /*
    ** Pointer to bitmap information.
    */
    struct __GLGENbitmapRec *bitmap;
};

/* generic span read routine */
extern GLboolean __glReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
			      __GLcolor *results, GLint w);

/* generic accum return span routine */
extern void __glReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
			   const __GLaccumCell *ac, __GLfloat scale,
			   GLint w);

/* generic span fetch routine */
extern GLboolean FASTCALL __glFetchSpan(__GLcontext *gc);

/************************************************************************/

struct __GLdepthBufferRec {
    __GLbuffer buf;

    GLuint writeMask;

    /*
    ** Scale factor used to convert users ZValues (0.0 to 1.0, inclusive)
    ** into this depth buffers range.
    */
    GLuint scale;

    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLdepthBuffer *dfb, GLint depthIndex );

    /*
    ** Attempt to update the depth buffer using z.  If the depth function
    ** passes then the depth buffer is updated and True is returned,
    ** otherwise False is returned.  The caller is responsible for
    ** updating the stencil buffer.
    */

    GLboolean (*store)(__GLdepthBuffer *dfb, GLint x, GLint y, __GLzValue z);

    /*
    ** Clear the scissor area of the buffer clipped to the window
    ** area.  No other modes apply.
    */
    void (FASTCALL *clear)(__GLdepthBuffer *dfb);

    /*
    ** Direct access routines used by ReadPixels(), WritePixels(), 
    ** CopyPixels().
    */
    GLboolean (*store2)(__GLdepthBuffer *dfb, GLint x, GLint y, __GLzValue z);
    __GLzValue (FASTCALL *fetch)(__GLdepthBuffer *dfb, GLint x, GLint y);

    /*
    ** When using MCD, depth values are passed to the MCD driver via a
    ** 32-bit depth scanline buffer.  The normal store proc, for 16-bit
    ** MCD depth buffers, will translate an incoming 16-bit depth value
    ** into a 32-bit value before copying it into the scanline buffer.
    **
    ** However, some code paths (such as the generic MCD line code)
    ** already do all computations in 32-bit no matter what the MCD
    ** depth buffer size.  These code paths need a proc to write their
    ** values untranslated.
    **
    ** The storeRaw proc will store the incoming z value without any
    ** translation.
    */

    GLboolean (*storeRaw)(__GLdepthBuffer *dfb, GLint x, GLint y, __GLzValue z);
};

#define	__GL_DEPTH_ADDR(a,b,c,d) __GL_FB_ADDRESS(a,b,c,d)

/************************************************************************/

struct __GLstencilBufferRec {
    __GLbuffer buf;

    /*
    ** Stencil test lookup table.  The stencil buffer value is masked
    ** against the stencil mask and then used as an index into this
    ** table which contains either GL_TRUE or GL_FALSE for the
    ** index.
    */
    GLboolean *testFuncTable;

    /*
    ** Stencil op tables.  These tables contain the new stencil buffer
    ** value given the old stencil buffer value as an index.
    */
    __GLstencilCell *failOpTable;
    __GLstencilCell *depthFailOpTable;
    __GLstencilCell *depthPassOpTable;

    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLstencilBuffer *sfb);

    /*
    ** Store a fragment into the buffer.
    */
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y,
		  GLint value);

    /* 
    ** Fetch a value.
    */
    GLint (FASTCALL *fetch)(__GLstencilBuffer *sfb, GLint x, GLint y);

    /*
    ** Return GL_TRUE if the stencil test passes.
    */
    GLboolean (FASTCALL *testFunc)(__GLstencilBuffer *sfb, GLint x, GLint y);

    /*
    ** Apply the stencil ops to this position.
    */
    void (FASTCALL *failOp)(__GLstencilBuffer *sfb, GLint x, GLint y);
    void (FASTCALL *passDepthFailOp)(__GLstencilBuffer *sfb, GLint x, GLint y);
    void (FASTCALL *depthPassOp)(__GLstencilBuffer *sfb, GLint x, GLint y);

    /*
    ** Clear the scissor area of the buffer clipped to the window
    ** area.  No other modes apply.
    */
    void (FASTCALL *clear)(__GLstencilBuffer *sfb);
};

#define	__GL_STENCIL_ADDR(a,b,c,d) __GL_FB_ADDRESS(a,b,c,d)

/************************************************************************/

struct __GLaccumBufferRec {
    __GLbuffer buf;

    /*
    ** Scaling factors to convert from color buffer values to accum
    ** buffer values.
    */
    __GLfloat redScale;
    __GLfloat greenScale;
    __GLfloat blueScale;
    __GLfloat alphaScale;

    __GLfloat oneOverRedScale;
    __GLfloat oneOverGreenScale;
    __GLfloat oneOverBlueScale;
    __GLfloat oneOverAlphaScale;

    __GLuicolor shift, mask, sign; // Cache of commonly used values
    __GLcolor *colors;  // Temporary scanline buffer ptr
    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLaccumBuffer *afb);

    /*
    ** Clear a rectangular region in the buffer.  The scissor area is
    ** cleared.
    */
    void (FASTCALL *clear)(__GLaccumBuffer *afb);

    /*
    ** Accumulate data into the accum buffer.
    */
    void (*accumulate)(__GLaccumBuffer *afb, __GLfloat value);

    /*
    ** Load data into the accum buffer.
    */
    void (*load)(__GLaccumBuffer *afb, __GLfloat value);

    /*
    ** Return data from the accum buffer to the current framebuffer.
    */
    void (*ret)(__GLaccumBuffer *afb, __GLfloat value);

    /*
    ** Multiply the accum buffer by the value.
    */
    void (*mult)(__GLaccumBuffer *afb, __GLfloat value);


    /*
    ** Add the value to the accum buffer.
    */
    void (*add)(__GLaccumBuffer *afb, __GLfloat value);
};

#define	__GL_ACCUM_ADDRESS(a,b,c,d) __GL_FB_ADDRESS(a,b,c,d)

/************************************************************************/

extern void FASTCALL __glInitAccum64(__GLcontext *gc, __GLaccumBuffer *afb);
extern void FASTCALL __glFreeAccum64(__GLcontext *gc, __GLaccumBuffer *afb);
extern void FASTCALL __glInitAccum32(__GLcontext *gc, __GLaccumBuffer *afb);

extern void FASTCALL __glInitCI4(__GLcontext *gc, __GLcolorBuffer *cfb);
extern void FASTCALL __glInitCI8(__GLcontext *gc, __GLcolorBuffer *cfb);
extern void FASTCALL __glInitCI16(__GLcontext *gc, __GLcolorBuffer *cfb);

extern void FASTCALL __glInitStencil8(__GLcontext *gc, __GLstencilBuffer *sfb);
extern void FASTCALL __glInitAlpha(__GLcontext *gc, __GLcolorBuffer *cfb);
extern void FASTCALL __glFreeStencil8(__GLcontext *gc, __GLstencilBuffer *sfb);

#ifdef NT
extern void FASTCALL __glInitDepth16(__GLcontext *gc, __GLdepthBuffer *dfb);
#endif
extern void FASTCALL __glInitDepth32(__GLcontext *gc, __GLdepthBuffer *dfb);
extern void FASTCALL __glFreeDepth32(__GLcontext *gc, __GLdepthBuffer *dfb);

extern void FASTCALL __glClearBuffers(__GLcontext *gc, GLuint mask);

#endif /* __glbuffers_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\context.h ===
#ifndef __glcontext_h_
#define __glcontext_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Graphics context structures.
*/
#include "os.h"
#include "attrib.h"
#include "feedback.h"
#include "select.h"
#include "buffers.h"
#include "pixel.h"
#include "dlist.h"
#include "xform.h"
#include "render.h"
#include "oleauto.h"
#include "parray.h"
#include "procs.h"
#include "gldrv.h"
#include "glarray.h"

// Disable long to float conversion warning.  see also gencx.h
#pragma warning (disable:4244)

/*
** Mode and limit information for a context.  This information is
** kept around in the context so that values can be used during
** command execution, and for returning information about the
** context to the application.
*/
struct __GLcontextModesRec {
    GLboolean rgbMode;
    GLboolean colorIndexMode;
    GLboolean doubleBufferMode;
    GLboolean stereoMode;
    GLboolean haveAccumBuffer;
    GLboolean haveDepthBuffer;
    GLboolean haveStencilBuffer;

    /* The number of bits present in various buffers */
    GLint accumBits;
    GLint *auxBits;
    GLint depthBits;
    GLint stencilBits;
    GLint indexBits;
    GLint indexFractionBits;
    GLint redBits, greenBits, blueBits, alphaBits;
    GLuint redMask, greenMask, blueMask, alphaMask;
#ifdef NT
    GLuint allMask;
    GLuint rgbMask;
#endif
    GLint maxAuxBuffers;

    /* False if running from inside the X server */
    GLboolean isDirect;

    /* frame buffer level */
    GLint level;
};

/*
** Various constants.  Most of these will never change through the life
** of the context.
*/
typedef struct __GLcontextConstantsRec {
    /* Specific size limits */
    GLint numberOfLights;
    GLint numberOfClipPlanes;
    GLint numberOfTextures;
    GLint numberOfTextureEnvs;
    GLint maxViewportWidth;
    GLint maxViewportHeight;

#ifdef GL_WIN_multiple_textures
    /* Maximum number of current textures */
    GLuint numberOfCurrentTextures;
    GLenum texCombineNaturalClamp;
#endif // GL_WIN_multiple_textures

    /*
    ** Viewport offsets: These numbers are added to the viewport center
    ** values to adjust the computed window coordinates into a
    ** numerically well behaved space (fixed point represented in a
    ** floating point number).
    */
    GLint viewportXAdjust;
    GLint viewportYAdjust;
    __GLfloat fviewportXAdjust;
    __GLfloat fviewportYAdjust;

    /*
    ** These values are computed from viewportXAdjust when the context
    ** is created.  It is assumed that x and y are forced into the same
    ** fixed point range by viewportXAdjust and viewportYAdjust.
    **
    ** viewportEpsilon is computed as the smallest possible value that can
    ** be represented in that fixed point space.
    **
    ** viewportAlmostHalf is equal to 0.5 - viewportEpsilon.
    */
    __GLfloat viewportEpsilon;
    __GLfloat viewportAlmostHalf;

    /* Scales that bring colors values from 0.0 to 1.0 into internal range */
    __GLfloat redScale, blueScale, greenScale, alphaScale;

    /*
    ** Geometry of the current window.
    */
    GLint width, height;

    /*
    ** Size of the alpha lookup table for alpha testing, and conversion
    ** value to convert from scaled alpha to alpha to be used for lookup table.
    */
    GLint alphaTestSize;
    __GLfloat alphaTableConv;

    /*
    ** Random getable constants
    */
    GLint maxTextureSize;
    GLint maxMipMapLevel;
    GLint subpixelBits;
    GLint maxListNesting;
    __GLfloat pointSizeMinimum;
    __GLfloat pointSizeMaximum;
    __GLfloat pointSizeGranularity;
    __GLfloat lineWidthMinimum;
    __GLfloat lineWidthMaximum;
    __GLfloat lineWidthGranularity;
    GLint maxEvalOrder;
    GLint maxPixelMapTable;
    GLint maxAttribStackDepth;
    GLint maxClientAttribStackDepth;
    GLint maxNameStackDepth;

    /*
    ** GDI's Y is inverted.  These two constants help out.
    */
    GLboolean yInverted;
    GLint ySign;
} __GLcontextConstants;

/************************************************************************/

typedef enum __GLbeginModeEnum {
    __GL_NOT_IN_BEGIN = 0,
    __GL_IN_BEGIN = 1,
    __GL_NEED_VALIDATE = 2
} __GLbeginMode;

#ifdef NT_SERVER_SHARE_LISTS
//
// Information for tracking dlist locks so we know what to unlock during
// cleanup
//
typedef struct _DlLockEntry
{
    __GLdlist *dlist;
} DlLockEntry;

typedef struct _DlLockArray
{
    GLsizei nAllocated;
    GLsizei nFilled;
    DlLockEntry *pdleEntries;
} DlLockArray;
#endif

// Signature stamp for gc's.  Must be non-zero.
// Currently spells 'GLGC' in byte order.
#define GC_SIGNATURE 0x43474c47

struct __GLcontextRec {

    /************************************************************************/

    /*
    ** Initialization and signature flag.  If this flag is set to the
    ** gc signature value then the gc is initialized.
    ** This could be a simple bit flag except that having the signature
    ** is convenient for identifying gc's in memory during debugging.
    */
    GLuint gcSig;

    /************************************************************************/

    /*
    ** Stackable state.  All of the current user controllable state
    ** is resident here.
    */
    __GLattribute state;

    /************************************************************************/

    /*
    ** Unstackable State
    */

    /*
    ** Current glBegin mode.  Legal values are 0 (not in begin mode), 1
    ** (in beginMode), or 2 (not in begin mode, some validation is
    ** needed).  Because all state changing routines have to fetch this
    ** value, we have overloaded state validation into it.  There is
    ** special code in the __glim_Begin (for software renderers) which
    ** deals with validation.
    */
    __GLbeginMode beginMode;

    /* Current rendering mode */
    GLenum renderMode;

    /*
    ** Most recent error code, or GL_NO_ERROR if no error has occurred
    ** since the last glGetError.
    */
    GLint error;

    /*
    ** Mode information that describes the kind of buffers and rendering
    ** modes that this context manages.
    */
    __GLcontextModes modes;

    /* Implementation dependent constants */
    __GLcontextConstants constants;

    /* Feedback and select state */
    __GLfeedbackMachine feedback;

    __GLselectMachine select;

    /* Display list state */
    __GLdlistMachine dlist;

#ifdef NT
    /* Saved client side dispatch tables.  Used by display list. */
    GLCLTPROCTABLE savedCltProcTable;
    GLEXTPROCTABLE savedExtProcTable;
#endif

    /************************************************************************/

    /*
    ** The remaining state is used primarily by the software renderer.
    */

    /*
    ** Mask word for validation state to help guide the gc validation
    ** code.  Only operations which are largely expensive are broken
    ** out here.  See the #define's below for the values being used.
    */
    GLuint validateMask;

    /*
    ** Mask word of dirty bits.  Most routines just set the GENERIC bit to
    ** dirty, others may set more specific bits.  The list of bits is
    ** listed below.
    */
    GLuint dirtyMask;

    /* Current draw buffer, set by glDrawBuffer */
    __GLcolorBuffer *drawBuffer;

    /* Current read buffer, set by glReadBuffer */
    __GLcolorBuffer *readBuffer;

    /* Function pointers that are mode dependent */
    __GLprocs procs;

    /* Attribute stack state */
    __GLattributeMachine attributes;

    /* Client attribute stack state */
    __GLclientAttributeMachine clientAttributes;

    /* Machine structures defining software rendering "machine" state */
    __GLvertexMachine vertex;
    __GLlightMachine light;
    __GLtextureMachine texture;
    __GLevaluatorMachine eval;
    __GLtransformMachine transform;
    __GLlineMachine line;
    __GLpolygonMachine polygon;
    __GLpixelMachine pixel;
    __GLbufferMachine buffers;

#ifdef NT
    __GLfloat redClampTable[4];
    __GLfloat greenClampTable[4];
    __GLfloat blueClampTable[4];
    __GLfloat alphaClampTable[4];
    __GLfloat oneOverRedVertexScale;
    __GLfloat oneOverGreenVertexScale;
    __GLfloat oneOverBlueVertexScale;
    __GLfloat oneOverAlphaVertexScale;
    __GLfloat redVertexScale;
    __GLfloat greenVertexScale;
    __GLfloat blueVertexScale;
    __GLfloat alphaVertexScale;
    GLboolean vertexToBufferIdentity;
    __GLfloat redVertexToBufferScale;
    __GLfloat blueVertexToBufferScale;
    __GLfloat greenVertexToBufferScale;
    __GLfloat alphaVertexToBufferScale;
    GLuint textureKey;
    GLubyte *alphaTestFuncTable;
#endif

    /* Buffers */
    __GLcolorBuffer *front;
    __GLcolorBuffer *back;
    __GLcolorBuffer frontBuffer;
    __GLcolorBuffer backBuffer;
    __GLcolorBuffer *auxBuffer;
    __GLstencilBuffer stencilBuffer;
    __GLdepthBuffer depthBuffer;
    __GLaccumBuffer accumBuffer;

#ifdef NT
    // Temporary buffers allocated by the gc.  The abnormal process exit
    // code will release these buffers.
    void * apvTempBuf[6];
#endif // NT

#ifdef NT_SERVER_SHARE_LISTS
    DlLockArray dla;
#endif

#ifdef NT
    // TEB polyarray pointer for this thread.  It allows fast access to the
    // polyarray structure in the TEB equivalent to the GLTEB_CLTPOLYARRAY
    // macro.  This field is kept current in MakeCurrent.
    POLYARRAY *paTeb;

    // Vertex array client states
    __GLvertexArray vertexArray;

    // Saved vertex array state for execution of display-listed
    // vertex array calls
    __GLvertexArray savedVertexArray;

    __GLmatrix *mInv;
#endif // NT
};

#ifdef NT
// Associate the temporary buffer with the gc for abnormal process cleanup.
#define GC_TEMP_BUFFER_ALLOC(gc, pv)                                    \
        {                                                               \
            int _i;                                                     \
            for (_i = 0; _i < sizeof(gc->apvTempBuf)/sizeof(void *); _i++)\
            {                                                           \
                if (!gc->apvTempBuf[_i])                                \
                {                                                       \
                    gc->apvTempBuf[_i] = pv;                            \
                    break;                                              \
                }                                                       \
            }                                                           \
            ASSERTOPENGL(_i < sizeof(gc->apvTempBuf)/sizeof(void *),    \
                "gc->apvTempBuf overflows\n");                          \
        }

// Unassociate the temporary buffer with the gc.
#define GC_TEMP_BUFFER_FREE(gc, pv)                                     \
        {                                                               \
            int _i;                                                     \
            for (_i = 0; _i < sizeof(gc->apvTempBuf)/sizeof(void *); _i++)\
            {                                                           \
                if (gc->apvTempBuf[_i] == pv)                           \
                {                                                       \
                    gc->apvTempBuf[_i] = (void *) NULL;                 \
                    break;                                              \
                }                                                       \
            }                                                           \
            ASSERTOPENGL(_i < sizeof(gc->apvTempBuf)/sizeof(void *),    \
                "gc->apvTempBuf entry not found\n");                    \
        }

// Cleanup any temporary buffer allocated in gc in abnormal process exit.
#define GC_TEMP_BUFFER_EXIT_CLEANUP(gc)                                 \
        {                                                               \
            int _i;                                                     \
            for (_i = 0; _i < sizeof(gc->apvTempBuf)/sizeof(void *); _i++)\
            {                                                           \
                if (gc->apvTempBuf[_i])                                 \
                {                                                       \
                    WARNING("Abnormal process exit: free allocated buffers\n");\
                    gcTempFree(gc, gc->apvTempBuf[_i]);              \
                    gc->apvTempBuf[_i] = (void *) NULL;                 \
                }                                                       \
            }                                                           \
        }
#endif // NT

/*
** Bit values for the validateMask word
*/
#define __GL_VALIDATE_ALPHA_FUNC	0x00000001
#define __GL_VALIDATE_STENCIL_FUNC	0x00000002
#define __GL_VALIDATE_STENCIL_OP	0x00000004

/*
** Bit values for dirtyMask word.
**
** These are all for delayed validation.  There are a few things that do
** not trigger delayed validation.  They are:
**
** Matrix operations -- matrices are validated immediately.
** Material changes -- they also validate immediately.
** Color Material change -- validated immediately.
** Color Material enable -- validated immediately.
** Pixel Map changes -- no validation.
*/

/*
** All things not listed elsewhere.
*/
#define __GL_DIRTY_GENERIC		0x00000001

/*
** Line stipple, line stipple enable, line width, line smooth enable,
** line smooth hint.
*/
#define __GL_DIRTY_LINE			0x00000002

/*
** Polygon stipple, polygon stipple enable, polygon smooth enable, face
** culling, front face orientation, polygon mode, point smooth hint.
*/
#define __GL_DIRTY_POLYGON		0x00000004

/*
** Point smooth, point smooth hint, point width.
*/
#define __GL_DIRTY_POINT		0x00000008

/*
** Pixel store, pixel zoom, pixel transfer, (pixel maps don't cause
** validation), read buffer.
*/
#define __GL_DIRTY_PIXEL		0x00000010

/*
** Light, Light Model, lighting enable, lightx enable, (color material
** validates immediately), (NOT shade model -- it is generic), (color material
** enable validates immediately)
*/
#define __GL_DIRTY_LIGHTING		0x00000020

/*
** Polygon stipple
*/
#define __GL_DIRTY_POLYGON_STIPPLE	0x00000040

/*
** the depth mode has changed.  Need to update depth function pointers.
*/
#define	__GL_DIRTY_DEPTH		0x00000080

/*
** Need to update texture and function pointers.
*/
#define	__GL_DIRTY_TEXTURE      0x00000100

#define __GL_DIRTY_ALL			0x000001ff

/*
** Bit values for changes to material colors
**
** These values are shared with MCDMATERIAL_
*/
#define __GL_MATERIAL_AMBIENT		0x00000001
#define __GL_MATERIAL_DIFFUSE		0x00000002
#define __GL_MATERIAL_SPECULAR		0x00000004
#define __GL_MATERIAL_EMISSIVE		0x00000008
#define __GL_MATERIAL_SHININESS		0x00000010
#define __GL_MATERIAL_COLORINDEXES	0x00000020
#define __GL_MATERIAL_ALL		0x0000003f

#define __GL_DELAY_VALIDATE(gc)		      \
    ASSERTOPENGL((gc)->beginMode != __GL_IN_BEGIN, "Dirty state in begin\n"); \
    (gc)->beginMode = __GL_NEED_VALIDATE;     \
    (gc)->dirtyMask |= __GL_DIRTY_GENERIC

#define __GL_DELAY_VALIDATE_MASK(gc, mask)	\
    ASSERTOPENGL((gc)->beginMode != __GL_IN_BEGIN, "Dirty state in begin\n"); \
    (gc)->beginMode = __GL_NEED_VALIDATE;     	\
    (gc)->dirtyMask |= (mask)

#define __GL_CLAMP_CI(target, gc, r)                            \
{                                                               \
    if ((r) > (GLfloat)(gc)->frontBuffer.redMax) {              \
        GLfloat fraction;                                       \
        GLint integer;                                          \
                                                                \
        integer = (GLint) (r);                                  \
        fraction = (r) - (GLfloat) integer;                     \
        integer = integer & (GLint)(gc)->frontBuffer.redMax;    \
        target = (GLfloat) integer + fraction;                  \
    } else if ((r) < 0) {                                       \
        GLfloat fraction;                                       \
        GLint integer;                                          \
                                                                \
        integer = (GLint) __GL_FLOORF(r);                       \
        fraction = (r) - (GLfloat) integer;                     \
        integer = integer & (GLint)(gc)->frontBuffer.redMax;    \
        target = (GLfloat) integer + fraction;                  \
    } else {                                                    \
        target = r;                                             \
    }\
}

#define __GL_CHECK_CLAMP_CI(target, gc, flags, r)               \
{                                                               \
    if (((r) > (GLfloat)(gc)->frontBuffer.redMax) ||            \
        ((r) < 0))                                              \
        flags |= POLYARRAY_CLAMP_COLOR;                         \
    (target) = (r);                                             \
}

#define __GL_COLOR_CLAMP_INDEX_R(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->redVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))	\

#define __GL_COLOR_CLAMP_INDEX_G(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->greenVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))	\

#define __GL_COLOR_CLAMP_INDEX_B(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->blueVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))	\

#define __GL_COLOR_CLAMP_INDEX_A(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->alphaVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))  \

#define __GL_SCALE_R(target, gc, r)                                         \
    (target) = (r) * (gc)->redVertexScale

#define __GL_SCALE_G(target, gc, g)                                         \
    (target) = (g) * (gc)->greenVertexScale

#define __GL_SCALE_B(target, gc, b)                                         \
    (target) = (b) * (gc)->blueVertexScale

#define __GL_SCALE_A(target, gc, a)                                         \
    (target) = (a) * (gc)->alphaVertexScale

#define __GL_COLOR_CHECK_CLAMP_R(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->redVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_G(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->greenVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_B(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->blueVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_A(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->alphaVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_RGB(gc, r, g, b)                              \
    ((CASTINT(r) | ((ULONG)(CASTINT(gc->redVertexScale) - CASTINT(r))) |     \
      CASTINT(g) | ((ULONG)(CASTINT(gc->greenVertexScale) - CASTINT(g))) |   \
      CASTINT(b) | ((ULONG)(CASTINT(gc->blueVertexScale) - CASTINT(b)))) &   \
     0x80000000)


#define __GL_SCALE_AND_CHECK_CLAMP_R(target, gc, flags, r)                  \
{                                                                           \
    __GL_SCALE_R(target, gc, r);                                            \
    __GL_COLOR_CHECK_CLAMP_R(target, flags);                                \
}

#define __GL_SCALE_AND_CHECK_CLAMP_G(target, gc, flags, g)                  \
{                                                                           \
    __GL_SCALE_G(target, gc, g);                                            \
    __GL_COLOR_CHECK_CLAMP_G(target, flags);                                \
}

#define __GL_SCALE_AND_CHECK_CLAMP_B(target, gc, flags, b)                  \
{                                                                           \
    __GL_SCALE_B(target, gc, b);                                            \
    __GL_COLOR_CHECK_CLAMP_B(target, flags);                                \
}

#define __GL_SCALE_AND_CHECK_CLAMP_A(target, gc, flags, a)                  \
{                                                                           \
    __GL_SCALE_A(target, gc, a);                                            \
    __GL_COLOR_CHECK_CLAMP_A(target, flags);                                \
}

#define __GL_CLAMP_R(target, gc, r)                                         \
{                                                                           \
    (gc)->redClampTable[0] = (r);                                           \
    target = (gc)->redClampTable[__GL_COLOR_CLAMP_INDEX_R((gc)->redClampTable[0])]; \
}

#define __GL_CLAMP_G(target, gc, g)                                         \
{                                                                           \
    (gc)->greenClampTable[0] = (g);                                         \
    target = (gc)->greenClampTable[__GL_COLOR_CLAMP_INDEX_G((gc)->greenClampTable[0])]; \
}

#define __GL_CLAMP_B(target, gc, b)                                         \
{                                                                           \
    (gc)->blueClampTable[0] = (b);                                          \
    target = (gc)->blueClampTable[__GL_COLOR_CLAMP_INDEX_B((gc)->blueClampTable[0])]; \
}

#define __GL_CLAMP_A(target, gc, a)                                         \
{                                                                           \
    (gc)->alphaClampTable[0] = (a);                                         \
    target = (gc)->alphaClampTable[__GL_COLOR_CLAMP_INDEX_A((gc)->alphaClampTable[0])]; \
}

/* Aggregate clamping routines. */


#ifdef _X86_

#define __GL_SCALE_RGB(rOut, gOut, bOut, gc, r, g, b)                   \
    __GL_SCALE_R(rOut, gc, r);                                    	\
    __GL_SCALE_G(gOut, gc, g);                                    	\
    __GL_SCALE_B(bOut, gc, b);

#define __GL_SCALE_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)         \
    __GL_SCALE_R(rOut, gc, r);                                    	\
    __GL_SCALE_G(gOut, gc, g);                                    	\
    __GL_SCALE_B(bOut, gc, b);                                    	\
    __GL_SCALE_A(aOut, gc, a);

#define __GL_CLAMP_RGB(rOut, gOut, bOut, gc, r, g, b)       		\
    __GL_CLAMP_R(rOut, gc, r);                                    	\
    __GL_CLAMP_G(gOut, gc, g);                                    	\
    __GL_CLAMP_B(bOut, gc, b);

#define __GL_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)         \
    __GL_CLAMP_R(rOut, gc, r);                                          \
    __GL_CLAMP_G(gOut, gc, g);                                    	\
    __GL_CLAMP_B(bOut, gc, b);                                    	\
    __GL_CLAMP_A(aOut, gc, a);

#define __GL_SCALE_AND_CHECK_CLAMP_RGB(rOut, gOut, bOut, gc, flags, r, g, b)\
    __GL_SCALE_AND_CHECK_CLAMP_R(rOut, gc, flags, r);         		\
    __GL_SCALE_AND_CHECK_CLAMP_G(gOut, gc, flags, g);         		\
    __GL_SCALE_AND_CHECK_CLAMP_B(bOut, gc, flags, b);

#define __GL_SCALE_AND_CHECK_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, flags,\
                                        r, g, b, a)                     \
    __GL_SCALE_AND_CHECK_CLAMP_R(rOut, gc, flags, r);                   \
    __GL_SCALE_AND_CHECK_CLAMP_G(gOut, gc, flags, g);                   \
    __GL_SCALE_AND_CHECK_CLAMP_B(bOut, gc, flags, b);                   \
    __GL_SCALE_AND_CHECK_CLAMP_A(aOut, gc, flags, a);

#else // NOT _X86_

/* The following code is written in a "load, compute, store" style.
** It is preferable for RISC CPU's with larger numbers of registers,
** such as DEC Alpha.  VC++ for Alpha does not do
** a good job expanding the __GL_CLAMP_R, __GL_CLAMP_G, __GL_CLAMP_B,
** __GL_CLAMP_A macros, due to all the pointer indirections and the
** basic blocks defined by {} brackets.
*/

#define __GL_SCALE_RGB(rOut, gOut, bOut, gc, r, g, b)               \
{                                                                   \
    __GLfloat rScale, gScale, bScale;                               \
    __GLfloat rs, gs, bs;                                           \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
                                                                    \
    rs = (r) * rScale;                                              \
    gs = (g) * gScale;                                              \
    bs = (b) * bScale;                                              \
                                                                    \
    rOut = rs;                                                      \
    gOut = gs;                                                      \
    bOut = bs;                                                      \
}

#define __GL_SCALE_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)     \
{                                                                   \
    __GLfloat rScale, gScale, bScale, aScale;                       \
    __GLfloat rs, gs, bs, as;                                       \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
    aScale = (gc)->alphaVertexScale;                                \
                                                                    \
    rs = (r) * rScale;                                              \
    gs = (g) * gScale;                                              \
    bs = (b) * bScale;                                              \
    as = (a) * aScale;                                              \
                                                                    \
    rOut = rs;                                                      \
    gOut = gs;                                                      \
    bOut = bs;                                                      \
    aOut = as;                                                      \
}

#define __GL_CLAMP_RGB(rOut, gOut, bOut, gc, r, g, b)               \
{                                                                   \
    __GLfloat dst_r, dst_g, dst_b;                                  \
    ULONG index_r, index_g, index_b;                                \
    LONG clamp_r, clamp_g, clamp_b;                                 \
    LONG i_rScale, i_gScale, i_bScale;                              \
    ULONG sign_mask = 0x80000000;                                   \
                                                                    \
    (gc)->redClampTable[0] = (r);                                   \
    (gc)->greenClampTable[0] = (g);                                 \
    (gc)->blueClampTable[0] = (b);                                  \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
                                                                    \
    clamp_r = CASTINT((gc)->redClampTable[0]);                      \
    clamp_g = CASTINT((gc)->greenClampTable[0]);                    \
    clamp_b = CASTINT((gc)->blueClampTable[0]);                     \
                                                                    \
    index_r =                                                       \
        (((ULONG)((clamp_r & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_rScale - clamp_r) & sign_mask)) >> 31));      \
                                                                    \
    index_g =                                                       \
        (((ULONG)((clamp_g & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_gScale - clamp_g) & sign_mask)) >> 31));      \
                                                                    \
    index_b =                                                       \
        (((ULONG)((clamp_b & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_bScale - clamp_b) & sign_mask)) >> 31));      \
                                                                    \
    dst_r = (gc)->redClampTable[index_r];                           \
    dst_g = (gc)->greenClampTable[index_g];                         \
    dst_b = (gc)->blueClampTable[index_b];                          \
                                                                    \
    rOut = dst_r;                                                   \
    gOut = dst_g;                                                   \
    bOut = dst_b;                                                   \
}



#define __GL_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)     \
{                                                                   \
    __GLfloat dst_r, dst_g, dst_b, dst_a;                           \
    ULONG index_r, index_g, index_b, index_a;                       \
    LONG clamp_r, clamp_g, clamp_b, clamp_a;                        \
    LONG i_rScale, i_gScale, i_bScale, i_aScale;                    \
    ULONG sign_mask = 0x80000000;                                   \
                                                                    \
    (gc)->redClampTable[0] = (r);                                   \
    (gc)->greenClampTable[0] = (g);                                 \
    (gc)->blueClampTable[0] = (b);                                  \
    (gc)->alphaClampTable[0] = (a);                                 \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
    i_aScale = CASTINT((gc)->alphaVertexScale);                     \
                                                                    \
    clamp_r = CASTINT((gc)->redClampTable[0]);                      \
    clamp_g = CASTINT((gc)->greenClampTable[0]);                    \
    clamp_b = CASTINT((gc)->blueClampTable[0]);                     \
    clamp_a = CASTINT((gc)->alphaClampTable[0]);                    \
                                                                    \
    index_r =                                                       \
        (((ULONG)((clamp_r & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_rScale - clamp_r) & sign_mask)) >> 31));      \
                                                                    \
    index_g =                                                       \
        (((ULONG)((clamp_g & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_gScale - clamp_g) & sign_mask)) >> 31));      \
                                                                    \
    index_b =                                                       \
        (((ULONG)((clamp_b & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_bScale - clamp_b) & sign_mask)) >> 31));      \
                                                                    \
    index_a =                                                       \
        (((ULONG)((clamp_a & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_aScale - clamp_a) & sign_mask)) >> 31));      \
                                                                    \
    dst_r = (gc)->redClampTable[index_r];                           \
    dst_g = (gc)->greenClampTable[index_g];                         \
    dst_b = (gc)->blueClampTable[index_b];                          \
    dst_a = (gc)->alphaClampTable[index_a];                         \
                                                                    \
    rOut = dst_r;                                                   \
    gOut = dst_g;                                                   \
    bOut = dst_b;                                                   \
    aOut = dst_a;                                                   \
}


#define __GL_SCALE_AND_CHECK_CLAMP_RGB(rOut, gOut, bOut, gc, flags, r, g, b)\
{                                                                   \
    ULONG sign_mask = 0x80000000;                                   \
    __GLfloat rScale, gScale, bScale;                               \
    LONG i_rScale, i_gScale, i_bScale;                              \
    LONG i_r, i_g, i_b;                                             \
    __GLfloat fr, fg, fb;                                           \
    ULONG the_flags_copy, r_flags, g_flags, b_flags;                \
                                                                    \
    the_flags_copy = (flags);                                       \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
                                                                    \
    fr = (r) * rScale;                                              \
    fg = (g) * gScale;                                              \
    fb = (b) * bScale;                                              \
                                                                    \
    rOut = fr;                                                      \
    gOut = fg;                                                      \
    bOut = fb;                                                      \
                                                                    \
    i_r = CASTINT((rOut));  		                            \
    i_g = CASTINT((gOut));					    \
    i_b = CASTINT((bOut));	                                    \
                                                                    \
    r_flags =                                                       \
        ((ULONG)(i_r & sign_mask) |                                 \
         (ULONG)((i_rScale - i_r) & sign_mask));                    \
                                                                    \
    g_flags =                                                       \
        ((ULONG)(i_g & sign_mask) |                                 \
         (ULONG)((i_gScale - i_g) & sign_mask));                    \
                                                                    \
    b_flags =                                                       \
        ((ULONG)(i_b & sign_mask) |                                 \
         (ULONG)((i_bScale - i_b) & sign_mask));                    \
                                                                    \
    the_flags_copy |= r_flags | g_flags | b_flags;                  \
    (flags) = the_flags_copy;                                       \
}


#define __GL_SCALE_AND_CHECK_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, flags, \
                                        r, g, b, a)\
{                                                                   \
    ULONG sign_mask = 0x80000000;                                   \
    __GLfloat rScale, gScale, bScale, aScale;                       \
    LONG i_rScale, i_gScale, i_bScale, i_aScale;                    \
    LONG i_r, i_g, i_b, i_a;                                        \
    __GLfloat fr, fg, fb, fa;                                       \
    ULONG the_flags_copy, r_flags, g_flags, b_flags, a_flags;       \
                                                                    \
    the_flags_copy = (flags);                                       \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
    aScale = (gc)->alphaVertexScale;                                \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
    i_aScale = CASTINT((gc)->alphaVertexScale);                     \
                                                                    \
    fr = (r) * rScale;                                              \
    fg = (g) * gScale;                                              \
    fb = (b) * bScale;                                              \
    fa = (a) * aScale;                                              \
                                                                    \
    rOut = fr;                                                      \
    gOut = fg;                                                      \
    bOut = fb;                                                      \
    aOut = fa;                                                      \
                                                                    \
    i_r = CASTINT((rOut));                                          \
    i_g = CASTINT((gOut));                                          \
    i_b = CASTINT((bOut));                                          \
    i_a = CASTINT((aOut));                                          \
                                                                    \
    r_flags =                                                       \
        ((ULONG)(i_r & sign_mask) |                                 \
         (ULONG)((i_rScale - i_r) & sign_mask));                    \
                                                                    \
    g_flags =                                                       \
        ((ULONG)(i_g & sign_mask) |                                 \
         (ULONG)((i_gScale - i_g) & sign_mask));                    \
                                                                    \
    b_flags =                                                       \
        ((ULONG)(i_b & sign_mask) |                                 \
         (ULONG)((i_bScale - i_b) & sign_mask));                    \
                                                                    \
    a_flags =                                                       \
        ((ULONG)(i_a & sign_mask) |                                 \
         (ULONG)((i_aScale - i_a) & sign_mask));                    \
                                                                    \
    the_flags_copy |= r_flags | g_flags | b_flags | a_flags;        \
    (flags) = the_flags_copy;                                       \
}

#endif // NOT _X86_


/************************************************************************/

/* Applies to current context */
extern void FASTCALL __glSetError(GLenum code);
#ifdef NT
/* Used when no RC is current */
extern void FASTCALL __glSetErrorEarly(__GLcontext *gc, GLenum code);
#endif // NT

extern void FASTCALL __glFreeEvaluatorState(__GLcontext *gc);
extern void FASTCALL __glFreeDlistState(__GLcontext *gc);
extern void FASTCALL __glFreeMachineState(__GLcontext *gc);
extern void FASTCALL __glFreePixelState(__GLcontext *gc);
extern void FASTCALL __glFreeTextureState(__GLcontext *gc);

extern void FASTCALL __glInitDlistState(__GLcontext *gc);
extern void FASTCALL __glInitEvaluatorState(__GLcontext *gc);
extern void FASTCALL __glInitPixelState(__GLcontext *gc);
extern void FASTCALL __glInitTextureState(__GLcontext *gc);
extern void FASTCALL __glInitTransformState(__GLcontext *gc);

void FASTCALL __glEarlyInitContext(__GLcontext *gc);
void FASTCALL __glContextSetColorScales(__GLcontext *gc);
void FASTCALL __glContextUnsetColorScales(__GLcontext *gc);
void FASTCALL __glSoftResetContext(__GLcontext *gc);
void FASTCALL __glDestroyContext(__GLcontext *gc);

#endif /* __glcontext_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\eval.h ===
#ifndef	__glevaluator_h_
#define	__glevaluator_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.5 $
** $Date: 1993/11/23 21:33:10 $
*/
#include "types.h"

/* XXX Can this be changed? */
#define __GL_MAX_ORDER		40

/* Number of maps */
#define __GL_MAP_RANGE_COUNT	9

#define __GL_EVAL1D_INDEX(old)		((old) - GL_MAP1_COLOR_4)
#define __GL_EVAL2D_INDEX(old)		((old) - GL_MAP2_COLOR_4)

/* Evaluator Flag Macros */
#define GET_EVALSTATE(gc)                                        \
    ((gc)->eval.evalStateFlags)

#define GET_EVALSTATE_PTR(gc)                                    \
    (&((gc)->eval.evalStateFlags))

#define SET_EVALSTATE(gc,Flag)                                   \
    ((gc)->eval.evalStateFlags = (DWORD)(Flag))

/* Evaluator Stack State Macros */
#define GET_EVALSTACKSTATE(gc)                                    \
    ((gc)->eval.evalStackState)

#define GET_EVALSTACKSTATE_PTR(gc)                                \
    (&((gc)->eval.evalStackState))

#define SET_EVALSTACKSTATE(gc,Flag)                               \
    ((gc)->eval.evalStackState= (DWORD)(Flag))

// Flags set by various API for indicating the Evaluator State.
#define __EVALS_AFFECTS_1D_EVAL              0x00000001
#define __EVALS_AFFECTS_2D_EVAL              0x00000002
#define __EVALS_AFFECTS_ALL_EVAL             0x00000004
#define __EVALS_PUSH_EVAL_ATTRIB             0x00000008
#define __EVALS_POP_EVAL_ATTRIB              0x00000010


/* Largest Grid Size */
#define __GL_MAX_EVAL_WIDTH		1024

/* internal form of map range indexes */
#define __GL_C4		__GL_EVAL1D_INDEX(GL_MAP1_COLOR_4)
#define __GL_I		__GL_EVAL1D_INDEX(GL_MAP1_INDEX)
#define __GL_N3		__GL_EVAL1D_INDEX(GL_MAP1_NORMAL)
#define __GL_T1		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_1)
#define __GL_T2		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_2)
#define __GL_T3		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_3)
#define __GL_T4		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_4)
#define __GL_V3		__GL_EVAL1D_INDEX(GL_MAP1_VERTEX_3)
#define __GL_V4		__GL_EVAL1D_INDEX(GL_MAP1_VERTEX_4)

#define EVAL_COLOR_VALID              0x00000001
#define EVAL_NORMAL_VALID             0x00000002
#define EVAL_TEXTURE_VALID            0x00000004

typedef struct {
    /*
    ** not strictly necessary since it can be inferred from the index,
    ** but it makes the code simpler.
    */
    GLint k;		

    /*
    ** Order of the polynomial + 1
    */
    GLint order;

    __GLfloat u1, u2;
} __GLevaluator1;

typedef struct {
    GLint k;
    GLint majorOrder, minorOrder;
    __GLfloat u1, u2;
    __GLfloat v1, v2;
} __GLevaluator2;

typedef struct {
    __GLfloat start;
    __GLfloat finish;
    __GLfloat step;
    GLint n;
} __GLevaluatorGrid;

typedef struct {
    __GLevaluatorGrid u1, u2, v2;
} __GLevaluatorState;

typedef struct {
    __GLevaluator1 eval1[__GL_MAP_RANGE_COUNT];
    __GLevaluator2 eval2[__GL_MAP_RANGE_COUNT];

    __GLfloat *eval1Data[__GL_MAP_RANGE_COUNT];
    __GLfloat *eval2Data[__GL_MAP_RANGE_COUNT];

    __GLfloat uvalue;
    __GLfloat vvalue;
    __GLfloat ucoeff[__GL_MAX_ORDER];
    __GLfloat vcoeff[__GL_MAX_ORDER];
    __GLfloat ucoeffDeriv[__GL_MAX_ORDER];
    __GLfloat vcoeffDeriv[__GL_MAX_ORDER];
    GLint uorder;
    GLint vorder;
    GLint utype;
    GLint vtype;

    // Currently 16 bits long because that is the 
    // maximum attribute stack depth.
    // The right-end is the stack-top
    // This field is used to keep track of PushAttrib/PopAttrib calls
    // that affect the Evaluator state.

    DWORD evalStackState;

    // This field is used to keep track of calls that can potentially
    // that affect the Evaluator state. If any of the flags are set, 
    // a glsbAttention() call is made in the affected Evaluator client
    // side functions.

    DWORD evalStateFlags;
  
    // These are used to store the respective state values in POLYDATA 
    // if they have been set by a not evaluator call (glcltColor, 
    // glcltNormal etc.)

    DWORD accFlags;
    __GLcolor color;
    __GLcoord normal;
    __GLcoord texture;
} __GLevaluatorMachine;

extern void __glCopyEvaluatorState(__GLcontext *gc, __GLattribute *dst,
				   const __GLattribute *src);

extern GLint FASTCALL __glEvalComputeK(GLenum target);

extern void APIPRIVATE __glFillMap1f(GLint k, GLint order, GLint stride,
			  const GLfloat *points, __GLfloat *data);
extern void APIPRIVATE __glFillMap1d(GLint k, GLint order, GLint stride,
			  const GLdouble *points, __GLfloat *data);
extern void APIPRIVATE __glFillMap2f(GLint k, GLint majorOrder, GLint minorOrder,
			  GLint majorStride, GLint minorStride,
			  const GLfloat *points, __GLfloat *data);
extern void APIPRIVATE __glFillMap2d(GLint k, GLint majorOrder, GLint minorOrder,
			  GLint majorStride, GLint minorStride,
			  const GLdouble *points, __GLfloat *data);

#ifdef NT
#define __glMap1_size(k,order)	((k)*(order))
#define __glMap2_size(k,majorOrder,minorOrder)	((k)*(majorOrder)*(minorOrder))
#else
extern GLint FASTCALL __glMap1_size(GLint k, GLint order);
extern GLint FASTCALL __glMap2_size(GLint k, GLint majorOrder, GLint minorOrder);
#endif


extern __GLevaluator1 *__glSetUpMap1(__GLcontext *gc, GLenum type,
				     GLint order, __GLfloat u1, __GLfloat u2);
extern __GLevaluator2 *__glSetUpMap2(__GLcontext *gc, GLenum type,
				     GLint majorOrder, GLint minorOrder,
				     __GLfloat u1, __GLfloat u2,
				     __GLfloat v1, __GLfloat v2);

extern void __glDoEvalCoord1(__GLcontext *gc, __GLfloat u);
extern void __glDoEvalCoord2(__GLcontext *gc, __GLfloat u, __GLfloat v);

extern void FASTCALL __glEvalMesh1Line(__GLcontext *gc, GLint low, GLint high);
extern void FASTCALL __glEvalMesh1Point(__GLcontext *gc, GLint low, GLint high);
extern void __glEvalMesh2Fill(__GLcontext *gc, GLint lowU, GLint lowV,
			      GLint highU, GLint highV);
extern void __glEvalMesh2Line(__GLcontext *gc, GLint lowU, GLint lowV,
			      GLint highU, GLint highV);
extern void __glEvalMesh2Point(__GLcontext *gc, GLint lowU, GLint lowV,
			       GLint highU, GLint highV);

#endif /* __glevaluator_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\feedback.h ===
#ifndef __glfeedback_h_
#define __glfeedback_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.2 $
** $Date: 1992/10/06 16:22:36 $
*/
#include "types.h"

typedef struct {
    /*
    ** The user specified result array overflows, this bit is set.
    */
    GLboolean overFlowed;

    /*
    ** User specified result array.  As primitives are processed feedback
    ** data will be entered into this array.
    */
    GLfloat *resultBase;

    /*
    ** Current pointer into the result array.
    */
    GLfloat *result;

    /*
    ** The number of GLfloat's that the array can hold.
    */
    GLint resultLength;

    /*
    ** Type of vertices wanted
    */
    GLenum type;
} __GLfeedbackMachine;

extern void FASTCALL __glFeedbackBitmap(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glFeedbackDrawPixels(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glFeedbackCopyPixels(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glFeedbackPoint(__GLcontext *gc, __GLvertex *v);
#ifdef NT
extern void FASTCALL __glFeedbackLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, GLuint flags);
#else
extern void FASTCALL __glFeedbackLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif
extern void FASTCALL __glFeedbackTriangle(__GLcontext *gc, __GLvertex *a, 
                                          __GLvertex *b, __GLvertex *c);

extern void __glFeedbackTag(__GLcontext *gc, GLfloat tag);

#endif /* __glfeedback_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\devlock.h ===
/******************************Module*Header*******************************\
* Module Name: devlock.h
*
* Created: 12-Apr-1994 19:45:42
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

// Engine helper functions to grab/release display semaphore and to
// teardown/restore the cursor.

extern BOOL APIENTRY glsrvGrabLock(__GLGENcontext *gengc);
extern VOID APIENTRY glsrvReleaseLock(__GLGENcontext *gengc);

extern BOOL APIENTRY glsrvGrabSurfaces(__GLGENcontext *gengc,
                                       GLGENwindow *pwnd,
                                       FSHORT surfBits);
extern VOID APIENTRY glsrvReleaseSurfaces(__GLGENcontext *gengc,
                                          GLGENwindow *pwnd,
                                          FSHORT surfBits);
extern void APIENTRY glsrvSynchronizeWithGdi(__GLGENcontext *gengc,
                                             GLGENwindow *pwnd,
                                             FSHORT surfBits);
extern void APIENTRY glsrvDecoupleFromGdi(__GLGENcontext *gengc,
                                          GLGENwindow *pwnd,
                                          FSHORT surfBits);

/******************************Public*Routine******************************\
*
* glsrvLazyGrabSurfaces
*
* Indicates a need for all surfaces whose bits are set in the flags
* word.  If the locking code determined that a lock was needed for
* that surface and the lock isn't currently held, the lock is taken.
*
* History:
*  Fri May 30 18:17:27 1997	-by-	Gilman Wong [gilmanw]
*   Created
*
\**************************************************************************/

__inline BOOL glsrvLazyGrabSurfaces(__GLGENcontext *gengc,
                                    FSHORT surfBits)
{
    BOOL bRet = TRUE;

    if (((gengc->fsGenLocks ^ gengc->fsLocks) & surfBits) != 0)
    {
        bRet = glsrvGrabSurfaces(gengc, gengc->pwndLocked, surfBits);
    }

    return bRet;
}

//
// Provide wrappers for DirectDraw surface locking and unlocking so
// that lock tracking can be done on debug builds.
//
// #define VERBOSE_DDSLOCK

#if !defined(DBG) || !defined(VERBOSE_DDSLOCK)
#define DDSLOCK(pdds, pddsd, flags, prect) \
    ((pdds)->lpVtbl->Lock((pdds), (prect), (pddsd), (flags), NULL))
#define DDSUNLOCK(pdds, ptr) \
    ((pdds)->lpVtbl->Unlock((pdds), (ptr)))
#else
HRESULT dbgDdsLock(LPDIRECTDRAWSURFACE pdds, DDSURFACEDESC *pddsd,
                   DWORD flags, char *file, int line);
HRESULT dbgDdsUnlock(LPDIRECTDRAWSURFACE pdds, void *ptr,
                     char *file, int line);
#define DDSLOCK(pdds, pddsd, flags, prect) \
    dbgDdsLock(pdds, pddsd, flags, __FILE__, __LINE__)
#define DDSUNLOCK(pdds, ptr) \
    dbgDdsUnlock(pdds, ptr, __FILE__, __LINE__)
#endif

extern DWORD gcmsOpenGLTimer;

//#define BATCH_LOCK_TICKMAX  99
//#define TICK_RANGE_LO       60
//#define TICK_RANGE_HI       100
extern DWORD BATCH_LOCK_TICKMAX;
extern DWORD TICK_RANGE_LO;
extern DWORD TICK_RANGE_HI;

#define GENERIC_BACKBUFFER_ONLY(gc) \
      ( ((gc)->state.raster.drawBuffer == GL_BACK ) &&\
        ((gc)->state.pixel.readBuffer == GL_BACK ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\constant.h ===
#ifndef __glconstants_h_
#define __glconstants_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** Some pixel code depends upon this constant in deciding what the longest
** horizontal span of a DrawPixels command can possibly be.  With 2048, it
** is allocating an array of size 32K.  If this constant increases too much,
** then the pixel code might need to be revisited.
*/
#define __GL_MAX_MAX_VIEWPORT		16384

/*
** The following is the maximum number of __GLcolor structures to allocate on
** the stack.  It is set to keep a maximum of 1K bytes allocated on the stack
*/
#define __GL_MAX_STACKED_COLORS         64

#endif /* __glconstants_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\cpu.h ===
#ifndef __glcpu_h_
#define __glcpu_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** CPU dependent constants.
*/

#include <float.h>
#include <math.h>

#define __GL_BITS_PER_BYTE	8
#define __GL_STIPPLE_MSB	1

#define __GL_FLOAT_MANTISSA_BITS	23
#define __GL_FLOAT_MANTISSA_SHIFT	0
#define __GL_FLOAT_EXPONENT_BIAS	127
#define __GL_FLOAT_EXPONENT_BITS	8
#define __GL_FLOAT_EXPONENT_SHIFT	23
#define __GL_FLOAT_SIGN_SHIFT		31
#define __GL_FLOAT_MANTISSA_MASK (((1 << __GL_FLOAT_MANTISSA_BITS) - 1) << __GL_FLOAT_MANTISSA_SHIFT)
#define __GL_FLOAT_EXPONENT_MASK (((1 << __GL_FLOAT_EXPONENT_BITS) - 1) << __GL_FLOAT_EXPONENT_SHIFT)

// If the MSB of a FP number is known then float-to-int conversion
// becomes a simple shift and mask
// The value must be positive
#define __GL_FIXED_FLOAT_TO_INT(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS-(shift)))-1) | \
     (1 << (__GL_FLOAT_MANTISSA_BITS-(shift))))

// Same as above except without the MSB, which can be useful
// for getting unbiased numbers when the bias is only the MSB
// The value must be positive
#define __GL_FIXED_FLOAT_TO_INT_NO_MSB(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS-(shift)))-1))

// Produces the fixed-point form
// The value must be positive
#define __GL_FIXED_FLOAT_TO_FIXED(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS))-1) | \
     (1 << (__GL_FLOAT_MANTISSA_BITS)))

#define __GL_FIXED_FLOAT_TO_FIXED_NO_MSB(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS))-1))

// The fixed-point fraction as an integer
// The value must be positive
#define __GL_FIXED_FLOAT_FRACTION(flt, shift) \
    (*(LONG *)&(flt) & ((1 << (shift))-1))

// Converts the fixed-point form to an IEEE float, but still typed
// as an int because a cast to float would cause the compiler to do
// an int-float conversion
// The value must be positive
#define __GL_FIXED_TO_FIXED_FLOAT(fxed, shift) \
    ((fxed) & ((1 << (__GL_FLOAT_MANTISSA_BITS))-1) | \
     ((__GL_FLOAT_EXPONENT_BIAS+(shift)) << __GL_FLOAT_EXPONENT_SHIFT))
      
// On the x86, it's faster to do zero compares with an integer cast
// than it is to do the fcomp.
// In the case of the equality test there is only a check for
// +0.  IEEE floats can also be -0, so great care should be
// taken not to use the zero test unless missing this case is
// unimportant
//
// Additionally, FP compares are faster as integers

// These operations work for all normalized FP numbers, -0 included
#ifdef _X86_
#define __GL_FLOAT_GTZ(flt)             (*(LONG *)&(flt) > 0)
#define __GL_FLOAT_LTZ(flt)             (*(ULONG *)&(flt) > 0x80000000)
#define __GL_FLOAT_GEZ(flt)             (*(ULONG *)&(flt) <= 0x80000000)
#define __GL_FLOAT_LEZ(flt)             (*(LONG *)&(flt) <= 0)
#define __GL_FLOAT_EQZ(flt)             ((*(ULONG *)&(flt) & 0x7fffffff) == 0)
#define __GL_FLOAT_NEZ(flt)             ((*(ULONG *)&(flt) & 0x7fffffff) != 0)
#define __GL_FLOAT_COMPARE_PONE(flt, op) (*(LONG *)&(flt) op 0x3f800000)
#else
#define __GL_FLOAT_GTZ(flt)             ((flt) > __glZero)
#define __GL_FLOAT_LTZ(flt)             ((flt) < __glZero)
#define __GL_FLOAT_GEZ(flt)             ((flt) >= __glZero)
#define __GL_FLOAT_LEZ(flt)             ((flt) <= __glZero)
#define __GL_FLOAT_EQZ(flt)             ((flt) == __glZero)
#define __GL_FLOAT_NEZ(flt)             ((flt) != __glZero)
#define __GL_FLOAT_COMPARE_PONE(flt, op) ((flt) op __glOne)
#endif // _X86_

// These operations only account for positive zero.  -0 will not work
#ifdef _X86_
#define __GL_FLOAT_EQPZ(flt)            (*(LONG *)&(flt) == 0)
#define __GL_FLOAT_NEPZ(flt)            (*(LONG *)&(flt) != 0)
#define __GL_FLOAT_EQ(f1, f2)           (*(LONG *)&(f1) == *(LONG *)&(f2))
#define __GL_FLOAT_NE(f1, f2)           (*(LONG *)&(f1) != *(LONG *)&(f2))
#else
#define __GL_FLOAT_EQPZ(flt)            ((flt) == __glZero)
#define __GL_FLOAT_NEPZ(flt)            ((flt) != __glZero)
#define __GL_FLOAT_EQ(f1, f2)           ((f1) == (f2))
#define __GL_FLOAT_NE(f1, f2)           ((f1) != (f2))
#endif // _X86_

// Macro to start an FP divide in the FPU, used to overlap a
// divide with integer operations
// Can't just use C because it stores the result immediately
#ifdef _X86_

#define __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    __asm fld num \
    __asm fdiv den
#define __GL_FLOAT_SIMPLE_END_DIVIDE(result) \
    __asm fstp DWORD PTR result

__inline void __GL_FLOAT_BEGIN_DIVIDE(__GLfloat num, __GLfloat den,
                                      __GLfloat *result)
{
    __asm fld num
    __asm fdiv den
}
__inline void __GL_FLOAT_END_DIVIDE(__GLfloat *result)
{
    __asm mov eax, result
    __asm fstp DWORD PTR [eax]
}
#else
#define __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    ((result) = (num)/(den))
#define __GL_FLOAT_SIMPLE_END_DIVIDE(result)
#define __GL_FLOAT_BEGIN_DIVIDE(num, den, result) (*(result) = (num)/(den))
#define __GL_FLOAT_END_DIVIDE(result)
#endif // _X86_

//**********************************************************************
//
// Math helper functions and macros
//
//**********************************************************************

#define CASTFIX(a)              (*((LONG *)&(a)))
#define CASTINT(a)              CASTFIX(a)
#define CASTFLOAT(a)            (*((__GLfloat *)&(a)))

#define FLT_TO_RGBA(ul, pColor) \
    (ul) =\
    (((ULONG)(FLT_TO_UCHAR_SCALE(pColor->a, GENACCEL(gc).aAccelPrimScale)) << 24) | \
     ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->r, GENACCEL(gc).rAccelPrimScale)) << 16) | \
     ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->g, GENACCEL(gc).gAccelPrimScale)) << 8)  | \
     ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->b, GENACCEL(gc).bAccelPrimScale))))

#define FLT_TO_CINDEX(ul, pColor) \
    (ul) =\
    ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->r, GENACCEL(gc).rAccelPrimScale)) << 16)

#ifdef _X86_

#pragma warning(disable:4035) // Function doesn't return a value

// Convert float to int 15.16
__inline LONG __fastcall FLT_TO_FIX(
    float a)
{
    LARGE_INTEGER li;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 08000000h
        mov     a, eax
        fld     a
        fistp   li
        mov     eax, DWORD PTR li
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 15.16, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_TO_FIX(
    float a)
{
    LONG l;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 08000000h
        mov     a, eax
        fld     a
        fistp   l
        mov     eax, l
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31
__inline LONG __fastcall FLT_FRACTION(
    float a)
{
    LARGE_INTEGER li;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 0f800000h
        mov     a, eax
        fld     a
        fistp   li
        mov     eax, DWORD PTR li
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_FRACTION(
    float a)
{
    LONG l;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 0f800000h
        mov     a, eax
        fld     a
        fistp   l
        mov     eax, l
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

#pragma warning(default:4035) // Function doesn't return a value

// Convert float*scale to int
__inline LONG __fastcall FLT_TO_FIX_SCALE(
    float a,
    float b)
{
    LARGE_INTEGER li;

    __asm {
        fld     a
        fmul    b
        fistp   li
    }

    return li.LowPart;
}

#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)FLT_TO_FIX_SCALE(value_in, scale))

__inline LONG __fastcall FTOL(
    float a)
{
    LARGE_INTEGER li;

    _asm {
        fld     a
        fistp   li
    }

    return li.LowPart;
}

// Can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FTOL(
    float a)
{
    LONG l;

    _asm {
        fld     a
        fistp   l
    }

    return l;
}

// Requires R-G-B to be FP stack 2-1-0
// Requires gc in edx
#define FLT_STACK_RGB_TO_GC_FIXED(rOffset, gOffset, bOffset)	              \
    __asm fld __glVal65536						      \
    __asm fmul st(3), st(0)						      \
    __asm fmul st(2), st(0)						      \
    __asm fmulp st(1), st(0)						      \
    __asm fistp DWORD PTR [edx+bOffset]					      \
    __asm fistp DWORD PTR [edx+gOffset]					      \
    __asm fistp DWORD PTR [edx+rOffset]					      

#define FPU_SAVE_MODE()                 \
    DWORD cwSave;                       \
    DWORD cwTemp;                       \
                                        \
    __asm {                             \
        _asm fnstcw  WORD PTR cwSave    \
        _asm mov     eax, cwSave        \
        _asm mov     cwTemp, eax        \
    }

#define FPU_RESTORE_MODE()              \
    __asm {                             \
        _asm fldcw   WORD PTR cwSave    \
    }

#define FPU_RESTORE_MODE_NO_EXCEPTIONS()\
    __asm {                             \
        _asm fnclex                     \
        _asm fldcw   WORD PTR cwSave    \
    }

#define FPU_CHOP_ON()                    \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm or     eax, 0x0c00          \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_ROUND_ON()                   \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax,0xf3ff           \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_ROUND_ON_PREC_HI()           \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax,0xf0ff           \
        _asm or     eax,0x0200           \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_PREC_LOW()                   \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax, 0xfcff          \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_PREC_LOW_MASK_EXCEPTIONS()   \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax, 0xfcff          \
        _asm or     eax, 0x3f            \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_CHOP_ON_PREC_LOW()          \
    __asm {                             \
        _asm mov    eax, cwTemp         \
        _asm or     eax, 0x0c00         \
        _asm and    eax, 0xfcff         \
        _asm mov    cwTemp, eax         \
        _asm fldcw  WORD PTR cwTemp     \
    }

#define FPU_CHOP_OFF_PREC_HI()          \
    __asm {                             \
        _asm mov    eax, cwTemp         \
        _asm mov    ah, 2               \
        _asm mov    cwTemp, eax         \
        _asm fldcw  WORD PTR cwTemp     \
    }

#define CHOP_ROUND_ON()		
#define CHOP_ROUND_OFF()

#if DBG
#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm {                     \
            __asm fnstcw cw         \
        }                           \
        ASSERTOPENGL((cw & 0xc00) == 0xc00, "Chop round must be on\n"); \
    }
#else
#define ASSERT_CHOP_ROUND()
#endif

#else // _X86_

#define FTOL(value) \
    ((GLint)(value))
#define UNSAFE_FTOL(value) \
    FTOL(value)
#define FLT_TO_FIX_SCALE(value_in, scale) \
    ((GLint)((__GLfloat)(value_in) * scale))
#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)((GLint)((__GLfloat)(value_in) * scale)))
#define FLT_TO_FIX(value_in) \
    ((GLint)((__GLfloat)(value_in) * FIX_SCALEFACT))
#define UNSAFE_FLT_TO_FIX(value_in) \
    FLT_TO_FIX(value_in)
#define FLT_FRACTION(f) \
    FTOL((f) * __glVal2147483648)
#define UNSAFE_FLT_FRACTION(f) \
    FLT_FRACTION(f)

#define FPU_SAVE_MODE()
#define FPU_RESTORE_MODE()
#define FPU_RESTORE_MODE_NO_EXCEPTIONS()
#define FPU_CHOP_ON()
#define FPU_ROUND_ON()
#define FPU_ROUND_ON_PREC_HI()
#define FPU_PREC_LOW()
#define FPU_PREC_LOW_MASK_EXCEPTIONS()
#define FPU_CHOP_ON_PREC_LOW()
#define FPU_CHOP_OFF_PREC_HI()
#define CHOP_ROUND_ON()
#define CHOP_ROUND_OFF()
#define ASSERT_CHOP_ROUND()

#endif  //_X86_

//**********************************************************************
//
// Fast math routines/macros.  These may assume that the FPU is in
// single-precision, truncation mode as defined by the CPU_XXX macros.
//
//**********************************************************************

#ifdef _X86_

__inline float __gl_fast_ceilf(float f)
{
    LONG i;

    ASSERT_CHOP_ROUND();
    
    i = FTOL(f + ((float)1.0 - (float)FLT_EPSILON));

    return (float)i;
}

__inline float __gl_fast_floorf(float f)
{
    LONG i;

    ASSERT_CHOP_ROUND();

    if (__GL_FLOAT_LTZ(f)) {
        i = FTOL(f - ((float)1.0 - (float)FLT_EPSILON));
    } else {
        i = FTOL(f);
    }

    return (float)i;
}

__inline LONG __gl_fast_floorf_i(float f)
{
    ASSERT_CHOP_ROUND();

    if (__GL_FLOAT_LTZ(f)) {
        return FTOL(f - ((float)1.0 - (float)FLT_EPSILON));
    } else {
        return FTOL(f);
    }
}

#define __GL_FAST_FLOORF_I(f)  __gl_fast_floorf_i(f)
#define __GL_FAST_FLOORF(f)  __gl_fast_floorf(f)
#define __GL_FAST_CEILF(f)   __gl_fast_ceilf(f)

#else

#define __GL_FAST_FLOORF_I(f)  ((GLint)floor((double) (f)))
#define __GL_FAST_FLOORF(f)  ((__GLfloat)floor((double) (f)))
#define __GL_FAST_CEILF(f)   ((__GLfloat)ceil((double) (f)))

#endif


//**********************************************************************
//
// Other various macros:
//
//**********************************************************************


// Z16_SCALE is the same as FIX_SCALEFACT
#define FLT_TO_Z16_SCALE(value) FLT_TO_FIX(value)

/* NOTE: __glzValue better be unsigned */
#define __GL_Z_SIGN_BIT(z) \
    ((z) >> (sizeof(__GLzValue) * __GL_BITS_PER_BYTE - 1))

#ifdef NT
#define __GL_STIPPLE_MSB	1
#endif /* NT */

#endif /* __glcpu_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\dlist.h ===
#ifndef __gldlist_h_
#define __gldlist_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list state descriptions.
**
*/
#include "os.h"
#include "types.h"

typedef const GLubyte * FASTCALL __GLlistExecFunc(__GLcontext *gc, const GLubyte *);

/* 
** Maximum recursive nesting of display list calls.
*/
#define __GL_MAX_LIST_NESTING		64

//
// Turn on list sharing for NT if we're a client/server implementation
//
#ifdef NT
#define NT_SERVER_SHARE_LISTS
#endif

#ifndef NT
/* 
** Machine specific opcodes should start here.  All opcodes lower than 
** this are reserved by the generic code.
*/
#define __GL_MACHINE_DLIST_OPCODE	10000

typedef void (FASTCALL *__GLdlistFreeProc)(__GLcontext *gc, GLubyte *);

/*
** A compiled, unoptimized dlist.  Conceptually a linked list of operations.
** An optimizer may work through the operations and delete, add, or change 
** them.
**
** These are only stored transiently.  They are created, optimized, and 
** converted into optimized dlists.
**
** This structure *MUST* be set up so that data is doubleword aligned!
*/
struct __GLdlistOpRec {
    __GLdlistOp *next;		/* Linked list chain */
    __GLdlistFreeProc dlistFree;
				/* This dlist free function is called when
				** the entire dlist is freed.  It is passed
				** a pointer to data.  It should *not* free
				** data, but only any memory that has been
				** allocated and is pointed to by the
				** structure contained in data (which will
				** be freed after this function returns).
				*/ 
    GLuint size;		/* Actual size of data */
    GLshort opcode;		/* Opcode for this operation */
    GLboolean aligned;		/* GL_TRUE if data needs to be doubleword 
				** aligned.
				*/
    GLboolean pad1;		/* Padding */
    GLubyte data[4];		/* Variable size */
};

typedef struct __GLcompiledDistRec {
    GLint freeCount;		/* Number of free functions defined */
    GLuint genericFlags;	/* Flags needed by generic optimizers */
    GLuint machineFlags;	/* Machine controlled flags */
    __GLdlistOp *dlist;		/* The linked list of operations */
    __GLdlistOp *lastDlist;	/* For quick appends */
} __GLcompiledDlist;

typedef struct __GLDlistFreeFnRec {
    __GLdlistFreeProc freeFn;
    GLubyte *data;
} __GLDlistFreeFn;
#endif // !NT

/* 
** A fully optimized dlist.  One of these is stored for every permanent
** dlist.
**
** NOTE: 'head' is assumed to start at word offset, but NOT a double word
** offset!
*/
typedef struct __GLdlistRec __GLdlist;
struct __GLdlistRec {
    GLuint refcount;	/* To deal with multi-threading, must be first */
    GLuint size;	/* Total size of this block */
#ifndef NT
    GLint freeCount;	/* Number of operations */
    __GLDlistFreeFn *freeFns;	/* Array of functions called before freeing */
#endif
    GLubyte *end;	/* End of optimized block */
#ifdef NT
#if 0
    GLint drawBuffer;   /* Contains DrawBuffer calls or not,
                           used for optimizing lock checking in
                           DCLDispatchLoop */
#endif
    GLuint used;        /* Amount of space used in the list so far */
    __GLdlist *nextBlock; /* Next block in chain of blocks */
#if 0
    GLuint pad;         /* Pad to put head on a word offset */
#endif
#endif // NT
    GLubyte head[4];	/* Optimized block (variable size) */
};

#ifdef NT
// Adds on overhead bytes for a given dlist op data size
// Currently the only overhead is four bytes for the function pointer
#define DLIST_SIZE(n) ((n)+sizeof(__GLlistExecFunc *))
#define DLIST_GENERIC_OP(name) __glle_##name
#else
#define DLIST_SIZE(n) (n)
#define DLIST_GENERIC_OP(name) __glop_##name
#define DLIST_OPT_OP(name) __glop_##name
#endif

#ifndef NT
/*
** Some data structure for storing and retrieving display lists quickly.
** This structure is kept hidden so that a new implementation can be used
** if desired.
*/
typedef struct __GLdlistArrayRec __GLdlistArray;
#endif

typedef struct __GLdlistMachineRec {
#ifndef NT
    __GLdlistArray *dlistArray;
#endif
    __GLnamesArray *namesArray;

#ifndef NT
    /*
    ** The optimizer for the display list.  Runs through a __GLcompiledDlist
    ** and deletes, changes, adds operations.  Presumably, this optimizer
    ** will be a set of function calls to other optimizers (some provided
    ** by the generic dlist code, some by machine specific code).
    **
    ** Operations created by the machine specific optimizers need to have
    ** opcodes starting with __GL_MACHINE_DLIST_OPCODE.
    */
    void (FASTCALL *optimizer)(__GLcontext *gc, __GLcompiledDlist *);

    /*
    ** This routine is called before puting each new command into the 
    ** display list at list compilation time.
    */
    void (FASTCALL *checkOp)(__GLcontext *gc, __GLdlistOp *);
#endif
    
    /*
    ** This routine is called when a new display list is about to be 
    ** compiled.
    */
    void (FASTCALL *initState)(__GLcontext *gc);

#ifndef NT
    /* 
    ** Array of functions pointers used for display list execution of 
    ** generic ops.
    */
    __GLlistExecFunc **baseListExec;

    /* 
    ** Array of functions pointers used for display list execution of 
    ** generic optimizations.
    */
    __GLlistExecFunc **listExec;

    /*
    ** The machine specific list execution routines.  These function
    ** pointers are bound into the display list at list compilation time,
    ** so it is illegal to be changing these dynamically based upon the 
    ** machine state.  Any optimizations based upon the current state need
    ** to be performed in the machine specific code.  The first entry of
    ** this array corresponds to opcode __GL_MACHINE_DLIST_OPCODE, and 
    ** subsequent entries correspond to subsequent opcodes.
    **
    ** machineListExec is a pointer to an array of function pointers.
    */
    __GLlistExecFunc **machineListExec;
#endif

    /*
    ** If a list is being executed (glCallList or glCallLists) then this
    ** is the current nesting of calls.  It is constrained by the limit
    ** __GL_MAX_LIST_NESTING (this prevents infinite recursion).
    */
    GLint nesting;

    /*
    ** GL_COMPILE or GL_COMPILE_AND_EXECUTE.
    */
    GLenum mode;

    /*
    ** List being compiled - 0 means none.
    */
    GLuint currentList;

#ifdef NT
    /* Points to the current begin record when compiling poly array */
    struct __gllc_Begin_Rec *beginRec;

    /* Skip compiling of the next PolyData when compiling poly array */
    GLboolean skipPolyData;
#endif

#if 0
#ifdef NT
    // Whether the current list contains a DrawBuffer call or not
    GLboolean drawBuffer;
#endif
#endif

#ifndef NT
    /*
    ** Data for the current list being compiled.
    */
    __GLcompiledDlist listData;

    /*
    ** For fast memory manipulation.  Check out soft/so_memmgr for details.
    */
    __GLarena *arena;
#else
    /*
    ** Data for current list
    */
    __GLdlist *listData;
#endif
} __GLdlistMachine;

#ifndef NT
extern void FASTCALL__glDestroyDisplayLists(__GLcontext *gc);
#endif
#ifdef NT_SERVER_SHARE_LISTS
extern GLboolean FASTCALL __glCanShareDlist(__GLcontext *gc, __GLcontext *share_cx);
#endif
extern void FASTCALL __glShareDlist(__GLcontext *gc, __GLcontext *share_cx);

// Perform thread-exit cleanup for dlists
#ifdef NT_SERVER_SHARE_LISTS
extern void __glDlistThreadCleanup(__GLcontext *gc);
#endif

/*
** Assorted routines needed by dlist compilation routines.
*/

/* 
** Create and destroy display list ops.  __glDlistAllocOp2() sets an
** out of memory error before returning NULL if there is no memory left.
*/
#ifndef NT
extern __GLdlistOp *__glDlistAllocOp(__GLcontext *gc, GLuint size);
extern __GLdlistOp *__glDlistAllocOp2(__GLcontext *gc, GLuint size);
extern void FASTCALL __glDlistFreeOp(__GLcontext *gc, __GLdlistOp *op);

/*
** Append the given op to the currently under construction list.
*/
extern void FASTCALL __glDlistAppendOp(__GLcontext *gc, __GLdlistOp *newop,
                                       __GLlistExecFunc *listExec);
#else
extern __GLdlist *__glDlistGrow(GLuint size);
#endif

/*
** Create and destroy optimized display lists.
*/
extern __GLdlist *__glAllocDlist(__GLcontext *gc, GLuint size);
extern void FASTCALL __glFreeDlist(__GLcontext *gc, __GLdlist *dlist);

#ifndef NT
/*
** Generic dlist memory manager.
*/
extern void *__glDlistAlloc(GLuint size);
extern void *__glDlistRealloc(void *oldmem, GLuint oldsize, GLuint newsize);
extern void FASTCALL __glDlistFree(void *memory, GLuint size);

/*
** Generic table of display list execution routines.
*/
extern __GLlistExecFunc *__glListExecTable[];
#endif

#endif /* __gldlist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\gencx.h ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#ifndef __GLGENCONTXT_H__
#define __GLGENCONTXT_H__

#include "context.h"
#ifdef _MCD_
#include <winddi.h>
#include "mcdrv.h"
#include "mcd2hack.h"
#include "mcd.h"
#endif

// Re-enable long to float conversion warning.  see also context.h
#pragma warning (default:4244)

#ifdef _CLIENTSIDE_
#include "glscreen.h"
#include "glgenwin.h"
#endif

#ifdef _MCD_
#include "mcdcx.h"
#endif

/*
 * Define maximum color-index table size
 */

#define MAXPALENTRIES   4096

/*
 *  Machine dependent implementation limits
 *  (stolen from gfx/lib/opengl/LIGHT/rexcx.h)
 */

#define __GL_WGL_SUBPIXEL_BITS                  3

#define __GL_WGL_NUMBER_OF_CLIP_PLANES          6
#define __GL_WGL_NUMBER_OF_LIGHTS               8
#define __GL_WGL_NUMBER_OF_TEXTURES             1
#define __GL_WGL_NUMBER_OF_TEXTURE_ENVS         1

#define __GL_WGL_MAX_MODELVIEW_STACK_DEPTH      32
#define __GL_WGL_MAX_PROJECTION_STACK_DEPTH     10
#define __GL_WGL_MAX_TEXTURE_STACK_DEPTH        10
#define __GL_WGL_MAX_ATTRIB_STACK_DEPTH         16
#define __GL_WGL_MAX_CLIENT_ATTRIB_STACK_DEPTH  16
#define __GL_WGL_MAX_NAME_STACK_DEPTH           128
#define __GL_WGL_MAX_EVAL_ORDER                 30
#define __GL_WGL_MAX_MIPMAP_LEVEL               11
#define __GL_WGL_MAX_PIXEL_MAP_TABLE            65536
#define __GL_WGL_MAX_LIST_NESTING               64

#define __GL_WGL_POINT_SIZE_MINIMUM             ((__GLfloat) 0.5)
#define __GL_WGL_POINT_SIZE_MAXIMUM             ((__GLfloat) 10.0)
#define __GL_WGL_POINT_SIZE_GRANULARITY         ((__GLfloat) 0.125)

#define __GL_WGL_LINE_WIDTH_MINIMUM             ((__GLfloat) 0.5)
#define __GL_WGL_LINE_WIDTH_MAXIMUM             ((__GLfloat) 10.0)
#define __GL_WGL_LINE_WIDTH_GRANULARITY         ((__GLfloat) 0.125)

// Constants for fast accelerated texture code...

#define TEX_SCALEFACT	        ((float)65536.0)
#define TEX_SCALESHIFT          16
#define TEX_SHIFTPER4BPPTEXEL   2
#define TEX_SHIFTPER2BPPTEXEL   1
#define TEX_SHIFTPER1BPPTEXEL   0
#define TEX_T_FRAC_BITS         6
#define TEX_SUBDIV              8
#define TEX_SUBDIV_LOG2         3

// This is the largest size we support in the software-accelerated
// perspective-corrected texture code.  This allows 8.6 representation for
// s and t, which permits shifting by constant values in the inner loop.
// Note that the maximum size for paletted textures is greater than for
// RGBA textures, since the number of address bits is smaller (1 byte vs
// 4 bytes).

#define TEX_MAX_SIZE_LOG2      10

#define __GL_MAX_INV_TABLE     31

#define __GL_UNBIAS_AND_INVERT_Y(gc, y) \
        ((gc)->constants.height - __GL_UNBIAS_Y((gc), (y)))

// XXX do we need to add .5?
#define __GL_COLOR_TO_COLORREF(color) \
        RGB( (BYTE)((color)->r), (BYTE)((color)->g), (BYTE)((color)->b))

typedef struct __RenderStateRec {

    GLuint *SrvSelectBuffer;            // Server side address of
                                        // the selection buffer.
    GLuint *CltSelectBuffer;            // Client address of the
                                        // Selection buffer
    GLuint SelectBufferSize;            // Size of select buffer in bytes
    GLfloat *SrvFeedbackBuffer;         // Server side address of the
                                        // feedback buffer
    GLfloat *CltFeedbackBuffer;         // Client side address of the
                                        // Feedback buffer.
    GLuint FeedbackBufferSize;          // Size of the feedback buffer
    GLenum FeedbackType;                // Type of elements for feedback


} __RenderState;

typedef BOOL (APIENTRY *PIXVISPROC)(LONG, LONG);
typedef void (*PIXCOPYPROC)(struct __GLGENcontextRec *, __GLcolorBuffer *, 
                            GLint, GLint, GLint, BOOL);

/****************************************************************************/


typedef struct _SPANREC {
    LONG r;
    LONG g;
    LONG b;
    LONG a;
    ULONG z;
    LONG s;
    LONG t;
} SPANREC;

typedef struct __GLGENcontextRec __GLGENcontext;

typedef void (FASTCALL *__genSpanFunc)(__GLGENcontext *gc);

typedef ULONG (FASTCALL *__computeColorFunc)(__GLcontext *gc,
                                             __GLcolor *color);

typedef struct _GENTEXCACHE {
    __GLcontext *gc;
    ULONG paletteTimeStamp;
    UCHAR *texImageReplace;
    GLenum internalFormat;
    LONG height;
    LONG width;
} GENTEXCACHE;

typedef GLboolean (FASTCALL *fastGenLineProc)(__GLcontext *gc);

typedef struct _GENACCEL {
    //
    // stuff below here is used in the rendering inner loops
    //

    ULONG constantR;        // These are used for scaling texture color values
    ULONG constantG;
    ULONG constantB;
    ULONG constantA;
    SPANREC spanValue;
    SPANREC spanDelta;
    ULONG rAccum;
    ULONG gAccum;
    ULONG bAccum;
    ULONG aAccum;
    ULONG sAccum;
    ULONG tAccum;
    ULONG sResult[2];
    ULONG tResult[2];
    ULONG sResultNew[2];
    ULONG tResultNew[2];
    ULONG sStepX;
    ULONG tStepX;
    ULONG subDs;
    ULONG subDt;
    ULONG pixAccum;
    ULONG ditherAccum;
    __GLfloat qwStepX;
    __GLfloat qwAccum;
    ULONG zAccum;
    PBYTE pPix;
    BYTE displayColor[4];
    __genSpanFunc __fastSpanFuncPtr;

    //
    // stuff below here is used in the FillTriangle routine
    //

    SPANREC spanDeltaY;
    int xMultiplier;
    __genSpanFunc __fastFlatSpanFuncPtr;
    __genSpanFunc __fastSmoothSpanFuncPtr;
    __genSpanFunc __fastTexSpanFuncPtr;
    __GLspanFunc __fastZSpanFuncPtr;
    __GLspanFunc __fastStippleDepthTestSpan;
    __GLfloat rAccelScale;          // Span scale values
    __GLfloat gAccelScale;
    __GLfloat bAccelScale;
    __GLfloat aAccelScale;
    __GLfloat zScale;

    void (FASTCALL *__fastFillSubTrianglePtr)(__GLcontext *, GLint, GLint);
    void (FASTCALL *__fastCalcDeltaPtr)(__GLcontext *gc, __GLvertex *a,
                                        __GLvertex *b, __GLvertex *c);
    void (*__fastSetInitParamPtr)(__GLcontext *gc,
                                  const __GLvertex *a,
                                 __GLfloat dx,
                                 __GLfloat dy);
    //
    // these things are used in the generic rendering or texture path
    //
    int bpp;
    ULONG flags;
    ULONG tShift;
    ULONG sMask, tMask;
    ULONG *texImage;
    ULONG *texPalette;
    ULONG tMaskSubDiv;
    ULONG tShiftSubDiv;
    __GLfloat texXScale;
    __GLfloat texYScale;

    UCHAR *texImageReplace;
    __GLtexture *tex;
    GLboolean (FASTCALL *__fastGenZStore)(__GLzValue z, __GLzValue *fp);
    fastGenLineProc __fastGenLineProc;
    BOOL (FASTCALL *__fastGenInitLineData)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);

    //
    // stuff below here is not used in drawing triangles
    //

    char *buffer;
    FLONG flLineAccelModes;
    BOOL bFastLineDispAccel;
    BOOL bFastLineDIBAccel;
    __computeColorFunc fastLineComputeColor;
    BYTE *pFastLineBuffer;
    POINT *pFastLinePoint;
    DWORD *pFastLineCount;
    DWORD fastLineCounts;
    __GLfloat fastLineOffsetX;
    __GLfloat fastLineOffsetY;

    double zDevScale;     // z scaling for MCD

} GENACCEL;

/*
** Secondary dispatch tables for GENENERIC implementation  (eg CPU specific)
*/


// Define the Rendering context used by the Generic implementation
// One of these structures is allocated for each wglCreateContext().  The
// TEB will contain a pointer to this structure after a wglMakeCurrent()
// NOTE: the TEB will also have a pointer to DispatchTables, if we need
// another entry on the server side, reuse that one.  Could generate code to
// offset into contextRec to get a tables.
typedef struct __GLGENcontextRec
{
    // Must be first entry
    struct __GLcontextRec gc;

    HGLRC hrc;                          // handle from gdi code
    GLWINDOWID gwidCurrent;             // Surface made current
    DWORD dwCurrentFlags;               // GLSURF flags for current surface
    GLDDSURF *pgddsFront;               // Current DirectDraw surface for
                                        // front buffer

    GLuint flags;                       // misc. state flags

    // Window that this context was made current to.  Set in MakeCurrent and
    // kept to validate that attentions are taking place on the same
    // window as was made current.
    GLGENwindow *pwndMakeCur;
    
    // Window that this context current is holding a lock on.  While
    // locked, this must always match pwndMakeCur.  When outside the
    // lock it will be NULL.  Any context-derived window access must
    // use this field rather than pwndMakeCur to ensure that access
    // only takes place while the window lock is held.
    GLGENwindow *pwndLocked;
    
    GLint WndUniq;
    GLint WndSizeUniq;
    ULONG PaletteTimestamp;
    GLint errorcode;

                                        // info for render DC, surface
    GLSURF gsurf;
    int ipfdCurrent;

    BYTE *pajTranslateVector;		// Used for Logical <--> System xlate
    BYTE *pajInvTranslateVector;
    HBITMAP ColorsBitmap;		// GDI dibs for device managed surfs
    PVOID ColorsBits;
    HBITMAP StippleBitmap;
    PVOID StippleBits;
#ifdef _CLIENTSIDE_
    HDC ColorsMemDC;
    HDC ColorsDdbDc;
    HBITMAP ColorsDdb;
#endif

    // Cached GDI objects for rectangle filling and line drawing
    HBRUSH hbrFill;
    COLORREF crFill;
    HDC hdcFill;
    HPEN hpenStroke;
    __GLcolor cStroke;
    COLORREF crStroke;
    HDC hdcStroke;
    BOOL fStrokeInvalid;
    
    // A COLORREF value which isn't a legal COLORREF, used for marking
    // the caches as empty
#define COLORREF_UNUSED 0xffffffff

    __RenderState RenderState;

    VOID *pPrivateArea;                 // Pointer to implementation-specific
                                        // memory area.

    GENACCEL genAccel;                  // Always have this handy...
    BYTE xlatPalette[256];              // goes here to save indirection

    GLint visibleWidth;
    GLint visibleHeight;

    // Information so that OpenGL can adaptively change the amount of
    // time the lock is held.

    DWORD dwLockTick;                   // tick count when lock was acquired

    DWORD dwCalls;                      // tracks number of calls for this tick
    DWORD dwCallsPerTick;               // number of calls per tick allowed
    DWORD dwLastTick;                   // last recorded tick count

    // Locks held by OpenGL while drawing to this context (see values
    // below).

    FSHORT fsGenLocks;                  // locks needed for generic code
    FSHORT fsLocks;                     // locks actually held

    HANDLE hTexture;                    // current texture handle

    PIXCOPYPROC pfnCopyPixels;
    PIXVISPROC pfnPixelVisible;

#ifdef _CLIENTSIDE_
    // Pointers to LOGPALETTE buffers.  The pointer ppalBuf is storage for
    // for two maximally sized (MAXPALENTRIES) LOGPALETTEs.  One, pointed
    // to by ppalSave, is a copy of the last LOGPALETTE used.  The other,
    // pointed to by ppalTmp, is used for temporary storage of the current
    // LOGPALETTE.  To keep the saved copy current, rather than copy the
    // contents of the temp buffer, the two pointers are swapped.
    //
    // We need to do this comparison to detect LOGPALETTE changes to maintain
    // the window ulPaletteUniq when doing >= 16bpp color index-mode drawing
    // (WM_PALETTECHANGED messages are not sent for this case).
    //
    // The LOGPALETTE pointers are NULL if pixelformat is RGBA or < 16bpp.

    LOGPALETTE *ppalBuf;                // Room for both save and tmp buffers.
    LOGPALETTE *ppalSave;               // Saved copy of LOGPALETTE
    LOGPALETTE *ppalTemp;               // Temp storage for current LOGPALETTE

    // In addition, if we are rendering to a 4bpp or 8bpp DIB, we need to
    // track changes in the DIB color table.  In this case, the ppalBuf
    // buffer also includes room for two 256-entry RGBQUAD tables.

    ULONG   crgbSave;                   // Num of valid entries in color table
    RGBQUAD *prgbSave;                  // Saved copy of color table
    ULONG   crgbTemp;
    RGBQUAD *prgbTemp;                  // Temp storage for color table

#endif

#ifdef _MCD_
    // MCD state

    GENMCDSTATE   *_pMcdState;      // pointer to MCD context/state

    GENMCDSTATE   *pMcdState;       // pointer to bound MCD context/state
                                    // (implies both _pMcdState and pMcdSurf
                                    // valid; i.e., valid MCD context is
                                    // bound to a valid MCD surface)

    LONG iLayerPlane;
#endif
    // Add other rc info here

} __GLGENcontext;

/*
 * Mark the gc as dirty so that pick procs will be executed when
 * __glGenericPickAllProcs is called (probably via gc->proc.pickAllProcs).
 */
#define __GL_INVALIDATE(gc)                 \
    (gc)->dirtyMask |= __GL_DIRTY_GENERIC

/*
 * __GLGENcontext flags
 *
 *  GLGEN_MCD_CONVERTED_TO_GENERIC      context used to be MCD, but now
 *                                      converted to generic
 *
 *  GENGC_MCD_BGR_INTO_RGB              fake 233BGR format to appear internally
 *                                      as 332RGB (more 332RGB fast path code)
 *
 *  GENGC_GENERIC_COMPATIBLE_FORMAT     pixel format is compatible with
 *                                      generic code (see in pixelfmt.c
 *                                      GenMcdGenericCompatibleFormat)
 */
#define GLGEN_MCD_CONVERTED_TO_GENERIC      0x0001
#define GENGC_MCD_BGR_INTO_RGB              0x0002
#define GENGC_GENERIC_COMPATIBLE_FORMAT     0x0004

/*
 * Error codes
 */
#define GLGEN_NO_ERROR          0
#define GLGEN_OUT_OF_MEMORY     1
#define GLGEN_GRE_FAILURE       2
#define GLGEN_DEVLOCK_FAILED    3

/*
 * Locks that can be held during operation.
 *
 *      Value               Description
 *      ------------------------------------------------------------------
 *      LOCKFLAG_WINDOW         Window information semaphore.
 *      LOCKFLAG_MCD            MCD lock.
 *      LOCKFLAG_FRONT_BUFFER   Primary surface lock.
 *      LOCKFLAG_DD_DEPTH       DirectDraw depth buffer surface lock.
 *      LOCKFLAG_DD_TEXTURE     DirectDraw texture mipmap surface locks.
 *
 * __GLGENcontext.fsLocks indicates the locks currently held by the context.
 * __GLGENcontext.fsGenLocks indicates the locks that need to be held
 * if generic code is going to be executed.  The two fields allow
 * lazy acquisition of locks by deferring actual locking until just
 * before generic code is executed.
 *
 */
#define LOCKFLAG_WINDOW         0x0001
#define LOCKFLAG_MCD            0x0002
#define LOCKFLAG_FRONT_BUFFER   0x0004
#define LOCKFLAG_DD_DEPTH       0x0008
#define LOCKFLAG_DD_TEXTURE     0x0010

// All lock flags that can be lazily acquired.
#define LAZY_LOCK_FLAGS \
    (LOCKFLAG_MCD | LOCKFLAG_FRONT_BUFFER | LOCKFLAG_DD_DEPTH | \
     LOCKFLAG_DD_TEXTURE)

// All lock flags for surfaces.
#define SURFACE_LOCK_FLAGS \
    (LOCKFLAG_FRONT_BUFFER | LOCKFLAG_DD_DEPTH | LOCKFLAG_DD_TEXTURE)

// All lock flags for color buffer access.
#define COLOR_LOCK_FLAGS        (LOCKFLAG_MCD | LOCKFLAG_FRONT_BUFFER)

// All lock flags for depth buffer access.
#define DEPTH_LOCK_FLAGS        (LOCKFLAG_MCD | LOCKFLAG_DD_DEPTH)

// All lock flags for texture access.
#define TEXTURE_LOCK_FLAGS      LOCKFLAG_DD_TEXTURE

// Accesses required for fragment rendering.
#define RENDER_LOCK_FLAGS       (COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS | \
                                 TEXTURE_LOCK_FLAGS)

/*
 * Screen lock testing functions.  GDI drawing calls should not be made
 * when the screen lock is held.  These are for
 * use on a checked (debug system) to assert the state of the lock.
 */
#if DBG
#define GENGC_LOCK \
    (((__GLGENcontext *)GLTEB_SRVCONTEXT())->fsLocks)
#define PWNDFLAGS \
    ((((__GLGENcontext *)GLTEB_SRVCONTEXT())->pwndLocked)->ulFlags)
#define CHECKSCREENLOCKOUT() \
    ASSERTOPENGL(GLTEB_SRVCONTEXT() == NULL || \
                 !(GENGC_LOCK & LOCKFLAG_FRONT_BUFFER) || \
                 !(PWNDFLAGS & GLGENWIN_DIRECTSCREEN), \
                 "Screen lock held\n")

#define CHECKSCREENLOCKIN() \
    ASSERTOPENGL(GLTEB_SRVCONTEXT() != NULL && \
                 (GENGC_LOCK & LOCKFLAG_FRONT_BUFFER) && \
                 (PWNDFLAGS & GLGENWIN_DIRECTSCREEN), \
                 "Screen lock not held\n")
#else
#define CHECKSCREENLOCKOUT()
#define CHECKSCREENLOCKIN()
#endif

/*
 * Structure to keep track of ancillary buffers for a window/drawable
 * All RCs/threads must share the ancillary buffers, including fake back buffer
 */

typedef struct __GLGENbitmapRec {
    GLGENwindow *pwnd; // This must be the first member in this structure
    GLGENwindow wnd;
    HBITMAP hbm;
    HDC hdc;
    PVOID pvBits;
} __GLGENbitmap;

#define CURRENT_DC_CFB(cfb)     ((cfb)->bitmap->hdc)
#define CURRENT_DC              CURRENT_DC_CFB(cfb)
#define CURRENT_DC_GC(gc)       CURRENT_DC_CFB(gc->drawBuffer)
#define CURRENT_DC_FRONT_GC(gc) CURRENT_DC_CFB(gc->front)

/*
 * Structure used to cache clip rectangles enumerated from window clip region.
 */

typedef struct __GLGENclipCacheRec {
    GLint WndUniq;
    GLint crcl;
    RECTL *prcl;
} __GLGENclipCache;

/****************************************************************************/

// Make sure this header file is loaded, it contains the rectlist definition.

#include "srvp.h"

/****************************************************************************/

// Comment it out if the __glDoPolygonClip stack allocation fix is not
// wanted
#define __CLIP_FIX

#ifdef __CLIP_FIX
#define __GL_TOTAL_CLIP_PLANES 20   /*XXX*/
#define __GL_MAX_CLIP_VERTEX (__GL_TOTAL_CLIP_PLANES + __GL_MAX_POLYGON_CLIP_SIZE)
#endif

/*
 * This structure contains the buffers shared by all gc's using the
 * same window.
 */

struct __GLGENbuffersRec {

// Global (within this structure) state.

    GLint WndUniq;
    GLint WndSizeUniq;
    GLint flags;
    GLint width, height;

// Ancillary buffers and state.

// The ancillary buffers are lazily created.  The createdXBuffer flags
// indicate one of two states: FALSE means that the lazy allocation
// function has never been called, TRUE means that it has.  What this
// allows us to do, in the event of an ancillary buffer allocation
// failure, is temporarily disable the ancillary buffer and continue to
// render.  At some later time, the createdXBuffer flag serves as an
// indication that the buffer SHOULD exist and that we may need to try
// and retry the allocation.
//
// The stencil, depth, accum, and color bits must match the corresponding
// bits in the context.  Otherwise, glsrvMakeCurrent should not succeed.

    GLboolean  createdStencilBuffer;
    GLboolean  createdDepthBuffer;
    GLboolean  createdAccumBuffer;
    GLint      stencilBits;
    GLint      depthBits;
    GLint      accumBits;
    GLint      colorBits;
    __GLbuffer stencilBuffer;
    __GLbuffer depthBuffer;
    __GLbuffer accumBuffer;
    GLint      alphaBits;
    __GLbuffer alphaBuffer0;
    __GLbuffer alphaBuffer1;
    __GLbuffer *alphaFrontBuffer;
    __GLbuffer *alphaBackBuffer;

// Back buffer.

    __GLbuffer backBuffer;
    __GLGENbitmap backBitmap;

// Ancillary buffer resize functions.

    GLboolean (*resize)(__GLGENbuffers *, __GLbuffer *,  GLint, GLint);
    GLboolean (*resizeDepth)(__GLGENbuffers *, __GLbuffer *,  GLint, GLint);

// Clip rectangle cache.

    __GLGENclipCache clip;

    // dirty regions data

    PXLIST pxlist;                      // free lists
    PYLIST pylist;

    RECTLIST rl;                        // SwapBuffers Hint Region
    BOOL fMax;                          // should we blt the entire window?

#ifdef _MCD_
// MCD surface.

    GENMCDSURFACE *pMcdSurf;            // pointer MCD surface
    GENMCDSTATE *pMcdState;             // pointer to current MCD state
                                        // holding McdSurf for rendering
                                        // (i.e., holds the window lock)
#endif

#ifdef __CLIP_FIX 
    __GLvertex *clip_verts[__GL_TOTAL_CLIP_PLANES][__GL_MAX_CLIP_VERTEX];
#endif
};

/* flags */
#define GLGENBUF_HAS_BACK_BUF       0x0001
#define GLGENBUF_MCD_LOST           0x0002

/****************************************************************************/

void RECTLISTAddRect(PRECTLIST prl, int xs, int ys, int xe, int ye);
void RECTLISTSetEmpty(PRECTLIST prl);
BOOL RECTLISTIsEmpty(PRECTLIST prl);
void YLISTFree(__GLGENbuffers *buffers, PYLIST pylist);
void XLISTFree(__GLGENbuffers *buffers, PXLIST pxlist);

/****************************************************************************/

/* colorbuffer flags */
#define COLORMASK_ON    0x0001          // glColorMask() not all true for r,g,b
#define INDEXMASK_ON    0x0001          // glIndexMask() not all 1's
#define DIB_FORMAT      0x0002          // surface is DIB format
#define NEED_FETCH   	0x0004          // fetch required
#define MEMORY_DC       0x0008          // set if DIB in memory (ie !display)
#define NO_CLIP         0x0010          // Set if surface never requires clip
#define ALPHA_ON        0x0020          // have alphaBits, alphaMask is true
#define ALPHA_IN_PIXEL_BIT  0x0040      // alpha is part of the pixel

#define ALPHA_WRITE_ENABLED( cfb ) \
    ( (cfb)->buf.flags & ALPHA_ON ) 

// These next macros take into account the fact that alpha values can either be
// part of the pixel (e.g. MCD color buffer), or are kept in a separate software
// buffer (generic software implementation).  They are mostly used by the span
// routines in genrgb.c to determine where to store/fetch alpha values.

#define ALPHA_IN_PIXEL( cfb ) \
    ( (cfb)->buf.flags & ALPHA_IN_PIXEL_BIT ) 

#define ALPHA_BUFFER_WRITE( cfb ) \
    (((cfb)->buf.flags & (ALPHA_ON | ALPHA_IN_PIXEL_BIT)) == ALPHA_ON)
     
#define ALPHA_PIXEL_WRITE( cfb ) \
    (((cfb)->buf.flags & (ALPHA_ON | ALPHA_IN_PIXEL_BIT)) == \
     (ALPHA_ON | ALPHA_IN_PIXEL_BIT))


/*
 * Structures and flags for accelerated span and line functions.
 */

#define SURFACE_TYPE_DIB     0x001
#define HAVE_STIPPLE         0x002

#define GEN_TEXTURE_ORTHO    0x008
#define GEN_TEXTURE          0x010
#define GEN_RGBMODE          0x020
#define GEN_DITHER           0x040
#define GEN_SHADE            0x080
#define GEN_FASTZBUFFER      0x100
#define GEN_LESS             0x200

#define ACCEL_FIX_SCALE         65536.0
#define ACCEL_COLOR_SCALE       ((GLfloat)(255.0))
#define ACCEL_COLOR_SCALE_FIX   ((GLfloat)(65536.0 * 255.0))

// Overall size of fast line buffer
#define __FAST_LINE_BUFFER_SIZE 65536
// Number of polyline counts reserved in the fast line buffer
// This is computed to roughly handle lines with eight vertices
#define __FAST_LINE_BUFFER_COUNTS (__FAST_LINE_BUFFER_SIZE/64)

#define GENACCEL(gc)	(((__GLGENcontext *)gc)->genAccel)

BOOL FASTCALL __glGenCreateAccelContext(__GLcontext *gc);
void FASTCALL __glGenDestroyAccelContext(__GLcontext *gc);

#define Copy3Bytes( dst, src ) \
{ \
    GLubyte *ps = (GLubyte *)src, *pd = (GLubyte *)dst;	\
    *pd++ = *ps++;	\
    *pd++ = *ps++;	\
    *pd   = *ps  ;      \
}
    
#define NeedLogicOpFetch( op ) \
    !( (op == GL_CLEAR) || (op == GL_COPY) || (op == GL_COPY_INVERTED) || \
       (op == GL_SET) )

GLuint FASTCALL DoLogicOp( GLenum logicOp, GLuint SrcColor, GLuint DstColor );

/*
 * Function Prototypes for Generic calls
 */
void FASTCALL __fastGenPickSpanProcs(__GLcontext *gc);
void FASTCALL __fastGenPickZStoreProc(__GLcontext *gc);
void FASTCALL __fastGenPickTriangleProcs(__GLcontext *gc);
void FASTCALL __fastGenPickLineProcs(__GLcontext *gc);
void FASTCALL __fastGenFillSubTriangle(__GLcontext *, GLint, GLint);
void FASTCALL __fastGenFillSubTriangleTexRGBA(__GLcontext *, GLint, GLint);
void FASTCALL __glGenPickStoreProcs(__GLcontext *gc);
__GLcontext *__glGenCreateContext( HDC hdc, ULONG handle);
void ResizeBitmapBuffer(__GLGENbuffers *, __GLcolorBuffer *, GLint, GLint);
void FASTCALL ClearBitmapBuffer(__GLcolorBuffer *);
void UpdateSharedBuffer(__GLbuffer *to, __GLbuffer *from);
void FASTCALL LazyAllocateDepth(__GLcontext *gc);
void FASTCALL LazyAllocateAccum(__GLcontext *gc);
void FASTCALL LazyAllocateStencil(__GLcontext *gc);
void FASTCALL glGenInitCommon(__GLGENcontext *gengc, __GLcolorBuffer *cfb, GLenum type);
BOOL FASTCALL wglCreateScanlineBuffers(__GLGENcontext *gengc);
VOID FASTCALL wglDeleteScanlineBuffers(__GLGENcontext *gengc);
VOID FASTCALL wglInitializeColorBuffers(__GLGENcontext *gengc);
VOID FASTCALL wglInitializeDepthBuffer(__GLGENcontext *gengc);
VOID FASTCALL wglInitializePixelCopyFuncs(__GLGENcontext *gengc);
GLboolean ResizeAncillaryBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);
GLboolean ResizeUnownedDepthBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);
VOID wglResizeBuffers(__GLGENcontext *gengc, GLint width, GLint height);
BOOL wglUpdateBuffers(__GLGENcontext *gengc, __GLGENbuffers *buffers);

extern void APIPRIVATE glsrvFlushDrawPolyArray(struct _POLYARRAY *, BOOL);

MCDHANDLE FASTCALL __glGenLoadTexture(__GLcontext *gc, __GLtexture *tex, ULONG flags);
BOOL FASTCALL __glGenUpdateTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey);
void FASTCALL __glGenFreeTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey);
BOOL FASTCALL __glGenMakeTextureCurrent(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey);
void FASTCALL __glGenUpdateTexturePalette(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey,
                                          ULONG start, ULONG count);
#ifdef GL_EXT_flat_paletted_lighting
void FASTCALL __glGenSetPaletteOffset(__GLcontext *gc, __GLtexture *tex,
                                      GLint offset);
#endif

/*
 * Function Prototypes and Externs for accelerated generic calls
 */

extern __genSpanFunc __fastGenRGBFlatFuncs[];
extern __genSpanFunc __fastGenCIFlatFuncs[];
extern __genSpanFunc __fastGenRGBFuncs[];
extern __genSpanFunc __fastGenCIFuncs[];
extern __genSpanFunc __fastGenTexDecalFuncs[];
extern __genSpanFunc __fastGenTexFuncs[];
extern __genSpanFunc __fastGenWTexDecalFuncs[];
extern __genSpanFunc __fastGenWTexFuncs[];
extern __genSpanFunc __fastPerspTexReplaceFuncs[];
extern __genSpanFunc __fastPerspTexPalReplaceFuncs[];
extern __genSpanFunc __fastPerspTexFlatFuncs[];
extern __genSpanFunc __fastPerspTexSmoothFuncs[];

extern __GLspanFunc __fastDepthFuncs[];
extern __GLspanFunc __fastDepth16Funcs[];

extern void FASTCALL __fastGenDeltaSpan(__GLcontext *gc, SPANREC *spanDelta);
extern void FASTCALL __fastGenFillTriangle(__GLcontext *gc, __GLvertex *a, 
                                  __GLvertex *b, __GLvertex *c, GLboolean ccw);

extern void FASTCALL __fastLineComputeOffsets(__GLGENcontext *gengc);

extern void FASTCALL __fastGenRenderLineDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);

extern void gdiCopyPixels(__GLGENcontext *, __GLcolorBuffer *, GLint, GLint,
                          GLint, BOOL);

extern void dibCopyPixels(__GLGENcontext *, __GLcolorBuffer *, GLint, GLint,
                          GLint, BOOL);

typedef void (FASTCALL *PFNZIPPYSUB)(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTRGBTex(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTTex(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTRGB(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTCI(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTZ(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTCI8Flat(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __fastGenSpan(__GLGENcontext *gengc);

GLboolean FASTCALL __fastGenStippleLt32Span(__GLcontext *gc);
GLboolean FASTCALL __fastGenStippleLt16Span(__GLcontext *gc);
GLboolean FASTCALL __fastGenStippleAnyDepthTestSpan(__GLcontext *gc);

extern BYTE gbMulTable[];
extern BYTE gbSatTable[];
extern DWORD ditherShade[];
extern DWORD ditherTexture[];
extern __GLfloat invTable[];

extern __GLfloat fDitherIncTable[]; // defined in genrgb.c

void FASTCALL __glGenFreeBuffers( __GLGENbuffers *buffers );

#endif /* __GLGENCONTXT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\glmath.h ===
#ifndef __glmath_h_
#define __glmath_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1993/01/06 19:02:47 $
*/
#include "types.h"

__GLfloat __glLog2(__GLfloat x);
GLint FASTCALL __glIntLog2(__GLfloat f);
GLfloat FASTCALL __glClampf(GLfloat fval, __GLfloat zero, __GLfloat one);
void FASTCALL __glVecSub4(__GLcoord *r,
                          const __GLcoord *p1, const __GLcoord *p2);

#endif /* __glmath_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\image.h ===
#ifndef _image_h_
#define _image_h_

/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.2 $
** $Date: 1992/10/06 16:22:55 $
*/

extern GLint APIPRIVATE __glImageSize(GLsizei width, GLsizei height, GLenum format, 
			   GLenum type);

extern void APIPRIVATE __glFillImage(__GLcontext *gc, GLsizei width, GLsizei height, 
			  GLenum format, GLenum type, const GLvoid *userdata, 
			  GLubyte *newimage);

extern void __glEmptyImage(__GLcontext *gc, GLsizei width, GLsizei height, 
			   GLenum format, GLenum type, const GLubyte *oldimage, 
			   GLvoid *userdata);

extern GLubyte __glMsbToLsbTable[256];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\fixed.h ===
#ifndef __glfixed_h_
#define __glfixed_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "cpu.h"

/*
** These constants in this file must be valid for all adapters using
** these macros and code which uses these macros.
**
** These should be equal
*/
#define __GL_MAX_WINDOW_SIZE_LOG2       14
#define __GL_MAX_WINDOW_WIDTH	        (1 << __GL_MAX_WINDOW_SIZE_LOG2)
#define __GL_MAX_WINDOW_HEIGHT	        __GL_MAX_WINDOW_WIDTH

/*
** Bias numbers for moving window coordinates into a positive space.
** These values are used during viewport computations.
**
** In our existing code this is only used to provide some buffer room
** in the vertex coordinate space to avoid any errors caused by
** small under- or overflows around the edge of the viewport caused
** by clip inaccuracy.
**
** It must be less than the max window size so that the case of
** a point exactly at the max window value doesn't overflow
** the fixing range
*/
#define __GL_VERTEX_X_BIAS	(1 << (__GL_MAX_WINDOW_SIZE_LOG2-1))
#define __GL_VERTEX_Y_BIAS	__GL_VERTEX_X_BIAS

/* 
** Fixing numbers.  These are used to move the biased window coordinates
** into a range where the number of fraction bits are constant from the
** minimal value in the range to the largest value in the range.
**
** This value should be twice as large as the highest possible window
** coordinate value.  Both values should be the same.
**
** Having the bias in addition to this is important because in
** extreme cases the clipper can generate values slightly outside
** the clip range, due to FP inaccuracy.  A slop bias in addition
** to the real fixing bias makes it impossible to underflow.
*/
#define __GL_VERTEX_FIX_POINT   (__GL_MAX_WINDOW_SIZE_LOG2+1)
#define __GL_VERTEX_X_FIX	(1 << __GL_VERTEX_FIX_POINT)
#define __GL_VERTEX_Y_FIX	__GL_VERTEX_X_FIX

// The addition of the FIX bias to raw window coordinates forces the
// MSB of the window coordinate to always be the same since the FIX
// value is chosen to be the largest power of two greater than any
// possibly window coordinate value.  With the MSB pinned down, the
// floating-point representation of a window coordinates degenerates to
// a fixed-point number since the MSB doesn't change.
//
// We take advantage of this in conversions.

#define __GL_VERTEX_FRAC_BITS \
    (__GL_FLOAT_MANTISSA_BITS-__GL_VERTEX_FIX_POINT)
#define __GL_VERTEX_FRAC_HALF \
    (1 << (__GL_VERTEX_FRAC_BITS-1))
#define __GL_VERTEX_FRAC_ONE \
    (1 << __GL_VERTEX_FRAC_BITS)

// Converts a floating-point window coordinate to integer
#define __GL_VERTEX_FLOAT_TO_INT(windowCoord) \
    __GL_FIXED_FLOAT_TO_INT(windowCoord, __GL_VERTEX_FRAC_BITS)
// To fixed point
#define __GL_VERTEX_FLOAT_TO_FIXED(windowCoord) \
    __GL_FIXED_FLOAT_TO_FIXED(windowCoord)
// And back
#define __GL_VERTEX_FIXED_TO_FLOAT(fxWindowCoord) \
    __GL_FIXED_TO_FIXED_FLOAT(fxWindowCoord, __GL_VERTEX_FRAC_BITS)
// Fixed-point to integer
#define __GL_VERTEX_FIXED_TO_INT(fxWindowCoord) \
    ((fxWindowCoord) >> __GL_VERTEX_FRAC_BITS)

// Returns the fraction from a FP window coordinate as an N
// bit integer, where N depends on the FP mantissa size and the
// FIX size
#define __GL_VERTEX_FLOAT_FRACTION(windowCoord) \
    __GL_FIXED_FLOAT_FRACTION(windowCoord, __GL_VERTEX_FRAC_BITS)

// Scale the fraction to 2^31 for step values
#define __GL_VERTEX_PROMOTE_FRACTION(frac) \
    ((frac) << (31-__GL_VERTEX_FRAC_BITS))
#define __GL_VERTEX_PROMOTED_FRACTION(windowCoord) \
    __GL_VERTEX_PROMOTE_FRACTION(__GL_VERTEX_FLOAT_FRACTION(windowCoord))

// Compare two window coordinates.  Since window coordinates
// are fixed-point numbers, they can be compared directly as
// integers
#define __GL_VERTEX_COMPARE(a, op, b) \
    ((*(LONG *)&(a)) op (*(LONG *)&(b)))

#endif /* __glfixed_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\imports.h ===
#ifndef __glimports_h_
#define __glimports_h_

/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Imports from outside libraries.
**
** $Revision: 1.8 $
** $Date: 1993/12/09 01:57:59 $
*/
#include <memory.h>
#include <math.h>

#if defined(NT)
/*
** MEMMOVE handles overlapping memory (slower)
** MEMCOPY does not handle overlapping memory (faster)
*/

#define __GL_MEMCOPY(to,from,count)	RtlCopyMemory(to,from,(size_t)(count))
#define __GL_MEMMOVE(to,from,count)	RtlMoveMemory(to,from,(size_t)(count))
#define __GL_MEMZERO(to,count)		RtlZeroMemory(to,(size_t)(count))

#else

#define __GL_MEMCOPY(to,from,count)	memcpy(to,from,(size_t)(count))
#define __GL_MEMMOVE(to,from,count)	memmove(to,from,(size_t)(count))
#define __GL_MEMZERO(to,count)		memset(to,0,(size_t)(count))

#endif

#ifdef _ALPHA_
extern float fpow(float, float);
#define __GL_POWF(a,b)			((__GLfloat)fpow((__GLfloat)(a), (__GLfloat)(b)))
#else
#define __GL_POWF(a,b)			((__GLfloat)pow((double)(a),(double)(b)))
#endif
 
#define __GL_CEILF(f)			((__GLfloat)ceil((double) (f)))
#define __GL_SQRTF(f)			((__GLfloat)sqrt((double) (f)))	
#define __GL_ABSF(f)			((__GLfloat)fabs((double) (f)))
#define __GL_FLOORF(f)			((__GLfloat)floor((double) (f)))
#define __GL_FLOORD(f)			floor(f)
#define __GL_SINF(f)			((__GLfloat)sin((double) (f)))
#define __GL_COSF(f)			((__GLfloat)cos((double) (f)))
#define __GL_ATANF(f)			((__GLfloat)atan((double) (f)))
#define __GL_ATAN2F(x, y)		((__GLfloat)atan2((double) (x), (double) (y)))
#define __GL_LOGF(f)			((__GLfloat)log((double) (f)))

#endif /* __glimports_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\glarray.h ===
/******************************Module*Header*******************************\
* Module Name: glarray.h
*
* Vertex array states.
*
* Created: 2-04-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __glarray_h_
#define __glarray_h_

extern GLuint vaEnable[];

typedef struct
{
    GLuint   iIn;
    GLushort next;
} VAMAP;

// Vertex array structures.

typedef void (FASTCALL *PFNVAELEMENTBATCH)
    (__GLcontext *gc, GLint firstIndex, GLint  nVertices);

typedef void (FASTCALL *PFNVAELEMENTBATCHINDIRECT)
    (__GLcontext *gc, GLint  nVertices, VAMAP* indices);

typedef void (FASTCALL *PFNVAELEMENT)(__GLcontext *gc, GLint i);

typedef void (APIENTRY *PFNGLVECTOR)(IN const GLvoid *v);

typedef struct __GLarrayEdgeFlagRec {
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayEdgeFlag;

typedef struct __GLarrayTexCoordRec {
    GLint         size;
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayTexCoord;

typedef struct __GLarrayIndexRec {
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayIndex;

typedef struct __GLarrayColorRec {
    GLint         size;
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayColor;

typedef struct __GLarrayNormalRec {
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayNormal;

typedef struct __GLarrayVertexRec {
    GLint         size;
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayVertex;

// Vertex array states.
typedef struct __GLvertexArrayRec {
    GLuint            flags;
    GLuint            mask;
    PFNVAELEMENT      pfnArrayElement;
    PFNVAELEMENTBATCH pfnArrayElementBatch;
    PFNVAELEMENTBATCHINDIRECT pfnArrayElementBatchIndirect;
    __GLarrayEdgeFlag edgeFlag;
    __GLarrayTexCoord texCoord;
    __GLarrayIndex    index;
    __GLarrayColor    color;
    __GLarrayNormal   normal;
    __GLarrayVertex   vertex;
} __GLvertexArray;

// Vertex array flags.
#define __GL_VERTEX_ARRAY_DIRTY      0x0001

// Mask that encapsulates the current vertex array settings.
// It is maintained in the mask field in __GLvertexArray.
// The mask is given in the following binary form in 24 bits:
//
//    VeVsVsVtVtNeNtNtNtCeCsCtCtCtIeItItItTeTsTsTtTtEe
//    232221201918171615141312111009080706050403020100
//
// where V:vertex pointer,
//       N:normal pointer,
//       C:color pointer,
//       I:index pointer,
//       T:texture coord pointer,
//       E:edge flag pointer,
//       e:enable flag,
//       s:size field,
//       t:type field.

#define VAMASK_EDGEFLAG_ENABLE_SHIFT	0
#define VAMASK_TEXCOORD_TYPE_SHIFT	1
#define VAMASK_TEXCOORD_SIZE_SHIFT	3
#define VAMASK_TEXCOORD_ENABLE_SHIFT	5
#define VAMASK_INDEX_TYPE_SHIFT		6
#define VAMASK_INDEX_ENABLE_SHIFT	9
#define VAMASK_COLOR_TYPE_SHIFT		10
#define VAMASK_COLOR_SIZE_SHIFT		13
#define VAMASK_COLOR_ENABLE_SHIFT	14
#define VAMASK_NORMAL_TYPE_SHIFT	15
#define VAMASK_NORMAL_ENABLE_SHIFT	18
#define VAMASK_VERTEX_TYPE_SHIFT	19
#define VAMASK_VERTEX_SIZE_SHIFT	21
#define VAMASK_VERTEX_ENABLE_SHIFT	23

#define VAMASK_EDGEFLAG_ENABLE_MASK	(1 << VAMASK_EDGEFLAG_ENABLE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_MASK	(3 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_MASK	(3 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_ENABLE_MASK	(1 << VAMASK_TEXCOORD_ENABLE_SHIFT)
#define VAMASK_INDEX_TYPE_MASK		(7 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_ENABLE_MASK	(1 << VAMASK_INDEX_ENABLE_SHIFT)
#define VAMASK_COLOR_TYPE_MASK		(7 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_SIZE_MASK		(1 << VAMASK_COLOR_SIZE_SHIFT)
#define VAMASK_COLOR_ENABLE_MASK	(1 << VAMASK_COLOR_ENABLE_SHIFT)
#define VAMASK_NORMAL_TYPE_MASK		(7 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_ENABLE_MASK	(1 << VAMASK_NORMAL_ENABLE_SHIFT)
#define VAMASK_VERTEX_TYPE_MASK		(3 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_SIZE_MASK		(3 << VAMASK_VERTEX_SIZE_SHIFT)
#define VAMASK_VERTEX_ENABLE_MASK	(1 << VAMASK_VERTEX_ENABLE_SHIFT)

#define VAMASK_EDGEFLAG_TYPE_SIZE_MASK \
    (0)
#define VAMASK_TEXCOORD_TYPE_SIZE_MASK \
    (VAMASK_TEXCOORD_TYPE_MASK | VAMASK_TEXCOORD_SIZE_MASK)
#define VAMASK_INDEX_TYPE_SIZE_MASK \
    (VAMASK_INDEX_TYPE_MASK)
#define VAMASK_COLOR_TYPE_SIZE_MASK \
    (VAMASK_COLOR_TYPE_MASK | VAMASK_COLOR_SIZE_MASK)
#define VAMASK_NORMAL_TYPE_SIZE_MASK \
    (VAMASK_NORMAL_TYPE_MASK)
#define VAMASK_VERTEX_TYPE_SIZE_MASK \
    (VAMASK_VERTEX_TYPE_MASK | VAMASK_VERTEX_SIZE_MASK)

#define VAMASK_TEXCOORD_TYPE_SHORT	(0 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_INT	(1 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_FLOAT	(2 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_DOUBLE	(3 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_1		(0 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_2		(1 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_3		(2 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_4		(3 << VAMASK_TEXCOORD_SIZE_SHIFT)

#define VAMASK_INDEX_TYPE_UBYTE		(0 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_SHORT		(1 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_INT		(2 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_FLOAT		(3 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_DOUBLE	(4 << VAMASK_INDEX_TYPE_SHIFT)

#define VAMASK_COLOR_TYPE_BYTE		(0 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_UBYTE		(1 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_SHORT		(2 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_USHORT	(3 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_INT		(4 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_UINT		(5 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_FLOAT		(6 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_DOUBLE	(7 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_SIZE_3		(0 << VAMASK_COLOR_SIZE_SHIFT)
#define VAMASK_COLOR_SIZE_4		(1 << VAMASK_COLOR_SIZE_SHIFT)

#define VAMASK_NORMAL_TYPE_BYTE		(0 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_SHORT	(1 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_INT		(2 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_FLOAT	(3 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_DOUBLE	(4 << VAMASK_NORMAL_TYPE_SHIFT)

#define VAMASK_VERTEX_TYPE_SHORT	(0 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_TYPE_INT		(1 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_TYPE_FLOAT	(2 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_TYPE_DOUBLE	(3 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_SIZE_2		(0 << VAMASK_VERTEX_SIZE_SHIFT)
#define VAMASK_VERTEX_SIZE_3		(1 << VAMASK_VERTEX_SIZE_SHIFT)
#define VAMASK_VERTEX_SIZE_4		(2 << VAMASK_VERTEX_SIZE_SHIFT)

// Constants used by DrawElements.  Do not modify them because
// glcltDrawElements assumes they have these values!
#define VA_DRAWELEM_MAP_SIZE     	256
#define VA_DRAWELEM_INDEX_SIZE	        (8*VA_DRAWELEM_MAP_SIZE)

// Constants used by DrawRangeElementsEXT : currently these map identically
// with DrawElements constants.
#define VA_DRAWRANGEELEM_MAX_VERTICES    VA_DRAWELEM_MAP_SIZE
#define VA_DRAWRANGEELEM_MAX_INDICES     VA_DRAWELEM_INDEX_SIZE

void FASTCALL __glInitVertexArray(__GLcontext *gc);
void FASTCALL VA_ValidateArrayPointers(__GLcontext *gc);
void FASTCALL VA_DrawElementsBegin(POLYARRAY *pa, GLenum mode, GLsizei count);
void FASTCALL VA_DrawElementsEnd(POLYARRAY *pa);
void FASTCALL VA_DrawElementsFlushPartialPrimitive(POLYARRAY *pa, GLenum mode);

extern GLint nReservedIndicesPartialBegin[];

typedef void (FASTCALL *pfnReducedElementsHandler)
    (__GLcontext *gc, GLenum mode,
     GLsizei iVertexCount, GLsizei iVertexBase, VAMAP *pvmVertices,
     GLsizei iElementCount, GLubyte *pbElements,
     GLboolean fPartial);

void FASTCALL glcltReducedElementsHandler(__GLcontext *gc,
                                          GLenum mode,
                                          GLsizei iVertexCount,
                                          GLsizei iVertexBase,
                                          VAMAP *pvmVertices,
                                          GLsizei iElementCount,
                                          GLubyte *pbElements,
                                          GLboolean fPartial);
void FASTCALL ReduceDrawElements(__GLcontext *gc,
                                 GLenum mode, GLsizei count, GLenum type,
                                 const GLvoid *pIn,
                                 pfnReducedElementsHandler pfnHandler);

#endif // __glarray_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\imfuncs.h ===
#ifndef __glimfuncs_h_
#define __glimfuncs_h_

/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"

extern void APIPRIVATE __glim_NewList(GLuint, GLenum);
extern void APIPRIVATE __glim_EndList(void);
extern void APIPRIVATE __glim_CallList(GLuint);
extern void APIPRIVATE __glim_CallLists(GLsizei, GLenum, const GLvoid *);
extern void APIPRIVATE __glim_DeleteLists(GLuint, GLsizei);
extern GLuint APIPRIVATE __glim_GenLists(GLsizei);
extern void APIPRIVATE __glim_ListBase(GLuint);
extern void APIPRIVATE __glim_DrawPolyArray(void *);
#ifdef NT
extern void APIPRIVATE __glim_Bitmap(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *, GLboolean);
#else
extern void APIPRIVATE __glim_Bitmap(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
#endif
extern void APIPRIVATE __glim_Color3b(GLbyte, GLbyte, GLbyte);
extern void APIPRIVATE __glim_Color3bv(const GLbyte *);
extern void APIPRIVATE __glim_Color3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Color3dv(const GLdouble *);
extern void APIPRIVATE __glim_Color3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Color3fv(const GLfloat *);
extern void APIPRIVATE __glim_Color3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_Color3iv(const GLint *);
extern void APIPRIVATE __glim_Color3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Color3sv(const GLshort *);
extern void APIPRIVATE __glim_Color3ub(GLubyte, GLubyte, GLubyte);
extern void APIPRIVATE __glim_Color3ubv(const GLubyte *);
extern void APIPRIVATE __glim_Color3ui(GLuint, GLuint, GLuint);
extern void APIPRIVATE __glim_Color3uiv(const GLuint *);
extern void APIPRIVATE __glim_Color3us(GLushort, GLushort, GLushort);
extern void APIPRIVATE __glim_Color3usv(const GLushort *);
extern void APIPRIVATE __glim_Color4b(GLbyte, GLbyte, GLbyte, GLbyte);
extern void APIPRIVATE __glim_Color4bv(const GLbyte *);
extern void APIPRIVATE __glim_Color4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Color4dv(const GLdouble *);
extern void APIPRIVATE __glim_Color4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Color4fv(const GLfloat *);
extern void APIPRIVATE __glim_Color4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_Color4iv(const GLint *);
extern void APIPRIVATE __glim_Color4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Color4sv(const GLshort *);
extern void APIPRIVATE __glim_Color4ub(GLubyte, GLubyte, GLubyte, GLubyte);
extern void APIPRIVATE __glim_Color4ubv(const GLubyte *);
extern void APIPRIVATE __glim_Color4ui(GLuint, GLuint, GLuint, GLuint);
extern void APIPRIVATE __glim_Color4uiv(const GLuint *);
extern void APIPRIVATE __glim_Color4us(GLushort, GLushort, GLushort, GLushort);
extern void APIPRIVATE __glim_Color4usv(const GLushort *);
extern void APIPRIVATE __glim_EdgeFlag(GLboolean);
extern void APIPRIVATE __glim_EdgeFlagv(const GLboolean *);
extern void APIPRIVATE __glim_End(void);
extern void APIPRIVATE __glim_Indexd(GLdouble);
extern void APIPRIVATE __glim_Indexdv(const GLdouble *);
extern void APIPRIVATE __glim_Indexf(GLfloat);
extern void APIPRIVATE __glim_Indexfv(const GLfloat *);
extern void APIPRIVATE __glim_Indexi(GLint);
extern void APIPRIVATE __glim_Indexiv(const GLint *);
extern void APIPRIVATE __glim_Indexs(GLshort);
extern void APIPRIVATE __glim_Indexsv(const GLshort *);
extern void APIPRIVATE __glim_Normal3b(GLbyte, GLbyte, GLbyte);
extern void APIPRIVATE __glim_Normal3bv(const GLbyte *);
extern void APIPRIVATE __glim_Normal3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Normal3dv(const GLdouble *);
extern void APIPRIVATE __glim_Normal3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Normal3fv(const GLfloat *);
extern void APIPRIVATE __glim_Normal3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_Normal3iv(const GLint *);
extern void APIPRIVATE __glim_Normal3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Normal3sv(const GLshort *);
extern void APIPRIVATE __glim_RasterPos2d(GLdouble, GLdouble);
extern void APIPRIVATE __glim_RasterPos2dv(const GLdouble *);
extern void APIPRIVATE __glim_RasterPos2f(GLfloat, GLfloat);
extern void APIPRIVATE __glim_RasterPos2fv(const GLfloat *);
extern void APIPRIVATE __glim_RasterPos2i(GLint, GLint);
extern void APIPRIVATE __glim_RasterPos2iv(const GLint *);
extern void APIPRIVATE __glim_RasterPos2s(GLshort, GLshort);
extern void APIPRIVATE __glim_RasterPos2sv(const GLshort *);
extern void APIPRIVATE __glim_RasterPos3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_RasterPos3dv(const GLdouble *);
extern void APIPRIVATE __glim_RasterPos3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_RasterPos3fv(const GLfloat *);
extern void APIPRIVATE __glim_RasterPos3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_RasterPos3iv(const GLint *);
extern void APIPRIVATE __glim_RasterPos3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_RasterPos3sv(const GLshort *);
extern void APIPRIVATE __glim_RasterPos4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_RasterPos4dv(const GLdouble *);
extern void APIPRIVATE __glim_RasterPos4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_RasterPos4fv(const GLfloat *);
extern void APIPRIVATE __glim_RasterPos4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_RasterPos4iv(const GLint *);
extern void APIPRIVATE __glim_RasterPos4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_RasterPos4sv(const GLshort *);
extern void APIPRIVATE __glim_Rectd(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Rectdv(const GLdouble *, const GLdouble *);
extern void APIPRIVATE __glim_Rectf(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Rectfv(const GLfloat *, const GLfloat *);
extern void APIPRIVATE __glim_Recti(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_Rectiv(const GLint *, const GLint *);
extern void APIPRIVATE __glim_Rects(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Rectsv(const GLshort *, const GLshort *);
extern void APIPRIVATE __glim_TexCoord1d(GLdouble);
extern void APIPRIVATE __glim_TexCoord1dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord1f(GLfloat);
extern void APIPRIVATE __glim_TexCoord1fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord1i(GLint);
extern void APIPRIVATE __glim_TexCoord1iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord1s(GLshort);
extern void APIPRIVATE __glim_TexCoord1sv(const GLshort *);
extern void APIPRIVATE __glim_TexCoord2d(GLdouble, GLdouble);
extern void APIPRIVATE __glim_TexCoord2dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord2f(GLfloat, GLfloat);
extern void APIPRIVATE __glim_TexCoord2fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord2i(GLint, GLint);
extern void APIPRIVATE __glim_TexCoord2iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord2s(GLshort, GLshort);
extern void APIPRIVATE __glim_TexCoord2sv(const GLshort *);
extern void APIPRIVATE __glim_TexCoord3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_TexCoord3dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_TexCoord3fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_TexCoord3iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_TexCoord3sv(const GLshort *);
extern void APIPRIVATE __glim_TexCoord4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_TexCoord4dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_TexCoord4fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_TexCoord4iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_TexCoord4sv(const GLshort *);
extern void APIPRIVATE __glim_Vertex2d(GLdouble, GLdouble);
extern void APIPRIVATE __glim_Vertex2dv(const GLdouble *);
extern void APIPRIVATE __glim_Vertex2f(GLfloat, GLfloat);
extern void APIPRIVATE __glim_Vertex2fv(const GLfloat *);
extern void APIPRIVATE __glim_Vertex2i(GLint, GLint);
extern void APIPRIVATE __glim_Vertex2iv(const GLint *);
extern void APIPRIVATE __glim_Vertex2s(GLshort, GLshort);
extern void APIPRIVATE __glim_Vertex2sv(const GLshort *);
extern void APIPRIVATE __glim_Vertex3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Vertex3dv(const GLdouble *);
extern void APIPRIVATE __glim_Vertex3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Vertex3fv(const GLfloat *);
extern void APIPRIVATE __glim_Vertex3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_Vertex3iv(const GLint *);
extern void APIPRIVATE __glim_Vertex3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Vertex3sv(const GLshort *);
extern void APIPRIVATE __glim_Vertex4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Vertex4dv(const GLdouble *);
extern void APIPRIVATE __glim_Vertex4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Vertex4fv(const GLfloat *);
extern void APIPRIVATE __glim_Vertex4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_Vertex4iv(const GLint *);
extern void APIPRIVATE __glim_Vertex4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Vertex4sv(const GLshort *);
extern void APIPRIVATE __glim_ClipPlane(GLenum, const GLdouble *);
extern void APIPRIVATE __glim_ColorMaterial(GLenum, GLenum);
extern void APIPRIVATE __glim_CullFace(GLenum);
extern void APIPRIVATE __glim_Fogf(GLenum, GLfloat);
extern void APIPRIVATE __glim_Fogfv(GLenum, const GLfloat *);
extern void APIPRIVATE __glim_Fogi(GLenum, GLint);
extern void APIPRIVATE __glim_Fogiv(GLenum, const GLint *);
extern void APIPRIVATE __glim_FrontFace(GLenum);
extern void APIPRIVATE __glim_Hint(GLenum, GLenum);
extern void APIPRIVATE __glim_Lightf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_Lightfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_Lighti(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_Lightiv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_LightModelf(GLenum, GLfloat);
extern void APIPRIVATE __glim_LightModelfv(GLenum, const GLfloat *);
extern void APIPRIVATE __glim_LightModeli(GLenum, GLint);
extern void APIPRIVATE __glim_LightModeliv(GLenum, const GLint *);
extern void APIPRIVATE __glim_LineStipple(GLint, GLushort);
extern void APIPRIVATE __glim_LineWidth(GLfloat);
extern void APIPRIVATE __glim_Materialf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_Materialfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_Materiali(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_Materialiv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_PointSize(GLfloat);
extern void APIPRIVATE __glim_PolygonMode(GLenum, GLenum);
#ifdef NT
extern void APIPRIVATE __glim_PolygonStipple(const GLubyte *, GLboolean);
#else
extern void APIPRIVATE __glim_PolygonStipple(const GLubyte *);
#endif
extern void APIPRIVATE __glim_Scissor(GLint, GLint, GLsizei, GLsizei);
extern void APIPRIVATE __glim_ShadeModel(GLenum);
extern void APIPRIVATE __glim_TexParameterf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_TexParameterfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_TexParameteri(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_TexParameteriv(GLenum, GLenum, const GLint *);
#ifdef NT
extern void APIPRIVATE __glim_TexImage1D(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *, GLboolean);
extern void APIPRIVATE __glim_TexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *, GLboolean);
#else
extern void APIPRIVATE __glim_TexImage1D(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
extern void APIPRIVATE __glim_TexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
#endif
extern void APIPRIVATE __glim_TexEnvf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_TexEnvfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_TexEnvi(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_TexEnviv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_TexGend(GLenum, GLenum, GLdouble);
extern void APIPRIVATE __glim_TexGendv(GLenum, GLenum, const GLdouble *);
extern void APIPRIVATE __glim_TexGenf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_TexGenfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_TexGeni(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_TexGeniv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_FeedbackBuffer(GLsizei, GLenum, GLfloat *);
extern void APIPRIVATE __glim_SelectBuffer(GLsizei, GLuint *);
extern GLint APIPRIVATE __glim_RenderMode(GLenum);
extern void APIPRIVATE __glim_InitNames(void);
extern void APIPRIVATE __glim_LoadName(GLuint);
extern void APIPRIVATE __glim_PassThrough(GLfloat);
extern void APIPRIVATE __glim_PopName(void);
extern void APIPRIVATE __glim_PushName(GLuint);
extern void APIPRIVATE __glim_DrawBuffer(GLenum);
extern void APIPRIVATE __glim_Clear(GLbitfield);
extern void APIPRIVATE __glim_ClearAccum(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_ClearIndex(GLfloat);
extern void APIPRIVATE __glim_ClearColor(GLclampf, GLclampf, GLclampf, GLclampf);
extern void APIPRIVATE __glim_ClearStencil(GLint);
extern void APIPRIVATE __glim_ClearDepth(GLclampd);
extern void APIPRIVATE __glim_StencilMask(GLuint);
extern void APIPRIVATE __glim_ColorMask(GLboolean, GLboolean, GLboolean, GLboolean);
extern void APIPRIVATE __glim_DepthMask(GLboolean);
extern void APIPRIVATE __glim_IndexMask(GLuint);
extern void APIPRIVATE __glim_Accum(GLenum, GLfloat);
extern void APIPRIVATE __glim_Disable(GLenum);
extern void APIPRIVATE __glim_Enable(GLenum);
extern void APIPRIVATE __glim_Finish(void);
extern void APIPRIVATE __glim_Flush(void);
extern void APIPRIVATE __glim_PopAttrib(void);
extern void APIPRIVATE __glim_PushAttrib(GLbitfield);
extern void APIPRIVATE __glim_AlphaFunc(GLenum, GLclampf);
extern void APIPRIVATE __glim_BlendFunc(GLenum, GLenum);
extern void APIPRIVATE __glim_LogicOp(GLenum);
extern void APIPRIVATE __glim_StencilFunc(GLenum, GLint, GLuint);
extern void APIPRIVATE __glim_StencilOp(GLenum, GLenum, GLenum);
extern void APIPRIVATE __glim_DepthFunc(GLenum);
extern void APIPRIVATE __glim_PixelZoom(GLfloat, GLfloat);
extern void APIPRIVATE __glim_PixelTransferf(GLenum, GLfloat);
extern void APIPRIVATE __glim_PixelTransferi(GLenum, GLint);
extern void APIPRIVATE __glim_PixelStoref(GLenum, GLfloat);
extern void APIPRIVATE __glim_PixelStorei(GLenum, GLint);
extern void APIPRIVATE __glim_PixelMapfv(GLenum, GLint, const GLfloat *);
extern void APIPRIVATE __glim_PixelMapuiv(GLenum, GLint, const GLuint *);
extern void APIPRIVATE __glim_PixelMapusv(GLenum, GLint, const GLushort *);
extern void APIPRIVATE __glim_ReadBuffer(GLenum);
extern void APIPRIVATE __glim_CopyPixels(GLint, GLint, GLsizei, GLsizei, GLenum);
extern void APIPRIVATE __glim_ReadPixels(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
#ifdef NT
extern void APIPRIVATE __glim_DrawPixels(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, GLboolean);
#else
extern void APIPRIVATE __glim_DrawPixels(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#endif
extern void APIPRIVATE __glim_GetBooleanv(GLenum, GLboolean *);
extern void APIPRIVATE __glim_GetClipPlane(GLenum, GLdouble *);
extern void APIPRIVATE __glim_GetDoublev(GLenum, GLdouble *);
extern GLenum APIPRIVATE __glim_GetError(void);
extern void APIPRIVATE __glim_GetFloatv(GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetIntegerv(GLenum, GLint *);
extern void APIPRIVATE __glim_GetLightfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetLightiv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetMapdv(GLenum, GLenum, GLdouble *);
extern void APIPRIVATE __glim_GetMapfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetMapiv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetMaterialfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetMaterialiv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetPixelMapfv(GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetPixelMapuiv(GLenum, GLuint *);
extern void APIPRIVATE __glim_GetPixelMapusv(GLenum, GLushort *);
extern void APIPRIVATE __glim_GetPolygonStipple(GLubyte *);
extern const GLubyte * APIPRIVATE __glim_GetString(GLenum);
extern void APIPRIVATE __glim_GetTexEnvfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexEnviv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetTexGendv(GLenum, GLenum, GLdouble *);
extern void APIPRIVATE __glim_GetTexGenfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexGeniv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetTexImage(GLenum, GLint, GLenum, GLenum, GLvoid *);
extern void APIPRIVATE __glim_GetTexParameterfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexParameteriv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetTexLevelParameterfv(GLenum, GLint, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexLevelParameteriv(GLenum, GLint, GLenum, GLint *);
extern GLboolean APIPRIVATE __glim_IsEnabled(GLenum);
extern GLboolean APIPRIVATE __glim_IsList(GLuint);
extern void APIPRIVATE __glim_DepthRange(GLclampd, GLclampd);
extern void APIPRIVATE __glim_Frustum(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_LoadIdentity(void);
extern void APIPRIVATE __glim_LoadMatrixf(const GLfloat *);
extern void APIPRIVATE __glim_LoadMatrixd(const GLdouble *);
extern void APIPRIVATE __glim_MatrixMode(GLenum);
extern void APIPRIVATE __glim_MultMatrixf(const GLfloat *);
extern void APIPRIVATE __glim_MultMatrixd(const GLdouble *);
extern void APIPRIVATE __glim_Ortho(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_PopMatrix(void);
extern void APIPRIVATE __glim_PushMatrix(void);
extern void APIPRIVATE __glim_Rotated(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Rotatef(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Scaled(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Scalef(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Translated(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Translatef(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Viewport(GLint, GLint, GLsizei, GLsizei);
extern void APIPRIVATE __glim_AddSwapHintRectWIN(GLint, GLint, GLint, GLint);
extern GLboolean APIPRIVATE __glim_AreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences);
extern void APIPRIVATE __glim_BindTexture(GLenum target, GLuint texture);
extern void APIPRIVATE __glim_CopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border);
extern void APIPRIVATE __glim_CopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border);
extern void APIPRIVATE __glim_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width);
extern void APIPRIVATE __glim_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height);
extern void APIPRIVATE __glim_DeleteTextures(GLsizei n, const GLuint *textures);
extern void APIPRIVATE __glim_GenTextures(GLsizei n, GLuint *textures);
extern GLboolean APIPRIVATE __glim_IsTexture(GLuint texture);
extern void APIPRIVATE __glim_PrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities);
#ifdef NT
extern void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels, GLboolean _IsDlist);
extern void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels, GLboolean _IsDlist);
#else
extern void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels);
extern void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);
#endif

extern void APIPRIVATE __glim_PolygonOffset(GLfloat factor, GLfloat units);

#ifdef NT
extern void APIPRIVATE __glim_ColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data, GLboolean _IsDlist);
extern void APIPRIVATE __glim_ColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data, GLboolean _IsDlist);
extern void APIPRIVATE __glim_GetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
extern void APIPRIVATE __glim_GetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
extern void APIPRIVATE __glim_GetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);
#endif

#ifdef GL_WIN_multiple_textures
extern void APIPRIVATE __glim_CurrentTextureIndexWIN(GLuint index);
extern void APIPRIVATE __glim_BindNthTextureWIN(GLuint index, GLenum target, GLuint texture);
extern void APIPRIVATE __glim_NthTexCombineFuncWIN(GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

extern void APIPRIVATE __glim_MipsVertex2fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex3fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex4fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex2fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex3fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex4fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex2fvFastest(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex3fvFastest(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex4fvFastest(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex2fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex3fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex4fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex2fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex3fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex4fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex2fvFast2D(const GLfloat *);

extern void APIPRIVATE __glim_FastColor3ub(GLubyte, GLubyte, GLubyte);
extern void APIPRIVATE __glim_FastColor3ubv(const GLubyte *);

#endif /* __glimfuncs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\global.h ===
#ifndef __glglobal_h_
#define __glglobal_h_

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "context.h"

/*
** Some misc constants
*/
#ifdef NT
// These constants can either be static memory constants or
// real constants.  This #if should be modified for each
// platform to optimize the constant type for the platform
// For example, the x86 FPU can only load from memory so having
// these constants as memory locations rather than values is
// a clear win
#if defined(_X86_) || defined(_ALPHA_) || defined(_MIPS_) || defined(_PPC_)

extern const double    __glDoubleTwo;
extern const double    __glDoubleMinusTwo;

#ifdef _ALPHA_
// On Alpha, register f31 always reads as zero.
#define __glZero		((__GLfloat) 0.0)
#else
extern const __GLfloat __glZero;
#endif

extern const __GLfloat __glOne;
extern const __GLfloat __glMinusOne;
extern const __GLfloat __glHalf;
extern const __GLfloat __glDegreesToRadians;
extern const __GLfloat __glPi;
extern const __GLfloat __glSqrt2;
extern const __GLfloat __glE;
extern const __GLfloat __glVal128;
extern const __GLfloat __glVal255;
extern const __GLfloat __glOneOver255;
extern const __GLfloat __glVal256;
extern const __GLfloat __glOneOver512;
extern const __GLfloat __glVal768;
extern const __GLfloat __glVal65535;
extern const __GLfloat __glVal65536;
extern const __GLfloat __glOneOver65535;
extern const __GLfloat __glTexSubDiv;
extern const __GLfloat __glVal2147483648;
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
extern const __GLfloat __glVal4294965000;
extern const __GLfloat __glOneOver4294965000;

#else // Real values

#define __glDoubleTwo		((double) 2.0)
#define __glDoubleMinusTwo	((double) -2.0)

#define __glZero		((__GLfloat) 0.0)
#define __glOne			((__GLfloat) 1.0)
#define __glMinusOne		((__GLfloat) -1.0)
#define __glHalf		((__GLfloat) 0.5)
#define __glDegreesToRadians	(__glPi / (__GLfloat) 180.0)
#define __glPi			((__GLfloat) 3.14159265358979323846)
#define __glSqrt2		((__GLfloat) 1.41421356237309504880)
#define __glE			((__GLfloat) 2.7182818284590452354)
#define __glVal128              ((__GLfloat) 128.0)
#define __glVal255		((__GLfloat) 255.0)
#define __glOneOver255		((__GLfloat) (1.0 / 255.0))
#define __glVal256              ((__GLfloat) 256.0)
#define __glOneOver512          ((__GLfloat) (1.0 / 512.0))
#define __glVal768              ((__GLfloat) 768.0)
#define __glVal65535		((__GLfloat) 65535.0)
#define __glVal65536	        ((__GLfloat) 65536.0)
#define __glOneOver65535	((__GLfloat) (1.0 / 65535.0))
#define __glVal2147483648       ((__GLfloat) 2147483648.0)
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#define __glVal4294965000	((__GLfloat) (4294965000.0))
#define __glOneOver4294965000	((__GLfloat) (1.0 / 4294965000.0))
#endif // Real values

#else

#define __glZero		((__GLfloat) 0.0)
#define __glOne			(gc->constants.one)
#define __glMinusOne		((__GLfloat) -1.0)
#define __glHalf		(gc->constants.half)
#define __glTwo			((__GLfloat) 2.0)
#define __glDegreesToRadians	(__glPi / (__GLfloat) 180.0)
#define __glPi			((__GLfloat) 3.14159265358979323846)
#define __glSqrt2		((__GLfloat) 1.41421356237309504880)
#define __glE			((__GLfloat) 2.7182818284590452354)
#define __glVal255		((__GLfloat) 255.0)
#define __glOneOver255		((__GLfloat) (1.0 / 255.0))
#define __glVal65535		((__GLfloat) 65535.0)
#define __glOneOver65535	((__GLfloat) (1.0 / 65535.0))
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#define __glVal4294965000	((__GLfloat) (4294965000.0))
#define __glOneOver4294965000	((__GLfloat) (1.0 / 4294965000.0))

#endif // NT

// This is used by the macro __GL_UB_TO_FLOAT which converts
// unsigned bytes to floats in the range [0,1].
extern GLfloat __glUByteToFloat[256];

// This is used by the macro __GL_B_TO_FLOAT for byte to float component
// conversion.
extern GLfloat __glByteToFloat[256];

// This is used by frustum clipping to determine which plane coordinate
// to use
extern GLuint __glFrustumOffsets[];

/************************************************************************/

#define __GL_SETUP() \
    __GLcontext *gc = GLTEB_SRVCONTEXT()

#define __GL_IN_BEGIN() \
    (gc->beginMode == __GL_IN_BEGIN)

#define __GL_SETUP_NOT_IN_BEGIN()	    \
    __GL_SETUP();			    \
    if (__GL_IN_BEGIN()) {		    \
	__glSetError(GL_INVALID_OPERATION); \
	return;				    \
    }

#define __GL_SETUP_NOT_IN_BEGIN_VALIDATE()	\
    __GL_SETUP();				\
    __GLbeginMode beginMode = gc->beginMode;	\
    if (beginMode != __GL_NOT_IN_BEGIN) {	\
	if (beginMode == __GL_NEED_VALIDATE) {	\
	    (*gc->procs.validate)(gc);		\
	    gc->beginMode = __GL_NOT_IN_BEGIN;	\
	} else {				\
	    __glSetError(GL_INVALID_OPERATION);	\
	    return;				\
	}					\
    }

#define __GL_SETUP_NOT_IN_BEGIN2()	    \
    __GL_SETUP();			    \
    if (__GL_IN_BEGIN()) {		    \
	__glSetError(GL_INVALID_OPERATION); \
	return 0;			    \
    }

#endif /* __glglobal_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\lighting.h ===
#ifndef __gllighting_h_
#define __gllighting_h_

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "xform.h"

/*
** Light state.  Contains all the user controllable lighting state.
** Most of the colors kept in user state are scaled to match the
** drawing surfaces color resolution.
**
** Exposed to the MCD as MCDMATERIAL.
*/

struct __GLmaterialStateRec {
    __GLcolor ambient;			/* unscaled */
    __GLcolor diffuse;			/* unscaled */
    __GLcolor specular;			/* unscaled */
    __GLcolor emissive;			/* scaled */
    __GLfloat specularExponent; 
#ifdef NT
// SGIBUG align it properly, otherwise GetMateriali returns wrong result!
    __GLfloat cmapa, cmapd, cmaps;
#else
    __GLfloat cmapa, cmaps, cmapd;
#endif
};

/*
** Exposed to the MCD as MCDLIGHTMODEL
*/
    
struct __GLlightModelStateRec {
    __GLcolor ambient;			/* scaled */
    GLboolean localViewer;
    GLboolean twoSided;
};

/*
** Partially exposed to the MCD as MCDLIGHT
*/

typedef struct {
    __GLcolor ambient;			/* scaled */
    __GLcolor diffuse;			/* scaled */
    __GLcolor specular;			/* scaled */
    __GLcoord position;
    __GLcoord positionEye;
    __GLcoord direction;
    __GLcoord directionEyeNorm;
    __GLfloat spotLightExponent;
    __GLfloat spotLightCutOffAngle;
    __GLfloat constantAttenuation;
    __GLfloat linearAttenuation;
    __GLfloat quadraticAttenuation;

    /* MCDLIGHT ends */

    /* Need both directionEyeNorm and directionEye because MCD 2.0 wants
       a normalized direction but glGetLightfv specifies that the value
       returned for spot direction is the pre-normalized eye coordinate
       direction */
    __GLcoord directionEye;
    struct __GLmatrixRec lightMatrix;
} __GLlightSourceState;

typedef struct {
    GLenum colorMaterialFace;
    GLenum colorMaterialParam;
    GLenum shadingModel;
    __GLlightModelState model;
    __GLmaterialState front;
    __GLmaterialState back;
    GLuint dirtyLights;
    __GLlightSourceState *source;
} __GLlightState;

/************************************************************************/

/*
** What bits are affected by color index anti-aliasing.  This isn't a
** really a changeable parameter (it is defined by the spec), but it
** is useful for documentation instead of a mysterious 4 or 16 sitting
** around in the code.
*/
#define __GL_CI_ANTI_ALIAS_BITS		4
#define __GL_CI_ANTI_ALIAS_DIVISOR	(1 << __GL_CI_ANTI_ALIAS_BITS)

/************************************************************************/

/*
** These macros are used to convert incoming color values into the
** abstract color range from 0.0 to 1.0
*/
#ifdef NT
#define __GL_B_TO_FLOAT(b)	(__glByteToFloat[(GLubyte)(b)])
#define __GL_UB_TO_FLOAT(ub)	(__glUByteToFloat[ub])
#define __GL_S_TO_FLOAT(s)	((((s)<<1) + 1) * __glOneOver65535)
#define __GL_US_TO_FLOAT(us)	((us) * __glOneOver65535)
#else
#define __GL_B_TO_FLOAT(b)	((((b)<<1) + 1) * gc->constants.oneOver255)
#define __GL_UB_TO_FLOAT(ub)	(gc->constants.uByteToFloat[ub])
#define __GL_S_TO_FLOAT(s)	((((s)<<1) + 1) * gc->constants.oneOver65535)
#define __GL_US_TO_FLOAT(us)	((us) * gc->constants.oneOver65535)
#endif

/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#ifdef NT
#define __GL_I_TO_FLOAT(i) \
	((((__GLfloat)(i) * (__GLfloat) 2.0) + 1) * \
	    __glOneOver4294965000)
#define __GL_UI_TO_FLOAT(ui) \
	((__GLfloat)(ui) * __glOneOver4294965000)
#else
#define __GL_I_TO_FLOAT(i) \
	((((__GLfloat)(i) * (__GLfloat) 2.0) + 1) * \
	    gc->constants.oneOver4294965000)
#define __GL_UI_TO_FLOAT(ui) \
	((__GLfloat)(ui) * gc->constants.oneOver4294965000)
#endif

/*
** Bloody "round towards 0" convention.  We could avoid these floor() calls
** were it not for that!
*/
#ifdef NT
#define __GL_FLOAT_TO_B(f) \
	((GLbyte) __GL_FLOORF(((f) * __glVal255) * __glHalf))
#define __GL_FLOAT_TO_UB(f) \
	((GLubyte) ((f) * __glVal255 + __glHalf))
#define __GL_FLOAT_TO_S(f) \
	((GLshort) __GL_FLOORF(((f) * __glVal65535) * __glHalf))
#define __GL_FLOAT_TO_US(f) \
	((GLushort) ((f) * __glVal65535 + __glHalf))
#else
#define __GL_FLOAT_TO_B(f) \
	((GLbyte) __GL_FLOORF(((f) * gc->constants.val255) * __glHalf))
#define __GL_FLOAT_TO_UB(f) \
	((GLubyte) ((f) * gc->constants.val255 + __glHalf))
#define __GL_FLOAT_TO_S(f) \
	((GLshort) __GL_FLOORF(((f) * gc->constants.val65535) * __glHalf))
#define __GL_FLOAT_TO_US(f) \
	((GLushort) ((f) * gc->constants.val65535 + __glHalf))
#endif

/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#ifdef NT
#define __GL_FLOAT_TO_I(f) \
    ((GLint) __GL_FLOORF(((f) * __glVal4294965000) * __glHalf))
#define __GL_FLOAT_TO_UI(f) \
    ((GLuint) ((f) * __glVal4294965000 + __glHalf))
#else
#define __GL_FLOAT_TO_I(f) \
    ((GLint) __GL_FLOORF(((f) * gc->constants.val4294965000) * __glHalf))
#define __GL_FLOAT_TO_UI(f) \
    ((GLuint) ((f) * gc->constants.val4294965000 + __glHalf))
#endif

/*
** Mask the incoming color index (in floating point) against the
** maximum color index value for the color buffers.  Keep 4 bits
** of fractional precision.
*/
#define __GL_MASK_INDEXF(gc, val)			       \
    (((__GLfloat) (((GLint) ((val) * 16))		       \
		   & (((gc)->frontBuffer.redMax << 4) | 0xf))) \
     / (__GLfloat)16.0)

#define __GL_MASK_INDEXI(gc, val)			       \
    ((val) & (gc)->frontBuffer.redMax)

/************************************************************************/

/* 
** These two must be the same size, because they cache their tables in the
** same arena.
*/
#define __GL_SPEC_LOOKUP_TABLE_SIZE	256
#define __GL_SPOT_LOOKUP_TABLE_SIZE	__GL_SPEC_LOOKUP_TABLE_SIZE

typedef struct {
    GLint refcount;
    __GLfloat threshold, scale, exp;
    __GLfloat table[__GL_SPEC_LOOKUP_TABLE_SIZE];
} __GLspecLUTEntry;

__GLspecLUTEntry *__glCreateSpecLUT(__GLcontext *gc, __GLfloat exp);
void FASTCALL __glFreeSpecLUT(__GLcontext *gc, __GLspecLUTEntry *lut);
void FASTCALL __glInitLUTCache(__GLcontext *gc);
void FASTCALL __glFreeLUTCache(__GLcontext *gc);

#define __GL_LIGHT_UPDATE_FRONT_MATERIAL_AMBIENT

/*
** Per light source per material computed state.
*/
typedef struct __GLlightSourcePerMaterialMachineRec {
    __GLcolor ambient;		/* light ambient times material ambient */
    __GLcolor diffuse;		/* light diffuse times material diffuse */
    __GLcolor specular;		/* light specular times material specular */
} __GLlightSourcePerMaterialMachine;

/*
** Per light source computed state.
*/
struct __GLlightSourceMachineRec {
    /*
    ** ambient, diffuse and specular are each pre-multiplied by the
    ** material ambient, material diffuse and material specular.
    ** We use the face being lit to pick between the two sets.
    */
    __GLlightSourcePerMaterialMachine front, back;

    __GLlightSourceState *state;

    __GLfloat constantAttenuation;
    __GLfloat linearAttenuation;
    __GLfloat quadraticAttenuation;
    __GLfloat spotLightExponent;

    /* Position of the light source in eye coordinates */
    __GLcoord position;

    /* Direction of the light source in eye coordinates, normalize */
    __GLcoord direction;

    /* Cosine of the spot light cutoff angle */
    __GLfloat cosCutOffAngle;

    /* Precomputed attenuation, only when k1 and k2 are zero */
    __GLfloat attenuation;

    /* This will be set when the cut off angle != 180 */
    GLboolean isSpot;

    /* When possible, the normalized "h" value from the spec is pre-computed */
    __GLcoord hHat;

    /* Unit vector VPpli pre-computed (only when light is at infinity) */
    __GLcoord unitVPpli;

    /* sli and dli values pre-computed (color index mode only) */
    __GLfloat sli, dli;

    /* Link to next active light */
    __GLlightSourceMachine *next;

    /* Spot light exponent lookup table */
    __GLfloat *spotTable;

    /* Values used to avoid pow function during spot computations */
    __GLfloat threshold, scale;

    /* cache entry where this data came from */
    __GLspecLUTEntry *cache;

    /* Set to GL_TRUE if slow processing path is needed */
    GLboolean slowPath;

    /* temporary storage for hHat when original hHat is transformed into *
    /* normal space */
    __GLcoord tmpHHat;

    /* temporary storage for unitVPpli when original is transformed into *
    /* normal space */
    __GLcoord tmpUnitVPpli;
};

/*
** Per material computed state.
*/
struct __GLmaterialMachineRec {
#ifdef NT
    /*
    ** Sum of:
    **	invariant material emissive color (with respect to color material)
    **  invariant material ambient color * scene ambient color (with
    **    respect to color material)
    **
    ** This sum is carefully kept scaled.
    */
    __GLcolor paSceneColor;

    /*
    ** Cached values for the total emissive+ambient for a material, and
    ** the clamped version of this value which can be directly applied
    ** to backface vertices with no effective specular or diffuse components.
    */

    __GLcolor cachedEmissiveAmbient;
    __GLcolor cachedNonLit;
#else
    /*
    ** Sum of:
    **	material emissive color
    **  material ambient color * scene ambient color
    **
    ** This sum is carefully kept scaled.
    */
    __GLcolor sceneColor;
#endif

    /* Specular exponent */
    __GLfloat specularExponent;

    /* Specular exponent lookup table */
    __GLfloat *specTable;

    /* Values used to avoid pow function during specular computations */
    __GLfloat threshold, scale;

    /* cache entry where this data came from */
    __GLspecLUTEntry *cache;

    /* Scaled and clamped form of material diffuse alpha */
    __GLfloat alpha;

#ifdef NT
    /* color material change bits */
    GLuint    colorMaterialChange;
#endif
};

typedef struct {
    __GLlightSourceMachine *source;
    __GLmaterialMachine front, back;

    /* List of enabled light sources */
    __GLlightSourceMachine *sources;

    /* Current material color material (iff one material is being updated) */
    __GLmaterialState *cm;
    __GLmaterialMachine *cmm;

    /* Cache of lookup tables for spot lights and specular highlights */
    struct __GLspecLUTCache_Rec *lutCache;
} __GLlightMachine;

/* Values for cmParam */
#define __GL_EMISSION			0
#define __GL_AMBIENT			1
#define __GL_SPECULAR			2
#define __GL_AMBIENT_AND_DIFFUSE	3
#define __GL_DIFFUSE			4

extern void FASTCALL __glCopyCIColor(__GLcontext *gc, GLuint faceBit, __GLvertex *v);
extern void FASTCALL __glCopyRGBColor(__GLcontext *gc, GLuint faceBit, __GLvertex *v);

extern void FASTCALL __glClampRGBColor(__GLcontext *gc, __GLcolor *dst,
			      const __GLcolor *src);
extern void FASTCALL __glClampAndScaleColor(__GLcontext *gc);


/* Stuff for converting float colors */
extern void FASTCALL __glClampAndScaleColorf(__GLcontext *gc, __GLcolor *dst,
				    const GLfloat src[4]);
extern void FASTCALL __glClampColorf(__GLcontext *gc, __GLcolor *dst,
			    const GLfloat src[4]);
extern void FASTCALL __glScaleColorf(__GLcontext *gc, __GLcolor *dst,
			    const GLfloat src[4]);
extern void FASTCALL __glUnScaleColorf(__GLcontext *gc, GLfloat dst[4],
			      const __GLcolor *src);

/* Stuff for converting integer colors */
extern void FASTCALL __glClampAndScaleColori(__GLcontext *gc, __GLcolor *dst,
				    const GLint src[4]);
extern void FASTCALL __glClampColori(__GLcontext *gc, __GLcolor *dst,
			    const GLint src[4]);
extern void FASTCALL __glScaleColori(__GLcontext *gc, __GLcolor *dst,
			    const GLint src[4]);
extern void FASTCALL __glUnScaleColori(__GLcontext *gc, GLint dst[4],
			      const __GLcolor *src);

extern void FASTCALL __glTransformLightDirection(__GLcontext *gc,
					__GLlightSourceState *ls);

extern void FASTCALL __glValidateLighting(__GLcontext *gc);
extern void FASTCALL __glValidateMaterial(__GLcontext *gc, GLint front, GLint back);

/* Procs for handling color material changes */
extern void FASTCALL __glChangeOneMaterialColor(__GLcontext *gc);
extern void FASTCALL __glChangeBothMaterialColors(__GLcontext *gc);

/* Lighting procs */
extern void FASTCALL __glCalcRGBColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL __glFastCalcRGBColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL __glCalcCIColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL __glFastCalcCIColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL ComputeColorMaterialChange(__GLcontext *gc);

#endif /* __gllighting_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\namesint.h ===
#ifndef __glnamesint_h
#define __glnamesint_h

/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list internal structure description.
**
** $Revision: 1.2 $
** $Date: 1995/01/25 18:05:43 $
*/


/************************************************************************/
/*
** Names Manager Interface
**
** This file contains the Name Space Management types and structures.
**
** The Name Space Management code is used to store and retreive named
** data structures.  The data being stored is referred to with void 
** pointers to allow for the storage of any type of structure.
**
** The Name Space is implemented as a 2-3 tree.  For a detailed
** description of its implementation, see lib/opengl/soft/so_names.c.
**
** __GLnamesArray is declared in types.h.
*/
/************************************************************************/


/*
** A tree can be used to hold different types of data,
** e.g. display lists or texture objects.  This is the structure 
** that contains information needed for each tree type.  For
** example, this structure contains a pointer to a dummy empty
** structure and a callback for freeing memory associated with
** the structure.
*/
struct __GLnamesArrayTypeInfoRec {
    void *empty;		/* ptr to empty info structure */
    GLuint dataSize;		/* sizeof data structure in bytes */
    void (WINAPIV *free)(__GLcontext *gc, void *memory);	
				/* callback for freeing data */
    GLboolean (WINAPIV *alloc)(__GLcontext *gc, size_t size);
				/* callback for allocating data */
};
typedef struct __GLnamesArrayTypeInfoRec __GLnamesArrayTypeInfo;

/*
** The number of spare branches and leaves that we keep about in case
** we run out of memory.  At that point, we complete the current operation
** by using the extra leaves and branches, and we report an OUT_OF_MEMORY
** error when a new operation is requested (unless we can fill our extras
** again!)
**
** These constants were not chosen terribly carefully.  As best as I can
** figure, we only need one spare branch per level in the tree (so 16
** supports a tree with 65536 leaves).  And even then, the user would have
** to be extremely devious to actually force 16 new branches to appear in
** the tree at just the same moment that the system runs out of memory.
**
** The number of spare leaves required, I believe, is one.  Three is chosen
** to allow for some slop.
*/
#define __GL_DL_EXTRA_BRANCHES          16
#define __GL_DL_EXTRA_LEAVES            3

/*
** This is the structure that contains information that is needed
** for each instance of a names tree.  It needs to be public
** so the refcount can be managed.
*/

typedef struct __GLnamesArrayTypeInfoRec __GLnamesArrayTypeInfo;
typedef struct __GLnamesBranchRec __GLnamesBranch;
typedef struct __GLnamesLeafRec __GLnamesLeaf;

struct __GLnamesArrayRec {
    __GLnamesBranch *tree;      /* points to the top of the names tree */
    GLuint depth;               /* depth of tree */
    GLint refcount; /*# ctxs using this array: create with 1, delete at 0*/
    __GLnamesArrayTypeInfo *dataInfo;   /* ptr to data type info */
    GLuint nbranches, nleaves;  /* should basically always be at max */
    __GLnamesBranch *branches[__GL_DL_EXTRA_BRANCHES];
    __GLnamesLeaf *leaves[__GL_DL_EXTRA_LEAVES];
#ifdef NT
    CRITICAL_SECTION critsec;
#endif
};

#ifdef NT
// Locking macros to enable or disable locking
#define __GL_NAMES_LOCK(array)   EnterCriticalSection(&(array)->critsec)
#define __GL_NAMES_UNLOCK(array) LeaveCriticalSection(&(array)->critsec)

#if DBG
typedef struct _RTL_CRITICAL_SECTION *LPCRITICAL_SECTION;
extern void APIENTRY CheckCritSectionIn(LPCRITICAL_SECTION pcs);
#define __GL_NAMES_ASSERT_LOCKED(array) CheckCritSectionIn(&(array)->critsec)
#else
#define __GL_NAMES_ASSERT_LOCKED(array)
#endif
#endif

/*
** Clean up an item whose refcount has fallen to zero due to unlocking
*/
typedef void (FASTCALL *__GLnamesCleanupFunc)(__GLcontext *gc, void *data);

/*
** Allocate and initialize a new array structure.
*/
extern __GLnamesArray * FASTCALL __glNamesNewArray(__GLcontext *gc, 
					 __GLnamesArrayTypeInfo *dataInfo);

/*
** Free the array structure.
*/
extern void FASTCALL __glNamesFreeArray(__GLcontext *gc, __GLnamesArray *array);

/*
** Save a new display list in the array.  A return value of GL_FALSE
** indicates and OUT_OF_MEMORY error, indicating that the list was 
** not stored.
*/
extern GLboolean FASTCALL __glNamesNewData(__GLcontext *gc, __GLnamesArray *array,
				  GLuint name, void *data);

/*
** Find and lock the list specified with "listnum".  A return value of NULL
** indicates that there was no such list.  __glNamesUnlockList() needs to
** be called to unlock the list otherwise.
*/
extern void * FASTCALL __glNamesLockData(__GLcontext *gc, __GLnamesArray *array,
			       GLuint name);

/*
** Unlock a list locked with __glNamesLockList().  If this is not called, then
** any memory associated with the list will never be freed when the list
** is deleted.
*/
extern void FASTCALL __glNamesUnlockData(__GLcontext *gc, void *data,
                                         __GLnamesCleanupFunc cleanup);

/*
** Same as __glNamesLockList() except that a bunch of lists are locked and
** returned simultaneously.  Any listbase previously specified is used as 
** an offset to the entries in the array.
*/
extern void FASTCALL __glNamesLockDataList(__GLcontext *gc, __GLnamesArray *array,
				  GLsizei n, GLenum type, GLuint base,
			          const GLvoid *names, void *dataList[]);

/*
** Same as __glNamesUnlockList() except that the entire array of names
** is unlocked at once.
*/
extern void FASTCALL __glNamesUnlockDataList(__GLcontext *gc, GLsizei n,
                                             void *dataList[],
                                             __GLnamesCleanupFunc cleanup);

#ifdef NT
/*
** Locks entire array
*/
#define __glNamesLockArray(gc, array) __GL_NAMES_LOCK(array)

/*
** Unlocks array
*/
#define __glNamesUnlockArray(gc, array) __GL_NAMES_UNLOCK(array)
#endif

/*
** Generates a list of names.
*/
extern GLuint FASTCALL __glNamesGenRange(__GLcontext *gc, __GLnamesArray *array, 
				GLsizei range);

/*
** Returns GL_TRUE if name has been generated for this array.
*/
extern GLboolean FASTCALL __glNamesIsName(__GLcontext *gc, __GLnamesArray *array, 
				 GLuint name);

/*
** Deletes a range of names.
*/
extern void FASTCALL __glNamesDeleteRange(__GLcontext *gc, __GLnamesArray *array, 
				 GLuint name, GLsizei range);

/*
** Generates a list of (not necessarily contiguous) names.
*/
extern void FASTCALL __glNamesGenNames(__GLcontext *gc, __GLnamesArray *array, 
			      GLsizei n, GLuint* names);

/*
** Deletes a list of (not necessarily contiguous) names.
*/
extern void FASTCALL __glNamesDeleteNames(__GLcontext *gc, __GLnamesArray *array, 
				 GLsizei n, const GLuint* names);

#endif /* __glnamesint_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\os.h ===
#ifndef __glos_h_
#define __glos_h_

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <nt.h>
#include <stdlib.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>

#include "glscreen.h"
#include "types.h"

// Indicator of which platform we're running on,
// uses the VER_PLATFORM defines
extern DWORD dwPlatformId;

//
// LocalRtlFillMemoryUlong
//
// Inline implementation of RtlFillMemoryUlong.  Destination has DWORD
// alignment.
//
// Parameters:
//
//  Destination     pointer to DWORD aligned destination
//  Length          number of bytes to fill
//  Pattern         fill pattern
//
_inline VOID LocalRtlFillMemoryUlong(PVOID Destination, ULONG Length,
             ULONG Pattern)
{
    if ((Pattern == 0) || (Pattern == 0xffffffff))
        memset(Destination, Pattern, Length);
    else {
        register ULONG *pDest = (ULONG *)Destination;
        LONG unroll;

        Length >>= 2;

        for (unroll = Length >> 5; unroll; unroll--) {
            pDest[0] = Pattern; pDest[1] = Pattern;
            pDest[2] = Pattern; pDest[3] = Pattern;
            pDest[4] = Pattern; pDest[5] = Pattern;
            pDest[6] = Pattern; pDest[7] = Pattern;
            pDest[8] = Pattern; pDest[9] = Pattern;
            pDest[10] = Pattern; pDest[11] = Pattern;
            pDest[12] = Pattern; pDest[13] = Pattern;
            pDest[14] = Pattern; pDest[15] = Pattern;
            pDest[16] = Pattern; pDest[17] = Pattern;
            pDest[18] = Pattern; pDest[19] = Pattern;
            pDest[20] = Pattern; pDest[21] = Pattern;
            pDest[22] = Pattern; pDest[23] = Pattern;
            pDest[24] = Pattern; pDest[25] = Pattern;
            pDest[26] = Pattern; pDest[27] = Pattern;
            pDest[28] = Pattern; pDest[29] = Pattern;
            pDest[30] = Pattern; pDest[31] = Pattern;
            pDest += 32;
        }

        for (unroll = (Length & 0x1f) >> 2; unroll; unroll--) {
            pDest[0] = Pattern; pDest[1] = Pattern;
            pDest[2] = Pattern; pDest[3] = Pattern;
            pDest += 4;
        }

        for (unroll = (Length & 0x3) - 1; unroll >= 0; unroll--)
            pDest[unroll] = Pattern;
    }
}

//
// LocalCompareUlongMemory
//
// Inline implementation of RtlCompareUlongMemory.  Both pointers
// must have DWORD alignment.
//
// Returns TRUE if the two source arrays are equal.  FALSE otherwise.
//
// Parameters:
//
//  Source1     pointer to DWORD aligned array to check
//  Source1     pointer to DWORD aligned array to compare with
//  Length      number of bytes to fill
//
_inline BOOL LocalCompareUlongMemory(PVOID Source1, PVOID Source2,
             ULONG Length)
{
    register ULONG *pSrc1 = (ULONG *) Source1;
    register ULONG *pSrc2 = (ULONG *) Source2;
    LONG unroll;
    BOOL bRet = FALSE;

    Length >>= 2;

    for (unroll = Length >> 5; unroll; unroll--) {
        if ( (pSrc1[0]  != pSrc2[0])  || (pSrc1[1]  != pSrc2[1])  ||
             (pSrc1[2]  != pSrc2[2])  || (pSrc1[3]  != pSrc2[3])  ||
             (pSrc1[4]  != pSrc2[4])  || (pSrc1[5]  != pSrc2[5])  ||
             (pSrc1[6]  != pSrc2[6])  || (pSrc1[7]  != pSrc2[7])  ||
             (pSrc1[8]  != pSrc2[8])  || (pSrc1[9]  != pSrc2[9])  ||
             (pSrc1[10] != pSrc2[10]) || (pSrc1[11] != pSrc2[11]) ||
             (pSrc1[12] != pSrc2[12]) || (pSrc1[13] != pSrc2[13]) ||
             (pSrc1[14] != pSrc2[14]) || (pSrc1[15] != pSrc2[15]) ||
             (pSrc1[16] != pSrc2[16]) || (pSrc1[17] != pSrc2[17]) ||
             (pSrc1[18] != pSrc2[18]) || (pSrc1[19] != pSrc2[19]) ||
             (pSrc1[20] != pSrc2[20]) || (pSrc1[21] != pSrc2[21]) ||
             (pSrc1[22] != pSrc2[22]) || (pSrc1[23] != pSrc2[23]) ||
             (pSrc1[24] != pSrc2[24]) || (pSrc1[25] != pSrc2[25]) ||
             (pSrc1[26] != pSrc2[26]) || (pSrc1[27] != pSrc2[27]) ||
             (pSrc1[28] != pSrc2[28]) || (pSrc1[29] != pSrc2[29]) ||
             (pSrc1[30] != pSrc2[30]) || (pSrc1[31] != pSrc2[31]) )
            goto LocalRtlCompareUlongMemory_exit;

        pSrc1 += 32;
        pSrc2 += 32;
    }

    for (unroll = (Length & 0x1f) >> 2; unroll; unroll--) {
        if ( (pSrc1[0] != pSrc2[0]) || (pSrc1[1] != pSrc2[1]) ||
             (pSrc1[2] != pSrc2[2]) || (pSrc1[3] != pSrc2[3]) )
            goto LocalRtlCompareUlongMemory_exit;

        pSrc1 += 4;
        pSrc2 += 4;
    }

    for (unroll = (Length & 0x3) - 1; unroll >= 0; unroll--)
        if ( pSrc1[unroll] != pSrc2[unroll] )
            goto LocalRtlCompareUlongMemory_exit;

    bRet = TRUE;    // return TRUE if memory is identical

LocalRtlCompareUlongMemory_exit:

    return bRet;
}

//
// LocalRtlFillMemoryUshort
//
// Inline implementation of USHORT equivalent to RtlFillMemoryUlong,
// RtlFillMemoryUshort (does not currently exist in NT).  WORD alignment
// assumed for Destination.
//
// Parameters:
//
//  Destination     pointer to USHORT aligned destination
//  Length          number of bytes to fill
//  Pattern         fill pattern
//
_inline VOID LocalRtlFillMemoryUshort(PVOID Destination, ULONG Length,
             USHORT Pattern)
{
    if ( Length == 0 )
        return;

// If odd WORD, make it DWORD aligned by writing a WORD up front.

    if ( ((ULONG_PTR) Destination) & 0x2 )
    {
        *((USHORT *) Destination)++ = Pattern;
        Length -= sizeof(USHORT);

        if ( Length == 0 )
            return;
    }

// Now the Destination start is DWORD aligned.  If the remaining length
// is an odd number of WORDs, we will need to pick up an extra WORD write
// at the end.

    if ((Pattern == 0x0000) || (Pattern == 0xffff))
        memset(Destination, Pattern, Length);
    else {
        ULONG ulPattern = Pattern | (Pattern << 16);
        ULONG cjDwords;

    // Do what we can with DWORD writes.

        if ( cjDwords = (Length & (~3)) )
        {
            LocalRtlFillMemoryUlong((PVOID) Destination, cjDwords, ulPattern);
            ((BYTE *) Destination) += cjDwords;
        }

    // Pick up the last WORD.

        if ( Length & 3 )
            *((USHORT *) Destination) = Pattern;
    }
}

//
// LocalRtlFillMemory24
//
// Inline implementation of 24bit equivalent to RtlFillMemoryUlong,
// No assumptions made about alignment.
// Parameters:
//
//  Destination         pointer to destination
//  Length              number of bytes to fill
//  col0, col1, col2    Colors
//
_inline VOID LocalRtlFillMemory24(PVOID Destination, ULONG Length,
             BYTE col0, BYTE col1, BYTE col2)
{
    BYTE col[3];

    if ( Length == 0 )
        return;


    // Check for special cases, same valued components
    if ((col0 == col1) && (col0 == col2)) {

        memset(Destination, col0, Length);

    } else { //Other colors
    	ULONG ulPat1, ulPat2, ulPat3;
    	int rem;
    	int i, tmp;
        register ULONG *pDest;
        register BYTE *pByte = (BYTE *)Destination;
        LONG unroll;
    	
        // If not DWORD aligned, make it DWORD aligned.
    	tmp = (int)((ULONG_PTR) Destination & 0x3);
        switch ( 4 - tmp ) {
    	  case 1:
    		*pByte++ = col0;
    		Length--;
    		ulPat1 = (col1 << 24) | (col0 << 16) | (col2 << 8) | col1;
    		ulPat2 = (col2 << 24) | (col1 << 16) | (col0 << 8) | col2;
    		ulPat3 = (col0 << 24) | (col2 << 16) | (col1 << 8) | col0;
    		break;
    	  case 2:
    		*pByte++ = col0;
    		*pByte++ = col1;
    		Length -= 2;
    		ulPat1 = (col2 << 24) | (col1 << 16) | (col0 << 8) | col2;
    		ulPat2 = (col0 << 24) | (col2 << 16) | (col1 << 8) | col0;
    		ulPat3 = (col1 << 24) | (col0 << 16) | (col2 << 8) | col1;
    		break;
    	  case 3:
    		*pByte++ = col0;
    		*pByte++ = col1;
    		*pByte++ = col2;
    		Length -= 3;
    	  case 4:   // fall thru, 'cause the pattern is the same
    	  default:
    		ulPat1 = (col0 << 24) | (col2 << 16) | (col1 << 8) | col0;
    		ulPat2 = (col1 << 24) | (col0 << 16) | (col2 << 8) | col1;
    		ulPat3 = (col2 << 24) | (col1 << 16) | (col0 << 8) | col2;
    	}
    	
    	pDest = (ULONG *)pByte;
    	rem = Length % 48;
        Length >>= 2;
        for (unroll = Length/12; unroll; unroll--) {
            pDest[0] = ulPat1; pDest[1] = ulPat2;
            pDest[2] = ulPat3; pDest[3] = ulPat1;
            pDest[4] = ulPat2; pDest[5] = ulPat3;
            pDest[6] = ulPat1; pDest[7] = ulPat2;
            pDest[8] = ulPat3; pDest[9] = ulPat1;
            pDest[10] = ulPat2; pDest[11] = ulPat3;
            pDest += 12;
        }

        col[0] = (BYTE) (ulPat1 & 0x000000ff);
        col[1] = (BYTE) ((ulPat1 & 0x0000ff00) >> 8);
        col[2] = (BYTE) ((ulPat1 & 0x00ff0000) >> 16);

        pByte = (BYTE *)pDest;
    	for (i=0; i<rem; i++) *pByte++ = col [i%3];
    }
}

//
// LocalWriteMemoryAlign
//
// Inline implementation of RtlCopyMemory that ensures that the copy
// operation will write to the destination with DWORD alignment.
//
_inline VOID LocalWriteMemoryAlign(PBYTE pjDst, PBYTE pjSrc, ULONG cj)
{
    ULONG cjExtraBytes;
    ULONG cjDwords;

// If cj < sizeof(DWORD), then set cjExtraBytes to cj.  That's all we will
// need to do.
//
// Otherwise, compute the number of leading bytes to the next DWORD boundary.

    if ( cj < 4 )
        cjExtraBytes = cj;
    else
        cjExtraBytes = (ULONG)(4 - (((ULONG_PTR) pjDst) & 3)) & 3;

// Make dst array DWORD aligned by copying the leading non-DWORD aligned bytes.

    if ( cjExtraBytes )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }

        if ( (cj -= cjExtraBytes) == 0 )
            return;
    }

// Now the beginning of dst array is DWORD aligned.  If the remaining length
// is an odd number of BYTEs, we will need to pick up the extra BYTE writes
// at the end.

// Do what we can with DWORD copy.

    if ( cjDwords = (cj & (~3)) )
    {
        memcpy(pjDst, pjSrc, cjDwords);
        pjDst += cjDwords;
        pjSrc += cjDwords;
    }

// Pick up the remaining BYTES.

    if ( cjExtraBytes = (cj & 3) )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }
    }
}

//
// LocalReadMemoryAlign
//
// Inline implementation of RtlCopyMemory that ensures that the copy
// operation will read from the source with DWORD alignment.
//
_inline VOID LocalReadMemoryAlign(PBYTE pjDst, PBYTE pjSrc, ULONG cj)
{
    ULONG cjExtraBytes;
    ULONG cjDwords;

// If cj < sizeof(DWORD), then set cjExtraBytes to cj.  That's all we will
// need to do.
//
// Otherwise, compute the number of leading bytes to the next DWORD boundary.

    if ( cj < 4 )
        cjExtraBytes = cj;
    else
        cjExtraBytes = (ULONG) (4 - (((ULONG_PTR) pjSrc) & 3)) & 3;

// Take care of the leading BYTES.

    if ( cjExtraBytes )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }

        if ( (cj -= cjExtraBytes) == 0 )
            return;
    }

// Now the beginning of src array is DWORD aligned.  If the remaining length
// is an odd number of BYTEs, we will need to pick up the extra BYTE writes
// at the end.

// Do what we can with DWORD copy.

    if ( cjDwords = (cj & (~3)) )
    {
        memcpy(pjDst, pjSrc, cjDwords);
        pjDst += cjDwords;
        pjSrc += cjDwords;
    }

// Pick up the remaining BYTES.

    if ( cjExtraBytes = (cj & 3) )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }
    }
}

//
// LocalFillMemory
//
// Inline implementation of RtlFillMemory.  Assume that pjDst has only BYTE
// alignment.
//
_inline VOID LocalFillMemory(PBYTE pjDst, ULONG cj, BYTE j)
{
    ULONG cjExtraBytes;
    ULONG cjDwords;

// If cj < sizeof(DWORD), then set cjExtraBytes to cj.  That's all we will
// need to do.
//
// Otherwise, compute the number of leading bytes to the next DWORD boundary.

    if ( cj < 4 )
        cjExtraBytes = cj;
    else
        cjExtraBytes = (ULONG)(4 - (((ULONG_PTR) pjDst) & 3)) & 3;

// Take care of the leading BYTES.

    if ( cjExtraBytes )
    {
        switch ( cjExtraBytes )
        {
            case 3: *pjDst++ = j;
            case 2: *pjDst++ = j;
            case 1: *pjDst++ = j;
        }

        if ( (cj -= cjExtraBytes) == 0 )
            return;
    }

// Now both arrays start is DWORD aligned.  If the remaining length
// is an odd number of BYTEs, we will need to pick up the extra BYTE writes
// at the end.

// Do what we can with DWORD copy.

    if ( cjDwords = (cj & (~3)) )
    {
        ULONG ul = j | (j<<8) | (j<<16) | (j<<24);

        LocalRtlFillMemoryUlong((PVOID) pjDst, cjDwords, ul);
        pjDst += cjDwords;
    }

// Pick up the remaining BYTES.

    if ( cjExtraBytes = (cj & 3) )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = j;
            case 2: *pjDst++ = j;
            case 1: *pjDst++ = j;
        }
    }
}

//
// LocalZeroMemory
//
// Inline implementation of RtlFillMemory.  Assume that pjDst has only BYTE
// alignment.
//
_inline VOID LocalZeroMemory(PBYTE pjDst, ULONG cj)
{
    LocalFillMemory(pjDst, cj, 0);
}

#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory
#undef RtlFillMemoryUlong
#undef RtlFillMemory24

#define RtlMoveMemory(d, s, l)          memmove((d),(s),(l))
#define RtlCopyMemory(d, s, l)          memcpy((d),(s),(l))
#define RtlFillMemoryUlong(d, cj, ul)   LocalRtlFillMemoryUlong((PVOID)(d),(ULONG)(cj),(ULONG)(ul))
#define RtlFillMemoryUshort(d, cj, us)  LocalRtlFillMemoryUshort((PVOID)(d),(ULONG)(cj),(USHORT)(us))
#define RtlFillMemory24(d, cj, c0, c1, c2)  LocalRtlFillMemory24((PVOID)(d),(ULONG)(cj),(BYTE)c0,(BYTE)c1,(BYTE)c2)

// RtlCopyMemory_UnalignedDst should be used if the src is guaranteed to have
// DWORD alignment, but the dst does not.
//
// RtlCopyMemory_UnalignedSrc should be used if the dst is guaranteed to have
// DWORD alignment, but the src does not.

#if defined(i386)
#define RtlFillMemory(d, cj, j)             LocalFillMemory((PBYTE)(d),(ULONG)(cj),(BYTE)(j))
#define RtlZeroMemory(d, cj)                LocalZeroMemory((PBYTE)(d),(ULONG)(cj))
#define RtlCopyMemory_UnalignedDst(d, s, l) LocalWriteMemoryAlign((PBYTE)(d),(PBYTE)(s),(ULONG)(l))
#define RtlCopyMemory_UnalignedSrc(d, s, l) LocalReadMemoryAlign((PBYTE)(d),(PBYTE)(s),(ULONG)(l))
#else
#define RtlFillMemory(d, cj, j)             memset((d),(j),(cj))
#define RtlZeroMemory(d, cj)                memset((d),0,(cj))
#define RtlCopyMemory_UnalignedDst(d, s, l) memcpy((d),(s),(l))
#define RtlCopyMemory_UnalignedSrc(d, s, l) memcpy((d),(s),(l))
#endif

#include "oleauto.h"
#include "batchinf.h"
#include "glteb.h"
#include "debug.h"
#include "asm.h"

#endif /* __glos_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\mcdcx.h ===
/******************************Module*Header*******************************\
* Module Name: mcdcx.h
*
* MCD support: structures, variables, constants, and functions.
*
* Created: 26-Feb-1996 12:30:41
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDCX_H_
#define _MCDCX_H_

//
// Handy forward declaration.
//

typedef struct __GLGENbuffersRec __GLGENbuffers;
typedef struct __GLGENcontextRec __GLGENcontext;

//
// Macros to maintain MCD dirty state:
//
//  MCD_STATE_DIRTY     set specified dirty flag
//  MCD_STATE_CLEAR     clear specified dirty flag
//  MCD_STATE_RESET     clear all dirty flags
//  MCD_STATE_DIRTYTEST check state flag (TRUE if dirty)
//

#define MCD_STATE_DIRTY(gc, stateName)\
{\
    if (((__GLGENcontext *) (gc))->pMcdState)\
        ((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState |= MCD_DIRTY_##stateName;\
}
#define MCD_STATE_CLEAR(gc, stateName)\
{\
    if (((__GLGENcontext *) (gc))->pMcdState)\
        ((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState &= ~MCD_DIRTY_##stateName;\
}
#define MCD_STATE_RESET(gc)\
{\
    if (((__GLGENcontext *) (gc))->pMcdState)\
        ((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState = 0;\
}
#define MCD_STATE_DIRTYTEST(gc, stateName)\
(\
    (((__GLGENcontext *) (gc))->pMcdState) &&\
    (((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState & MCD_DIRTY_##stateName)\
)

//
// MCD interface functions.  These functions call the MCD client interface.
// The function implementations are found in generic\mcdcx.c.
//

BOOL FASTCALL bInitMcd(HDC hdc);
BOOL FASTCALL bInitMcdContext(__GLGENcontext *, GLGENwindow *);
BOOL FASTCALL bInitMcdSurface(__GLGENcontext *, GLGENwindow *, __GLGENbuffers *);
void FASTCALL GenMcdDeleteContext(GENMCDSTATE *);
void FASTCALL GenMcdDeleteSurface(GENMCDSURFACE *);
BOOL FASTCALL GenMcdMakeCurrent(__GLGENcontext *gengc, GLGENwindow *pwnd);
void FASTCALL GenMcdInitDepth(__GLcontext *, __GLdepthBuffer *);
void FASTCALL GenMcdClear(__GLGENcontext *, ULONG *);
void FASTCALL GenMcdClearDepth16(__GLdepthBuffer *);
void FASTCALL GenMcdClearDepth32(__GLdepthBuffer *);
void FASTCALL GenMcdUpdateRenderState(__GLGENcontext *);
void FASTCALL GenMcdViewport(__GLGENcontext *);
void FASTCALL GenMcdScissor(__GLGENcontext *);
void FASTCALL GenMcdUpdateScissorState(__GLGENcontext *);
void FASTCALL GenMcdUpdateTexEnvState(__GLGENcontext *);
POLYARRAY * FASTCALL GenMcdDrawPrim(__GLGENcontext *, POLYARRAY *);
void FASTCALL GenMcdSwapBatch(__GLGENcontext *);
BOOL FASTCALL GenMcdSwapBuffers(HDC, GLGENwindow *pwnd);
BOOL FASTCALL GenMcdResizeBuffers(__GLGENcontext *);
BOOL FASTCALL GenMcdUpdateBufferInfo(__GLGENcontext *);
void GenMcdCopyPixels(__GLGENcontext *, __GLcolorBuffer *, GLint, GLint, GLint, BOOL);
void FASTCALL GenMcdSynchronize(__GLGENcontext *);
BOOL FASTCALL GenMcdConvertContext(__GLGENcontext *, __GLGENbuffers *);
PVOID FASTCALL GenMcdReadZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx);
void  FASTCALL GenMcdWriteZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx);
MCDHANDLE FASTCALL GenMcdCreateTexture(__GLGENcontext *gengc, __GLtexture *tex,
                                       ULONG flags);
BOOL FASTCALL GenMcdDeleteTexture(__GLGENcontext *gengc, MCDHANDLE texHandle);
BOOL FASTCALL GenMcdUpdateSubTexture(__GLGENcontext *ggenc, __GLtexture *tex,
                                     MCDHANDLE texHandle, GLint lod, 
                                     GLint xoffset, GLint yoffset, 
                                     GLsizei w, GLsizei h);
BOOL FASTCALL GenMcdUpdateTexturePalette(__GLGENcontext *gengc, __GLtexture *tex,
                                         MCDHANDLE texHandle, GLsizei start,
                                         GLsizei count);
BOOL FASTCALL GenMcdUpdateTexturePriority(__GLGENcontext *gengc, __GLtexture *tex,
                                          MCDHANDLE texHandle);
BOOL FASTCALL GenMcdUpdateTextureState(__GLGENcontext *gengc, __GLtexture *tex,
                                       MCDHANDLE texHandle);
void FASTCALL GenMcdUpdateFineState(__GLGENcontext *gengc);
DWORD FASTCALL GenMcdTextureStatus(__GLGENcontext *gengc, MCDHANDLE texHandle);
DWORD FASTCALL GenMcdTextureKey(__GLGENcontext *gengc, MCDHANDLE texHandle);
VOID FASTCALL GenMcdSetScaling(__GLGENcontext *gengc);
typedef enum { VP_FIXBIAS, VP_NOBIAS } VP_BIAS_TYPE;
BOOL FASTCALL GenMcdResetViewportAdj(__GLcontext *, VP_BIAS_TYPE);
BOOL FASTCALL GenMcdDescribeLayerPlane(HDC hdc, int iPixelFormat,
                                       int iLayerPlane, UINT nBytes,
                                       LPLAYERPLANEDESCRIPTOR plpd);
int  FASTCALL GenMcdSetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                           int iStart, int cEntries,
                                           CONST COLORREF *pcr);
int  FASTCALL GenMcdGetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                           int iStart, int cEntries,
                                           COLORREF *pcr);
int  FASTCALL GenMcdRealizeLayerPalette(HDC hdc, int iLayerPlane,
                                        BOOL bRealize);
BOOL FASTCALL GenMcdSwapLayerBuffers(HDC hdc, UINT fuFlags);
void FASTCALL GenMcdUpdatePixelState(__GLGENcontext *gengc);
ULONG FASTCALL GenMcdDrawPix(__GLGENcontext *gengc, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels, BOOL packed);
ULONG FASTCALL GenMcdReadPix(__GLGENcontext *gengc, LONG x, LONG y, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels);
ULONG FASTCALL GenMcdCopyPix(__GLGENcontext *gengc, LONG x, LONG y, ULONG width,
                             ULONG height, ULONG type);
ULONG FASTCALL GenMcdPixelMap(__GLGENcontext *gengc, ULONG mapType,
                              ULONG mapSize, VOID *pMap);
void FASTCALL GenMcdDestroyWindow(GLGENwindow *pwnd);
int FASTCALL GenMcdGetTextureFormats(__GLGENcontext *gengc, int nFmts,
                                     struct _DDSURFACEDESC *pddsd);
DWORD FASTCALL GenMcdSwapMultiple(UINT cBuffers, GENMCDSWAP *pgms);

// Note:
// GenMcdGenericCompatibleFormat is implemented in pixelfmt.c
BOOL FASTCALL GenMcdGenericCompatibleFormat(__GLGENcontext *gengc);

//
// Depth test drawing functions that utilize an intermediate scanline
// depth buffer to access the MCD depth buffer.
//

GLboolean FASTCALL GenMcdDepthTestLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStippledLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilStippledLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestSpan(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStippledSpan(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilSpan(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilStippledSpan(__GLcontext *);
GLboolean FASTCALL GenMcdStippleAnyDepthTestSpan(__GLcontext *);

// 2.0 Front-end processing call
POLYARRAY * FASTCALL GenMcdProcessPrim(__GLGENcontext *gengc, POLYARRAY *pa,
                                       ULONG cmdFlagsAll, ULONG primFlags,
                                       MCDTRANSFORM *pMCDTransform,
                                       MCDMATERIALCHANGES *pMCDMatChanges);

//
// "Safe" version of __fastGenFillTriangle that does not allow floating
// point divides to straddle an MCD function call.
//

extern void FASTCALL __fastGenMcdFillTriangle(__GLcontext *, __GLvertex *,
                                     __GLvertex *, __GLvertex *, GLboolean);

//
// MCD32.DLL entry points.
//
// Rather than link directly to MCD32.DLL (thereby requiring its existence
// to run OPENGL32.DLL), we load it and hook its entry points as needed.
// This table stores the function pointers we hook.
//

typedef BOOL     (APIENTRY *MCDGETDRIVERINFOFUNC)(HDC hdc, struct _MCDDRIVERINFOI *pMCDDriverInfo);
typedef LONG     (APIENTRY *MCDDESCRIBEMCDPIXELFORMATFUNC)(HDC hdc, LONG iPixelFormat,
                                                           MCDPIXELFORMAT *pMcdPixelFmt);
typedef LONG     (APIENTRY *MCDDESCRIBEPIXELFORMATFUNC)(HDC hdc, LONG iPixelFormat,
                                                        LPPIXELFORMATDESCRIPTOR ppfd);
typedef BOOL     (APIENTRY *MCDCREATECONTEXTFUNC)(MCDCONTEXT *pMCDContext,
                                                  MCDRCINFOPRIV *pMcdRcInfo,
                                                  struct _GLSURF *pgsurf,
                                                  int ipfd,
                                                  ULONG flags);
typedef BOOL      (APIENTRY *MCDDELETECONTEXTFUNC)(MCDCONTEXT *pMCDContext);
typedef UCHAR *   (APIENTRY *MCDALLOCFUNC)(MCDCONTEXT *pMCDContext, ULONG numBytes, MCDHANDLE *pMCDHandle,
                                           ULONG flags);
typedef BOOL      (APIENTRY *MCDFREEFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
typedef VOID      (APIENTRY *MCDBEGINSTATEFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
typedef BOOL      (APIENTRY *MCDFLUSHSTATEFUNC)(VOID *pMCDMem);
typedef BOOL      (APIENTRY *MCDADDSTATEFUNC)(VOID *pMCDMem, ULONG stateToChange,
                                              ULONG stateValue);
typedef BOOL      (APIENTRY *MCDADDSTATESTRUCTFUNC)(VOID *pMCDMem, ULONG stateToChange,
                                                    VOID *pStateValue, ULONG stateValueSize);
typedef BOOL      (APIENTRY *MCDSETVIEWPORTFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                                 MCDVIEWPORT *pMCDViewport);
typedef BOOL      (APIENTRY *MCDSETSCISSORRECTFUNC)(MCDCONTEXT *pMCDContext, RECTL *pRect,
                                                    BOOL bEnabled);
typedef ULONG     (APIENTRY *MCDQUERYMEMSTATUSFUNC)(VOID *pMCDMem);
typedef PVOID     (APIENTRY *MCDPROCESSBATCHFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                                  ULONG batchSize, VOID *pMCDFirstCmd,
                                                  int cExtraSurfaces,
                                                  struct IDirectDrawSurface **pdds);
typedef BOOL      (APIENTRY *MCDREADSPANFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                              ULONG x, ULONG y, ULONG numPixels, ULONG type);
typedef BOOL      (APIENTRY *MCDWRITESPANFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                               ULONG x, ULONG y, ULONG numPixels, ULONG type);
typedef BOOL      (APIENTRY *MCDCLEARFUNC)(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers);
typedef BOOL      (APIENTRY *MCDSWAPFUNC)(MCDCONTEXT *pMCDContext, ULONG flags);
typedef BOOL      (APIENTRY *MCDGETBUFFERSFUNC)(MCDCONTEXT *pMCDContext, MCDRECTBUFFERS *pMCDBuffers);
typedef BOOL      (APIENTRY *MCDALLOCBUFFERSFUNC)(MCDCONTEXT *pMCDContext, RECTL *pWndRect);
typedef ULONG     (APIENTRY *MCDLOCKFUNC)(MCDCONTEXT *pMCDContext);
typedef VOID      (APIENTRY *MCDUNLOCKFUNC)(MCDCONTEXT *pMCDContext);
typedef BOOL      (APIENTRY *MCDBINDCONTEXT)(MCDCONTEXT *pMCDContext, HDC hdc,
                                             struct GLGENwindowRec *pwnd);
typedef BOOL      (APIENTRY *MCDSYNCFUNC)(MCDCONTEXT *pMCDContext);
typedef MCDHANDLE (APIENTRY *MCDCREATETEXTUREFUNC)(MCDCONTEXT *pMCDContext, 
                                MCDTEXTUREDATA *pTexData,
                                ULONG flags, VOID *pSurface);
typedef BOOL      (APIENTRY *MCDDELETETEXTUREFUNC)(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
typedef BOOL      (APIENTRY *MCDUPDATESUBTEXTUREFUNC)(MCDCONTEXT *pMCDContext,
                                MCDTEXTUREDATA *pTexData, MCDHANDLE hTex, 
                                ULONG lod, RECTL *pRect);
typedef BOOL      (APIENTRY *MCDUPDATETEXTUREPALETTEFUNC)(MCDCONTEXT *pMCDContext, 
                                MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                ULONG start, ULONG numEntries);
typedef BOOL      (APIENTRY *MCDUPDATETEXTUREPRIORITYFUNC)(MCDCONTEXT *pMCDContext, 
                                MCDTEXTUREDATA *pTexData,
                                MCDHANDLE hTex);
typedef ULONG     (APIENTRY *MCDTEXTURESTATUSFUNC)(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
typedef ULONG     (APIENTRY *MCDTEXTUREKEYFUNC)(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
typedef BOOL      (APIENTRY *MCDDESCRIBEMCDLAYERPLANEFUNC)(HDC hdc,
                                LONG iPixelFormat, LONG iLayerPlane,
                                MCDLAYERPLANE *pMcdLayer);
typedef BOOL      (APIENTRY *MCDDESCRIBELAYERPLANEFUNC)(HDC hdc,
                                LONG iPixelFormat, LONG iLayerPlane,
                                LPLAYERPLANEDESCRIPTOR plpd);
typedef LONG      (APIENTRY *MCDSETLAYERPALETTEFUNC)(HDC hdc, LONG iLayerPlane,
                                BOOL bRealize, LONG cEntries, COLORREF *pcr);
typedef ULONG     (APIENTRY *MCDDRAWPIXELS)(MCDCONTEXT *pMCDContext, ULONG width,
                                ULONG height, ULONG format, ULONG type,
                                VOID *pPixels, BOOL packed);
typedef ULONG     (APIENTRY *MCDREADPIXELS)(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width,
                                ULONG height, ULONG format, ULONG type,
                                VOID *pPixels);
typedef ULONG     (APIENTRY *MCDCOPYPIXELS)(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width,
                                ULONG height, ULONG type);
typedef ULONG     (APIENTRY *MCDPIXELMAP)(MCDCONTEXT *pMCDContext, ULONG mapType,
                                ULONG mapSize, VOID *pMap);
typedef void      (APIENTRY *MCDDESTROYWINDOW)(HDC hdc, ULONG_PTR dwMcdWindow);
typedef int       (APIENTRY *MCDGETTEXTUREFORMATS)(MCDCONTEXT *pMCDContext,
                                                   int nFmts,
                                                   struct _DDSURFACEDESC *pddsd);
typedef DWORD     (APIENTRY *MCDSWAPMULTIPLE)(HDC hdc,
                                              UINT cBuffers,
                                              GENMCDSWAP *pgms);

typedef PVOID     (APIENTRY *MCDPROCESSBATCH2FUNC)(MCDCONTEXT *pMCDContext,
                                                   VOID *pMCDCmdMem,
                                                   VOID *pMCDPrimMem,
                                                   MCDCOMMAND *pMCDFirstCmd,
                                                   int cExtraSurfaces,
                                                   struct
                                                   IDirectDrawSurface **pdds,
                                                   ULONG cmdFlagsAll,
                                                   ULONG primFlags,
                                                   MCDTRANSFORM *pMCDTransform,
                                                   MCDMATERIALCHANGES
                                                   *pMCDMatChanges);

typedef struct _MCDTABLE_ {
    MCDGETDRIVERINFOFUNC            pMCDGetDriverInfo;
    MCDDESCRIBEMCDPIXELFORMATFUNC   pMCDDescribeMcdPixelFormat;
    MCDDESCRIBEPIXELFORMATFUNC      pMCDDescribePixelFormat;
    MCDCREATECONTEXTFUNC            pMCDCreateContext;
    MCDDELETECONTEXTFUNC            pMCDDeleteContext;
    MCDALLOCFUNC                    pMCDAlloc;
    MCDFREEFUNC                     pMCDFree;
    MCDBEGINSTATEFUNC               pMCDBeginState;
    MCDFLUSHSTATEFUNC               pMCDFlushState;
    MCDADDSTATEFUNC                 pMCDAddState;
    MCDADDSTATESTRUCTFUNC           pMCDAddStateStruct;
    MCDSETVIEWPORTFUNC              pMCDSetViewport;
    MCDSETSCISSORRECTFUNC           pMCDSetScissorRect;
    MCDQUERYMEMSTATUSFUNC           pMCDQueryMemStatus;
    MCDPROCESSBATCHFUNC             pMCDProcessBatch;
    MCDREADSPANFUNC                 pMCDReadSpan;
    MCDWRITESPANFUNC                pMCDWriteSpan;
    MCDCLEARFUNC                    pMCDClear;
    MCDSWAPFUNC                     pMCDSwap;
    MCDGETBUFFERSFUNC               pMCDGetBuffers;
    MCDALLOCBUFFERSFUNC             pMCDAllocBuffers;
    MCDLOCKFUNC                     pMCDLock;
    MCDUNLOCKFUNC                   pMCDUnlock;
    MCDBINDCONTEXT                  pMCDBindContext;
    MCDSYNCFUNC                     pMCDSync;
    MCDCREATETEXTUREFUNC            pMCDCreateTexture;
    MCDDELETETEXTUREFUNC            pMCDDeleteTexture;
    MCDUPDATESUBTEXTUREFUNC         pMCDUpdateSubTexture;
    MCDUPDATETEXTUREPALETTEFUNC     pMCDUpdateTexturePalette;
    MCDUPDATETEXTUREPRIORITYFUNC    pMCDUpdateTexturePriority;
    MCDUPDATETEXTUREPRIORITYFUNC    pMCDUpdateTextureState;
    MCDTEXTURESTATUSFUNC            pMCDTextureStatus;
    MCDTEXTUREKEYFUNC               pMCDTextureKey;
    MCDDESCRIBEMCDLAYERPLANEFUNC    pMCDDescribeMcdLayerPlane;
    MCDDESCRIBELAYERPLANEFUNC       pMCDDescribeLayerPlane;
    MCDSETLAYERPALETTEFUNC          pMCDSetLayerPalette;
    MCDDRAWPIXELS                   pMCDDrawPixels;
    MCDREADPIXELS                   pMCDReadPixels;
    MCDCOPYPIXELS                   pMCDCopyPixels;
    MCDPIXELMAP                     pMCDPixelMap;
    MCDDESTROYWINDOW                pMCDDestroyWindow;
    MCDGETTEXTUREFORMATS            pMCDGetTextureFormats;
    MCDSWAPMULTIPLE                 pMCDSwapMultiple;
    MCDPROCESSBATCH2FUNC            pMCDProcessBatch2;
} MCDTABLE;

extern MCDTABLE *gpMcdTable;
extern MCDDRIVERINFOI McdDriverInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\pixel.h ===
#ifndef _pixel_h_
#define _pixel_h_

/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "vertex.h"
#include "constant.h"

/* Not much for elegance, but it works. */
#define __GL_N_PIXEL_MAPS       (GL_PIXEL_MAP_A_TO_A - GL_PIXEL_MAP_I_TO_I + 1)
#define __GL_REMAP_PM(x)        ((x) - GL_PIXEL_MAP_I_TO_I)
#define __GL_PIXEL_MAP_I_TO_I   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_I)
#define __GL_PIXEL_MAP_S_TO_S   __GL_REMAP_PM(GL_PIXEL_MAP_S_TO_S)
#define __GL_PIXEL_MAP_I_TO_R   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_R)
#define __GL_PIXEL_MAP_I_TO_G   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_G)
#define __GL_PIXEL_MAP_I_TO_B   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_B)
#define __GL_PIXEL_MAP_I_TO_A   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_A)
#define __GL_PIXEL_MAP_R_TO_R   __GL_REMAP_PM(GL_PIXEL_MAP_R_TO_R)
#define __GL_PIXEL_MAP_G_TO_G   __GL_REMAP_PM(GL_PIXEL_MAP_G_TO_G)
#define __GL_PIXEL_MAP_B_TO_B   __GL_REMAP_PM(GL_PIXEL_MAP_B_TO_B)
#define __GL_PIXEL_MAP_A_TO_A   __GL_REMAP_PM(GL_PIXEL_MAP_A_TO_A)

/*
** Pixel type not exlicitly defined by the spec, but implictly suggested.
*/
#define __GL_RED_ALPHA		1

#ifdef GL_EXT_paletted_texture
// Pixel type needed to distinguish paletted texture data from
// normal color index
#define __GL_PALETTE_INDEX      2
#endif

typedef struct __GLpixelMapHeadRec {
    GLint size;
    GLint tableId;
    union {
        GLint *mapI;		/* access index (integral) entries */
        __GLfloat *mapF;	/* access component (float) entries */
    } base;
} __GLpixelMapHead;

//!!! Don't change this structure without changing MCDPIXELTRANSFER !!!

typedef struct __GLpixelTransferModeRec {
    __GLfloat r_scale, g_scale, b_scale, a_scale, d_scale;
    __GLfloat r_bias, g_bias, b_bias, a_bias, d_bias;
    __GLfloat zoomX;
    __GLfloat zoomY;

    GLint indexShift;
    GLint indexOffset;

    GLboolean mapColor;
    GLboolean mapStencil;
} __GLpixelTransferMode;

//!!! Don't change this structure without changing MCDPIXELPACK !!!

typedef struct __GLpixelPackModeRec {
    GLboolean swapEndian;
    GLboolean lsbFirst;

    GLuint lineLength;
    GLuint skipLines;
    GLuint skipPixels;
    GLuint alignment;
} __GLpixelPackMode;

//!!! Don't change this structure without changing MCDPIXELUNPACK !!!

typedef struct __GLpixelUnpackModeRec {
    GLboolean swapEndian;
    GLboolean lsbFirst;

    GLuint lineLength;
    GLuint skipLines;
    GLuint skipPixels;
    GLuint alignment;
} __GLpixelUnpackMode;

typedef struct __GLpixelStateRec {
    __GLpixelTransferMode transferMode;
    __GLpixelMapHead pixelMap[__GL_N_PIXEL_MAPS];
    __GLpixelPackMode packModes;
    __GLpixelUnpackMode unpackModes;
    GLuint pixelMapTableId;

    /*
    ** Read buffer.  Where pixel reads come from.
    */
    GLenum readBuffer;

    /*
    ** Read buffer specified by user.  May be different from readBuffer
    ** above.  If the user specifies GL_FRONT_LEFT, for example, then 
    ** readBuffer is set to GL_FRONT, and readBufferReturn to 
    ** GL_FRONT_LEFT.
    */
    GLenum readBufferReturn;
} __GLpixelState;

typedef struct __GLpixelMachineRec {
    GLboolean modifyRGBA;	/* Is the RGBA path being modified? */
    GLboolean modifyCI;
    GLboolean modifyDepth;
    GLboolean modifyStencil;
    /* scaled values indicating what a red of 0 maps to, an alpha of 1 ... */
    GLfloat red0Mod, green0Mod, blue0Mod, alpha1Mod;
    GLfloat *redMap;		/* Lookup tables with no modification */
    GLfloat *greenMap;
    GLfloat *blueMap;
    GLfloat *alphaMap;
    GLfloat *iMap;
    GLvoid *iCurMap, *redCurMap, *greenCurMap, *blueCurMap, *alphaCurMap;
    GLboolean rgbaCurrent;	
    GLfloat *redModMap;		/* Lookup tables for modification path */
    GLfloat *greenModMap;
    GLfloat *blueModMap;
    GLfloat *alphaModMap;
    GLboolean iToICurrent;	/* Lookup table for modification of CI */
    GLfloat *iToIMap;
    GLboolean iToRGBACurrent;	/* Lookup tables from CI to RGBA */
    GLfloat *iToRMap;
    GLfloat *iToGMap;
    GLfloat *iToBMap;
    GLfloat *iToAMap;
} __GLpixelMachine;

extern void FASTCALL __glInitDefaultPixelMap(__GLcontext *gc, GLenum map);

/************************************************************************/

#define __GL_MAX_SPAN_SIZE	(__GL_MAX_MAX_VIEWPORT * 4 * sizeof(GLfloat))

struct __GLpixelSpanInfoRec {
    GLenum srcFormat, srcType;	/* Form of source image */
    const GLvoid *srcImage;	/* The source image */
    GLvoid *srcCurrent;		/* The current pointer into the source data */
    GLint srcRowIncrement;	/* Add this much to get to the next row */
    GLint srcGroupIncrement;	/* Add this much to get to the next group */
    GLint srcComponents;	/* (4 for RGBA, 1 for ALPHA, etc.) */
    GLint srcElementSize;	/* Size of one element (1 for BYTE) */
    GLint srcSwapBytes;		
    GLint srcLsbFirst;
    GLint srcSkipPixels, srcSkipLines;
    GLint srcLineLength;
    GLint srcAlignment;
    GLboolean srcPackedData;	/* True if source data is packed */
    GLint srcStartBit;		/* After applying skipPixels */

    GLenum dstFormat, dstType;	/* Form of destination image */
    const GLvoid *dstImage;	/* The destination image */
    GLvoid *dstCurrent;		/* The current pointer into the dest data */
    GLint dstRowIncrement;	/* Add this much to get to the next row */
    GLint dstGroupIncrement;	/* Add this much to get to the next group */
    GLint dstComponents;	/* (4 for RGBA, 1 for ALPHA, etc.) */
    GLint dstElementSize;	/* Size of one element (1 for BYTE) */
    GLint dstSwapBytes;		
    GLint dstLsbFirst;
    GLint dstSkipPixels, dstSkipLines;
    GLint dstLineLength;
    GLint dstAlignment;
    GLboolean dstPackedData;	/* True if destination data is packed */
    GLint dstStartBit;		/* After applying skipPixels */

    __GLfloat zoomx, zoomy;
    GLint width, height;	/* Size of image */
    GLint realWidth;		/* Width of actual span (after xZoom) */
    __GLfloat readX, readY;	/* Reading coords (CopyPixels, ReadPixels) */
    __GLfloat x, y;		/* Effective raster coordinates */
    GLint startCol, startRow;	/* First actual pixel goes here */
    GLint endCol;		/* Last column rendered (minus coladd) */
    GLint columns, rows;	/* Taking zoomx, zoomy into account */
    GLboolean overlap;		/* Do CopyPixels src/dest regions overlap? */
    GLint rowsUp, rowsDown;	/* Stuff for overlapping CopyPixels regions */
    GLint rowadd, coladd;	/* Adders for incrementing the col or row */
    __GLfloat rendZoomx;	/* effective zoomx for render span */
    __GLzValue fragz;		/* save this computation in the span walker */
    __GLfloat rpyUp, rpyDown;
    GLint startUp, startDown;
    GLint readUp, readDown;
    GLvoid *redMap, *greenMap, *blueMap, *alphaMap;
    GLvoid *indexMap;
    GLshort *pixelArray;	/* Array of pixel relication counts (if    */
				/* zoomx < -1 or zoomx > 1) or pixels to   */
				/* skip (if zoomx < 1 and zoomx > -1).     */

#ifdef GL_EXT_paletted_texture
    // Used when the source or destination has a palette
    // These fields are only used for expanding palette index
    // data into RGBA so only source fields are needed
    RGBQUAD *srcPalette;
    GLint srcPaletteSize;
#endif
    
    /*
    ** A pile of span routines used by the DrawPixels, ReadPixels, and 
    ** CopyPixels functions.
    */
    void (FASTCALL *spanReader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *outspan);
    void (*(spanModifier[7]))(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *spanRender)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan);
};

/* px_api.c */
extern GLboolean __glCheckDrawPixelArgs(__GLcontext *gc, GLsizei width, 
					GLsizei height, GLenum format, 
					GLenum type);
void FASTCALL __glPixelSetColorScales(__GLcontext *);

/* px_paths.c */
GLboolean FASTCALL __glClipDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glComputeSpanPixelArray(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glLoadUnpackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLboolean packed);
void __glInitDrawPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLint width, GLint height, GLenum format, 
                            GLenum type, const GLvoid *pixels);
void FASTCALL __glDrawPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSlowPickDrawPixels(__GLcontext *gc, GLint width, GLint height,
                            GLenum format, GLenum type, const GLvoid *pixels,
			    GLboolean packed);
void FASTCALL __glGenericPickDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean FASTCALL __glClipReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glLoadPackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glInitReadPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLint x, GLint y, GLint width, GLint height, 
                            GLenum format, GLenum type, const GLvoid *pixels);
void FASTCALL __glReadPixels5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSlowPickReadPixels(__GLcontext *gc, GLint x, GLint y,
                            GLsizei width, GLsizei height,
                            GLenum format, GLenum type, const GLvoid *pixels);
void FASTCALL __glGenericPickReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean FASTCALL __glClipCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glInitCopyPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                            GLint x, GLint y, GLint width, GLint height, 
                            GLenum format);
void FASTCALL __glCopyPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyPixelsOverlapping(__GLcontext *gc,
                               __GLpixelSpanInfo *spanInfo, GLint modifiers);
void __glSlowPickCopyPixels(__GLcontext *gc, GLint x, GLint y, GLint width,
                            GLint height, GLenum type);
void FASTCALL __glGenericPickCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage6(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage7(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glGenericPickCopyImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLboolean applyPixelTransfer);

/* px_modify.c */
void FASTCALL __glBuildRGBAModifyTables(__GLcontext *gc, __GLpixelMachine *pm);
void FASTCALL __glBuildItoIModifyTables(__GLcontext *gc, __GLpixelMachine *pm);
void FASTCALL __glBuildItoRGBAModifyTables(__GLcontext *gc,
				  __GLpixelMachine *pm);
void __glSpanModifyRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		        GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		       GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		        GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			 GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			 GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *inspan, GLvoid *outspan);

/* px_pack.c */
void FASTCALL __glInitPacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSpanReduceRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#ifdef GL_EXT_bgra
void __glSpanReduceBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#endif
void __glSpanReduceLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanPackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanPackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                     GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanPackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanPackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanCopy(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
void __glSpanPackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan);

/* px_read.c */
void FASTCALL __glSpanReadRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *span);
void FASTCALL __glSpanReadRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *span);
void FASTCALL __glSpanReadCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                    GLvoid *span);
void FASTCALL __glSpanReadCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                     GLvoid *span);
void FASTCALL __glSpanReadDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *span);
void FASTCALL __glSpanReadDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *span);
void FASTCALL __glSpanReadStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *span);
void FASTCALL __glSpanReadStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *span);

/* px_render.c */
void FASTCALL __glSlowDrawPixelsStore(__GLcolorBuffer *cfb, const __GLfragment *frag);
void FASTCALL __glSpanRenderRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderRGBubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderRGBAubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLvoid *span);
void FASTCALL __glSpanRenderDepthUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderDepthUint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLvoid *span);
void FASTCALL __glSpanRenderDepth2Uint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLvoid *span);
void FASTCALL __glSpanRenderDepth2Uint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                               GLvoid *span);
void FASTCALL __glSpanRenderStencilUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                 GLvoid *span);
void FASTCALL __glSpanRenderStencilUshort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *span);
void FASTCALL __glSpanRenderStencilUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                GLvoid *span);
void FASTCALL __glSpanRenderStencilUbyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                 GLvoid *span);
void FASTCALL __glSpanRenderCIushort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderCIushort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderCIubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *span);
void FASTCALL __glSpanRenderCIubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderCIubyte3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderCIubyte4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *span);
void FASTCALL __glSpanRenderRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *span);
void FASTCALL __glSpanRenderDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *span);
void FASTCALL __glSpanRenderDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *span);
void FASTCALL __glSpanRenderCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *span);
void FASTCALL __glSpanRenderCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *span);
void FASTCALL __glSpanRenderStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *span);
void FASTCALL __glSpanRenderStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);

/* px_unpack.c */
GLint FASTCALL __glElementsPerGroup(GLenum format);
__GLfloat FASTCALL __glBytesPerElement(GLenum type);
void FASTCALL __glInitUnpacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSpanUnpackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackBitmap2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackIndexUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                              GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapAndSkipBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                               GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapAndSkipBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                               GLvoid *inspan, GLvoid *outspan);
void __glSpanSkipPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanSlowSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanSlowSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanClampFloat(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanClampSigned(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
#ifdef GL_EXT_bgra
void __glSpanExpandBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
#endif
void __glSpanExpandLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanScaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanUnscaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#ifdef GL_EXT_bgra
void __glSpanScaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanUnscaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#endif
#ifdef GL_EXT_paletted_texture
void __glSpanModifyPI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanScalePI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                     GLvoid *inspan, GLvoid *outspan);
#endif

#endif /* _pixel_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\phong.h ===
#ifndef __glphong_h_
#define __glphong_h_

#include "types.h"


#ifdef GL_WIN_phong_shading

//Definitions for the phong-flag
#define __GL_PHONG_INV_COLOR_VALID              0x00000001
#define __GL_PHONG_NEED_EYE_XPOLATE             0x00000002
#define __GL_PHONG_NEED_COLOR_XPOLATE           0x00000004

#define __GL_PHONG_ALREADY_SORTED               0x00000010
#define __GL_PHONG_USE_FAST_COLOR               0x00000020
#define __GL_PHONG_USE_SLOW_COLOR               0x00000040


/*
** Shader record for iterated objects (lines/triangles).  This keeps
** track of all the various deltas needed to rasterize a triangle.
*/

/* NOTES:
 * -----
 * After expanding the shading equation using Taylor's series
 * /=======================================\
 * |            2     2                    |
 * | S(x,y) = ax  + by + cxy + dx + ey + f |
 * \=======================================/
 *
 * f = S (0, 0)          ,        e = S (0, 0 )
 *                                     y  
 *
 * d = S (0, 0)          ,        c = S  (0, 0)
 *      x                              xy
 *
 * b = 0.5 * S  (0 , 0)  ,        a = 0.5 * S  (0, 0)
 *            yy                             xx  
 *
 * Compute these in SetInitialPhongParameters
 */

/* NOTES on Forward differencing:
 * -----------------------------
 * 
 * Along the edge interpolation: delta_x = X (dxdy), delta_y = 1
 * -------------------------------------------------------------
 * Initial S: S (0, 0) = f (compute in SetInitialPhongParameters, for vert A)
 * (Sinit_edge)        
 *                2
 * Initial dS : aX + b + cX + dX + e (compute in FillSubTriangle)
 * (dS_edge)                   
 *                             2
 * Initial ddS (constant) : 2aX + 2cX + 2b (compute in FillSubTriangle)
 * (ddS_edge)
 *
 * Every iteration compute Sinit_span (in FillSubTriangle).
 *
 *
 *
 * Along the span interpolation: delta_x = 1, delta_y = 0
 * -------------------------------------------------------------
 * Initial S: sEdge (compute in FillSubTriangle)
 * (Sinit_span)
 *
 * Initial dS: a(2x+1) + cy + d (compute once in SpanProc)
 * (dS_span)
 *
 * Initial ddS (constant): 2a (compute in SetInitialPhongParameters)
 * (ddS_span)
 *
 * Every iteration compute Color (in SpanProc).
 *
 */ 

typedef struct __GLphongPerLightDataRec {

  /****** Diffuse Part *****/
    GLfloat Dcurr;    //current dot-product
    GLfloat Ddel;    
    GLfloat Ddel2;
                         
  /****** Specular Part *****/
    GLfloat Scurr;    //current dot-product
    GLfloat Sdel;    
    GLfloat Sdel2;

#ifdef __JUNKED_CODE                         
    /* Along the edge */
    GLfloat DdelEdgeLittle;
    GLfloat Ddel2EdgeLittle;
    GLfloat DdelEdgeBig;
    GLfloat Ddel2EdgeBig;

    /* Along the span */
    GLfloat DdelSpan;
    GLfloat DdelSpanEdgeBig, DdelSpanEdgeLittle;
    GLfloat Ddel2Span;

    /* Temporary storages during span-generation */
    GLfloat D_tmp;     
    GLfloat Ddel_tmp;     

    /* Polynomial coefficients */
    GLfloat D[6];

  /****** Specular Part *****/
    GLfloat S_curr;    //current dot-product
                         
    /* Along the edge */
    GLfloat SdelEdgeLittle;
    GLfloat Sdel2EdgeLittle;
    GLfloat SdelEdgeBig;
    GLfloat Sdel2EdgeBig;

    /* Along the span */
    GLfloat SdelSpan;
    GLfloat SdelSpanEdgeBig, SdelSpanEdgeLittle;
    GLfloat Sdel2Span;

    /* Temporary storages during span-generation */
    GLfloat S_tmp;     
    GLfloat Sdel_tmp;     

    /* Polynomial coefficients */
    GLfloat S[6];

  /****** Attenuation Part *****/
  /****** Spotlight Part *****/
#endif //__JUNKED_CODE
} __GLphongPerLightData;


typedef struct __GLphongShadeRec {

    GLuint flags;

    GLint numLights;
  
    /* Normals */
    __GLcoord dndx, dndy;
    __GLcoord nBig, nLittle;
    __GLcoord nCur, nTmp;
  
    /* Eye */
    __GLcoord dedx, dedy;
    __GLcoord eBig, eLittle;
    __GLcoord eCur, eTmp;
  
    /* Face: Whether to use the FRONT or the BACK material */
    GLint face;
  
    /* Store the invarient color */
    __GLcolor invColor;      

    /* Temporary storage during span-interpolation of color */
    __GLcolor tmpColor;      

#ifdef __JUNKED_CODE
    /* Tracks the current position wrt to the starting vertex */
    __GLcoord cur_pos;     
    __GLcoord tmp_pos;     
#endif //__JUNKED_CODE

    /* Per-light data array */
    __GLphongPerLightData perLight[8]; //update this to WGL_MAX_NUM_LIGHTS
} __GLphongShader;

  
extern void FASTCALL __glGenericPickPhongProcs(__GLcontext *gc);
extern void ComputePhongInvarientRGBColor (__GLcontext *gc);              
#ifdef GL_WIN_specular_fog
extern __GLfloat ComputeSpecValue (__GLcontext *gc, __GLvertex *vx);
#endif //GL_WIN_specular_fog


#endif //GL_WIN_phong_shading


#endif /* __glphong_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\listcomp.h ===
#ifndef __gl_g_lcomp_h
#define __gl_g_lcomp_h

/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define __GL_PAD(x) ((((x) + 3) >> 2) << 2)


struct __gllc_CallList_Rec {
	GLuint	list;
};

extern const GLubyte * FASTCALL __glle_CallList(__GLcontext *, const GLubyte *);

struct __gllc_CallLists_Rec {
	GLsizei	n;
	GLenum	type;
	/*	lists	*/
};

extern const GLubyte * FASTCALL __glle_CallLists(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glCallLists_size(GLsizei n, GLenum type);

struct __gllc_ListBase_Rec {
	GLuint	base;
};

extern const GLubyte * FASTCALL __glle_ListBase(__GLcontext *, const GLubyte *);

struct __gllc_Begin_Rec {
	GLenum	mode;
#ifdef NT
	GLuint	flags;
	GLint	nVertices;
	__GLcolor otherColor;
#endif
};

extern const GLubyte * FASTCALL __glle_Begin(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_Bitmap(__GLcontext *, const GLubyte *);

struct __gllc_Color3b_Rec {
	GLbyte	red;
	GLbyte	green;
	GLbyte	blue;
	GLubyte	pad1;
};


struct __gllc_Color3bv_Rec {
	GLbyte	v[3];
	GLubyte	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3bv(__GLcontext *, const GLubyte *);

struct __gllc_Color3d_Rec {
	GLdouble	red;
	GLdouble	green;
	GLdouble	blue;
};


struct __gllc_Color3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3dv(__GLcontext *, const GLubyte *);

struct __gllc_Color3f_Rec {
	GLfloat	red;
	GLfloat	green;
	GLfloat	blue;
};


struct __gllc_Color3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3fv(__GLcontext *, const GLubyte *);

struct __gllc_Color3i_Rec {
	GLint	red;
	GLint	green;
	GLint	blue;
};


struct __gllc_Color3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3iv(__GLcontext *, const GLubyte *);

struct __gllc_Color3s_Rec {
	GLshort	red;
	GLshort	green;
	GLshort	blue;
	GLushort	pad1;
};


struct __gllc_Color3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3sv(__GLcontext *, const GLubyte *);

struct __gllc_Color3ub_Rec {
	GLubyte	red;
	GLubyte	green;
	GLubyte	blue;
	GLubyte	pad1;
};


struct __gllc_Color3ubv_Rec {
	GLubyte	v[3];
	GLubyte	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3ubv(__GLcontext *, const GLubyte *);

struct __gllc_Color3ui_Rec {
	GLuint	red;
	GLuint	green;
	GLuint	blue;
};


struct __gllc_Color3uiv_Rec {
	GLuint	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3uiv(__GLcontext *, const GLubyte *);

struct __gllc_Color3us_Rec {
	GLushort	red;
	GLushort	green;
	GLushort	blue;
	GLushort	pad1;
};


struct __gllc_Color3usv_Rec {
	GLushort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3usv(__GLcontext *, const GLubyte *);

struct __gllc_Color4b_Rec {
	GLbyte	red;
	GLbyte	green;
	GLbyte	blue;
	GLbyte	alpha;
};


struct __gllc_Color4bv_Rec {
	GLbyte	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4bv(__GLcontext *, const GLubyte *);

struct __gllc_Color4d_Rec {
	GLdouble	red;
	GLdouble	green;
	GLdouble	blue;
	GLdouble	alpha;
};


struct __gllc_Color4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4dv(__GLcontext *, const GLubyte *);

struct __gllc_Color4f_Rec {
	GLfloat	red;
	GLfloat	green;
	GLfloat	blue;
	GLfloat	alpha;
};


struct __gllc_Color4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4fv(__GLcontext *, const GLubyte *);

struct __gllc_Color4i_Rec {
	GLint	red;
	GLint	green;
	GLint	blue;
	GLint	alpha;
};


struct __gllc_Color4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4iv(__GLcontext *, const GLubyte *);

struct __gllc_Color4s_Rec {
	GLshort	red;
	GLshort	green;
	GLshort	blue;
	GLshort	alpha;
};


struct __gllc_Color4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4sv(__GLcontext *, const GLubyte *);

struct __gllc_Color4ub_Rec {
	GLubyte	red;
	GLubyte	green;
	GLubyte	blue;
	GLubyte	alpha;
};


struct __gllc_Color4ubv_Rec {
	GLubyte	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4ubv(__GLcontext *, const GLubyte *);

struct __gllc_Color4ui_Rec {
	GLuint	red;
	GLuint	green;
	GLuint	blue;
	GLuint	alpha;
};


struct __gllc_Color4uiv_Rec {
	GLuint	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4uiv(__GLcontext *, const GLubyte *);

struct __gllc_Color4us_Rec {
	GLushort	red;
	GLushort	green;
	GLushort	blue;
	GLushort	alpha;
};


struct __gllc_Color4usv_Rec {
	GLushort	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4usv(__GLcontext *, const GLubyte *);

struct __gllc_EdgeFlag_Rec {
	GLboolean	flag;
	GLubyte	pad1;
	GLubyte	pad2;
	GLubyte	pad3;
};


struct __gllc_EdgeFlagv_Rec {
	GLboolean	flag[1];
	GLubyte	pad1;
	GLubyte	pad2;
	GLubyte	pad3;
};

extern const GLubyte * FASTCALL __glle_EdgeFlag(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_End(__GLcontext *, const GLubyte *);

struct __gllc_Indexd_Rec {
	GLdouble	c;
};


struct __gllc_Indexdv_Rec {
	GLdouble	c[1];
};

extern const GLubyte * FASTCALL __glle_Indexdv(__GLcontext *, const GLubyte *);

struct __gllc_Indexf_Rec {
	GLfloat	c;
};


struct __gllc_Indexfv_Rec {
	GLfloat	c[1];
};

extern const GLubyte * FASTCALL __glle_Indexf(__GLcontext *, const GLubyte *);

struct __gllc_Indexi_Rec {
	GLint	c;
};


struct __gllc_Indexiv_Rec {
	GLint	c[1];
};

extern const GLubyte * FASTCALL __glle_Indexiv(__GLcontext *, const GLubyte *);

struct __gllc_Indexs_Rec {
	GLshort	c;
	GLushort	pad1;
};


struct __gllc_Indexsv_Rec {
	GLshort	c[1];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Indexsv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3b_Rec {
	GLbyte	nx;
	GLbyte	ny;
	GLbyte	nz;
	GLubyte	pad1;
};


struct __gllc_Normal3bv_Rec {
	GLbyte	v[3];
	GLubyte	pad1;
};

extern const GLubyte * FASTCALL __glle_Normal3bv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3d_Rec {
	GLdouble	nx;
	GLdouble	ny;
	GLdouble	nz;
};


struct __gllc_Normal3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_Normal3dv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3f_Rec {
	GLfloat	nx;
	GLfloat	ny;
	GLfloat	nz;
};


struct __gllc_Normal3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_Normal3fv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3i_Rec {
	GLint	nx;
	GLint	ny;
	GLint	nz;
};


struct __gllc_Normal3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_Normal3iv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3s_Rec {
	GLshort	nx;
	GLshort	ny;
	GLshort	nz;
	GLushort	pad1;
};


struct __gllc_Normal3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Normal3sv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2d_Rec {
	GLdouble	x;
	GLdouble	y;
};


struct __gllc_RasterPos2dv_Rec {
	GLdouble	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2dv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2f_Rec {
	GLfloat	x;
	GLfloat	y;
};


struct __gllc_RasterPos2fv_Rec {
	GLfloat	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2f(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2i_Rec {
	GLint	x;
	GLint	y;
};


struct __gllc_RasterPos2iv_Rec {
	GLint	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2iv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2s_Rec {
	GLshort	x;
	GLshort	y;
};


struct __gllc_RasterPos2sv_Rec {
	GLshort	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2sv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};


struct __gllc_RasterPos3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_RasterPos3dv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};


struct __gllc_RasterPos3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_RasterPos3fv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
};


struct __gllc_RasterPos3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_RasterPos3iv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLushort	pad1;
};


struct __gllc_RasterPos3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_RasterPos3sv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
	GLdouble	w;
};


struct __gllc_RasterPos4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4dv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
	GLfloat	w;
};


struct __gllc_RasterPos4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4fv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
	GLint	w;
};


struct __gllc_RasterPos4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4iv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLshort	w;
};


struct __gllc_RasterPos4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4sv(__GLcontext *, const GLubyte *);

struct __gllc_Rectd_Rec {
	GLdouble	x1;
	GLdouble	y1;
	GLdouble	x2;
	GLdouble	y2;
};


struct __gllc_Rectdv_Rec {
	GLdouble	v1[2];
	GLdouble	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectdv(__GLcontext *, const GLubyte *);

struct __gllc_Rectf_Rec {
	GLfloat	x1;
	GLfloat	y1;
	GLfloat	x2;
	GLfloat	y2;
};


struct __gllc_Rectfv_Rec {
	GLfloat	v1[2];
	GLfloat	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectf(__GLcontext *, const GLubyte *);

struct __gllc_Recti_Rec {
	GLint	x1;
	GLint	y1;
	GLint	x2;
	GLint	y2;
};


struct __gllc_Rectiv_Rec {
	GLint	v1[2];
	GLint	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectiv(__GLcontext *, const GLubyte *);

struct __gllc_Rects_Rec {
	GLshort	x1;
	GLshort	y1;
	GLshort	x2;
	GLshort	y2;
};


struct __gllc_Rectsv_Rec {
	GLshort	v1[2];
	GLshort	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectsv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1d_Rec {
	GLdouble	s;
};


struct __gllc_TexCoord1dv_Rec {
	GLdouble	v[1];
};

extern const GLubyte * FASTCALL __glle_TexCoord1dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1f_Rec {
	GLfloat	s;
};


struct __gllc_TexCoord1fv_Rec {
	GLfloat	v[1];
};

extern const GLubyte * FASTCALL __glle_TexCoord1f(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1i_Rec {
	GLint	s;
};


struct __gllc_TexCoord1iv_Rec {
	GLint	v[1];
};

extern const GLubyte * FASTCALL __glle_TexCoord1iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1s_Rec {
	GLshort	s;
	GLushort	pad1;
};


struct __gllc_TexCoord1sv_Rec {
	GLshort	v[1];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_TexCoord1sv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2d_Rec {
	GLdouble	s;
	GLdouble	t;
};


struct __gllc_TexCoord2dv_Rec {
	GLdouble	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2f_Rec {
	GLfloat	s;
	GLfloat	t;
};


struct __gllc_TexCoord2fv_Rec {
	GLfloat	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2f(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2i_Rec {
	GLint	s;
	GLint	t;
};


struct __gllc_TexCoord2iv_Rec {
	GLint	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2s_Rec {
	GLshort	s;
	GLshort	t;
};


struct __gllc_TexCoord2sv_Rec {
	GLshort	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2sv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3d_Rec {
	GLdouble	s;
	GLdouble	t;
	GLdouble	r;
};


struct __gllc_TexCoord3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_TexCoord3dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3f_Rec {
	GLfloat	s;
	GLfloat	t;
	GLfloat	r;
};


struct __gllc_TexCoord3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_TexCoord3fv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3i_Rec {
	GLint	s;
	GLint	t;
	GLint	r;
};


struct __gllc_TexCoord3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_TexCoord3iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3s_Rec {
	GLshort	s;
	GLshort	t;
	GLshort	r;
	GLushort	pad1;
};


struct __gllc_TexCoord3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_TexCoord3sv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4d_Rec {
	GLdouble	s;
	GLdouble	t;
	GLdouble	r;
	GLdouble	q;
};


struct __gllc_TexCoord4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4f_Rec {
	GLfloat	s;
	GLfloat	t;
	GLfloat	r;
	GLfloat	q;
};


struct __gllc_TexCoord4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4fv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4i_Rec {
	GLint	s;
	GLint	t;
	GLint	r;
	GLint	q;
};


struct __gllc_TexCoord4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4s_Rec {
	GLshort	s;
	GLshort	t;
	GLshort	r;
	GLshort	q;
};


struct __gllc_TexCoord4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4sv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2d_Rec {
	GLdouble	x;
	GLdouble	y;
};


struct __gllc_Vertex2dv_Rec {
	GLdouble	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2dv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2f_Rec {
	GLfloat	x;
	GLfloat	y;
};


struct __gllc_Vertex2fv_Rec {
	GLfloat	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2f(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2i_Rec {
	GLint	x;
	GLint	y;
};


struct __gllc_Vertex2iv_Rec {
	GLint	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2iv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2s_Rec {
	GLshort	x;
	GLshort	y;
};


struct __gllc_Vertex2sv_Rec {
	GLshort	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2sv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};


struct __gllc_Vertex3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_Vertex3dv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};


struct __gllc_Vertex3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_Vertex3fv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
};


struct __gllc_Vertex3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_Vertex3iv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLushort	pad1;
};


struct __gllc_Vertex3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Vertex3sv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
	GLdouble	w;
};


struct __gllc_Vertex4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4dv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
	GLfloat	w;
};


struct __gllc_Vertex4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4fv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
	GLint	w;
};


struct __gllc_Vertex4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4iv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLshort	w;
};


struct __gllc_Vertex4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4sv(__GLcontext *, const GLubyte *);

struct __gllc_ClipPlane_Rec {
	GLdouble	equation[4];
	GLenum	plane;
};

extern const GLubyte * FASTCALL __glle_ClipPlane(__GLcontext *, const GLubyte *);

struct __gllc_ColorMaterial_Rec {
	GLenum	face;
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_ColorMaterial(__GLcontext *, const GLubyte *);

struct __gllc_CullFace_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_CullFace(__GLcontext *, const GLubyte *);

struct __gllc_Fogf_Rec {
	GLenum	pname;
	GLfloat	param;
};

extern const GLubyte * FASTCALL __glle_Fogf(__GLcontext *, const GLubyte *);

struct __gllc_Fogfv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Fogfv(__GLcontext *, const GLubyte *);
#ifdef NT
// FOG_ASSERT
#define __glFogfv_size(pname)					\
    ((pname) == GL_FOG_COLOR					\
	? 4							\
	: (RANGE((pname),GL_FOG_INDEX,GL_FOG_MODE)		\
	    ? 1							\
	    : -1))
#else
extern GLint FASTCALL __glFogfv_size(GLenum pname);
#endif

struct __gllc_Fogi_Rec {
	GLenum	pname;
	GLint	param;
};

extern const GLubyte * FASTCALL __glle_Fogi(__GLcontext *, const GLubyte *);

struct __gllc_Fogiv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Fogiv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glFogiv_size(GLenum pname);

struct __gllc_FrontFace_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_FrontFace(__GLcontext *, const GLubyte *);

struct __gllc_Hint_Rec {
	GLenum	target;
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_Hint(__GLcontext *, const GLubyte *);

struct __gllc_Lightfv_Rec {
	GLenum	light;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Lightfv(__GLcontext *, const GLubyte *);
#ifdef NT
// LIGHT_SOURCE_ASSERT
#define __glLightfv_size(pname)						\
    ((pname) == GL_SPOT_DIRECTION					\
	? 3								\
	: (RANGE((pname),GL_AMBIENT,GL_POSITION)			\
	    ? 4								\
	    : (RANGE((pname),GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION)	\
		? 1							\
		: -1)))
#else
extern GLint FASTCALL __glLightfv_size(GLenum pname);
#endif

struct __gllc_Lightiv_Rec {
	GLenum	light;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Lightiv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glLightiv_size(GLenum pname);

struct __gllc_LightModelfv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_LightModelfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glLightModelfv_size(pname)					\
    (((pname) == GL_LIGHT_MODEL_LOCAL_VIEWER ||				\
      (pname) == GL_LIGHT_MODEL_TWO_SIDE)				\
	? 1								\
	: ((pname) == GL_LIGHT_MODEL_AMBIENT				\
	    ? 4								\
	    : -1))
#else
extern GLint FASTCALL __glLightModelfv_size(GLenum pname);
#endif

struct __gllc_LightModeliv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_LightModeliv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glLightModeliv_size(GLenum pname);

struct __gllc_LineStipple_Rec {
	GLint	factor;
	GLushort	pattern;
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_LineStipple(__GLcontext *, const GLubyte *);

struct __gllc_LineWidth_Rec {
	GLfloat	width;
};

extern const GLubyte * FASTCALL __glle_LineWidth(__GLcontext *, const GLubyte *);

struct __gllc_Materialfv_Rec {
	GLenum	face;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Materialfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glMaterialfv_size(pname)					\
    ((pname) == GL_SHININESS						\
	? 1								\
	: ((pname) == GL_COLOR_INDEXES					\
	    ? 3								\
	    : (((pname) == GL_AMBIENT ||				\
	        (pname) == GL_DIFFUSE ||				\
	        (pname) == GL_SPECULAR ||				\
	        (pname) == GL_EMISSION ||				\
	        (pname) == GL_AMBIENT_AND_DIFFUSE) 			\
		? 4							\
		: -1)))
#else
extern GLint FASTCALL __glMaterialfv_size(GLenum pname);
#endif

struct __gllc_Materialiv_Rec {
	GLenum	face;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Materialiv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glMaterialiv_size(GLenum pname);

struct __gllc_PointSize_Rec {
	GLfloat	size;
};

extern const GLubyte * FASTCALL __glle_PointSize(__GLcontext *, const GLubyte *);

struct __gllc_PolygonMode_Rec {
	GLenum	face;
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_PolygonMode(__GLcontext *, const GLubyte *);

struct __gllc_PolygonStipple_Rec {
	GLubyte	mask[128];
};

extern const GLubyte * FASTCALL __glle_PolygonStipple(__GLcontext *, const GLubyte *);

struct __gllc_Scissor_Rec {
	GLint	x;
	GLint	y;
	GLsizei	width;
	GLsizei	height;
};

extern const GLubyte * FASTCALL __glle_Scissor(__GLcontext *, const GLubyte *);

struct __gllc_ShadeModel_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_ShadeModel(__GLcontext *, const GLubyte *);

struct __gllc_TexParameterfv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexParameterfv(__GLcontext *, const GLubyte *);
#ifdef NT
// TEX_PARAMETER_ASSERT
#define __glTexParameterfv_size(pname)					\
    ((RANGE((pname),GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) ||		\
      (pname) == GL_TEXTURE_PRIORITY)				        \
	? 1								\
	: ((pname) == GL_TEXTURE_BORDER_COLOR				\
	    ? 4								\
	    : -1))
#else
extern GLint FASTCALL __glTexParameterfv_size(GLenum pname);
#endif

struct __gllc_TexParameteriv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexParameteriv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexParameteriv_size(pname)	__glTexParameterfv_size(pname)
#else
extern GLint FASTCALL __glTexParameteriv_size(GLenum pname);
#endif

typedef struct __GLtexImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage1D;

extern const GLubyte * FASTCALL __glle_TexImage1D(__GLcontext *, const GLubyte *);

typedef struct __GLtexImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLsizei height;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage2D;

extern const GLubyte * FASTCALL __glle_TexImage2D(__GLcontext *, const GLubyte *);

struct __gllc_TexEnvfv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexEnvfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexEnvfv_size(pname)					\
    ((pname) == GL_TEXTURE_ENV_MODE					\
	? 1								\
	: ((pname) == GL_TEXTURE_ENV_COLOR				\
	    ? 4								\
	    : -1))
#else
extern GLint FASTCALL __glTexEnvfv_size(GLenum pname);
#endif

struct __gllc_TexEnviv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexEnviv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexEnviv_size(pname)	__glTexEnvfv_size(pname)
#else
extern GLint FASTCALL __glTexEnviv_size(GLenum pname);
#endif

struct __gllc_TexGendv_Rec {
	GLenum	coord;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexGendv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexGendv_size(pname)					\
    (((pname) == GL_OBJECT_PLANE || (pname) == GL_EYE_PLANE)		\
	? 4								\
	: ((pname) == GL_TEXTURE_GEN_MODE				\
	    ? 1								\
	    : -1))
#else
extern GLint FASTCALL __glTexGendv_size(GLenum pname);
#endif

struct __gllc_TexGenfv_Rec {
	GLenum	coord;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexGenfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexGenfv_size(pname)	__glTexGendv_size(pname)
#else
extern GLint FASTCALL __glTexGenfv_size(GLenum pname);
#endif

struct __gllc_TexGeniv_Rec {
	GLenum	coord;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexGeniv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexGeniv_size(pname)	__glTexGendv_size(pname)
#else
extern GLint FASTCALL __glTexGeniv_size(GLenum pname);
#endif


extern const GLubyte * FASTCALL __glle_InitNames(__GLcontext *, const GLubyte *);

struct __gllc_LoadName_Rec {
	GLuint	name;
};

extern const GLubyte * FASTCALL __glle_LoadName(__GLcontext *, const GLubyte *);

struct __gllc_PassThrough_Rec {
	GLfloat	token;
};

extern const GLubyte * FASTCALL __glle_PassThrough(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PopName(__GLcontext *, const GLubyte *);

struct __gllc_PushName_Rec {
	GLuint	name;
};

extern const GLubyte * FASTCALL __glle_PushName(__GLcontext *, const GLubyte *);

struct __gllc_DrawBuffer_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_DrawBuffer(__GLcontext *, const GLubyte *);

struct __gllc_Clear_Rec {
	GLbitfield	mask;
};

extern const GLubyte * FASTCALL __glle_Clear(__GLcontext *, const GLubyte *);

struct __gllc_ClearAccum_Rec {
	GLfloat	red;
	GLfloat	green;
	GLfloat	blue;
	GLfloat	alpha;
};

extern const GLubyte * FASTCALL __glle_ClearAccum(__GLcontext *, const GLubyte *);

struct __gllc_ClearIndex_Rec {
	GLfloat	c;
};

extern const GLubyte * FASTCALL __glle_ClearIndex(__GLcontext *, const GLubyte *);

struct __gllc_ClearColor_Rec {
	GLclampf	red;
	GLclampf	green;
	GLclampf	blue;
	GLclampf	alpha;
};

extern const GLubyte * FASTCALL __glle_ClearColor(__GLcontext *, const GLubyte *);

struct __gllc_ClearStencil_Rec {
	GLint	s;
};

extern const GLubyte * FASTCALL __glle_ClearStencil(__GLcontext *, const GLubyte *);

struct __gllc_ClearDepth_Rec {
	GLclampd	depth;
};

extern const GLubyte * FASTCALL __glle_ClearDepth(__GLcontext *, const GLubyte *);

struct __gllc_StencilMask_Rec {
	GLuint	mask;
};

extern const GLubyte * FASTCALL __glle_StencilMask(__GLcontext *, const GLubyte *);

struct __gllc_ColorMask_Rec {
	GLboolean	red;
	GLboolean	green;
	GLboolean	blue;
	GLboolean	alpha;
};

extern const GLubyte * FASTCALL __glle_ColorMask(__GLcontext *, const GLubyte *);

struct __gllc_DepthMask_Rec {
	GLboolean	flag;
	GLubyte	pad1;
	GLubyte	pad2;
	GLubyte	pad3;
};

extern const GLubyte * FASTCALL __glle_DepthMask(__GLcontext *, const GLubyte *);

struct __gllc_IndexMask_Rec {
	GLuint	mask;
};

extern const GLubyte * FASTCALL __glle_IndexMask(__GLcontext *, const GLubyte *);

struct __gllc_Accum_Rec {
	GLenum	op;
	GLfloat	value;
};

extern const GLubyte * FASTCALL __glle_Accum(__GLcontext *, const GLubyte *);

struct __gllc_Disable_Rec {
	GLenum	cap;
};

extern const GLubyte * FASTCALL __glle_Disable(__GLcontext *, const GLubyte *);

struct __gllc_Enable_Rec {
	GLenum	cap;
};

extern const GLubyte * FASTCALL __glle_Enable(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PopAttrib(__GLcontext *, const GLubyte *);

struct __gllc_PushAttrib_Rec {
	GLbitfield	mask;
};

extern const GLubyte * FASTCALL __glle_PushAttrib(__GLcontext *, const GLubyte *);

typedef struct __GLmap1_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     order;
        /*        points  */
} __GLmap1;



extern const GLubyte * FASTCALL __glle_Map1(__GLcontext *, const GLubyte *);

typedef struct __GLmap2_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     uorder;
        __GLfloat v1;
        __GLfloat v2;
        GLint     vorder;
        /*        points  */
} __GLmap2;



extern const GLubyte * FASTCALL __glle_Map2(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid1d_Rec {
	GLdouble	u1;
	GLdouble	u2;
	GLint	un;
};

extern const GLubyte * FASTCALL __glle_MapGrid1d(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid1f_Rec {
	GLint	un;
	GLfloat	u1;
	GLfloat	u2;
};

extern const GLubyte * FASTCALL __glle_MapGrid1f(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid2d_Rec {
	GLdouble	u1;
	GLdouble	u2;
	GLdouble	v1;
	GLdouble	v2;
	GLint	un;
	GLint	vn;
};

extern const GLubyte * FASTCALL __glle_MapGrid2d(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid2f_Rec {
	GLint	un;
	GLfloat	u1;
	GLfloat	u2;
	GLint	vn;
	GLfloat	v1;
	GLfloat	v2;
};

extern const GLubyte * FASTCALL __glle_MapGrid2f(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord1d_Rec {
	GLdouble	u;
};


struct __gllc_EvalCoord1dv_Rec {
	GLdouble	u[1];
};

extern const GLubyte * FASTCALL __glle_EvalCoord1dv(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord1f_Rec {
	GLfloat	u;
};


struct __gllc_EvalCoord1fv_Rec {
	GLfloat	u[1];
};

extern const GLubyte * FASTCALL __glle_EvalCoord1f(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord2d_Rec {
	GLdouble	u;
	GLdouble	v;
};


struct __gllc_EvalCoord2dv_Rec {
	GLdouble	u[2];
};

extern const GLubyte * FASTCALL __glle_EvalCoord2dv(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord2f_Rec {
	GLfloat	u;
	GLfloat	v;
};


struct __gllc_EvalCoord2fv_Rec {
	GLfloat	u[2];
};

extern const GLubyte * FASTCALL __glle_EvalCoord2f(__GLcontext *, const GLubyte *);

struct __gllc_EvalMesh1_Rec {
	GLenum	mode;
	GLint	i1;
	GLint	i2;
};

extern const GLubyte * FASTCALL __glle_EvalMesh1(__GLcontext *, const GLubyte *);

struct __gllc_EvalPoint1_Rec {
	GLint	i;
};

extern const GLubyte * FASTCALL __glle_EvalPoint1(__GLcontext *, const GLubyte *);

struct __gllc_EvalMesh2_Rec {
	GLenum	mode;
	GLint	i1;
	GLint	i2;
	GLint	j1;
	GLint	j2;
};

extern const GLubyte * FASTCALL __glle_EvalMesh2(__GLcontext *, const GLubyte *);

struct __gllc_EvalPoint2_Rec {
	GLint	i;
	GLint	j;
};

extern const GLubyte * FASTCALL __glle_EvalPoint2(__GLcontext *, const GLubyte *);

struct __gllc_AlphaFunc_Rec {
	GLenum	func;
	GLclampf	ref;
};

extern const GLubyte * FASTCALL __glle_AlphaFunc(__GLcontext *, const GLubyte *);

struct __gllc_BlendFunc_Rec {
	GLenum	sfactor;
	GLenum	dfactor;
};

extern const GLubyte * FASTCALL __glle_BlendFunc(__GLcontext *, const GLubyte *);

struct __gllc_LogicOp_Rec {
	GLenum	opcode;
};

extern const GLubyte * FASTCALL __glle_LogicOp(__GLcontext *, const GLubyte *);

struct __gllc_StencilFunc_Rec {
	GLenum	func;
	GLint	ref;
	GLuint	mask;
};

extern const GLubyte * FASTCALL __glle_StencilFunc(__GLcontext *, const GLubyte *);

struct __gllc_StencilOp_Rec {
	GLenum	fail;
	GLenum	zfail;
	GLenum	zpass;
};

extern const GLubyte * FASTCALL __glle_StencilOp(__GLcontext *, const GLubyte *);

struct __gllc_DepthFunc_Rec {
	GLenum	func;
};

extern const GLubyte * FASTCALL __glle_DepthFunc(__GLcontext *, const GLubyte *);

struct __gllc_PixelZoom_Rec {
	GLfloat	xfactor;
	GLfloat	yfactor;
};

extern const GLubyte * FASTCALL __glle_PixelZoom(__GLcontext *, const GLubyte *);

struct __gllc_PixelTransferf_Rec {
	GLenum	pname;
	GLfloat	param;
};

extern const GLubyte * FASTCALL __glle_PixelTransferf(__GLcontext *, const GLubyte *);

struct __gllc_PixelTransferi_Rec {
	GLenum	pname;
	GLint	param;
};

extern const GLubyte * FASTCALL __glle_PixelTransferi(__GLcontext *, const GLubyte *);

struct __gllc_PixelMapfv_Rec {
	GLenum	map;
	GLint	mapsize;
	/*	values	*/
};

extern const GLubyte * FASTCALL __glle_PixelMapfv(__GLcontext *, const GLubyte *);

struct __gllc_PixelMapuiv_Rec {
	GLenum	map;
	GLint	mapsize;
	/*	values	*/
};

extern const GLubyte * FASTCALL __glle_PixelMapuiv(__GLcontext *, const GLubyte *);

struct __gllc_PixelMapusv_Rec {
	GLenum	map;
	GLint	mapsize;
	/*	values	*/
};

extern const GLubyte * FASTCALL __glle_PixelMapusv(__GLcontext *, const GLubyte *);

struct __gllc_ReadBuffer_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_ReadBuffer(__GLcontext *, const GLubyte *);

struct __gllc_CopyPixels_Rec {
	GLint	x;
	GLint	y;
	GLsizei	width;
	GLsizei	height;
	GLenum	type;
};

extern const GLubyte * FASTCALL __glle_CopyPixels(__GLcontext *, const GLubyte *);

typedef struct __GLdrawPixels_Rec {
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        /*      pixels  */
} __GLdrawPixels;

extern const GLubyte * FASTCALL __glle_DrawPixels(__GLcontext *, const GLubyte *);

struct __gllc_DepthRange_Rec {
	GLclampd	zNear;
	GLclampd	zFar;
};

extern const GLubyte * FASTCALL __glle_DepthRange(__GLcontext *, const GLubyte *);

struct __gllc_Frustum_Rec {
	GLdouble	left;
	GLdouble	right;
	GLdouble	bottom;
	GLdouble	top;
	GLdouble	zNear;
	GLdouble	zFar;
};

extern const GLubyte * FASTCALL __glle_Frustum(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_LoadIdentity(__GLcontext *, const GLubyte *);

struct __gllc_LoadMatrixf_Rec {
	GLfloat	m[16];
};

extern const GLubyte * FASTCALL __glle_LoadMatrixf(__GLcontext *, const GLubyte *);

struct __gllc_LoadMatrixd_Rec {
	GLdouble	m[16];
};

extern const GLubyte * FASTCALL __glle_LoadMatrixd(__GLcontext *, const GLubyte *);

struct __gllc_MatrixMode_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_MatrixMode(__GLcontext *, const GLubyte *);

struct __gllc_MultMatrixf_Rec {
	GLfloat	m[16];
};

extern const GLubyte * FASTCALL __glle_MultMatrixf(__GLcontext *, const GLubyte *);

struct __gllc_MultMatrixd_Rec {
	GLdouble	m[16];
};

extern const GLubyte * FASTCALL __glle_MultMatrixd(__GLcontext *, const GLubyte *);

struct __gllc_Ortho_Rec {
	GLdouble	left;
	GLdouble	right;
	GLdouble	bottom;
	GLdouble	top;
	GLdouble	zNear;
	GLdouble	zFar;
};

extern const GLubyte * FASTCALL __glle_Ortho(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PopMatrix(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PushMatrix(__GLcontext *, const GLubyte *);

struct __gllc_Rotated_Rec {
	GLdouble	angle;
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};

extern const GLubyte * FASTCALL __glle_Rotated(__GLcontext *, const GLubyte *);

struct __gllc_Rotatef_Rec {
	GLfloat	angle;
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};

extern const GLubyte * FASTCALL __glle_Rotatef(__GLcontext *, const GLubyte *);

struct __gllc_Scaled_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};

extern const GLubyte * FASTCALL __glle_Scaled(__GLcontext *, const GLubyte *);

struct __gllc_Scalef_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};

extern const GLubyte * FASTCALL __glle_Scalef(__GLcontext *, const GLubyte *);

struct __gllc_Translated_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};

extern const GLubyte * FASTCALL __glle_Translated(__GLcontext *, const GLubyte *);

struct __gllc_Translatef_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};

extern const GLubyte * FASTCALL __glle_Translatef(__GLcontext *, const GLubyte *);

struct __gllc_Viewport_Rec {
	GLint	x;
	GLint	y;
	GLsizei	width;
	GLsizei	height;
};

extern const GLubyte * FASTCALL __glle_Viewport(__GLcontext *, const GLubyte *);


typedef struct __GLtexSubImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLsizei width;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage1D;

extern const GLubyte * FASTCALL __glle_TexSubImage1D(__GLcontext *, const GLubyte *);

typedef struct __GLtexSubImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLint   yoffset;
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage2D;

extern const GLubyte * FASTCALL __glle_TexSubImage2D(__GLcontext *, const GLubyte *);

struct __gllc_BindTexture_Rec {
      GLenum target;
      GLuint texture;
};

extern const GLubyte * FASTCALL __glle_BindTexture(__GLcontext *, const GLubyte *);

struct __gllc_PrioritizeTextures_Rec {
      GLsizei n;
      /*    textures    */
      /*    priorities    */
};

extern const GLubyte * FASTCALL __glle_PrioritizeTextures(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexImage1D_Rec {
      GLenum target;
      GLint level;
      GLenum internalformat;
      GLint x;
      GLint y;
      GLsizei width;
      GLint border;
};

extern const GLubyte * FASTCALL __glle_CopyTexImage1D(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexImage2D_Rec {
      GLenum target;
      GLint level;
      GLenum internalformat;
      GLint x;
      GLint y;
      GLsizei width;
      GLsizei height;
      GLint border;
};

extern const GLubyte * FASTCALL __glle_CopyTexImage2D(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexSubImage1D_Rec {
      GLenum target;
      GLint level;
      GLint xoffset;
      GLint x;
      GLint y;
      GLsizei width;
};

extern const GLubyte * FASTCALL __glle_CopyTexSubImage1D(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexSubImage2D_Rec {
      GLenum target;
      GLint level;
      GLint xoffset;
      GLint yoffset;
      GLint x;
      GLint y;
      GLsizei width;
      GLsizei height;
};

extern const GLubyte * FASTCALL __glle_CopyTexSubImage2D(__GLcontext *, const GLubyte *);

typedef struct __gllc_ColorTableEXT_Rec
{
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint imageSize;
    /* Data */
} __GLcolorTableEXT;

extern const GLubyte * FASTCALL __glle_ColorTableEXT(__GLcontext *, const GLubyte *);

typedef struct __gllc_ColorSubTableEXT_Rec
{
    GLenum target;
    GLuint start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLint imageSize;
    /* Data */
} __GLcolorSubTableEXT;

extern const GLubyte * FASTCALL __glle_ColorSubTableEXT(__GLcontext *, const GLubyte *);

struct __gllc_PolygonOffset_Rec
{
    GLfloat factor;
    GLfloat units;
};

extern const GLubyte * FASTCALL __glle_PolygonOffset(__GLcontext *, const GLubyte *);

struct __gllc_DrawElementsBegin_Rec
{
    GLenum  mode;
    GLsizei count;
    GLuint  vaMask;
};

extern const GLubyte * FASTCALL __glle_DrawElementsBegin(__GLcontext *, const GLubyte *);

struct __gllc_DrawElements_Rec
{
    GLenum  mode;
    GLsizei iElementCount;
    GLsizei iVertexCount;
    GLuint  vaMask;
    GLboolean partial;
    GLuint  recSize;
    GLuint  edgeFlagOff;
    GLuint  texCoordOff;
    GLint   texCoordSize;
    GLenum  texCoordType;
    GLuint  indexOff;
    GLenum  indexType;
    GLuint  colorOff;
    GLint   colorSize;
    GLenum  colorType;
    GLuint  normalOff;
    GLenum  normalType;
    GLuint  vertexOff;
    GLint   vertexSize;
    GLenum  vertexType;
    GLuint  mapOff;
};

extern const GLubyte * FASTCALL __glle_DrawElements(__GLcontext *, const GLubyte *);

#ifdef GL_WIN_multiple_textures
struct __gllc_CurrentTextureIndexWIN_Rec
{
    GLuint index;
};

extern const GLubyte * FASTCALL __glle_CurrentTextureIndexWIN(__GLcontext *, const GLubyte *);

struct __gllc_BindNthTextureWIN_Rec
{
    GLuint index;
    GLenum target;
    GLuint texture;
};

extern const GLubyte * FASTCALL __glle_BindNthTextureWIN(__GLcontext *, const GLubyte *);

struct __gllc_NthTexCombineFuncWIN_Rec
{
    GLuint index;
    GLenum leftColorFactor;
    GLenum colorOp;
    GLenum rightColorFactor;
    GLenum leftAlphaFactor;
    GLenum alphaOp;
    GLenum rightAlphaFactor;
};

extern const GLubyte * FASTCALL __glle_NthTexCombineFuncWIN(__GLcontext *, const GLubyte *);
#endif // GL_WIN_multiple_textures

#endif /* __gl_g_lcomp_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\procs.h ===
#ifndef __glprocs_h_
#define __glprocs_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"

/*
** These typedefs are used to normalize the calling conventions
** for the span procs.  Some of the arguments are not used by
** many of the span procs, but the arguments are present so that
** the function pointers in the spanProcsRec can be interchanged.
** The idea is to move up in the calling sequence as high as possible
** the final "store" span proc.
**
** The type __GLspanFunc returns GL_TRUE if it stippled the span while
** processing it.  If it also stippled the span all black, it sets
** gc->polygon.shader.done to GL_TRUE.
**
** The type __GLstippledSpanFunc return GL_TRUE if it stippled the span
** to all black, and GL_FALSE otherwise.
*/
typedef GLboolean (FASTCALL *__GLspanFunc)(__GLcontext *gc);
typedef GLboolean (FASTCALL *__GLstippledSpanFunc)(__GLcontext *gc);

#define __GL_MAX_SPAN_FUNCS	15
#define __GL_MAX_LINE_FUNCS	16

typedef struct __GLspanProcsRec {
    /*
    ** First phase of span processing.  Clip the span so that it won't
    ** render outside of the intersection of the window box and the
    ** scissor box.  Then call the stipple proc to replicate the stipple
    ** (and rotate it) sufficient for rendering w pixels.  If there is no
    ** active polygon stipple then the stipple proc is skipped, and the
    ** unstippled form of the next phase of procs is used until stippling
    ** becomes necessary.
    **
    ** Second phase of span processing.  Apply the various test functions 
    ** producing at the end a final stipple for the span.  
    ** Each test procedure outputs a new stipple as
    ** needed, calling the stippled form of the next proc only if the
    ** test failed somewhere in the span.
    **
    ** Next phase of span processing.  This phase is responsible for
    ** generating the final colors to be stored.  The operations are
    ** applied in order as shown below, producing at the end the final
    ** color values.  draw is used to replicate the span so that it
    ** properly renders to the correct number of destination buffers
    ** (e.g., when drawBuffer is FRONT_AND_BACK).
    **
    ** Final phase of span rendering.  Apply blend function, dither
    ** operation, logic-op and writemask before calling the store
    ** proc.  When blending, logic-oping, or writemasking is being done,
    ** the fetch proc will be used to read in the span (from the draw
    ** buffer) before proceeding furthur.
    */

    /*
    ** The 15 layers of the span procs are:
    **
    ** scissor, poly stipple, alpha test, stencil test, depth test, shading,
    ** texturing, fogging, FRONT_AND_BACK drawing, fetching, blending, 
    ** dithering, logic op, masking, storing.
    */
    __GLspanFunc spanFuncs[__GL_MAX_SPAN_FUNCS];
    __GLstippledSpanFunc stippledSpanFuncs[__GL_MAX_SPAN_FUNCS];

    /* 
    ** The number of procs stored in the span function arrays.  n is 
    ** the number applied prior to span replication (for drawing to both
    ** FRONT_AND_BACK buffers), and m is the total number applied.
    */
    GLint n, m;

    /*
    ** This is the root span function.  It is called when a span needs 
    ** processing.
    */
    __GLspanFunc processSpan;

    /*
    ** Assembly routine to depth test a single pixel.  There is no prototype,
    ** since variables are passed in registers.
    */
    void (*depthTestPixel)(void);
} __GLspanProcs;

typedef struct __GLlineProcsRec {
    /*
    ** The line procs are very similar to the span procs.  The biggest 
    ** difference is that they iterate along a line instead of a span.
    **
    ** The prototypes for the line procs are identical to the prototypes 
    ** to the poly span paths so that some of the leaves can be shared.
    **
    ** The layers of the line procs are as follows:
    **
    ** scissor, line stipple, alpha test, stencil test, depth test, shading,
    ** texturing, fogging, wide line duplication, FRONT_AND_BACK drawing, 
    ** fetching, blending, dithering, logic op, masking, storing.
    */
    __GLspanFunc lineFuncs[__GL_MAX_LINE_FUNCS];
    __GLstippledSpanFunc stippledLineFuncs[__GL_MAX_LINE_FUNCS];

    /* 
    ** The number of procs stored in the line function arrays.  n is 
    ** the number applied prior to wide line replication (for lines of 
    ** width greater than 1), m is the total number applied prior to 
    ** FRONT_AND_BACK line replication, and l is the total number applied
    ** altogether (l > m > n).
    */
    GLint n, m, l;

    /*
    ** This is the root line function.  It is called when a line needs 
    ** processing.
    */
    __GLspanFunc processLine;

    /*
    ** One of these procs is called after the first n procs have been
    ** completed.  This proc is responsible for replicating a wide line
    ** numerous times.
    */
    __GLspanFunc wideLineRep;
    __GLstippledSpanFunc wideStippledLineRep;

    /*
    ** One of these procs is called after the first m procs have been
    ** completed.  This proc is responsible for replication a line to 
    ** be drawn to both the FRONT and BACK buffers.
    */
    __GLspanFunc drawLine;
    __GLstippledSpanFunc drawStippledLine;

    /*
    ** Assembly routine to depth test a single pixel.  There is no prototype,
    ** since variables are passed in registers.
    **
    ** depthTestPixel is for unstippled lines,
    ** depthTestSPixel is for stippled lines,
    ** depthTestPixelSF is for unstippled lines with stenciling enabled
    ** depthTestSPixelSF is for stippled lines with stenciling enabled.
    */
    void (*depthTestPixel)(void);
    void (*depthTestSPixel)(void);
    void (*depthTestPixelSF)(void);
    void (*depthTestSPixelSF)(void);
} __GLlineProcs;

typedef struct __GLpixelSpanProcsRec {
    /*
    ** Pixel span reading routines.  For examples of each, see pixel/px_read.c.
    **
    ** These routines read pixel spans for CI, RGBA, Stencil and Depth.  The
    ** base versions perform pixel skipping, and the '2' versions simply read
    ** the span straight.  The RGBA routines should produce outgoing scaled
    ** colors.
    */
    void (FASTCALL *spanReadCI)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span);
    void (FASTCALL *spanReadCI2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			GLvoid *span);
    void (FASTCALL *spanReadRGBA)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLvoid *span);
    void (FASTCALL *spanReadRGBA2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *span);
    void (FASTCALL *spanReadDepth)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *span);
    void (FASTCALL *spanReadDepth2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			   GLvoid *span);
    void (FASTCALL *spanReadStencil)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span);
    void (FASTCALL *spanReadStencil2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *span);

    /*
    ** Pixel span rendering routines.  For examples of each, see 
    ** pixel/px_render.c.
    **
    ** These routines render pixel spans for CI, RGBA, Stencil and Depth.  The
    ** base versions perform pixel replication, and the '2' versions simply
    ** render the span straight.  The RGBA routines should take incoming 
    ** scaled colors.
    */
    void (FASTCALL *spanRenderCI)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLvoid *span);
    void (FASTCALL *spanRenderCI2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *span);
    void (FASTCALL *spanRenderRGBA)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			   GLvoid *span);
    void (FASTCALL *spanRenderRGBA2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span);
    void (FASTCALL *spanRenderDepth)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span);
    void (FASTCALL *spanRenderDepth2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *span);
    void (FASTCALL *spanRenderStencil)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			      GLvoid *span);
    void (FASTCALL *spanRenderStencil2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			       GLvoid *span);
} __GLpixelSpanProcs;

/************************************************************************/

/*
** Procedures required for phong shading.
*/

#ifdef GL_WIN_phong_shading
typedef struct __GLphongProcsRec {
    void (*InitSpanInterpolation) (__GLcontext *gc);
    void (*UpdateAlongSpan) (__GLcontext *gc);
    void (*ComputeRGBColor) (__GLcontext *gc, __GLcolor *outColor);
    void (*ComputeCIColor) (__GLcontext *gc, __GLcolor *outColor);
    void (*InitLineParams) (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                            __GLfloat invDelta);
#ifdef __JUNKED_CODE
    void (*InitInterpolation) (__GLcontext *gc, __GLvertex *v);
    void (*SetInitParams) (__GLcontext *gc, __GLvertex *a, 
                                     __GLcoord *an, __GLfloat dx, 
                                     __GLfloat dy);
    void (*UpdateAlongEdge) (__GLcontext *gc, __GLfloat dxLeft, 
                                       GLboolean useBigStep);
#endif //__JUNKED_CODE
} __GLphongProcs;

#endif //GL_WIN_phong_shading
/************************************************************************/

#ifdef unix
typedef struct _XDisplay __GLdisplay;
typedef unsigned long __GLdrawable;
typedef unsigned long __GLfont;
#endif

#ifdef NT
typedef void (FASTCALL *PFN_RENDER_LINE)(__GLcontext *gc, __GLvertex *v0,
                                         __GLvertex *v1, GLuint flags);
typedef void (FASTCALL *PFN_VERTEX_CLIP_PROC)(__GLvertex*, const __GLvertex*,
                                              const __GLvertex*, __GLfloat);
typedef void (FASTCALL *PFN_RENDER_TRIANGLE)(__GLcontext *gc, __GLvertex *v0,
                                             __GLvertex *v1, __GLvertex *v2);
typedef void (FASTCALL *PFN_FILL_TRIANGLE)(__GLcontext *gc, __GLvertex *v0,
                                           __GLvertex *v1,
                                           __GLvertex *v2, GLboolean ccw);
#endif

typedef struct __GLprocsRec __GLprocs;
struct __GLprocsRec {
    /**************************************************************/

    /*
    ** Context function pointer management procs.
    */

    /* Validate the context derived state */
    void (FASTCALL *validate)(__GLcontext *gc);

    /*
    ** Pick procs to choose the other procs in this structure.  These
    ** default to procedures in pick.c (and elsewhere) but can be
    ** overriden by the machine dependent context code.
    */
    void (FASTCALL *pickBlendProcs)(__GLcontext *gc);
    void (FASTCALL *pickColorMaterialProcs)(__GLcontext *gc);
    void (FASTCALL *pickTextureProcs)(__GLcontext *gc);
    void (FASTCALL *pickFogProcs)(__GLcontext *gc);

    void (FASTCALL *pickPointProcs)(__GLcontext *gc);
    void (FASTCALL *pickLineProcs)(__GLcontext *gc);
    void (FASTCALL *pickTriangleProcs)(__GLcontext *gc);
    void (FASTCALL *pickRenderBitmapProcs)(__GLcontext *gc);
    void (FASTCALL *pickPixelProcs)(__GLcontext *gc);

    void (FASTCALL *pickClipProcs)(__GLcontext *gc);
    void (FASTCALL *pickParameterClipProcs)(__GLcontext *gc);

    void (FASTCALL *pickBufferProcs)(__GLcontext *gc);
    void (FASTCALL *pickStoreProcs)(__GLcontext *gc);
    void (FASTCALL *pickSpanProcs)(__GLcontext *gc);
    void (FASTCALL *pickVertexProcs)(__GLcontext *gc);

    int  (FASTCALL *pickDepthProcs)(__GLcontext *gc);
    void (FASTCALL *pickAllProcs)(__GLcontext *gc);

    /**************************************************************/

    /*
    ** Function pointers used for transformation, viewport and normal
    ** processing.
    */

    /* Called when the viewport changes */
    void (FASTCALL *applyViewport)(__GLcontext *gc);

    /**************************************************************/

#ifdef NT
    GLuint (FASTCALL *paClipCheck)(__GLcontext *gc, POLYARRAY *pa, 
                                   POLYDATA *pdLast);
#endif

#ifdef NT
    void (FASTCALL *paCalcTexture)(__GLcontext *gc, POLYARRAY *pa);
#endif

    /**************************************************************/

    /*
    ** Function pointers used for coloring
    */

    /*
    ** applyColor processes a color from the user that has been loaded
    ** into the gc->state.current.color.  If color material is enabled
    ** then the color will be applied the appropriate material(s).
    ** Otherwise, the color will be either scaled or scaled and clamped.
    */
    void (FASTCALL *applyColor)(__GLcontext *gc);

#ifdef NT
    PFN_POLYARRAYCALCCOLORSKIP paCalcColorSkip;
    PFN_POLYARRAYCALCCOLOR     paCalcColor;
    PFN_POLYARRAYAPPLYCHEAPFOG paApplyCheapFog;
#endif

    /*
    ** Apply a color change to a material.
    */
    void (FASTCALL *changeMaterial)(__GLcontext *gc, __GLmaterialState *ms,
			   __GLmaterialMachine *msm);

    /**************************************************************/

    /*
    ** Z buffer test procs
    */

    /*
    ** assembly routines to depth test a single pixel.  These are 
    ** highly optimized C-callable routines...
    */
    GLboolean (FASTCALL *DTPixel)( __GLzValue z, __GLzValue *zfb );

    /**************************************************************/

    /*
    ** Function pointers used for polygon, triangle, quad and rect
    ** rendering.
    */

    /* Rendering */
    PFN_RENDER_TRIANGLE renderTriangle;
    PFN_FILL_TRIANGLE fillTriangle;
    PFN_FILL_TRIANGLE fillTriangle2;

    /* Clipping */
    void (FASTCALL *clipTriangle)(__GLcontext *gc, __GLvertex *v0,
                                  __GLvertex *v1,
                                  __GLvertex *v2, GLuint orCodes);
    void (FASTCALL *clipPolygon)(__GLcontext *gc, __GLvertex *v0, GLint nv);
    PFN_VERTEX_CLIP_PROC polyClipParam;

    /* Function pointers specific to span level rendering */
    __GLspanProcs span;

    /* Function pointers specific to line level rendering */
    __GLlineProcs line;

    /* Function pointers specific to pixel routines (DrawPixels, CopyPixels,
    ** ReadPixels).
    */
    __GLpixelSpanProcs pixel;

    /**************************************************************/

    /*
    ** Function pointers used for lines.
    */
#ifdef NT
    void (FASTCALL *lineBegin)(__GLcontext *gc);
    void (FASTCALL *lineEnd)(__GLcontext *gc);
    PFN_RENDER_LINE renderLine;
    PFN_RENDER_LINE renderLine2;
#else
    void (FASTCALL *renderLine)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
    void (FASTCALL *renderLine2)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif

    /* Line specific parameter clip proc */
    PFN_VERTEX_CLIP_PROC lineClipParam;

    /*
    ** The default slow path renderLine proc simply initializes some line
    ** data, and then calls this proc.
    */
    void (FASTCALL *rasterizeLine)(__GLcontext *gc);

    /**************************************************************/

    /*
    ** Point procs.
    */
    void (FASTCALL *renderPoint)(__GLcontext *gc, __GLvertex *v);
#ifdef __BUGGY_RENDER_POINT
    void (FASTCALL *renderPoint2)(__GLcontext *gc, __GLvertex *v);
#endif //__BUGGY_RENDER_POINT

    /**************************************************************/

    /*
    ** Bitmap procs.
    */
    void (*bitmap)(__GLcontext *gc, GLint width, GLint height,
		   GLfloat xOrig, GLfloat yOrig,
		   GLfloat xMove, GLfloat yMove, const GLubyte bits[]);
    void (FASTCALL *renderBitmap)(__GLcontext *gc, const __GLbitmap *bitmap,
			 const GLubyte *bits);

    /**************************************************************/

    /*
    ** Texturing procs.  The rho procs compute the next rho value
    ** for mipmap selection.  They might be simple procedures if
    ** mipmapping is not being done.
    */
    __GLfloat (*calcLineRho)(__GLcontext *gc, __GLfloat s,
			     __GLfloat t, __GLfloat winv);
    __GLfloat (*calcPolygonRho)(__GLcontext *gc, const __GLshade *sh,
				__GLfloat s, __GLfloat t, __GLfloat winv);
    void (*texture)(__GLcontext *gc, __GLcolor *color, __GLfloat s,
		    __GLfloat t, __GLfloat rho);

    /**************************************************************/

    /*
    ** Fogging procs.  Vertex fogging computes the fog factor at the
    ** vertex and then interpolates that.  High quality fogging
    ** (GL_FOG_HINT set to GL_NICEST) interpolates the eyeZ at then
    ** evaluates the fog function for each fragment.
    */
    void (*fogPoint)(__GLcontext *gc, __GLfragment *frag, __GLfloat eyeZ);
    void (*fogColor)(__GLcontext *gc, __GLcolor *out, __GLcolor *in, 
	    	     __GLfloat eyeZ);
    __GLfloat (FASTCALL *fogVertex)(__GLcontext *gc, __GLvertex *vx);

    /**************************************************************/

    /*
    ** Blend an incoming fragment according to the current blending
    ** mode and return a pointer to the new fragment which contains
    ** the updated colors.
    */
    void (*blend)(__GLcontext *gc, __GLcolorBuffer *cfb,
		  const __GLfragment *frag, __GLcolor *result);
    void (*blendColor)(__GLcontext *gc, const __GLcolor *source,
		       const __GLcolor *dest, __GLcolor *result);
    void (*blendSrc)(__GLcontext *gc, const __GLcolor *source,
		     const __GLcolor *dest, __GLcolor *result);
    void (*blendDst)(__GLcontext *gc, const __GLcolor *frag,
		     const __GLcolor *dest, __GLcolor *result);
    void (FASTCALL *blendSpan)(__GLcontext *gc);

    /**************************************************************/

    /* Pixel proc pointers */
    void (*drawPixels)(__GLcontext *gc, GLint width, GLint height,
		       GLenum format, GLenum type, const GLvoid *pixels,
		       GLboolean packed);
    void (*copyPixels)(__GLcontext *gc, GLint x, GLint y,
		       GLsizei width, GLsizei height, GLenum type);
    void (*readPixels)(__GLcontext *gc, GLint x, GLint y,
		       GLsizei width, GLsizei height,
		       GLenum format, GLenum type, const GLvoid *pixels);
    void (FASTCALL *copyImage)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLboolean applyPixelTransfer);
    void (FASTCALL *pxStore)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /**************************************************************/

    /*
    ** Store a fragment into the given frame buffer, applying any
    ** currently active rasterization modes properly.
    */
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /*
    ** Store a fragment into the given frame buffer.
    */
    void (FASTCALL *cfbStore)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /**************************************************************/

    /*
    ** Function pointers used for attribute processing.
    */

    /* called when the polygon stipple changes */
    void (FASTCALL *convertPolygonStipple)(__GLcontext *gc);

#ifdef GL_WIN_phong_shading
    /**************************************************************/

    /*
    ** Function pointers used for Phong shading.
    */
    __GLphongProcs phong;

    /**************************************************************/
#endif //GL_WIN_phong_shading
};

extern void FASTCALL __glGenericValidate(__GLcontext *gc);

/* Generic (portable) implementations of the pick procs */
extern void FASTCALL __glGenericPickBlendProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickColorMaterialProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickTextureProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickFogProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickParameterClipProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickPointProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickTriangleProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickLineProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickRenderBitmapProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickClipProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickBufferProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickStoreProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickSpanProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickVertexProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickPixelProcs(__GLcontext *gc);
extern int  FASTCALL __glGenericPickDepthProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickAllProcs(__GLcontext *gc);

/* some useful store procs */
extern void FASTCALL __glDoStore_ASD(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_AS(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_AD(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_SD(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_A(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_S(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_D(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoNullStore(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoDoubleStore(__GLcolorBuffer *, const __GLfragment *);

/* Some predicates for pick procs to use */
extern GLboolean FASTCALL __glFastRGBA(__GLcontext *gc);
extern GLboolean FASTCALL __glNeedAlpha(__GLcontext *gc);

/* Save routines */
void FASTCALL FASTCALL __glSaveN(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveC(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCI(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveT(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCT(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveNT(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCAll(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCIAll(__GLcontext *gc, __GLvertex *vx);

#ifdef NT
void FASTCALL PolyArrayCalcTexture(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcObjectLinearSameST(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcObjectLinear(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcEyeLinearSameST(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcEyeLinear(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcSphereMap(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcMixedTexture(__GLcontext *gc, POLYARRAY *pa);
#endif

#ifdef _X86_

void initClipCodesTable();       // Defined in so_prim.c
void initInvSqrtTable();         // Defined in so_prim.c

#endif // _X86_

#endif /* __glprocs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\span2.h ===
/******************************Module*Header*******************************\
* Module Name: span2.h
*
* This code figures out the color for pixel and stores it
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

{
    DWORD r, g, b;
    DWORD color;
    #if DITHER
        #if (BPP == 8)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix) & 0x3];
        #elif (BPP == 16)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix & 0x6) >> 1];
        #elif (BPP == 24)
            ULONG ditherVal = pdither[iDither];
        #else
            ULONG ditherVal = pdither[((ULONG_PTR)pPix & 0xc) >> 2];
        #endif
    #else
        #if (RGBMODE) && (TEXTURE) && (SHADE)
            #define ditherVal 0x0008
        #else
            #define ditherVal 0x0000
        #endif
    #endif

    #if TEXTURE
        #if !(SHADE) && !(DITHER) && (BPP == 8)
            texBits = (BYTE *)(texAddr + ((sAccum & GENACCEL(gengc).sMask) >> 16) +
                                          ((tAccum & GENACCEL(gengc).tMask) >> GENACCEL(gengc).tShift));
        #elif !(SHADE) && !(DITHER) && (BPP == 16)
            texBits = (BYTE *)(texAddr + ((sAccum & GENACCEL(gengc).sMask) >> 15) +
                                          ((tAccum & GENACCEL(gengc).tMask) >> GENACCEL(gengc).tShift));
        #else
            texBits = (BYTE *)(texAddr + ((sAccum & GENACCEL(gengc).sMask) >> 14) +
                                          ((tAccum & GENACCEL(gengc).tMask) >> GENACCEL(gengc).tShift));
        #endif
    #endif

    #if !(RGBMODE)
        // !!! probably don't need to mask values
        #if (BPP == 8)
            color = ((rAccum + ditherVal) >> 16) & 0xff;
        #else
            color = ((PULONG)pXlat)[(((rAccum + ditherVal) >> 16) & 0xfff)];
        #endif
    #else //RGBMODE
        #if TEXTURE
            #if SHADE
                 #define BIGSHIFT 8
                 #ifdef RSHIFT
                 r = ((ULONG)gbMulTable[(((rAccum >> RBITS) & 0xff00) | texBits[2])] << RBITS) + ditherVal;
                 g = ((ULONG)gbMulTable[(((gAccum >> GBITS) & 0xff00) | texBits[1])] << GBITS) + ditherVal;
                 b = ((ULONG)gbMulTable[(((bAccum >> BBITS) & 0xff00) | texBits[0])] << BBITS) + ditherVal;
                 #else
                 r = ((ULONG)gbMulTable[(((rAccum >> rBits) & 0xff00) | texBits[2])] << rBits) + ditherVal;
                 g = ((ULONG)gbMulTable[(((gAccum >> gBits) & 0xff00) | texBits[1])] << gBits) + ditherVal;
                 b = ((ULONG)gbMulTable[(((bAccum >> bBits) & 0xff00) | texBits[0])] << bBits) + ditherVal;
                 #endif
            #else //!SHADE
                #define BIGSHIFT 8
                #if DITHER
                    #ifdef RSHIFT
                    r = ((ULONG)gbMulTable[(rAccum | texBits[2])] << RBITS) + ditherVal;
                    g = ((ULONG)gbMulTable[(gAccum | texBits[1])] << GBITS) + ditherVal;
                    b = ((ULONG)gbMulTable[(bAccum | texBits[0])] << BBITS) + ditherVal;
                    #else
                    r = ((ULONG)gbMulTable[(rAccum | texBits[2])] << rBits) + ditherVal;
                    g = ((ULONG)gbMulTable[(gAccum | texBits[1])] << gBits) + ditherVal;
                    b = ((ULONG)gbMulTable[(bAccum | texBits[0])] << bBits) + ditherVal;
                    #endif
                #else //!DITHER
                    #if (!((BPP == 8) || (BPP == 16)))
                        #ifdef RSHIFT
                        r = (texBits[2] << RBITS);
                        g = (texBits[1] << GBITS);
                        b = (texBits[0] << BBITS);
                        #else
                        r = (texBits[2] << rBits);
                        g = (texBits[1] << gBits);
                        b = (texBits[0] << bBits);
                        #endif
                    #endif
                #endif  //DITHER
            #endif //SHADE
        #else //!TEXTURE
            #define BIGSHIFT 16
            r = rAccum + ditherVal;
            g = gAccum + ditherVal;
            b = bAccum + ditherVal;
        #endif //TEXTURE

        #if !((TEXTURE) && !(SHADE) && !(DITHER) && ((BPP == 8) || (BPP == 16)))

            #ifdef RSHIFT
                color = ((r >> BIGSHIFT) << RSHIFT) |
                        ((g >> BIGSHIFT) << GSHIFT) |
                        ((b >> BIGSHIFT) << BSHIFT);
            #else
                color = ((r >> BIGSHIFT) << rShift) |
                        ((g >> BIGSHIFT) << gShift) |
                        ((b >> BIGSHIFT) << bShift);
            #endif

        #endif

        #undef BIGSHIFT
    #endif //RGBMODE

    #if (TEXTURE) && !(SHADE) && !(DITHER) && ((BPP == 8) || (BPP == 16))
        #if (BPP == 8)
            *pPix = texBits[0];
        #else
            *((WORD *)pPix) = *((WORD *)texBits);
        #endif
    #else
        #if (BPP == 8)
            *pPix = gengc->xlatPalette[color & 0xff];
        #elif (BPP == 16)
            *((WORD *)pPix) = (USHORT)color;
        #elif (BPP == 24)
            *pPix = (BYTE)color;
            *(pPix + 1) = (BYTE)(color >> 8);
            *(pPix + 2) = (BYTE)(color >> 16);
        #else
            *((DWORD *)pPix) = color;
        #endif // BPP
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\select.h ===
#ifndef _select_h_
#define _select_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.3 $
** $Date: 1992/10/13 14:13:28 $
*/
#include "types.h"

typedef struct __GLselectMachineRec {
    /*
    ** This is true when the last primitive to execute hit (intersected)
    ** the selection box.  Whenever the name stack is manipulated this
    ** bit is cleared.
    */
    GLboolean hit;

    /*
    ** Name stack.
    */
    GLuint *stack;
    GLuint *sp;

    /*
    ** The user specified result array overflows, this bit is set.
    */
    GLboolean overFlowed;

    /*
    ** User specified result array.  As primitives are processed names
    ** will be entered into this array.
    */
    GLuint *resultBase;

    /*
    ** Current pointer into the result array.
    */
    GLuint *result;

    /*
    ** The number of GLint's that the array can hold.
    */
    GLint resultLength;

    /*
    ** Number of hits
    */
    GLint hits;

    /*
    ** Pointer to z values for last hit.
    */
    GLuint *z;
} __GLselectMachine;

extern void __glSelectHit(__GLcontext *gc, __GLfloat z);

#ifdef NT
extern void FASTCALL __glSelectLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b, GLuint flags);
#else
extern void FASTCALL __glSelectLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b);
#endif
extern void FASTCALL __glSelectPoint(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glSelectTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                                        __GLvertex *c);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\span3.h ===
/******************************Module*Header*******************************\
* Module Name: span3.h
*
* This code advances all the values for the next pixel
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

    #if (SHADE) || !(RGBMODE)
        rAccum += rDelta;
        #if RGBMODE
            gAccum += gDelta;
            bAccum += bDelta;
        #endif
    #endif

    #if TEXTURE
        sAccum += sDelta;
        tAccum += tDelta;
    #endif

    #if GENERIC || ((DITHER) && (BPP == 24))
        iDither = (iDither + 1) & 0x3;
    #endif

    pPix += (BPP / 8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\render.h ===
#ifndef __glrender_h_
#define __glrender_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "constant.h"
#include "cpu.h"
#ifdef GL_WIN_phong_shading
#include "phong.h"
#endif //GL_WIN_phong_shading

/* 
** used to approximate zero (and avoid divide by zero errors)
** when doing polygon offset with dzdx = 0.
*/
#define __GL_PGON_OFFSET_NEAR_ZERO .00001

/* 
** Epsilon value for detecting non-scaling transformation matrices:
*/

#define __GL_MATRIX_UNITY_SCALE_EPSILON ((__GLfloat)0.0001)


typedef GLuint __GLstippleWord;

/*
** A fragment is a collection of all the data needed after rasterization
** of a primitive has occured, but before the data is entered into various
** framebuffers.  The data contained in the fragment has been normalized
** into a form for immediate storage into the framebuffer.
*/
struct __GLfragmentRec {
    /* Screen x, y */
    GLint x, y;

    /* Z coordinate in form used by depth buffer */
    __GLzValue z;

    /*
    ** Color of the fragment.  When in colorIndexMode only the r component
    ** is valid.
    */
    __GLcolor color;

    /* Texture information for the fragment */
    __GLfloat s, t, qw;

    /* Fog information for the fragment */
    __GLfloat f;
};

/************************************************************************/

/*
** Shader record for iterated objects (lines/triangles).  This keeps
** track of all the various deltas needed to rasterize a triangle.
*/
struct __GLshadeRec {
    GLint dxLeftLittle, dxLeftBig;
    GLint dxLeftFrac;
    GLint ixLeft, ixLeftFrac;

    GLint dxRightLittle, dxRightBig;
    GLint dxRightFrac;
    GLint ixRight, ixRightFrac;

    __GLfloat area;
    __GLfloat dxAC, dxBC, dyAC, dyBC;

    __GLfragment frag;
    GLint length;

    /* Color */
    __GLfloat rLittle, gLittle, bLittle, aLittle;
    __GLfloat rBig, gBig, bBig, aBig;
    __GLfloat drdx, dgdx, dbdx, dadx;
    __GLfloat drdy, dgdy, dbdy, dady;

    /* Depth */
    GLint zLittle, zBig;
    GLint dzdx;
    __GLfloat dzdyf, dzdxf;

    /* Texture */
    __GLfloat sLittle, tLittle, qwLittle;
  __GLfloat sBig, tBig, qwBig;
    __GLfloat dsdx, dtdx, dqwdx;
    __GLfloat dsdy, dtdy, dqwdy;

    __GLfloat fLittle, fBig;
    __GLfloat dfdy, dfdx;

    GLuint modeFlags;

    __GLzValue *zbuf;
    GLint zbufBig, zbufLittle;

    __GLstencilCell *sbuf;
    GLint sbufBig, sbufLittle;

    __GLcolor *colors;
    __GLcolor *fbcolors;
    __GLstippleWord *stipplePat;
    GLboolean done;

    __GLcolorBuffer *cfb;

#ifdef GL_WIN_phong_shading
    __GLphongShade phong;
#endif //GL_WIN_phong_shading
};


/*
** The distinction between __GL_SHADE_SMOOTH and __GL_SHADE_SMOOTH_LIGHT is
** simple.  __GL_SHADE_SMOOTH indicates if the polygon will be smoothly 
** shaded, and __GL_SHADE_SMOOTH_LIGHT indicates if the polygon will be 
** lit at each vertex.  Note that __GL_SHADE_SMOOTH might be set while
** __GL_SHADE_SMOOTH_LIGHT is not set if the lighting model is GL_FLAT, but
** the polygons are fogged.
*/
#define __GL_SHADE_RGB		0x0001
#define __GL_SHADE_SMOOTH	0x0002 /* smooth shaded polygons */
#define __GL_SHADE_DEPTH_TEST	0x0004
#define __GL_SHADE_TEXTURE	0x0008
#define __GL_SHADE_STIPPLE	0x0010 /* polygon stipple */
#define __GL_SHADE_STENCIL_TEST	0x0020
#define __GL_SHADE_DITHER	0x0040
#define __GL_SHADE_LOGICOP	0x0080
#define __GL_SHADE_BLEND	0x0100
#define __GL_SHADE_ALPHA_TEST	0x0200
#define __GL_SHADE_TWOSIDED	0x0400
#define __GL_SHADE_MASK		0x0800

/* Two kinds of fog... */
#define __GL_SHADE_SLOW_FOG	0x1000
#define __GL_SHADE_CHEAP_FOG	0x2000

/* do we iterate depth values in software */
#define __GL_SHADE_DEPTH_ITER	0x4000

#define __GL_SHADE_LINE_STIPPLE	0x8000

#define __GL_SHADE_CULL_FACE	0x00010000
#define __GL_SHADE_SMOOTH_LIGHT	0x00020000 /* smoothly lit polygons */

// Set when the texture mode makes polygon color irrelevant
#define __GL_SHADE_FULL_REPLACE_TEXTURE 0x00040000

#ifdef GL_WIN_phong_shading
/* 
** This is set when shade-model is GL_PHONG_EXT and Lighting is ON
** otherwise use smooth shading.
** Used in place of __GL_SHADE_SMOOTH_LIGHT when ShadeModel is 
** GL_PHONG_EXT.
*/
#define __GL_SHADE_PHONG    0x00100000
#endif //GL_WIN_phong_shading
// Set when the current sub-triangle is the last (or only) subtriangle
#define __GL_SHADE_LAST_SUBTRI		0x00080000
#ifdef GL_WIN_specular_fog
// Set when the specularly-lit textures are needed using fog.
#define __GL_SHADE_SPEC_FOG		0x00200000
#endif //GL_WIN_specular_fog
#define __GL_SHADE_COMPUTE_FOG	0x00400000
#define __GL_SHADE_INTERP_FOG	0x00800000

/************************************************************************/

/*
** __GL_STIPPLE_COUNT_BITS is the number of bits needed to represent a 
** stipple count (5 bits).
**
** __GL_STIPPLE_BITS is the number of bits in a stipple word (32 bits).
*/
#define __GL_STIPPLE_COUNT_BITS 5
#define __GL_STIPPLE_BITS (1 << __GL_STIPPLE_COUNT_BITS)

#ifdef __GL_STIPPLE_MSB
#define __GL_STIPPLE_SHIFT(i) (1 << (__GL_STIPPLE_BITS - 1 - (i)))
#else
#define __GL_STIPPLE_SHIFT(i) (1 << (i))
#endif

#define __GL_MAX_STIPPLE_WORDS \
    ((__GL_MAX_MAX_VIEWPORT + __GL_STIPPLE_BITS - 1) / __GL_STIPPLE_BITS)

#ifdef NT
// Allow 256 bytes of stipple on the stack.  This may seem small but
// stipples are consumed a bit at a time so this is good enough for
// 2048 stipple bits
#define __GL_MAX_STACK_STIPPLE_BITS \
    2048
#define __GL_MAX_STACK_STIPPLE_WORDS \
    ((__GL_MAX_STACK_STIPPLE_BITS+__GL_STIPPLE_BITS-1)/__GL_STIPPLE_BITS)
#endif

/************************************************************************/

/*
** Accumulation buffer cells for each color component.  Note that these
** items needs to be at least 2 bits bigger than the color components
** that drive them, with 2 times being ideal.  This declaration assumes
** that the underlying color components are no more than 14 bits and
** hopefully 8.
*/
typedef struct __GLaccumCellRec {
    __GLaccumCellElement r, g, b, a;
} __GLaccumCell;

/************************************************************************/

struct __GLbitmapRec {
        GLsizei width;
        GLsizei height;
        GLfloat xorig;
        GLfloat yorig;
        GLfloat xmove;
        GLfloat ymove;
	GLint imageSize;		/* An optimization */
        /*      bitmap  */
};

extern void __glDrawBitmap(__GLcontext *gc, GLsizei width, GLsizei height,
			   GLfloat xOrig, GLfloat yOrig,
			   GLfloat xMove, GLfloat yMove,
			   const GLubyte bits[]);

extern __GLbitmap *__glAllocBitmap(__GLcontext *gc,
				   GLsizei width, GLsizei height,
				   GLfloat xOrig, GLfloat yOrig,
				   GLfloat xMove, GLfloat yMove);
				
extern void FASTCALL __glRenderBitmap(__GLcontext *gc, const __GLbitmap *bitmap,
			     const GLubyte *bits);

/************************************************************************/

/* New AA line algorithm supports widths one or more.  Until that changes,
** don't change this minimum!
*/
#define __GL_POINT_SIZE_MINIMUM		 ((__GLfloat) 1.0)
#define __GL_POINT_SIZE_MAXIMUM		((__GLfloat) 10.0)
#define __GL_POINT_SIZE_GRANULARITY	 ((__GLfloat) 0.125)

extern void FASTCALL __glBeginPoints(__GLcontext *gc);
extern void FASTCALL __glEndPoints(__GLcontext *gc);

extern void FASTCALL __glPoint(__GLcontext *gc, __GLvertex *vx);
extern void FASTCALL __glPointFast(__GLcontext *gc, __GLvertex *vx);

/* Various point rendering implementations */
void FASTCALL __glRenderAliasedPointN(__GLcontext *gc, __GLvertex *v);
void FASTCALL __glRenderAliasedPoint1(__GLcontext *gc, __GLvertex *v);
void FASTCALL __glRenderAliasedPoint1_NoTex(__GLcontext *gc, __GLvertex *v);
#ifdef __BUGGY_RENDER_POINT
void FASTCALL __glRenderFlatFogPoint(__GLcontext *gc, __GLvertex *v);
#ifdef NT
void FASTCALL __glRenderFlatFogPointSlow(__GLcontext *gc, __GLvertex *v);
#endif
#endif //__BUGGY_RENDER_POINT

void FASTCALL __glRenderAntiAliasedRGBPoint(__GLcontext *gc, __GLvertex *v);
void FASTCALL __glRenderAntiAliasedCIPoint(__GLcontext *gc, __GLvertex *v);

/************************************************************************/

#define __GL_LINE_WIDTH_MINIMUM		 ((__GLfloat) 0.5)
#define __GL_LINE_WIDTH_MAXIMUM		((__GLfloat) 10.0)
#define __GL_LINE_WIDTH_GRANULARITY	 ((__GLfloat) 0.125)

/*
** Don't change these constants without fixing LIGHT/rex_linespan.ma which
** currently assumes that __GL_X_MAJOR is 0.
*/
#define __GL_X_MAJOR    0
#define __GL_Y_MAJOR    1

/*
** Use a fixed point notation of 15.17
**
** This should support screen sizes up to 4K x 4K, with 5 subpixel bits
** for 4K x 4K screens.
*/
#define __GL_LINE_FRACBITS              17
#define __GL_LINE_INT_TO_FIXED(x)       ((x) << __GL_LINE_FRACBITS)
#define __GL_LINE_FLOAT_TO_FIXED(x)     ((x) * (1 << __GL_LINE_FRACBITS))
#define __GL_LINE_FIXED_ONE             (1 << __GL_LINE_FRACBITS)
#define __GL_LINE_FIXED_HALF            (1 << (__GL_LINE_FRACBITS-1))
#define __GL_LINE_FIXED_TO_FLOAT(x) 	(((GLfloat) (x)) / __GL_LINE_FIXED_ONE)
#define __GL_LINE_FIXED_TO_INT(x)       (((unsigned int) (x)) >> __GL_LINE_FRACBITS)

/*
** Contains variables needed to draw all line options.
*/
struct __GLlineOptionsRec {
    GLint axis, numPixels;
    __GLfloat offset, length, oneOverLength;
    GLint xStart, yStart;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    __GLfloat curF, curR, curG, curB, curA, curS, curT, curQW;
    __GLzValue curZ;
    __GLfloat antiAliasPercent;
    __GLfloat f0;
    GLint width;
    const __GLvertex *v0, *v1;

    /* Anti-aliased line only info */
    __GLfloat realLength;
    __GLfloat dldx, dldy;
    __GLfloat dddx, dddy;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLfloat plength, pwidth;

    /* Anti-aliased stippled lines only */
    __GLfloat stippleOffset;
    __GLfloat oneOverStippleRepeat;
};

/*
** Line state.  Contains all the line specific state, as well as
** procedure pointers used during rendering operations.
*/
typedef struct {
    /*
    ** stipplePosition indicates which bit in mask is being examined
    ** for the next pixel in the line to be rendered.  It is also used
    ** by feedback lines to determine if they are the first of a connected
    ** loop.
    */
    GLint stipplePosition;

    /*
    ** Repeat factor.  After repeat is reduced to zero the
    ** stipplePosition is updated.
    */
    GLint repeat;

    /*
    ** Set to FALSE when the stipple needs to be reset.
    */
    GLboolean notResetStipple;

    __GLlineOptions options;
} __GLlineMachine;

#ifdef NT
// renderLine flags
#define __GL_LVERT_FIRST        0x0001
#endif

void FASTCALL __glBeginLStrip(__GLcontext *gc);
void FASTCALL __glEndLStrip(__GLcontext *gc);
void FASTCALL __glBeginLLoop(__GLcontext *gc);
void FASTCALL __glEndLLoop(__GLcontext *gc);
void FASTCALL __glBeginLines(__GLcontext *gc);
void FASTCALL __glEndLines(__GLcontext *gc);

#ifdef NT
void FASTCALL __glClipLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                           GLuint flags);
void FASTCALL __glNopLineBegin(__GLcontext *gc);
void FASTCALL __glNopLineEnd(__GLcontext *gc);
#else
void FASTCALL __glClipLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif

#ifdef NT
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0,
                                  __GLvertex *v1, GLuint flags);
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
                                    __GLvertex *v1, GLuint flags);
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0,
                                      __GLvertex *v1, GLuint flags);
BOOL FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#else
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
			   __GLvertex *v1);
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
void FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif

/*
** Line procs
*/
GLboolean FASTCALL __glProcessLine(__GLcontext *);
GLboolean FASTCALL __glProcessLine3NW(__GLcontext *);
GLboolean FASTCALL __glWideLineRep(__GLcontext *);
GLboolean FASTCALL __glDrawBothLine(__GLcontext *);
GLboolean FASTCALL __glScissorLine(__GLcontext *);
GLboolean FASTCALL __glStippleLine(__GLcontext *);
GLboolean FASTCALL __glStencilTestLine(__GLcontext *);
#ifdef NT
GLboolean FASTCALL __glDepth16TestStencilLine(__GLcontext *);
#endif
GLboolean FASTCALL __glDepthTestStencilLine(__GLcontext *);
GLboolean FASTCALL __glDepthPassLine(__GLcontext *);
GLboolean FASTCALL __glDitherCILine(__GLcontext *);
GLboolean FASTCALL __glDitherRGBALine(__GLcontext *);
GLboolean FASTCALL __glStoreLine(__GLcontext *);
GLboolean FASTCALL __glAntiAliasLine(__GLcontext *);

#ifdef __GL_USEASMCODE
GLboolean FASTCALL __glDepthTestLine_asm(__GLcontext *gc);

/*
** A LEQUAL specific line depth tester because LEQUAL is the method of
** choice.  :)
*/
GLboolean FASTCALL __glDepthTestLine_LEQ_asm(__GLcontext *gc);

/* Assembly routines */
void __glDTP_LEQUAL(void);
void __glDTP_EQUAL(void);
void __glDTP_GREATER(void);
void __glDTP_NOTEQUAL(void);
void __glDTP_GEQUAL(void);
void __glDTP_ALWAYS(void);
void __glDTP_LESS(void);
void __glDTP_LEQUAL_M(void);
void __glDTP_EQUAL_M(void);
void __glDTP_GREATER_M(void);
void __glDTP_NOTEQUAL_M(void);
void __glDTP_GEQUAL_M(void);
void __glDTP_ALWAYS_M(void);
void __glDTP_LESS_M(void);
#else
#ifdef NT
GLboolean FASTCALL __glDepth16TestLine(__GLcontext *);
#endif
GLboolean FASTCALL __glDepthTestLine(__GLcontext *);
#endif

/*
** Line stippled procs
*/
GLboolean FASTCALL __glScissorStippledLine(__GLcontext *);
GLboolean FASTCALL __glWideStippleLineRep(__GLcontext *);
GLboolean FASTCALL __glDrawBothStippledLine(__GLcontext *);
GLboolean FASTCALL __glStencilTestStippledLine(__GLcontext *);
#ifdef NT
GLboolean FASTCALL __glDepth16TestStippledLine(__GLcontext *);
GLboolean FASTCALL __glDepth16TestStencilStippledLine(__GLcontext *);
#endif
GLboolean FASTCALL __glDepthTestStippledLine(__GLcontext *);
GLboolean FASTCALL __glDepthTestStencilStippledLine(__GLcontext *);
GLboolean FASTCALL __glDepthPassStippledLine(__GLcontext *);
GLboolean FASTCALL __glDitherCIStippledLine(__GLcontext *);
GLboolean FASTCALL __glDitherRGBAStippledLine(__GLcontext *);
GLboolean FASTCALL __glStoreStippledLine(__GLcontext *);
GLboolean FASTCALL __glAntiAliasStippledLine(__GLcontext *);


/* 
** C depth-test routines
*/
GLboolean FASTCALL __glDT_NEVER( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_LEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_LESS( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_EQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GREATER( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_NOTEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_ALWAYS( __GLzValue, __GLzValue * );

GLboolean FASTCALL __glDT_LEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_LESS_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_EQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GREATER_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_NOTEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_ALWAYS_M( __GLzValue, __GLzValue * );

GLboolean FASTCALL __glDT16_LEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_LESS( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_EQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GREATER( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_NOTEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_ALWAYS( __GLzValue, __GLzValue * );

GLboolean FASTCALL __glDT16_LEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_LESS_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_EQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GREATER_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_NOTEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_ALWAYS_M( __GLzValue, __GLzValue * );

extern GLboolean (FASTCALL *__glCDTPixel[32])(__GLzValue, __GLzValue * );

/************************************************************************/

/*
** Polygon machine state.  Contains all the polygon specific state,
** as well as procedure pointers used during rendering operations.
*/
typedef struct __GLpolygonMachineRec {
    /*
    ** Internal form of users stipple.  Users stipple is always
    ** normalized to stippleWord sized with the LSB of each word mapping
    ** to the left x coordinate.
    */
    __GLstippleWord stipple[32];

    /*
    ** Polygon (triangle really) shading state.  Used by polygon fillers
    ** and span routines.
    */
    __GLshade shader;

    /*
    ** Lookup table that returns the face (0=front, 1=back) when indexed
    ** by a flag which is zero for CW and 1 for CCW.  If FrontFace is CW:
    ** 	face[0] = 0
    ** 	face[1] = 1
    ** else
    ** 	face[0] = 1
    ** 	face[1] = 0
    */
    GLubyte face[2];

    /*
    ** Internal form of polygon mode for each face
    */
    GLubyte mode[2];

    /*
    ** Culling flag.  0 when culling the front face, 1 when culling the
    ** back face and 2 when not culling.
    */
    GLubyte cullFace;
} __GLpolygonMachine;

/* defines for above cullFlag */
#define __GL_CULL_FLAG_FRONT	__GL_FRONTFACE
#define __GL_CULL_FLAG_BACK	__GL_BACKFACE
#define __GL_CULL_FLAG_DONT	2

/* Indicies for face[] array in polygonMachine above */
#define __GL_CW		0
#define __GL_CCW	1

/* Internal numbering for polymode values */
#define __GL_POLYGON_MODE_FILL	(GL_FILL & 0xf)
#define __GL_POLYGON_MODE_LINE	(GL_LINE & 0xf)
#define __GL_POLYGON_MODE_POINT	(GL_POINT & 0xf)

extern void FASTCALL __glBeginPolygon(__GLcontext *gc);
extern void FASTCALL __glBeginQStrip(__GLcontext *gc);
extern void FASTCALL __glBeginQuads(__GLcontext *gc);
extern void FASTCALL __glBeginTFan(__GLcontext *gc);
extern void FASTCALL __glBeginTriangles(__GLcontext *gc);
extern void FASTCALL __glBeginTStrip(__GLcontext *gc);

extern void FASTCALL __glClipTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			     __GLvertex *c, GLuint orClipCodes);
extern void FASTCALL __glClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv);
extern void __glDoPolygonClip(__GLcontext *gc, __GLvertex **vp, GLint nv,
			      GLuint orClipCodes);
extern void FASTCALL __glFrustumClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv);

extern void FASTCALL __glConvertStipple(__GLcontext *gc);

/* Rectangle processing proc */
extern void __glRect(__GLcontext *gc, __GLfloat x0, __GLfloat y0, 
	             __GLfloat x1, __GLfloat y1);

/*
** Triangle render proc that handles culling, twosided lighting and
** polygon mode.
*/
extern void FASTCALL __glRenderTriangle(__GLcontext *gc, __GLvertex *a,
			       __GLvertex *b, __GLvertex *c);
extern void FASTCALL __glRenderFlatTriangle(__GLcontext *gc, __GLvertex *a,
				   __GLvertex *b, __GLvertex *c);
extern void FASTCALL __glRenderSmoothTriangle(__GLcontext *gc, __GLvertex *a,
				     __GLvertex *b, __GLvertex *c);

#ifdef GL_WIN_phong_shading
extern void FASTCALL __glRenderPhongTriangle(__GLcontext *gc, __GLvertex *a,
				     __GLvertex *b, __GLvertex *c);
#endif //GL_WIN_phong_shading

extern void FASTCALL __glDontRenderTriangle(__GLcontext *gc, __GLvertex *a,
				   __GLvertex *b, __GLvertex *c);

/*
** Triangle filling procs for each polygon smooth mode
*/
void FASTCALL __glFillTriangle(__GLcontext *gc, __GLvertex *a,
		      __GLvertex *b, __GLvertex *c, GLboolean ccw);

#ifdef GL_WIN_phong_shading
extern void FASTCALL __glFillPhongTriangle(__GLcontext *gc, __GLvertex *a,
		      __GLvertex *b, __GLvertex *c, GLboolean ccw);
extern void FASTCALL __glFillAntiAliasedPhongTriangle(__GLcontext *gc, 
                                                      __GLvertex *a,
                                                      __GLvertex *b, 
                                                      __GLvertex *c,
                                                      GLboolean ccw);
#endif //GL_WIN_phong_shading

void FASTCALL __glFillFlatFogTriangle(__GLcontext *gc, __GLvertex *a,
			     __GLvertex *b, __GLvertex *c, 
			     GLboolean ccw);
void FASTCALL __glFillAntiAliasedTriangle(__GLcontext *gc, __GLvertex *a,
				 __GLvertex *b, __GLvertex *c,
				 GLboolean ccw);

#ifdef GL_WIN_specular_fog
void FASTCALL __glFillFlatSpecFogTriangle(__GLcontext *gc, __GLvertex *a,
                                          __GLvertex *b, __GLvertex *c, 
                                          GLboolean ccw);
#endif //GL_WIN_specular_fog


/*
** Polygon offset calc
*/
extern __GLfloat __glPolygonOffsetZ(__GLcontext *gc );

/*
** Span procs
*/
extern GLboolean FASTCALL __glProcessSpan(__GLcontext *);
extern GLboolean FASTCALL __glProcessReplicateSpan(__GLcontext *);
extern GLboolean FASTCALL __glClipSpan(__GLcontext *);
extern GLboolean FASTCALL __glStippleSpan(__GLcontext *);
extern GLboolean FASTCALL __glAlphaTestSpan(__GLcontext *);

#ifdef __GL_USEASMCODE
/* Assembly routines */
void FASTCALL __glDTS_LEQUAL(void);
void FASTCALL __glDTS_EQUAL(void);
void FASTCALL __glDTS_GREATER(void);
void FASTCALL __glDTS_NOTEQUAL(void);
void FASTCALL __glDTS_GEQUAL(void);
void FASTCALL __glDTS_ALWAYS(void);
void FASTCALL __glDTS_LESS(void);
void FASTCALL __glDTS_LEQUAL_M(void);
void FASTCALL __glDTS_EQUAL_M(void);
void FASTCALL __glDTS_GREATER_M(void);
void FASTCALL __glDTS_NOTEQUAL_M(void);
void FASTCALL __glDTS_GEQUAL_M(void);
void FASTCALL __glDTS_ALWAYS_M(void);
void FASTCALL __glDTS_LESS_M(void);
extern GLboolean FASTCALL __glStencilTestSpan_asm(__GLcontext *);
extern GLboolean FASTCALL __glDepthTestSpan_asm(__GLcontext *);
extern void (*__glSDepthTestPixel[16])(void);
#else
extern GLboolean FASTCALL __glStencilTestSpan(__GLcontext *);
#ifdef NT
extern GLboolean FASTCALL __glDepth16TestSpan(__GLcontext *);
#endif
extern GLboolean FASTCALL __glDepthTestSpan(__GLcontext *);
#endif

#ifdef NT
extern GLboolean FASTCALL __glDepth16TestStencilSpan(__GLcontext *);
#endif
extern GLboolean FASTCALL __glDepthTestStencilSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepthPassSpan(__GLcontext *);
extern GLboolean FASTCALL __glColorSpan1(__GLcontext *);
extern GLboolean FASTCALL __glColorSpan2(__GLcontext *);
extern GLboolean FASTCALL __glColorSpan3(__GLcontext *);
extern GLboolean FASTCALL __glFlatRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glShadeRGBASpan(__GLcontext *);

#ifdef GL_WIN_phong_shading
extern GLboolean FASTCALL __glPhongRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glPhongCISpan(__GLcontext *);
extern GLboolean FASTCALL __glPhongRGBALineSpan(__GLcontext *);
extern GLboolean FASTCALL __glPhongCILineSpan(__GLcontext *);
#endif //GL_WIN_phong_shading

extern GLboolean FASTCALL __glFlatCISpan(__GLcontext *);
extern GLboolean FASTCALL __glShadeCISpan(__GLcontext *);
extern GLboolean FASTCALL __glTextureSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogSpanSlow(__GLcontext *);
extern GLboolean FASTCALL __glDrawBothSpan(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan1(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan2(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan3(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan4(__GLcontext *);
extern GLboolean FASTCALL __glDitherRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glDitherCISpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundCISpan(__GLcontext*);
extern GLboolean FASTCALL __glLogicOpSpan(__GLcontext *);
extern GLboolean FASTCALL __glMaskRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glMaskCISpan(__GLcontext *);

/*
** Stippled span procs
*/
extern GLboolean FASTCALL __glStippleStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glAlphaTestStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glStencilTestStippledSpan(__GLcontext *);
#ifdef NT
extern GLboolean FASTCALL __glDepth16TestStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepth16TestStencilStippledSpan(__GLcontext *);
#endif
extern GLboolean FASTCALL __glDepthTestStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepthTestStencilStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepthPassStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glColorStippledSpan1(__GLcontext *);
extern GLboolean FASTCALL __glColorStippledSpan2(__GLcontext *);
extern GLboolean FASTCALL __glColorStippledSpan3(__GLcontext *);
extern GLboolean FASTCALL __glTextureStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogStippledSpanSlow(__GLcontext *);
extern GLboolean FASTCALL __glDrawBothStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan1(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan2(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan3(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan4(__GLcontext *);
extern GLboolean FASTCALL __glBlendStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDitherRGBAStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDitherCIStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundRGBAStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundCIStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glLogicOpStippledSpan(__GLcontext *);

/************************************************************************/

extern void FASTCALL __glValidateAlphaTest(__GLcontext *gc);

/************************************************************************/

extern void FASTCALL __glValidateStencil(__GLcontext *gc, __GLstencilBuffer *sfb);

#define __GL_STENCIL_RANGE	(1 << (sizeof(__GLstencilCell) * 8))/*XXX*/
#define __GL_MAX_STENCIL_VALUE	(__GL_STENCIL_RANGE - 1)

/************************************************************************/

void __glFogFragmentSlow(__GLcontext *gc, __GLfragment *fr, __GLfloat f);
__GLfloat FASTCALL __glFogVertex(__GLcontext *gc, __GLvertex *fr);
__GLfloat FASTCALL __glFogVertexLinear(__GLcontext *gc, __GLvertex *fr);
void __glFogColorSlow(__GLcontext *gc, __GLcolor *out, __GLcolor *in,
		      __GLfloat fog);

/************************************************************************/

/* color index anti-alias support function */
extern __GLfloat __glBuildAntiAliasIndex(__GLfloat idx,
				         __GLfloat antiAliasPercent);

/************************************************************************/

/*
** Dithering implementation stuff.
*/
#define	__GL_DITHER_BITS 4
#define	__GL_DITHER_PRECISION (1 << __GL_DITHER_BITS)
#define	__GL_DITHER_INDEX(x,y) (((x) & 3) + (((y) & 3) << 2))

extern GLbyte __glDitherTable[16];

#endif /* __glrender_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\span.h ===
/******************************Module*Header*******************************\
* Module Name: span.h
*
* This include file is used to generate various flavors of textured and
* shaded spans, or scanlines.
*
* 14-Oct-1994   mikeke  Combined span_t.h and span_s.h to share common
*                       code.  Speeded things up a little.  Had a little
*                       fun with the C preprocessor.
* 11-April-1994 Otto Berkes [ottob] Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#undef STRING1
#undef STRING2
#undef STRING3
#undef STRING4

#if GENERIC
    void FASTCALL __fastGenSpan
#else
    #if ZBUFFER
        #define STRING1 __fastGenMask
    #else
        #define STRING1 __fastGen
    #endif

    #if TEXTURE
        #if SHADE
            #define STRING2 Tex
        #else
            #define STRING2 TexDecal
        #endif
    #elif RGBMODE
        #define STRING2 RGB
    #else
        #define STRING2 CI
    #endif

    #if DITHER
        #define STRING3 STRCAT2(COLORFORMAT, Dith)
    #else
        #define STRING3 COLORFORMAT
    #endif

    #define STRING4 Span

    void FASTCALL STRCAT4(STRING1, STRING2, STRING3, STRING4)
#endif
(__GLGENcontext *gengc)
{
    #if (SHADE) || !(RGBMODE) || (TEXTURE && DITHER)
        ULONG rAccum;
        LONG rDelta;

        #if RGBMODE
            ULONG gAccum;
            ULONG bAccum;
            LONG gDelta;
            LONG bDelta;
        #endif
    #endif

    #if TEXTURE
        LONG sAccum;
        LONG tAccum;
        LONG sDelta;
        LONG tDelta;
        ULONG tShift;
        ULONG sMask, tMask;
    #endif

    ULONG rShift;
    ULONG rBits;
    #if RGBMODE
        ULONG gShift;
        ULONG gBits;
        ULONG bShift;
        ULONG bBits;
    #endif

    BYTE *pPix;
    BYTE *texAddr;
    BYTE *texBits;
    LONG count;
    LONG totalCount;

    #if DITHER
        PDWORD pdither;
        #if (BPP == 24) || (GENERIC)
            DWORD iDither;
        #endif
    #endif

    #if (BPP == 8) || (GENERIC)
        BYTE *pXlat;
    #elif (!RGBMODE)
        ULONG *pXlat;
    #endif

    #if GENERIC
        DWORD flags = GENACCEL(gengc).flags;
        DWORD bpp = GENACCEL(gengc).bpp;
    #endif

    #if GENERIC
        if (flags & GEN_TEXTURE)
    #endif
    #if TEXTURE
        {
            __GLtexture *tex = ((__GLcontext *)gengc)->texture.currentTexture;

            sMask = GENACCEL(gengc).sMask;
            tMask = GENACCEL(gengc).tMask;
            tShift = GENACCEL(gengc).tShift;
            sDelta = GENACCEL(gengc).spanDelta.s;
            tDelta = GENACCEL(gengc).spanDelta.t;
            sAccum = GENACCEL(gengc).spanValue.s;
            tAccum = GENACCEL(gengc).spanValue.t;
            #if !(SHADE) && !(DITHER) && ((BPP == 8) || (BPP == 16))
                texAddr = (BYTE *)GENACCEL(gengc).texImageReplace;
            #else
                texAddr = (BYTE *)GENACCEL(gengc).texImage;
            #endif
        }
    #endif

    // get color deltas and accumulators

    #ifndef RSHIFT
        rShift = gengc->gsurf.pfd.cRedShift;
	rBits = gengc->gsurf.pfd.cRedBits;
        #if RGBMODE
            gShift = gengc->gsurf.pfd.cGreenShift;
	    gBits = gengc->gsurf.pfd.cGreenBits;
            bShift = gengc->gsurf.pfd.cBlueShift;
	    bBits = gengc->gsurf.pfd.cBlueBits;
        #endif
    #endif

    #if (GENERIC)
        if (!(flags & GEN_SHADE) && 
            (flags & (GEN_TEXTURE | GEN_DITHER)) == (GEN_TEXTURE | GEN_DITHER)) {
            rAccum = (GENACCEL(gengc).spanValue.r >> rBits) & 0xff00;
            gAccum = (GENACCEL(gengc).spanValue.g >> gBits) & 0xff00;
            bAccum = (GENACCEL(gengc).spanValue.b >> bBits) & 0xff00;
            rDelta = 0;
            gDelta = 0;
            bDelta = 0;
        } else {
            rAccum = GENACCEL(gengc).spanValue.r;
            gAccum = GENACCEL(gengc).spanValue.g;
            bAccum = GENACCEL(gengc).spanValue.b;
            rDelta = GENACCEL(gengc).spanDelta.r;
            gDelta = GENACCEL(gengc).spanDelta.g;
            bDelta = GENACCEL(gengc).spanDelta.b;
        }
    #else

        #if !(SHADE) && (TEXTURE) && (DITHER)
            #ifndef RSHIFT
                rAccum = (GENACCEL(gengc).spanValue.r >> rBits) & 0xff00;
                gAccum = (GENACCEL(gengc).spanValue.g >> gBits) & 0xff00;
                bAccum = (GENACCEL(gengc).spanValue.b >> bBits) & 0xff00;
            #else
                rAccum = (GENACCEL(gengc).spanValue.r >> RBITS) & 0xff00;
                gAccum = (GENACCEL(gengc).spanValue.g >> GBITS) & 0xff00;
                bAccum = (GENACCEL(gengc).spanValue.b >> BBITS) & 0xff00;
            #endif
        #else
            #if (SHADE) || !(RGBMODE)
                rAccum = GENACCEL(gengc).spanValue.r;
                #if RGBMODE
                    gAccum = GENACCEL(gengc).spanValue.g;
                    bAccum = GENACCEL(gengc).spanValue.b;
                #endif
            #endif
        #endif

        #if (SHADE) || !(RGBMODE)
            rDelta = GENACCEL(gengc).spanDelta.r;
            #if RGBMODE
                gDelta = GENACCEL(gengc).spanDelta.g;
                bDelta = GENACCEL(gengc).spanDelta.b;
            #endif
        #endif
    #endif

    // get address of destination

    if (GENACCEL(gengc).flags & SURFACE_TYPE_DIB) {
        pPix = GENACCEL(gengc).pPix +
            gengc->gc.polygon.shader.frag.x * (BPP / 8);
    } else {
        pPix = gengc->ColorsBits;
    }

    // set up pointer to translation table as needed

    #if GENERIC
        if ((bpp != 8) && (!(flags & GEN_RGBMODE))) {
            pXlat = gengc->pajTranslateVector + sizeof(DWORD);
        }
    #else
        #if (BPP == 8)
            // No need to set up xlat vector
        #elif (!RGBMODE)
            pXlat = (ULONG *)(gengc->pajTranslateVector + sizeof(DWORD));
        #endif
    #endif

    #if GENERIC
        if (GENACCEL(gengc).flags & GEN_DITHER) {
            // LATER !!! mikeke
            // fix this so the destination is always aligned with the x value
            // !!! make sure this is correct in generic case
            // look at flat it assumes alignment
            //

            if (GENACCEL(gengc).flags & GEN_TEXTURE)
                pdither = ditherTexture;
            else
                pdither = ditherShade;

            pdither += (gengc->gc.polygon.shader.frag.y & 0x3) * 8;
            iDither = gengc->gc.polygon.shader.frag.x & 0x3;
        } else {
            // LATER !!! mikeke
            // add these outside of the loop

            if (!(GENACCEL(gengc).flags & GEN_TEXTURE)) {
                rAccum += 0x0800;
                gAccum += 0x0800;
                bAccum += 0x0800;
            }
            //pdither = 0;
        }
    #else
        #if DITHER
            // LATER !!! mikeke
            // fix this so the destination is always aligned with the x value
            // !!! make sure this is correct in generic case
            // look at flat it assumes alignment
            //

            #if (BPP == 24)
                pdither = (gengc->gc.polygon.shader.frag.y & 0x3) * 8
                    #if (TEXTURE)
                        + ditherTexture
                    #else
                        + ditherShade
                    #endif
                    ;
                iDither = gengc->gc.polygon.shader.frag.x & 0x3;
            #else
                pdither = (gengc->gc.polygon.shader.frag.y & 0x3) * 8
                    #if (TEXTURE)
                        + ditherTexture
                    #else
                        + ditherShade
                    #endif

                    + ((
                          (gengc->gc.polygon.shader.frag.x & 0x3)
                        - (((ULONG_PTR)pPix / (BPP / 8)) & 0x3)
                      ) & 0x3 );
            #endif
        #else
            // LATER !!! mikeke
            // add these outside of the loop
            #if !(RGBMODE)
                rAccum += 0x0800;
            #else //RGBMODE
                #if (TEXTURE) && !(GENERIC)
                #else //!TEXTURE
                    rAccum += 0x0800;
                    gAccum += 0x0800;
                    bAccum += 0x0800;
                #endif //TEXTURE
            #endif //RGBMODE
        #endif
    #endif

    #if GENERIC
        {
            ULONG *pMask;

            pMask = gengc->gc.polygon.shader.stipplePat;

            for (totalCount = gengc->gc.polygon.shader.length;
                    totalCount > 0; totalCount -= 32
                ) {
                ULONG maskTest;
                ULONG mask = *pMask++;

                if (mask == 0) {
                    #if (SHADE) || !(RGBMODE)
                        rAccum += (rDelta << 5);
                        #if RGBMODE
                            gAccum += (gDelta << 5);
                            bAccum += (bDelta << 5);
                        #endif
                    #endif

                    #if TEXTURE
                        sAccum += (sDelta << 5);
                        tAccum += (tDelta << 5);
                    #endif

                    //iDither = (iDither + 32) & 0x3;
                    pPix += (32 * (BPP / 8));
                } else {
                    maskTest = 0x80000000;

                    if ((count = totalCount) > 32)
                        count = 32;

                    for (; count; count--, maskTest >>= 1) {
                        if (mask & maskTest) {
                            #include "spangen.h"
                        }
                        #include "span3.h"
                    }
                }
            }
        }
    #elif ZBUFFER
        {
            GLuint zAccum = gengc->gc.polygon.shader.frag.z;
            GLint  zDelta = gengc->gc.polygon.shader.dzdx;
            PBYTE zbuf = (PBYTE)gengc->gc.polygon.shader.zbuf;

            if (GENACCEL(gengc).flags & GEN_LESS) {
                if (gengc->gc.modes.depthBits == 16) {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) < *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 2;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                } else {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( zAccum < *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 4;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                }
            } else {
                if (gengc->gc.modes.depthBits == 16) {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 2;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                } else {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 4;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                }
            }
        }
    #else
        for (count = gengc->gc.polygon.shader.length;;) {
            #include "span2.h"
            if (--count == 0)
                return;
            #include "span3.h"
        }
    #endif
}

#undef ditherVal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\spanci.h ===
/******************************Module*Header*******************************\
* Module Name: spansgen.h
*
* This file is included to generate a set of span functions for a certain
* pixel format and zbuffer format
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#undef  ZBUFFER
#define ZBUFFER 0

    #undef RGBMODE
    #define RGBMODE 1

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"

    #undef RGBMODE
    #define RGBMODE 0

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"
            #include "span.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"
            #include "span.h"

#undef  ZBUFFER
#define ZBUFFER 1

    #undef RGBMODE
    #define RGBMODE 1

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"

    #undef RGBMODE
    #define RGBMODE 0

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"
            #include "span.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"
            #include "span.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\spanset.h ===
/******************************Module*Header*******************************\
* Module Name: spanset.h
*
* This file is included to generate a set of span functions for a certain
* pixel format
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#undef RGBMODE
#define RGBMODE 1

#undef  ZBUFFER
#define ZBUFFER 0

    #undef TEXTURE
    #define TEXTURE 0
        #undef SHADE
        #define SHADE 1
        #include "span.h"

    #undef TEXTURE
    #define TEXTURE 1
            #undef SHADE
            #define SHADE 1
            #include "span.h"

            #undef SHADE
            #define SHADE 0
            #include "span.h"

#undef  ZBUFFER
#define ZBUFFER 1

    #undef TEXTURE
    #define TEXTURE 0
        #undef SHADE
        #define SHADE 1
        #include "span.h"

    #undef TEXTURE
    #define TEXTURE 1
            #undef SHADE
            #define SHADE 1
            #include "span.h"

            #undef SHADE
            #define SHADE 0
            #include "span.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\spangen.h ===
/******************************Module*Header*******************************\
* Module Name: spangen.h
*
* This code figures out the color for pixel and stores it
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

{
    DWORD r, g, b;
    DWORD color;
    ULONG ditherVal;

    if (flags & GEN_DITHER) {
        ditherVal = pdither[iDither];
    } else {
        if ((flags & (GEN_SHADE | GEN_TEXTURE | GEN_RGBMODE)) ==
            (GEN_SHADE | GEN_TEXTURE | GEN_RGBMODE)) {
            ditherVal = 0x08;
        } else {
            ditherVal = 0x0000;
        }
    }

    if (!(flags & GEN_RGBMODE)) {
        if (BPP == 8) {
            color = ((rAccum + ditherVal) >> 16) & 0xff;
        } else {
            color = ((PULONG)pXlat)[(((rAccum + ditherVal) >> 16) & 0xfff)];
        }
    } else {
        if (flags & GEN_TEXTURE) {
            texBits = (texAddr + ((sAccum & sMask) >> 14) +
                                  ((tAccum & tMask) >> tShift));

            if (flags & GEN_SHADE) {
                r = ((ULONG)(gbMulTable[(((rAccum >> rBits) & 0xff00) | texBits[2])] << rBits) + ditherVal) >> 8;
                g = ((ULONG)(gbMulTable[(((gAccum >> gBits) & 0xff00) | texBits[1])] << gBits) + ditherVal) >> 8;
                b = ((ULONG)(gbMulTable[(((bAccum >> bBits) & 0xff00) | texBits[0])] << bBits) + ditherVal) >> 8;
            } else {
                if (flags & GEN_DITHER) {
                    r = ((ULONG)(gbMulTable[(rAccum | texBits[2])] << rBits) + ditherVal) >> 8;
                    g = ((ULONG)(gbMulTable[(gAccum | texBits[1])] << gBits) + ditherVal) >> 8;
                    b = ((ULONG)(gbMulTable[(bAccum | texBits[0])] << bBits) + ditherVal) >> 8;
                } else {
                    r = (texBits[2] << rBits) >> 8;
                    g = (texBits[1] << gBits) >> 8;
                    b = (texBits[0] << bBits) >> 8;
                }
            }
        } else {
            r = (rAccum + ditherVal) >> 16;
            g = (gAccum + ditherVal) >> 16;
            b = (bAccum + ditherVal) >> 16;
        }
        color = (r << rShift) |
                (g << gShift) |
                (b << bShift);
    }

    if (BPP == 8) {
        *pPix = gengc->xlatPalette[color & 0xff];
#ifdef OLDWAY
        if ((flags & (GEN_TEXTURE | GEN_SHADE | GEN_DITHER)) ==
             GEN_TEXTURE) {
            *pPix = (BYTE)color;
        } else {
            *pPix = (BYTE)pXlat[color & 0xff];
        }
#endif
    } else if (BPP == 16) {
        *((WORD *)pPix) = (USHORT)color;
    } else if (BPP == 24) {
        *pPix = (BYTE)color;
        *(pPix + 1) = (BYTE)(color >> 8);
        *(pPix + 2) = (BYTE)(color >> 16);
    } else {
        *((DWORD *)pPix) = color;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\span_s.h ===
/******************************Module*Header*******************************\
* Module Name: span_s.h                                                    *
*                                                                          *
* This include file is used to generate various flavors of smooth-shaded   *
* spans, or scanlines.  The variations cover RGB/Color-indexed operation,  *
* dithering, and pixel-depth.  Not your typical include file.              *
*                                                                          *
* Created: 24-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

void

#if RGBMODE

#if DITHER

#if (BPP == 8)
__fastGenRGB8DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenRGB16DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenRGB24DithSmoothSpan(__GLGENcontext *gengc)
#else
__fastGenRGB32DithSmoothSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenRGB8SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenRGB16SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenRGB24SmoothSpan(__GLGENcontext *gengc)
#else
__fastGenRGB32SmoothSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

#else //!RGBMODE

#if DITHER

#if (BPP == 8)
__fastGenCI8DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenCI16DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenCI24DithSmoothSpan(__GLGENcontext *gengc)
#else
__fastGenCI32DithSmoothSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenCI8SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenCI16SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenCI24SmoothSpan(__GLGENcontext *gengc)
#else
__fastGenCI32SmoothSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

#endif //!RGBMODE

{
    ULONG rAccum;
#if RGBMODE
    ULONG gAccum;
    ULONG bAccum;
#endif
    LONG rDelta;
#if RGBMODE
    LONG gDelta;
    LONG bDelta;
#endif
    ULONG rShift;
#if RGBMODE
    ULONG gShift;
    ULONG bShift;
#endif
    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;
#if (BPP == 8)
    BYTE *pXlat;
#elif (!RGBMODE)
    ULONG *pXlat;
#endif
    ULONG *pMask;
#if DITHER
    ULONG ditherShift;
    ULONG ditherRow;
#endif
    LONG count;
    LONG totalCount;
    
    // get color deltas and accumulators

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);

    rDelta = pGenAccel->spanDelta.r;
#if RGBMODE
    gDelta = pGenAccel->spanDelta.g;
    bDelta = pGenAccel->spanDelta.b;
#endif

    // Try to accelerate color-invariant spans

    if (!(pGenAccel->flags & HAVE_STIPPLE) && 
        (gengc->gc.polygon.shader.length > 3)) {
        if (gengc->gc.polygon.shader.length < 16) {
#if RGBMODE
            if ((((rDelta & 0xffffff80) == 0) || ((-rDelta & 0xffffff80) == 0)) &&
                (((gDelta & 0xffffff80) == 0) || ((-gDelta & 0xffffff80) == 0)) &&
                (((bDelta & 0xffffff80) == 0) || ((-bDelta & 0xffffff80) == 0))) {
#else
            if (((rDelta & 0xffffff80) == 0) || ((-rDelta & 0xffffff80) == 0)) {
#endif
                (*pGenAccel->__fastFlatSpanFuncPtr)(gengc);
                return;
            }
        } else if (gengc->gc.polygon.shader.length < 32) {
#if RGBMODE
            if ((((rDelta & 0xffffffc0) == 0) || ((-rDelta & 0xffffffc0) == 0)) &&
                (((gDelta & 0xffffffc0) == 0) || ((-gDelta & 0xffffffc0) == 0)) &&
                (((bDelta & 0xffffffc0) == 0) || ((-bDelta & 0xffffffc0) == 0))) {
#else
            if (((rDelta & 0xffffffc0) == 0) || ((-rDelta & 0xffffffc0) == 0)) {
#endif
                (*pGenAccel->__fastFlatSpanFuncPtr)(gengc);
                return;
            }
        } else if (gengc->gc.polygon.shader.length < 64) {
#if RGBMODE
            if ((((rDelta & 0xffffffe0) == 0) || ((-rDelta & 0xffffffe0) == 0)) &&
                (((gDelta & 0xffffffe0) == 0) || ((-gDelta & 0xffffffe0) == 0)) &&
                (((bDelta & 0xffffffe0) == 0) || ((-bDelta & 0xffffffe0) == 0))) {
#else
            if (((rDelta & 0xffffffe0) == 0) || ((-rDelta & 0xffffffe0) == 0)) {
#endif
                (*pGenAccel->__fastFlatSpanFuncPtr)(gengc);
                return;
            }
        }
    }
    
    rAccum = pGenAccel->spanValue.r;
#if RGBMODE
    gAccum = pGenAccel->spanValue.g;
    bAccum = pGenAccel->spanValue.b;
#endif

    cfb = gengc->gc.polygon.shader.cfb;

    rShift = cfb->redShift;
#if RGBMODE
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;
#endif

    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        int xScr;
        int yScr;

        xScr = gengc->gc.polygon.shader.frag.x - 
               gengc->gc.constants.viewportXAdjust +
               cfb->buf.xOrigin;
        
        yScr = gengc->gc.polygon.shader.frag.y - 
               gengc->gc.constants.viewportYAdjust +
               cfb->buf.yOrigin;

        pPix = (BYTE *)cfb->buf.base + (yScr * cfb->buf.outerWidth) +
#if (BPP == 8)
               xScr;
#elif (BPP == 16)
               (xScr << 1);
#elif (BPP == 24)
               xScr + (xScr << 1);
#else
               (xScr << 2);
#endif //BPP
    } else
        pPix = gengc->ColorsBits;

    // set up pointer to translation table as needed

#if (BPP == 8)
    pXlat = gengc->pajTranslateVector;
#elif (!RGBMODE)
    pXlat = (ULONG *)(gengc->pajTranslateVector + sizeof(DWORD));
#endif

#if DITHER
    ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
    ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;
#endif

    pMask = gengc->gc.polygon.shader.stipplePat;
    if ((totalCount = count = gengc->gc.polygon.shader.length) > 32)
        count = 32;

    for (; totalCount > 0; totalCount -= 32) {
        ULONG mask;
        ULONG maskTest;
    
        if ((mask = *pMask++) == 0) {
#if RGBMODE
            rAccum += (rDelta << 5);
            gAccum += (gDelta << 5);
            bAccum += (bDelta << 5);
#else
            rAccum += (rDelta << 5);
#endif
            pPix += (32 * (BPP / 8));
            continue;
        }

        maskTest = 0x80000000;

        if ((count = totalCount) > 32)
            count = 32;

        for (; count; count--, maskTest >>= 1) {
            if (mask & maskTest) {
                DWORD color;
#if DITHER
                ULONG ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                ditherShift = (ditherShift + 8) & 0x18;
#else
#define ditherVal 0x0800
#endif

#if RGBMODE
                color = (((rAccum + ditherVal) >> 16) << rShift) |
                        (((gAccum + ditherVal) >> 16) << gShift) |
                        (((bAccum + ditherVal) >> 16) << bShift);
#if (BPP == 8)
// XXX the color value should *not* have to be masked!
                color = *(pXlat + (color & 0xff));
#endif

#else //!RGBMODE

// XXX nor should color-index values!

#if (BPP == 8)
		color = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xff));
#else
		color = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
#endif

#endif //!RGBMODE

#if (BPP == 8)
                *pPix = (BYTE)color;
#elif (BPP == 16)
                *((WORD *)pPix) = (USHORT)color;
#elif (BPP == 24)
                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                *((DWORD *)pPix) = color;
#endif //BPP

            }
#if RGBMODE
            rAccum += rDelta;
            gAccum += gDelta;
            bAccum += bDelta;
#else
            rAccum += rDelta;
#endif
            pPix += (BPP / 8);
        }
    }
}


#if !DITHER
#undef ditherVal
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\span_t.h ===
/******************************Module*Header*******************************\
* Module Name: span_t.h                                                    *
*                                                                          *
* This include file is used to generate various flavors of textured        *
* spans, or scanlines.  The variations cover only RGB operation,           *
* dithering, and pixel-depth.  Not your typical include file.              *
*                                                                          *
* Created: 11-April-1994                                                   *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/


void

#if DITHER

#if (BPP == 8)
__fastGenTex8DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24DithSmoothSpan(__GLGENcontext *gengc)
#else
__fastGenTex32DithSmoothSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenTex8SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24SmoothSpan(__GLGENcontext *gengc)
#else
__fastGenTex32SmoothSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

{
    ULONG rAccum;
    ULONG gAccum;
    ULONG bAccum;
    ULONG sAccum;
    ULONG tAccum;
    LONG rDelta;
    LONG gDelta;
    LONG bDelta;
    LONG sDelta;
    LONG tDelta;
    ULONG rShift;
    ULONG gShift;
    ULONG bShift;
    ULONG rtShift;
    ULONG gtShift;
    ULONG btShift;
    ULONG tShift;
    ULONG sMask, tMask;
    ULONG wLog2;
    ULONG hLog2;
    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;
    UCHAR *texAddr;
    USHORT *texBits;
#if DITHER
    ULONG ditherVal;
#endif
#if (BPP == 8)
    BYTE *pXlat;
#endif
    ULONG *pMask;
#if DITHER
    ULONG ditherShift;
    ULONG ditherRow;
#endif
    LONG count;
    LONG totalCount;
    __GLtexture *tex = ((__GLcontext *)gengc)->texture.currentTexture;

    wLog2 = tex->level[0].widthLog2;
    hLog2 = tex->level[0].heightLog2;
    sMask = (~(~0 << wLog2)) << 16;
    tMask = (~(~0 << hLog2)) << 16;
    tShift = 13 - wLog2;
    
    // get color deltas and accumulators

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);

    texAddr = (UCHAR *)pGenAccel->texImage;

    rDelta = pGenAccel->spanDelta.r;
    gDelta = pGenAccel->spanDelta.g;
    bDelta = pGenAccel->spanDelta.b;
    sDelta = pGenAccel->spanDelta.s;
    tDelta = pGenAccel->spanDelta.t;

    rAccum = pGenAccel->spanValue.r;
    gAccum = pGenAccel->spanValue.g;
    bAccum = pGenAccel->spanValue.b;
    sAccum = pGenAccel->spanValue.s;
    tAccum = pGenAccel->spanValue.t;


    cfb = gengc->gc.polygon.shader.cfb;

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;
#if DITHER
    rtShift = 8 + ((__GLcontext *)gengc)->modes.redBits;
    gtShift = 8 + ((__GLcontext *)gengc)->modes.greenBits;
    btShift = 8 + ((__GLcontext *)gengc)->modes.blueBits;
#else
    rtShift = 16 + ((__GLcontext *)gengc)->modes.redBits;
    gtShift = 16 + ((__GLcontext *)gengc)->modes.greenBits;
    btShift = 16 + ((__GLcontext *)gengc)->modes.blueBits;
#endif


    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        int xScr;
        int yScr;

        xScr = gengc->gc.polygon.shader.frag.x - 
               gengc->gc.constants.viewportXAdjust +
               cfb->buf.xOrigin;
        
        yScr = gengc->gc.polygon.shader.frag.y - 
               gengc->gc.constants.viewportYAdjust +
               cfb->buf.yOrigin;

        pPix = (BYTE *)cfb->buf.base + (yScr * cfb->buf.outerWidth) +
#if (BPP == 8)
               xScr;
#elif (BPP == 16)
               (xScr << 1);
#elif (BPP == 24)
               xScr + (xScr << 1);
#else
               (xScr << 2);
#endif //BPP
    } else
        pPix = gengc->ColorsBits;

    // set up pointer to translation table as needed

#if (BPP == 8)
    pXlat = gengc->pajTranslateVector;
#endif

#if DITHER
    ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
    ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;
#endif

    pMask = gengc->gc.polygon.shader.stipplePat;
    if ((totalCount = count = gengc->gc.polygon.shader.length) > 32)
        count = 32;

    for (; totalCount > 0; totalCount -= 32) {
        ULONG mask;
        ULONG maskTest;
    
        if ((mask = *pMask++) == 0) {
            rAccum += (rDelta << 5);
            gAccum += (gDelta << 5);
            bAccum += (bDelta << 5);
            sAccum += (sDelta << 5);
            tAccum += (tDelta << 5);

            pPix += (32 * (BPP / 8));
            continue;
        }

        maskTest = 0x80000000;

        if ((count = totalCount) > 32)
            count = 32;

        for (; count; count--, maskTest >>= 1) {
            if (mask & maskTest) {
                DWORD color;

                texBits = (USHORT *)(texAddr + ((sAccum & sMask) >> 13) + 
                                               ((tAccum & tMask) >> tShift));

#if DITHER
                ditherVal = (ditherRow >> ditherShift) & 0xff;

                ditherShift = (ditherShift + 8) & 0x18;

                color = 
                    ((((((ULONG)texBits[0] * (rAccum >> 8)) >> rtShift) + ditherVal) >> 8) << rShift) |
                    ((((((ULONG)texBits[1] * (gAccum >> 8)) >> gtShift) + ditherVal) >> 8) << gShift) |
                    ((((((ULONG)texBits[2] * (bAccum >> 8)) >> btShift) + ditherVal) >> 8) << bShift);
#else
                color = 
                    ((((ULONG)texBits[0] * (rAccum >> 8)) >> rtShift) << rShift) |
                    ((((ULONG)texBits[1] * (gAccum >> 8)) >> gtShift) << gShift) |
                    ((((ULONG)texBits[2] * (bAccum >> 8)) >> btShift) << bShift);
#endif


#if (BPP == 8)
// XXX the color value should *not* have to be masked!
                color = *(pXlat + (color & 0xff));
#endif

#if (BPP == 8)
                *pPix = (BYTE)color;
#elif (BPP == 16)
                *((WORD *)pPix) = (USHORT)color;
#elif (BPP == 24)
                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                *((DWORD *)pPix) = color;
#endif //BPP

            }
            rAccum += rDelta;
            gAccum += gDelta;
            bAccum += bDelta;
            sAccum += sDelta;
            tAccum += tDelta;

            pPix += (BPP / 8);
        }
    }
}



void

#if DITHER

#if (BPP == 8)
__fastGenTex8DithDecalSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16DithDecalSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24DithDecalSpan(__GLGENcontext *gengc)
#else
__fastGenTex32DithDecalSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenTex8DecalSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16DecalSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24DecalSpan(__GLGENcontext *gengc)
#else
__fastGenTex32DecalSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

{
    register ULONG sAccum;
    register ULONG tAccum;
    LONG sDelta;
    LONG tDelta;
    ULONG rShift;
    ULONG gShift;
    ULONG bShift;
    ULONG tShift;
    ULONG sMask, tMask;
    ULONG wLog2;
    ULONG hLog2;
    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;
    UCHAR *texAddr;
    USHORT *texBits;
#if DITHER
    ULONG ditherVal;
#endif
#if (BPP == 8)
    BYTE *pXlat;
#endif
    ULONG *pMask;
#if DITHER
    ULONG ditherShift;
    ULONG ditherRow;
#endif
    LONG count;
    LONG totalCount;
    __GLtexture *tex = ((__GLcontext *)gengc)->texture.currentTexture;

    wLog2 = tex->level[0].widthLog2;
    hLog2 = tex->level[0].heightLog2;
    sMask = (~(~0 << wLog2)) << 16;
    tMask = (~(~0 << hLog2)) << 16;
    tShift = 13 - wLog2;

    // get color deltas and accumulators

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);

    sDelta = pGenAccel->spanDelta.s;
    tDelta = pGenAccel->spanDelta.t;

    sAccum = pGenAccel->spanValue.s;
    tAccum = pGenAccel->spanValue.t;

    texAddr = (UCHAR *)pGenAccel->texImage;

    cfb = gengc->gc.polygon.shader.cfb;

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;

    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        int xScr;
        int yScr;

        xScr = gengc->gc.polygon.shader.frag.x - 
               gengc->gc.constants.viewportXAdjust +
               cfb->buf.xOrigin;
        
        yScr = gengc->gc.polygon.shader.frag.y - 
               gengc->gc.constants.viewportYAdjust +
               cfb->buf.yOrigin;

        pPix = (BYTE *)cfb->buf.base + (yScr * cfb->buf.outerWidth) +
#if (BPP == 8)
               xScr;
#elif (BPP == 16)
               (xScr << 1);
#elif (BPP == 24)
               xScr + (xScr << 1);
#else
               (xScr << 2);
#endif //BPP
    } else
        pPix = gengc->ColorsBits;

    // set up pointer to translation table as needed

#if (BPP == 8)
    pXlat = gengc->pajTranslateVector;
#endif

#if DITHER
    ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
    ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;
#endif

    pMask = gengc->gc.polygon.shader.stipplePat;
    if ((totalCount = count = gengc->gc.polygon.shader.length) > 32)
        count = 32;

    for (; totalCount > 0; totalCount -= 32) {
        ULONG mask;
        ULONG maskTest;
    
        if ((mask = *pMask++) == 0) {
            sAccum += (sDelta << 5);
            tAccum += (tDelta << 5);

            pPix += (32 * (BPP / 8));
            continue;
        }

        maskTest = 0x80000000;

        if ((count = totalCount) > 32)
            count = 32;

        for (; count; count--, maskTest >>= 1) {
            if (mask & maskTest) {
#if (DITHER) || (BPP >= 24)
                DWORD color;
#endif

                texBits = (USHORT *)(texAddr + ((sAccum & sMask) >> 13) + 
                                               ((tAccum & tMask) >> tShift));

#if DITHER
                ditherVal = ((ditherRow >> ditherShift) & 0xff);

                ditherShift = (ditherShift + 8) & 0x18;

                color = 
                    (((texBits[0] + ditherVal) >> 8) << rShift) |
                    (((texBits[1] + ditherVal) >> 8) << gShift) |
                    (((texBits[2] + ditherVal) >> 8) << bShift);

#if (BPP == 8)
// XXX the color value should *not* have to be masked!
                color = *(pXlat + (color & 0xff));
                *pPix = (BYTE)color;
#elif (BPP == 16)
                *((WORD *)pPix) = (USHORT)color;
#elif (BPP == 24)
                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                *((DWORD *)pPix) = color;
#endif //BPP

#else //!DITHER

#if (BPP == 8)
                *pPix = *((BYTE *)&texBits[3]);
#elif (BPP == 16)
                *((WORD *)pPix) = *((WORD *)&texBits[3]);
#elif (BPP == 24)
                color = 
                    ((texBits[0] >> 8) << rShift) |
                    ((texBits[1] >> 8) << gShift) |
                    ((texBits[2] >> 8) << bShift);

                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                color = 
                    ((texBits[0] >> 8) << rShift) |
                    ((texBits[1] >> 8) << gShift) |
                    ((texBits[2] >> 8) << bShift);

                *((DWORD *)pPix) = color;
#endif //BPP


#endif  //DITHER
            }
            sAccum += sDelta;
            tAccum += tDelta;

            pPix += (BPP / 8);
        }
    }
}


#if !DITHER
#undef ditherVal
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\span_f.h ===
/******************************Module*Header*******************************\
* Module Name: span_f.h                                                    *
*                                                                          *
* This include file is used to generate various flavors of flat-shaded     *
* spans, or scanlines.  The variations cover RGB/Color-indexed operation,  *
* dithering, and pixel-depth.  Not your typical include file.              *
*                                                                          *
* Created: 24-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#undef STRING1
#undef STRING2
#undef STRING3
#undef STRING4

#if ZBUFFER
    #define STRING1 __fastGenMask
#else
    #define STRING1 __fastGen
#endif

#if RGBMODE
    #define STRING2 RGB
#else
    #define STRING2 CI
#endif

#if DITHER
    #define STRING3 STRCAT2(BPP, Dith)
#else
    #define STRING3 BPP
#endif

#define STRING4 FlatSpan

#undef OLDTEXTURE
#define OLDTEXTURE 0

void FASTCALL STRCAT4(STRING1, STRING2, STRING3, STRING4)
(__GLGENcontext *gengc)
{
    ULONG rAccum;
    ULONG rShift;
    #if RGBMODE
        ULONG gAccum;
        ULONG bAccum;
        ULONG gShift;
        ULONG bShift;
    #endif

    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;

    #if (BPP == 8)
        BYTE *pXlat;
    #elif (!RGBMODE)
        ULONG *pXlat;
    #endif

    #if DITHER
        ULONG ditherShift;
        ULONG ditherRow;
        ULONG ditherVal;
    #endif

    LONG count, cDith;
    ULONG color1;

    #if DITHER
        #if (RGBMODE) || (BPP > 8)
            ULONG color2;
            ULONG color3;
            ULONG color4;
        #endif
    #elif (BPP == 24)
        ULONG color2;
        ULONG color3;
    #endif

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);
    cfb = gengc->gc.polygon.shader.cfb;

    // get color deltas and accumulators

    rAccum = pGenAccel->spanValue.r;
    rShift = cfb->redShift;
    #if RGBMODE
        gAccum = pGenAccel->spanValue.g;
        bAccum = pGenAccel->spanValue.b;
        gShift = cfb->greenShift;
        bShift = cfb->blueShift;
    #endif

    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        pPix = pGenAccel->pPix +
            gengc->gc.polygon.shader.frag.x * (BPP / 8);
    } else {
        pPix = gengc->ColorsBits;
    }

    // set up pointer to translation table as needed

    #if (BPP == 8)
        pXlat = gengc->pajTranslateVector;
    #elif (!RGBMODE)
        pXlat = (ULONG *)(gengc->pajTranslateVector + sizeof(DWORD));
    #endif

    cDith = (
         gengc->gc.polygon.shader.length >= 4
       ? 4
       : gengc->gc.polygon.shader.length);

    #if DITHER
        ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
        ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;

        #if RGBMODE
            ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
            color1 = (((rAccum + ditherVal) >> 16) << rShift) |
                     (((gAccum + ditherVal) >> 16) << gShift) |
                     (((bAccum + ditherVal) >> 16) << bShift);

            #if (BPP == 8)
                color1 = *(pXlat + (color1 & 0xff));
            #endif

            if (--cDith) {
                ditherShift = (ditherShift + 8) & 0x18;
                ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
                color2 = (((rAccum + ditherVal) >> 16) << rShift) |
                         (((gAccum + ditherVal) >> 16) << gShift) |
                         (((bAccum + ditherVal) >> 16) << bShift);

                #if (BPP == 8)
                    color1 |= (*(pXlat + (color2 & 0xff))) << 8;
                #endif

                if (--cDith) {
                    ditherShift = (ditherShift + 8) & 0x18;
                    ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
                    color3 = (((rAccum + ditherVal) >> 16) << rShift) |
                             (((gAccum + ditherVal) >> 16) << gShift) |
                             (((bAccum + ditherVal) >> 16) << bShift);

                    #if (BPP == 8)
                        color1 |= (*(pXlat + (color3 & 0xff))) << 16;
                    #endif

                    if (--cDith) {
                        ditherShift = (ditherShift + 8) & 0x18;
                        ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
                        color4 = (((rAccum + ditherVal) >> 16) << rShift) |
                                 (((gAccum + ditherVal) >> 16) << gShift) |
                                 (((bAccum + ditherVal) >> 16) << bShift);
                        #if (BPP == 8)
                            color1 |= (*(pXlat + (color4 & 0xff))) << 24;
                        #endif
                    }
                }
            }
        #else //!RGBMODE
            ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

            #if (BPP == 8)
                color1 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xff));
            #else
                color1 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
            #endif

            if (--cDith) {
                ditherShift = (ditherShift + 8) & 0x18;
                ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                #if (BPP == 8)
                    color1 |= (*(pXlat + (((rAccum + ditherVal) >> 16) & 0xff)) << 8);
                #else
                    color2 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
                #endif

                if (--cDith) {
                    ditherShift = (ditherShift + 8) & 0x18;
                    ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                    #if (BPP == 8)
                        color1 |= (*(pXlat + (((rAccum + ditherVal) >> 16) & 0xff)) << 16);
                    #else
                        color3= *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
                    #endif

                    if (--cDith) {
                        ditherShift = (ditherShift + 8) & 0x18;
                        ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                        #if (BPP == 8)
                            color1 |= (*(pXlat + (((rAccum + ditherVal) >> 16) & 0xff)) << 24);
                        #else
                            color4 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
                        #endif
                    }
                }
            }
        #endif //!RGBMODE
    #else //!DITHER
        #if RGBMODE
            color1 = (((rAccum + 0x0800) >> 16) << rShift) |
                     (((gAccum + 0x0800) >> 16) << gShift) |
                     (((bAccum + 0x0800) >> 16) << bShift);

            #if (BPP == 8)
                color1 = *(pXlat + (color1 & 0xff));
            #endif

            #if (BPP == 16)
                color1 = color1 | (color1 << 16);
            #elif (BPP == 24)
                color2 = color1 >> 8;
                color3 = color1 >> 16;
            #endif
        #else //!RGBMODE
            #if (BPP == 8)
                color1 = *(pXlat + (((rAccum + 0x0800) >> 16) & 0xff));
            #else
                color1 = *(pXlat + (((rAccum + 0x0800) >> 16) & 0xfff));
            #endif

            #if (BPP == 16)
                color1 = color1 | (color1 << 16);
            #elif (BPP == 24)
                color2 = color1 >> 8;
                color3 = color1 >> 16;
            #endif
        #endif //!RGBMODE
    #endif //!DITHER

    #if (ZBUFFER)
        if (pGenAccel->flags & GEN_FASTZBUFFER) {
            GLuint zAccum = gengc->gc.polygon.shader.frag.z;
            GLint  zDelta = gengc->gc.polygon.shader.dzdx;
            PBYTE zbuf = (PBYTE)gengc->gc.polygon.shader.zbuf;
            count = gengc->gc.polygon.shader.length;

            if (gengc->gc.modes.depthBits == 16) {
                #if DITHER
                    for (;;) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color1;
                                            *(pPix + 1) = (BYTE)(color1 >> 8);
                                            *(pPix + 2) = (BYTE)(color1 >> 16);
                            #else
                                            *((DWORD *)pPix) = color1;
                            #endif
                        }

                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 8);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color2;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color2;
                                            *(pPix + 1) = (BYTE)(color2 >> 8);
                                            *(pPix + 2) = (BYTE)(color2 >> 16);
                            #else
                                            *((DWORD *)pPix) = color2;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 16);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color3;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color3;
                                            *(pPix + 1) = (BYTE)(color3 >> 8);
                                            *(pPix + 2) = (BYTE)(color3 >> 16);
                            #else
                                            *((DWORD *)pPix) = color3;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 24);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color4;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color4;
                                            *(pPix + 1) = (BYTE)(color4 >> 8);
                                            *(pPix + 2) = (BYTE)(color4 >> 16);
                            #else
                                            *((DWORD *)pPix) = color4;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                    }
                #else //!DITHER
                    for (; count; count--) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            #else
                                 *((DWORD *)pPix) = color1;
                            #endif //BPP
                        }
                        zAccum += zDelta;
                        zbuf +=2 ;
                        pPix += (BPP / 8);
                    }
                #endif //!DITHER
            } else {
                #if DITHER
                    for (;;) {
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color1;
                                            *(pPix + 1) = (BYTE)(color1 >> 8);
                                            *(pPix + 2) = (BYTE)(color1 >> 16);
                            #else
                                            *((DWORD *)pPix) = color1;
                            #endif
                        }

                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zbuf+=4;
                        zAccum += zDelta;
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 8);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color2;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color2;
                                            *(pPix + 1) = (BYTE)(color2 >> 8);
                                            *(pPix + 2) = (BYTE)(color2 >> 16);
                            #else
                                            *((DWORD *)pPix) = color2;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zbuf+=4;
                        zAccum += zDelta;
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 16);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color3;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color3;
                                            *(pPix + 1) = (BYTE)(color3 >> 8);
                                            *(pPix + 2) = (BYTE)(color3 >> 16);
                            #else
                                            *((DWORD *)pPix) = color3;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zbuf+=4;
                        zAccum += zDelta;
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 24);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color4;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color4;
                                            *(pPix + 1) = (BYTE)(color4 >> 8);
                                            *(pPix + 2) = (BYTE)(color4 >> 16);
                            #else
                                            *((DWORD *)pPix) = color4;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;
                        zAccum += zDelta;
                        zbuf+=4;
                    }
                #else //!DITHER
                    for (; count; count--) {
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            #else
                                 *((DWORD *)pPix) = color1;
                            #endif //BPP
                        }
                        zbuf+=4;
                        zAccum += zDelta;
                        pPix += (BPP / 8);
                    }
                #endif //!DITHER
            }
        } else { // !FASTZBUFFER
            LONG totalCount;
            ULONG *pMask = gengc->gc.polygon.shader.stipplePat;

            for (totalCount = gengc->gc.polygon.shader.length; totalCount > 0; totalCount -= 32) {
                ULONG mask;
                ULONG maskTest;

                if ((mask = *pMask++) == 0) {
                    pPix += (32 * (BPP / 8));
                    continue;
                }

                maskTest = 0x80000000;

                if ((count = totalCount) > 32)
                    count = 32;

                #if DITHER
                    for (;;) {
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color1;
                                            *(pPix + 1) = (BYTE)(color1 >> 8);
                                            *(pPix + 2) = (BYTE)(color1 >> 16);
                            #else
                                            *((DWORD *)pPix) = color1;
                            #endif
                        }

                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        maskTest >>= 1;
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 8);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color2;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color2;
                                            *(pPix + 1) = (BYTE)(color2 >> 8);
                                            *(pPix + 2) = (BYTE)(color2 >> 16);
                            #else
                                            *((DWORD *)pPix) = color2;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        maskTest >>= 1;
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 16);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color3;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color3;
                                            *(pPix + 1) = (BYTE)(color3 >> 8);
                                            *(pPix + 2) = (BYTE)(color3 >> 16);
                            #else
                                            *((DWORD *)pPix) = color3;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        maskTest >>= 1;
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 24);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color4;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color4;
                                            *(pPix + 1) = (BYTE)(color4 >> 8);
                                            *(pPix + 2) = (BYTE)(color4 >> 16);
                            #else
                                            *((DWORD *)pPix) = color4;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;
                        #if ZBUFFER
                            maskTest >>= 1;
                        #else
                            zAccum += zDelta;
                            zbuf++;
                        #endif
                    }
                #else //!DITHER
                    #if (BPP == 8)
                        if (mask == 0xffffffff) {
                            RtlFillMemory(pPix, count, color1);
                            pPix += (32 * (BPP / 8));
                            continue;
                        }
                    #elif (BPP == 16)
                        if (mask == 0xffffffff) {
                            LONG ddCount;

                            if ((ULONG_PTR)pPix & 0x2) {                 // get odd-start pixel
                                *((WORD *)pPix)++ = (WORD)color1;
                                if (--count <= 0)
                                    return;
                            }

                            if (ddCount = (count & (~1)) << 1) {    // fill DWORDs
                                RtlFillMemoryUlong(pPix, ddCount, color1);
                                pPix += ddCount;
                            }

                            if (count & 1)                          // get odd-end pixel
                                *((WORD *)pPix)++ = (WORD)color1;

                            continue;
                        }
                    #elif (BPP == 24)
                        if (mask == 0xffffffff) {
                            ULONG colorShr = color1 >> 8;
                            LONG i;

                            for (i = 0; i < count; i++, pPix += 3) {
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            }
                            continue;
                        }
                    #elif (BPP == 32)
                        if (mask == 0xffffffff) {
                            RtlFillMemoryUlong(pPix, count << 2, color1);
                            pPix += (32 * (BPP / 8));
                            continue;
                        }
                    #endif //BPP

                    for (; count; count--) {
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            #else
                                 *((DWORD *)pPix) = color1;
                            #endif //BPP
                        }
                        maskTest >>= 1;
                        pPix += (BPP / 8);
                    }
                #endif //!DITHER
            }
        }
    #else // !ZBUFFER
        {
            LONG totalCount = gengc->gc.polygon.shader.length;
            #if DITHER
                #if (BPP == 8)
                    LONG i;

                    if (totalCount < 7) {
                        *pPix++ = (BYTE)color1;
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)(color1 >> 8);
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)(color1 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)(color1 >> 24);
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)color1;
                        if (--totalCount <= 0)
                            return;
                        *pPix = (BYTE)(color1 >> 8);
                        return;
                    }

                    if (i = (LONG)((ULONG_PTR)pPix & 0x3)) {
                        i = ditherShift = (4 - i);

                        totalCount -= i;

                        if (i--) {
                            *pPix++ = (BYTE)color1;
                            if (i--) {
                                *pPix++ = (BYTE)(color1 >> 8);
                                if (i--) {
                                    *pPix++ = (BYTE)(color1 >> 16);
                                }
                            }
                        }

                        // re-align the dither colors for DWORD boundaries

                        ditherShift <<= 3;

                        color1 = (color1 >> ditherShift) |
                                 (color1 << (32 - ditherShift));
                    }

                    RtlFillMemoryUlong(pPix, totalCount, color1);
                    pPix += (totalCount & 0xfffffffc);

                    i = totalCount & 0x3;

                    if (i--) {
                        *pPix++ = (BYTE)color1;
                        if (i--) {
                            *pPix++ = (BYTE)(color1 >> 8);
                            if (i--) {
                                *pPix++ = (BYTE)(color1 >> 16);
                            }
                        }
                    }

                    return;

                #elif (BPP == 16)
                    ULONG colorA, colorB;
                    LONG i;

                    if (totalCount < 3) {
                        *((WORD *)pPix)++ = (WORD)color1;
                        if (--totalCount <= 0)
                            return;
                        *((WORD *)pPix)++ = (WORD)color2;
                        return;
                    }

                    if ((ULONG_PTR)pPix & 0x2) {
                        totalCount--;

                        *((WORD *)pPix)++ = (WORD)color1;

                        colorA = color2 | (color3 << 16);
                        colorB = color4 | (color1 << 16);
                    } else {
                        colorA = color1 | (color2 << 16);
                        colorB = color3 | (color4 << 16);
                    }

                    for (i = (totalCount >> 1);;) {
                        *((DWORD *)pPix)++ = colorA;
                        if (--i <= 0) {
                            if (totalCount & 1)
                                *((WORD *)pPix) = (WORD)colorB;
                            return;
                        }
                        *((DWORD *)pPix)++ = colorB;
                        if (--i <= 0) {
                            if (totalCount & 1)
                                *((WORD *)pPix) = (WORD)colorA;
                            return;
                        }
                    }

                #elif (BPP == 24)
                    for (;;pPix += 12) {
                        *pPix = (BYTE)color1;
                        *(pPix + 1) = (BYTE)(color1 >> 8);
                        *(pPix + 2) = (BYTE)(color1 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *(pPix + 3) = (BYTE)color2;
                        *(pPix + 4) = (BYTE)(color2 >> 8);
                        *(pPix + 5) = (BYTE)(color2 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *(pPix + 6) = (BYTE)color3;
                        *(pPix + 7) = (BYTE)(color3 >> 8);
                        *(pPix + 8) = (BYTE)(color3 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *(pPix + 9) = (BYTE)color4;
                        *(pPix + 10) = (BYTE)(color4 >> 8);
                        *(pPix + 11) = (BYTE)(color4 >> 16);
                        if (--totalCount <= 0)
                            return;
                    }
                #elif (BPP == 32)
                    for (;;pPix += 16) {
                        *((DWORD *)pPix) = color1;
                        if (--totalCount <= 0)
                            return;
                        *((DWORD *)(pPix + 4)) = color2;
                        if (--totalCount <= 0)
                            return;
                        *((DWORD *)(pPix + 8)) = color3;
                        if (--totalCount <= 0)
                            return;
                        *((DWORD *)(pPix + 12)) = color4;
                        if (--totalCount <= 0)
                            return;
                    }
                #endif //BPP
            #else //!DITHER
                #if (BPP == 8)
                    RtlFillMemory(pPix, totalCount, color1);
                    return;
                #elif (BPP == 16)
                    if ((ULONG_PTR)pPix & 0x2) {                    // get odd-start pixel
                        *((WORD *)pPix)++ = (WORD)color1;
                        if (--totalCount <= 0)
                            return;
                    }
            	    if (count = (totalCount & (~1)) << 1)
                        RtlFillMemoryUlong(pPix, count, color1);
                    if (totalCount & 1)                         // get odd-end pixel
                        *((WORD *)(pPix + count)) = (WORD)color1;
                    return;
                #elif (BPP == 24)
                    LONG i;

                    for (i = 0; i < totalCount; i++, pPix += 3) {
                        *pPix = (BYTE)color1;
                        *(pPix + 1) = (BYTE)(color2);
                        *(pPix + 2) = (BYTE)(color3);
                    }
                    return;
                #elif (BPP == 32)
                    RtlFillMemoryUlong(pPix, totalCount << 2, color1);
                    return;
                #endif //BPP
            #endif //!DITHER
        }
    #endif // !ZBUFFER
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\srvp.h ===
/******************************Module*Header*******************************\
* Module Name: srvp.h
*
* System routines shared through the back end
*
* Created: 28-Jun-1995 17:36:00
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _srvp_
#define _srvp_

typedef struct _XLIST *PXLIST;
typedef struct _XLIST {
    PXLIST pnext;
    int s, e;
} XLIST;

typedef struct _YLIST *PYLIST;
typedef struct _YLIST {
    PYLIST pnext;
    PXLIST pxlist;
    int s, e;
} YLIST;

typedef struct _RECTLIST *PRECTLIST;
typedef struct _RECTLIST {
    PYLIST pylist;
    PVOID buffers;
} RECTLIST;

BOOL  APIENTRY wglPixelVisible(LONG, LONG);
ULONG APIENTRY wglSpanVisible(LONG, LONG, ULONG, LONG *, LONG **);

VOID  APIENTRY wglCopyBits(__GLGENcontext *, GLGENwindow *, HBITMAP, LONG, LONG, ULONG, BOOL);
VOID  APIENTRY wglCopyBits2(HDC, GLGENwindow *, __GLGENcontext *, LONG, LONG, ULONG, BOOL);
VOID  APIENTRY wglCopyBuf(HDC, HDC, LONG, LONG, ULONG, ULONG);
VOID  APIENTRY wglCopyBufRECTLIST(HDC, HDC, LONG, LONG, ULONG, ULONG, PRECTLIST);
VOID  APIENTRY wglFillRect(__GLGENcontext *, GLGENwindow *, PRECTL, ULONG);
VOID  APIENTRY wglCopyBuf2(HDC, GLGENwindow *, HBITMAP, LONG, LONG, ULONG, ULONG);

ULONG APIENTRY wglGetClipRects(GLGENwindow *, RECTL *);
#ifdef _CLIENTSIDE_
BOOL APIENTRY wglGetClipList(GLGENwindow *);
#endif

COLORREF wglTranslateColor(COLORREF crColor,
                           HDC hdc,
                           __GLGENcontext *gengc,
                           PIXELFORMATDESCRIPTOR *ppfd);

VOID  APIENTRY wglCleanupWindow(GLGENwindow *);

BOOL  APIENTRY wglCopyTranslateVector(__GLGENcontext *gengc, BYTE *, ULONG);

ULONG APIENTRY wglPaletteChanged(__GLGENcontext *gengc,
                                 GLGENwindow *pwnd);
ULONG APIENTRY wglPaletteSize(__GLGENcontext *gengc);
BOOL  APIENTRY wglComputeIndexedColors(__GLGENcontext *gengc, ULONG *, ULONG);
BOOL  APIENTRY wglValidPixelFormat(HDC, int, DWORD,
                                   LPDIRECTDRAWSURFACE, DDSURFACEDESC *);

/* Returned by wglSpanVisible */
#define WGL_SPAN_NONE       0
#define WGL_SPAN_ALL        1
#define WGL_SPAN_PARTIAL    2

int  WINAPI wglGetPixelFormat(HDC hdc);
BOOL WINAPI wglSetPixelFormat(HDC hdc, int ipfd,
                              CONST PIXELFORMATDESCRIPTOR *ppfd);
int  WINAPI wglChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd);
int  WINAPI wglDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                   LPPIXELFORMATDESCRIPTOR ppfd);
BOOL WINAPI wglSwapBuffers(HDC hdc);

void UpdateWindowInfo(__GLGENcontext *gengc);
void HandlePaletteChanges( __GLGENcontext *gengc, GLGENwindow *pwnd );

UINT APIENTRY wglGetSystemPaletteEntries(HDC hdc, UINT iStartIndex,
                                         UINT nEntries, LPPALETTEENTRY lppe);

#endif // _srvp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\texspan.h ===
/******************************Module*Header*******************************\
* Module Name: texspan.h
*
* Main header file for textured spans.
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

typedef LONG FIXED16;


#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)

#if (REPLACE || FAST_REPLACE)

    #define RRIGHTSHIFTADJ  (16 - (RSHIFT + RBITS))
    #define GRIGHTSHIFTADJ  (16 - (GSHIFT + GBITS))
    #define BRIGHTSHIFTADJ  (16 - (BSHIFT + BBITS))

#else

    #define RRIGHTSHIFTADJ  (16 - (RSHIFT))
    #define GRIGHTSHIFTADJ  (16 - (GSHIFT))
    #define BRIGHTSHIFTADJ  (16 - (BSHIFT))

#endif

#define S_SHIFT_PAL	16
#define T_SHIFT_PAL	6
#define TMASK_SUBDIV    GENACCEL(gengc).tMaskSubDiv
#define TSHIFT_SUBDIV   GENACCEL(gengc).tShiftSubDiv


#if (FAST_REPLACE)
    #define TEX_PALETTE         GENACCEL(gengc).texImageReplace
    #if (PALETTE_ONLY)
        #define TEX_IMAGE       GENACCEL(gengc).texImage
    #else
        #define TEX_IMAGE       GENACCEL(gengc).texImageReplace
    #endif
    #if (PALETTE_ONLY)
        #define S_SHIFT S_SHIFT_PAL
        #define T_SHIFT 6
    #elif (BPP == 8)
        #define S_SHIFT 16
        #define T_SHIFT 6
    #else
        #define S_SHIFT 15
        #define T_SHIFT 5
    #endif
#else
    #if (PALETTE_ONLY)
        #define S_SHIFT S_SHIFT_PAL
        #define T_SHIFT 6
    #else
        #define S_SHIFT 14
        #define T_SHIFT 4
    #endif

    #define TEX_IMAGE       GENACCEL(gengc).texImage
    #define TEX_PALETTE     GENACCEL(gengc).texPalette
#endif


#define ALPHA_MODULATE  \
    aDisplay = (ULONG)(gbMulTable[((aAccum >> 8) & 0xff00) | texBits[3]]) << 8;

#define ALPHA_NOMODULATE  \
    aDisplay = ((ULONG)texBits[3] << 8);

#define ALPHA_READ_8 \
{\
    ULONG pix = (ULONG)gengc->pajInvTranslateVector[*pPix];\
    ULONG alphaVal = (0xff00 - aDisplay);\
\
    rDisplay = gbMulTable[((pix & RMASK) << (GBITS + BBITS)) | alphaVal];\
    gDisplay = gbMulTable[((pix & GMASK) << (BBITS)) | alphaVal];\
    bDisplay = gbMulTable[(pix & BMASK) | alphaVal];\
}


#define ALPHA_READ_16 \
{\
    ULONG pix = *((USHORT *)pPix);\
    ULONG alphaVal = (0xff00 - aDisplay);\
\
    rDisplay = gbMulTable[((pix & RMASK) >> (RSHIFT - (8 - RBITS))) | alphaVal];\
    gDisplay = gbMulTable[((pix & GMASK) >> (GSHIFT - (8 - GBITS))) | alphaVal];\
    bDisplay = gbMulTable[((pix & BMASK) << (8 - BBITS)) | alphaVal];\
}


#define ALPHA_READ_32 \
{\
    ULONG alphaVal = (0xff00 - aDisplay);\
\
    rDisplay = gbMulTable[pPix[2] | alphaVal];\
    gDisplay = gbMulTable[pPix[1] | alphaVal];\
    bDisplay = gbMulTable[pPix[0] | alphaVal];\
}

#if (BPP == 8)
    #define ALPHA_READ  ALPHA_READ_8
#elif (BPP == 16)
    #define ALPHA_READ  ALPHA_READ_16
#else
    #define ALPHA_READ  ALPHA_READ_32
#endif

#undef STRING1
#undef STRING2
#undef STRING3
#undef STRING4

#if FAST_REPLACE
    #if PALETTE_ONLY
        #define STRING1 __fastFastPerspPalReplace
    #else
        #define STRING1 __fastFastPerspReplace
    #endif
#elif REPLACE
    #if (PALETTE_ONLY)
        #define STRING1 __fastPerspPalReplace
    #else
        #define STRING1 __fastPerspReplace
    #endif
#elif FLAT_SHADING
    #define STRING1 __fastPerspFlat
#else
    #define STRING1 __fastPerspSmooth
#endif

#if ALPHA
    #define STRING2 Alpha
#endif


#if ZBUFFER
    #if (ZCMP_L)
        #define STRING3 Zlt
    #else
        #define STRING3 Zle
    #endif
#endif

#if (BPP == 8)
    #define STRING4 332
#elif (BPP == 16)
    #if (GBITS == 5)
        #define STRING4 555
    #else
        #define STRING4 565
    #endif
#else
    #define STRING4 888
#endif

#ifdef STRING2

    #ifdef STRING3
        void FASTCALL STRCAT4(STRING1, STRING2, STRING3, STRING4)
    #else
        void FASTCALL STRCAT3(STRING1, STRING2, STRING4)
    #endif

#else

    #ifdef STRING3
        void FASTCALL STRCAT3(STRING1, STRING3, STRING4)
    #else
        void FASTCALL STRCAT2(STRING1, STRING4)
    #endif

#endif


(__GLGENcontext *gengc)
{
    __GLfloat qwInv;
    ULONG count;
    LONG subDivCount;
    FIXED16 sAccum;
    FIXED16 tAccum;
    __GLfloat qwAccum;
    FIXED16 subDs, subDt;
    FIXED16 sResult, tResult;
    FIXED16 sResultNew, tResultNew;
    BYTE *pPix;
    BYTE *texAddr;
    BYTE *texBits;
#if ALPHA
    ULONG rDisplay, gDisplay, bDisplay, aDisplay;
#endif
#if (FLAT_SHADING || SMOOTH_SHADING)
    PDWORD pdither;
    FIXED16 rAccum, gAccum, bAccum;
    #if (ALPHA)
        FIXED16 aAccum;
    #endif
#endif

#if (BPP == 32)
    ULONG pixAdj;
    #if (FLAT_SHADING || SMOOTH_SHADING)
        ULONG ditherVal;
    #endif
#endif

#if PALETTE_ENABLED
    BOOL bPalette = (GENACCEL(gengc).texPalette != NULL);
#endif
    BOOL bOrtho = (GENACCEL(gengc).flags & GEN_TEXTURE_ORTHO);

    if (!bOrtho) {
        if (CASTINT(gengc->gc.polygon.shader.frag.qw) <= 0)
            gengc->gc.polygon.shader.frag.qw = (__GLfloat)1.0;
        __GL_FLOAT_BEGIN_DIVIDE(__glOne, gengc->gc.polygon.shader.frag.qw,
                                &qwInv);
    }

    subDivCount = 7;
    sAccum = GENACCEL(gengc).spanValue.s;
    tAccum = GENACCEL(gengc).spanValue.t;
    qwAccum = gengc->gc.polygon.shader.frag.qw;
#if (FLAT_SHADING)
    rAccum = ((GENACCEL(gengc).spanValue.r >> RBITS) & 0xff00);
    gAccum = ((GENACCEL(gengc).spanValue.g >> GBITS) & 0xff00);
    bAccum = ((GENACCEL(gengc).spanValue.b >> BBITS) & 0xff00);
    #if (ALPHA)
        aAccum = GENACCEL(gengc).spanValue.a;
    #endif
#elif (SMOOTH_SHADING)
    rAccum = GENACCEL(gengc).spanValue.r;
    gAccum = GENACCEL(gengc).spanValue.g;
    bAccum = GENACCEL(gengc).spanValue.b;
    #if ALPHA
        aAccum = GENACCEL(gengc).spanValue.a;
    #endif
#endif
#if ((BPP == 32) && (FLAT_SHADING || SMOOTH_SHADING))
    ditherVal = ditherShade[0];
#endif

    if (!bOrtho) {
        __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
        sResult = FTOL((__GLfloat)sAccum * qwInv);
        tResult = ((FTOL((__GLfloat)tAccum * qwInv)) >> TSHIFT_SUBDIV) & ~7;
        qwAccum += GENACCEL(gengc).qwStepX;
        if (CASTINT(qwAccum) <= 0)
            qwAccum = (__GLfloat)1.0;
        __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, qwAccum, qwInv);
    } else {
        sResult = sAccum;
        tResult = (tAccum >> TSHIFT_SUBDIV) & ~7;
    }
    sAccum += GENACCEL(gengc).sStepX;
    tAccum += GENACCEL(gengc).tStepX;

    if (GENACCEL(gengc).flags & SURFACE_TYPE_DIB) {
        #if (BPP != 32)
            pPix = GENACCEL(gengc).pPix +
                gengc->gc.polygon.shader.frag.x * (BPP / 8);
        #else
            if (GENACCEL(gengc).bpp == 32) {
                pPix = GENACCEL(gengc).pPix +
                    gengc->gc.polygon.shader.frag.x * 4;
                pixAdj = 4;
            } else {
                pPix = GENACCEL(gengc).pPix +
                    gengc->gc.polygon.shader.frag.x * 3;
                pixAdj = 3;
            }
        #endif
    } else {
        pPix = gengc->ColorsBits;    
        #if (BPP == 32)
            pixAdj = GENACCEL(gengc).xMultiplier;
        #endif
    }

#if (FLAT_SHADING || SMOOTH_SHADING)
    #if (BPP != 32)
        pdither = (gengc->gc.polygon.shader.frag.y & 0x3) * 8 + ditherShade +
                  (((gengc->gc.polygon.shader.frag.x & 0x3) -
                   (((ULONG_PTR)pPix / (BPP / 8)) & 0x3)) & 0x3);
    #endif
#endif

    if (!bOrtho) {
        __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
        sResultNew = FTOL((__GLfloat)sAccum * qwInv);
        tResultNew = ((FTOL((__GLfloat)tAccum * qwInv)) >> TSHIFT_SUBDIV) & ~7;
        qwAccum += GENACCEL(gengc).qwStepX;
        if (CASTINT(qwAccum) <= 0)
            qwAccum = (__GLfloat)1.0;
        __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, qwAccum, qwInv);
    } else {
        sResultNew = sAccum;
        tResultNew = (tAccum >> TSHIFT_SUBDIV) & ~7;
    }

    sAccum += GENACCEL(gengc).sStepX;
    tAccum += GENACCEL(gengc).tStepX;

    subDs = (sResultNew - sResult) >> 3;
    subDt = (tResultNew - tResult) >> 3;

#if ZBUFFER
    {
        GLuint zAccum = gengc->gc.polygon.shader.frag.z;
        GLint  zDelta = gengc->gc.polygon.shader.dzdx;
        PBYTE zbuf = (PBYTE)gengc->gc.polygon.shader.zbuf;

        if (GENACCEL(gengc).flags & GEN_LESS) {
            for (count = gengc->gc.polygon.shader.length;;) {
                if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) < *((__GLz16Value*)zbuf) ) {
                    *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    #include "texspan2.h"
                }
                if (--count == 0)
                    goto exit;
                zbuf += 2;
                zAccum += zDelta;
                #include "texspan3.h"
            }
        } else {
            for (count = gengc->gc.polygon.shader.length;;) {
                if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                    *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    #include "texspan2.h"
                }
                if (--count == 0)
                    goto exit;
                zbuf += 2;
                zAccum += zDelta;
                #include "texspan3.h"
            }
        }
    }
#else
    for (count = gengc->gc.polygon.shader.length;;) {
        #include "texspan2.h"
        if (--count == 0)
            goto exit;
        #include "texspan3.h"
    }
#endif

exit:
    if (!bOrtho) {
        __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
    }
}

#undef RMASK
#undef GMASK
#undef BMASK
#undef RRIGHTSHIFTADJ
#undef GRIGHTSHIFTADJ
#undef BRIGHTSHIFTADJ
#undef ALPHA_MODULATE
#undef ALPHA_NOMODULATE
#undef ALPHA_READ_8
#undef ALPHA_READ_16
#undef ALPHA_READ_32
#undef ALPHA_READ

#undef S_SHIFT
#undef T_SHIFT
#undef TMASK_SUBDIV
#undef TSHIFT_SUBDIV
#undef TEX_IMAGE
#undef TEX_PALETTE
#undef S_SHIFT_PAL
#undef T_SHIFT_PAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\texspan3.h ===
/******************************Module*Header*******************************\
* Module Name: texspan3.h
*
* Advance the required interpolants, and do the subdivision if needed.
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

    #if (SMOOTH_SHADING)
        rAccum += GENACCEL(gengc).spanDelta.r;
        gAccum += GENACCEL(gengc).spanDelta.g;
        bAccum += GENACCEL(gengc).spanDelta.b;
        #if (ALPHA)
            aAccum += GENACCEL(gengc).spanDelta.a;
        #endif
    #endif

    #if (BPP != 32)
        pPix += (BPP / 8);
    #else
        pPix += pixAdj;
    #endif

    if (--subDivCount < 0) {
        if (!bOrtho) {
            __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
            sResult = sResultNew;
            tResult = tResultNew;
            sResultNew = FTOL((__GLfloat)sAccum * qwInv);
            tResultNew = ((FTOL((__GLfloat)tAccum * qwInv)) >> TSHIFT_SUBDIV) & ~7;
            qwAccum += GENACCEL(gengc).qwStepX;
            if (CASTINT(qwAccum) <= 0)
                qwAccum -= GENACCEL(gengc).qwStepX;
            __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, qwAccum, qwInv);
        } else {
            sResult = sResultNew;
            tResult = tResultNew;
            sResultNew = sAccum;
            tResultNew = (tAccum >> TSHIFT_SUBDIV) & ~7;
        }
        sAccum += GENACCEL(gengc).sStepX;
        tAccum += GENACCEL(gengc).tStepX;

        subDs = (sResultNew - sResult) >> 3;
        subDt = (tResultNew - tResult) >> 3;

        subDivCount = 7;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\texspan2.h ===
/******************************Module*Header*******************************\
* Module Name: texspan2.h
*
* Calculate the textured pixel, and write the value to the framebuffer.
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

{
    DWORD r, g, b;

    #if (FLAT_SHADING || SMOOTH_SHADING)
        #if (BPP == 8)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix) & 0x3];
        #elif (BPP == 16)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix & 0x6) >> 1];
        #endif
    #endif

    #if PALETTE_ENABLED

        if (bPalette) {
            texBits = ((BYTE *)TEX_IMAGE + 
                       ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT_PAL) +
                       ((tResult & TMASK_SUBDIV) >> T_SHIFT_PAL));

            texBits = (BYTE *)((ULONG *)TEX_PALETTE + *texBits);

        } else {
            texBits = ((BYTE *)TEX_IMAGE + 
                       ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT) +
                       ((tResult & TMASK_SUBDIV) >> T_SHIFT));
        }

    #elif PALETTE_ONLY

        texBits = ((BYTE *)TEX_IMAGE + 
                   ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT_PAL) +
                   ((tResult & TMASK_SUBDIV) >> T_SHIFT_PAL));

        texBits = (BYTE *)((ULONG *)TEX_PALETTE + *texBits);

    #else
        texBits = ((BYTE *)TEX_IMAGE + 
                   ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT) +
                   ((tResult & TMASK_SUBDIV) >> T_SHIFT));
    #endif

    sResult += subDs;
    tResult += subDt;


    #if (FAST_REPLACE)
    {
        #if (ALPHA)
            if (texBits[3] != 0) {
                if (texBits[3] != 0xff) {

                    texBits = (texBits - GENACCEL(gengc).texImageReplace +
                               (BYTE *)GENACCEL(gengc).texPalette);

                    ALPHA_NOMODULATE	
                    ALPHA_READ

                    #if (BPP == 32)
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) << -RRIGHTSHIFTADJ) & RMASK;
                    #else
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) >> RRIGHTSHIFTADJ) & RMASK;
                    #endif
                    g = (((gbMulTable[aDisplay | texBits[1]] + gDisplay) << 8) >> GRIGHTSHIFTADJ) & GMASK;
                    b = (((gbMulTable[aDisplay | texBits[0]] + bDisplay) << 8) >> BRIGHTSHIFTADJ) & BMASK;

                    #if (BPP == 8)
                       *pPix = gengc->xlatPalette[r | g | b];
                    #elif (BPP == 16)
                       *((USHORT *)pPix) = (USHORT)(r | g | b);
                    #else
                        *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                        pPix[2] = (BYTE)(r >> 16);
                    #endif

                } else {
                    #if (BPP > 16)
                        ULONG texel = *((ULONG *)texBits);
                    #endif

                    #if (BPP == 8)
                        *pPix = *texBits;
                    #elif (BPP == 16)
                        *((USHORT *)pPix) = *((USHORT *)texBits);
                    #else
                        *((USHORT UNALIGNED *)pPix) = (USHORT)texel;
                        pPix[2] = (BYTE)(texel >> 16);
                    #endif      
                }
            }
        #else
            {
                #if (BPP > 16)
                    ULONG texel = *((ULONG *)texBits);
                #endif

                #if (BPP == 8)
                    *pPix = *texBits;
                #elif (BPP == 16)
                    *((USHORT *)pPix) = *((USHORT *)texBits);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)texel;
                    pPix[2] = (BYTE)(texel >> 16);
                #endif      
            }
        #endif
    }

    #elif (REPLACE)
    {
        #if (ALPHA)
            if (texBits[3] != 0) {
                if (texBits[3] != 0xff) {

                    ALPHA_NOMODULATE	
                    ALPHA_READ

                    #if (BPP == 32)
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) << -RRIGHTSHIFTADJ) & RMASK;
                    #else
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) >> RRIGHTSHIFTADJ) & RMASK;
                    #endif
                    g = (((gbMulTable[aDisplay | texBits[1]] + gDisplay) << 8) >> GRIGHTSHIFTADJ) & GMASK;
                    b = (((gbMulTable[aDisplay | texBits[0]] + bDisplay) << 8) >> BRIGHTSHIFTADJ) & BMASK;
                } else {
                    #if (BPP == 32)
                        r = ((texBits[2] << 8) << -RRIGHTSHIFTADJ) & RMASK;
                    #else
                        r = ((texBits[2] << 8) >> RRIGHTSHIFTADJ) & RMASK;
                    #endif
                    g = ((texBits[1] << 8) >> GRIGHTSHIFTADJ) & GMASK;
                    b = ((texBits[0] << 8) >> BRIGHTSHIFTADJ) & BMASK;
                }

                #if (BPP == 8)
                   *pPix = gengc->xlatPalette[r | g | b];
                #elif (BPP == 16)
                   *((USHORT *)pPix) = (USHORT)(r | g | b);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                    pPix[2] = (BYTE)(r >> 16);
                #endif

            }
        #else

            #if (BPP != 32)
                r = ((texBits[2] << 8) >> RRIGHTSHIFTADJ) & RMASK;
                g = ((texBits[1] << 8) >> GRIGHTSHIFTADJ) & GMASK;
                b = ((texBits[0] << 8) >> BRIGHTSHIFTADJ) & BMASK;
            #endif

            #if (BPP == 8)
               *pPix = gengc->xlatPalette[r | g | b];
            #elif (BPP == 16)
               *((USHORT *)pPix) = (USHORT)(r | g | b);
            #else
                *((USHORT UNALIGNED *)pPix) = *((USHORT *)texBits);
                pPix[2] = (BYTE)texBits[2];
            #endif

        #endif
    }

    #elif (FLAT_SHADING)
    {
        #if (ALPHA)
            if (texBits[3] != 0) {

                ALPHA_MODULATE;
                ALPHA_READ;

                #if (BPP == 32)
                    r = ((((gbMulTable[aDisplay | gbMulTable[rAccum | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
                #else
                    r = ((((gbMulTable[aDisplay | gbMulTable[rAccum | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
                #endif
                g = ((((gbMulTable[aDisplay | gbMulTable[gAccum | texBits[1]]] + gDisplay) << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
                b = ((((gbMulTable[aDisplay | gbMulTable[bAccum | texBits[0]]] + bDisplay) << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

                #if (BPP == 8)
                    *pPix = gengc->xlatPalette[r | g | b];
                #elif (BPP == 16)
                    *((USHORT *)pPix) = (USHORT)(r | g | b);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                    pPix[2] = (BYTE)(r >> 16);
                #endif
            }

        #else

            #if (BPP == 32)
                r = (((gbMulTable[rAccum | texBits[2]] << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
            #else
                r = (((gbMulTable[rAccum | texBits[2]] << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
            #endif
            g = (((gbMulTable[gAccum | texBits[1]] << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
            b = (((gbMulTable[bAccum | texBits[0]] << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

            #if (BPP == 8)
                *pPix = gengc->xlatPalette[r | g | b];
            #elif (BPP == 16)
                *((USHORT *)pPix) = (USHORT)(r | g | b);
            #else
                *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                pPix[2] = (BYTE)(r >> 16);
            #endif

        #endif

    }

    #else       // SMOOTH_SHADING
    {
        #if (ALPHA)
            if (texBits[3] != 0) {

                ALPHA_MODULATE;
                ALPHA_READ;

                #if (BPP == 32)
                    r = ((((gbMulTable[aDisplay | gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
                #else
                    r = ((((gbMulTable[aDisplay | gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
                #endif
                g = ((((gbMulTable[aDisplay | gbMulTable[((gAccum >> GBITS) & 0xff00) | texBits[1]]] + gDisplay) << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
                b = ((((gbMulTable[aDisplay | gbMulTable[((bAccum >> BBITS) & 0xff00) | texBits[0]]] + bDisplay) << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

                #if (BPP == 8)
                    *pPix = gengc->xlatPalette[r | g | b];
                #elif (BPP == 16)
                    *((USHORT *)pPix) = (USHORT)(r | g | b);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                    pPix[2] = (BYTE)(r >> 16);
                #endif
            }
    
        #else

            #if (BPP == 32)
                r = (((gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]] << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
            #else
                r = (((gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]] << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
            #endif
            g = (((gbMulTable[((gAccum >> GBITS) & 0xff00) | texBits[1]] << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
            b = (((gbMulTable[((bAccum >> BBITS) & 0xff00) | texBits[0]] << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

            #if (BPP == 8)
                *pPix = gengc->xlatPalette[r | g | b];
            #elif (BPP == 16)
                *((USHORT *)pPix) = (USHORT)(r | g | b);
            #else
                *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                pPix[2] = (BYTE)(r >> 16);
            #endif
        #endif
    }
    #endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\texspans.h ===
/******************************Module*Header*******************************\
* Module Name: texspans.h
*
* This file is included to generate the set of perspective-corrected
* span functions with combinations of pixel formats and other attributes
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#undef  ZBUFFER
#define ZBUFFER 0
#undef ZCMP_L
#define ZCMP_L 0
#undef ALPHA
#define ALPHA 0

#if (!SKIP_FAST_REPLACE)

#include "texspan.h"


#undef  ZBUFFER
#define ZBUFFER 1

#include "texspan.h"

#undef ZCMP_L
#define ZCMP_L 1

#include "texspan.h"

#endif // SKIP_FAST_REPLACE

#if !(FAST_REPLACE && !PALETTE_ONLY)

#undef  ZBUFFER
#define ZBUFFER 0
#undef ZCMP_L
#define ZCMP_L 0
#undef ALPHA
#define ALPHA 1

#include "texspan.h"

#undef  ZBUFFER
#define ZBUFFER 1

#include "texspan.h"

#undef ZCMP_L
#define ZCMP_L 1

#include "texspan.h"

#endif	// FAST_REPLACE and not PALETTE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\vertex.h ===
#ifndef __glvertex_h_
#define __glvertex_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.16 $
** $Date: 1993/12/08 06:29:30 $
*/
#include "types.h"
#include "parray.h"

/*
** Vertex structure.  Each vertex contains enough state to properly
** render the active primitive.  It is used by the front-end geometry
** and back-end rasterization pipelines.
**
** NOTE: Same as the POLYDATA structure!
**
** To minimize storage requirement, some front-end storage (e.g. obj and normal)
** is shared with back-end storage.
*/
struct __GLvertexRec {
    /*
    ** Keep this data structure aligned: have all vectors start on
    ** 4-word boundary, and sizeof this struct should be kept at
    ** a multiple of 4 words. Also helps to bunch together most
    ** frequently used items, helps cache.
    */

    /*
    ** Bits are set in this indicating which fields of the vertex are
    ** valid.  This field is shared with the front-end flags field!
    */
    GLuint has;

    /*
    ** Moved up here to keep GLcoords aligned.
    */
    __GLcolor *color;

    /*
    ** Clipping code mask.  One bit is set for each clipping plane that
    ** the vertex is out on.
    */
    GLuint clipCode;

    /*
    ** Fog value for the vertex.  This is only filled when doing cheap
    ** fogging.
    */
    __GLfloat fog;

    /*
    ** Projected eye coodinate.  This field is filled in when the users
    ** eye coordinate has been multiplied by the projection matrix.
    */

    __GLcoord clip;

    /*
    ** Window coordinate. This field is filled in when the eye coordinate
    ** is converted to a drawing surface relative "window" coordinate.
    ** NOTE: the window.w coordinate contains 1/clip.w.
    */
    __GLcoord window;

    __GLcoord texture;

    __GLcoord normal;

    /*
    ** Colors.  colors[0] is the "front" color, colors[1] is the "back" color.
    ** The color pointer points to which color is current for this
    ** vertex.  Verticies can have more than one color when two sided
    ** lighting is enabled. (note color pointer moved up top).
    */
    __GLcolor colors[2];

    /*
    ** Eye coordinate. This field is filled in when the object coordinate
    ** has been multiplied by the model-view matrix.  If no eye coordinate
    ** was needed then this field contains undefined values.
    */
    __GLfloat eyeX;
    __GLfloat eyeY;
    __GLfloat eyeZ;
    union
    {
        __GLfloat eyeW;         //Used by the phong-shader
        __GLcolor *lastColor;   // eyeW is not used in rasterization
    };

    /*
    ** On Win64 the POLYARRAY structure is larger than the __GLvertex
    ** structure since the former contains several pointers which are
    ** 8 bytes on the 64-bit system. Therefore, this structure must
    ** be padded to be the same size as the POLYARRAY structure.
    **
    ** N.B. Since the structure must be the same size as the POLYDATA
    **      structure that structure must also be padded.
    **
    */

#if defined(_WIN64)

    PVOID Filler[7];

#endif

};

/* Indicies for colors[] array in vertex */
#define __GL_FRONTFACE		0
#define __GL_BACKFACE		1


/* Bits for clipCode (NOTE: MAX of 26 user clip planes) */
#define __GL_CLIP_LEFT		    0x00000001
#define __GL_CLIP_RIGHT		    0x00000002
#define __GL_CLIP_BOTTOM	    0x00000004
#define __GL_CLIP_TOP		    0x00000008
#define __GL_CLIP_NEAR		    0x00000010
#define __GL_CLIP_FAR		    0x00000020
#define __GL_FRUSTUM_CLIP_MASK	0x0000003f
#define __GL_CLIP_USER0		    0x00000040

/* Bits for has */
#ifdef NT
// These has bits are shared with POLYDATA flags!
#define __GL_HAS_EDGEFLAG_BOUNDARY  0x00000001 // must be 1, same as
					       // POLYDATA_EDGEFLAG_BOUNDARY
#define __GL_HAS_FOG	            0x00004000 // same as POLYDATA_FOG_VALID
#define __GL_HAS_FIXEDPT            0x00008000
#else
#define	__GL_HAS_FRONT_COLOR	0x0001
#define __GL_HAS_BACK_COLOR	0x0002
	    /* for poly clipping */
#define __GL_HAS_BOTH		(__GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR)
#define	__GL_HAS_TEXTURE	0x0004
#define __GL_HAS_NORMAL		0x0008
#define __GL_HAS_EYE		0x0010
#define __GL_HAS_CLIP		0x0020
#define __GL_HAS_FOG		0x0040
#define __GL_HAS_LIGHTING	(__GL_HAS_EYE | __GL_HAS_NORMAL)
#endif /* NT */

#ifdef NT

/*
** Poly array needs
*/
// front/back color needs for lit polygons or unlit primitives
#define PANEEDS_FRONT_COLOR         0x0001
#define PANEEDS_BACK_COLOR          0x0002
// normal need
#define PANEEDS_NORMAL              0x0004

#define PANEEDS_NORMAL_FOR_TEXTURE              0x0100
#define PANEEDS_RASTERPOS_NORMAL_FOR_TEXTURE    0x0200

// normal need for RasterPos
#define PANEEDS_RASTERPOS_NORMAL    0x0008
// texture coord need, set by RasterPos too!
#define PANEEDS_TEXCOORD            0x0010
// edge flag need
#define PANEEDS_EDGEFLAG            0x0020
// set in selection mode but cleared by RasterPos!
#define PANEEDS_CLIP_ONLY           0x0040
// skip lighting calculation optimiztaion
#define PANEEDS_SKIP_LIGHTING       0x0080
#endif

/*
** NOTE: may need to change the raster pos handler if more bits are added
** to the above constants
*/

/************************************************************************/

/*
** Total number of clipping planes supported by this gl.  This includes
** the frustum's six clipping planes.
*/
/*#define	__GL_TOTAL_CLIP_PLANES	(6 + __GL_NUMBER_OF_CLIP_PLANES)*/

#ifndef NT
/*
** Number of static verticies in the context.  Polygon's larger than
** this number will be decomposed.
*/
#define __GL_NVBUF 100
#endif

#define NEW_PARTIAL_PRIM // New processing of partial primitives

#ifdef NEW_PARTIAL_PRIM

// Structure to save shared vertices of partial primitives
//
typedef struct _SAVEREGION
{
    POLYDATA        pd;
    __GLmatChange   front, back;
} SAVEREGION;

#endif // NEW_PARTIAL_PRIM

/*
** State for managing the vertex machinery.
*/
typedef struct __GLvertexMachineRec {
#ifdef NT
    /*
    ** Saved vertices of a decomposed polygon.
    */
#ifdef NEW_PARTIAL_PRIM
    SAVEREGION regSaved;        // Saved data for partial line loop
#else
    POLYDATA pdSaved[3];
#endif // NEW_PARTIAL_PRIM

    /*
    ** The polyarray vertex buffer.  The last vertex is reserved by the
    ** polyarray code.
    ** Note that pdBuf has (pdBufSize + 1) entries.  Only pdBufSize
    ** entries are available for use.  The last entry is reserved by
    ** polyarray code.
    */
    POLYDATA *pdBuf;
    GLuint   pdBufSize;
    GLuint   pdBufSizeBytes;
#else
    /*
    ** Vertex pointers. v0 always points to the next slot in vbuf to
    ** be filled in when a new vertex arrives.  v1, v2 and v3 are
    ** used by the per-primitive vertex handlers.
    */
    __GLvertex *v0;
    __GLvertex *v1;
    __GLvertex *v2;
    __GLvertex *v3;
    __GLvertex vbuf[__GL_NVBUF];
#endif

    /*
    ** Provoking vertex.  For flat shaded primitives the triangle
    ** renderer needs to know which vertex provoked the primitive to
    ** properly assign the color during scan conversion.  This is kept
    ** around as its a big pain to remember which vertex was provoking
    ** during clipping (and to keep its parameters right).
    */
    __GLvertex *provoking;

#ifdef NT
    /*
    ** Poly array needs
    */
    GLuint paNeeds;
#else
    /*
    ** needs is a bit field that keeps track of what kind of information
    ** is needed in the verticies.  See the vertex->has bits define for
    ** the definition of the bits used here.
    **
    ** frontNeeds is what the front faces need, and backNeeds is what
    ** the back faces need.
    */
    GLuint needs;

    /*
    ** frontNeeds and backNeeds are the needs
    */
    GLuint faceNeeds[2];

    /*
    ** materialNeeds is a bit field indicating what kind of information is
    ** needed in the vertices if the material is going to change.
    */
    GLuint materialNeeds;
#endif
} __GLvertexMachine;

/************************************************************************/

void APIPRIVATE __glim_NoXFVertex2fv(const GLfloat v[2]);
void APIPRIVATE __glim_NoXFVertex3fv(const GLfloat v[3]);
void APIPRIVATE __glim_NoXFVertex4fv(const GLfloat v[4]);

#endif /* __glvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\types.h ===
#ifndef __gltypes_h_
#define __gltypes_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Low level data types.
*/

#ifdef NT
#include <nt.h>
#include <windef.h>
#include <wingdi.h>

#include <ddraw.h>
#include <mcdesc.h>

#endif

#include <GL/gl.h>

/*
** Typedefs.  These are forward declarations to internal data structures.
** This eases the burden of dealing with circular references among
** the header files.
*/
typedef GLshort __GLaccumCellElement;
typedef GLubyte __GLstencilCell;
typedef struct __GLaccumBufferRec __GLaccumBuffer;
typedef struct __GLalphaBufferRec __GLalphaBuffer;
typedef struct __GLattributeRec __GLattribute;
typedef struct __GLbitmapRec __GLbitmap;
typedef struct __GLbufferRec __GLbuffer;
typedef struct __GLcolorBufferRec __GLcolorBuffer;
typedef struct __GLcontextRec __GLcontext;
typedef struct __GLdepthBufferRec __GLdepthBuffer;
typedef struct __GLfogMachineRec __GLfogMachine;
typedef struct __GLfragmentRec __GLfragment;
typedef struct __GLlightModelStateRec __GLlightModelState;
typedef struct __GLlightSourceMachineRec __GLlightSourceMachine;
typedef struct __GLlineOptionsRec __GLlineOptions;
typedef struct __GLmaterialMachineRec __GLmaterialMachine;
typedef struct __GLmaterialStateRec __GLmaterialState;
typedef struct __GLmatrixRec __GLmatrix;
typedef struct __GLpixelSpanInfoRec __GLpixelSpanInfo;
typedef struct __GLprocTableRec __GLprocTable;
typedef struct __GLscreenRec __GLscreen;
typedef struct __GLshadeRec __GLshade;
typedef struct __GLphongShadeRec __GLphongShade;
typedef struct __GLstencilBufferRec __GLstencilBuffer;
typedef struct __GLstippleRec __GLstipple;
typedef struct __GLtransformRec __GLtransform;
typedef struct __GLvertexRec __GLvertex;
typedef struct __GLtexelRec __GLtexel;
typedef struct __GLdlistOpRec __GLdlistOp;

typedef struct __GLcontextModesRec __GLcontextModes;
typedef struct __GLnamesArrayRec __GLnamesArray;

typedef struct __GLGENbuffersRec __GLGENbuffers;

/*
** Type of z value used by the software z buffering code.
** NOTE: must be unsigned
*/
#ifdef NT
#define FIX_SCALEFACT           __glVal65536
#define FIX_SHIFT               16

typedef unsigned short __GLz16Value;
#define Z16_SCALE	        FIX_SCALEFACT
#define Z16_SHIFT	        FIX_SHIFT
#endif
typedef unsigned int __GLzValue;

/************************************************************************/

/*
** Implementation data types.  The implementation is designed to run in
** single precision or double precision mode, all of which is controlled
** by an ifdef and the following typedef's.
*/
#ifdef	__GL_DOUBLE
typedef double __GLfloat;
#else
typedef float __GLfloat;
#endif

/************************************************************************/

/*
** Coordinate structure.  Coordinates contain x, y, z and w.
*/
typedef struct __GLcoordRec {
    __GLfloat x, y, z, w;
} __GLcoord;

/*
** Color structure.  Colors are composed of red, green, blue and alpha.
*/
typedef struct __GLcolorRec {
    __GLfloat r, g, b, a;
} __GLcolor;

typedef struct __GLicolorRec {
    GLint r, g, b, a;
} __GLicolor;

typedef struct __GLuicolorRec {
    GLuint r, g, b, a;
} __GLuicolor;

/*
** Generic no-operation procedure.  Used when function pointers need to
** be stubbed out when an operation is disabled.
*/
extern void FASTCALL __glNop(void);
extern void FASTCALL __glNopGC(__GLcontext*);
extern GLboolean FASTCALL __glNopGCBOOL(__GLcontext*);
extern void FASTCALL __glNopGCFRAG(__GLcontext*, __GLfragment *, __GLtexel *);
extern void FASTCALL __glNopGCCOLOR(__GLcontext*, __GLcolor *, __GLtexel *);
extern void FASTCALL __glNopLight(__GLcontext*, GLint, __GLvertex*);
extern void FASTCALL __glNopGCListOp(__GLcontext *, __GLdlistOp*);
extern void FASTCALL __glNopExtract(struct __GLmipMapLevelRec *level, struct __GLtextureRec *tex,
                                    GLint row, GLint col, __GLtexel *result);

#endif /* __gltypes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <ddraw.h>

#include <math.h>

#include <glp.h>
#include <context.h>
#include <global.h>
#include <pixel.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\zippy.h ===
/******************************Module*Header*******************************\
* Module Name: zippy.h
*
* included by zippy.c
*
* 28-Oct-1994 mikeke    Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

void FASTCALL
#if ZBUFFER
    __ZippyFSTZ
#else
    #if TEXTURE
        #if SHADE
            __ZippyFSTRGBTex
        #else
            __ZippyFSTTex
        #endif
    #else
        #if SHADE
            __ZippyFSTRGB
        #else
            __ZippyFSTCI
        #endif
    #endif
#endif

(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    int scansize;

    //
    // this function assumes all this stuff
    //
    ASSERTOPENGL((gc->drawBuffer->buf.flags & DIB_FORMAT) != 0,
		 "Zippy target must have DIB format\n");
    ASSERTOPENGL((gc->drawBuffer->buf.flags & NO_CLIP) != 0,
                 "Zippy doesn't support per-pixel clipping\n");
    ASSERTOPENGL(gc->state.raster.drawBuffer != GL_FRONT_AND_BACK,
                 "Zippy only handles one draw buffer\n");
    ASSERTOPENGL(gc->transform.reasonableViewport,
                 "Zippy requires reasonableViewport\n");
    ASSERTOPENGL(gc->transform.clipY0 <= iyBottom,
                 "Zippy requires unclipped area\n");
    ASSERTOPENGL(iyTop <= gc->transform.clipY1,
                 "Zippy requires unclipped area\n");

    //
    // setup zbuffer
    //

    #if (ZBUFFER)
        if( gc->modes.depthBits == 32 ) {
            gc->polygon.shader.zbuf = (__GLzValue *)
                ((GLubyte *)gc->polygon.shader.zbuf+
                 (gc->polygon.shader.ixLeft << 2));
        } else {
            gc->polygon.shader.zbuf = (__GLzValue *)
                ((GLubyte *)gc->polygon.shader.zbuf+
                 (gc->polygon.shader.ixLeft << 1));
        }
    #endif

    //
    // render the spans
    //

    scansize = gc->polygon.shader.cfb->buf.outerWidth;
    gc->polygon.shader.frag.x = gc->polygon.shader.ixLeft;

    for (gc->polygon.shader.frag.y = iyBottom; 
	 gc->polygon.shader.frag.y != iyTop;) {

	GLint spanWidth = gc->polygon.shader.ixRight - gc->polygon.shader.frag.x;

	if (spanWidth > 0) {
            gc->polygon.shader.length = spanWidth;

            (GENACCEL(gc).__fastSpanFuncPtr)((__GLGENcontext *)gc);
	}

        if ((++gc->polygon.shader.frag.y == iyTop) && 
            (gc->polygon.shader.modeFlags & __GL_SHADE_LAST_SUBTRI))
            return;

        GENACCEL(gc).pPix += scansize;

	gc->polygon.shader.ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (gc->polygon.shader.ixRightFrac < 0) {
	    /*
             * Carry/Borrow'd. Use large step
             */
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightBig;
	    gc->polygon.shader.ixRightFrac &= ~0x80000000;
	} else {
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightLittle;
	}

	gc->polygon.shader.ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (gc->polygon.shader.ixLeftFrac < 0) {
	    /*
             * Carry/Borrow'd.  Use large step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftBig;
	    gc->polygon.shader.ixLeftFrac &= ~0x80000000;

            #if SHADE
		GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rBig);
		GENACCEL(gc).spanValue.g += *((GLint *)&gc->polygon.shader.gBig);
		GENACCEL(gc).spanValue.b += *((GLint *)&gc->polygon.shader.bBig);
            #endif
            #if TEXTURE
                #if SHADE
    		GENACCEL(gc).spanValue.a += *((GLint *)&gc->polygon.shader.aBig);
                #endif
	        GENACCEL(gc).spanValue.s += *((GLint *)&gc->polygon.shader.sBig);
	        GENACCEL(gc).spanValue.t += *((GLint *)&gc->polygon.shader.tBig);
	        gc->polygon.shader.frag.qw += gc->polygon.shader.qwBig;
            #endif
            #if !(SHADE) && !(TEXTURE)
		GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rBig);
            #endif
            #if ZBUFFER
		gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
		gc->polygon.shader.zbuf =
                    (__GLzValue*)((GLubyte*)gc->polygon.shader.zbuf +
                    gc->polygon.shader.zbufBig);
            #endif
	} else {
	    /*
             * Use small step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftLittle;

            #if SHADE
		GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rLittle);
		GENACCEL(gc).spanValue.g += *((GLint *)&gc->polygon.shader.gLittle);
		GENACCEL(gc).spanValue.b += *((GLint *)&gc->polygon.shader.bLittle);
            #endif
            #if TEXTURE
                #if SHADE
    		GENACCEL(gc).spanValue.a += *((GLint *)&gc->polygon.shader.aLittle);
                #endif
		GENACCEL(gc).spanValue.s += *((GLint *)&gc->polygon.shader.sLittle);
		GENACCEL(gc).spanValue.t += *((GLint *)&gc->polygon.shader.tLittle);
	        gc->polygon.shader.frag.qw += gc->polygon.shader.qwLittle;
            #endif
            #if !(SHADE) && !(TEXTURE)
	        GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rLittle);
            #endif
            #if ZBUFFER
		gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
		gc->polygon.shader.zbuf =
                    (__GLzValue*)((GLubyte*)gc->polygon.shader.zbuf +
		    gc->polygon.shader.zbufLittle);
            #endif
	}
    }

    gc->polygon.shader.ixLeft = gc->polygon.shader.frag.x;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\texture.h ===
#ifndef _texture_h_
#define _texture_h_

/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.11 $
** $Date: 1995/01/25 18:07:23 $
*/
#include "types.h"

#define __GL_TEX_TARGET_INDEX_1D 2
#define __GL_TEX_TARGET_INDEX_2D 3

// This doesn't correspond to an actual default texture, it's just a special
// name for the static DDraw texobj.
#define __GL_TEX_TARGET_INDEX_DDRAW 4

// Texobj name for the DDraw texobj.  This can't be zero because it
// must be distinct from a default texture name.  Technically that's
// all that matters, but in reality it's nice to use a number that's
// uncommon as a normal texture name because it makes it easy to
// identify the DDraw texture object vs. a normal texture object.
// This difference can never be guaranteed, though, so no code should
// ever be written that assumes name matching is good enough to
// identify the DDraw texture object.
#define __GL_TEX_DDRAW 0xdddddddd

/*
** Client state set with glTexGen.
**
** This structure is shared with MCD as MCDTEXTURECOORDGENERATION.
*/
typedef struct __GLtextureCoordStateRec {
    /* How coordinates are being generated */
    GLenum mode;

    /* eye plane set via API, stored for MCD */
    __GLcoord eyePlaneSet;
    
    /* eye plane equation (used iff mode == GL_EYE_LINEAR) */
    __GLcoord eyePlaneEquation;

    /* object plane equation (used iff mode == GL_OBJECT_LINEAR) */
    __GLcoord objectPlaneEquation;
} __GLtextureCoordState;

/*
** Client state set with glTexEnv
*/
typedef struct __GLtextureEnvStateRec {
    /* environment "blend" function */
    GLenum mode;

    /* environment color */
    __GLcolor color;
} __GLtextureEnvState;

//!!! Don't change this structure without changing MCDTEXTURESTATE !!!

/*
** Client state set with glTexParameter
*/
typedef struct __GLtextureParamStateRec {
    /* S & T wrap modes */
    GLenum sWrapMode;
    GLenum tWrapMode;

    /* min and mag filter */
    GLenum minFilter;
    GLenum magFilter;

    /* border color */
    __GLcolor borderColor;	/* Unscaled! */
} __GLtextureParamState;

/*
** Stackable texture object state.
*/
typedef struct __GLtextureObjectStateRec {
    GLuint name;	/* name of the texture */
    GLfloat priority;	/* priority of the texture object */
} __GLtextureObjectState;

/*
** Client state per texture map per dimension.
*/
typedef struct __GLperTextureStateRec {
    /*
    ** Texture parameter state (set with glTexParameter).
    */
    __GLtextureParamState params;

    /*
    ** Texture object bindings and priorities.
    */
    __GLtextureObjectState texobjs;
} __GLperTextureState;

/*
** Stackable client texture state. This does not include
** the mipmaps, or level dependent state.  Only state which is
** stackable via glPushAttrib/glPopAttrib is here.  The rest of the
** state is in the machine structure below.
*/
typedef struct __GLtextureStateRec {
    /* Per coordinate texture state (set with glTexGen) */
    __GLtextureCoordState s;
    __GLtextureCoordState t;
    __GLtextureCoordState r;
    __GLtextureCoordState q;

    /* Per texture state */
    __GLperTextureState *texture;

    /* Per texture environment state */
    __GLtextureEnvState *env;
} __GLtextureState;

/************************************************************************/

typedef __GLfloat __GLtextureBuffer;

typedef struct __GLtexelRec {
    __GLfloat r, g, b;
    __GLfloat luminance;
    __GLfloat alpha;
    __GLfloat intensity;
} __GLtexel;

/************************************************************************/

typedef struct __GLmipMapLevelRec __GLmipMapLevel;
typedef struct __GLtextureRec __GLtexture;

//!!! Don't change this structure without changing MCDMIPMAPLEVEL !!!

struct __GLmipMapLevelRec {
    __GLtextureBuffer *buffer;
    /* Image dimensions, including border */
    GLint width, height;

    /* Image dimensions, doesn't include border */
    GLint width2, height2;
    __GLfloat width2f, height2f;

    /* log2 of width2 & height2 */
    GLint widthLog2, heightLog2;

    /* Border size */
    GLint border;

    /* Requested internal format */
    GLint requestedFormat;

    /* Base internal format */
    GLint baseFormat;

    /* Actual internal format */
    GLint internalFormat;

    /* Component resolution */
    GLint redSize;
    GLint greenSize;
    GLint blueSize;
    GLint alphaSize;
    GLint luminanceSize;
    GLint intensitySize;

    /* Extract function for this mipmap level */
    void (FASTCALL *extract)(__GLmipMapLevel *level, __GLtexture *tex,
                             GLint row, GLint col, __GLtexel *result);
};

//!!! Don't change this structure without changing MCDTEXTUREDATA !!!

struct __GLtextureRec {
    /* Back pointer to context */
    __GLcontext *gc;

    /* Copy of parameter state */
    // This is the start of MCDTEXTUREDATA:
    __GLtextureParamState params;

    /* Copy of texure object stackable state */
    __GLtextureObjectState texobjs;

    /* Level information */
    __GLmipMapLevel *level;

    /* Dimension of this texture (1 or 2) */
    GLint dim;

#ifdef GL_EXT_paletted_texture
    // The palette is the same for all mipmap levels so it
    // is a texture field rather than a mipmap field
    GLsizei paletteSize;
    RGBQUAD *paletteData;

    // Type of palette data, determined by glColorTableEXT
    // and applied to all mipmap levels
    GLenum paletteBaseFormat;
    // internalFormat given in glColorTableEXT call, for
    // GL_COLOR_TABLE_FORMAT requests
    GLenum paletteRequestedFormat;
#endif

    /* maximum( log2(level[0].width2), log2(level[0].height2) ) */
    GLint p;

    /* Min/Mag switchover point */
    __GLfloat c;

    /* Create a new mipmap level for this texture */
    __GLtextureBuffer * (FASTCALL *createLevel)(__GLcontext *gc, __GLtexture *tex,
				       GLint lod, GLint components,
				       GLsizei w, GLsizei h, GLint border,
				       GLint dim);

    /* Texturing function for this texture */
    void (*textureFunc)(__GLcontext *gc, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLfloat rho);

    /* Apply current environment function to fragment */
    void (FASTCALL *env)(__GLcontext *gc, __GLcolor *color, __GLtexel *texel);

    /* Magnification routine for this texture */
    void (FASTCALL *magnify)(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		    __GLcolor *color, __GLfloat s, __GLfloat t,
		    __GLtexel *result);

    /* Minification routine for this texture */
    void (FASTCALL *minnify)(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		    __GLcolor *color, __GLfloat s, __GLfloat t,
		    __GLtexel *result);

    /* Linear filter for this texture */
    void (FASTCALL *linear)(__GLcontext *gc, __GLtexture *tex,
		   __GLmipMapLevel *lp, __GLcolor *color,
		   __GLfloat s, __GLfloat t, __GLtexel *result);

    /* Nearest filter for this texture */
    void (FASTCALL *nearest)(__GLcontext *gc, __GLtexture *tex,
		    __GLmipMapLevel *lp, __GLcolor *color,
		    __GLfloat s, __GLfloat t, __GLtexel *result);

    void *pvUser;   // user-defined expansion for caching, etc.
    DWORD textureKey;  // driver-private key for MCD-accelerated textures

    // The palette can be subdivided into multiple sections.  paletteSize
    // and paletteData point to a single section, while the Total versions
    // contain information about the entire palette.
    GLsizei paletteTotalSize;
    RGBQUAD *paletteTotalData;

    // Number of subdivisions in total palette minus one
    GLsizei paletteDivision;

    // Shift to go from subdivision number to palette entry
    GLsizei paletteDivShift;
};

typedef struct __GLperTextureMachineRec {
    __GLtexture map;
} __GLperTextureMachine;


/*
** Texture object structure.
** refcount field MUST be first in the structure.
*/
typedef struct __GLtextureObjectRec {
    GLint refcount;   	/* reference count: create with 1; delete when 0 */
			/* refcount MUST be first in this structure */
    GLenum targetIndex;	/* index of the target it's bound to */
    GLboolean resident; /* residence status of the texture object */
    __GLperTextureMachine texture;	/* actual texture data */
    struct __GLtextureObjectRec *lowerPriority; /* Priority list link */
    struct __GLtextureObjectRec *higherPriority; /* Priority list link */
    HANDLE loadKey;     /* Texture memory load key for unloading */
} __GLtextureObject;

typedef struct __GLsharedTextureStateRec {
    /* Stores pointers to texture objects, retrieved by name */
    __GLnamesArray *namesArray;

    /* List of all texture objects sorted by priority */
    __GLtextureObject *priorityListHighest;
    __GLtextureObject *priorityListLowest;
} __GLsharedTextureState;

/*
** DDraw texture flags.
*/

/* Whether the texture's format is supported by generic or not */
#define DDTEX_GENERIC_FORMAT    0x00000001

/* Whether all texture surfaces are in video memory or not */
#define DDTEX_VIDEO_MEMORY      0x00000002

typedef struct ___GLddrawTexture {
    /* If levels is greater than zero, a DirectDraw texture is current */
    GLint levels;
    
    /* Level-zero surface with cached description */
    GLDDSURF gdds;

    /* Storage space for DirectDraw texture definitions */
    __GLtextureObject texobj;

    /* levels surface pointers */
    LPDIRECTDRAWSURFACE *pdds;
    
    GLuint flags;
} __GLddrawTexture;
    
typedef struct __GLtextureMachineRec {
    __GLperTextureMachine **texture;

    /* Array of ptrs to the currently bound texture objects. */
    __GLtextureObject **boundTextures;

    /* Array of dummy texture objects for the default textures */
    __GLtextureObject *defaultTextures;

#ifdef GL_WIN_multiple_textures
    /* Current texture index */
    GLuint texIndex;
#endif // GL_WIN_multiple_textures
    
    /* Current enabled texture */
    __GLtexture *currentTexture;

    /* Current DirectDraw texture */
    __GLddrawTexture ddtex;
    
    /* The OR of all texture enable bits */
    GLboolean textureEnabled;

    /* State that can be shared between contexts */
    __GLsharedTextureState *shared;
} __GLtextureMachine;

/************************************************************************/

/* Check for texture consistency before enabling texturing */
extern GLboolean FASTCALL __glIsTextureConsistent(__GLcontext *gc, GLenum texture);

/* Fragment texturing routines */
extern void __glFastTextureFragment(__GLcontext *gc, __GLcolor *color,
				    __GLfloat s, __GLfloat t, __GLfloat rho);
extern void __glTextureFragment(__GLcontext *gc, __GLcolor *color,
				__GLfloat s, __GLfloat t, __GLfloat rho);
extern void __glMipMapFragment(__GLcontext *gc, __GLcolor *color,
			       __GLfloat s, __GLfloat t, __GLfloat rho);

/* Texturing routines */
extern void FASTCALL __glLinearFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			     __GLcolor *color, __GLfloat s, __GLfloat t,
			     __GLtexel *result);
extern void FASTCALL __glNearestFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			      __GLcolor *color, __GLfloat s, __GLfloat t,
			      __GLtexel *result);
extern void FASTCALL __glNMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);
extern void FASTCALL __glLMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);
extern void FASTCALL __glNMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);
extern void FASTCALL __glLMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);

/* Filter routines */
extern void FASTCALL __glLinearFilter1(__GLcontext *gc, __GLtexture *tex,
			      __GLmipMapLevel *lp, __GLcolor *color,
			      __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glLinearFilter2(__GLcontext *gc, __GLtexture *tex,
			      __GLmipMapLevel *lp, __GLcolor *color,
			      __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glNearestFilter1(__GLcontext *gc, __GLtexture *tex,
			       __GLmipMapLevel *lp, __GLcolor *color,
			       __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glNearestFilter2(__GLcontext *gc, __GLtexture *tex,
			       __GLmipMapLevel *lp, __GLcolor *color,
			       __GLfloat s, __GLfloat t, __GLtexel *result);

extern void FASTCALL __glLinearFilter2_BGR8Repeat(__GLcontext *gc, 
                       __GLtexture *tex, __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glLinearFilter2_BGRA8Repeat(__GLcontext *gc, 
                       __GLtexture *tex, __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result);

/* Texture environment functions */
extern void FASTCALL __glTextureModulateL(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateLA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateRGB(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateRGBA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateI(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);

extern void FASTCALL __glTextureDecalRGB(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureDecalRGBA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);

extern void FASTCALL __glTextureBlendL(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendLA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendRGB(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendRGBA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendI(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);

extern void FASTCALL __glTextureReplaceL(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceLA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceRGB(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceRGBA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceI(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);

/* Extract a texel from a texture level (no border) */
extern void FASTCALL __glExtractTexelL(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelLA(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelA(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelI(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelBGR8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelBGRA8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);

/* Extract a texel from a texture level (the texture has a border) */
extern void FASTCALL __glExtractTexelL_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelLA_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelA_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelI_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB8_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA8_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
#ifdef GL_EXT_paletted_texture
extern void FASTCALL __glExtractTexelPI8BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI8BGR(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGR(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI8BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI8BGRA(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGRA(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
#endif

#ifdef GL_EXT_bgra
void FASTCALL __glExtractTexelBGR8_B(__GLmipMapLevel *level, __GLtexture *tex,
                                     GLint row, GLint col, __GLtexel *result);
void FASTCALL __glExtractTexelBGRA8_B(__GLmipMapLevel *level, __GLtexture *tex,
                                      GLint row, GLint col, __GLtexel *result);
#endif // GL_EXT_bgra

/* Texture init */
extern void FASTCALL __glInitTextureUnpack(__GLcontext *gc, __GLpixelSpanInfo *, GLint,
				  GLint, GLenum, GLenum, const GLvoid *,
				  GLenum, GLboolean);
extern void FASTCALL __glInitImagePack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                                       GLint width, GLint height, GLenum format, GLenum type, 
                                       const GLvoid *buf);

/* List execution texture image code */
extern void __gllei_TexImage1D(__GLcontext *gc, GLenum target, GLint lod,
			       GLint components, GLint length, 
			       GLint border, GLenum format, GLenum type,
			       const GLubyte *image);
extern void __gllei_TexImage2D(__GLcontext *gc, GLenum target, GLint lod,
			       GLint components, GLint w, GLint h,
			       GLint border, GLenum format, GLenum type,
			       const GLubyte *image);

extern void __gllei_TexSubImage1D(__GLcontext *gc, GLenum target, GLint lod,
				     GLint xoffset, GLint length,
				     GLenum format, GLenum type,
				     const GLubyte *image);
extern void __gllei_TexSubImage2D(__GLcontext *gc, GLenum target, GLint lod, 
				     GLint xoffset, GLint yoffset,
				     GLsizei w, GLsizei h,
				     GLenum format, GLenum type,
				     const GLubyte *image);

/* Rho calculation routines */
extern __GLfloat __glComputeLineRho(__GLcontext *gc, 
				    __GLfloat s, __GLfloat t, __GLfloat wInv);
extern __GLfloat __glNopLineRho(__GLcontext *gc, 
				__GLfloat s, __GLfloat t, __GLfloat wInv);
extern __GLfloat __glComputePolygonRho(__GLcontext *gc, const __GLshade *sh,
				       __GLfloat s, __GLfloat t,
				       __GLfloat winv);
extern __GLfloat __glNopPolygonRho(__GLcontext *gc, const __GLshade *sh,
				   __GLfloat s, __GLfloat t, __GLfloat winv);

extern __GLtexture *FASTCALL __glCheckTexImage1DArgs(__GLcontext *gc, GLenum target,
					    GLint lod, GLint components,
					    GLsizei length, GLint border,
					    GLenum format, GLenum type);

extern __GLtexture *FASTCALL __glCheckTexImage2DArgs(__GLcontext *gc, GLenum target,
					    GLint lod, GLint components,
					    GLsizei w, GLsizei h, GLint border,
					    GLenum format, GLenum type);

/* Texture Lookup */
extern __GLtextureObjectState *FASTCALL __glLookUpTextureTexobjs(__GLcontext *gc,
						        GLenum target);
/* Texture Lookup */
extern __GLtextureParamState *FASTCALL __glLookUpTextureParams(__GLcontext *gc,
						      GLenum target);
extern __GLtexture *FASTCALL __glLookUpTexture(__GLcontext *gc, GLenum target);

extern __GLtextureObject *FASTCALL __glLookUpTextureObject(__GLcontext *gc,
						  GLenum target);

/* Texture Initialization */
extern void FASTCALL __glEarlyInitTextureState(__GLcontext *gc);

GLboolean FASTCALL __glInitTextureObject(__GLcontext *gc,
                                         __GLtextureObject *texobj, 
                                         GLuint name, GLuint targetIndex);
void FASTCALL __glInitTextureMachine(__GLcontext *gc, GLuint targetIndex, 
                                     __GLperTextureMachine *ptm,
                                     GLboolean allocLevels);

/* Bind Texture used by pop or entry point. */
extern void FASTCALL __glBindTexture(__GLcontext *gc, GLuint targetIndex, GLuint name, GLboolean callGen);

#ifdef NT
extern GLboolean FASTCALL __glCanShareTextures(__GLcontext *gc, __GLcontext *shareMe);
extern void FASTCALL __glShareTextures(__GLcontext *gc, __GLcontext *shareMe);
#endif

void FASTCALL __glSetPaletteSubdivision(__GLtexture *tex, GLsizei subdiv);

#ifdef GL_EXT_paletted_texture
// Attempt to set the extraction function.  If no palette is set,
// this can't be done
void __glSetPaletteLevelExtract8(__GLtexture *tex, __GLmipMapLevel *lp,
                                 GLint border);
void __glSetPaletteLevelExtract16(__GLtexture *tex, __GLmipMapLevel *lp,
                                  GLint border);
#endif // GL_EXT_palette_texture

void __glTexPriListRealize(__GLcontext *gc);
void __glTexPriListAddToList(__GLcontext *gc, __GLtextureObject *texobj);
void __glTexPriListAdd(__GLcontext *gc, __GLtextureObject *texobj,
                       GLboolean realize);
void __glTexPriListRemoveFromList(__GLcontext *gc, __GLtextureObject *texobj);
void __glTexPriListRemove(__GLcontext *gc, __GLtextureObject *texobj,
                          GLboolean realize);
void __glTexPriListChangePriority(__GLcontext *gc, __GLtextureObject *texobj,
                                  GLboolean realize);
void __glTexPriListLoadSubImage(__GLcontext *gc, GLenum target, GLint lod, 
                                GLint xoffset, GLint yoffset, 
                                GLsizei w, GLsizei h);
void __glTexPriListLoadImage(__GLcontext *gc, GLenum target);
void __glTexPriListUnloadAll(__GLcontext *gc);

__GLtextureBuffer * FASTCALL __glCreateProxyLevel(__GLcontext *gc,
                                                  __GLtexture *tex,
					   GLint lod, GLint components,
					   GLsizei w, GLsizei h, GLint border,
					   GLint dim);
__GLtextureBuffer * FASTCALL __glCreateLevel(__GLcontext *gc, __GLtexture *tex,
				      GLint lod, GLint components,
				      GLsizei w, GLsizei h, GLint border,
				      GLint dim);

GLvoid FASTCALL __glCleanupTexObj(__GLcontext *gc, void *pData);

void __glFreeSharedTextureState(__GLcontext *gc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_fast.c ===
/******************************Module*Header*******************************\
* Module Name: px_fast.c                                                   *
*                                                                          *
* Fast special case code for the pixel routines                            *
*                                                                          *
* Created: 10-Oct-1995                                                     *
* Author: Drew Bliss [drewb]                                               *
*                                                                          *
* Copyright (c) 1995 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <gencx.h>
#include <devlock.h>

#include "px_fast.h"

#ifdef NT

// Color rescaling table for [0,255] -> [0,7]
// Generated by (i*14+255)/510, which matches the OpenGL conversion of
// i*7.0/255.0+0.5
static GLubyte ab255to7[256] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};

// Similar table for [0,255] -> [0,3]
static GLubyte ab255to3[256] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

// Color rescaling table for [0,7] -> [0,255]
// Computed as i*255/7
static GLubyte ab7to255[8] =
{
    0, 36, 72, 109, 145, 182, 218, 255
};

// Similar table for [0,3] -> [0,255]
static GLubyte ab3to255[4] =
{
    0, 85, 170, 255
};

/******************************Public*Routine******************************\
*
* DrawRgbPixels
*
* Special case of glDrawPixels for GL_RGB with straight data copy
*
* History:
*  Tue Oct 10 18:43:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean DrawRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;
    __GLcolorBuffer *cfb;
    BYTE abBitmapInfo[sizeof(BITMAPINFO)+2*sizeof(RGBQUAD)];
    BITMAPINFO *pbmi = NULL;
    BITMAPINFOHEADER *pbmih;
    BYTE *pbBits, *pbSrc, *pbDst;
    int x, y, xDst, yDst;
    GLboolean bFail = GL_TRUE;
    int cbSrcLine, cbSrcExtra, cbDstExtra, cbSrcElement, cbDstElement;
    int cbSrcWidth, cbDstWidth;
    int cBits;
    __GLGENcontext *gengc;
    HPALETTE hpal;

#if 0
    DbgPrint("DrawRgbPixels\n");
#endif

    gengc = (__GLGENcontext *)gc;
    cBits = gengc->gsurf.pfd.cColorBits;
    
    // Don't bother with 4bpp because of problems with color reduction
    // The same problems occur in 8bpp but there is special case code
    // to handle it.
    if (cBits < 8)
    {
        return GL_FALSE;
    }

    // If there is no lock, we must have failed to reacquire the lock
    // from some previous call.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("DrawRgbPixels: No lock\n");
	return GL_FALSE;
    }

    // We need to synchronize with GDI so that the surface state is
    // stable before we begin making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);

    cfb = gc->drawBuffer;

    // Determine buffer coordinates
    xDst = __GL_UNBIAS_X(gc, spanInfo->startCol);
    yDst = __GL_UNBIAS_Y(gc, spanInfo->startRow)-spanInfo->height+1;

    if (cBits == 8)
    {
        pbmi = (BITMAPINFO *)gcTempAlloc(gc, sizeof(BITMAPINFO)+
                                         255*sizeof(RGBQUAD));
        if (pbmi == NULL)
        {
            goto EH_Fail;
        }
    }
    else
    {
        pbmi = (BITMAPINFO *)abBitmapInfo;
    }
        
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    // Start out setting the width to the line length to describe
    // the actual data coming in
    pbmih->biWidth = spanInfo->srcLineLength;
    pbmih->biHeight = spanInfo->height;
    pbmih->biPlanes = 1;
    
    if (cBits == 8)
    {
        int i;
        RGBQUAD rqTmp;
        
        // If the destination is 8bpp then we do the color
        // reduction ourselves.  In this case we want to create
        // an 8bpp DIB whose color table matches the destination
        pbmih->biBitCount = 8;
        pbmih->biCompression = BI_RGB;

        hpal = GetCurrentObject(CURRENT_DC, OBJ_PAL);
        if (hpal == NULL)
        {
            goto EH_Fail;
        }

        if (GetPaletteEntries(hpal, 0, 256,
                              (LPPALETTEENTRY)pbmi->bmiColors) != 256)
        {
            goto EH_Fail;
        }

        for (i = 0; i < 256; i++)
        {
            rqTmp = pbmi->bmiColors[i];
            pbmi->bmiColors[i].rgbRed = rqTmp.rgbBlue;
            pbmi->bmiColors[i].rgbBlue = rqTmp.rgbRed;
            pbmi->bmiColors[i].rgbReserved = 0;
        }

        cbDstElement = 1;
    }
    else
    {
        if (spanInfo->srcFormat == GL_BGRA_EXT)
        {
            pbmih->biBitCount = 32;
            pbmih->biCompression = BI_BITFIELDS;
            *((DWORD *)pbmi->bmiColors+0) = 0xff0000;
            *((DWORD *)pbmi->bmiColors+1) = 0xff00;
            *((DWORD *)pbmi->bmiColors+2) = 0xff;
            cbDstElement = 4;
        }
        else
        {
            pbmih->biBitCount = 24;
            pbmih->biCompression = BI_RGB;
            cbDstElement = 3;
        }
    }
    
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;
    
    // For GL_BGR_EXT and GL_BGRA_EXT we can use the data directly if
    // it is laid out in memory like a DIB.  The key thing to check
    // is that scanlines are DWORD aligned.
    // If we can't use the data directly, fall back on the DIB section
    // method which works for anything
    if (cBits > 8 &&
        (spanInfo->srcFormat == GL_BGR_EXT ||
         spanInfo->srcFormat == GL_BGRA_EXT) &&
        spanInfo->srcAlignment == 4)
    {
        if (SetDIBitsToDevice(CURRENT_DC, xDst, yDst,
                              spanInfo->width, spanInfo->height,
                              spanInfo->srcSkipPixels, spanInfo->srcSkipLines,
                              0, spanInfo->height, spanInfo->srcImage,
                              pbmi, DIB_RGB_COLORS) == 0)
        {
            goto EH_Fail;
        }
        
        bFail = GL_FALSE;
        goto EH_Fail;
    }

    // Create a DIB section of the appropriate height and width
    // We originally set the BITMAPINFO width to the width of the
    // incoming data, but we only need to create a DIB section
    // as large as the data we're going to copy so reset the
    // width
    pbmih->biWidth = spanInfo->width;

    hdc = CreateCompatibleDC(CURRENT_DC);
    if (hdc == NULL)
    {
        goto EH_Fail;
    }

    hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS,
                           &pbBits, NULL, 0);
    if (hbm == NULL)
    {
        goto EH_Fail;
    }

    if (SelectObject(hdc, hbm) == NULL)
    {
        goto EH_Fail;
    }

    // Copy the input data to the DIB's contents, possibly swapping R and B,
    // plus skipping any appropriate data, fixing up alignment and
    // obeying the line length

    if (spanInfo->srcFormat == GL_BGRA_EXT)
    {
        cbSrcElement = 4;
    }
    else
    {
        cbSrcElement = 3;
    }
    
    cbSrcLine = spanInfo->srcLineLength*cbSrcElement;
    cbSrcExtra = cbSrcLine % spanInfo->srcAlignment;
    if (cbSrcExtra != 0)
    {
        cbSrcExtra = spanInfo->srcAlignment-cbSrcExtra;
        cbSrcLine += cbSrcExtra;
    }
    cbSrcWidth = spanInfo->width * cbSrcElement;
    cbSrcExtra = cbSrcLine - cbSrcWidth;

    cbDstWidth = spanInfo->width * cbDstElement;
    cbDstExtra = cbDstWidth & 3;
    if (cbDstExtra != 0)
    {
        cbDstExtra = 4-cbDstExtra;
    }
    
    pbSrc = (BYTE *)spanInfo->srcImage+
        spanInfo->srcSkipPixels*cbSrcElement+
        spanInfo->srcSkipLines*cbSrcLine;
    pbDst = pbBits;

    if (cBits == 8)
    {
        // For 8bpp destinations we need to perform the color reduction
        // ourselves because GDI's reduction doesn't match OpenGL's.
        // GDI does a closest-match-in-palette for each pixel, while
        // OpenGL does a rescaling of the color range plus rounding
        
        switch(spanInfo->srcFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ =
                        (ab255to3[*(pbSrc+2)] << cfb->blueShift) |
                        (ab255to7[*(pbSrc+1)] << cfb->greenShift) |
                        (ab255to7[*(pbSrc+0)] << cfb->redShift);
                    pbSrc += 3;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
        case GL_BGRA_EXT:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ =
                        (ab255to3[*(pbSrc+0)] << cfb->blueShift) |
                        (ab255to7[*(pbSrc+1)] << cfb->greenShift) |
                        (ab255to7[*(pbSrc+2)] << cfb->redShift);
                    pbSrc += cbSrcElement;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
        }
    }
    else
    {
        switch(spanInfo->srcFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ = *(pbSrc+2);
                    *pbDst++ = *(pbSrc+1);
                    *pbDst++ = *pbSrc;
                    pbSrc += 3;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
        case GL_BGRA_EXT:
            if (cbSrcExtra == 0 && cbDstExtra == 0)
            {
                CopyMemory(pbDst, pbSrc, cbSrcWidth*spanInfo->height);
            }
            else
            {
                cbDstWidth += cbDstExtra;
                for (y = 0; y < spanInfo->height; y++)
                {
                    CopyMemory(pbDst, pbSrc, cbSrcWidth);
                    pbSrc += cbSrcLine;
                    pbDst += cbDstWidth;
                }
            }
            break;
        }
    }

    // Copy the DIB to the buffer
    bFail = !BitBlt(CURRENT_DC, xDst, yDst, spanInfo->width, spanInfo->height,
                    hdc, 0, 0, SRCCOPY);

 EH_Fail:
    if (hdc != NULL)
    {
        DeleteDC(hdc);
    }
    if (hbm != NULL)
    {
        DeleteObject(hbm);
    }
    if (pbmi != NULL && pbmi != (BITMAPINFO *)abBitmapInfo)
    {
        gcTempFree(gc, pbmi);
    }

    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);
    
    return !bFail;
}

/******************************Public*Routine******************************\
*
* StoreZPixels
*
* Special case of glDrawPixels for GL_DEPTH_COMPONENTs going directly
* into the Z buffer with no color buffer modification.
*
* History:
*  Tue Oct 10 18:43:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean StoreZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLdepthBuffer *fb;
    BYTE *pbBits, *pbSrc, *pbDst;
    int x, y;
    int cbElement, cbSrcLine, cbSrcExtra, cbDstExtra;

#if 0
    DbgPrint("StoreZPixels\n");
#endif
    
    fb = &gc->depthBuffer;
    
    // Copy the input data to the depth buffer,
    // skipping any appropriate data, fixing up alignment and
    // obeying the line length

    switch(spanInfo->srcType)
    {
    case GL_UNSIGNED_SHORT:
        cbElement = 2;
        break;
    case GL_UNSIGNED_INT:
        cbElement = 4;
        break;
        
    default:
        ASSERTOPENGL(0, "StoreZPixels: Unknown srcType\n");
        break;
    }
    
    cbSrcLine = spanInfo->srcLineLength*cbElement;
    cbSrcExtra = cbSrcLine % spanInfo->srcAlignment;
    if (cbSrcExtra != 0)
    {
        cbSrcExtra = spanInfo->srcAlignment-cbSrcExtra;
        cbSrcLine += cbSrcExtra;
    }

    pbSrc = (BYTE *)spanInfo->srcImage+
        spanInfo->srcSkipPixels*cbElement+
        spanInfo->srcSkipLines*cbSrcLine;
    
    // Determine buffer coordinates
    x = spanInfo->startCol;
    y = spanInfo->startRow;

    if (fb->buf.elementSize == sizeof(__GLzValue))
    {
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
        cbDstExtra = -(fb->buf.outerWidth+spanInfo->width)*sizeof(__GLzValue);
    }
    else
    {
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
        cbDstExtra = -(fb->buf.outerWidth+spanInfo->width)*
            sizeof(__GLz16Value);
    }

    switch(spanInfo->srcType)
    {
    case GL_UNSIGNED_SHORT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLzValue *)pbDst =
                        (__GLzValue)(*(GLushort *)pbSrc) << (Z16_SHIFT-1);
                    pbDst += sizeof(__GLzValue);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLz16Value *)pbDst =
                        (*(GLushort *)pbSrc) >> 1;
                    pbDst += sizeof(__GLz16Value);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;

    case GL_UNSIGNED_INT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLzValue *)pbDst =
                        (*(GLuint *)pbSrc) >> 1;
                    pbDst += sizeof(__GLzValue);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLz16Value *)pbDst =
                        (__GLz16Value)((*(GLuint *)pbSrc) >> (Z16_SHIFT+1));
                    pbDst += sizeof(__GLz16Value);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* ReadRgbPixels
*
* Special case of glReadPixels for GL_RGB with straight data copy
*
* History:
*  Tue Oct 10 18:43:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean ReadRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;
    __GLcolorBuffer *cfb;
    BYTE abBitmapInfo[sizeof(BITMAPINFO)+2*sizeof(RGBQUAD)];
    BITMAPINFO *pbmi = NULL;
    BITMAPINFOHEADER *pbmih;
    BYTE *pbBits, *pbDst, *pbSrc;
    DWORD *pdwDst;
    int x, y;
    GLboolean bFail = GL_TRUE;
    int cbDstLine, cbDstExtra, cbSrcExtra, cbSrcElement, cbDstElement;
    int cbSrcWidth, cbDstWidth;
    int cBits;
    HPALETTE hpal;
    __GLGENcontext *gengc;

#if 0
    DbgPrint("ReadRgbPixels\n");
#endif

    gengc = (__GLGENcontext *)gc;
    cBits = gengc->gsurf.pfd.cColorBits;
    
    // Don't bother with 4bpp surfaces
    if (cBits < 8)
    {
        return GL_FALSE;
    }

    // If there is no lock, we must have failed to reacquire the lock
    // from some previous call.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("ReadRgbPixels: No lock\n");
	return GL_FALSE;
    }

    // We need to synchronize with GDI so that the surface state is
    // stable before we begin making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);

    cfb = gc->readBuffer;

    if (cBits == 8)
    {
        pbmi = (BITMAPINFO *)gcTempAlloc(gc, sizeof(BITMAPINFO)+
                                         255*sizeof(RGBQUAD));
        if (pbmi == NULL)
        {
            goto EH_Fail;
        }
    }
    else
    {
        pbmi = (BITMAPINFO *)abBitmapInfo;
    }
    
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    // Start out setting the width to the line length to describe
    // the actual data coming in
    pbmih->biWidth = spanInfo->width;
    pbmih->biHeight = spanInfo->height;
    pbmih->biPlanes = 1;
    
    if (cBits == 8)
    {
        int i;
        RGBQUAD rqTmp;
        
        // If the destination is 8bpp then we do the color
        // expansion ourselves.  In this case we want to create
        // an 8bpp DIB whose color table matches the source
        pbmih->biBitCount = 8;
        pbmih->biCompression = BI_RGB;

        hpal = GetCurrentObject(CURRENT_DC, OBJ_PAL);
        if (hpal == NULL)
        {
            goto EH_Fail;
        }

        if (GetPaletteEntries(hpal, 0, 256,
                              (LPPALETTEENTRY)pbmi->bmiColors) != 256)
        {
            goto EH_Fail;
        }

        for (i = 0; i < 256; i++)
        {
            rqTmp = pbmi->bmiColors[i];
            pbmi->bmiColors[i].rgbRed = rqTmp.rgbBlue;
            pbmi->bmiColors[i].rgbBlue = rqTmp.rgbRed;
            pbmi->bmiColors[i].rgbReserved = 0;
        }

        cbSrcElement = 1;
    }
    else
    {
        if (spanInfo->dstFormat == GL_BGRA_EXT)
        {
            pbmih->biBitCount = 32;
            pbmih->biCompression = BI_BITFIELDS;
            *((DWORD *)pbmi->bmiColors+0) = 0xff0000;
            *((DWORD *)pbmi->bmiColors+1) = 0xff00;
            *((DWORD *)pbmi->bmiColors+2) = 0xff;
            cbSrcElement = 4;
        }
        else
        {
            pbmih->biBitCount = 24;
            pbmih->biCompression = BI_RGB;
            cbSrcElement = 3;
        }
    }
    
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;

    // Create a DIB section of the appropriate height and width
    // We originally set the BITMAPINFO width to the width of the
    // incoming data, but we only need to create a DIB section
    // as large as the data we're going to copy so reset the
    // width
    pbmih->biWidth = spanInfo->width;

    hdc = CreateCompatibleDC(CURRENT_DC);
    if (hdc == NULL)
    {
        goto EH_Fail;
    }

    hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS,
                           &pbBits, NULL, 0);
    if (hbm == NULL)
    {
        goto EH_Fail;
    }

    if (SelectObject(hdc, hbm) == NULL)
    {
        goto EH_Fail;
    }

    if (cBits <= 8)
    {
        hpal = GetCurrentObject(CURRENT_DC, OBJ_PAL);
        if (hpal != NULL)
        {
            if (SelectPalette(hdc, hpal, FALSE) == NULL)
            {
                goto EH_Fail;
            }

            if (RealizePalette(hdc) == GDI_ERROR)
            {
                goto EH_Fail;
            }
        }
    }
    
    // Determine buffer coordinates
    x = __GL_UNBIAS_X(gc, (GLint)spanInfo->readX);
    y = __GL_UNBIAS_Y(gc, (GLint)spanInfo->readY)-spanInfo->height+1;

    // Copy the buffer's contents to the DIB
    if (!BitBlt(hdc, 0, 0, spanInfo->width, spanInfo->height,
                CURRENT_DC, x, y, SRCCOPY))
    {
        goto EH_Fail;
    }
    
    GdiFlush();

    // Copy the DIB's contents to the output buffer, swapping R and B,
    // plus skipping any appropriate data, fixing up alignment and
    // obeying the line length

    if (spanInfo->dstFormat == GL_BGRA_EXT)
    {
        cbDstElement = 4;
    }
    else
    {
        cbDstElement = 3;
    }
    
    cbDstLine = spanInfo->dstLineLength*cbDstElement;
    cbDstExtra = cbDstLine % spanInfo->dstAlignment;
    if (cbDstExtra != 0)
    {
        cbDstExtra = spanInfo->dstAlignment-cbDstExtra;
        cbDstLine += cbDstExtra;
    }
    cbDstWidth = spanInfo->width * cbDstElement;
    cbDstExtra = cbDstLine - cbDstWidth;

    cbSrcWidth = spanInfo->width * cbSrcElement;
    cbSrcExtra = cbSrcWidth & 3;
    if (cbSrcExtra != 0)
    {
        cbSrcExtra = 4-cbSrcExtra;
    }

    pbSrc = pbBits;
    pbDst = (BYTE *)spanInfo->dstImage+
        spanInfo->dstSkipPixels*cbDstElement+
        spanInfo->dstSkipLines*cbDstLine;

    if (cBits == 8)
    {
        BYTE b;
        
        // For 8bpp sources we need to do the color expansion ourselves
        // because the 8bpp palette is only an approximation of a 3-3-2
        // palette since the system colors are forced into it.  Also,
        // GL does a rescaling of the color range.
        
        switch(spanInfo->dstFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    b = *pbSrc++;

                    *pbDst++ =
                        ab7to255[(b & gc->modes.redMask) >> cfb->redShift];
                    *pbDst++ =
                        ab7to255[(b & gc->modes.greenMask) >> cfb->greenShift];
                    *pbDst++ =
                        ab3to255[(b & gc->modes.blueMask) >> cfb->blueShift];
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    b = *pbSrc++;

                    *pbDst++ =
                        ab3to255[(b & gc->modes.blueMask) >> cfb->blueShift];
                    *pbDst++ =
                        ab7to255[(b & gc->modes.greenMask) >> cfb->greenShift];
                    *pbDst++ =
                        ab7to255[(b & gc->modes.redMask) >> cfb->redShift];
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGRA_EXT:
            pdwDst = (DWORD *)pbDst;
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    b = *pbSrc++;

                    *pdwDst++ =
                        0xff000000 |
                        ((DWORD)ab7to255[(b & gc->modes.redMask) >>
                                         cfb->redShift] << 16) |
                        ((DWORD)ab7to255[(b & gc->modes.greenMask) >>
                                         cfb->greenShift] << 8) |
                        ((DWORD)ab3to255[(b & gc->modes.blueMask) >>
                                         cfb->blueShift]);
                }
                
                pbSrc += cbSrcExtra;
                pdwDst = (DWORD *)(((BYTE *)pdwDst) + cbDstExtra);
            }
            break;
        }
    }
    else
    {
        switch(spanInfo->dstFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ = *(pbSrc+2);
                    *pbDst++ = *(pbSrc+1);
                    *pbDst++ = *pbSrc;
                    pbSrc += 3;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
            if (cbSrcExtra == 0 && cbDstExtra == 0)
            {
                CopyMemory(pbDst, pbSrc, cbDstWidth*spanInfo->height);
            }
            else
            {
                cbSrcWidth += cbSrcExtra;
                for (y = 0; y < spanInfo->height; y++)
                {
                    CopyMemory(pbDst, pbSrc, cbDstWidth);
                    pbSrc += cbSrcWidth;
                    pbDst += cbDstLine;
                }
            }
            break;

        case GL_BGRA_EXT:
            {
                DWORD *pdwSrc = (DWORD *)pbSrc;

                pdwDst = (DWORD *)pbDst;

                for (y = 0; y < spanInfo->height; y++)
                {
                    for (x = 0; x < spanInfo->width; x++)
                    {
                        *pdwDst++ = 0xff000000 | (*pdwSrc++);
                    }

                    pdwSrc = (DWORD *)(((BYTE *)pdwSrc) + cbSrcExtra);
                    pdwDst = (DWORD *)(((BYTE *)pdwDst) + cbDstExtra);
                }
            }
        }
    }
    
    bFail = GL_FALSE;

 EH_Fail:
    if (hdc != NULL)
    {
        DeleteDC(hdc);
    }
    if (hbm != NULL)
    {
        DeleteObject(hbm);
    }
    if (pbmi != NULL && pbmi != (BITMAPINFO *)abBitmapInfo)
    {
        gcTempFree(gc, pbmi);
    }

    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);
    
    return !bFail;
}

/******************************Public*Routine******************************\
*
* ReadZPixels
*
* Special case of glReadPixels for GL_DEPTH_COMPONENTs with
* unsigned types that require minimal transformation
*
* History:
*  Tue Oct 10 18:43:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean ReadZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLdepthBuffer *fb;
    BYTE *pbBits, *pbSrc, *pbDst;
    int x, y;
    int cbElement, cbDstLine, cbSrcExtra, cbDstExtra;

#if 0
    DbgPrint("ReadZPixels\n");
#endif
    
    fb = &gc->depthBuffer;
    
    // Copy the depth buffer data to the output
    // skipping any appropriate data, fixing up alignment and
    // obeying the line length

    switch(spanInfo->dstType)
    {
    case GL_UNSIGNED_SHORT:
        cbElement = 2;
        break;
    case GL_UNSIGNED_INT:
        cbElement = 4;
        break;
        
    default:
        ASSERTOPENGL(0, "ReadZPixels: Unknown dstType\n");
        break;
    }
    
    cbDstLine = spanInfo->dstLineLength*cbElement;
    cbDstExtra = cbDstLine % spanInfo->dstAlignment;
    if (cbDstExtra != 0)
    {
        cbDstExtra = spanInfo->dstAlignment-cbDstExtra;
        cbDstLine += cbDstExtra;
    }

    pbDst = (BYTE *)spanInfo->dstImage+
        spanInfo->dstSkipPixels*cbElement+
        spanInfo->dstSkipLines*cbDstLine;
    
    // Determine buffer coordinates
    x = (GLint)spanInfo->readX;
    y = (GLint)spanInfo->readY;

    if (fb->buf.elementSize == sizeof(__GLzValue))
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
        cbSrcExtra = -(fb->buf.outerWidth+spanInfo->width)*sizeof(__GLzValue);
    }
    else
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
        cbSrcExtra = -(fb->buf.outerWidth+spanInfo->width)*
            sizeof(__GLz16Value);
    }

    switch(spanInfo->dstType)
    {
    case GL_UNSIGNED_SHORT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLushort *)pbDst =
                        (GLushort)(*(__GLzValue *)pbSrc) >> (Z16_SHIFT-1);
                    pbSrc += sizeof(__GLzValue);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLushort *)pbDst =
                        (*(__GLz16Value *)pbSrc) << 1;
                    pbSrc += sizeof(__GLz16Value);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;

    case GL_UNSIGNED_INT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLuint *)pbDst =
                        (*(__GLzValue *)pbSrc) << 1;
                    pbSrc += sizeof(__GLzValue);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLuint *)pbDst =
                        (GLuint)((*(__GLz16Value *)pbSrc) << (Z16_SHIFT+1));
                    pbSrc += sizeof(__GLz16Value);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyRgbPixels
*
* Special case of glCopyPixels for straight data copy
*
* Currently we only have to deal with normal color buffers
* If we start supporting aux buffers it may no longer be possible
* to accelerate this function in all cases
*
* History:
*  Tue Oct 10 18:43:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLcolorBuffer *cfbSrc, *cfbDst;
    int xSrc, ySrc, xDst, yDst;
    GLboolean bFail;
    __GLGENcontext *gengc;

#if 0
    DbgPrint("CopyRgbPixels\n");
#endif

    gengc = (__GLGENcontext *)gc;
    
    // If there is no lock, we must have failed to reacquire the lock
    // from some previous call.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("CopyRgbPixels: No lock\n");
	return GL_FALSE;
    }

    // We need to synchronize with GDI so that the surface state is
    // stable before we begin making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);

    cfbSrc = gc->readBuffer;
    cfbDst = gc->drawBuffer;
    
    // Determine buffer coordinates
    xSrc = __GL_UNBIAS_X(gc, (GLint)spanInfo->readX);
    ySrc = __GL_UNBIAS_Y(gc, (GLint)spanInfo->readY)-spanInfo->height+1;
    xDst = __GL_UNBIAS_X(gc, (GLint)spanInfo->x);
    yDst = __GL_UNBIAS_Y(gc, (GLint)spanInfo->y)-spanInfo->height+1;

    // Copy the data between the buffers
    bFail = (GLboolean)BitBlt(CURRENT_DC_CFB(cfbDst), xDst, yDst,
                              spanInfo->width, spanInfo->height,
                              CURRENT_DC_CFB(cfbSrc), xSrc, ySrc, SRCCOPY);
    
    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);
    
    return bFail;
}

/******************************Public*Routine******************************\
*
* CopyZPixels
*
* Special case of glCopyPixels for GL_DEPTH where there is no
* destination color buffer and the Z function is GL_ALWAYS
*
* History:
*  Tue Oct 10 18:43:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLdepthBuffer *fb;
    BYTE *pbSrc, *pbDst;
    int y, xSrc, ySrc, xDst, yDst;
    int cbLine, cbWidth;

#if 0
    DbgPrint("CopyZPixels\n");
#endif
    
    fb = &gc->depthBuffer;
    
    // Determine buffer coordinates
    xSrc = (GLint)spanInfo->readX;
    ySrc = (GLint)spanInfo->readY;
    xDst = (GLint)spanInfo->x;
    yDst = (GLint)spanInfo->y;

    if (fb->buf.elementSize == sizeof(__GLzValue))
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), xSrc, ySrc);
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), xDst, yDst);
        cbLine = -fb->buf.outerWidth*sizeof(__GLzValue);
        cbWidth = spanInfo->width*sizeof(__GLzValue);
    }
    else
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), xSrc, ySrc);
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), xDst, yDst);
        cbLine = -fb->buf.outerWidth*sizeof(__GLz16Value);
        cbWidth = spanInfo->width*sizeof(__GLz16Value);
    }

    if (cbLine == cbWidth)
    {
        MoveMemory(pbDst, pbSrc, cbWidth*spanInfo->height);
    }
    else
    {
        // Adjust copy direction to handle overlap cases
        if (ySrc > yDst)
        {
            pbSrc += cbLine*spanInfo->height;
            pbDst += cbLine*spanInfo->height;
            for (y = 0; y < spanInfo->height; y++)
            {
                pbSrc -= cbLine;
                pbDst -= cbLine;
                CopyMemory(pbDst, pbSrc, cbWidth);
            }
        }
        else if (ySrc < yDst)
        {
            for (y = 0; y < spanInfo->height; y++)
            {
                CopyMemory(pbDst, pbSrc, cbWidth);
                pbSrc += cbLine;
                pbDst += cbLine;
            }
        }
        else
        {
            for (y = 0; y < spanInfo->height; y++)
            {
                MoveMemory(pbDst, pbSrc, cbWidth);
                pbSrc += cbLine;
                pbDst += cbLine;
            }
        }
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyAlignedImage
*
* Copies data between memory images where straight data copy is applicable
*
* This routine doesn't handle overlap
* The old code doesn't seem to either, so perhaps this isn't a problem
*
* History:
*  Tue Nov 07 14:27:06 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyAlignedImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int cbLine;
    int y;
    GLubyte *src, *dst;

    ASSERTOPENGL(spanInfo->srcGroupIncrement == spanInfo->dstGroupIncrement,
                 "CopyAlignedImage: Group size mismatch\n");

    cbLine = spanInfo->width*spanInfo->dstGroupIncrement;
    if (spanInfo->srcRowIncrement == spanInfo->dstRowIncrement &&
        cbLine == spanInfo->srcRowIncrement)
    {
        // Source and destination rows are the same size and the copy
        // is copying all of the row so we can do everything with a
        // single copy
        CopyMemory(spanInfo->dstCurrent, spanInfo->srcCurrent,
                   cbLine*spanInfo->height);
    }
    else
    {
        // Either the rows aren't the same size or we're not copying
        // all of each row, so we have to go row by row
        src = spanInfo->srcCurrent;
        dst = spanInfo->dstCurrent;
        for (y = spanInfo->height; y > 0; y--)
        {
            CopyMemory(dst, src, cbLine);
            src += spanInfo->srcRowIncrement;
            dst += spanInfo->dstRowIncrement;
        }
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyRgbToBgraImage
*
* Special case for 24-bit RGB to 32-bit BGRA
*
* History:
*  Tue Nov 07 15:09:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyRgbToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int x, y;
    GLubyte *src;
    GLuint *dst;
    int srcStep, dstStep;

    src = spanInfo->srcCurrent;
    dst = spanInfo->dstCurrent;
    srcStep = spanInfo->srcRowIncrement-
        spanInfo->width*spanInfo->srcGroupIncrement;
    dstStep = spanInfo->dstRowIncrement-
        spanInfo->width*spanInfo->dstGroupIncrement;
    
    ASSERTOPENGL((dstStep & 3) == 0, "Non-dword step\n");
    dstStep >>= 2;
    
    for (y = spanInfo->height; y > 0; y--)
    {
        for (x = spanInfo->width; x > 0; x--)
        {
            *dst++ =
                0xff000000             |
                ((GLuint)src[0] << 16) |
                ((GLuint)src[1] <<  8) |
                ((GLuint)src[2] <<  0);
            src += 3;
        }
        src += srcStep;
        dst += dstStep;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyRgbaToBgraImage
*
* Special case for 32-bit RGBA to 32-bit BGRA
*
* History:
*  Tue Nov 07 15:09:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyRgbaToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int x, y;
    GLubyte *src;
    GLuint *dst;
    int srcStep, dstStep;

    src = spanInfo->srcCurrent;
    dst = spanInfo->dstCurrent;
    srcStep = spanInfo->srcRowIncrement-
        spanInfo->width*spanInfo->srcGroupIncrement;
    dstStep = spanInfo->dstRowIncrement-
        spanInfo->width*spanInfo->dstGroupIncrement;
    
    ASSERTOPENGL((dstStep & 3) == 0, "Non-dword step\n");
    dstStep >>= 2;
    
    for (y = spanInfo->height; y > 0; y--)
    {
        for (x = spanInfo->width; x > 0; x--)
        {
            *dst++ =
                ((GLuint)src[0] << 16) |
                ((GLuint)src[1] <<  8) |
                ((GLuint)src[2] <<  0) |
                ((GLuint)src[3] << 24);
            src += 4;
        }
        src += srcStep;
        dst += dstStep;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyBgrToBgraImage
*
* Special case for 24-bit BGR to 32-bit BGRA
*
* History:
*  Tue Nov 07 15:09:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyBgrToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int x, y;
    GLubyte *src;
    GLuint *dst;
    int srcStep, dstStep;

    src = spanInfo->srcCurrent;
    dst = spanInfo->dstCurrent;
    srcStep = spanInfo->srcRowIncrement-
        spanInfo->width*spanInfo->srcGroupIncrement;
    dstStep = spanInfo->dstRowIncrement-
        spanInfo->width*spanInfo->dstGroupIncrement;
    
    ASSERTOPENGL((dstStep & 3) == 0, "Non-dword step\n");
    dstStep >>= 2;
    
    for (y = spanInfo->height; y > 0; y--)
    {
        for (x = spanInfo->width; x > 0; x--)
        {
            *dst++ =
                0xff000000             |
                ((GLuint)src[0] <<  0) |
                ((GLuint)src[1] <<  8) |
                ((GLuint)src[2] << 16);
            src += 3;
        }
        src += srcStep;
        dst += dstStep;
    }

    return GL_TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\inc\xform.h ===
#ifndef _transform_h_
#define _transform_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.18 $
** $Date: 1993/11/29 20:34:42 $
*/
#include "vertex.h"

extern __GLcoord __gl_frustumClipPlanes[6];

extern void FASTCALL __glComputeClipBox(__GLcontext *gc);
extern void FASTCALL __glUpdateDepthRange(__GLcontext *gc);
extern void FASTCALL __glUpdateViewport(__GLcontext *gc);
#ifdef NT
extern void FASTCALL __glUpdateViewportDependents(__GLcontext *gc);
#endif

/*
** Note: 
**
** Other code assumes that all types >= __GL_MT_IS2D are also 2D
** Other code assumes that all types >= __GL_MT_W0001 are also W0001
** Other code assumes that all types >= __GL_MT_IS2DNR are also 2DNR
**
** These enumerants are exposed to the MCD.
*/
#define __GL_MT_GENERAL		0	/* No information */
#define __GL_MT_W0001		1	/* W row looks like 0 0 0 1 */
#define __GL_MT_IS2D		2	/* 2D matrix */
#define __GL_MT_IS2DNR		3	/* 2D non-rotational matrix */
#define __GL_MT_IDENTITY	4	/* Identity */

/*
** Matrix struct.  This contains a 4x4 matrix as well as function
** pointers used to do a transformation with the matrix.  The function
** pointers are loaded based on the matrix contents attempting to
** avoid unneccesary computation.
*/

// Matrix structure.
typedef struct __GLmatrixBaseRec {
    __GLfloat matrix[4][4];
} __GLmatrixBase;

// Projection matrix structure.
typedef struct __GLmatrixPRec {
    __GLfloat matrix[4][4];
    GLenum matrixType;
} __GLmatrixP;

// Modelview and texture transform structures.
//
// This structure is exposed to the MCD as MCDMATRIX.
struct __GLmatrixRec {
    __GLfloat matrix[4][4];

    /* 
    ** matrixType set to general if nothing is known about this matrix.
    **
    ** matrixType set to __GL_MT_W0001 if it looks like this:
    ** | . . . 0 |
    ** | . . . 0 |
    ** | . . . 0 |
    ** | . . . 1 |
    **
    ** matrixType set to __GL_MT_IS2D if it looks like this:
    ** | . . 0 0 |
    ** | . . 0 0 |
    ** | 0 0 . 0 |
    ** | . . . 1 |
    **
    ** matrixType set to __GL_MT_IS2DNR if it looks like this:
    ** | . 0 0 0 |
    ** | 0 . 0 0 |
    ** | 0 0 . 0 |
    ** | . . . 1 |
    **
    */
    GLenum matrixType;

    void (FASTCALL *xf1)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf2)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf3)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf4)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xfNorm)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf1Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xf2Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xf3Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xf4Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xfNormBatch) (POLYARRAY *pa, const __GLmatrix *m);
     // Transform and normalize
    void (FASTCALL *xfNormBatchN)(POLYARRAY *pa, const __GLmatrix *m);
    GLboolean nonScaling;    
};

extern void FASTCALL __glGenericPickMatrixProcs(__GLcontext *gc, __GLmatrix *m );
extern void FASTCALL __glGenericPickInvTransposeProcs(__GLcontext *gc, __GLmatrix *m );
extern void FASTCALL __glGenericPickMvpMatrixProcs(__GLcontext *gc, __GLmatrix *m );

/************************************************************************/

/*
** Transform struct.  This structure is what the matrix stacks are
** composed of.  inverseTranspose contains the inverse transpose of matrix.
** For the modelView stack, "mvp" will contain the concatenation of
** the modelView and current projection matrix (i.e. the multiplication of
** the two matricies).
**
** The beginning of this structure is exposed to the MCD as MCDTRANSFORM.
*/

// Transform flags

// Used for MCD
#define XFORM_CHANGED           0x00000001

// Internal
#define XFORM_UPDATE_INVERSE    0x00000002
    
// Modelview transform structure.
struct __GLtransformRec {
    __GLmatrix matrix;
    __GLmatrix mvp;

    GLuint flags;
    
    /* MCDTRANSFORM ends */
    
    /* Sequence number tag for mvp */
    GLuint sequence;
    
    __GLmatrix inverseTranspose;
};

// Texture transform structure.
typedef struct __GLtransformTRec {
    __GLmatrix matrix;
} __GLtransformT;

// Projection transform structure.
typedef struct __GLtransformPRec {
    __GLmatrixP matrix;
    /* Sequence number tag for mvp */
    GLuint sequence;
} __GLtransformP;

/************************************************************************/

/* Unbias an x,y coordinate */
#define __GL_UNBIAS_X(gc, x)	((x) - (gc)->constants.viewportXAdjust)
#define __GL_UNBIAS_Y(gc, y)	((y) - (gc)->constants.viewportYAdjust)

/*
** Transformation machinery state.  Contains the state needed to transform
** user coordinates into eye & window coordinates.
*/
typedef struct __GLtransformMachineRec {
    /*
    ** Transformation stack.  "modelView" points to the active element in
    ** the stack.
    */
    __GLtransform *modelViewStack;
    __GLtransform *modelView;

    /*
    ** Current projection matrix.  Used to transform eye coordinates into
    ** NTVP (or clip) coordinates.
    */
    __GLtransformP *projectionStack;
    __GLtransformP *projection;
    GLuint projectionSequence;

    /*
    ** Texture matrix stack.
    */
    __GLtransformT *textureStack;
    __GLtransformT *texture;

    /*
    ** Temporary verticies used during clipping.  These contain verticies
    ** that are the result of clipping a polygon edge against a clipping
    ** plane.  For a convex polygon at most one vertex can be added for 
    ** each clipping plane.
    */
    __GLvertex *clipTemp;
    __GLvertex *nextClipTemp;

    /*
    ** The smallest rectangle that is the intersection of the window clip
    ** and the scissor clip.  If the scissor box is disabled then this
    ** is just the window box. Note that the x0,y0 point is inside the
    ** box but that the x1,y1 point is just outside the box.
    */
    GLint clipX0;
    GLint clipY0;
    GLint clipX1;
    GLint clipY1;

    /*
    ** The viewport translated into offset window coordinates.  maxx and maxy
    ** are one past the edge (an x coord is in if minx <= x < maxx).
    */
    GLint minx, miny, maxx, maxy;

    /*
    ** The same thing expressed as floating point numbers.
    */
    __GLfloat fminx, fminy, fmaxx, fmaxy;

#ifdef SGI
// Not used.
    /* 
    ** Fast 2D transform state.  If the mvp matrix is >= __GL_MT_IS2D, then
    ** matrix2D contains the matrix to transform object coordinates directly
    ** to window coordinates.
    ** Even though this optimization is used on a per implementation basis,
    ** this matrix is maintained up to date by the soft code.
    */
    __GLmatrix matrix2D;
#endif // SGI
    
    /* A flag for fast path triangle rendering.
    ** If this flag is set, then the user has created a viewport that 
    ** fits within the window, and we can make it render fast.  If, however,
    ** the viewport extends outside the window, we have to be more careful
    ** about scissoring.
    */
    GLboolean reasonableViewport;
} __GLtransformMachine;

extern void __glDoClip(__GLcontext *gc, const __GLvertex *v0,
		       const __GLvertex *v1, __GLvertex *result, __GLfloat t);

extern void FASTCALL __glDoLoadMatrix(__GLcontext *gc, const __GLfloat m[4][4],
			BOOL bIsIdentity);
extern void FASTCALL __glDoMultMatrix(__GLcontext *gc, void *data, 
    void (FASTCALL *multiply)(__GLcontext *gc, __GLmatrix *m, void *data));
extern void __glDoRotate(__GLcontext *gc, __GLfloat angle, __GLfloat ax,
			 __GLfloat ay, __GLfloat az);
extern void __glDoScale(__GLcontext *gc, __GLfloat x, __GLfloat y, __GLfloat z);
extern void __glDoTranslate(__GLcontext *gc, __GLfloat x, __GLfloat y,
			    __GLfloat z);

extern void FASTCALL __glComputeInverseTranspose(__GLcontext *gc, __GLtransform *tr);

/*
** Matrix routines.
*/
extern void FASTCALL __glCopyMatrix(__GLmatrix *dst, const __GLmatrix *src);
extern void FASTCALL __glInvertTransposeMatrix(__GLmatrix *dst, const __GLmatrix *src);
extern void FASTCALL __glMakeIdentity(__GLmatrix *result);
extern void FASTCALL __glMultMatrix(__GLmatrix *result, const __GLmatrix *a,
			   const __GLmatrix *b);
extern void __glTranspose3x3(__GLmatrix *dst, __GLmatrix *src);

/*
** Miscellaneous routines.
*/
extern void FASTCALL __glNormalize(__GLfloat dst[3], const __GLfloat src[3]);
extern void FASTCALL __glNormalizeBatch(POLYARRAY* pa);

/************************************************************************/

extern void FASTCALL __glPushModelViewMatrix(__GLcontext *gc);
extern void FASTCALL __glPopModelViewMatrix(__GLcontext *gc);
extern void FASTCALL __glLoadIdentityModelViewMatrix(__GLcontext *gc);

extern void FASTCALL __glPushProjectionMatrix(__GLcontext *gc);
extern void FASTCALL __glPopProjectionMatrix(__GLcontext *gc);
extern void FASTCALL __glLoadIdentityProjectionMatrix(__GLcontext *gc);

extern void FASTCALL __glPushTextureMatrix(__GLcontext *gc);
extern void FASTCALL __glPopTextureMatrix(__GLcontext *gc);
extern void FASTCALL __glLoadIdentityTextureMatrix(__GLcontext *gc);

/*
** Xforming routines.
*/

void FASTCALL __glXForm4_2DNRW(__GLcoord *res, const __GLfloat v[4],
		      const __GLmatrix *m);
void FASTCALL __glXForm3_2DNRW(__GLcoord *res, const __GLfloat v[3],
		      const __GLmatrix *m);
void FASTCALL __glXForm4_2DW(__GLcoord *res, const __GLfloat v[4],
		    const __GLmatrix *m);
void FASTCALL __glXForm3_2DW(__GLcoord *res, const __GLfloat v[3],
		    const __GLmatrix *m);
#ifndef __GL_USEASMCODE
void FASTCALL __glXForm4_W(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m);
void FASTCALL __glXForm3x3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m);
void FASTCALL __glXForm3_W(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m);
void FASTCALL __glXForm2_W(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m);
void FASTCALL __glXForm4(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m);
void FASTCALL __glXForm3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m);
void FASTCALL __glXForm2(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m);
void FASTCALL __glXForm2_2DW(__GLcoord *res, const __GLfloat v[2],
		    const __GLmatrix *m);
void FASTCALL __glXForm2_2DNRW(__GLcoord *res, const __GLfloat v[2],
		      const __GLmatrix *m);
#endif /* !__GL_USEASMCODE */
void FASTCALL __glXForm1_W(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m);
void FASTCALL __glXForm1(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m);
void FASTCALL __glXForm1_2DW(__GLcoord *res, const __GLfloat v[1],
		    const __GLmatrix *m);
void FASTCALL __glXForm1_2DNRW(__GLcoord *res, const __GLfloat v[1],
		      const __GLmatrix *m);


/*
** Batched versions of the above routines.
*/

void FASTCALL __glXForm4_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm4_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
#ifndef __GL_USEASMCODE
void FASTCALL __glXForm4_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3x3Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm4Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
#endif /* !__GL_USEASMCODE */
void FASTCALL __glXForm1_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm1Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm1_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm1_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);

// Transformations for normals
//
void FASTCALL __glXForm3_2DNRWBatchNormal  (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3_2DNRWBatchNormalN (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3_2DWBatchNormal    (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3_2DWBatchNormalN   (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3x3BatchNormal      (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3x3BatchNormalN     (POLYARRAY *pa, const __GLmatrix *m);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_api.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "gencx.h"
#include "imfuncs.h"

/*
** Initialize pixel map with default size and value.
*/
void FASTCALL __glInitDefaultPixelMap(__GLcontext *gc, GLenum map)
{
    __GLpixelState *ps = &gc->state.pixel;
    __GLpixelMapHead *pMap = ps->pixelMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
#ifdef _MCD_
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
#endif

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        /*
        ** Allocate single-entry map for index type.
        */
        if (!(pMap[index].base.mapI = (GLint*)
              GCALLOC(gc, sizeof(GLint)))) {
            return;
        } else {
            pMap[index].base.mapI[0] = 0;
            pMap[index].size = 1;
#ifdef _MCD_
            if (gengc->pMcdState)
                GenMcdPixelMap(gengc, map, 1, (VOID *) pMap[index].base.mapI);
#endif
        }
        break;
      case GL_PIXEL_MAP_I_TO_R: case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B: case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R: case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B: case GL_PIXEL_MAP_A_TO_A:
        /*
        ** Allocate single-entry map for component type.
        */
        if (!(pMap[index].base.mapF = (__GLfloat*)
              GCALLOC(gc, sizeof(__GLfloat)))) {
            return;
        } else {
            pMap[index].base.mapF[0] = __glZero;
            pMap[index].size = 1;
#ifdef _MCD_
            if (gengc->pMcdState)
                GenMcdPixelMap(gengc, map, 1, (VOID *) pMap[index].base.mapF);
#endif
        }
        break;
    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void FASTCALL __glPixelSetColorScales(__GLcontext *gc)
{
    __GLpixelMachine *pm = &gc->pixel;
    GLfloat redScale, greenScale, blueScale, alphaScale;
    int i;
    GLint mask;

    if (pm->redMap == NULL) {
        /* First time allocation of these maps */

        /*
        ** These lookup tables are for type UNSIGNED_BYTE, so they are sized
        ** to 256 entries.  They map from UNSIGNED_BYTE to internal scaled
        ** floating point colors.
        */
#ifdef NT
        pm->redMap =
            (GLfloat*) GCALLOC(gc, 5 * 256 * sizeof(GLfloat));
        if (!pm->redMap)
            return;
        pm->greenMap = pm->redMap + 1 * 256;
        pm->blueMap  = pm->redMap + 2 * 256;
        pm->alphaMap = pm->redMap + 3 * 256;
        pm->iMap     = pm->redMap + 4 * 256;
#else
        pm->redMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->greenMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->blueMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->alphaMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->iMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
#endif
    }

    redScale = gc->frontBuffer.redScale / 255;
    greenScale = gc->frontBuffer.greenScale / 255;
    blueScale = gc->frontBuffer.blueScale / 255;
    alphaScale = gc->frontBuffer.alphaScale / 255;
    mask = gc->frontBuffer.redMax;
    for (i=0; i<256; i++) {
        pm->redMap[i] = i * redScale;
        pm->greenMap[i] = i * greenScale;
        pm->blueMap[i] = i * blueScale;
        pm->alphaMap[i] = i * alphaScale;
        pm->iMap[i] = (GLfloat) (i & mask);
    }

    /*
    ** Invalidate the RGBA modify tables so that they will be
    ** recomputed using the current color buffer scales.
    */
    pm->rgbaCurrent = GL_FALSE;
}

/************************************************************************/

void FASTCALL __glFreePixelState(__GLcontext *gc)
{
    __GLpixelState *ps = &gc->state.pixel;
    __GLpixelMapHead *pMap = ps->pixelMap;
    __GLpixelMachine *pm = &gc->pixel;
    GLenum m;
    GLint i;

    /*
    ** Free memory allocated to pixel maps.
    */
    for (m = GL_PIXEL_MAP_I_TO_I; m <= GL_PIXEL_MAP_A_TO_A; m++) {
        i = m - GL_PIXEL_MAP_I_TO_I;
        if (pMap[i].base.mapI) {
            GCFREE(gc, pMap[i].base.mapI);
            pMap[i].base.mapI = 0;
        }
    }

#ifdef NT
    // This includes red, green, blue, alpha and i maps.
    GCFREE(gc, pm->redMap);
#else
    GCFREE(gc, pm->redMap);
    GCFREE(gc, pm->greenMap);
    GCFREE(gc, pm->blueMap);
    GCFREE(gc, pm->alphaMap);
    GCFREE(gc, pm->iMap);
#endif
    if (pm->redModMap) {
#ifdef NT
        // This includes red, green, blue and alpha mod maps.
        GCFREE(gc, pm->redModMap);
#else
        GCFREE(gc, pm->redModMap);
        GCFREE(gc, pm->greenModMap);
        GCFREE(gc, pm->blueModMap);
        GCFREE(gc, pm->alphaModMap);
#endif
    }
    if (pm->iToRMap) {
#ifdef NT
        // This includes iToR, iToG, iToB and iToA maps.
        GCFREE(gc, pm->iToRMap);
#else
        GCFREE(gc, pm->iToRMap);
        GCFREE(gc, pm->iToGMap);
        GCFREE(gc, pm->iToBMap);
        GCFREE(gc, pm->iToAMap);
#endif
    }
    if (pm->iToIMap) {
        GCFREE(gc, pm->iToIMap);
    }
}

void FASTCALL __glInitPixelState(__GLcontext *gc)
{
    __GLpixelState *ps = &gc->state.pixel;
    __GLpixelMachine *pm = &gc->pixel;
    GLenum m;

    /*
    ** Initialize transfer mode.
    */
    ps->transferMode.r_scale = __glOne;
    ps->transferMode.g_scale = __glOne;
    ps->transferMode.b_scale = __glOne;
    ps->transferMode.a_scale = __glOne;
    ps->transferMode.d_scale = __glOne;
    ps->transferMode.zoomX = __glOne;
    ps->transferMode.zoomY = __glOne;

    /*
    ** Initialize pixel maps with default sizes and values.
    */
    for (m = GL_PIXEL_MAP_I_TO_I; m <= GL_PIXEL_MAP_A_TO_A; m++) {
        __glInitDefaultPixelMap(gc, m);
    }

    /*
    ** Initialize store mode.
    */
    ps->packModes.alignment = 4;
    ps->unpackModes.alignment = 4;

    /* Setup to use the correct read buffer */
    if (gc->modes.doubleBufferMode) {
        ps->readBuffer = GL_BACK;
    } else {
        ps->readBuffer = GL_FRONT;
    }
    ps->readBufferReturn = ps->readBuffer;

    /* Lookup tables used by some pixel routines */

    __glPixelSetColorScales(gc);

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/************************************************************************/

/*
** Specify modes that control the storage format of pixel arrays.
*/
void APIPRIVATE __glim_PixelStoref(GLenum mode, GLfloat value)
{
    switch (mode) {
      case GL_PACK_ROW_LENGTH:
      case GL_PACK_SKIP_ROWS:
      case GL_PACK_SKIP_PIXELS:
      case GL_PACK_ALIGNMENT:
      case GL_UNPACK_ROW_LENGTH:
      case GL_UNPACK_SKIP_ROWS:
      case GL_UNPACK_SKIP_PIXELS:
      case GL_UNPACK_ALIGNMENT:
        /* Round */
        if (value < 0) {
            __glim_PixelStorei(mode, (GLint) (value - (__GLfloat) 0.5));
        } else {
            __glim_PixelStorei(mode, (GLint) (value + (__GLfloat) 0.5));
        }
        break;
      case GL_PACK_SWAP_BYTES:
      case GL_PACK_LSB_FIRST:
      case GL_UNPACK_SWAP_BYTES:
      case GL_UNPACK_LSB_FIRST:
        if (value == __glZero) {
            __glim_PixelStorei(mode, GL_FALSE);
        } else {
            __glim_PixelStorei(mode, GL_TRUE);
        }
      default:
        __glim_PixelStorei(mode, (GLint) value);
        break;
    }
}

void APIPRIVATE __glim_PixelStorei(GLenum mode, GLint value)
{
    __GLpixelState *ps;
    __GL_SETUP_NOT_IN_BEGIN();

    ps = &gc->state.pixel;

    switch (mode) {
      case GL_PACK_ROW_LENGTH:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->packModes.lineLength == (GLuint) value) return;
        ps->packModes.lineLength = (GLuint) value;
        break;
      case GL_PACK_SKIP_ROWS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->packModes.skipLines == (GLuint) value) return;
        ps->packModes.skipLines = (GLuint) value;
        break;
      case GL_PACK_SKIP_PIXELS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->packModes.skipPixels == (GLuint) value) return;
        ps->packModes.skipPixels = (GLuint) value;
        break;
      case GL_PACK_ALIGNMENT:
        switch (value) {
          case 1: case 2: case 4: case 8:
            if (ps->packModes.alignment == (GLuint) value) return;
            ps->packModes.alignment = (GLuint) value;
            break;
          default:
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        break;
      case GL_PACK_SWAP_BYTES:
        if (ps->packModes.swapEndian == (value != 0)) return;
        ps->packModes.swapEndian = (value != 0);
        break;
      case GL_PACK_LSB_FIRST:
        if (ps->packModes.lsbFirst == (value != 0)) return;
        ps->packModes.lsbFirst = (value != 0);
        break;

      case GL_UNPACK_ROW_LENGTH:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->unpackModes.lineLength == (GLuint) value) return;
        ps->unpackModes.lineLength = (GLuint) value;
        break;
      case GL_UNPACK_SKIP_ROWS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->unpackModes.skipLines == (GLuint) value) return;
        ps->unpackModes.skipLines = (GLuint) value;
        break;
      case GL_UNPACK_SKIP_PIXELS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->unpackModes.skipPixels == (GLuint) value) return;
        ps->unpackModes.skipPixels = (GLuint) value;
        break;
      case GL_UNPACK_ALIGNMENT:
        switch (value) {
          case 1: case 2: case 4: case 8:
            if (ps->unpackModes.alignment == (GLuint) value) return;
            ps->unpackModes.alignment = (GLuint) value;
            break;
          default:
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        break;
      case GL_UNPACK_SWAP_BYTES:
        if (ps->unpackModes.swapEndian == (value != 0)) return;
        ps->unpackModes.swapEndian = (value != 0);
        break;
      case GL_UNPACK_LSB_FIRST:
        if (ps->unpackModes.lsbFirst == (value != 0)) return;
        ps->unpackModes.lsbFirst = (value != 0);
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/*
** Specify zoom factor that affects drawing and copying of pixel arrays
*/
void APIPRIVATE __glim_PixelZoom(GLfloat xfactor, GLfloat yfactor)
{
    __GLpixelState *ps;
    GLint xtemp, ytemp;
    __GL_SETUP_NOT_IN_BEGIN();

    ps = &gc->state.pixel;

    /* Round xfactor and yfactor to fixed point accuracy. */
    if (xfactor > 0) {
        xtemp = (GLint) ((xfactor / gc->constants.viewportEpsilon) + __glHalf);
    } else {
        xtemp = (GLint) ((xfactor / gc->constants.viewportEpsilon) - __glHalf);
    }
    if (yfactor > 0) {
        ytemp = (GLint) ((yfactor / gc->constants.viewportEpsilon) + __glHalf);
    } else {
        ytemp = (GLint) ((yfactor / gc->constants.viewportEpsilon) - __glHalf);
    }
    xfactor = xtemp * gc->constants.viewportEpsilon;
    yfactor = ytemp * gc->constants.viewportEpsilon;

    if ((ps->transferMode.zoomX == xfactor) && 
        (ps->transferMode.zoomY == yfactor)) 
        return;
    ps->transferMode.zoomX = xfactor;
    ps->transferMode.zoomY = yfactor;
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
	
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/*
** Specify modes that control the transfer of pixel arrays.
*/
void APIPRIVATE __glim_PixelTransferf(GLenum mode, GLfloat value)
{
    __GLpixelState *ps;
    __GL_SETUP_NOT_IN_BEGIN();

    ps = &gc->state.pixel;

    switch (mode) {
      case GL_RED_SCALE:
        if (ps->transferMode.r_scale == value) return;
        ps->transferMode.r_scale = value;
        break;
      case GL_GREEN_SCALE:
        if (ps->transferMode.g_scale == value) return;
        ps->transferMode.g_scale = value;
        break;
      case GL_BLUE_SCALE:
        if (ps->transferMode.b_scale == value) return;
        ps->transferMode.b_scale = value;
        break;
      case GL_ALPHA_SCALE:
        if (ps->transferMode.a_scale == value) return;
        ps->transferMode.a_scale = value;
        break;
      case GL_DEPTH_SCALE:
        if (ps->transferMode.d_scale == value) return;
        ps->transferMode.d_scale = value;
        break;
      case GL_RED_BIAS:
        if (ps->transferMode.r_bias == value) return;
        ps->transferMode.r_bias = value;
        break;
      case GL_GREEN_BIAS:
        if (ps->transferMode.g_bias == value) return;
        ps->transferMode.g_bias = value;
        break;
      case GL_BLUE_BIAS:
        if (ps->transferMode.b_bias == value) return;
        ps->transferMode.b_bias = value;
        break;
      case GL_ALPHA_BIAS:
        if (ps->transferMode.a_bias == value) return;
        ps->transferMode.a_bias = value;
        break;
      case GL_DEPTH_BIAS:
        if (ps->transferMode.d_bias == value) return;
        ps->transferMode.d_bias = value;
        break;
      case GL_INDEX_SHIFT:
      {
        GLint tmp;
        
        /* Round */
        if (value > 0) {
            tmp = (GLint) (value + __glHalf);
        } else {
            tmp = (GLint) (value - __glHalf);
        }
        if (ps->transferMode.indexShift == tmp) return;
        ps->transferMode.indexShift = tmp;
        break;
      }
      case GL_INDEX_OFFSET:
      {
        GLint tmp;
        
        /* Round */
        if (value > 0) {
            tmp = (GLint) (value - __glHalf);
        } else {
            tmp = (GLint) (value - __glHalf);
        }
        if (ps->transferMode.indexOffset == tmp) return;
        ps->transferMode.indexOffset = tmp;
        break;
      }
      case GL_MAP_COLOR:
        if (ps->transferMode.mapColor == (value != __glZero)) return;
        ps->transferMode.mapColor = (value != __glZero);
        break;
      case GL_MAP_STENCIL:
        if (ps->transferMode.mapStencil == (value != __glZero)) return;
        ps->transferMode.mapStencil = (value != __glZero);
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
    
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

void APIPRIVATE __glim_PixelTransferi( GLenum mode, GLint value)
{
    __glim_PixelTransferf(mode, (GLfloat) value);
}

/************************************************************************/

/*
** Functions to specify mapping of pixel colors and stencil values.
*/
void APIPRIVATE __glim_PixelMapfv(GLenum map, GLint mapSize,
                       const GLfloat values[])
{
    __GLpixelState *ps;
    __GLpixelMapHead *pMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
    GLfloat value;
#ifdef _MCD_
    __GLGENcontext *gengc;
#endif
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef _MCD_
    gengc = (__GLGENcontext *) gc;
#endif

    ps = &gc->state.pixel;
    pMap = ps->pixelMap;

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapI) {
            GCFREE(gc, pMap[index].base.mapI);
            pMap[index].base.mapI = 0;
        }
        pMap[index].base.mapI = (GLint*)
            GCALLOC(gc, (size_t) (mapSize * sizeof(GLint)));
        if (!pMap[index].base.mapI) {
            pMap[index].size = 0;
            return;
        }
        pMap[index].size = mapSize;
        while (--mapSize >= 0) {
            value = values[mapSize];
            if (value > 0) {            /* round! */
                pMap[index].base.mapI[mapSize] =
                    (GLint)(value + __glHalf);
            } else {
                pMap[index].base.mapI[mapSize] =
                    (GLint)(value - __glHalf);
            }
        }
#ifdef _MCD_
        if (gengc->pMcdState) {
            GenMcdPixelMap(gengc, map, mapSize,
                           (VOID *) pMap[index].base.mapI);
        }
#endif
        break;
      case GL_PIXEL_MAP_I_TO_R:
      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:
      case GL_PIXEL_MAP_I_TO_A:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
      case GL_PIXEL_MAP_R_TO_R:
      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:
      case GL_PIXEL_MAP_A_TO_A:
        if (mapSize < 0) {
            /*
            ** Maps indexed by color component must not have negative size.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapF) {
            GCFREE(gc, pMap[index].base.mapF);
            pMap[index].base.mapF = 0;
        }
        if (mapSize == 0) {
            __glInitDefaultPixelMap(gc, map);
        } else {
            pMap[index].base.mapF = (__GLfloat*)
                GCALLOC(gc,
                                      (size_t) (mapSize * sizeof(__GLfloat)));
            if (!pMap[index].base.mapF) {
                pMap[index].size = 0;
                return;
            }
            pMap[index].size = mapSize;
            while (--mapSize >= 0) {
                value = values[mapSize];
                if (value < __glZero) value = __glZero;
                else if (value > __glOne) value = __glOne;
                pMap[index].base.mapF[mapSize] = value;
            }
#ifdef _MCD_
            if (gengc->pMcdState) {
                GenMcdPixelMap(gengc, map, mapSize,
                               (VOID *) pMap[index].base.mapF);
            }
#endif
        }
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_PixelMapuiv(GLenum map, GLint mapSize,
                        const GLuint values[])
{
    __GLpixelState *ps;
    __GLpixelMapHead *pMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
#ifdef _MCD_
    __GLGENcontext *gengc;
#endif
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef _MCD_
    gengc = (__GLGENcontext *) gc;
#endif

    ps = &gc->state.pixel;
    pMap = ps->pixelMap;

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapI) {
            GCFREE(gc, pMap[index].base.mapI);
            pMap[index].base.mapI = 0;
        }
        pMap[index].base.mapI = (GLint*)
            GCALLOC(gc, (size_t) (mapSize * sizeof(GLint)));
        if (!pMap[index].base.mapI) {
            pMap[index].size = 0;
            return;
        }
        pMap[index].size = mapSize;
        while (--mapSize >= 0) {
            pMap[index].base.mapI[mapSize] = values[mapSize];
        }
#ifdef _MCD_
        if (gengc->pMcdState) {
            GenMcdPixelMap(gengc, map, mapSize,
                           (VOID *) pMap[index].base.mapI);
        }
#endif
        break;
      case GL_PIXEL_MAP_I_TO_R:
      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:
      case GL_PIXEL_MAP_I_TO_A:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
      case GL_PIXEL_MAP_R_TO_R:
      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:
      case GL_PIXEL_MAP_A_TO_A:
        if (mapSize < 0) {
            /*
            ** Maps indexed by color component must not have negative size.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapF) {
            GCFREE(gc, pMap[index].base.mapF);
            pMap[index].base.mapF = 0;
        }
        if (mapSize == 0) {
            __glInitDefaultPixelMap(gc, map);
        } else {
            pMap[index].base.mapF = (__GLfloat*)
                GCALLOC(gc, (size_t) (mapSize * sizeof(GLfloat)));
            if (!pMap[index].base.mapF) {
                pMap[index].size = 0;
                return;
            }
            pMap[index].size = mapSize;
            while (--mapSize >= 0) {
                pMap[index].base.mapF[mapSize] =
                        __GL_UI_TO_FLOAT(values[mapSize]);
            }
#ifdef _MCD_
            if (gengc->pMcdState) {
                GenMcdPixelMap(gengc, map, mapSize,
                               (VOID *) pMap[index].base.mapF);
            }
#endif
        }
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_PixelMapusv(GLenum map, GLint mapSize,
                        const GLushort values[])
{
    __GLpixelState *ps;
    __GLpixelMapHead *pMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
#ifdef _MCD_
    __GLGENcontext *gengc;
#endif
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef _MCD_
    gengc = (__GLGENcontext *) gc;
#endif

    ps = &gc->state.pixel;
    pMap = ps->pixelMap;

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapI) {
            GCFREE(gc, pMap[index].base.mapI);
            pMap[index].base.mapI = 0;
        }
        pMap[index].base.mapI = (GLint*)
            GCALLOC(gc, (size_t) (mapSize * sizeof(GLint)));
        if (!pMap[index].base.mapI) {
            pMap[index].size = 0;
            return;
        }
        pMap[index].size = mapSize;
        while (--mapSize >= 0) {
            pMap[index].base.mapI[mapSize] = values[mapSize];
        }
#ifdef _MCD_
        if (gengc->pMcdState) {
            GenMcdPixelMap(gengc, map, mapSize,
                           (VOID *) pMap[index].base.mapI);
        }
#endif
        break;
      case GL_PIXEL_MAP_I_TO_R:
      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:
      case GL_PIXEL_MAP_I_TO_A:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
      case GL_PIXEL_MAP_R_TO_R:
      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:
      case GL_PIXEL_MAP_A_TO_A:
        if (mapSize < 0) {
            /*
            ** Maps indexed by color component must not have negative size.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapF) {
            GCFREE(gc, pMap[index].base.mapF);
            pMap[index].base.mapF = 0;
        }
        if (mapSize == 0) {
            __glInitDefaultPixelMap(gc, map);
        } else {
            pMap[index].base.mapF = (__GLfloat*)
                GCALLOC(gc, (size_t) (mapSize * sizeof(GLfloat)));
            if (!pMap[index].base.mapF) {
                pMap[index].size = 0;
                return;
            }
            pMap[index].size = mapSize;
            while (--mapSize >= 0) {
                pMap[index].base.mapF[mapSize] =
                        __GL_US_TO_FLOAT(values[mapSize]);
            }
#ifdef _MCD_
            if (gengc->pMcdState) {
                GenMcdPixelMap(gengc, map, mapSize,
                               (VOID *) pMap[index].base.mapF);
            }
#endif
        }
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

/*
** Specify buffer from which pixels are read (another transfer mode).
*/
void APIPRIVATE __glim_ReadBuffer(GLenum mode)
{
    GLint i;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_FRONT:
      case GL_LEFT:
      case GL_FRONT_LEFT:
        gc->state.pixel.readBuffer = GL_FRONT;
        break;
      case GL_BACK:
      case GL_BACK_LEFT:
        if (!gc->modes.doubleBufferMode) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        gc->state.pixel.readBuffer = GL_BACK;
        break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
        i = mode - GL_AUX0;
        if (i >= gc->modes.maxAuxBuffers) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        gc->state.pixel.readBuffer = mode;
        break;
      case GL_FRONT_RIGHT:
      case GL_BACK_RIGHT:
      case GL_RIGHT:
        __glSetError(GL_INVALID_OPERATION);
        return;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    if (gc->state.pixel.readBufferReturn == mode) return;
    gc->state.pixel.readBufferReturn = mode;
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_fast.h ===
/******************************Module*Header*******************************\
* Module Name: px_fast.h                                                   *
*                                                                          *
* Fast special case code for the pixel routines                            *
*                                                                          *
* Created: 10-Oct-1995                                                     *
* Author: Drew Bliss [drewb]                                               *
*                                                                          *
* Copyright (c) 1995 Microsoft Corporation                                 *
\**************************************************************************/

#ifndef __PX_FAST_H__
#define __PX_FAST_H__

GLboolean DrawRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean StoreZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean ReadRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean ReadZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyAlignedImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyRgbToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyRgbaToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyBgrToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);

#endif // __PX_FAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_modif.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains a bunch of routines that perform span modification.
** As a span of pixel data is being processed (for DrawPixels, ReadPixels
** or CopyPixels), it usually has to pass through one of these routines.
** Span modification consists of mapping colors through pixel maps provided 
** with glPixelMap*(), or scaling/biasing/shifting/offsetting colors with the
** values provided through glPixelTransfer*().
*/

/*
** Build lookup tables to perform automatic modification of RGBA when the
** type is UNSIGNED_BYTE.
*/
void FASTCALL __glBuildRGBAModifyTables(__GLcontext *gc, __GLpixelMachine *pm)
{
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    GLint rrsize, ggsize, bbsize, aasize;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLboolean mapColor;
    __GLfloat rbias, gbias, bbias, abias;
    GLint entry;
    __GLfloat rscale, gscale, bscale, ascale;
    GLint i;
    __GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;
    pm->rgbaCurrent = GL_TRUE;

    redMap = pm->redModMap;
    if (redMap == NULL) {
	/* First time allocation of these maps */
	redMap = pm->redModMap = (GLfloat*)
	    GCALLOC(gc, 4 * 256 * sizeof(GLfloat));
        if (!pm->redModMap)
            return;
	pm->greenModMap = pm->redModMap + 1 * 256;
	pm->blueModMap  = pm->redModMap + 2 * 256;
	pm->alphaModMap = pm->redModMap + 3 * 256;
    }
    greenMap = pm->greenModMap;
    blueMap = pm->blueModMap;
    alphaMap = pm->alphaModMap;

    rbias = gc->state.pixel.transferMode.r_bias;
    gbias = gc->state.pixel.transferMode.g_bias;
    bbias = gc->state.pixel.transferMode.b_bias;
    abias = gc->state.pixel.transferMode.a_bias;
    rscale = gc->state.pixel.transferMode.r_scale;
    gscale = gc->state.pixel.transferMode.g_scale;
    bscale = gc->state.pixel.transferMode.b_scale;
    ascale = gc->state.pixel.transferMode.a_scale;
    if (mapColor) {
	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    }

    for (i=0; i<256; i++) {
	alpha = red = green = blue = i / (__GLfloat) 255.0;

	red = red * rscale + rbias;
	green = green * gscale + gbias;
	blue = blue * bscale + bbias;
	alpha = alpha * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    red = rrmap->base.mapF[entry];

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    green = ggmap->base.mapF[entry];

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    blue = bbmap->base.mapF[entry];

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    alpha = aamap->base.mapF[entry];
	} else {
	    if (red > __glOne) red = __glOne;
	    else if (red < 0) red = 0;
	    if (green > __glOne) green = __glOne;
	    else if (green < 0) green = 0;
	    if (blue > __glOne) blue = __glOne;
	    else if (blue < 0) blue = 0;
	    if (alpha > __glOne) alpha = __glOne;
	    else if (alpha < 0) alpha = 0;
	}

	redMap[i] = red * gc->frontBuffer.redScale;
	greenMap[i] = green * gc->frontBuffer.greenScale;
	blueMap[i] = blue * gc->frontBuffer.blueScale;
	alphaMap[i] = alpha * gc->frontBuffer.alphaScale;
    }
}

/*
** Build lookup tables to perform automatic modification of color index to 
** color index when the type is UNSIGNED_BYTE.
*/
void FASTCALL __glBuildItoIModifyTables(__GLcontext *gc, __GLpixelMachine *pm)
{
    GLint indexOffset, indexShift;
    __GLfloat indexScale;
    __GLpixelMapHead *iimap;
    GLint iimask;
    GLboolean mapColor;
    GLfloat *indexMap;
    GLint i;
    GLint entry;
    __GLfloat index;
    GLint mask;

    mapColor = gc->state.pixel.transferMode.mapColor;
    mask = gc->frontBuffer.redMax;
    pm->iToICurrent = GL_TRUE;

    indexMap = pm->iToIMap;
    if (indexMap == NULL) {
	indexMap = pm->iToIMap = (GLfloat*)
	    GCALLOC(gc, 256 * sizeof(GLfloat));
#ifdef NT
        if (!indexMap)
            return;
#endif
    }

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }

    if (mapColor) {
	iimap = &gc->state.pixel.
	    pixelMap[__GL_PIXEL_MAP_I_TO_I];
	iimask = iimap->size - 1;
    }

    for (i=0; i<256; i++) {
	index = i * indexScale + indexOffset;

	if (mapColor) {
	    entry = (GLint) index;
	    index = iimap->base.mapI[entry & iimask];
	}

	indexMap[i] = ((GLint) index) & mask;
    }
}

/*
** Build lookup tables to perform automatic modification of color index to 
** RGBA when the type is UNSIGNED_BYTE.
*/
void FASTCALL __glBuildItoRGBAModifyTables(__GLcontext *gc, __GLpixelMachine *pm)
{
    GLint indexOffset, indexShift;
    __GLfloat indexScale;
    __GLpixelMapHead *irmap, *igmap, *ibmap, *iamap;
    GLint irmask, igmask, ibmask, iamask;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfloat index;
    GLint entry;
    GLint i;

    pm->iToRGBACurrent = GL_TRUE;

    redMap = pm->iToRMap;
    if (redMap == NULL) {
	/* First time allocation of these maps */
	redMap = pm->iToRMap =
	    (GLfloat*) GCALLOC(gc, 4 * 256 * sizeof(GLfloat));
        if (!pm->iToRMap)
            return;
	pm->iToGMap = pm->iToRMap + 1 * 256;
	pm->iToBMap = pm->iToRMap + 2 * 256;
	pm->iToAMap = pm->iToRMap + 3 * 256;
    }
    greenMap = pm->iToGMap;
    blueMap = pm->iToBMap;
    alphaMap = pm->iToAMap;

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }

    irmap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_R];
    irmask = irmap->size - 1;
    igmap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_G];
    igmask = igmap->size - 1;
    ibmap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_B];
    ibmask = ibmap->size - 1;
    iamap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_A];
    iamask = iamap->size - 1;

    for (i=0; i<256; i++) {
	index = i * indexScale + indexOffset;
	entry = (GLint) index;

	redMap[i] = irmap->base.mapF[entry & irmask] * 
		gc->frontBuffer.redScale;
	greenMap[i] = igmap->base.mapF[entry & igmask] *
		gc->frontBuffer.greenScale;
	blueMap[i] = ibmap->base.mapF[entry & ibmask] * 
		gc->frontBuffer.blueScale;
	alphaMap[i] = iamap->base.mapF[entry & iamask] *
		gc->frontBuffer.alphaScale;
    }
}

/*
** Modify a RGBA, FLOAT span.  On the way out, the RGBA span will have 
** been modified as needed, and also scaled by the color scaling factors.
*/
void __glSpanModifyRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat rbias, gbias, bbias, abias;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLint rrsize, ggsize, bbsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
#ifdef GL_EXT_bgra
        if (spanInfo->srcFormat == GL_RGBA)
        {
            red = *oldData++ * rscale + rbias;
            green = *oldData++ * gscale + gbias;
            blue = *oldData++ * bscale + bbias;
            alpha = *oldData++ * ascale + abias;
        }
        else
        {
            blue = *oldData++ * bscale + bbias;
            green = *oldData++ * gscale + gbias;
            red = *oldData++ * rscale + rbias;
            alpha = *oldData++ * ascale + abias;
        }
#else
	red = *oldData++ * rscale + rbias;
	green = *oldData++ * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
	alpha = *oldData++ * ascale + abias;
#endif
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}

/*
** Modify a palette index, FLOAT span. On the way out, the RGBA span will have 
** been modified as needed, and also scaled by the color scaling factors.
**
** Because the palette in the span info is a pointer to the internal palette,
** it's guaranteed to always be 32-bit BGRA
*/
#ifdef GL_EXT_paletted_texture
void __glSpanModifyPI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat rbias, gbias, bbias, abias;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLint rrsize, ggsize, bbsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;
    RGBQUAD *rgb;

    mapColor = gc->state.pixel.transferMode.mapColor;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }
    // Throw in an extra scaling of 1/255 because the palette
    // data is in ubyte format
    rscale *= __glOneOver255;
    gscale *= __glOneOver255;
    bscale *= __glOneOver255;
    ascale *= __glOneOver255;

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
        rgb = &spanInfo->srcPalette[(int)((*oldData++)*
                                          spanInfo->srcPaletteSize)];
	red = rgb->rgbRed * rscale + rbias;
	green = rgb->rgbGreen * gscale + gbias;
	blue = rgb->rgbBlue * bscale + bbias;
	alpha = rgb->rgbReserved * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}
#endif

/*
** Modify a RED, FLOAT span.  On the way out, the RED span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias;
    __GLfloat rscale;
    __GLpixelMapHead *rrmap;
    GLint rrsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    green = pm->green0Mod;
    blue = pm->blue0Mod;
    alpha = pm->alpha1Mod;
    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias *
		gc->frontBuffer.redScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData++ * rscale + rbias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;

	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    *newData++ = red;
	}

	*newData++ = green;
	*newData++ = blue;
	*newData++ = alpha;
    }
}

/*
** Modify a GREEN, FLOAT span.  On the way out, the GREEN span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat gbias;
    __GLfloat gscale;
    __GLpixelMapHead *ggmap;
    GLint ggsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    red = pm->red0Mod;
    blue = pm->blue0Mod;
    alpha = pm->alpha1Mod;
    if (mapColor) {
	gbias = gc->state.pixel.transferMode.g_bias;
	gscale = gc->state.pixel.transferMode.g_scale;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
    } else {
	gbias = gc->state.pixel.transferMode.g_bias *
		gc->frontBuffer.greenScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	green = *oldData++ * gscale + gbias;
	*newData++ = red;
	if (mapColor) {
	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;
	} else {
	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    *newData++ = green;
	}

	*newData++ = blue;
	*newData++ = alpha;
    }
}

/*
** Modify a BLUE, FLOAT span.  On the way out, the BLUE span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat bbias;
    __GLfloat bscale;
    __GLpixelMapHead *bbmap;
    GLint bbsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    red = pm->red0Mod;
    green = pm->green0Mod;
    alpha = pm->alpha1Mod;
    if (mapColor) {
	bbias = gc->state.pixel.transferMode.b_bias;
	bscale = gc->state.pixel.transferMode.b_scale;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
    } else {
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	blue = *oldData++ * bscale + bbias;
	*newData++ = red;
	*newData++ = green;
	if (mapColor) {
	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;
	} else {
	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    *newData++ = blue;
	}

	*newData++ = alpha;
    }
}

/*
** Modify an ALPHA, FLOAT span.  On the way out, the ALPHA span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat abias;
    __GLfloat ascale;
    __GLpixelMapHead *aamap;
    GLint aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    red = pm->red0Mod;
    green = pm->green0Mod;
    blue = pm->blue0Mod;
    if (mapColor) {
	abias = gc->state.pixel.transferMode.a_bias;
	ascale = gc->state.pixel.transferMode.a_scale;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	alpha = *oldData++ * ascale + abias;
	*newData++ = red;
	*newData++ = green;
	*newData++ = blue;
	if (mapColor) {
	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = alpha;
	}
    }
}

/*
** Modify a RGB, FLOAT span.  On the way out, the RGB span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias, gbias, bbias;
    __GLfloat rscale, gscale, bscale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap;
    GLint rrsize, ggsize, bbsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    pm = &(gc->pixel);
    mapColor = gc->state.pixel.transferMode.mapColor;

    alpha = pm->alpha1Mod;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
#ifdef GL_EXT_bgra
        if (spanInfo->srcFormat == GL_RGB)
        {
            red = *oldData++ * rscale + rbias;
            green = *oldData++ * gscale + gbias;
            blue = *oldData++ * bscale + bbias;
        }
        else
        {
            blue = *oldData++ * bscale + bbias;
            green = *oldData++ * gscale + gbias;
            red = *oldData++ * rscale + rbias;
        }
#else
	red = *oldData++ * rscale + rbias;
	green = *oldData++ * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
#endif
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	}

	*newData++ = alpha;
    }
}

/*
** Modify a LUMINANCE, FLOAT span.  On the way out, the LUMINANCE span will 
** have been converted into a RGBA span, modified as needed, and also scaled 
** by the color scaling factors.
*/
void __glSpanModifyLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias, gbias, bbias;
    __GLfloat rscale, gscale, bscale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap;
    GLint rrsize, ggsize, bbsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    pm = &(gc->pixel);
    mapColor = gc->state.pixel.transferMode.mapColor;

    alpha = pm->alpha1Mod;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData * rscale + rbias;
	green = *oldData * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	}

	*newData++ = alpha;
    }
}

/*
** Modify a LUMINANCE_ALPHA, FLOAT span.  On the way out, the LUMINANCE_ALPHA 
** span will have been converted into a RGBA span, modified as needed, and 
** also scaled by the color scaling factors.
*/
void __glSpanModifyLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat rbias, gbias, bbias, abias;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLint rrsize, ggsize, bbsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData * rscale + rbias;
	green = *oldData * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
	alpha = *oldData++ * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}

/*
** Modify a RED_ALPHA, FLOAT span.  On the way out, the RED_ALPHA span will 
** have been converted into a RGBA span, modified as needed, and also scaled 
** by the color scaling factors.
**
** A RED_ALPHA span comes from a two component texture (where the spec 
** takes the first component from RED for some reason rather than the more
** typical recombination of r, g and b, as is done in ReadPixels).
*/
void __glSpanModifyRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias, abias;
    __GLfloat rscale, ascale;
    __GLpixelMapHead *rrmap, *aamap;
    GLint rrsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);

    green = pm->green0Mod;
    blue = pm->blue0Mod;
    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData * rscale + rbias;
	alpha = *oldData++ * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    *newData++ = green;
	    *newData++ = blue;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}

/*
** Modify a DEPTH, FLOAT span.  On the way out, the DEPTH span will have been
** modified as needed.
*/
void __glSpanModifyDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat dbias;
    __GLfloat dscale;
    GLfloat *oldData;
    GLfloat *newData;
    GLfloat d;
    GLfloat one, zero;
    GLint i;
    GLint width;

    dbias = gc->state.pixel.transferMode.d_bias;
    dscale = gc->state.pixel.transferMode.d_scale;
    one = __glOne;
    zero = __glZero;

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	d = *oldData++ * dscale + dbias;
	if (d < zero) d = zero;
	else if (d > one) d = one;
	*newData++ = d;
    }
}

/*
** Modify a STENCIL_INDEX, FLOAT span.  On the way out, the STENCIL_INDEX span 
** will have been modified as needed.
*/
void __glSpanModifyStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMapHead *ssmap;
    GLint ssmask;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLboolean mapStencil;
    __GLfloat indexScale;
    GLint indexOffset, indexShift;
    GLfloat index;

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }
    mapStencil = gc->state.pixel.transferMode.mapStencil;
    if (mapStencil) {
	ssmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_S_TO_S];
	ssmask = ssmap->size - 1;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	index = *oldData++ * indexScale + indexOffset;
	if (mapStencil) {
	    entry = (int) index;
	    *newData++ = ssmap->base.mapI[entry & ssmask];
	} else {
	    *newData++ = index;
	}
    }
}

/*
** Modify a COLOR_INDEX, FLOAT span.  On the way out, the COLOR_INDEX span 
** will have been modified as needed.
*/
void __glSpanModifyCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat indexScale;
    GLint indexOffset, indexShift;
    __GLpixelMapHead *iimap, *irmap, *igmap, *ibmap, *iamap;
    GLint iimask, irmask, igmask, ibmask, iamask;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat index;

    mapColor = gc->state.pixel.transferMode.mapColor;

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }
    if (spanInfo->dstFormat != GL_COLOR_INDEX) {
	irmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_R];
	irmask = irmap->size - 1;
	igmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_G];
	igmask = igmap->size - 1;
	ibmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_B];
	ibmask = ibmap->size - 1;
	iamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_A];
	iamask = iamap->size - 1;
    } else {
	if (mapColor) {
	    iimap = &gc->state.pixel.
		pixelMap[__GL_PIXEL_MAP_I_TO_I];
	    iimask = iimap->size - 1;
	}
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	index = *oldData++ * indexScale + indexOffset;
	entry = (int) index;
	if (spanInfo->dstFormat != GL_COLOR_INDEX) {
	    *newData++ = irmap->base.mapF[entry & irmask] * 
		    gc->frontBuffer.redScale;
	    *newData++ = igmap->base.mapF[entry & igmask] *
		    gc->frontBuffer.greenScale;
	    *newData++ = ibmap->base.mapF[entry & ibmask] * 
		    gc->frontBuffer.blueScale;
	    *newData++ = iamap->base.mapF[entry & iamask] *
		    gc->frontBuffer.alphaScale;
	} else if (mapColor) {
	    *newData++ = iimap->base.mapI[entry & iimask];
	} else {
	    *newData++ = index;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_read.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains span reading routines.  These are routines which 
** read data from the depth buffer, stencil buffer, or frame buffer
** into internal software spans.  The type of internal span that it
** is read into varies from routine to routine.
*/

/*
** A reader that reads spans into scaled a RGBA, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
#ifdef NT
    	(*gc->readBuffer->readColor)(gc->readBuffer, readX, readY, 
	    	(__GLcolor *) spanData);
#else
	(*gc->frontBuffer.readColor)(gc->readBuffer, readX, readY, 
		(__GLcolor *) spanData);
#endif

	spanData += 4;
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a scaled RGBA, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

#ifdef NT 
    (*gc->readBuffer->readSpan)(gc->readBuffer, readX, readY, 
	    (__GLcolor *) spanData, width);
#else
    (*gc->frontBuffer.readSpan)(gc->readBuffer, readX, readY, 
	    (__GLcolor *) spanData, width);
#endif
}

/*
** A reader that reads spans into a COLOR_INDEX, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		    GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLenum format;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
#ifdef NT
    	(*gc->readBuffer->readColor)(gc->readBuffer, readX, readY, 
	    	(__GLcolor *) spanData);
#else
	(*gc->frontBuffer.readColor)(gc->readBuffer, readX, readY, 
		(__GLcolor *) spanData);
#endif
	spanData++;
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a COLOR_INDEX, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		     GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
#ifdef NT
    	(*gc->readBuffer->readColor)(gc->readBuffer, readX, readY, 
	    	(__GLcolor *) spanData);
#else
	(*gc->frontBuffer.readColor)(gc->readBuffer, readX, readY, 
		(__GLcolor *) spanData);
#endif
	spanData++;
	readX++;
    }
}

/*
** A reader that reads spans into a DEPTH_COMPONENT, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;
    __GLfloat oneOverScale;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;
    oneOverScale = __glOne / gc->depthBuffer.scale;

    for (i=0; i<width; i++) {
	*spanData++ = 
		(*gc->depthBuffer.fetch)(&(gc->depthBuffer), readX, readY) *
		oneOverScale;
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a DEPTH_COMPONENT, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    __GLfloat oneOverScale;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;
    oneOverScale = __glOne / gc->depthBuffer.scale;

    for (i=0; i<width; i++) {
	*spanData++ = 
		(*gc->depthBuffer.fetch)(&(gc->depthBuffer), readX, readY) *
		oneOverScale;
	readX++;
    }
}

/*
** A reader that reads spans into a STENCIL_INDEX, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
	*spanData++ = 
	    (*gc->stencilBuffer.fetch)(&(gc->stencilBuffer), readX, readY);
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a STENCIL_INDEX, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		          GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
	*spanData++ = 
	    (*gc->stencilBuffer.fetch)(&(gc->stencilBuffer), readX, readY);
	readX++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_pack.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "imports.h"

/*
** This file contains span packers.  A span packer takes a span of source
** data, and packs its contents into the user's data space.
**
** The packer is expected to aquire information about store modes from
** the __GLpixelSpanInfo structure.
*/

void FASTCALL __glInitPacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint alignment;
    GLint lsb_first;
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint group_size;
    GLint groups_per_line;
    GLint skip_pixels, skip_lines;
    GLint swap_bytes;
    GLenum format, type;
    const GLvoid *pixels;

    format = spanInfo->dstFormat;
    type = spanInfo->dstType;
    pixels = spanInfo->dstImage;
    skip_pixels = spanInfo->dstSkipPixels;
    skip_lines = spanInfo->dstSkipLines;
    alignment = spanInfo->dstAlignment;
    lsb_first = spanInfo->dstLsbFirst;
    swap_bytes = spanInfo->dstSwapBytes;

    components = __glElementsPerGroup(format);
    groups_per_line = spanInfo->dstLineLength;

    element_size = __glBytesPerElement(type);
    if (element_size == 1) swap_bytes = 0;
    group_size = element_size * components;

    rowsize = groups_per_line * group_size;
    if (type == GL_BITMAP) {
	rowsize = (groups_per_line + 7)/8;
    }
    padding = (rowsize % alignment);
    if (padding) {
	rowsize += alignment - padding;
    }
    if (((skip_pixels & 0x7) && type == GL_BITMAP) ||
	    (swap_bytes && element_size > 1)) {
	spanInfo->dstPackedData = GL_FALSE;
    } else {
	spanInfo->dstPackedData = GL_TRUE;
    }

    if (type == GL_BITMAP) {
	spanInfo->dstCurrent = (GLvoid *) (((const GLubyte*) pixels) +
		skip_lines * rowsize + skip_pixels / 8);
	spanInfo->dstStartBit = skip_pixels % 8;
    } else {
	spanInfo->dstCurrent = (GLvoid *) (((const GLubyte*) pixels) +
		skip_lines * rowsize + skip_pixels * group_size);
    }
    spanInfo->dstRowIncrement = rowsize;
    spanInfo->dstGroupIncrement = group_size;
    spanInfo->dstComponents = components;
    spanInfo->dstElementSize = element_size;
}

/*
** Reduces and unscales a RGBA, FLOAT span into a RED, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;

    for (i=0; i<width; i++) {
	*outData++ = *inData * rs;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a GREEN, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;

    inData++;	/* Skip first red */
    for (i=0; i<width; i++) {
	*outData++ = *inData * gs;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a BLUE, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;

    inData += 2;	/* Skip first red, green */
    for (i=0; i<width; i++) {
	*outData++ = *inData * bs;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a ALPHA, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat as = gc->frontBuffer.oneOverAlphaScale;

    inData += 3;	/* Skip first red, green, blue */
    for (i=0; i<width; i++) {
	*outData++ = *inData * as;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a RGB, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;
    GLfloat red, green, blue;

    for (i=0; i<width; i++) {
	red = *inData++ * rs;
	green = *inData++ * gs;
	blue = *inData++ * bs;
	*outData++ = red;
	*outData++ = green;
	*outData++ = blue;
	inData++;
    }
}

#ifdef GL_EXT_bgra
/*
** Reduces and unscales a RGBA, FLOAT span into a BGR, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;
    GLfloat red, green, blue;

    for (i=0; i<width; i++) {
	red = *inData++ * rs;
	green = *inData++ * gs;
	blue = *inData++ * bs;
	*outData++ = blue;
	*outData++ = green;
	*outData++ = red;
	inData++;
    }
}
#endif

/*
** Reduces and unscales a RGBA, FLOAT span into a LUMINANCE, FLOAT span,
** unscaling as it goes.
*/
void __glSpanReduceLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat l, one;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;

    one = __glOne;

    for (i=0; i<width; i++) {
	l = inData[0] * rs + inData[1] * gs + inData[2] * bs;
	if (l > one) l = one;
	*outData++ = l;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a LUMINANCE_ALPHA, FLOAT span,
** unscaling as it goes.
*/
void __glSpanReduceLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat l, one;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;
    GLfloat as = gc->frontBuffer.oneOverAlphaScale;

    one = __glOne;

    for (i=0; i<width; i++) {
	l = inData[0] * rs + inData[1] * gs + inData[2] * bs;
	if (l > one) l = one;
	*outData++ = l;
	inData += 3;
	*outData++ = *inData++ * as;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a __GL_RED_ALPHA, FLOAT span,
** unscaling as it goes.
*/
void __glSpanReduceRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat r, one;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat as = gc->frontBuffer.oneOverAlphaScale;

    one = __glOne;

    for (i=0; i<width; i++) {
	*outData++ = *inData++ * rs;
	inData += 2;
	*outData++ = *inData++ * as;
    }
}

/*
** Packs to any component of type UNSIGNED_BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLubyte) UNSAFE_FTOL((*inData++) * __glVal255 + __glHalf);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any component of type BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	              GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLbyte *outData = (GLbyte *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_B(*inData++);
    }
}

/*
** Packs to any component of type UNSIGNED_SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLushort *outData = (GLushort *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLushort) UNSAFE_FTOL((*inData++) * __glVal65535 + __glHalf);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any component of type SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLshort *outData = (GLshort *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_S(*inData++);
    }
}

/*
** Packs to any component of type UNSIGNED_INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	              GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLuint *outData = (GLuint *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_UI(*inData++);
    }
}

/*
** Packs to any component of type INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	             GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLint *outData = (GLint *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_I(*inData++);
    }
}

/*
** Packs to any index of type UNSIGNED_BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLubyte *outData = (GLubyte *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLubyte) UNSAFE_FTOL(*inData++);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLbyte *outData = (GLbyte *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = UNSAFE_FTOL(*inData++) & 0x7f;
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type UNSIGNED_SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLushort *outData = (GLushort *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLushort) UNSAFE_FTOL(*inData++);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLshort *outData = (GLshort *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = UNSAFE_FTOL(*inData++) & 0x7fff;
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type UNSIGNED_INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLuint *outData = (GLuint *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = FTOL(*inData++);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	              GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLint *outData = (GLint *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = FTOL(*inData++) & 0x7fffffff;
    }

    FPU_RESTORE_MODE();
}

void __glSpanCopy(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan)
{
    GLint totalSize = spanInfo->realWidth * spanInfo->srcComponents *
	spanInfo->srcElementSize;

    __GL_MEMCOPY(outspan, inspan, totalSize);
}

/*
** Packs to any index of type BITMAP from a span of the same
** format of type FLOAT.
*/
void __glSpanPackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width;
    GLvoid *userData;
    GLfloat *spanData;
    GLint lsbFirst;
    GLint startBit;
    GLint bit;
    GLubyte ubyte, mask;

#ifdef __GL_LINT
    gc = gc;
#endif

    width = spanInfo->width;
    userData = outspan;
    spanData = (GLfloat *) inspan;

    lsbFirst = spanInfo->dstLsbFirst;
    startBit = spanInfo->dstStartBit;

    i = width;
    bit = startBit;
    ubyte = *(GLubyte *) userData;

    if (lsbFirst) {
	if (bit) {
	    switch(bit) {
	      case 1:
		if (((GLint) *spanData++) & 1) ubyte |= 0x02;
		else ubyte &= ~0x02;
		if (--i == 0) break;
	      case 2:
		if (((GLint) *spanData++) & 1) ubyte |= 0x04;
		else ubyte &= ~0x04;
		if (--i == 0) break;
	      case 3:
		if (((GLint) *spanData++) & 1) ubyte |= 0x08;
		else ubyte &= ~0x08;
		if (--i == 0) break;
	      case 4:
		if (((GLint) *spanData++) & 1) ubyte |= 0x10;
		else ubyte &= ~0x10;
		if (--i == 0) break;
	      case 5:
		if (((GLint) *spanData++) & 1) ubyte |= 0x20;
		else ubyte &= ~0x20;
		if (--i == 0) break;
	      case 6:
		if (((GLint) *spanData++) & 1) ubyte |= 0x40;
		else ubyte &= ~0x40;
		if (--i == 0) break;
	      case 7:
		if (((GLint) *spanData++) & 1) ubyte |= 0x80;
		else ubyte &= ~0x80;
		i--;
	    }
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	while (i >= 8) {
	    ubyte = 0;
	    i -= 8;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x01;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x02;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x04;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x08;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x10;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x20;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x40;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x80;
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
            mask = 0x01;
            while (i-- > 0) {
		if (((GLint) *spanData++) & 1) ubyte |= mask;
		else ubyte &= ~mask;
                mask <<= 1;
	    }
	    *(GLubyte *) userData = ubyte;
	}
    } else {
	if (bit) {
	    switch(bit) {
	      case 1:
		if (((GLint) *spanData++) & 1) ubyte |= 0x40;
		else ubyte &= ~0x40;
		if (--i == 0) break;
	      case 2:
		if (((GLint) *spanData++) & 1) ubyte |= 0x20;
		else ubyte &= ~0x20;
		if (--i == 0) break;
	      case 3:
		if (((GLint) *spanData++) & 1) ubyte |= 0x10;
		else ubyte &= ~0x10;
		if (--i == 0) break;
	      case 4:
		if (((GLint) *spanData++) & 1) ubyte |= 0x08;
		else ubyte &= ~0x08;
		if (--i == 0) break;
	      case 5:
		if (((GLint) *spanData++) & 1) ubyte |= 0x04;
		else ubyte &= ~0x04;
		if (--i == 0) break;
	      case 6:
		if (((GLint) *spanData++) & 1) ubyte |= 0x02;
		else ubyte &= ~0x02;
		if (--i == 0) break;
	      case 7:
		if (((GLint) *spanData++) & 1) ubyte |= 0x01;
		else ubyte &= ~0x01;
		i--;
	    }
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	while (i >= 8) {
	    ubyte = 0;
	    i -= 8;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x80;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x40;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x20;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x10;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x08;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x04;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x02;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x01;
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
            mask = 0x80;
            while (i-- > 0) {
		if (((GLint) *spanData++) & 1) ubyte |= mask;
		else ubyte &= ~mask;
                mask >>= 1;
            }
	    *(GLubyte *) userData = ubyte;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_paths.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "imports.h"
#include "gencx.h"
#include "px_fast.h"

// Disable long to float conversion warning.  see also context.h
#pragma warning (disable:4244)

/*
** This routine clips a draw pixels box, and sets up a bunch of 
** variables required for drawing the box.  These are some of them:
**
** startCol   - The first column that will be drawn.
** x          - Effective raster position.  This will be set up so that 
**		every time zoomx is added, a change in the integer portion
**		of x indicates that a pixel should rendered (unpacked).
** columns    - The total number of columns that will be rendered.
**
** Others are startRow, y, rows.
**
** Yet other variables may be modified, such as width, height, skipPixels,
** skipLines.
**
** The clipping routine is written very carefully so that a fragment will
** be rasterized by a pixel if it's center falls within the range
** [x, x+zoomx) x [y, y+zoomy).
*/
GLboolean FASTCALL __glClipDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint skipPixels;
    GLint skipRows;
    GLint width, height;
    GLint tempint;
    GLint endCol, endRow;
    __GLfloat x,y,x2,y2;
    __GLfloat zoomx, zoomy;
    __GLfloat clipLeft, clipRight, clipBottom, clipTop;

    zoomx = spanInfo->zoomx;
    zoomy = spanInfo->zoomy;
    if (zoomx == __glZero || zoomy == __glZero) {
	return GL_FALSE;
    }

    skipPixels = skipRows = 0;
    width = spanInfo->width;
    height = spanInfo->height;
    clipLeft = gc->transform.clipX0 + __glHalf;
    clipBottom = gc->transform.clipY0 + __glHalf;
    clipRight = gc->transform.clipX1 - gc->constants.viewportAlmostHalf;
    clipTop = gc->transform.clipY1 - gc->constants.viewportAlmostHalf;

    x = spanInfo->x;
    y = spanInfo->y;
    x2 = x + zoomx * width;
    y2 = y + zoomy * height;

    if (zoomx > 0) {
	/* Zoomx is positive, clip the left edge */
	if (x > clipLeft) {
	    /* Clip to the first fragment that will be produced */
	    clipLeft = (GLint) (x + gc->constants.viewportAlmostHalf);
	    clipLeft += __glHalf;
	}
	skipPixels = (clipLeft-x) / zoomx;
	if (skipPixels >= width) return GL_FALSE;

	width -= skipPixels;
	spanInfo->startCol = clipLeft;
	x = x + skipPixels * zoomx;
	spanInfo->x = x + gc->constants.viewportAlmostHalf;
	spanInfo->srcSkipPixels += skipPixels;

	/* Zoomx is positive, clip the right edge */
	if (x2 < clipRight) {
	    /* Clip to the last fragment that will be produced */
	    clipRight = (GLint) (x2 + gc->constants.viewportAlmostHalf);
	    clipRight -= gc->constants.viewportAlmostHalf;
	}
	tempint = (x2-clipRight) / zoomx;
	if (tempint >= width) return GL_FALSE;

	width -= tempint;
	endCol = (GLint) clipRight + 1;
	spanInfo->endCol = endCol;
	spanInfo->columns = endCol - spanInfo->startCol;
    } else /* zoomx < 0 */ {
	/* Zoomx is negative, clip the right edge */
	if (x < clipRight) {
	    /* Clip to the first fragment that will be produced */
	    clipRight = (GLint) (x + gc->constants.viewportAlmostHalf);
	    clipRight -= gc->constants.viewportAlmostHalf;
	}
	skipPixels = (clipRight-x) / zoomx;
	if (skipPixels >= width) return GL_FALSE;

	width -= skipPixels;
	spanInfo->startCol = clipRight;
	x = x + skipPixels * zoomx;
	spanInfo->x = x + gc->constants.viewportAlmostHalf - __glOne;
	spanInfo->srcSkipPixels += skipPixels;

	/* Zoomx is negative, clip the left edge */
	if (x2 > clipLeft) {
	    clipLeft = (GLint) (x2 + gc->constants.viewportAlmostHalf);
	    clipLeft += __glHalf;
	}
	tempint = (x2-clipLeft) / zoomx;
	if (tempint >= width) return GL_FALSE;

	width -= tempint;
	endCol = (GLint) clipLeft - 1;
	spanInfo->endCol = endCol;
	spanInfo->columns = spanInfo->startCol - endCol;
    }

    if (zoomy > 0) {
	/* Zoomy is positive, clip the bottom edge */
	if (y > clipBottom) {
	    /* Clip to the first row that will be produced */
	    clipBottom = (GLint) (y + gc->constants.viewportAlmostHalf);
	    clipBottom += __glHalf;
	}
	skipRows = (clipBottom-y) / zoomy;
	if (skipRows >= height) return GL_FALSE;

	height -= skipRows;
	spanInfo->startRow = clipBottom;
	y = y + skipRows * zoomy;
	spanInfo->y = y + gc->constants.viewportAlmostHalf;
	spanInfo->srcSkipLines += skipRows;

	/* Zoomy is positive, clip the top edge */
	if (y2 < clipTop) {
	    /* Clip to the last row that will be produced */
	    clipTop = (GLint) (y2 + gc->constants.viewportAlmostHalf);
	    clipTop -= gc->constants.viewportAlmostHalf;
	}
	tempint = (y2-clipTop) / zoomy;
	if (tempint >= height) return GL_FALSE;

	height -= tempint;
	endRow = (GLint) clipTop + 1;
	spanInfo->rows = endRow - spanInfo->startRow;
    } else /* zoomy < 0 */ {
	/* Zoomy is negative, clip the top edge */
	if (y < clipTop) {
	    /* Clip to the first row that will be produced */
	    clipTop = (GLint) (y + gc->constants.viewportAlmostHalf);
	    clipTop -= gc->constants.viewportAlmostHalf;
	}
	skipRows = (clipTop-y) / zoomy;
	if (skipRows >= height) return GL_FALSE;

	height -= skipRows;
	spanInfo->startRow = clipTop;
	y = y + skipRows * zoomy;
	/* spanInfo->y = y - __glHalf; */
	spanInfo->y = y + gc->constants.viewportAlmostHalf - __glOne;
	spanInfo->srcSkipLines += skipRows;

	/* Zoomy is negative, clip the bottom edge */
	if (y2 > clipBottom) {
	    clipBottom = (GLint) (y2 + gc->constants.viewportAlmostHalf);
	    clipBottom += __glHalf;
	}
	tempint = (y2-clipBottom) / zoomy;
	if (tempint >= height) return GL_FALSE;

	height -= tempint;
	endRow = (GLint) clipBottom - 1;
	spanInfo->rows = spanInfo->startRow - endRow;
    }

    spanInfo->width = width;
    spanInfo->height = height;

    if (zoomx < 0) zoomx = -zoomx;
    if (zoomx >= 1) {
	spanInfo->realWidth = width;
    } else {
	spanInfo->realWidth = spanInfo->columns;
    }

    return GL_TRUE;
}

/*
** This routine computes spanInfo->pixelArray if needed.
**
** If |zoomx| > 1.0, this array contains counts for how many times to 
** replicate a given pixel.  For example, if zoomx is 2.0, this array will
** contain all 2's.  If zoomx is 1.5, then every other entry will contain 
** a 2, and every other entry will contain a 1.
**
** if |zoomx| < 1.0, this array contains counts for how many pixels to 
** skip.  For example, if zoomx is 0.5, every entry in the array will contain
** a 2 (indicating to skip forward two pixels [only past one]).  If zoomx is
** .666, then every other entry will be a 2, and every other entry will be 
** a 1.
*/
void FASTCALL __glComputeSpanPixelArray(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint width, intx;
    __GLfloat zoomx, oldx, newx;
    GLint i;
    GLshort *array;
    
    zoomx = spanInfo->zoomx;
    if (zoomx > (__GLfloat) -1.0 && zoomx < __glOne) {
	GLint lasti;

	/* Build pixel skip array */
	width = spanInfo->width;
	oldx = spanInfo->x;
	array = spanInfo->pixelArray;

	intx = (GLint) oldx;
	newx = oldx;

	lasti = 0;
	for (i=0; i<width; i++) {
	    /* Skip groups which will not be rasterized */
	    newx += zoomx;
	    while ((GLint) newx == intx && i<width) {
		newx += zoomx;
		i++;
	    }
	    ASSERTOPENGL(i != width, "Pixel skip array overflow\n");
	    if (i != 0) {
		*array++ = (GLshort) (i - lasti);
	    }
	    lasti = i;
	    intx = (GLint) newx;
	}
	*array++ = 1;
    } else if (zoomx < (__GLfloat) -1.0 || zoomx > __glOne) {
	__GLfloat right;
	GLint iright;
	GLint coladd, column;
	GLint startCol;

	/* Build pixel replication array */
	width = spanInfo->realWidth - 1;
	startCol = spanInfo->startCol;
	column = startCol;
	coladd = spanInfo->coladd;
	array = spanInfo->pixelArray;
	right = spanInfo->x;
	for (i=0; i<width; i++) {
	    right = right + zoomx;
	    iright = right;
	    *array++ = (GLshort) (iright - column);
	    column = iright;
	}
	if (coladd == 1) {
	    *array++ = (GLshort) (spanInfo->columns - (column - startCol));
	} else {
	    *array++ = (GLshort) ((startCol - column) - spanInfo->columns);
	}
    }
}

/*
** Initialize the spanInfo structure.  If "packed" is true, the structure
** is initialized for unpacking data from a display list.  If "packed" is 
** false, it is initialized for unpacking data from the user's data space.
*/
void FASTCALL __glLoadUnpackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLboolean packed)
{

    if (packed) {
	/*
	** Data came from a display list.
	*/

	spanInfo->srcAlignment = 1;
	spanInfo->srcSkipPixels = 0;
	spanInfo->srcSkipLines = 0;
	spanInfo->srcLsbFirst = GL_FALSE;
	spanInfo->srcSwapBytes = GL_FALSE;
	spanInfo->srcLineLength = spanInfo->width;
    } else {
	GLint lineLength;

	/*
	** Data came straight from the application.
	*/

	lineLength = gc->state.pixel.unpackModes.lineLength;
	spanInfo->srcAlignment = gc->state.pixel.unpackModes.alignment;
	spanInfo->srcSkipPixels = gc->state.pixel.unpackModes.skipPixels;
	spanInfo->srcSkipLines = gc->state.pixel.unpackModes.skipLines;
	spanInfo->srcLsbFirst = gc->state.pixel.unpackModes.lsbFirst;
	spanInfo->srcSwapBytes = gc->state.pixel.unpackModes.swapEndian;
#ifdef NT
/* XXX! kluge? (mf) : Since the routines that unpack incoming data from
	  glTexImage commands use spanInfo->realWidth to determine how
	  much to unpack, set this approppriately when lineLength > 0
*/
	if (lineLength <= 0)
	    lineLength = spanInfo->width;
	else
	    spanInfo->realWidth = lineLength; /* otherwise, use value for
					realWidth already set */
#else
	if (lineLength <= 0) lineLength = spanInfo->width;
#endif
	spanInfo->srcLineLength = lineLength;
    }
}

void __glInitDrawPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLint width, GLint height, GLenum format, 
			    GLenum type, const GLvoid *pixels)
{
    __GLfloat x,y;
    __GLfloat zoomx, zoomy;

    x = gc->state.current.rasterPos.window.x;
    y = gc->state.current.rasterPos.window.y;

    spanInfo->x = x;
    spanInfo->y = y;
    spanInfo->fragz = gc->state.current.rasterPos.window.z;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx > __glZero) {
	if (zoomx < __glOne) {
	    spanInfo->rendZoomx = __glOne;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = 1;
    } else {
	if (zoomx > (GLfloat) -1.0) {
	    spanInfo->rendZoomx = (GLfloat) -1.0;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = -1;
    }
    spanInfo->zoomx = zoomx;
    zoomy = gc->state.pixel.transferMode.zoomY;
    if (gc->constants.yInverted) {
	zoomy = -zoomy;
    }
    if (zoomy > __glZero) {
	spanInfo->rowadd = 1;
    } else {
	spanInfo->rowadd = -1;
    }
    spanInfo->zoomy = zoomy;
    spanInfo->width = width;
    spanInfo->height = height;
    if (format == GL_COLOR_INDEX && gc->modes.rgbMode) {
	spanInfo->dstFormat = GL_RGBA;
    } else {
	spanInfo->dstFormat = format;
    }
    spanInfo->srcFormat = format;
    spanInfo->srcType = type;
    spanInfo->srcImage = pixels;
}

/*
** This is the generic DrawPixels routine.  It applies four span modification
** routines followed by a span rendering routine.
*/
void FASTCALL __glDrawPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height, width;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    width = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, width);
    spanData2 = gcTempAlloc(gc, width);
    width = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, width);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glDrawPixels4_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    width = spanInfo->width;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*render)(gc, spanInfo, spanData2);
    }
#ifdef NT
__glDrawPixels4_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/*
** This is the generic DrawPixels routine.  It applies three span modification
** routines followed by a span rendering routine.
*/
void FASTCALL __glDrawPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height, width;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT		   
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    width = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, width);
    spanData2 = gcTempAlloc(gc, width);
    width = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, width);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glDrawPixels3_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    width = spanInfo->width;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*render)(gc, spanInfo, spanData1);
    }
#ifdef NT
__glDrawPixels3_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/*
** This is the generic DrawPixels routine.  It applies two span modification
** routines followed by a span rendering routine.
*/
void FASTCALL __glDrawPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height, width;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    width = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, width);
    spanData2 = gcTempAlloc(gc, width);
    width = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, width);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glDrawPixels2_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    width = spanInfo->width;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*render)(gc, spanInfo, spanData2);
    }
#ifdef NT
__glDrawPixels2_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** Draw pixels with only one span modification routine.
*/
void FASTCALL __glDrawPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1;
    GLshort *pixelArray;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    pixelArray = gcTempAlloc(gc, spanInfo->width * sizeof(GLshort));
    if (!spanData1 || !pixelArray)
        goto __glDrawPixels1_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*render)(gc, spanInfo, spanData1);
    }
#ifdef NT
__glDrawPixels1_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** Draw pixels with no span modification routines.
*/
void FASTCALL __glDrawPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height;
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLshort *pixelArray;

    pixelArray = gcTempAlloc(gc, spanInfo->width * sizeof(GLshort));
    if (!pixelArray)
        return;
#else
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*render)(gc, spanInfo, spanInfo->srcCurrent);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
    }
#ifdef NT
    gcTempFree(gc, pixelArray);
#endif
}

/*
** Generic implementation of a DrawPixels picker.  Any machine specific
** implementation should provide their own.
*/
void __glSlowPickDrawPixels(__GLcontext *gc, GLint width, GLint height,
		            GLenum format, GLenum type, const GLvoid *pixels,
			    GLboolean packed)
{
    __GLpixelSpanInfo spanInfo;
    
    __glInitDrawPixelsInfo(gc, &spanInfo, width, height, format, type, pixels);
    __glLoadUnpackModes(gc, &spanInfo, packed);
    if (!__glClipDrawPixels(gc, &spanInfo)) return;

    __glInitUnpacker(gc, &spanInfo);

    __glGenericPickDrawPixels(gc, &spanInfo);
}

/*
** Generic picker for DrawPixels.  This should be called if no machine
** specific path is provided for this specific version of DrawPixels.
*/
void FASTCALL __glGenericPickDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLpixelMachine *pm;
    void (FASTCALL *dpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
    GLint spanCount;
    GLboolean zoomx1;		/* -1 <= zoomx <= 1? */
    GLboolean zoomx2;		/* zoomx <= -1 || zoomx >= 1 */
    __GLfloat zoomx;
    GLboolean packedUserData;
    GLenum type, format;
    GLboolean skip;
    GLboolean swap;
    GLboolean align;
    GLboolean convert;
    GLboolean expand;
    GLboolean clamp;

    spanCount = 0;
    pm = &gc->pixel;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx >= (__GLfloat) -1.0 && zoomx <= __glOne) {
	zoomx1 = GL_TRUE;
    } else {
	zoomx1 = GL_FALSE;
    }
    if (zoomx <= (__GLfloat) -1.0 || zoomx >= __glOne) {
	zoomx2 = GL_TRUE;
    } else {
	zoomx2 = GL_FALSE;
    }

    packedUserData = spanInfo->srcPackedData && zoomx2;
    type = spanInfo->srcType;
    format = spanInfo->srcFormat;

    if (spanInfo->srcSwapBytes && spanInfo->srcElementSize > 1) {
	swap = GL_TRUE;
    } else {
	swap = GL_FALSE;
    }
    if (zoomx2 || type == GL_BITMAP) {
	skip = GL_FALSE;
    } else {
	skip = GL_TRUE;
    }
    if (type != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->srcImage)) & (spanInfo->srcElementSize - 1))) {
	align = GL_TRUE;
    } else {
	align = GL_FALSE;
    }
    if (type == GL_FLOAT || type == GL_BITMAP) {
	convert = GL_FALSE;
    } else {
	convert = GL_TRUE;
    }
    /*
    ** Clamp types only if index or not modifying (because converting
    ** float types means clamping, and that is only done if not modifying),
    ** and only if they might need clamping (UNSIGNED types never do).
    */
    if (type == GL_BITMAP || type == GL_UNSIGNED_BYTE || 
	    type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT ||
	    format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX ||
	    (format == GL_DEPTH_COMPONENT && pm->modifyDepth) ||
	    (format != GL_DEPTH_COMPONENT && pm->modifyRGBA)) {
	clamp = GL_FALSE;
    } else {
	clamp = GL_TRUE;
    }
	    
#ifdef NT
    // Special case RGB drawing to use a DIB
    // Also special case loading the Z buffer
    if (format == GL_RGB || format == GL_BGR_EXT || format == GL_BGRA_EXT)
    {
        GLuint enables = gc->state.enables.general;
    
        // If the input is unsigned bytes with DWORD aligned scanlines
        // and no unusual lengths, then it's almost compatible with
        // a 24-bit RGB DIB.  The only problem is that OpenGL sees
        // it as BGR so the bytes need to be swapped.  Since we need to
        // copy the data to swap the bytes, we adjust line lengths and
        // alignment then, allowing nearly any unsigned byte input format
        //
        // Other things that can't be allowed are depth testing,
        // fogging, blending or anything that prevents the input data
        // from going directly into the destination buffer

        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            type == GL_UNSIGNED_BYTE &&
            !pm->modifyRGBA &&
            (enables & (__GL_DITHER_ENABLE |
                        __GL_ALPHA_TEST_ENABLE |
                        __GL_STENCIL_TEST_ENABLE |
                        __GL_DEPTH_TEST_ENABLE |
                        __GL_BLEND_ENABLE |
                        __GL_INDEX_LOGIC_OP_ENABLE |
                        __GL_COLOR_LOGIC_OP_ENABLE |
                        __GL_FOG_ENABLE)) == 0 &&
            gc->state.raster.drawBuffer != GL_NONE &&
            gc->state.raster.drawBuffer != GL_FRONT_AND_BACK &&
            !gc->texture.textureEnabled &&
            (gc->drawBuffer->buf.flags & COLORMASK_ON) == 0
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (DrawRgbPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
    else if (format == GL_DEPTH_COMPONENT)
    {
        // If the Z test is GL_ALWAYS and there is no draw buffer
        // then the application is simply loading Z values into
        // the Z buffer.
        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            !swap &&
            (type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT) &&
            !pm->modifyDepth &&
            gc->state.raster.drawBuffer == GL_NONE &&
            (gc->state.enables.general & __GL_DEPTH_TEST_ENABLE) &&
            gc->state.depth.testFunc == GL_ALWAYS &&
            gc->modes.haveDepthBuffer
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (StoreZPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif
    
    /* 
    ** First step:  convert data into a packed readable format 
    ** (RED, BYTE), (LUMINANCE, UNSIGNED_INT), etc...  This stage
    ** simply packs the user's data, but performs no conversion on it.
    **
    ** Packing can consist of:
    **  - aligning the data
    **  - skipping pixels if |xzoom| is < 1
    **  - swapping bytes if necessary
    */
    if (swap) {
	if (skip) {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanSwapAndSkipBytes2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanSwapAndSkipBytes4;
	    }
	} else {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4;
	    }
	}
    } else if (align) {
	if (skip) {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = __glSpanSlowSkipPixels2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = __glSpanSlowSkipPixels4;
	    }
	} else {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4;
	    }
	}
    } else if (skip) {
	if (spanInfo->srcElementSize == 1) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSkipPixels1;
	} else if (spanInfo->srcElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSkipPixels2;
	} else /* spanInfo->srcElementSize == 4 */ {
	    spanInfo->spanModifier[spanCount++] = __glSpanSkipPixels4;
	}
    }

    /* 
    ** Second step:  conversion to float
    ** All formats are converted into floating point (including GL_BITMAP).
    */
    if (convert) {
	if (format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX) {
	    /* Index conversion */
	    switch(type) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackByteI;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyteI;
		break;
	      case GL_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackShortI;
		break;
	      case GL_UNSIGNED_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshortI;
		break;
	      case GL_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackIntI;
		break;
	      case GL_UNSIGNED_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUintI;
		break;
	    }
	} else {
	    /* Component conversion */
	    switch(type) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackByte;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyte;
		break;
	      case GL_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackShort;
		break;
	      case GL_UNSIGNED_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshort;
		break;
	      case GL_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackInt;
		break;
	      case GL_UNSIGNED_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUint;
		break;
	    }
	}
    }

    if (clamp) {
	switch(type) {
	  case GL_BYTE:
	  case GL_SHORT:
	  case GL_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanClampSigned;
	    break;
	  case GL_FLOAT:
	    spanInfo->spanModifier[spanCount++] = __glSpanClampFloat;
	    break;
	}
    }

    if (type == GL_BITMAP) {
	if (zoomx2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap2;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap;
	}
    }

    /* 
    ** Third step:  Modification and color scaling
    **
    ** Spans are modified if necessary (color biasing, maps, shift,
    ** scale), and RGBA colors are scaled.  Also, all RGBA derivative
    ** formats (RED, LUMINANCE, ALPHA, etc.) are converted to RGBA.
    ** The only four span formats that survive this stage are:
    **
    ** (COLOR_INDEX, FLOAT),
    ** (STENCIL_INDEX, FLOAT),
    ** (DEPTH_COMPONENT, FLOAT),
    ** (RGBA, FLOAT),
    */

    switch(format) {
      case GL_RED:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRed;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandRed;
	}
	break;
      case GL_GREEN:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyGreen;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandGreen;
	}
	break;
      case GL_BLUE:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyBlue;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandBlue;
	}
	break;
      case GL_ALPHA:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyAlpha;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandAlpha;
	}
	break;
      case GL_RGB:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandRGB;
	}
	break;
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
	if (pm->modifyRGBA) {
            // __glSpanModifyRGB handles both RGB and BGR
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandBGR;
	}
	break;
#endif
      case GL_LUMINANCE:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyLuminance;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandLuminance;
	}
	break;
      case GL_LUMINANCE_ALPHA:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyLuminanceAlpha;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandLuminanceAlpha;
	}
	break;
      case GL_RGBA:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanScaleRGBA;
	}
	break;
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
	if (pm->modifyRGBA) {
            // __glSpanModifyRGBA handles both RGBA and BGRA
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanScaleBGRA;
	}
	break;
#endif
      case GL_DEPTH_COMPONENT:
	if (pm->modifyDepth) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	} 
	break;
      case GL_STENCIL_INDEX:
	if (pm->modifyStencil) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	} 
	break;
      case GL_COLOR_INDEX:
	if (pm->modifyCI) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	} 
	break;
    }

    /*
    ** Fourth step:  Rendering
    **
    ** The spans are rendered.  If |xzoom| > 1, then the span renderer
    ** is responsible for pixel replication.
    */

    switch(spanInfo->dstFormat) {
      case GL_RGBA:
      case GL_RGB:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderRGBA2;
	} else {
	    render = gc->procs.pixel.spanRenderRGBA;
	}
	break;
      case GL_DEPTH_COMPONENT:
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderDepth2;
	} else {
	    render = gc->procs.pixel.spanRenderDepth;
	}
	break;
      case GL_COLOR_INDEX:
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderCI2;
	} else {
	    render = gc->procs.pixel.spanRenderCI;
	}
	break;
      case GL_STENCIL_INDEX:
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderStencil2;
	} else {
	    render = gc->procs.pixel.spanRenderStencil;
	}
	break;
    }

    /*
    ** Optimization attempt.
    **
    ** There are some format, type combinations that are expected to be 
    ** common.  This code optimizes a few of those cases.  Specifically,
    ** these modes include:  (GL_UNSIGNED_BYTE, GL_RGB), 
    ** (GL_UNSIGNED_BYTE, GL_RGBA), (GL_UNSIGNED_BYTE, GL_COLOR_INDEX),
    ** (GL_UNSIGNED_BYTE, GL_STENCIL_INDEX), 
    ** (GL_UNSIGNED_SHORT, GL_COLOR_INDEX), 
    ** (GL_UNSIGNED_SHORT, GL_STENCIL_INDEX),
    ** (GL_UNSIGNED_INT, GL_DEPTH_COMPONENT)
    */

    switch(type) {
      case GL_UNSIGNED_BYTE:
	switch(format) {
	  case GL_RGB:
	    spanCount = 0;
	    if (packedUserData) {
		/* no span unpacking is necessary! */
	    } else {
		/* zoomx2 must not be true, or packedUserData would be set 
		*/
		ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackRGBubyte;
	    }
	    if (!pm->modifyRGBA) {
		pm->redCurMap = pm->redMap;
		pm->greenCurMap = pm->greenMap;
		pm->blueCurMap = pm->blueMap;
		pm->alphaCurMap = pm->alphaMap;
		if (zoomx1) {
		    render = __glSpanRenderRGBubyte2;
		} else {
		    render = __glSpanRenderRGBubyte;
		}
	    } else {
		if (!pm->rgbaCurrent) {
		    __glBuildRGBAModifyTables(gc, pm);
		}
		pm->redCurMap = pm->redModMap;
		pm->greenCurMap = pm->greenModMap;
		pm->blueCurMap = pm->blueModMap;
		pm->alphaCurMap = pm->alphaModMap;
		if (zoomx1) {
		    render = __glSpanRenderRGBubyte2;
		} else {
		    render = __glSpanRenderRGBubyte;
		}
	    }
	    break;
	  case GL_RGBA:
	    spanCount = 0;
	    if (packedUserData) {
		/* no span unpacking is necessary! */
	    } else {
		/* zoomx2 must not be true, or packedUserData would be set 
		*/
		ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackRGBAubyte;
	    }
	    if (!pm->modifyRGBA) {
		pm->redCurMap = pm->redMap;
		pm->greenCurMap = pm->greenMap;
		pm->blueCurMap = pm->blueMap;
		pm->alphaCurMap = pm->alphaMap;
	    } else {
		if (!pm->rgbaCurrent) {
		    __glBuildRGBAModifyTables(gc, pm);
		}
		pm->redCurMap = pm->redModMap;
		pm->greenCurMap = pm->greenModMap;
		pm->blueCurMap = pm->blueModMap;
		pm->alphaCurMap = pm->alphaModMap;
	    }
	    if (zoomx1) {
		render = __glSpanRenderRGBAubyte2;
	    } else {
		render = __glSpanRenderRGBAubyte;
	    }
	    break;
	  case GL_STENCIL_INDEX:
	    if (!pm->modifyStencil) {
		spanCount = 0;
		if (packedUserData) {
		    /* no span unpacking is necessary! */
		} else {
		    /* zoomx2 must not be true, or packedUserData would be set 
		    */
                    ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		    spanInfo->spanModifier[spanCount++] = 
			    __glSpanUnpackIndexUbyte;
		}
		if (zoomx1) {
		    render = __glSpanRenderStencilUbyte2;
		} else {
		    render = __glSpanRenderStencilUbyte;
		}
	    }
	    break;
	  case GL_COLOR_INDEX:
	    spanCount = 0;
	    if (packedUserData) {
		/* no span unpacking is necessary! */
	    } else {
		/* zoomx2 must not be true, or packedUserData would be set 
		*/
		ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		spanInfo->spanModifier[spanCount++] = 
			__glSpanUnpackIndexUbyte;
	    }
	    if (!pm->modifyCI) {
		pm->iCurMap = pm->iMap;
		if (zoomx1) {
		    render = __glSpanRenderCIubyte2;
		} else {
		    render = __glSpanRenderCIubyte;
		}
	    } else {
		if (gc->modes.rgbMode) {
		    if (!pm->iToRGBACurrent) {
			__glBuildItoRGBAModifyTables(gc, pm);
		    }
		    pm->redCurMap = pm->iToRMap;
		    pm->greenCurMap = pm->iToGMap;
		    pm->blueCurMap = pm->iToBMap;
		    pm->alphaCurMap = pm->iToAMap;
		    if (zoomx1) {
			render = __glSpanRenderCIubyte4;
		    } else {
			render = __glSpanRenderCIubyte3;
		    }
		} else {
		    if (!pm->iToICurrent) {
			__glBuildItoIModifyTables(gc, pm);
		    }
		    pm->iCurMap = pm->iToIMap;
		    if (zoomx1) {
			render = __glSpanRenderCIubyte2;
		    } else {
			render = __glSpanRenderCIubyte;
		    }
		}
	    }
	    break;
	  default:
	    break;
	}
	break;
      case GL_UNSIGNED_SHORT:
	switch(format) {
	  case GL_STENCIL_INDEX:
	    if (!pm->modifyStencil) {
		/* Back off conversion to float */
		ASSERTOPENGL(convert, "convert not set\n");
		spanCount--;
		if (zoomx1) {
		    render = __glSpanRenderStencilUshort2;
		} else {
		    render = __glSpanRenderStencilUshort;
		}
	    }
	    break;
	  case GL_COLOR_INDEX:
	    if (!pm->modifyCI) {
		/* Back off conversion to float */
		ASSERTOPENGL(convert, "convert not set\n");
		spanCount--;
		if (zoomx1) {
		    render = __glSpanRenderCIushort2;
		} else {
		    render = __glSpanRenderCIushort;
		}
	    }
	    break;
	  default:
	    break;
	}
	break;
      case GL_UNSIGNED_INT:
	switch(format) {
	  case GL_DEPTH_COMPONENT:
	    if (!pm->modifyDepth) {
		if (gc->depthBuffer.scale == 0xffffffff) {
                    // XXX we never set depthBuffer.scale to 0xffffffff in NT!
                    // XXX write optimize code for 16-bit z buffers?
		    /* Back off conversion to float */
                    ASSERTOPENGL(convert, "convert not set\n");
		    spanCount--;

		    if (zoomx1) {
			render = __glSpanRenderDepthUint2;
		    } else {
			render = __glSpanRenderDepthUint;
		    }
		} else if (gc->depthBuffer.scale == 0x7fffffff) {
		    /* Back off conversion to float */
                    ASSERTOPENGL(convert, "convert not set\n");
		    spanCount--;

		    if (zoomx1) {
			render = __glSpanRenderDepth2Uint2;
		    } else {
			render = __glSpanRenderDepth2Uint;
		    }
		}
	    }
	    break;
	  default:
	    break;
	}
	break;
      default:
	break;
    }

    /*
    ** Pick a DrawPixels function that applies the correct number of 
    ** span modifiers.
    */

    switch(spanCount) {
      case 0:
	dpfn = __glDrawPixels0;
	break;
      case 1:
	dpfn = __glDrawPixels1;
	break;
      case 2:
	dpfn = __glDrawPixels2;
	break;
      case 3:
	dpfn = __glDrawPixels3;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 4:
	dpfn = __glDrawPixels4;
	break;
    }
    spanInfo->spanRender = render;
    (*dpfn)(gc, spanInfo);
}

/*
** This routine clips ReadPixels calls so that only fragments which are
** owned by this context will be read and copied into the user's data.
** Parts of the ReadPixels rectangle lying outside of the window will
** be ignored.
*/
GLboolean FASTCALL __glClipReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint clipLeft, clipRight, clipTop, clipBottom;
    GLint x,y,x2,y2;
    GLint skipPixels, skipRows;
    GLint width, height;
    GLint tempint;
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GLGENwindow *pwnd = gengc->pwndLocked;

    width = spanInfo->width;
    height = spanInfo->height;
    x = spanInfo->readX;
    y = spanInfo->readY;
    x2 = x + spanInfo->width;
    if (gc->constants.yInverted) {
	y2 = y - spanInfo->height;
    } else {
	y2 = y + spanInfo->height;
    }
    if (pwnd &&
        (pwnd->rclBounds.left < pwnd->rclBounds.right) &&
        (pwnd->rclBounds.top < pwnd->rclBounds.bottom)) {

        clipLeft   = (pwnd->rclBounds.left - pwnd->rclClient.left)
                     + gc->constants.viewportXAdjust;
        clipRight  = (pwnd->rclBounds.right - pwnd->rclClient.left)
                     + gc->constants.viewportXAdjust;

        if (gc->constants.yInverted) {
            clipBottom = (pwnd->rclBounds.top - pwnd->rclClient.top)
                         + gc->constants.viewportYAdjust;
            clipTop    = (pwnd->rclBounds.bottom - pwnd->rclClient.top)
                         + gc->constants.viewportYAdjust;
        } else {
            clipBottom = (gc->constants.height -
                          (pwnd->rclBounds.bottom - pwnd->rclClient.top))
                         + gc->constants.viewportYAdjust;
            clipTop    = (gc->constants.height -
                          (pwnd->rclBounds.top - pwnd->rclClient.top))
                         + gc->constants.viewportYAdjust;
        }
    } else {
        clipLeft   = gc->constants.viewportXAdjust;
        clipRight  = gc->constants.viewportXAdjust;
        clipBottom = gc->constants.viewportYAdjust;
        clipTop    = gc->constants.viewportYAdjust;
    }
    skipPixels = 0;
    skipRows = 0;
    if (x < clipLeft) {
	skipPixels = clipLeft - x;
	if (skipPixels > width) return GL_FALSE;

	width -= skipPixels;
	x = clipLeft;
	spanInfo->dstSkipPixels += skipPixels;
	spanInfo->readX = x;
    }
    if (x2 > clipRight) {
	tempint = x2 - clipRight;
	if (tempint > width) return GL_FALSE;

	width -= tempint;
    }
    if (gc->constants.yInverted) {
	if (y >= clipTop) {
	    skipRows = y - clipTop + 1;
	    if (skipRows > height) return GL_FALSE;

	    height -= skipRows;
	    y = clipTop - 1;
	    spanInfo->dstSkipLines += skipRows;
	    spanInfo->readY = y;
	}
	if (y2 < clipBottom - 1) {
	    tempint = clipBottom - y2 - 1;
	    if (tempint > height) return GL_FALSE;

	    height -= tempint;
	}
    } else {
	if (y < clipBottom) {
	    skipRows = clipBottom - y;
	    if (skipRows > height) return GL_FALSE;

	    height -= skipRows;
	    y = clipBottom;
	    spanInfo->dstSkipLines += skipRows;
	    spanInfo->readY = y;
	}
	if (y2 > clipTop) {
	    tempint = y2 - clipTop;
	    if (tempint > height) return GL_FALSE;

	    height -= tempint;
	}
    }

    spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->realWidth = width;

    return GL_TRUE;
}

/*
** Initialize the spanInfo structure for packing data into the user's data
** space.
*/
void FASTCALL __glLoadPackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint lineLength = gc->state.pixel.packModes.lineLength;

    spanInfo->dstAlignment = gc->state.pixel.packModes.alignment;
    spanInfo->dstSkipPixels = gc->state.pixel.packModes.skipPixels;
    spanInfo->dstSkipLines = gc->state.pixel.packModes.skipLines;
    spanInfo->dstLsbFirst = gc->state.pixel.packModes.lsbFirst;
    spanInfo->dstSwapBytes = gc->state.pixel.packModes.swapEndian;
    if (lineLength <= 0) lineLength = spanInfo->width;
    spanInfo->dstLineLength = lineLength;
}

void __glInitReadPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLint x, GLint y, GLint width, GLint height, 
			    GLenum format, GLenum type, const GLvoid *pixels)
{
    spanInfo->readX = x + gc->constants.viewportXAdjust;
    if (gc->constants.yInverted) {
	spanInfo->readY = (gc->constants.height - y - 1) + 
		gc->constants.viewportYAdjust;
    } else {
	spanInfo->readY = y + gc->constants.viewportYAdjust;
    }
    spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->dstFormat = format;
    spanInfo->dstType = type;
    spanInfo->dstImage = pixels;
    spanInfo->zoomx = __glOne;
    spanInfo->x = __glZero;
    __glLoadPackModes(gc, spanInfo);
}

/*
** A simple generic ReadPixels routine with five span modifiers.
*/
void FASTCALL __glReadPixels5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels5_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*span3)(gc, spanInfo, spanData1, spanData2);
	(*span4)(gc, spanInfo, spanData2, spanData1);
	(*span5)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels5_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with three span modifiers.
*/
void FASTCALL __glReadPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels4_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*span3)(gc, spanInfo, spanData1, spanData2);
	(*span4)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels4_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with four span modifiers.
*/
void FASTCALL __glReadPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels3_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*span3)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels3_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with two span modifiers.
*/
void FASTCALL __glReadPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels2_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels2_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with one span modifier.
*/
void FASTCALL __glReadPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    if (!spanData1)
        return;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
    gcTempFree(gc, spanData1);
#endif
}

/*
** A simple generic ReadPixels routine with no span modifiers.
*/
void FASTCALL __glReadPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);

    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
}

/*
** Generic implementation of a ReadPixels picker.  Any machine specific
** implementation should provide their own.
*/
void __glSlowPickReadPixels(__GLcontext *gc, GLint x, GLint y,
		            GLsizei width, GLsizei height,
		            GLenum format, GLenum type, const GLvoid *pixels)
{
    __GLpixelSpanInfo spanInfo;

    __glInitReadPixelsInfo(gc, &spanInfo, x, y, width, height, format, 
	    type, pixels);
    if (!__glClipReadPixels(gc, &spanInfo)) return;

    __glInitPacker(gc, &spanInfo);

    __glGenericPickReadPixels(gc, &spanInfo);
}

/*
** Generic picker for ReadPixels.  This should be called if no machine
** specific path is provided for this specific version of ReadPixels.
*/
void FASTCALL __glGenericPickReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLpixelMachine *pm;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *rpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
    GLint spanCount;
    GLenum type, format;
    GLboolean isIndex;

    spanCount = 0;

    type = spanInfo->dstType;
    format = spanInfo->dstFormat;
    pm = &gc->pixel;

#ifdef NT
    // Special case RGB reading to use a DIB
    // Also special case reading the Z buffer
    if (format == GL_RGB || format == GL_BGR_EXT || format == GL_BGRA_EXT)
    {
        GLuint enables = gc->state.enables.general;
    
        if (type == GL_UNSIGNED_BYTE &&
            !pm->modifyRGBA &&
            gc->state.pixel.transferMode.indexShift == 0 &&
            gc->state.pixel.transferMode.indexOffset == 0
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (ReadRgbPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
    else if (format == GL_DEPTH_COMPONENT)
    {
        if (!spanInfo->dstSwapBytes &&
            (type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT) &&
            !pm->modifyDepth &&
            gc->modes.haveDepthBuffer
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (ReadZPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif

    // The read functions always retrieve __GLcolors so the source
    // data format is always GL_RGBA.  It's important to set this
    // because some routines handle both RGB and BGR ordering and
    // look at the srcFormat to determine what to do.
    spanInfo->srcFormat = GL_RGBA;

    /*
    ** First step:  Read and modify a span.  RGBA spans are scaled when
    ** this step is finished.
    */

    switch(format) {
      case GL_RGB:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_ALPHA:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	if (gc->modes.rgbMode) {
	    reader = gc->procs.pixel.spanReadRGBA2;
	    if (pm->modifyRGBA) {
		spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	    }
	} else {
	    reader = gc->procs.pixel.spanReadCI2;
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	}
	isIndex = GL_FALSE;
	break;
      case GL_DEPTH_COMPONENT:
	reader = gc->procs.pixel.spanReadDepth2;
	if (pm->modifyDepth) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	}
	isIndex = GL_FALSE;
	break;
      case GL_STENCIL_INDEX:
	reader = gc->procs.pixel.spanReadStencil2;
	if (pm->modifyStencil) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	}
	isIndex = GL_TRUE;
	break;
      case GL_COLOR_INDEX:
	reader = gc->procs.pixel.spanReadCI2;
	if (pm->modifyCI) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	} 
	isIndex = GL_TRUE;
	break;
    }

    /*
    ** Second step:  Reduce RGBA spans to appropriate derivative (RED, 
    ** LUMINANCE, ALPHA, etc.).
    */

    switch(format) {
      case GL_RGB:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceRGB;
	break;
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceBGR;
	break;
#endif
      case GL_RED:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceRed;
	break;
      case GL_GREEN:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceGreen;
	break;
      case GL_BLUE:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceBlue;
	break;
      case GL_LUMINANCE:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminance;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminanceAlpha;
	break;
      case GL_ALPHA:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceAlpha;
	break;
      case GL_RGBA:
	spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
	break;
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
	spanInfo->spanModifier[spanCount++] = __glSpanUnscaleBGRA;
	break;
#endif
    }

    /*
    ** Third step:  Conversion from FLOAT to user requested type.
    */

    if (isIndex) {
	switch(type) {
	  case GL_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackByteI;
	    break;
	  case GL_UNSIGNED_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUbyteI;
	    break;
	  case GL_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackShortI;
	    break;
	  case GL_UNSIGNED_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUshortI;
	    break;
	  case GL_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackIntI;
	    break;
	  case GL_UNSIGNED_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUintI;
	    break;
	  case GL_BITMAP:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackBitmap;
	    break;
	}
    } else {
	switch(type) {
	  case GL_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackByte;
	    break;
	  case GL_UNSIGNED_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUbyte;
	    break;
	  case GL_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackShort;
	    break;
	  case GL_UNSIGNED_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUshort;
	    break;
	  case GL_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackInt;
	    break;
	  case GL_UNSIGNED_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUint;
	    break;
	}
    }

    /*
    ** Fourth step:  Mis-align data as needed, and perform byte swapping
    ** if requested by the user.
    */

    if (spanInfo->dstSwapBytes) {
	/* Byte swapping is necessary */
	if (spanInfo->dstElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2Dst;
	} else if (spanInfo->dstElementSize == 4) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4Dst;
	}
    } else if (type != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->dstImage)) & (spanInfo->dstElementSize - 1))) {
	/* Alignment is necessary */
	if (spanInfo->dstElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2Dst;
	} else if (spanInfo->dstElementSize == 4) {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4Dst;
	}
    }

    /*
    ** Pick a ReadPixels routine that uses the right number of span 
    ** modifiers.
    */

    spanInfo->spanReader = reader;
    switch(spanCount) {
      case 0:
	rpfn = __glReadPixels0;
	break;
      case 1:
	rpfn = __glReadPixels1;
	break;
      case 2:
	rpfn = __glReadPixels2;
	break;
      case 3:
	rpfn = __glReadPixels3;
	break;
      case 4:
	rpfn = __glReadPixels4;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 5:
	rpfn = __glReadPixels5;
	break;
    }
    (*rpfn)(gc, spanInfo);
}

/*
** This routine does two clips.  It clips like the DrawPixel clipper so 
** that if you try to copy to off window pixels, nothing will be done, and it 
** also clips like the ReadPixel clipper so that if you try to copy from
** off window pixels, nothing will be done.
*/
GLboolean FASTCALL __glClipCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat num, den;
    __GLfloat rpyUp, rpyDown;
    GLint rowsUp, rowsDown, startUp, startDown;
    __GLfloat midPoint;
    GLint intMidPoint, rowCount;
    GLint width, height;
    GLint readX, readY;
    __GLfloat zoomx, zoomy;
    __GLfloat rpx, rpy;
    __GLfloat rx1, rx2, ry1, ry2, wx1, wx2, wy1, wy2;
    __GLfloat abszoomy;
    GLint readUp, readDown;

    /*
    ** NOTE:
    ** A "nice" thing we could do for our application writers would be 
    ** to copy white when they try to copy from off window memory.  This
    ** would alert them to a bug in their program which they could then
    ** fix.
    **
    ** However, that seems like unnecessary code which would never be used
    ** anyway (no reason to bloat unnecessarily).
    */

    /*
    ** We take the easy approach, and just call the DrawPixels and ReadPixels
    ** clippers directly.
    */
    spanInfo->dstSkipLines = 0;
    spanInfo->dstSkipPixels = 0;
    if (!__glClipReadPixels(gc, spanInfo)) return GL_FALSE;
    spanInfo->x += spanInfo->dstSkipPixels * spanInfo->zoomx;
    spanInfo->y += spanInfo->dstSkipLines * spanInfo->zoomy;

    spanInfo->srcSkipLines = 0;
    spanInfo->srcSkipPixels = 0;
    if (!__glClipDrawPixels(gc, spanInfo)) return GL_FALSE;
    spanInfo->readX += spanInfo->srcSkipPixels;
    if (gc->constants.yInverted) {
	spanInfo->readY -= spanInfo->srcSkipLines;
    } else {
	spanInfo->readY += spanInfo->srcSkipLines;
    }

    /*
    ** Now for the incredibly tricky part!
    **
    ** This code attempts to deal with overlapping CopyPixels regions.
    ** It is a very difficult problem given that zoomy may be negative.
    ** The IrisGL used a cheap hack to solve this problem, which is 
    ** to read in the entire source image, and then write the destination
    ** image.  The problem with this approach, of course, is that it 
    ** requires a large amount of memory.
    **
    ** If zoomy can only be positive, then any image can be copied by
    ** copying a single span at a time, as long as you are careful about
    ** what order you process the spans.  However, since zoomy may be
    ** negative, the worst case images require copying two spans at 
    ** a time.  This means reading both spans, possibly modifying them,
    ** and then writing them back out. 
    **
    ** An example of this can be seen as follows:  Suppose an image
    ** covering 4 spans is copied onto itself with a zoomy of -1.  This
    ** means that the first row will be copied to the fourth row,
    ** and the fourth row will be copied to the first row.  In order 
    ** to accomplish both of these copies, they must be performed 
    ** simultaneously (after all, if you copy the first row to
    ** the fourth row first, then you have just destroyed the data 
    ** on the fourth row, and you can no longer copy it!).
    **
    ** In the most general case, any rectangular image can be copied
    ** by simultaneously iterating two spans over the source image
    ** and copying as you go.  Sometimes these spans will start at 
    ** the outside of the image and move their way inwards meeting 
    ** in the middle, and sometimes they will start in the middle 
    ** and work their way outward.
    **
    ** The middle point where the spans both start or end depends
    ** upon how the source and destination images overlap.  This point
    ** may be exactly in the middle, or at either end.  This means 
    ** that you may only end up with just a single span iterating over the 
    ** entire image (starting at one end and moving to the other).
    **
    ** The code that follows computes if the images overlap, and if they
    ** do, how two spans can be used to iterate over the source image
    ** so that it can be successfully copied to the destination image.
    **
    ** The following fields in the spanInfo record will be set in the 
    ** process of making these calculations:
    **
    ** overlap - set to GL_TRUE if the regions overlap at all.  Set to
    **		 GL_FALSE otherwise.
    **
    ** rowsUp, rowsDown - The number of rows of the source image that
    ** 			  need to be dealt with by the span that moves up
    **			  over the source image and the one that moves down
    **			  over the source image.  For example, if rowsUp is
    **			  equal to 10 and rowsDown is 0, then all 10 rows of 
    **			  the image should be copied by the up moving span
    **			  (the one that starts at readY and works it's way
    **			  up to readY+height).
    **
    ** startUp, startDown - At what relative points in time the spans should
    **			    start iterating.  For example, if startUp is 0
    **			    and startDown is 2, then the up moving span 
    **			    should be started first, and after it has 
    **			    iterated over 2 rows of the source image then
    **			    the down moving span should be started.
    **
    ** rpyUp, rpyDown - The starting raster positions for the two spans.
    **			These numbers are not exactly what they claim to
    **			be, but they are close.  They should be used by
    **			the span iterators in the following manner:  When
    **			the up moving span starts, it starts iterating 
    **			the float "rp_y" at rpyUp.  After reading and
    **			modifying a span, the span is written to rows
    **           	floor(rp_y) through floor(rp_y+zoomy) of the
    **			screen (not-inclusive of floor(rp_y+zoomy)).
    **			rp_y is then incremented by zoomy.  The same 
    **			algorithm is applied to the down moving span except
    **			that zoomy is subtracted from rp_y instead of
    **			being added.
    **
    ** readUp, readDown - The spans that are to be used for reading from
    **			  the source image.  The up moving span should start
    **			  reading at line "readUp", and the down moving span
    **			  should start at "readDown". 
    **
    ** Remember that the up moving and down moving spans must be iterated
    ** over the image simultaneously such that both spans are read before
    ** either one is written.
    **
    ** The actual algorithm applied here took many many hours of scratch 
    ** paper, and graph diagrams to derive.  It is very complicated, and
    ** hard to understand.  Do not attempt to change it without first
    ** understanding what it does completely.
    **
    ** In a nutshell, it first computes what span of the source image 
    ** will be copied onto itself (if any), and if |zoomy| < 1 it starts the
    ** up and down moving spans there and moves them outwards, or if 
    ** |zoomy| >= 1 it starts the spans at the outside of the image 
    ** and moves them inward so that they meet at the computed point.
    **
    ** Computing what span of the source image copies onto itself is 
    ** relatively easy.  For any span j of the source image from 0 through
    ** height, the span is read from row "readY + j" and written to
    ** any row centers falling within the range "rp_y + j * zoomy" through 
    ** "rp_y + (j+1) * zoomy".  If you set these equations equal to 
    ** each other (and subtract 0.5 from the raster position -- effectively
    ** moving the row centers from X.5 to X.0), you can determine that for 
    ** j = (readY - (rpy - 0.5)) / (zoomy-1) the source image concides with
    ** the destination image.  This is a floating point solution to a discrete
    ** problem, meaning that it is not a complete solution, but that is 
    ** the general idea.  Explaining this algorithm in any more detail would
    ** take another 1000 lines of comments, so I will leave it at that.
    */

    width = spanInfo->width;
    height = spanInfo->height;
    rpx = spanInfo->x;
    rpy = spanInfo->y;
    readX = spanInfo->readX;
    readY = spanInfo->readY;
    zoomx = spanInfo->zoomx;
    zoomy = spanInfo->zoomy;

    /* First check if the regions overlap at all */
    if (gc->constants.yInverted) {
	ry1 = readY - height + __glHalf;
	ry2 = readY - gc->constants.viewportAlmostHalf;
    } else {
	ry1 = readY + __glHalf;
	ry2 = readY + height - gc->constants.viewportAlmostHalf;
    }
    rx1 = readX + __glHalf;
    rx2 = readX + width - gc->constants.viewportAlmostHalf;
    if (zoomx > 0) {
	/* Undo some math done by ClipDrawPixels */
	rpx = rpx - gc->constants.viewportAlmostHalf;
	wx1 = rpx;
	wx2 = rpx + zoomx * width;
    } else {
	/* Undo some math done by ClipDrawPixels */
	rpx = rpx - gc->constants.viewportAlmostHalf + __glOne;
	wx1 = rpx + zoomx * width;
	wx2 = rpx;
    }
    if (zoomy > 0) {
	/* Undo some math done by ClipDrawPixels */
	rpy = rpy - gc->constants.viewportAlmostHalf;
	abszoomy = zoomy;
	wy1 = rpy;
	wy2 = rpy + zoomy * height;
    } else {
	/* Undo some math done by ClipDrawPixels */
	rpy = rpy - gc->constants.viewportAlmostHalf + __glOne;
	abszoomy = -zoomy;
	wy1 = rpy + zoomy * height;
	wy2 = rpy;
    }

    if (rx2 < wx1 || wx2 < rx1 || ry2 < wy1 || wy2 < ry1) {
	/* No overlap! */
	spanInfo->overlap = GL_FALSE;
	spanInfo->rowsUp = height;
	spanInfo->rowsDown = 0;
	spanInfo->startUp = 0;
	spanInfo->startDown = 0;
	spanInfo->rpyUp = rpy;
	spanInfo->rpyDown = rpy;
	return GL_TRUE;
    }

    spanInfo->overlap = GL_TRUE;

    /* Time to compute how we should set up our spans */
    if (gc->constants.yInverted) {
	num = (rpy - (__GLfloat) 0.5) - readY;
	den = -zoomy - 1;
    } else {
	num = readY - (rpy - (__GLfloat) 0.5);
	den = zoomy - 1;
    }
    startDown = startUp = 0;
    rowsUp = rowsDown = 0;
    rpyUp = rpy;
    rpyDown = rpy + zoomy*height;
    readUp = readY;
    if (gc->constants.yInverted) {
	readDown = readY - height + 1;
    } else {
	readDown = readY + height - 1;
    }

    if (den == __glZero) {
	/* Better not divide! */
	if (num > 0) {
	    midPoint = height;
	} else {
	    midPoint = 0;
	}
    } else {
	midPoint = num/den;
	if (midPoint < 0) {
	    midPoint = 0;
	} else if (midPoint > height) {
	    midPoint = height;
	}
    }
    if (midPoint == 0) {
	/* Only one span needed */
	if (abszoomy < __glOne) {
	    rowsUp = height;
	} else {
	    rowsDown = height;
	}
    } else if (midPoint == height) {
	/* Only one span needed */
	if (abszoomy < __glOne) {
	    rowsDown = height;
	} else {
	    rowsUp = height;
	}
    } else {
	/* Almost definitely need two spans to copy this image! */
	intMidPoint = __GL_CEILF(midPoint);

	rowCount = height - intMidPoint;
	if (intMidPoint > rowCount) {
	    rowCount = intMidPoint;
	}

	if (abszoomy > __glOne) {
	    GLint temp;

	    /* Move from outside of image inward */
	    startUp = rowCount - intMidPoint;
	    startDown = rowCount - (height - intMidPoint);
	    rowsUp = intMidPoint;
	    rowsDown = height - rowsUp;

	    if (gc->constants.yInverted) {
		temp = readY - intMidPoint + 1;
	    } else {
		temp = readY + intMidPoint - 1;
	    }

	    if (__GL_FLOORF( (temp - 
		    (rpy-__glHalf-gc->constants.viewportEpsilon)) 
		    / zoomy) == intMidPoint-1) {
		/* 
		** row "intMidPoint-1" copies exactly onto itself.  Let's 
		** make it the midpoint which we converge to.
		*/
		if (startDown) {
		    startDown--;
		} else {
		    startUp++;
		}
	    }
	} else {
	    /* Move from inside of image outward */
	    rowsDown = intMidPoint;
	    rowsUp = height - rowsDown;
	    rpyUp = rpyDown = rpy + zoomy * intMidPoint;
	    if (gc->constants.yInverted) {
		readUp = readY - intMidPoint;
		readDown = readY - intMidPoint + 1;
	    } else {
		readUp = readY + intMidPoint;
		readDown = readY + intMidPoint - 1;
	    }

	    if (__GL_FLOORF( (readDown - 
		    (rpy-__glHalf-gc->constants.viewportEpsilon))
		    / zoomy) == intMidPoint-1) {
		/* 
		** row "intMidPoint-1" copies exactly onto itself.  Let's
		** make it the midpoint which we diverge from.
		*/
		startUp = 1;
	    }
	}
    }

    /* 
    ** Adjust rpyUp and rpyDown so that they will change integer values 
    ** when fragments should be produced.  This basically takes the 0.5
    ** out of the inner loop when these spans are actually iterated.
    */
    if (zoomy > 0) {
	spanInfo->rpyUp = rpyUp + gc->constants.viewportAlmostHalf;
	spanInfo->rpyDown = rpyDown + gc->constants.viewportAlmostHalf - 
		__glOne;
    } else {
	spanInfo->rpyUp = rpyUp + gc->constants.viewportAlmostHalf - __glOne;
	spanInfo->rpyDown = rpyDown + gc->constants.viewportAlmostHalf;
    }
    spanInfo->startUp = startUp;
    spanInfo->startDown = startDown;
    spanInfo->rowsUp = rowsUp;
    spanInfo->rowsDown = rowsDown;
    spanInfo->readUp = readUp;
    spanInfo->readDown = readDown;

    return GL_TRUE;
}

void __glInitCopyPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			    GLint x, GLint y, GLint width, GLint height, 
			    GLenum format)
{
    __GLfloat rpx, rpy;
    __GLfloat zoomx, zoomy;

    rpx = gc->state.current.rasterPos.window.x;
    rpy = gc->state.current.rasterPos.window.y;
    spanInfo->fragz = gc->state.current.rasterPos.window.z;

    spanInfo->x = rpx;
    spanInfo->y = rpy;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx > __glZero) {
	if (zoomx < __glOne) {
	    spanInfo->rendZoomx = __glOne;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = 1;
    } else {
	if (zoomx > (GLfloat) -1.0) {
	    spanInfo->rendZoomx = (GLfloat) -1.0;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = -1;
    }
    spanInfo->zoomx = zoomx;
    zoomy = gc->state.pixel.transferMode.zoomY;
    if (gc->constants.yInverted) {
	zoomy = -zoomy;
    }
    if (zoomy > __glZero) {
	spanInfo->rowadd = 1;
    } else {
	spanInfo->rowadd = -1;
    }
    spanInfo->zoomy = zoomy;
    spanInfo->readX = x + gc->constants.viewportXAdjust;
    if (gc->constants.yInverted) {
	spanInfo->readY = (gc->constants.height - y - 1) + 
		gc->constants.viewportYAdjust;
    } else {
	spanInfo->readY = y + gc->constants.viewportYAdjust;
    }
    spanInfo->dstFormat = spanInfo->srcFormat = format;
    spanInfo->width = width;
    spanInfo->height = height;
}

/* 
** A CopyPixels with two span modifiers.
*/
void FASTCALL __glCopyPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat newy;
    __GLfloat zoomy;
    GLint inty, i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    i = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glCopyPixels2_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    if (spanInfo->overlap) {
#ifdef NT
        gcTempFree(gc, spanData1);
        gcTempFree(gc, spanData2);
#endif
	__glCopyPixelsOverlapping(gc, spanInfo, 2);
#ifdef NT
        gcTempFree(gc, pixelArray);
#endif
	return;
    }

    reader = spanInfo->spanReader;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    render = spanInfo->spanRender;

    ySign = gc->constants.ySign;
    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->readY += ySign;
	    spanInfo->y = newy;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*render)(gc, spanInfo, spanData1);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glCopyPixels2_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** A CopyPixels with one span modifier.
*/
void FASTCALL __glCopyPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat newy;
    __GLfloat zoomy;
    GLint inty, i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    i = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glCopyPixels1_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    if (spanInfo->overlap) {
#ifdef NT
        gcTempFree(gc, spanData1);
        gcTempFree(gc, spanData2);
#endif
	__glCopyPixelsOverlapping(gc, spanInfo, 1);
#ifdef NT
        gcTempFree(gc, pixelArray);
#endif
	return;
    }

    reader = spanInfo->spanReader;
    span1 = spanInfo->spanModifier[0];
    render = spanInfo->spanRender;

    ySign = gc->constants.ySign;
    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->readY += ySign;
	    spanInfo->y = newy;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*render)(gc, spanInfo, spanData2);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glCopyPixels1_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** Copy pixels with no span modifiers.
*/
void FASTCALL __glCopyPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat newy;
    __GLfloat zoomy;
    GLint inty, i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1;
    GLshort *pixelArray;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    pixelArray = gcTempAlloc(gc, spanInfo->width * sizeof(GLshort));
    if (!spanData1 || !pixelArray)
        goto __glCopyPixels0_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    if (spanInfo->overlap) {
#ifdef NT
        gcTempFree(gc, spanData1);
#endif
	__glCopyPixelsOverlapping(gc, spanInfo, 0);
#ifdef NT
        gcTempFree(gc, pixelArray);
#endif
	return;
    }

    reader = spanInfo->spanReader;
    render = spanInfo->spanRender;

    ySign = gc->constants.ySign;
    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->readY += ySign;
	    spanInfo->y = newy;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*reader)(gc, spanInfo, spanData1);
	(*render)(gc, spanInfo, spanData1);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glCopyPixels0_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/*
** Yick!  
**
** This routine is provided to perform CopyPixels when the source and
** destination images overlap.  
**
** It is not designed to go particularly fast, but then overlapping
** copies is probably not too common, and this routine is not typically a 
** large part of the execution overhead anyway.
**
** For more information on copying an image which overlaps its destination,
** check out the hairy comment within the __glClipCopyPixels function.
*/
void FASTCALL __glCopyPixelsOverlapping(__GLcontext *gc,
			       __GLpixelSpanInfo *spanInfo, GLint modifiers)
{
    GLint i;
    __GLfloat zoomy, newy;
    GLint inty, ySign;
    GLubyte *outSpan1, *outSpan2;
    GLint rowsUp, rowsDown;
    GLint startUp, startDown;
    __GLfloat rpyUp, rpyDown;
    GLint readUp, readDown;
    GLint gotUp, gotDown;
    __GLpixelSpanInfo downSpanInfo;
    GLint clipLow, clipHigh;
    GLint startRow, endRow;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2, *spanData3;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    spanData3 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2 || !spanData3)
        goto __glCopyPixelsOverlapping_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLubyte spanData3[__GL_MAX_SPAN_SIZE];
#endif

    reader = spanInfo->spanReader;
    render = spanInfo->spanRender;

    if (modifiers & 1) {
	outSpan1 = outSpan2 = spanData3;
    } else {
	outSpan1 = spanData1;
	outSpan2 = spanData2;
    }

    zoomy = spanInfo->zoomy;
    rowsUp = spanInfo->rowsUp;
    rowsDown = spanInfo->rowsDown;
    startUp = spanInfo->startUp;
    startDown = spanInfo->startDown;
    rpyUp = spanInfo->rpyUp;
    rpyDown = spanInfo->rpyDown;
    readUp = spanInfo->readUp;
    readDown = spanInfo->readDown;
    downSpanInfo = *spanInfo;
    downSpanInfo.rowadd = -spanInfo->rowadd;
    downSpanInfo.zoomy = -zoomy;
    spanInfo->y = rpyUp;
    downSpanInfo.y = rpyDown;
    spanInfo->readY = readUp;
    downSpanInfo.readY = readDown;
    gotUp = gotDown = 0;
    ySign = gc->constants.ySign;

    /* Clip upgoing and downgoing spans */
    if (zoomy > 0) {
	clipLow = spanInfo->startRow;
	clipHigh = spanInfo->startRow + spanInfo->rows - 1;

	/* Clip down span first */
	startRow = (GLint) rpyDown;
	endRow = (GLint) (rpyDown - zoomy*rowsDown) + 1;
	if (startRow > clipHigh) startRow = clipHigh;
	if (endRow < clipLow) endRow = clipLow;
	downSpanInfo.startRow = startRow;
	downSpanInfo.rows = startRow - endRow + 1;

	/* Now clip up span */
	startRow = (GLint) rpyUp;
	endRow = (GLint) (rpyUp + zoomy*rowsUp) - 1;
	if (startRow < clipLow) startRow = clipLow;
	if (endRow > clipHigh) endRow = clipHigh;
	spanInfo->startRow = startRow;
	spanInfo->rows = endRow - startRow + 1;
    } else /* zoomy < 0 */ {
	clipHigh = spanInfo->startRow;
	clipLow = spanInfo->startRow - spanInfo->rows + 1;

	/* Clip down span first */
	startRow = (GLint) rpyDown;
	endRow = (GLint) (rpyDown - zoomy*rowsDown) - 1;
	if (startRow < clipLow) startRow = clipLow;
	if (endRow > clipHigh) endRow = clipHigh;
	downSpanInfo.startRow = startRow;
	downSpanInfo.rows = endRow - startRow + 1;

	/* Now clip up span */
	startRow = (GLint) rpyUp;
	endRow = (GLint) (rpyUp + zoomy*rowsUp) + 1;
	if (startRow > clipHigh) startRow = clipHigh;
	if (endRow < clipLow) endRow = clipLow;
	spanInfo->startRow = startRow;
	spanInfo->rows = startRow - endRow + 1;
    }

    while (rowsUp && rowsDown) {
	if (startUp) {
	    startUp--;
	} else {
	    gotUp = 1;
	    rowsUp--;
	    spanInfo->y = rpyUp;
	    newy = rpyUp + zoomy;
	    inty = (GLint) rpyUp;
	    while (rowsUp && (GLint) newy == inty) {
		spanInfo->y = newy;
		newy += zoomy;
		rowsUp--;
		spanInfo->readY += ySign;
	    }
	    if (inty == (GLint) newy) break;
	    rpyUp = newy;
	    (*reader)(gc, spanInfo, spanData1);
	    spanInfo->readY += ySign;
	}
	if (startDown) {
	    startDown--;
	} else {
	    gotDown = 1;
	    rowsDown--;
	    downSpanInfo.y = rpyDown;
	    newy = rpyDown - zoomy;
	    inty = (GLint) rpyDown;
	    while (rowsDown && (GLint) newy == inty) {
		downSpanInfo.y = newy;
		newy -= zoomy;
		rowsDown--;
		downSpanInfo.readY -= ySign;
	    }
	    if (inty == (GLint) newy) {
		if (gotUp) {
		    for (i=0; i<modifiers; i++) {
			if (i & 1) {
			    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
				    spanData3, spanData1);
			} else {
			    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
				    spanData1, spanData3);
			}
		    }
		    (*render)(gc, spanInfo, outSpan1);
		}
		break;
	    }
	    rpyDown = newy;
	    (*reader)(gc, &downSpanInfo, spanData2);
	    downSpanInfo.readY -= ySign;
	}

	if (gotUp) {
	    for (i=0; i<modifiers; i++) {
		if (i & 1) {
		    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			    spanData3, spanData1);
		} else {
		    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			    spanData1, spanData3);
		}
	    }
	    (*render)(gc, spanInfo, outSpan1);
	}

	if (gotDown) {
	    for (i=0; i<modifiers; i++) {
		if (i & 1) {
		    (*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			    spanData3, spanData2);
		} else {
		    (*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			    spanData2, spanData3);
		}
	    }
	    (*render)(gc, &downSpanInfo, outSpan2);
	}
    }

    /*
    ** Only one of the spanners is left to iterate.
    */

    while (rowsUp) {
	/* Do what is left of up spans */
	rowsUp--;
	spanInfo->y = rpyUp;
	newy = rpyUp + zoomy;
	inty = (GLint) rpyUp;
	while (rowsUp && (GLint) newy == inty) {
	    spanInfo->y = newy;
	    newy += zoomy;
	    rowsUp--;
	    spanInfo->readY += ySign;
	}
	if (inty == (GLint) newy) break;
	rpyUp = newy;

	(*reader)(gc, spanInfo, spanData1);
	for (i=0; i<modifiers; i++) {
	    if (i & 1) {
		(*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			spanData3, spanData1);
	    } else {
		(*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			spanData1, spanData3);
	    }
	}
	(*render)(gc, spanInfo, outSpan1);

	spanInfo->readY += ySign;
    }

    while (rowsDown) {
	/* Do what is left of down spans */
	rowsDown--;
	downSpanInfo.y = rpyDown;
	newy = rpyDown - zoomy;
	inty = (GLint) rpyDown;
	while (rowsDown && (GLint) newy == inty) {
	    downSpanInfo.y = newy;
	    newy -= zoomy;
	    rowsDown--;
	    downSpanInfo.readY -= ySign;
	}
	if (inty == (GLint) newy) break;
	rpyDown = newy;

	(*reader)(gc, &downSpanInfo, spanData2);
	for (i=0; i<modifiers; i++) {
	    if (i & 1) {
		(*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			spanData3, spanData2);
	    } else {
		(*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			spanData2, spanData3);
	    }
	}
	(*render)(gc, &downSpanInfo, outSpan2);

	downSpanInfo.readY -= ySign;
    }
#ifdef NT
__glCopyPixelsOverlapping_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (spanData3)  gcTempFree(gc, spanData3);
#endif
}

/*
** Generic implementation of a CopyPixels picker.  Any machine specific
** implementation should provide their own.
*/
void __glSlowPickCopyPixels(__GLcontext *gc, GLint x, GLint y, GLint width,
		            GLint height, GLenum type)
{
    __GLpixelSpanInfo spanInfo;

    __glInitCopyPixelsInfo(gc, &spanInfo, x, y, width, height, type);
    if (!__glClipCopyPixels(gc, &spanInfo)) return;

    __glGenericPickCopyPixels(gc, &spanInfo);
}

/*
** Generic picker for CopyPixels.  This should be called if no machine
** specific path is provided for this specific version of CopyPixels.
*/
void FASTCALL __glGenericPickCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLpixelMachine *pm;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
    void (FASTCALL *cpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
    GLint spanCount;
    GLboolean zoomx1;		/* -1 <= zoomx <= 1? */
    GLboolean zoomx2;		/* zoomx <= -1 || zoomx >= 1 */
    __GLfloat zoomx;
    GLenum format;

    pm = &gc->pixel;
    spanCount = 0;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx >= (__GLfloat) -1.0 && zoomx <= __glOne) {
	zoomx1 = GL_TRUE;
    } else {
	zoomx1 = GL_FALSE;
    }
    if (zoomx <= (__GLfloat) -1.0 || zoomx >= __glOne) {
	zoomx2 = GL_TRUE;
    } else {
	zoomx2 = GL_FALSE;
    }
    format = spanInfo->dstFormat;

#ifdef NT
    // Special case RGB copying to use a DIB
    // Also special case copying the Z buffer
    if (format == GL_RGBA)
    {
        GLuint enables = gc->state.enables.general;

        // Look to see if we're doing direct buffer-to-buffer copying
        // Things that can't be allowed are depth testing,
        // fogging, blending or anything that prevents the input data
        // from going directly into the destination buffer

        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            !pm->modifyRGBA &&
            (enables & (__GL_DITHER_ENABLE |
                        __GL_ALPHA_TEST_ENABLE |
                        __GL_STENCIL_TEST_ENABLE |
                        __GL_DEPTH_TEST_ENABLE |
                        __GL_BLEND_ENABLE |
                        __GL_INDEX_LOGIC_OP_ENABLE |
                        __GL_COLOR_LOGIC_OP_ENABLE |
                        __GL_FOG_ENABLE)) == 0 &&
            gc->state.raster.drawBuffer != GL_NONE &&
            gc->state.raster.drawBuffer != GL_FRONT_AND_BACK &&
            !gc->texture.textureEnabled &&
            (gc->drawBuffer->buf.flags & COLORMASK_ON) == 0
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (CopyRgbPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
    else if (format == GL_DEPTH_COMPONENT)
    {
        // If the Z test is GL_ALWAYS and there is no draw buffer
        // then the application is simply copying Z values around
        // the Z buffer.
        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            !pm->modifyDepth &&
            gc->state.raster.drawBuffer == GL_NONE &&
            (gc->state.enables.general & __GL_DEPTH_TEST_ENABLE) &&
            gc->state.depth.testFunc == GL_ALWAYS &&
            gc->modes.haveDepthBuffer
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (CopyZPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif

    switch(format) {
      case GL_RGBA:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadRGBA2;
	} else {
	    reader = gc->procs.pixel.spanReadRGBA;
	}
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderRGBA2;
	} else {
	    render = gc->procs.pixel.spanRenderRGBA;
	}
	break;
      case GL_COLOR_INDEX:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadCI2;
	} else {
	    reader = gc->procs.pixel.spanReadCI;
	}
	if (pm->modifyCI) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderCI2;
	} else {
	    render = gc->procs.pixel.spanRenderCI;
	}
	break;
      case GL_STENCIL_INDEX:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadStencil2;
	} else {
	    reader = gc->procs.pixel.spanReadStencil;
	}
	if (pm->modifyStencil) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderStencil2;
	} else {
	    render = gc->procs.pixel.spanRenderStencil;
	}
	break;
      case GL_DEPTH_COMPONENT:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadDepth2;
	} else {
	    reader = gc->procs.pixel.spanReadDepth;
	}
	if (pm->modifyDepth) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderDepth2;
	} else {
	    render = gc->procs.pixel.spanRenderDepth;
	}
	break;
    }

    switch(spanCount) {
      case 0:
	cpfn = __glCopyPixels0;
	break;
      case 1:
	cpfn = __glCopyPixels1;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 2:
	cpfn = __glCopyPixels2;
	break;
    }

    spanInfo->spanReader = reader;
    spanInfo->spanRender = render;

    (*cpfn)(gc, spanInfo);
}

/*
** A simple image copying routine with one span modifier.
*/
void FASTCALL __glCopyImage1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanInfo->dstCurrent);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
}

/*
** A simple image copying routine with two span modifiers.
*/
void FASTCALL __glCopyImage2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    if (!spanData1)
        return;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
    gcTempFree(gc, spanData1);
#endif
}

/*
** A simple image copying routine with three span modifiers.
*/
void FASTCALL __glCopyImage3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage3_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage3_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with four span modifiers.
*/
void FASTCALL __glCopyImage4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage4_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage4_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with five span modifiers.
*/
void FASTCALL __glCopyImage5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage5_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*span5)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage5_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with six span modifiers.
*/
void FASTCALL __glCopyImage6(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span6)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage6_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    span6 = spanInfo->spanModifier[5];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*span5)(gc, spanInfo, spanData2, spanData1);
	(*span6)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage6_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with seven span modifiers.
*/
void FASTCALL __glCopyImage7(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span6)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span7)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage7_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    span6 = spanInfo->spanModifier[5];
    span7 = spanInfo->spanModifier[6];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*span5)(gc, spanInfo, spanData2, spanData1);
	(*span6)(gc, spanInfo, spanData1, spanData2);
	(*span7)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage7_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** Internal image processing routine.  Used by GetTexImage to transfer from
** internal texture image to the user.  Used by TexImage[12]D to transfer
** from the user to internal texture.  Used for display list optimization of
** textures and DrawPixels.
**
** This routine also supports the pixel format mode __GL_RED_ALPHA which is
** basically a 2 component texture.
**
** If applyPixelTransfer is set to GL_TRUE, pixel transfer modes will be 
** applied as necessary.
*/
void FASTCALL __glGenericPickCopyImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			      GLboolean applyPixelTransfer)
{
    GLint spanCount;
    GLboolean srcPackedData;
    GLenum srcType, srcFormat;
    GLboolean srcSwap;
    GLboolean srcAlign;
    GLboolean srcConvert;
    GLboolean srcExpand;
    GLboolean srcClamp;
    GLenum dstType, dstFormat;
    GLboolean dstSwap;
    GLboolean dstAlign;
    GLboolean dstConvert;
    GLboolean dstReduce;
    GLboolean modify;
    __GLpixelMachine *pm;
    void (FASTCALL *cpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);

    pm = &gc->pixel;
    spanCount = 0;
    srcPackedData = spanInfo->srcPackedData;
    srcType = spanInfo->srcType;
    srcFormat = spanInfo->srcFormat;
    dstType = spanInfo->dstType;
    dstFormat = spanInfo->dstFormat;

    switch(srcFormat) {
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case __GL_RED_ALPHA:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
#ifdef GL_EXT_paletted_texture
      case __GL_PALETTE_INDEX:
#endif
	modify = applyPixelTransfer && pm->modifyRGBA;
	break;
      case GL_DEPTH_COMPONENT:
	modify = applyPixelTransfer && pm->modifyDepth;
	break;
      case GL_STENCIL_INDEX:
	modify = applyPixelTransfer && pm->modifyStencil;
	break;
      case GL_COLOR_INDEX:
	modify = applyPixelTransfer && pm->modifyCI;
	break;
    }

    if ((srcFormat == dstFormat || 
	    (srcFormat == GL_LUMINANCE_ALPHA && dstFormat == __GL_RED_ALPHA) ||
	    (srcFormat == __GL_RED_ALPHA && dstFormat == GL_LUMINANCE_ALPHA) ||
	    (srcFormat == GL_LUMINANCE && dstFormat == GL_RED) ||
	    (srcFormat == GL_RED && dstFormat == GL_LUMINANCE)) && !modify) {
	srcExpand = GL_FALSE;
	dstReduce = GL_FALSE;
    } else {
	srcExpand = GL_TRUE;
	dstReduce = GL_TRUE;
    }

    if (srcType == GL_FLOAT) {
	srcConvert = GL_FALSE;
    } else {
	srcConvert = GL_TRUE;
    }
    if (dstType == GL_FLOAT) {
	dstConvert = GL_FALSE;
    } else {
	dstConvert = GL_TRUE;
    }

    if (spanInfo->srcSwapBytes && spanInfo->srcElementSize > 1) {
	srcSwap = GL_TRUE;
    } else {
	srcSwap = GL_FALSE;
    }
    if (spanInfo->dstSwapBytes && spanInfo->dstElementSize > 1) {
	dstSwap = GL_TRUE;
    } else {
	dstSwap = GL_FALSE;
    }

    if (srcType != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->srcImage)) & (spanInfo->srcElementSize - 1))) {
	srcAlign = GL_TRUE;
    } else {
	srcAlign = GL_FALSE;
    }
    if (dstType != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->dstImage)) & (spanInfo->dstElementSize - 1))) {
	dstAlign = GL_TRUE;
    } else {
	dstAlign = GL_FALSE;
    }

    if (srcType == GL_BITMAP || srcType == GL_UNSIGNED_BYTE ||
            srcType == GL_UNSIGNED_SHORT || srcType == GL_UNSIGNED_INT ||
            srcFormat == GL_COLOR_INDEX || srcFormat == GL_STENCIL_INDEX ||
	    modify) {
        srcClamp = GL_FALSE;
    } else {
        srcClamp = GL_TRUE;
    }

    if (srcType == dstType && srcType != GL_BITMAP && !srcExpand && !srcClamp) {
	srcConvert = dstConvert = GL_FALSE;
    }

#ifdef NT
    // Special case copying where it's a straight data copy from
    // the source to the destination
    if (!srcSwap && !srcAlign && !srcConvert && !srcClamp && !srcExpand &&
        !dstReduce && !dstConvert && !dstSwap && !dstAlign)
    {
        if (CopyAlignedImage(gc, spanInfo))
        {
            return;
        }
    }
    else if (srcType == GL_UNSIGNED_BYTE && dstType == GL_UNSIGNED_BYTE &&
             !srcAlign && !dstAlign)
    {
        // Special case expanding a 24-bit RGB texture into 32-bit BGRA
        if (srcFormat == GL_RGB && dstFormat == GL_BGRA_EXT)
        {
            if (CopyRgbToBgraImage(gc, spanInfo))
            {
                return;
            }
        }
        // Special case flipping a 32-bit RGBA texture into 32-bit BGRA
        else if (srcFormat == GL_RGBA && dstFormat == GL_BGRA_EXT)
        {
            if (CopyRgbaToBgraImage(gc, spanInfo))
            {
                return;
            }
        }
        // Special case expanding a 24-bit BGR texture into 32-bit BGRA
        else if (srcFormat == GL_BGR_EXT && dstFormat == GL_BGRA_EXT)
        {
            if (CopyBgrToBgraImage(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif
    
    /* 
    ** First step:  Swap, align the data, etc. 
    */
    if (srcSwap) {
	if (spanInfo->srcElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2;
	} else /* spanInfo->srcElementSize == 4 */ {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4;
	}
    } else if (srcAlign) {
	if (spanInfo->srcElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2;
	} else /* spanInfo->srcElementSize == 4 */ {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4;
	}
    }


    /* 
    ** Second step:  conversion to float
    */
    if (srcConvert) {
        if (srcFormat == GL_COLOR_INDEX || srcFormat == GL_STENCIL_INDEX) {
            /* Index conversion */
            switch(srcType) {
              case GL_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackByteI;
                break;
              case GL_UNSIGNED_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyteI;
                break;
              case GL_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackShortI;
                break;
              case GL_UNSIGNED_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshortI;
                break;
              case GL_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackIntI;
                break;
              case GL_UNSIGNED_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUintI;
                break;
	      case GL_BITMAP:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap2;
		break;
            }
        } else {
            /* Component conversion */
            switch(srcType) {
              case GL_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackByte;
                break;
              case GL_UNSIGNED_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyte;
                break;
              case GL_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackShort;
                break;
              case GL_UNSIGNED_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshort;
                break;
              case GL_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackInt;
                break;
              case GL_UNSIGNED_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUint;
                break;
	      case GL_BITMAP:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap2;
		break;
            }
        }
    }

    /*
    ** Third step:  Clamp if necessary.
    */
    if (srcClamp) {
        switch(srcType) {
          case GL_BYTE:
          case GL_SHORT:
          case GL_INT:
            spanInfo->spanModifier[spanCount++] = __glSpanClampSigned;
            break;
          case GL_FLOAT:
            spanInfo->spanModifier[spanCount++] = __glSpanClampFloat;
            break;
        }
    }

    /*
    ** Fourth step:  Expansion to RGBA, Modification and scale colors (sortof a
    **   side effect).
    */
    if (srcExpand) {
	switch(srcFormat) {
	  case GL_RED:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRed;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandRed;
	    }
	    break;
	  case GL_GREEN:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyGreen;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandGreen;
	    }
	    break;
	  case GL_BLUE:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyBlue;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandBlue;
	    }
	    break;
	  case GL_ALPHA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyAlpha;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandAlpha;
	    }
	    break;
	  case GL_RGB:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandRGB;
	    }
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGR_EXT:
	    if (modify) {
                // __glSpanModifyRGB handles both RGB and BGR
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandBGR;
	    }
	    break;
#endif
	  case GL_LUMINANCE:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyLuminance;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandLuminance;
	    }
	    break;
	  case GL_LUMINANCE_ALPHA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanModifyLuminanceAlpha;
	    } else {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanExpandLuminanceAlpha;
	    }
	    break;
	  case __GL_RED_ALPHA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRedAlpha;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandRedAlpha;
	    }
	    break;
	  case GL_RGBA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanScaleRGBA;
	    }
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGRA_EXT:
	    if (modify) {
                // __glSpanModifyRGBA handles both RGBA and BGRA
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanScaleBGRA;
	    }
	    break;
#endif
	  case GL_DEPTH_COMPONENT:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	    }
	    break;
	  case GL_STENCIL_INDEX:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	    }
	    break;
	  case GL_COLOR_INDEX:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	    }
	    break;
#ifdef GL_EXT_paletted_texture
          case __GL_PALETTE_INDEX:
            if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyPI;
            } else {
		spanInfo->spanModifier[spanCount++] = __glSpanScalePI;
            }
            break;
#endif
	}
    }

    /*
    ** Fifth step:  Reduce RGBA spans to appropriate derivative (RED,
    **   LUMINANCE, ALPHA, etc.).
    */
    if (dstReduce) {
	switch(dstFormat) {
	  case GL_RGB:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceRGB;
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGR_EXT:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceBGR;
	    break;
#endif
	  case GL_RED:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceRed;
	    break;
	  case GL_GREEN:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceGreen;
	    break;
	  case GL_BLUE:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceBlue;
	    break;
	  case GL_LUMINANCE:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminance;
	    break;
	  case GL_LUMINANCE_ALPHA:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminanceAlpha;
	    break;
	  case __GL_RED_ALPHA:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceRedAlpha;
	    break;
	  case GL_ALPHA:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceAlpha;
	    break;
	  case GL_RGBA:
	    spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGRA_EXT:
	    spanInfo->spanModifier[spanCount++] = __glSpanUnscaleBGRA;
	    break;
#endif
#ifdef NT
          case GL_COLOR_INDEX:
            break;
          default:
            // We should never be asked to reduce to palette indices
            // so add this assert to catch such a request
            ASSERTOPENGL(FALSE, "Unhandled copy_image reduction\n");
            break;
#endif
	}
    }

    /*
    ** Sixth step:  Conversion from FLOAT to requested type.
    */
    if (dstConvert) {
        if (dstFormat == GL_COLOR_INDEX || dstFormat == GL_STENCIL_INDEX) {
	    switch(dstType) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackByteI;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUbyteI;
		break;
	      case GL_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackShortI;
		break;
	      case GL_UNSIGNED_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUshortI;
		break;
	      case GL_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackIntI;
		break;
	      case GL_UNSIGNED_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUintI;
		break;
	      case GL_BITMAP:
		spanInfo->spanModifier[spanCount++] = __glSpanPackBitmap;
		break;
	    }
	} else {
	    switch(dstType) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackByte;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUbyte;
		break;
	      case GL_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackShort;
		break;
	      case GL_UNSIGNED_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUshort;
		break;
	      case GL_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackInt;
		break;
	      case GL_UNSIGNED_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUint;
		break;
	    }
	}
    }

    /*
    ** Seventh step:  Mis-align data as needed, and perform byte swapping
    **   if requested by the user.
    */
    if (dstSwap) {
        if (spanInfo->dstElementSize == 2) {
            spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2Dst;
        } else /* if (spanInfo->dstElementSize == 4) */ {
            spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4Dst;
        }
    } else if (dstAlign) {
        if (spanInfo->dstElementSize == 2) {
            spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2Dst;
        } else /* if (spanInfo->dstElementSize == 4) */ {
            spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4Dst;
        }
    }

    /*
    ** Sanity check:  If we have zero span routines, then this simply
    **   isn't going to work.  We need to at least copy the data.
    */
    if (spanCount == 0) {
	spanInfo->spanModifier[spanCount++] = __glSpanCopy;
    }

    /*
    ** Final step:  Pick a copying function.
    */
    switch(spanCount) {
      case 1:
	cpfn = __glCopyImage1;
	break;
      case 2:
	cpfn = __glCopyImage2;
	break;
      case 3:
	cpfn = __glCopyImage3;
	break;
      case 4:
	cpfn = __glCopyImage4;
	break;
      case 5:
	cpfn = __glCopyImage5;
	break;
      case 6:
	cpfn = __glCopyImage6;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 7:
	cpfn = __glCopyImage7;
	break;
    }

    (*cpfn)(gc, spanInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>

#include <ddrawp.h>
#include <ddrawi.h>
#include <ddraw.h>

#include <math.h>
#include <string.h>

#include <glp.h>
#include <context.h>
#include <global.h>
#include <render.h>
#include <imfuncs.h>
#include <imports.h>
#include <pixel.h>
#include <image.h>
#ifdef GL_WIN_phong_shading
#include <phong.h>
#endif
#include <xform.h>

#include "gencx.h"
// redisable this

#pragma warning (disable:4244)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_unpac.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains routines to unpack data from the user's data space
** into a span of pixels which can then be rendered.
*/

/*
** Return the number of elements per group of a specified format
*/
GLint FASTCALL __glElementsPerGroup(GLenum format)
{
    switch(format) {
      case GL_RGB:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
#endif
        return 3;
      case GL_LUMINANCE_ALPHA:
      case __GL_RED_ALPHA:
        return 2;
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
#endif
        return 4;
      default:
        return 1;
    }
}

/*
** Return the number of bytes per element, based on the element type
*/
__GLfloat FASTCALL __glBytesPerElement(GLenum type)
{
    switch(type) {
      case GL_BITMAP:
        return ((__GLfloat) 1.0 / (__GLfloat) 8.0);
      case GL_UNSIGNED_SHORT:
      case GL_SHORT:
        return 2;
      case GL_UNSIGNED_BYTE:
      case GL_BYTE:
        return 1;
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
      default:
        return 4;
    }
}

void FASTCALL __glInitUnpacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint alignment;
    GLint lsb_first;
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint group_size;
    GLint groups_per_line;
    GLint skip_pixels, skip_lines;
    GLint swap_bytes;
    GLenum format, type;
    const GLvoid *pixels;

    format = spanInfo->srcFormat;
    type = spanInfo->srcType;
    pixels = spanInfo->srcImage;
    skip_pixels = spanInfo->srcSkipPixels;
    skip_lines = spanInfo->srcSkipLines;
    alignment = spanInfo->srcAlignment;
    lsb_first = spanInfo->srcLsbFirst;
    swap_bytes = spanInfo->srcSwapBytes;

    components = __glElementsPerGroup(format);
    groups_per_line = spanInfo->srcLineLength;

    element_size = __glBytesPerElement(type);
    if (element_size == 1) swap_bytes = 0;
    group_size = element_size * components;

    rowsize = groups_per_line * group_size;
    if (type == GL_BITMAP) {
	rowsize = (groups_per_line + 7)/8;
    }
    padding = (rowsize % alignment);
    if (padding) {
	rowsize += alignment - padding;
    }
    if (((skip_pixels & 0x7) && type == GL_BITMAP) ||
	    (swap_bytes && element_size > 1)) {
	spanInfo->srcPackedData = GL_FALSE;
    } else {
	spanInfo->srcPackedData = GL_TRUE;
    }

    if (type == GL_BITMAP) {
	spanInfo->srcCurrent = (GLvoid *) (((const GLubyte *) pixels) + 
		skip_lines * rowsize + skip_pixels / 8);
	spanInfo->srcStartBit = skip_pixels % 8;
    } else {
	spanInfo->srcCurrent = (GLvoid *) (((const GLubyte *) pixels) + 
		skip_lines * rowsize + skip_pixels * group_size);
    }
    spanInfo->srcRowIncrement = rowsize;
    spanInfo->srcGroupIncrement = group_size;
    spanInfo->srcComponents = components;
    spanInfo->srcElementSize = element_size;
}

/*
** An unpacker that unpacks from BITMAP source data, into FLOAT spans.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width;
    GLvoid *userData;
    GLfloat *spanData;
    GLint lsbFirst;
    GLint startBit;
    GLint bit;
    GLubyte ubyte;
    GLshort *pixelArray;
    GLint skipCount;
    __GLfloat zero, one;

    userData = inspan;
    spanData = (GLfloat *) outspan;
    pixelArray = spanInfo->pixelArray;

    width = spanInfo->width;
    lsbFirst = spanInfo->srcLsbFirst;
    startBit = spanInfo->srcStartBit;

    i = width;
    bit = startBit;
    ubyte = *(GLubyte *) userData;

    zero = __glZero;
    one = __glOne;

    skipCount = 1;
    if (lsbFirst) {
	switch(bit) {
	  case 1:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 2:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 3:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 4:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 5:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 6:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 7:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
    } else {
	switch(bit) {
	  case 1:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 2:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 3:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 4:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 5:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 6:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 7:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
    }
}

/*
** An unpacker that unpacks from BITMAP source data, into FLOAT spans.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void __glSpanUnpackBitmap2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                   GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width;
    GLvoid *userData;
    GLfloat *spanData;
    GLint lsbFirst;
    GLint startBit;
    GLint bit;
    GLubyte ubyte;

    width = spanInfo->realWidth;
    userData = inspan;
    spanData = (GLfloat *) outspan;

    lsbFirst = spanInfo->srcLsbFirst;
    startBit = spanInfo->srcStartBit;

    i = width;
    bit = startBit;
    ubyte = *(GLubyte *) userData;

    if (lsbFirst) {
	switch(bit) {
	  case 1:
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 2:
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 3:
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 4:
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 5:
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 6:
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 7:
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
    } else {
	switch(bit) {
	  case 1:
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 2:
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 3:
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 4:
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 5:
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 6:
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 7:
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
    }
}

/*
** An unpacker that unpacks from RGB, UNSIGNED_BYTE source data, into 
** RGB, UNSIGNED_BYTE spans.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                    GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLubyte *userData;
    GLubyte *spanData;
    GLint width, groupInc;
    GLshort *pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    width = spanInfo->realWidth;
    groupInc = spanInfo->srcGroupIncrement;
    userData = (GLubyte *) inspan;
    spanData = (GLubyte *) outspan;

    pixelArray = spanInfo->pixelArray;

    i = 0;
    do {
	spanData[0] = userData[0];
	spanData[1] = userData[1];
	spanData[2] = userData[2];
	spanData += 3;

	skipCount = *pixelArray++;
	userData = (GLubyte *) ((GLubyte *) userData + 3 * skipCount);
	i++;
    } while (i<width);
}

/*
** An unpacker that unpacks from either index, UNSIGNED_BYTE source data, 
** into UNSIGNED_BYTE spans.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackIndexUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                      GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLubyte *userData;
    GLubyte *spanData;
    GLint width, groupInc;
    GLshort *pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    width = spanInfo->realWidth;
    groupInc = spanInfo->srcGroupIncrement;
    userData = (GLubyte *) inspan;
    spanData = (GLubyte *) outspan;
    
    pixelArray = spanInfo->pixelArray;

    i = 0;
    do {
	*spanData = *userData;
	spanData++;

	skipCount = *pixelArray++;
	userData = (GLubyte *) ((GLubyte *) userData + skipCount);
	i++;
    } while (i<width);
}

/*
** An unpacker that unpacks from RGBA, UNSIGNED_BYTE source data, into 
** RGBA, UNSIGNED_BYTE spans.
**
** This could be faster if we could assume that the first ubyte (red)
** was aligned on a word boundary.  Then we could just use unsigned int
** pointers to copy the user's data.  This might be a reasonable future
** optimization.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                     GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLubyte *userData;
    GLubyte *spanData;
    GLint width, groupInc;
    GLshort *pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    width = spanInfo->realWidth;
    groupInc = spanInfo->srcGroupIncrement;
    userData = (GLubyte *) inspan;
    spanData = (GLubyte *) outspan;

    pixelArray = spanInfo->pixelArray;

    i = 0;
    do {
	spanData[0] = userData[0];
	spanData[1] = userData[1];
	spanData[2] = userData[2];
	spanData[3] = userData[3];
	spanData += 4;

	skipCount = *pixelArray++;
	userData = (GLubyte *) ((GLubyte *) userData + (skipCount << 2));
	i++;
    } while (i<width);
}

/*
** Swaps bytes from an incoming span of two byte objects to an outgoing span.
** No pixel skipping is performed.
*/
void __glSpanSwapBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = b;
	outData[1] = a;
	outData += 2;
	inData += 2;
    }
}

/*
** Swaps bytes from an incoming span of two byte objects to an outgoing span.
** No pixel skipping is performed.  This version is for swapping to the 
** desination image.
*/
void __glSpanSwapBytes2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = b;
	outData[1] = a;
	outData += 2;
	inData += 2;
    }
}

/*
** Swaps bytes from an incoming span of two byte objects to an outgoing span.
** Pixel skipping is performed.
*/
void __glSpanSwapAndSkipBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		               GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    a = inData[0];
	    b = inData[1];
	    outData[0] = b;
	    outData[1] = a;
	    outData += 2;
	    inData += 2;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLubyte *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** Swaps bytes from an incoming span of four byte objects to an outgoing span.
** No pixel skipping is performed.
*/
void __glSpanSwapBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	c = inData[2];
	d = inData[3];
	a = inData[0];
	b = inData[1];
	outData[0] = d;
	outData[1] = c;
	outData[2] = b;
	outData[3] = a;
	outData += 4;
	inData += 4;
    }
}

/*
** Swaps bytes from an incoming span of four byte objects to an outgoing span.
** No pixel skipping is performed.  This version is for swapping to the 
** destination image.
*/
void __glSpanSwapBytes4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	c = inData[2];
	d = inData[3];
	a = inData[0];
	b = inData[1];
	outData[0] = d;
	outData[1] = c;
	outData[2] = b;
	outData[3] = a;
	outData += 4;
	inData += 4;
    }
}

/*
** Swaps bytes from an incoming span of four byte objects to an outgoing span.
** Pixel skipping is performed.
*/
void __glSpanSwapAndSkipBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		               GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    c = inData[2];
	    d = inData[3];
	    outData[0] = d;
	    outData[1] = c;
	    a = inData[0];
	    b = inData[1];
	    outData[2] = b;
	    outData[3] = a;
	    outData += 4;
	    inData += 4;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLubyte *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 1 byte in size.
*/
void __glSpanSkipPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    *outData++ = *inData++;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLubyte *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 2 bytes in size, and aligned on a half
** word boundary.
*/
void __glSpanSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLushort *inData = (GLushort *) inspan;
    GLushort *outData = (GLushort *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    *outData++ = *inData++;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLushort *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 4 bytes in size, and aligned on a word
** boundary.
*/
void __glSpanSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLuint *inData = (GLuint *) inspan;
    GLuint *outData = (GLuint *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    *outData++ = *inData++;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLuint *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 2 bytes in size.  No alignment is assumed,
** so misaligned data should use this path.
*/
void __glSpanSlowSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    a = inData[0];
	    b = inData[1];
	    outData[0] = a;
	    outData[1] = b;
	    outData += 2;
	    inData += 2;
	}

	skipCount = (*pixelArray++) - 1;
	inData = ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 4 bytes in size.  No alignment is assumed,
** so misaligned data should use this path.
*/
void __glSpanSlowSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    a = inData[0];
	    b = inData[1];
	    c = inData[2];
	    d = inData[3];
	    outData[0] = a;
	    outData[1] = b;
	    outData[2] = c;
	    outData[3] = d;
	    outData += 4;
	    inData += 4;
	}

	skipCount = (*pixelArray++) - 1;
	inData = ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that aligns pixels 2 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.
*/
void __glSpanAlignPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = a;
	outData[1] = b;
	outData += 2;
	inData += 2;
    }
}

/*
** A span modifier that aligns pixels 2 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.  This version is for
** aligning to the destination image.
*/
void __glSpanAlignPixels2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = a;
	outData[1] = b;
	outData += 2;
	inData += 2;
    }
}

/*
** A span modifier that aligns pixels 4 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.
*/
void __glSpanAlignPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	c = inData[2];
	d = inData[3];
	outData[0] = a;
	outData[1] = b;
	outData[2] = c;
	outData[3] = d;
	outData += 4;
	inData += 4;
    }
}

/*
** A span modifier that aligns pixels 4 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.  This version is 
** for swapping to the destination image.
*/
void __glSpanAlignPixels4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	c = inData[2];
	d = inData[3];
	outData[0] = a;
	outData[1] = b;
	outData[2] = c;
	outData[3] = d;
	outData += 4;
	inData += 4;
    }
}

/*
** Unpacks from any component of type UNSIGNED_BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_UB_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLbyte *inData = (GLbyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_B_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type UNSIGNED_SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLushort *inData = (GLushort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_US_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLshort *inData = (GLshort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_S_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type UNSIGNED_INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLuint *inData = (GLuint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_UI_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLint *inData = (GLint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_I_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any index of type UNSIGNED_BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLbyte *inData = (GLbyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type UNSIGNED_SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                   GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLushort *inData = (GLushort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLshort *inData = (GLshort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type UNSIGNED_INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLuint *inData = (GLuint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLint *inData = (GLint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Clamps from any type FLOAT to a span of the same format of type FLOAT.
*/
void __glSpanClampFloat(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat r, one, zero;

    one = __glOne;
    zero = __glZero;
    for (i=0; i<totalSize; i++) {
	r = *inData++;
	if (r > one) r = one;
	else if (r < zero) r = zero;
	*outData++ = r;
    }
}

/*
** Clamps from a signed FLOAT [-1, 1] to a span of the same format of type 
** FLOAT.
*/
void __glSpanClampSigned(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat r, zero;

    zero = __glZero;
    for (i=0; i<totalSize; i++) {
	r = *inData++;
	if (r < zero) r = zero;
	*outData++ = r;
    }
}

/*
** Expands and scales a RED, FLOAT span into a RGBA, FLOAT span.
*/
void __glSpanExpandRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat as = gc->frontBuffer.alphaScale;
    GLfloat rs = gc->frontBuffer.redScale;

    for (i=0; i<width; i++) {
	*outData++ = *inData++ * rs;	/* Red */
	*outData++ = zero;		/* Green */
	*outData++ = zero;		/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales a GREEN, FLOAT span into a RGBA, FLOAT span.
*/
void __glSpanExpandGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat gs = gc->frontBuffer.greenScale;
    GLfloat as = gc->frontBuffer.alphaScale;

    for (i=0; i<width; i++) {
	*outData++ = zero;		/* Red */
	*outData++ = *inData++ * gs;	/* Green */
	*outData++ = zero;		/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales a BLUE, FLOAT span into a RGBA, FLOAT span.
*/
void __glSpanExpandBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat bs = gc->frontBuffer.blueScale;
    GLfloat as = gc->frontBuffer.alphaScale;

    for (i=0; i<width; i++) {
	*outData++ = zero;		/* Red */
	*outData++ = zero;		/* Green */
	*outData++ = *inData++ * bs;	/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales an ALPHA, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat as = gc->frontBuffer.alphaScale;

    for (i=0; i<width; i++) {
	*outData++ = zero;		/* Red */
	*outData++ = zero;		/* Green */
	*outData++ = zero;		/* Blue */
	*outData++ = *inData++ * as;	/* Alpha */
    }
}

/*
** Expands and scales an RGB, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat r,g,b;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	r = *inData++ * rs;
	g = *inData++ * gs;
	b = *inData++ * bs;
	*outData++ = r;
	*outData++ = g;
	*outData++ = b;
	*outData++ = as;		/* Alpha */
    }
}

#ifdef GL_EXT_bgra
/*
** Expands and scales a BGR, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat r,g,b;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	b = *inData++ * bs;
	g = *inData++ * gs;
	r = *inData++ * rs;
	*outData++ = r;
	*outData++ = g;
	*outData++ = b;
	*outData++ = as;		/* Alpha */
    }
}
#endif

/*
** Expands and scales a LUMINANCE, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat comp;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	comp = *inData++;
	*outData++ = comp * rs;		/* Red */
	*outData++ = comp * gs;		/* Green */
	*outData++ = comp * bs;		/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales a LUMINANCE_ALPHA, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat comp;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	comp = *inData++;
	*outData++ = comp * rs;		/* Red */
	*outData++ = comp * gs;		/* Green */
	*outData++ = comp * bs;		/* Blue */
	*outData++ = *inData++ * as;	/* Alpha */
    }
}

/*
** Expands and scales a __GL_RED_ALPHA, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat comp;
    GLfloat zero;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    zero = __glZero;

    for (i=0; i<width; i++) {
	comp = *inData++;
	*outData++ = comp * rs;		/* Red */
	*outData++ = zero;
	*outData++ = zero;
	*outData++ = *inData++ * as;	/* Alpha */
    }
}

/*
** The only span format supported by this routine is GL_RGBA, GL_FLOAT.
** The span is simply scaled by the frame buffer scaling factors.
*/
void __glSpanScaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.redScale;
    gscale = gc->frontBuffer.greenScale;
    bscale = gc->frontBuffer.blueScale;
    ascale = gc->frontBuffer.alphaScale;
    for (i=0; i<width; i++) {
	red = *inData++ * rscale;
	green = *inData++ * gscale;
	*outData++ = red;
	*outData++ = green;
	blue = *inData++ * bscale;
	alpha = *inData++ * ascale;
	*outData++ = blue;
	*outData++ = alpha;
    }
}

/*
** The only span format supported by this routine is GL_RGBA, GL_FLOAT.
** The span is simply unscaled by the frame buffer scaling factors.
*/
void __glSpanUnscaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.oneOverRedScale;
    gscale = gc->frontBuffer.oneOverGreenScale;
    bscale = gc->frontBuffer.oneOverBlueScale;
    ascale = gc->frontBuffer.oneOverAlphaScale;
    for (i=0; i<width; i++) {
	red = *inData++ * rscale;
	green = *inData++ * gscale;
	*outData++ = red;
	*outData++ = green;
	blue = *inData++ * bscale;
	alpha = *inData++ * ascale;
	*outData++ = blue;
	*outData++ = alpha;
    }
}

#ifdef GL_EXT_bgra
/*
** The only span format supported by this routine is GL_BGRA, GL_FLOAT.
** The span is scaled by the frame buffer scaling factors and swapped
** into RGBA order.
*/
void __glSpanScaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.redScale;
    gscale = gc->frontBuffer.greenScale;
    bscale = gc->frontBuffer.blueScale;
    ascale = gc->frontBuffer.alphaScale;
    for (i=0; i<width; i++) {
	blue = *inData++ * bscale;
	green = *inData++ * gscale;
	red = *inData++ * rscale;
	alpha = *inData++ * ascale;
	*outData++ = red;
	*outData++ = green;
	*outData++ = blue;
	*outData++ = alpha;
    }
}

/*
** The only input format supported by this routine is GL_RGBA, GL_FLOAT.
** The span is unscaled by the frame buffer scaling factors and swapped
** into BGRA order.
*/
void __glSpanUnscaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.oneOverRedScale;
    gscale = gc->frontBuffer.oneOverGreenScale;
    bscale = gc->frontBuffer.oneOverBlueScale;
    ascale = gc->frontBuffer.oneOverAlphaScale;
    for (i=0; i<width; i++) {
	red = *inData++ * rscale;
	green = *inData++ * gscale;
	blue = *inData++ * bscale;
	alpha = *inData++ * ascale;
	*outData++ = blue;
	*outData++ = green;
	*outData++ = red;
	*outData++ = alpha;
    }
}
#endif

/*
** The only span format supported by this routine is palette index, GL_FLOAT.
** The span is simply scaled by the frame buffer scaling factors.
*/
#ifdef GL_EXT_paletted_texture
void __glSpanScalePI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                     GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;
    RGBQUAD *rgb;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    // Throw in an extra scaling of 1/255 because the palette
    // data is in ubyte format
    rscale = gc->frontBuffer.redScale*__glOneOver255;
    gscale = gc->frontBuffer.greenScale*__glOneOver255;
    bscale = gc->frontBuffer.blueScale*__glOneOver255;
    ascale = gc->frontBuffer.alphaScale*__glOneOver255;
    for (i=0; i<width; i++) {
        rgb = &spanInfo->srcPalette[(int)((*inData++)*
                                          spanInfo->srcPaletteSize)];
	red = rgb->rgbRed * rscale;
	green = rgb->rgbGreen * gscale;
	*outData++ = red;
	*outData++ = green;
	blue = rgb->rgbBlue * bscale;
	alpha = rgb->rgbReserved * ascale;
	*outData++ = blue;
	*outData++ = alpha;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\pixel\px_rende.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains routines to render a span of pixel data (from a 
** glDrawPixels or possibly a glCopyPixels request).
*/

/*
** This routine is used to store one fragment from a DrawPixels request.
** It should only be used if the user is either texturing or fogging.
*/
void FASTCALL __glSlowDrawPixelsStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLvertex *rp = &gc->state.current.rasterPos;
    __GLfragment newfrag;

    // The texturing code assumes that FPU truncation is enabled, so
    // we have to turn it on for this case:

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    newfrag = *frag;
    if (gc->texture.textureEnabled) {
	__GLfloat qInv = __glOne / rp->texture.w;
	(*gc->procs.texture)(gc, &newfrag.color, rp->texture.x * qInv,
			       rp->texture.y * qInv, __glOne);
    }
    if (gc->state.enables.general & __GL_FOG_ENABLE) {
	(*gc->procs.fogPoint)(gc, &newfrag, rp->eyeZ);
    }
    (*gc->procs.store)(cfb, &newfrag);

    FPU_RESTORE_MODE();
}

/*
** The only span format supported by this routine is GL_RGB, GL_UNSIGNED_BYTE.
** The store proc is assumed not to mess with the fragment color or alpha.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    frag.color.a = ((GLfloat *) (gc->pixel.alphaCurMap))[255];
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                do {
                    frag.x = column;

                    /* This procedure will do the rest */
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a RGB, UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
**
** The store proc is assumed not to mess with the fragment alpha.
*/
void FASTCALL __glSpanRenderRGBubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.color.a = ((GLfloat *) (gc->pixel.alphaCurMap))[255];
    frag.z = spanInfo->fragz;
    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                frag.x = i;

                /* This procedure will do the rest */
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                frag.color.a = alphaMap[*spanData++];
                do {
                    frag.x = column;

                    /* This procedure will do the rest */
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderRGBAubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.z = spanInfo->fragz;
    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                frag.color.a = alphaMap[*spanData++];
                frag.x = i;

                /* This procedure will do the rest */
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 32 bit depth buffers.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderDepthUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLuint*) span;
	frag.y = row;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.z = *spanData++;   /* Assumes 32 bit depth buffer */
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 32 bit depth buffers.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderDepthUint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLuint*) span;
	frag.y = row;
	i = startCol;
	do {
	    frag.z = *spanData++;   /* Assumes 32 bit depth buffer */
	    frag.x = i;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 31 bit depth buffers.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderDepth2Uint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLuint*) span;
	frag.y = row;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.z = (*spanData++) >> 1;   /* Assumes 31 bit depth buffer */
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 31 bit depth buffers.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderDepth2Uint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		               GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLuint*) span;
	frag.y = row;
	i = startCol;
	do {
	    frag.z = (*spanData++) >> 1;   /* Assumes 31 bit depth buffer */
	    frag.x = i;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_SHORT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderStencilUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                 GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLushort *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint rows;
    GLint startCol;
    GLint value;
    GLshort *pixelArray;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = sb->store;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLushort*) span;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    value = *spanData++;
	    do {
		(*store)(sb, column, row, value);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_SHORT span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderStencilUshort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLushort *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint endCol, startCol;
    GLint rows;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    store = sb->store;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLushort*) span;
	i = startCol;
	do {
	    (*store)(sb, i, row, *spanData++);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderStencilUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint rows;
    GLint startCol;
    GLint value;
    GLshort *pixelArray;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = sb->store;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLubyte*) span;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    value = *spanData++;
	    do {
		(*store)(sb, column, row, value);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderStencilUbyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                 GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint endCol, startCol;
    GLint rows;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    store = sb->store;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLubyte*) span;
	i = startCol;
	do {
	    (*store)(sb, i, row, *spanData++);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_SHORT span.  gc->modes.rgbMode must 
** be GL_FALSE.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCIushort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLushort *spanData;
    GLint rows;
    GLint startCol;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLshort *pixelArray;
    GLint mask;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLushort*) span;
	frag.y = row;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.color.r = *spanData++ & mask;
	    do {
		frag.x = column;
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_SHORT.  gc->modes.rgbMode must 
** be GL_FALSE.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCIushort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLushort *spanData;
    GLint endCol, startCol;
    GLint rows;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint mask;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLushort*) span;
	frag.y = row;
	i = startCol;
	do {
	    frag.x = i;
	    frag.color.r = *spanData++ & mask;
	    (*store)(gc->drawBuffer, &frag);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  gc->modes.rgbMode must 
** be GL_FALSE.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCIubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			   GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLint rows;
    GLint startCol;
    GLfloat *indexMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    indexMap = (GLfloat*) gc->pixel.iCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (indexMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                frag.color.r = indexMap[*spanData++];
                do {
                    frag.x = column;
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  Also, gc->modes.rgbMode 
** must be GL_FALSE.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCIubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLint endCol, startCol;
    GLint rows;
    GLfloat *indexMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    indexMap = (GLfloat*) gc->pixel.iCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (indexMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.x = i;
                frag.color.r = indexMap[*spanData++];
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  Also, gc->modes.rgbMode 
** must be GL_TRUE.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCIubyte3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLint rows;
    GLint startCol;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    GLubyte value;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                value = *spanData++;
                frag.color.r = redMap[value];
                frag.color.g = greenMap[value];
                frag.color.b = blueMap[value];
                frag.color.a = alphaMap[value];
                do {
                    frag.x = column;
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  Also, gc->modes.rgbMode 
** must be GL_TRUE.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCIubyte4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLint endCol, startCol;
    GLint rows;
    GLubyte value;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.x = i;
                value = *spanData++;
                frag.color.r = redMap[value];
                frag.color.g = greenMap[value];
                frag.color.b = blueMap[value];
                frag.color.a = alphaMap[value];
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, scaled (by the implementation color scales) GL_FLOAT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;

    rows = spanInfo->rows;
    frag.z = spanInfo->fragz;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.color.r = *spanData++;
	    frag.color.g = *spanData++;
	    frag.color.b = *spanData++;
	    frag.color.a = *spanData++;
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, scaled (by the implementation color scales) GL_FLOAT span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;

    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    frag.color.r = *spanData++;
	    frag.color.g = *spanData++;
	    frag.color.b = *spanData++;
	    frag.color.a = *spanData++;
	    frag.x = column;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_FLOAT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;
    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;

	    frag.z = *spanData++ * gc->depthBuffer.scale;

	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_FLOAT.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		          GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;
    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    frag.x = column;
	    frag.z = *spanData++ * gc->depthBuffer.scale;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_FLOAT span (gc->modes.rgbMode == GL_FALSE).
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLshort *pixelArray;
    GLint mask;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.color.r = (GLint) (*spanData++) & mask;
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_COLOR_INDEX, GL_FLOAT span (gc->modes.rgbMode == GL_FALSE).
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint mask;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    frag.color.r = (GLint) (*spanData++) & mask;
	    frag.x = column;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_FLOAT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    GLint index;
    __GLstencilBuffer *sb;
    GLint rows;
    GLshort *pixelArray;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    sb = &gc->stencilBuffer;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    index = *spanData++;
	    do {
		(*sb->store)(sb, column, row, index);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_FLOAT span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    GLint index;
    __GLstencilBuffer *sb;
    GLint rows;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    sb = &gc->stencilBuffer;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	for (i=0; i<width; i++) {
	    index = *spanData++;
	    (*sb->store)(sb, column, row, index);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_alpha.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop


/* - Fetch converts GLubyte alpha value to float and puts in __GLcolor
   - Likewise, Store does the reverse
   - All input coords are viewport biased
*/

static void FASTCALL 
Store(__GLalphaBuffer *afb, GLint x, GLint y, const __GLcolor *color)
{
    GLubyte *pAlpha;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);
    *pAlpha = (GLubyte) FTOL( color->a );
}

static void FASTCALL 
StoreSpan(__GLalphaBuffer *afb)
{
    GLint w;
    GLubyte *pAlpha;
    __GLcolor *cp;
    __GLcontext *gc = afb->buf.gc;

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), gc->polygon.shader.frag.x, 
                                              gc->polygon.shader.frag.y);
    for( ; w ; w--, cp++, pAlpha++ )
        *pAlpha = (GLubyte) FTOL( cp->a );
}

// Generic version of StoreSpan
static void FASTCALL 
StoreSpan2( __GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *cp )
{
    GLubyte *pAlpha;
    __GLcontext *gc = afb->buf.gc;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);
    for( ; w ; w--, cp++, pAlpha++ )
        *pAlpha = (GLubyte) FTOL( cp->a );
}

static void FASTCALL 
Fetch(__GLalphaBuffer *afb, GLint x, GLint y, __GLcolor *result)
{
    GLubyte *pAlpha;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);
    result->a = (__GLfloat) *pAlpha;
}

static void FASTCALL 
ReadSpan(__GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *results)
{
    GLubyte *pAlpha;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);

    for( ; w ; w--, results++, pAlpha++ )
        results->a = (__GLfloat) *pAlpha;
}

static void FASTCALL Clear(__GLalphaBuffer *afb)
{
    __GLcontext *gc = afb->buf.gc;
    __GLcolor *clear;
    BYTE alphaClear;
    GLint x0, x1, y0, y1;
    int width, height, i;
    GLubyte *puj;

    // Check if alpha is masked
    if( ! gc->state.raster.aMask )
        return;

    // Get the alpha clear value
    clear = &gc->state.raster.clear;
    alphaClear = (BYTE) (clear->a*gc->frontBuffer.alphaScale);

    // Get area to clear
    x0 = __GL_UNBIAS_X(gc, gc->transform.clipX0);
    x1 = __GL_UNBIAS_X(gc, gc->transform.clipX1);
    y0 = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
    y1 = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
    width = x1 - x0;
    height = y1 - y0;
    if( (width <= 0) || (height <= 0) )
        return;

    puj = (GLubyte *)((ULONG_PTR)afb->buf.base + (y0*afb->buf.outerWidth) + x0 );

    if (width == afb->buf.outerWidth) {
        // Clearing contiguous buffer
        RtlFillMemory( (PVOID) puj, width * height, alphaClear);
        return;
    }

    // Clearing sub-rectangle of buffer
    for( i = height; i; i--, puj += afb->buf.outerWidth )
        RtlFillMemory( (PVOID) puj, width, alphaClear );
}

void FASTCALL __glInitAlpha(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    __GLalphaBuffer *afb = &cfb->alphaBuf;

    // The software alpha buffer is 8-bit.
    afb->buf.elementSize = sizeof(GLubyte);
    afb->store = Store;
    afb->storeSpan = StoreSpan;
    afb->storeSpan2 = StoreSpan2;
    afb->fetch = Fetch;
    afb->readSpan = ReadSpan;
    afb->clear = Clear;

    afb->buf.gc = gc;
    afb->alphaScale = cfb->alphaScale;
}

/*
** Initialize a lookup table that is indexed by the iterated alpha value.
** The table indicates whether the alpha test passed or failed, based on
** the current alpha function and the alpha reference value.
**
** NOTE:  The alpha span routines will never be called if the alpha test
** is GL_ALWAYS (its useless) or if the alpha test is GL_NEVER.  This
** is accomplished in the __glGenericPickSpanProcs procedure.
*/

void FASTCALL __glValidateAlphaTest(__GLcontext *gc)
{
    GLubyte *atft;
    GLint i, limit;
    GLint ref;
    GLenum alphaTestFunc = gc->state.raster.alphaFunction;

    limit = gc->constants.alphaTestSize;
    ref = (GLint)
	((gc->state.raster.alphaReference * gc->frontBuffer.alphaScale) *
	gc->constants.alphaTableConv);

    /*
    ** Allocate alpha test function table the first time.  It needs
    ** to have at most one entry for each possible alpha value.
    */
    atft = gc->alphaTestFuncTable;
    if (!atft) {
	atft = (GLubyte*) GCALLOC(gc, (limit) * sizeof(GLubyte));
	gc->alphaTestFuncTable = atft;
    }

    /*
    ** Build up alpha test lookup table.  The computed alpha value is
    ** used as an index into this table to determine if the alpha
    ** test passed or failed.
    */
    for (i = 0; i < limit; i++) {
	switch (alphaTestFunc) {
	  case GL_NEVER:	*atft++ = GL_FALSE; break;
	  case GL_LESS:		*atft++ = (GLubyte) (i <  ref); break;
	  case GL_EQUAL:	*atft++ = (GLubyte) (i == ref); break;
	  case GL_LEQUAL:	*atft++ = (GLubyte) (i <= ref); break;
	  case GL_GREATER:	*atft++ = (GLubyte) (i >  ref); break;
	  case GL_NOTEQUAL:	*atft++ = (GLubyte) (i != ref); break;
	  case GL_GEQUAL:	*atft++ = (GLubyte) (i >= ref); break;
	  case GL_ALWAYS:	*atft++ = GL_TRUE; break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_accum.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

void Load(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, ow, skip;
    __GLfloat rval, gval, bval, aval;
    __GLaccumCell *ac;
    __GLcolorBuffer *cfb;
#ifdef NT
    __GLcolor *cbuf;

    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));

    if (NULL == cbuf)
        return;
#else
    __GLcolor cbuf[4096];/*XXX*/

    w = x1 - x0;
    assert(w < 4096);/*XXX*/
#endif

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    rval = val * afb->redScale;
    gval = val * afb->greenScale;
    bval = val * afb->blueScale;
    aval = val * afb->alphaScale;

    for (; y0 < y1; y0++) {
	__GLcolor *cp = &cbuf[0];
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], ow);

	w = w4;
	while (--w >= 0) {
	    ac[0].r = (__GLaccumCellElement) (cp[0].r * rval);
	    ac[0].g = (__GLaccumCellElement) (cp[0].g * gval);
	    ac[0].b = (__GLaccumCellElement) (cp[0].b * bval);
	    ac[0].a = (__GLaccumCellElement) (cp[0].a * aval);

	    ac[1].r = (__GLaccumCellElement) (cp[1].r * rval);
	    ac[1].g = (__GLaccumCellElement) (cp[1].g * gval);
	    ac[1].b = (__GLaccumCellElement) (cp[1].b * bval);
	    ac[1].a = (__GLaccumCellElement) (cp[1].a * aval);

	    ac[2].r = (__GLaccumCellElement) (cp[2].r * rval);
	    ac[2].g = (__GLaccumCellElement) (cp[2].g * gval);
	    ac[2].b = (__GLaccumCellElement) (cp[2].b * bval);
	    ac[2].a = (__GLaccumCellElement) (cp[2].a * aval);

	    ac[3].r = (__GLaccumCellElement) (cp[3].r * rval);
	    ac[3].g = (__GLaccumCellElement) (cp[3].g * gval);
	    ac[3].b = (__GLaccumCellElement) (cp[3].b * bval);
	    ac[3].a = (__GLaccumCellElement) (cp[3].a * aval);
	    ac += 4;
	    cp += 4;
	}

	w = w1;
	while (--w >= 0) {
	    ac->r = (__GLaccumCellElement) (cp->r * rval);
	    ac->g = (__GLaccumCellElement) (cp->g * gval);
	    ac->b = (__GLaccumCellElement) (cp->b * bval);
	    ac->a = (__GLaccumCellElement) (cp->a * aval);
	    ac++;
	    cp++;
	}
	ac += skip;
    }
#ifdef NT
    gcTempFree(gc, cbuf);
#endif
}

void Accumulate(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, ow, skip, w4, w1;
    __GLfloat rval, gval, bval, aval;
    __GLaccumCell *ac;
    __GLcolorBuffer *cfb;
#ifdef NT
    __GLcolor *cbuf;

    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));

    if (NULL == cbuf)
        return;
#else
    __GLcolor cbuf[4096];/*XXX*/

    w = x1 - x0;
    assert(w < 4096);/*XXX*/
#endif

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    rval = val * afb->redScale;
    gval = val * afb->greenScale;
    bval = val * afb->blueScale;
    aval = val * afb->alphaScale;

    for (; y0 < y1; y0++) {
	__GLcolor *cp = &cbuf[0];
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], ow);

	w = w4;
	while (--w >= 0) {
	    ac[0].r += (__GLaccumCellElement) (cp[0].r * rval);
	    ac[0].g += (__GLaccumCellElement) (cp[0].g * gval);
	    ac[0].b += (__GLaccumCellElement) (cp[0].b * bval);
	    ac[0].a += (__GLaccumCellElement) (cp[0].a * aval);

	    ac[1].r += (__GLaccumCellElement) (cp[1].r * rval);
	    ac[1].g += (__GLaccumCellElement) (cp[1].g * gval);
	    ac[1].b += (__GLaccumCellElement) (cp[1].b * bval);
	    ac[1].a += (__GLaccumCellElement) (cp[1].a * aval);

	    ac[2].r += (__GLaccumCellElement) (cp[2].r * rval);
	    ac[2].g += (__GLaccumCellElement) (cp[2].g * gval);
	    ac[2].b += (__GLaccumCellElement) (cp[2].b * bval);
	    ac[2].a += (__GLaccumCellElement) (cp[2].a * aval);

	    ac[3].r += (__GLaccumCellElement) (cp[3].r * rval);
	    ac[3].g += (__GLaccumCellElement) (cp[3].g * gval);
	    ac[3].b += (__GLaccumCellElement) (cp[3].b * bval);
	    ac[3].a += (__GLaccumCellElement) (cp[3].a * aval);
	    ac += 4;
	    cp += 4;
	}

	w = w1;
	while (--w >= 0) {
	    ac->r += (__GLaccumCellElement) (cp->r * rval);
	    ac->g += (__GLaccumCellElement) (cp->g * gval);
	    ac->b += (__GLaccumCellElement) (cp->b * bval);
	    ac->a += (__GLaccumCellElement) (cp->a * aval);
	    ac++;
	    cp++;
	}
	ac += skip;
    }
#ifdef NT
    gcTempFree(gc, cbuf);
#endif
}

void Mult(__GLaccumBuffer *afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    __GLaccumCell *ac;

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = x1 - x0;
    skip = afb->buf.outerWidth - w;

    if (val == __glZero) {
	/* Zero out the buffers contents */
	for (; y0 < y1; y0++) {
	    GLint ww = w;
	    while (ww > 0) {
		ac[0].r = 0; ac[0].g = 0; ac[0].b = 0; ac[0].a = 0;
		ac++;
		ww--;
	    }
	    ac += skip;
	}
	return;
    }

    w4 = w >> 2;
    w1 = w & 3;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0].r = (__GLaccumCellElement) (ac[0].r * val);
	    ac[0].g = (__GLaccumCellElement) (ac[0].g * val);
	    ac[0].b = (__GLaccumCellElement) (ac[0].b * val);
	    ac[0].a = (__GLaccumCellElement) (ac[0].a * val);
	    ac[1].r = (__GLaccumCellElement) (ac[1].r * val);
	    ac[1].g = (__GLaccumCellElement) (ac[1].g * val);
	    ac[1].b = (__GLaccumCellElement) (ac[1].b * val);
	    ac[1].a = (__GLaccumCellElement) (ac[1].a * val);
	    ac[2].r = (__GLaccumCellElement) (ac[2].r * val);
	    ac[2].g = (__GLaccumCellElement) (ac[2].g * val);
	    ac[2].b = (__GLaccumCellElement) (ac[2].b * val);
	    ac[2].a = (__GLaccumCellElement) (ac[2].a * val);
	    ac[3].r = (__GLaccumCellElement) (ac[3].r * val);
	    ac[3].g = (__GLaccumCellElement) (ac[3].g * val);
	    ac[3].b = (__GLaccumCellElement) (ac[3].b * val);
	    ac[3].a = (__GLaccumCellElement) (ac[3].a * val);
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    ac[0].r = (__GLaccumCellElement) (ac[0].r * val);
	    ac[0].g = (__GLaccumCellElement) (ac[0].g * val);
	    ac[0].b = (__GLaccumCellElement) (ac[0].b * val);
	    ac[0].a = (__GLaccumCellElement) (ac[0].a * val);
	    ac++;
	}
	ac += skip;
    }
}

void Add(__GLaccumBuffer *afb, __GLfloat value)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    __GLaccumCellElement rval, gval, bval, aval;
    __GLaccumCell *ac;

    rval = (__GLaccumCellElement)
	(value * gc->frontBuffer.redScale * afb->redScale + __glHalf);
    gval = (__GLaccumCellElement)
	(value * gc->frontBuffer.greenScale * afb->greenScale + __glHalf);
    bval = (__GLaccumCellElement)
	(value * gc->frontBuffer.blueScale * afb->blueScale + __glHalf);
    aval = (__GLaccumCellElement)
	(value * gc->frontBuffer.alphaScale * afb->alphaScale + __glHalf);

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = x1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0].r += rval; ac[0].g += gval; ac[0].b += bval; ac[0].a += aval;
	    ac[1].r += rval; ac[1].g += gval; ac[1].b += bval; ac[1].a += aval;
	    ac[2].r += rval; ac[2].g += gval; ac[2].b += bval; ac[2].a += aval;
	    ac[3].r += rval; ac[3].g += gval; ac[3].b += bval; ac[3].a += aval;
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    ac[0].r += rval; ac[0].g += gval; ac[0].b += bval; ac[0].a += aval;
	    ac++;
	}
	ac += skip;
    }
}

void Return(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, next;
    __GLaccumCell *ac;
    __GLcolorBuffer *cfb;
    __GLcolorBuffer *cfb2;
    __GLfragment frag;
    __GLcolor *pAccumCol;
    // The returnspan routines use FTOL 
    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = x1 - x0;
    next = afb->buf.outerWidth;
    frag.y = y0;

    // Preallocate a color buffer for the return span functions
    pAccumCol = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if( NULL == pAccumCol )
        return;
    afb->colors = pAccumCol;

    if (gc->buffers.doubleStore) {
	/* Store to both buffers */
	cfb = &gc->frontBuffer;
	cfb2 = &gc->backBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, ac, val, w);
	    (*cfb2->returnSpan)(cfb2, x0, y0, ac, val, w);
	    ac += next;
	}
    } else {
	cfb = gc->drawBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, ac, val, w);
	    ac += next;
	}
    }
    FPU_RESTORE_MODE();
    gcTempFree( gc, pAccumCol );
}

void FASTCALL Clear(__GLaccumBuffer* afb)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    __GLaccumCell *ac;
    __GLaccumCellElement r, g, b, a;
    __GLcolorBuffer *cfb = &gc->frontBuffer;
    __GLcolor *val = &gc->state.accum.clear;

    /*
    ** Convert abstract color into specific color value.
    */
    r = (__GLaccumCellElement) (val->r * cfb->redScale * afb->redScale);
    g = (__GLaccumCellElement) (val->g * cfb->greenScale * afb->greenScale);
    b = (__GLaccumCellElement) (val->b * cfb->blueScale * afb->blueScale);
    a = (__GLaccumCellElement) (val->a * cfb->alphaScale * afb->alphaScale);

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = gc->transform.clipX1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0].r = r; ac[0].g = g; ac[0].b = b; ac[0].a = a;
	    ac[1].r = r; ac[1].g = g; ac[1].b = b; ac[1].a = a;
	    ac[2].r = r; ac[2].g = g; ac[2].b = b; ac[2].a = a;
	    ac[3].r = r; ac[3].g = g; ac[3].b = b; ac[3].a = a;
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    ac[0].r = r; ac[0].g = g; ac[0].b = b; ac[0].a = a;
	    ac++;
	}
	ac += skip;
    }
}

/************************************************************************/

void FASTCALL Pick(__GLcontext *gc, __GLaccumBuffer *afb)
{
#ifdef __GL_LINT
    gc = gc;
    afb = afb;
#endif
}

void FASTCALL __glInitAccum64(__GLcontext *gc, __GLaccumBuffer *afb)
{
    afb->buf.elementSize = sizeof(__GLaccumCell);
    afb->buf.gc = gc;
    if (gc->modes.rgbMode) {
	__GLcolorBuffer *cfb;
	__GLfloat scale;

	scale = (__GLfloat)((1 << (8 * sizeof(__GLaccumCellElement)))/2 - 1);

	cfb = &gc->frontBuffer;
	afb->redScale = scale / (cfb->redScale);
	afb->blueScale = scale / (cfb->blueScale);
	afb->greenScale = scale / (cfb->greenScale);
	afb->alphaScale = scale / (cfb->alphaScale);

	afb->oneOverRedScale = 1 / afb->redScale;
	afb->oneOverGreenScale = 1 / afb->greenScale;
	afb->oneOverBlueScale = 1 / afb->blueScale;
	afb->oneOverAlphaScale = 1 / afb->alphaScale;
    }
    afb->pick = Pick;
    afb->clear = Clear;
    afb->accumulate = Accumulate;
    afb->load = Load;
    afb->ret = Return;
    afb->mult = Mult;
    afb->add = Add;
}

void FASTCALL __glFreeAccum64(__GLcontext *gc, __GLaccumBuffer *afb)
{
#ifdef __GL_LINT
    gc = gc;
    afb = afb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_attri.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include "lighting.h"

#ifdef unix
#include <GL/glxproto.h>
#endif

void APIPRIVATE __glim_AlphaFunc(GLenum af, GLfloat ref)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((af < GL_NEVER) || (af > GL_ALWAYS)) {
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    if (__GL_FLOAT_LTZ (ref)) ref = __glZero;
    if (__GL_FLOAT_COMPARE_PONE (ref, >)) ref = __glOne;

    if ((gc->state.raster.alphaFunction != af) || 
        __GL_FLOAT_NE (gc->state.raster.alphaReference, ref)) {
        gc->state.raster.alphaFunction = af;
        gc->state.raster.alphaReference = ref;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ALPHATEST);
#endif
        gc->validateMask |= __GL_VALIDATE_ALPHA_FUNC;
    }
}

void APIPRIVATE __glim_BlendFunc(GLenum sf, GLenum df)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (sf) {
      case GL_ZERO:
      case GL_ONE:
      case GL_DST_COLOR:
      case GL_ONE_MINUS_DST_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
      case GL_SRC_ALPHA_SATURATE:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (df) {
      case GL_ZERO:
      case GL_ONE:
      case GL_SRC_COLOR:
      case GL_ONE_MINUS_SRC_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    if ((gc->state.raster.blendSrc != sf) || 
        (gc->state.raster.blendDst != df)) {
        gc->state.raster.blendSrc = sf;
        gc->state.raster.blendDst = df;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, BLEND);
#endif
    }
}

void APIPRIVATE __glim_ClearAccum(GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
    __GLfloat minusOne;
    __GLfloat one;
    __GL_SETUP_NOT_IN_BEGIN();

    minusOne = __glMinusOne;
    one = __glOne;
    if (r < minusOne) r = minusOne;
    if (r > one) r = one;
    if (g < minusOne) g = minusOne;
    if (g > one) g = one;
    if (b < minusOne) b = minusOne;
    if (b > one) b = one;
    if (a < minusOne) a = minusOne;
    if (a > one) a = one;

    if (__GL_FLOAT_NE (gc->state.accum.clear.r, r) || 
        __GL_FLOAT_NE (gc->state.accum.clear.g, g) ||
        __GL_FLOAT_NE (gc->state.accum.clear.b, b) || 
        __GL_FLOAT_NE (gc->state.accum.clear.a, a)) 
    {
        gc->state.accum.clear.r = r;
        gc->state.accum.clear.g = g;
        gc->state.accum.clear.b = b;
        gc->state.accum.clear.a = a;
        __GL_DELAY_VALIDATE(gc);
    }
}

void APIPRIVATE __glim_ClearColor (GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
    __GLfloat zero;
    __GLfloat one;
    __GL_SETUP_NOT_IN_BEGIN();

    zero = (__GLfloat)__glZero;
    one = (__GLfloat)__glOne;
    if (__GL_FLOAT_LTZ(r)) r = zero;
    if (__GL_FLOAT_COMPARE_PONE (r, >)) r = one;
    if (__GL_FLOAT_LTZ(g)) g = zero;
    if (__GL_FLOAT_COMPARE_PONE (g, >)) g = one;
    if (__GL_FLOAT_LTZ(b)) b = zero;
    if (__GL_FLOAT_COMPARE_PONE (b, >)) b = one;
    if (__GL_FLOAT_LTZ(a)) a = zero;
    if (__GL_FLOAT_COMPARE_PONE (a, >)) a = one;

#if 0
    if (__GL_FLOAT_NE (gc->state.raster.clear.r, r) || 
        __GL_FLOAT_NE (gc->state.raster.clear.g, g) ||
        __GL_FLOAT_NE (gc->state.raster.clear.b, b) || 
        __GL_FLOAT_NE (gc->state.raster.clear.a, a)) 
    {
#endif
        gc->state.raster.clear.r = r;
        gc->state.raster.clear.g = g;
        gc->state.raster.clear.b = b;
        gc->state.raster.clear.a = a;
	
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    //}
}

void APIPRIVATE __glim_ClearDepth(GLdouble z)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (z < (GLdouble) 0) z = (GLdouble)0;
    if (z > (GLdouble) 1) z = (GLdouble)1;
    if (gc->state.depth.clear != z) {
        gc->state.depth.clear = z;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
#ifdef _MCD_
      MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_ClearIndex(GLfloat val)
{
    __GL_SETUP_NOT_IN_BEGIN();

    val = __GL_MASK_INDEXF(gc, val);
    gc->state.raster.clearIndex = val;

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
}

void APIPRIVATE __glim_ClearStencil(GLint s)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->state.stencil.clear != (GLshort) (s & __GL_MAX_STENCIL_VALUE)) {
        gc->state.stencil.clear = (GLshort) (s & __GL_MAX_STENCIL_VALUE);
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_ColorMask(GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((gc->state.raster.rMask != r) || (gc->state.raster.gMask != g) ||
        (gc->state.raster.bMask != b) || (gc->state.raster.aMask != a)) {
        gc->state.raster.rMask = r;
        gc->state.raster.gMask = g;
        gc->state.raster.bMask = b;
        gc->state.raster.aMask = a;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_ColorMaterial(GLenum face, GLenum p)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (face) {
      case GL_FRONT:
      case GL_BACK:
      case GL_FRONT_AND_BACK:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (p) {
      case GL_EMISSION:
      case GL_SPECULAR:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_AMBIENT_AND_DIFFUSE:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    gc->state.light.colorMaterialFace = face;
    gc->state.light.colorMaterialParam = p;

    if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) {
#ifdef NT
	ComputeColorMaterialChange(gc);
#endif
	(*gc->procs.pickColorMaterialProcs)(gc);
	(*gc->procs.applyColor)(gc);
    }

    MCD_STATE_DIRTY(gc, COLORMATERIAL);
}

void APIPRIVATE __glim_CullFace(GLenum cfm)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (cfm) {
      case GL_FRONT:
      case GL_BACK:
      case GL_FRONT_AND_BACK:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->state.polygon.cull != cfm) {
        gc->state.polygon.cull = cfm;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
    }
}

void APIPRIVATE __glim_DepthFunc(GLenum zf)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((zf < GL_NEVER) || (zf > GL_ALWAYS)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->modes.depthBits != 0)
        gc->state.depth.testFunc = zf;
    else
        gc->state.depth.testFunc = GL_ALWAYS;
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, DEPTHTEST);
#endif
}

void APIPRIVATE __glim_DepthMask(GLboolean enabled)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->state.depth.writeEnable != enabled) {
        gc->state.depth.writeEnable = enabled;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_DrawBuffer(GLenum mode)
{
    GLint i;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_NONE:
	gc->state.raster.drawBuffer = GL_NONE;
	break;
      case GL_FRONT_RIGHT:
      case GL_BACK_RIGHT:
      case GL_RIGHT:
      not_supported_in_this_implementation:
	__glSetError(GL_INVALID_OPERATION);
	return;
      case GL_FRONT:
      case GL_FRONT_LEFT:
	gc->state.raster.drawBuffer = GL_FRONT;
	break;
      case GL_FRONT_AND_BACK:
      case GL_LEFT:
	if (!gc->modes.doubleBufferMode) {
	    gc->state.raster.drawBuffer = GL_FRONT;
	} else {
	    gc->state.raster.drawBuffer = GL_FRONT_AND_BACK;
	}
	break;
      case GL_BACK:
      case GL_BACK_LEFT:
	if (!gc->modes.doubleBufferMode) {
	    goto not_supported_in_this_implementation;
	}
	gc->state.raster.drawBuffer = GL_BACK;
	break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
	i = mode - GL_AUX0;
	if (i >= gc->modes.maxAuxBuffers) {
	    goto not_supported_in_this_implementation;
	}
	gc->state.raster.drawBuffer = mode;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->state.raster.drawBufferReturn != mode) {
        gc->state.raster.drawBufferReturn = mode;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_Fogfv(GLenum p, const GLfloat pv[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (p) {
      case GL_FOG_COLOR:
	__glClampAndScaleColorf(gc, &gc->state.fog.color, pv);
#ifdef NT
	if (gc->state.fog.color.r == gc->state.fog.color.g
	 && gc->state.fog.color.r == gc->state.fog.color.b)
	    gc->state.fog.flags |= __GL_FOG_GRAY_RGB;
	else
	    gc->state.fog.flags &= ~__GL_FOG_GRAY_RGB;
#endif
	break;
      case GL_FOG_DENSITY:
	if (pv[0] < __glZero) {
	    __glSetError(GL_INVALID_VALUE);
	    return;
	}
	gc->state.fog.density = pv[0];
#ifdef NT
	gc->state.fog.density2neg = -(pv[0] * pv[0]);
#endif
	break;
      case GL_FOG_END:
	gc->state.fog.end = pv[0];
	break;
      case GL_FOG_START:
	gc->state.fog.start = pv[0];
	break;
      case GL_FOG_INDEX:
        gc->state.fog.index = __GL_MASK_INDEXF(gc, pv[0]);
	break;
      case GL_FOG_MODE:
	switch ((GLenum) pv[0]) {
	  case GL_EXP:
	  case GL_EXP2:
	  case GL_LINEAR:
	    gc->state.fog.mode = (GLenum) pv[0];
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    /*
    ** Recompute cached 1/(end - start) value for linear fogging.
    */
    if (gc->state.fog.mode == GL_LINEAR) {
	if (gc->state.fog.start != gc->state.fog.end) {
	    gc->state.fog.oneOverEMinusS =  
		__glOne / (gc->state.fog.end - gc->state.fog.start);
	} else {
	    /*
	    ** Use zero as the undefined value.
	    */
	    gc->state.fog.oneOverEMinusS = __glZero;
	}
    }

    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FOG);
#endif
}

void APIPRIVATE __glim_FrontFace(GLenum dir)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (dir) {
      case GL_CW:
      case GL_CCW:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->state.polygon.frontFaceDirection != dir) {
        gc->state.polygon.frontFaceDirection = dir;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
    }
}

void APIPRIVATE __glim_Hint(GLenum target, GLenum mode)
{
    __GLhintState *hs;
    __GL_SETUP_NOT_IN_BEGIN();

    hs = &gc->state.hints;
    switch (mode) {
      case GL_DONT_CARE:
      case GL_FASTEST:
      case GL_NICEST:
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    switch (target) {
      case GL_PERSPECTIVE_CORRECTION_HINT:
        if (hs->perspectiveCorrection == mode) return;
        hs->perspectiveCorrection = mode;
        break;
      case GL_POINT_SMOOTH_HINT:
        if (hs->pointSmooth == mode) return;
        hs->pointSmooth = mode;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, HINTS);
#endif
        return;
      case GL_LINE_SMOOTH_HINT:
        if (hs->lineSmooth == mode) return;
        hs->lineSmooth = mode;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, HINTS);
#endif
        return;
      case GL_POLYGON_SMOOTH_HINT:
        if (hs->polygonSmooth == mode) return;
        hs->polygonSmooth = mode;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, HINTS);
#endif
        return;
      case GL_FOG_HINT:
        if (hs->fog == mode) return;
        hs->fog = mode;
        break;
#ifdef GL_WIN_phong_shading
      case GL_PHONG_HINT_WIN:
        if (hs->phong == mode) return;
        hs->phong = mode;
        break;
#endif //GL_WIN_phong_shading
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, HINTS);
#endif
}

void APIPRIVATE __glim_IndexMask(GLuint i)
{
    __GL_SETUP_NOT_IN_BEGIN();

    i = __GL_MASK_INDEXI(gc, i);
	if (gc->state.raster.writeMask != (GLint) i) {
	  gc->state.raster.writeMask = (GLint) i;
	  __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
	}
	
}

void FASTCALL __glTransformLightDirection(__GLcontext *gc, __GLlightSourceState *lss)
{
    __GLcoord dir;
    __GLfloat q;
    GLint target = (GLint)((ULONG_PTR)(lss - &gc->state.light.source[0]));
    __GLtransform *tr;

    dir.x = lss->direction.x;
    dir.y = lss->direction.y;
    dir.z = lss->direction.z;
#ifdef NT
    ASSERTOPENGL(lss->direction.w == __glOne, "Direction with invalid w\n");
    q = -(dir.x * lss->position.x + dir.y * lss->position.y +
	  dir.z * lss->position.z);
#else
    if (lss->position.w != __glZero) {
	q = -(dir.x * lss->position.x + dir.y * lss->position.y +
	      dir.z * lss->position.z) / lss->position.w;
    } else {
	q = __glZero;
    }
#endif // NT
    dir.w = q;

    tr = gc->transform.modelView;
    if (tr->flags & XFORM_UPDATE_INVERSE) {
	__glComputeInverseTranspose(gc, tr);
    }
    (*tr->inverseTranspose.xf4)(&lss->directionEye, &dir.x,
                                &tr->inverseTranspose);
    __glNormalize(&lss->directionEyeNorm.x, &lss->directionEye.x);
    gc->light.source[target].direction = lss->directionEyeNorm;
}

void APIPRIVATE __glim_Lightfv(GLenum light, GLenum p, const GLfloat pv[])
{
    __GLlightSourceState *lss;
    __GLmatrix *m;
    __GL_SETUP_NOT_IN_BEGIN();

    light -= GL_LIGHT0;
#ifdef NT
    // light is unsigned!
    if (light >= (GLenum) gc->constants.numberOfLights) {
#else
    if ((light < 0) || (light >= gc->constants.numberOfLights)) {
#endif // NT
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    lss = &gc->state.light.source[light];
    switch (p) {
      case GL_AMBIENT:
	__glScaleColorf(gc, &lss->ambient, pv);
	break;
      case GL_DIFFUSE:
	__glScaleColorf(gc, &lss->diffuse, pv);
	break;
      case GL_SPECULAR:
	__glScaleColorf(gc, &lss->specular, pv);
	break;
      case GL_POSITION:
	lss->position.x = pv[0];
	lss->position.y = pv[1];
	lss->position.z = pv[2];
	lss->position.w = pv[3];

	/*
	** Transform light position into eye space
	*/
	m = &gc->transform.modelView->matrix;
	(*m->xf4)(&lss->positionEye, &lss->position.x, m);
	//
	// Grab a copy of the matrix so we can do this again later for
        // infinite lighting (avoiding normal transformations):
	//        
        lss->lightMatrix = gc->transform.modelView->matrix;
	break;
      case GL_SPOT_DIRECTION:
	lss->direction.x = pv[0];
	lss->direction.y = pv[1];
	lss->direction.z = pv[2];
	lss->direction.w = __glOne;
	__glTransformLightDirection(gc, lss);
	break;
      case GL_SPOT_EXPONENT:
	if ((pv[0] < (__GLfloat) 0) || (pv[0] > (__GLfloat) 128)) {
	  bad_value:
	    __glSetError(GL_INVALID_VALUE);
	    return;
	}
	lss->spotLightExponent = pv[0];
	break;
      case GL_SPOT_CUTOFF:
	if ((pv[0] != (__GLfloat) 180) && ((pv[0] < (__GLfloat) 0) || (pv[0] > (__GLfloat) 90))) {
	    goto bad_value;
	}
	lss->spotLightCutOffAngle = pv[0];
	break;
      case GL_CONSTANT_ATTENUATION:
	if (pv[0] < __glZero) {
	    goto bad_value;
	}
	lss->constantAttenuation = pv[0];
	break;
      case GL_LINEAR_ATTENUATION:
	if (pv[0] < __glZero) {
	    goto bad_value;
	}
	lss->linearAttenuation = pv[0];
	break;
      case GL_QUADRATIC_ATTENUATION:
	if (pv[0] < __glZero) {
	    goto bad_value;
	}
	lss->quadraticAttenuation = pv[0];
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
    gc->state.light.dirtyLights |= 1 << light;
    MCD_STATE_DIRTY(gc, LIGHTS);
}

void APIPRIVATE __glim_LightModelfv(GLenum p, const GLfloat pv[])
{
    __GLlightModelState *model;
    __GL_SETUP_NOT_IN_BEGIN();

    model = &gc->state.light.model;
    switch (p) {
      case GL_LIGHT_MODEL_AMBIENT:
	__glScaleColorf(gc, &model->ambient, pv);
	break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	model->localViewer = pv[0] != __glZero;
	break;
      case GL_LIGHT_MODEL_TWO_SIDE:
	model->twoSided = pv[0] != __glZero;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
    MCD_STATE_DIRTY(gc, LIGHTMODEL);
}

void APIPRIVATE __glim_LineStipple(GLint factor, GLushort stipple)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (factor < 1) {
	factor = 1;
    }
    if (factor > 255) {
	factor = 255;
    }
	if ((gc->state.line.stippleRepeat != (GLshort) factor) || 
		(gc->state.line.stipple != stipple)) {
	  gc->state.line.stippleRepeat = (GLshort) factor;
	  gc->state.line.stipple = stipple;
	  __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, LINEDRAW);
#endif
	}
}

static GLint RoundWidth(__GLfloat size)
{
    if (size < (__GLfloat) 1.0)
	return 1;
    return size + (__GLfloat) 0.5;
}

static __GLfloat ClampWidth(__GLcontext *gc, __GLfloat size)
{
    __GLfloat minSize = gc->constants.lineWidthMinimum;
    __GLfloat maxSize = gc->constants.lineWidthMaximum;
    __GLfloat gran = gc->constants.lineWidthGranularity;
    GLint i;

    if (size <= minSize) return minSize;
    if (size >= maxSize) return maxSize;
	
    /* choose closest fence post */
    i = (GLint)(((size - minSize) / gran) + __glHalf);
    return minSize + i * gran;
}

void APIPRIVATE __glim_LineWidth(GLfloat width)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (width <= 0) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

    if (gc->state.line.requestedWidth == width) return;
    gc->state.line.requestedWidth = width;
    gc->state.line.aliasedWidth = RoundWidth(width);
    gc->state.line.smoothWidth = ClampWidth(gc, width);
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, LINEDRAW);
#endif
}

void APIPRIVATE __glim_LogicOp(GLenum op)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((op < GL_CLEAR) || (op > GL_SET)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
	if (gc->state.raster.logicOp != op) {
	  gc->state.raster.logicOp = op;
	  __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, LOGICOP);
#endif
	}
}

static GLint ApplyParameterF(__GLcontext *gc, __GLmaterialState *ms,
			     GLenum p, const GLfloat pv[])
{
    switch (p) {
      case GL_COLOR_INDEXES:
	ms->cmapa = pv[0];
	ms->cmapd = pv[1];
	ms->cmaps = pv[2];
	return __GL_MATERIAL_COLORINDEXES;
      case GL_EMISSION:
	__glScaleColorf(gc, &ms->emissive, pv);
	return __GL_MATERIAL_EMISSIVE;
      case GL_SPECULAR:
	ms->specular.r = pv[0];
	ms->specular.g = pv[1];
	ms->specular.b = pv[2];
	ms->specular.a = pv[3];
	return __GL_MATERIAL_SPECULAR;
      case GL_SHININESS:
	ms->specularExponent = pv[0];
	return __GL_MATERIAL_SHININESS;
      case GL_AMBIENT:
	ms->ambient.r = pv[0];
	ms->ambient.g = pv[1];
	ms->ambient.b = pv[2];
	ms->ambient.a = pv[3];
	return __GL_MATERIAL_AMBIENT;
      case GL_DIFFUSE:
	ms->diffuse.r = pv[0];
	ms->diffuse.g = pv[1];
	ms->diffuse.b = pv[2];
	ms->diffuse.a = pv[3];
	return __GL_MATERIAL_DIFFUSE;
      case GL_AMBIENT_AND_DIFFUSE:
	ms->ambient.r = pv[0];
	ms->ambient.g = pv[1];
	ms->ambient.b = pv[2];
	ms->ambient.a = pv[3];
	ms->diffuse = ms->ambient;
	return __GL_MATERIAL_DIFFUSE | __GL_MATERIAL_AMBIENT;
    }
    return 0;
}

#ifdef SGI
GLenum __glErrorCheckMaterial(GLenum face, GLenum p, GLfloat pv0)
{
    switch (face) {
      case GL_FRONT:
      case GL_BACK:
      case GL_FRONT_AND_BACK:
	break;
      default:
	return GL_INVALID_ENUM;
    }
    switch (p) {
      case GL_COLOR_INDEXES:
      case GL_EMISSION:
      case GL_SPECULAR:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_AMBIENT_AND_DIFFUSE:
	break;
      case GL_SHININESS:
	if (pv0 < (GLfloat) 0 || pv0 > (GLfloat) 128) {
	    return GL_INVALID_VALUE;
	}
	break;
      default:
	return GL_INVALID_ENUM;
    }
    return GL_NO_ERROR;
}
#endif

//!!! can we 'batch' these calls up until begin is called?
void APIPRIVATE __glim_Materialfv(GLenum face, GLenum p, const GLfloat pv[])
{
    GLenum error;
    GLint frontChange, backChange;
    __GL_SETUP();

    switch (face) {
      case GL_FRONT:
	frontChange = ApplyParameterF(gc, &gc->state.light.front, p, pv);
	backChange = 0;
	break;
      case GL_BACK:
	backChange = ApplyParameterF(gc, &gc->state.light.back, p, pv);
	frontChange = 0;
	break;
      case GL_FRONT_AND_BACK:
	backChange = ApplyParameterF(gc, &gc->state.light.back, p, pv);
	frontChange = ApplyParameterF(gc, &gc->state.light.front, p, pv);
	break;
    }

    if (p != GL_COLOR_INDEXES) {
	__glValidateMaterial(gc, frontChange, backChange);
    }

    if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) {
	(*gc->procs.applyColor)(gc);
    }

    MCD_STATE_DIRTY(gc, MATERIAL);
}

static GLint RoundSize(__GLfloat size)
{
    if (size < (__GLfloat) 1.0)
	return 1;
    return size + (__GLfloat) 0.5;
}

static __GLfloat ClampSize(__GLcontext *gc, __GLfloat size)
{
    __GLfloat minSize = gc->constants.pointSizeMinimum;
    __GLfloat maxSize = gc->constants.pointSizeMaximum;
    __GLfloat gran = gc->constants.pointSizeGranularity;
    GLint i;

    if (size <= minSize) return minSize;
    if (size >= maxSize) return maxSize;
	
    /* choose closest fence post */
    i = (GLint)(((size - minSize) / gran) + __glHalf);
    return minSize + i * gran;
}

void APIPRIVATE __glim_PointSize(GLfloat f)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (f <= __glZero) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
	
	if (gc->state.point.requestedSize != f) {
	  gc->state.point.requestedSize = f;
	  gc->state.point.aliasedSize = RoundSize(f);
	  gc->state.point.smoothSize = ClampSize(gc, f);
	  __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, POINTDRAW);
#endif
	}
}

void APIPRIVATE __glim_PolygonMode(GLenum face, GLenum mode)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_FILL:
        break;
      case GL_POINT:
	__GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
	break;
      case GL_LINE:
	__GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (face) {
      case GL_FRONT:
	gc->state.polygon.frontMode = mode;
	break;
      case GL_BACK:
	gc->state.polygon.backMode = mode;
	break;
      case GL_FRONT_AND_BACK:
	gc->state.polygon.frontMode = mode;
	gc->state.polygon.backMode = mode;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
}

#ifdef NT
void APIPRIVATE __glim_PolygonStipple(const GLubyte *mask, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_PolygonStipple(const GLubyte *mask)
#endif
{
    GLubyte *stipple;
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef NT
    if (_IsDlist)
    {
	const GLubyte *bits = mask;
	/* 
	** Just copy bits into stipple, convertPolygonStipple() will do the rest
	*/
	__GL_MEMCOPY(&gc->state.polygonStipple.stipple[0], bits,
		     sizeof(gc->state.polygonStipple.stipple));
    }
    else
    {
#endif
	stipple = &gc->state.polygonStipple.stipple[0];
	__glFillImage(gc, 32, 32, GL_COLOR_INDEX, GL_BITMAP, mask, stipple);
#ifdef NT
    }
#endif
    (*gc->procs.convertPolygonStipple)(gc);
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
}

void APIPRIVATE __glim_ShadeModel(GLenum sm)
{
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef GL_WIN_phong_shading
    if (!((sm == GL_FLAT) || (sm == GL_SMOOTH) || (sm == GL_PHONG_WIN))) 
#else
    if ((sm < GL_FLAT) || (sm > GL_SMOOTH)) 
#endif
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    if (gc->state.light.shadingModel != sm) 
    {
        gc->state.light.shadingModel = sm;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
      MCD_STATE_DIRTY(gc, SHADEMODEL);
#endif
    }
}

void APIPRIVATE __glim_StencilMask(GLuint sm)
{
    __GL_SETUP_NOT_IN_BEGIN();

	if (gc->state.stencil.writeMask != 
		(GLshort)(sm & __GL_MAX_STENCIL_VALUE)) {
	  gc->state.stencil.writeMask = (GLshort) (sm & __GL_MAX_STENCIL_VALUE);
	  __GL_DELAY_VALIDATE(gc);
	  gc->validateMask |= __GL_VALIDATE_STENCIL_FUNC;
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
	}
}

void APIPRIVATE __glim_StencilFunc(GLenum func, GLint ref, GLuint mask)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((func < GL_NEVER) || (func > GL_ALWAYS)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (ref < 0) ref = 0;
    if (ref > __GL_MAX_STENCIL_VALUE) ref = __GL_MAX_STENCIL_VALUE;
	
	if ((gc->state.stencil.testFunc != func) ||
		(gc->state.stencil.reference != (GLshort) ref) ||
		(gc->state.stencil.mask = (GLshort)(mask & __GL_MAX_STENCIL_VALUE))) {
	  gc->state.stencil.testFunc = func;
	  gc->state.stencil.reference = (GLshort) ref;
	  gc->state.stencil.mask = (GLshort) (mask & __GL_MAX_STENCIL_VALUE);
	  __GL_DELAY_VALIDATE(gc);
	  gc->validateMask |= __GL_VALIDATE_STENCIL_FUNC;
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, STENCILTEST);
#endif
	}
}

void APIPRIVATE __glim_StencilOp(GLenum fail, GLenum depthFail, GLenum depthPass)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (fail) {
      case GL_KEEP: case GL_ZERO: case GL_REPLACE:
      case GL_INCR: case GL_DECR: case GL_INVERT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (depthFail) {
      case GL_KEEP: case GL_ZERO: case GL_REPLACE:
      case GL_INCR: case GL_DECR: case GL_INVERT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (depthPass) {
      case GL_KEEP: case GL_ZERO: case GL_REPLACE:
      case GL_INCR: case GL_DECR: case GL_INVERT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

	if ((gc->state.stencil.fail != fail) || 
		(gc->state.stencil.depthFail != depthFail) ||
		(gc->state.stencil.depthPass != depthPass) ) {
	  gc->state.stencil.fail = fail;
	  gc->state.stencil.depthFail = depthFail;
	  gc->state.stencil.depthPass = depthPass;
	  __GL_DELAY_VALIDATE(gc);
	  gc->validateMask |= __GL_VALIDATE_STENCIL_OP;
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, STENCILTEST);
#endif
	}
}

/************************************************************************/

/*
** Copy context information from src to dst.  Mark dst for validation
** when done.
*/
GLboolean FASTCALL __glCopyContext(__GLcontext *dst, const __GLcontext *src, GLuint mask)
{
    const __GLattribute *sp;
    GLboolean rv = GL_TRUE;

    sp = &src->state;

    if (dst == GLTEB_SRVCONTEXT()) {
	return GL_FALSE;
    }

    /*
    ** In order for a context copy to be successful, the source
    ** and destination color scales must match. We make the
    ** destination context match the source context, since it isn't
    ** currently the current one, and will be automatically rescaled
    ** when it next made current.
    ** 
    */

    /* set the new destination context scale factors */

    dst->frontBuffer.redScale   = src->frontBuffer.redScale;
    dst->frontBuffer.greenScale = src->frontBuffer.greenScale;
    dst->frontBuffer.blueScale  = src->frontBuffer.blueScale;
    dst->frontBuffer.alphaScale = src->frontBuffer.alphaScale;

    dst->redVertexScale         = src->redVertexScale;
    dst->greenVertexScale       = src->greenVertexScale;
    dst->blueVertexScale        = src->blueVertexScale;
    dst->alphaVertexScale       = src->alphaVertexScale;

    /* rescale the destination context with the new scale factors */

    __glContextSetColorScales(dst);

    if (mask & GL_ACCUM_BUFFER_BIT) {
	dst->state.accum = sp->accum;
    }

    if (mask & GL_COLOR_BUFFER_BIT) {
	dst->state.raster = sp->raster;
#ifdef NT
        // A copy can occur from a double-buffered context to a single
        // buffered context, leaving the drawBuffer in an invalid state
        // Fix it up if necessary
        if (dst->state.raster.drawBuffer == GL_BACK &&
            !dst->modes.doubleBufferMode)
        {
            dst->state.raster.drawBuffer = GL_FRONT;
        }
#endif
	dst->state.enables.general &= ~__GL_COLOR_BUFFER_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_COLOR_BUFFER_ENABLES;
	dst->validateMask |= __GL_VALIDATE_ALPHA_FUNC; /*XXX*/
    }

    if (mask & GL_CURRENT_BIT) {
	dst->state.current = sp->current;
    }

    if (mask & GL_DEPTH_BUFFER_BIT) {
	dst->state.depth = sp->depth;
	dst->state.enables.general &= ~__GL_DEPTH_TEST_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_DEPTH_TEST_ENABLE;
        __GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_DEPTH);
    }

    if (mask & GL_ENABLE_BIT) {
	dst->state.enables = sp->enables;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_LINE | __GL_DIRTY_POLYGON | 
		__GL_DIRTY_POINT | __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH);
#ifdef NT
	ComputeColorMaterialChange(dst);
#endif
	(*dst->procs.pickColorMaterialProcs)(dst);
	(*dst->procs.applyColor)(dst);
    }

    if (mask & GL_EVAL_BIT) {
	dst->state.evaluator = sp->evaluator;
	dst->state.enables.general &= ~__GL_AUTO_NORMAL_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_AUTO_NORMAL_ENABLE;
	dst->state.enables.eval1 = sp->enables.eval1;
	dst->state.enables.eval2 = sp->enables.eval2;
    }

    if (mask & GL_FOG_BIT) {
	dst->state.fog = sp->fog;
	dst->state.enables.general &= ~__GL_FOG_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_FOG_ENABLE;
#ifdef GL_WIN_specular_fog
        dst->state.enables.general &= ~__GL_FOG_SPEC_TEX_ENABLE;
        dst->state.enables.general |=
          sp->enables.general & __GL_FOG_SPEC_TEX_ENABLE;
#endif //GL_WIN_specular_fog
    }

    if (mask & GL_HINT_BIT) {
	dst->state.hints = sp->hints;
    }

    if (mask & GL_LIGHTING_BIT) {
	dst->state.light.colorMaterialFace = sp->light.colorMaterialFace;
	dst->state.light.colorMaterialParam = sp->light.colorMaterialParam;
	dst->state.light.shadingModel = sp->light.shadingModel;
	dst->state.light.model = sp->light.model;
	dst->state.light.front = sp->light.front;
	dst->state.light.back = sp->light.back;
        dst->state.light.dirtyLights = (1 << dst->constants.numberOfLights)-1;
	__GL_MEMCOPY(dst->state.light.source, sp->light.source,
		     dst->constants.numberOfLights
		     * sizeof(__GLlightSourceState));
	dst->state.enables.general &= ~__GL_LIGHTING_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_LIGHTING_ENABLES;
	dst->state.enables.lights = sp->enables.lights;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_LIGHTING);
    }

    if (mask & GL_LINE_BIT) {
	dst->state.line = sp->line;
	dst->state.enables.general &= ~__GL_LINE_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_LINE_ENABLES;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_LINE);
    }

    if (mask & GL_LIST_BIT) {
	dst->state.list = sp->list;
    }

    if (mask & GL_PIXEL_MODE_BIT) {
	dst->state.pixel.readBuffer = sp->pixel.readBuffer;
	dst->state.pixel.readBufferReturn = sp->pixel.readBufferReturn;
	dst->state.pixel.transferMode = sp->pixel.transferMode;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_PIXEL);
    }

    if (mask & GL_POINT_BIT) {
	dst->state.point = sp->point;
	dst->state.enables.general &= ~__GL_POINT_SMOOTH_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_POINT_SMOOTH_ENABLE;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_POINT);
    }

    if (mask & GL_POLYGON_BIT) {
	dst->state.polygon = sp->polygon;
	dst->state.enables.general &= ~__GL_POLYGON_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_POLYGON_ENABLES;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_POLYGON);
    }

    if (mask & GL_POLYGON_STIPPLE_BIT) {
	dst->state.polygonStipple = sp->polygonStipple;
	dst->state.enables.general &= ~__GL_POLYGON_STIPPLE_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_POLYGON_STIPPLE_ENABLE;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_POLYGON |
		__GL_DIRTY_POLYGON_STIPPLE);
    }

    if (mask & GL_SCISSOR_BIT) {
	dst->state.scissor = sp->scissor;
	dst->state.enables.general &= ~__GL_SCISSOR_TEST_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_SCISSOR_TEST_ENABLE;
    }

    if (mask & GL_STENCIL_BUFFER_BIT) {
	dst->state.stencil = sp->stencil;
	dst->state.enables.general &= ~__GL_STENCIL_TEST_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_STENCIL_TEST_ENABLE;
	dst->validateMask |= __GL_VALIDATE_STENCIL_FUNC |
	    __GL_VALIDATE_STENCIL_OP; /*XXX*/
    }

    if (mask & GL_TEXTURE_BIT) {
	dst->state.texture.s = sp->texture.s;
	dst->state.texture.t = sp->texture.t;
	dst->state.texture.r = sp->texture.r;
	dst->state.texture.q = sp->texture.q;
	__GL_MEMCOPY(dst->state.texture.texture, sp->texture.texture,
		     dst->constants.numberOfTextures
		     * sizeof(__GLperTextureState));
	__GL_MEMCOPY(dst->state.texture.env, sp->texture.env,
		     dst->constants.numberOfTextureEnvs
		     * sizeof(__GLtextureEnvState));
	dst->state.enables.general &= ~__GL_TEXTURE_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_TEXTURE_ENABLES;
    }

    if (mask & GL_TRANSFORM_BIT) {
	dst->state.transform.matrixMode = sp->transform.matrixMode;
#ifdef NT
        if (sp->transform.eyeClipPlanes != NULL)
        {
            if (dst->state.transform.eyeClipPlanes != NULL)
            {
                __GL_MEMCOPY(dst->state.transform.eyeClipPlanes,
                             sp->transform.eyeClipPlanes,
                             dst->constants.numberOfClipPlanes *
                             sizeof(__GLcoord));
            }
        }
        else
        {
            dst->state.transform.eyeClipPlanes = NULL;
        }
#else
        __GL_MEMCOPY(dst->state.transform.eyeClipPlanes,
                     sp->transform.eyeClipPlanes,
                     dst->constants.numberOfClipPlanes *
                     sizeof(__GLcoord));
#endif
	dst->state.enables.general &= ~__GL_NORMALIZE_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_NORMALIZE_ENABLE;
    }

    if (mask & GL_VIEWPORT_BIT) {
	dst->state.viewport = sp->viewport;
        __glUpdateViewportDependents(dst);
    }

    __glContextUnsetColorScales(dst);

    __GL_DELAY_VALIDATE(dst);
#ifdef _MCD_
    MCD_STATE_DIRTY(dst, ALL);
#endif

    return rv;
}

/************************************************************************/

void APIPRIVATE __glim_PushAttrib(GLuint mask)
{
    __GLattribute **spp;
    __GLattribute *sp;
    __GL_SETUP_NOT_IN_BEGIN();

    spp = gc->attributes.stackPointer;
    if (spp < &gc->attributes.stack[gc->constants.maxAttribStackDepth]) {
	if (!(sp = *spp)) {
	    sp = (__GLattribute*)
		GCALLOCZ(gc, sizeof(__GLattribute));
	    if (NULL == sp)
            {
	        return;
            }
            
	    *spp = sp;
	}
	sp->mask = mask;
	sp->enables = gc->state.enables;	/* Always save enables */
	gc->attributes.stackPointer = spp + 1;

	if (mask & GL_ACCUM_BUFFER_BIT) {
	    sp->accum = gc->state.accum;
	}
	if (mask & GL_COLOR_BUFFER_BIT) {
	    sp->raster = gc->state.raster;
	}
	if (mask & GL_CURRENT_BIT) {
	    sp->current = gc->state.current;
	}
	if (mask & GL_DEPTH_BUFFER_BIT) {
	    sp->depth = gc->state.depth;
	}
	if (mask & GL_EVAL_BIT) {
	    sp->evaluator = gc->state.evaluator;
	}
	if (mask & GL_FOG_BIT) {
	    sp->fog = gc->state.fog;
	}
	if (mask & GL_HINT_BIT) {
	    sp->hints = gc->state.hints;
	}
	if (mask & GL_LIGHTING_BIT) {
	    size_t bytes = (size_t)
		(gc->constants.numberOfLights * sizeof(__GLlightSourceState));
	    sp->light.colorMaterialFace = gc->state.light.colorMaterialFace;
	    sp->light.colorMaterialParam = gc->state.light.colorMaterialParam;
	    sp->light.shadingModel = gc->state.light.shadingModel;
	    sp->light.model = gc->state.light.model;
	    sp->light.front = gc->state.light.front;
	    sp->light.back = gc->state.light.back;
	    sp->light.source = (__GLlightSourceState*)
		GCALLOC(gc, bytes);
#ifdef NT
	    if (NULL ==  sp->light.source)
	        sp->mask &= ~GL_LIGHTING_BIT;
	    else
	        __GL_MEMCOPY(sp->light.source, gc->state.light.source, bytes);
#else
	    __GL_MEMCOPY(sp->light.source, gc->state.light.source, bytes);
#endif
	}
	if (mask & GL_LINE_BIT) {
	    sp->line = gc->state.line;
	}
	if (mask & GL_LIST_BIT) {
	    sp->list = gc->state.list;
	}
	if (mask & GL_PIXEL_MODE_BIT) {
	    sp->pixel.readBuffer = gc->state.pixel.readBuffer;
	    sp->pixel.readBufferReturn = gc->state.pixel.readBufferReturn;
	    sp->pixel.transferMode = gc->state.pixel.transferMode;
	}
	if (mask & GL_POINT_BIT) {
	    sp->point = gc->state.point;
	}
	if (mask & GL_POLYGON_BIT) {
	    sp->polygon = gc->state.polygon;
	}
	if (mask & GL_POLYGON_STIPPLE_BIT) {
	    sp->polygonStipple = gc->state.polygonStipple;
	}
	if (mask & GL_SCISSOR_BIT) {
	    sp->scissor = gc->state.scissor;
	}
	if (mask & GL_STENCIL_BUFFER_BIT) {
	    sp->stencil = gc->state.stencil;
	}
	if (mask & GL_TEXTURE_BIT) {
	    size_t texbytes = (size_t) (gc->constants.numberOfTextures
					* sizeof(__GLperTextureState));
	    size_t envbytes = (size_t) (gc->constants.numberOfTextureEnvs
					* sizeof(__GLtextureEnvState));
	    sp->texture.s = gc->state.texture.s;
	    sp->texture.t = gc->state.texture.t;
	    sp->texture.r = gc->state.texture.r;
	    sp->texture.q = gc->state.texture.q;
#ifdef NT
	    sp->texture.texture = (__GLperTextureState*)
		GCALLOC(gc, texbytes);
	    sp->texture.env = (__GLtextureEnvState*)
		GCALLOC(gc, envbytes);
	    if ((NULL == sp->texture.texture) || (NULL == sp->texture.env)) {
	        if (sp->texture.texture)
	            GCFREE(gc, sp->texture.texture);
	        sp->texture.texture = NULL;
	        if (sp->texture.env)
	            GCFREE(gc, sp->texture.env);
	        sp->texture.env = NULL;
	        sp->mask &= ~GL_TEXTURE_BIT;
	    } else {
	        __GL_MEMCOPY(sp->texture.texture, gc->state.texture.texture,
			 texbytes);
	        __GL_MEMCOPY(sp->texture.env, gc->state.texture.env, envbytes);
	    }
#else
	    sp->texture.texture = (__GLperTextureState*)
		GCALLOC(gc, texbytes);
	    __GL_MEMCOPY(sp->texture.texture, gc->state.texture.texture,
			 texbytes);
	    sp->texture.env = (__GLtextureEnvState*)
		GCALLOC(gc, envbytes);
	    __GL_MEMCOPY(sp->texture.env, gc->state.texture.env, envbytes);
#endif
	}
	if (mask & GL_TRANSFORM_BIT) {
	    size_t bytes = (size_t)
		(gc->constants.numberOfClipPlanes * sizeof(__GLcoord));
	    sp->transform.matrixMode = gc->state.transform.matrixMode;
	    sp->transform.eyeClipPlanes = (__GLcoord*)
		GCALLOC(gc, bytes);
#ifdef NT
	    if (NULL == sp->transform.eyeClipPlanes)
	        sp->mask &= ~GL_TRANSFORM_BIT;
	    else
	        __GL_MEMCOPY(sp->transform.eyeClipPlanes,
			 gc->state.transform.eyeClipPlanes, bytes);
#else
	    __GL_MEMCOPY(sp->transform.eyeClipPlanes,
			 gc->state.transform.eyeClipPlanes, bytes);
#endif
	}
	if (mask & GL_VIEWPORT_BIT) {
	    sp->viewport = gc->state.viewport;
	}
    } else {
	__glSetError(GL_STACK_OVERFLOW);
	return;
    }
}

/************************************************************************/

GLuint FASTCALL __glInternalPopAttrib(__GLcontext *gc, GLboolean destroy)
{
    __GLattribute **spp;
    __GLattribute *sp;
    GLuint mask;
    GLuint dirtyMask = 0;

    spp = gc->attributes.stackPointer;
    if (spp > &gc->attributes.stack[0]) {
	--spp;
	sp = *spp;
	ASSERTOPENGL(sp != NULL, "No attribute data to pop\n");
	mask = sp->mask;
	gc->attributes.stackPointer = spp;
	if (mask & GL_ACCUM_BUFFER_BIT) {
	    gc->state.accum = sp->accum;
	}
	if (mask & GL_COLOR_BUFFER_BIT) {
	    gc->state.raster = sp->raster;
	    gc->state.enables.general &= ~__GL_COLOR_BUFFER_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_COLOR_BUFFER_ENABLES;
	    gc->validateMask |= __GL_VALIDATE_ALPHA_FUNC; /*XXX*/
	}
	if (mask & GL_CURRENT_BIT) {
	    gc->state.current = sp->current;
	}
	if (mask & GL_DEPTH_BUFFER_BIT) {
	    gc->state.depth = sp->depth;
	    gc->state.enables.general &= ~__GL_DEPTH_TEST_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_DEPTH_TEST_ENABLE;
            dirtyMask |= __GL_DIRTY_DEPTH;
	}
	if (mask & GL_ENABLE_BIT) {
	    gc->state.enables = sp->enables;
            dirtyMask |= (__GL_DIRTY_LINE | __GL_DIRTY_POLYGON |
		    __GL_DIRTY_POINT | __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH);
#ifdef NT
	    ComputeColorMaterialChange(gc);
#endif
	    (*gc->procs.pickColorMaterialProcs)(gc);
	    (*gc->procs.applyColor)(gc);
#ifdef NT
            if (!destroy)
            {
                // applyViewport does both
                (*gc->procs.applyViewport)(gc);
            }
#else
	    (*gc->procs.computeClipBox)(gc);
	    (*gc->procs.applyScissor)(gc);
#endif
	}
	if (mask & GL_EVAL_BIT) {
	    gc->state.evaluator = sp->evaluator;
	    gc->state.enables.general &= ~__GL_AUTO_NORMAL_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_AUTO_NORMAL_ENABLE;
	    gc->state.enables.eval1 = sp->enables.eval1;
	    gc->state.enables.eval2 = sp->enables.eval2;
	}
	if (mask & GL_FOG_BIT) {
	    gc->state.fog = sp->fog;
	    gc->state.enables.general &= ~__GL_FOG_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_FOG_ENABLE;
#ifdef GL_WIN_specular_fog
	    gc->state.enables.general &= ~__GL_FOG_SPEC_TEX_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_FOG_SPEC_TEX_ENABLE;
#endif //GL_WIN_specular_fog
	}
	if (mask & GL_HINT_BIT) {
	    gc->state.hints = sp->hints;
	}
	if (mask & GL_LIGHTING_BIT) {
	    gc->state.light.colorMaterialFace = sp->light.colorMaterialFace;
	    gc->state.light.colorMaterialParam = sp->light.colorMaterialParam;
	    gc->state.light.shadingModel = sp->light.shadingModel;
	    gc->state.light.model = sp->light.model;
	    gc->state.light.front = sp->light.front;
	    gc->state.light.back = sp->light.back;
            gc->state.light.dirtyLights =
                (1 << gc->constants.numberOfLights)-1;
	    __GL_MEMCOPY(gc->state.light.source, sp->light.source,
			 gc->constants.numberOfLights
			     * sizeof(__GLlightSourceState));
	    GCFREE(gc, sp->light.source);
	    sp->light.source = 0;
	    gc->state.enables.general &= ~__GL_LIGHTING_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_LIGHTING_ENABLES;
	    gc->state.enables.lights = sp->enables.lights;
            dirtyMask |= __GL_DIRTY_LIGHTING;
	}
	if (mask & GL_LINE_BIT) {
	    gc->state.line = sp->line;
	    gc->state.enables.general &= ~__GL_LINE_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_LINE_ENABLES;
            dirtyMask |= __GL_DIRTY_LINE;
	}
	if (mask & GL_LIST_BIT) {
	    gc->state.list = sp->list;
	}
	if (mask & GL_PIXEL_MODE_BIT) {
	    gc->state.pixel.transferMode = sp->pixel.transferMode;
	    gc->state.pixel.readBufferReturn = sp->pixel.readBufferReturn;
	    gc->state.pixel.readBuffer = sp->pixel.readBuffer;
            dirtyMask |= __GL_DIRTY_PIXEL;
	}
	if (mask & GL_POINT_BIT) {
	    gc->state.point = sp->point;
	    gc->state.enables.general &= ~__GL_POINT_SMOOTH_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_POINT_SMOOTH_ENABLE;
            dirtyMask |= __GL_DIRTY_POINT;
	}
	if (mask & GL_POLYGON_BIT) {
	    gc->state.polygon = sp->polygon;
	    gc->state.enables.general &= ~__GL_POLYGON_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_POLYGON_ENABLES;
            dirtyMask |= __GL_DIRTY_POLYGON;
	}
	if (mask & GL_POLYGON_STIPPLE_BIT) {
	    gc->state.polygonStipple = sp->polygonStipple;
	    gc->state.enables.general &= ~__GL_POLYGON_STIPPLE_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_POLYGON_STIPPLE_ENABLE;
	    (*gc->procs.convertPolygonStipple)(gc);
            dirtyMask |= __GL_DIRTY_POLYGON;
	}
	if (mask & GL_SCISSOR_BIT) {
	    gc->state.scissor = sp->scissor;
	    gc->state.enables.general &= ~__GL_SCISSOR_TEST_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_SCISSOR_TEST_ENABLE;
#ifdef NT
            if (!destroy)
            {
                // applyViewport does both
                (*gc->procs.applyViewport)(gc);
            }
#else
	    (*gc->procs.computeClipBox)(gc);
	    (*gc->procs.applyScissor)(gc);
#endif
	}
	if (mask & GL_STENCIL_BUFFER_BIT) {
	    gc->state.stencil = sp->stencil;
	    gc->state.enables.general &= ~__GL_STENCIL_TEST_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_STENCIL_TEST_ENABLE;
	    gc->validateMask |= __GL_VALIDATE_STENCIL_FUNC |
		__GL_VALIDATE_STENCIL_OP;/*XXX*/
	}
	if (mask & GL_TEXTURE_BIT) {
	    GLuint numTextures = gc->constants.numberOfTextures;
	    
	    gc->state.texture.s = sp->texture.s;
	    gc->state.texture.t = sp->texture.t;
	    gc->state.texture.r = sp->texture.r;
	    gc->state.texture.q = sp->texture.q;
	    /*
	    ** If the texture name is different, a new binding is
	    ** called for.  Deferring the binding is dangerous, because
	    ** the state before the pop has to be saved with the
	    ** texture that is being unbound.  If we defer the binding,
	    ** we need to watch out for cases like two pops in a row
	    ** or a pop followed by a bind.
	    */
	    {
		GLuint targetIndex;
		__GLperTextureState *pts, *spPts;

		pts = gc->state.texture.texture;
		spPts = sp->texture.texture;
		for (targetIndex = 0; targetIndex < numTextures; 
			targetIndex++, pts++, spPts++) {
		    if (pts->texobjs.name != spPts->texobjs.name) {
			__glBindTexture(gc, targetIndex, 
						spPts->texobjs.name, GL_TRUE);
		    }
		}
	    }
	    __GL_MEMCOPY(gc->state.texture.texture, sp->texture.texture,
			 numTextures * sizeof(__GLperTextureState));
	    __GL_MEMCOPY(gc->state.texture.env, sp->texture.env,
			 gc->constants.numberOfTextureEnvs
			     * sizeof(__GLtextureEnvState));
	    GCFREE(gc, sp->texture.texture);
	    sp->texture.texture = 0;
	    GCFREE(gc, sp->texture.env);
	    sp->texture.env = 0;
	    gc->state.enables.general &= ~__GL_TEXTURE_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_TEXTURE_ENABLES;
	}
	if (mask & GL_TRANSFORM_BIT) {
	    gc->state.transform.matrixMode = sp->transform.matrixMode;
	    __GL_MEMCOPY(gc->state.transform.eyeClipPlanes,
			 sp->transform.eyeClipPlanes,
			 gc->constants.numberOfClipPlanes * sizeof(__GLcoord));
	    GCFREE(gc, sp->transform.eyeClipPlanes);
	    sp->transform.eyeClipPlanes = 0;
	    gc->state.enables.general &= ~__GL_NORMALIZE_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_NORMALIZE_ENABLE;
	}
	if (mask & GL_VIEWPORT_BIT) {
	    gc->state.viewport = sp->viewport;
            __glUpdateViewportDependents(gc);
	}

	/*
	** Clear out mask so that any memory frees done above won't get
	** re-done when the context is destroyed
	*/
	sp->mask = 0;

	dirtyMask |= __GL_DIRTY_GENERIC;
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ALL);
#endif
    } else {
	__glSetError(GL_STACK_UNDERFLOW);
    }

    return dirtyMask;
}

void APIPRIVATE __glim_PopAttrib(void)
{
    GLuint dirtyMask;
    __GL_SETUP_NOT_IN_BEGIN();

    dirtyMask = __glInternalPopAttrib(gc, GL_FALSE);
    if (dirtyMask)
    {
	__GL_DELAY_VALIDATE_MASK(gc, dirtyMask);
    }
}

/************************************************************************/

void APIPRIVATE __glim_Disable(GLenum cap)
{
    GLuint frontChange, backChange;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (cap) {
      case GL_ALPHA_TEST:
        if (!(gc->state.enables.general & __GL_ALPHA_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_ALPHA_TEST_ENABLE;
        break;
      case GL_BLEND:
        if (!(gc->state.enables.general & __GL_BLEND_ENABLE)) return;
        gc->state.enables.general &= ~__GL_BLEND_ENABLE;
        break;
      case GL_COLOR_MATERIAL:
        if (!(gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE)) return;
        gc->state.enables.general &= ~__GL_COLOR_MATERIAL_ENABLE;
        frontChange = gc->light.front.colorMaterialChange;
        backChange  = gc->light.back.colorMaterialChange;
        ComputeColorMaterialChange(gc);
        (*gc->procs.pickColorMaterialProcs)(gc);
        __glValidateMaterial(gc, frontChange, backChange);
        break;
      case GL_CULL_FACE:
        if (!(gc->state.enables.general & __GL_CULL_FACE_ENABLE)) return;
        gc->state.enables.general &= ~__GL_CULL_FACE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_DEPTH_TEST:
        if (!(gc->state.enables.general & __GL_DEPTH_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_DEPTH_TEST_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
        break;
      case GL_POLYGON_OFFSET_POINT:
        if (!(gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_OFFSET_POINT_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
        break;
      case GL_POLYGON_OFFSET_LINE:
        if (!(gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_OFFSET_LINE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
        break;
      case GL_POLYGON_OFFSET_FILL:
        if (!(gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_OFFSET_FILL_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
        break;
      case GL_DITHER:
        if (!(gc->state.enables.general & __GL_DITHER_ENABLE)) return;
        gc->state.enables.general &= ~__GL_DITHER_ENABLE;
        break;
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
        if (!(gc->state.enables.general & __GL_FOG_SPEC_TEX_ENABLE))
            return;
        gc->state.enables.general &= ~__GL_FOG_SPEC_TEX_ENABLE;
        break;
#endif //GL_WIN_specular_fog
      case GL_FOG:
        if (!(gc->state.enables.general & __GL_FOG_ENABLE)) return;
        gc->state.enables.general &= ~__GL_FOG_ENABLE;
        break;
      case GL_LIGHTING:
        if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE)) return;
        gc->state.enables.general &= ~__GL_LIGHTING_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
#ifdef NT
        ComputeColorMaterialChange(gc);
#endif
        (*gc->procs.pickColorMaterialProcs)(gc);
        (*gc->procs.applyColor)(gc);
        return;
      case GL_LINE_SMOOTH:
        if (!(gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)) return;
        gc->state.enables.general &= ~__GL_LINE_SMOOTH_ENABLE;
        break;
      case GL_LINE_STIPPLE:
        if (!(gc->state.enables.general & __GL_LINE_STIPPLE_ENABLE)) return;
        gc->state.enables.general &= ~__GL_LINE_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_INDEX_LOGIC_OP:
        if (!(gc->state.enables.general & __GL_INDEX_LOGIC_OP_ENABLE)) return;
        gc->state.enables.general &= ~__GL_INDEX_LOGIC_OP_ENABLE;
        break;
      case GL_COLOR_LOGIC_OP:
        if (!(gc->state.enables.general & __GL_COLOR_LOGIC_OP_ENABLE)) return;
        gc->state.enables.general &= ~__GL_COLOR_LOGIC_OP_ENABLE;
        break;
      case GL_NORMALIZE:
        if (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE)) return;
        gc->state.enables.general &= ~__GL_NORMALIZE_ENABLE;
        break;
      case GL_POINT_SMOOTH:
        if (!(gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE)) return;
        gc->state.enables.general &= ~__GL_POINT_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_SMOOTH:
        if (!(gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE)) return;
        gc->state.enables.general &= ~__GL_POLYGON_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_STIPPLE:
        if (!(gc->state.enables.general & __GL_POLYGON_STIPPLE_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_SCISSOR_TEST:
        if (!(gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_SCISSOR_TEST_ENABLE;
#ifdef NT
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, SCISSOR);
#endif
        // applyViewport does both
        (*gc->procs.applyViewport)(gc);
#else
        (*gc->procs.computeClipBox)(gc);
        (*gc->procs.applyScissor)(gc);
#endif
        break;
      case GL_STENCIL_TEST:
        if (!(gc->state.enables.general & __GL_STENCIL_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_STENCIL_TEST_ENABLE;
        break;
      case GL_TEXTURE_1D:
        if (!(gc->state.enables.general & __GL_TEXTURE_1D_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_1D_ENABLE;
        break;
      case GL_TEXTURE_2D:
        if (!(gc->state.enables.general & __GL_TEXTURE_2D_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_2D_ENABLE;
        break;
      case GL_AUTO_NORMAL:
        if (!(gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE)) return;
        gc->state.enables.general &= ~__GL_AUTO_NORMAL_ENABLE;
        break;
      case GL_TEXTURE_GEN_S:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_S_ENABLE;
        break;
      case GL_TEXTURE_GEN_T:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_T_ENABLE;
        break;
      case GL_TEXTURE_GEN_R:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_R_ENABLE;
        break;
      case GL_TEXTURE_GEN_Q:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_Q_ENABLE;
        break;
#ifdef GL_WIN_multiple_textures
      case GL_TEXCOMBINE_CLAMP_WIN:
        if (!(gc->state.enables.general & __GL_TEXCOMBINE_CLAMP_ENABLE))
        {
            return;
        }
        gc->state.enables.general &= ~__GL_TEXCOMBINE_CLAMP_ENABLE;
        break;
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
        gc->state.enables.general &= ~__GL_PALETTED_LIGHTING_ENABLE;
        break;
#endif
        
      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
        cap -= GL_CLIP_PLANE0;
        if (!(gc->state.enables.clipPlanes & (1 << cap))) return;
        gc->state.enables.clipPlanes &= ~(1 << cap);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, CLIPCTRL);
#endif
        break;
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
        cap -= GL_LIGHT0;
        if (!(gc->state.enables.lights & (1 << cap))) return;
        gc->state.enables.lights &= ~(1 << cap);
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
        MCD_STATE_DIRTY(gc, LIGHTS);
        return;
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
        cap = __GL_EVAL1D_INDEX(cap);
        if (!(gc->state.enables.eval1 & (GLushort) ~(1 << cap))) return;
        gc->state.enables.eval1 &= (GLushort) ~(1 << cap);
        break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
        cap = __GL_EVAL2D_INDEX(cap);
        if (!(gc->state.enables.eval2 & (GLushort) ~(1 << cap))) return;
        gc->state.enables.eval2 &= (GLushort) ~(1 << cap);
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ENABLES);
#endif
}

GLboolean APIPRIVATE __glim_IsEnabled(GLenum cap)
{
    GLuint bit;
    __GL_SETUP_NOT_IN_BEGIN2();

    switch (cap) {
      case GL_ALPHA_TEST:
	bit = gc->state.enables.general & __GL_ALPHA_TEST_ENABLE;
	break;
      case GL_BLEND:
	bit = gc->state.enables.general & __GL_BLEND_ENABLE;
	break;
      case GL_COLOR_MATERIAL:
	bit = gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE;
	break;
      case GL_CULL_FACE:
	bit = gc->state.enables.general & __GL_CULL_FACE_ENABLE;
	break;
      case GL_DEPTH_TEST:
	bit = gc->state.enables.general & __GL_DEPTH_TEST_ENABLE;
	break;
      case GL_POLYGON_OFFSET_POINT:
	bit = gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE;
        break;
      case GL_POLYGON_OFFSET_LINE:
	bit = gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE;
        break;
      case GL_POLYGON_OFFSET_FILL:
	bit = gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE;
        break;
      case GL_DITHER:
	bit = gc->state.enables.general & __GL_DITHER_ENABLE;
	break;
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
        bit = gc->state.enables.general & __GL_FOG_SPEC_TEX_ENABLE;
        break;
#endif //GL_WIN_specular_fog
      case GL_FOG:
        bit = gc->state.enables.general & __GL_FOG_ENABLE;
        break;  
      case GL_LIGHTING:
	bit = gc->state.enables.general & __GL_LIGHTING_ENABLE;
	break;
      case GL_LINE_SMOOTH:
	bit = gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE;
	break;
      case GL_LINE_STIPPLE:
	bit = gc->state.enables.general & __GL_LINE_STIPPLE_ENABLE;
	break;
      case GL_INDEX_LOGIC_OP:
	bit = gc->state.enables.general & __GL_INDEX_LOGIC_OP_ENABLE;
	break;
      case GL_COLOR_LOGIC_OP:
	bit = gc->state.enables.general & __GL_COLOR_LOGIC_OP_ENABLE;
	break;
      case GL_NORMALIZE:
	bit = gc->state.enables.general & __GL_NORMALIZE_ENABLE;
	break;
      case GL_POINT_SMOOTH:
	bit = gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE;
	break;
      case GL_POLYGON_SMOOTH:
	bit = gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE;
	break;
      case GL_POLYGON_STIPPLE:
	bit = gc->state.enables.general & __GL_POLYGON_STIPPLE_ENABLE;
	break;
      case GL_SCISSOR_TEST:
	bit = gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE;
	break;
      case GL_STENCIL_TEST:
	bit = gc->state.enables.general & __GL_STENCIL_TEST_ENABLE;
	break;
      case GL_TEXTURE_1D:
	bit = gc->state.enables.general & __GL_TEXTURE_1D_ENABLE;
	break;
      case GL_TEXTURE_2D:
	bit = gc->state.enables.general & __GL_TEXTURE_2D_ENABLE;
	break;
      case GL_AUTO_NORMAL:
	bit = gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE;
	break;
      case GL_TEXTURE_GEN_S:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE;
	break;
      case GL_TEXTURE_GEN_T:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE;
	break;
      case GL_TEXTURE_GEN_R:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE;
	break;
      case GL_TEXTURE_GEN_Q:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE;
	break;
#ifdef GL_WIN_multiple_textures
      case GL_TEXCOMBINE_CLAMP_WIN:
        bit = gc->state.enables.general & __GL_TEXCOMBINE_CLAMP_ENABLE;
        break;
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
        bit = gc->state.enables.general & __GL_PALETTED_LIGHTING_ENABLE;
        break;
#endif // GL_EXT_flat_paletted_lighting

      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
	cap -= GL_CLIP_PLANE0;
	bit = gc->state.enables.clipPlanes & (1 << cap);
	break;
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
	cap -= GL_LIGHT0;
	bit = gc->state.enables.lights & (1 << cap);
	break;
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
	cap = __GL_EVAL1D_INDEX(cap);
	bit = gc->state.enables.eval1 & (1 << cap);
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
	cap = __GL_EVAL2D_INDEX(cap);
	bit = gc->state.enables.eval2 & (1 << cap);
	break;
      case GL_VERTEX_ARRAY:
      case GL_NORMAL_ARRAY:
      case GL_COLOR_ARRAY:
      case GL_INDEX_ARRAY:
      case GL_TEXTURE_COORD_ARRAY:
      case GL_EDGE_FLAG_ARRAY:
	bit = gc->vertexArray.mask & vaEnable[cap - GL_VERTEX_ARRAY];
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return GL_FALSE;
    }
    return bit != 0;
}

void APIPRIVATE __glim_PolygonOffset(GLfloat factor, GLfloat units)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (__GL_FLOAT_NE (gc->state.polygon.factor, factor) || 
        __GL_FLOAT_NE (gc->state.polygon.units, units))
    {
        gc->state.polygon.factor = factor;
        gc->state.polygon.units = units;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_bitdr.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.8 $
** $Date: 1993/04/10 04:07:00 $
*/
#include "precomp.h"
#pragma hdrstop

#define __GL_BITS_PER_UINT32 (sizeof(GLuint) * __GL_BITS_PER_BYTE)

void __glDrawBitmap(__GLcontext *gc, GLsizei width, GLsizei height,
                    GLfloat xOrig, GLfloat yOrig,
                    GLfloat xMove, GLfloat yMove,
                    const GLubyte oldbits[])
{
    __GLbitmap bitmap;
    GLubyte *newbits;
    size_t size;

    bitmap.width = width;
    bitmap.height = height;
    bitmap.xorig = xOrig;
    bitmap.yorig = yOrig;
    bitmap.xmove = xMove;
    bitmap.ymove = yMove;

    /*
    ** Could check the pixel transfer modes and see if we can maybe just
    ** render oldbits directly rather than converting it first.
    */
    size = (size_t) __glImageSize(width, height, GL_COLOR_INDEX, GL_BITMAP);
    newbits = (GLubyte *) gcTempAlloc(gc, size);

    __glFillImage(gc, width, height, GL_COLOR_INDEX, GL_BITMAP,
                  oldbits, newbits);

    (*gc->procs.renderBitmap)(gc, &bitmap, newbits);

    gcTempFree(gc, newbits);
}

void FASTCALL __glRenderBitmap(__GLcontext *gc, const __GLbitmap *bitmap,
                      const GLubyte *data)
{
    __GLfragment frag;
    __GLvertex *rp;
    __GLfloat fx;
    GLint x, y, bit;
    GLint ySign;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    // Crank down the fpu precision to 24-bit mantissa to gain front-end speed.
    // This will only affect code which relies on double arithmetic.  Also,
    // mask off FP exceptions.  Finally, to draw primitives, we can let the
    // FPU run in chop (truncation) mode since we have enough precision left
    // to convert to pixel units:

    FPU_SAVE_MODE();
    FPU_PREC_LOW_MASK_EXCEPTIONS();
    FPU_CHOP_ON_PREC_LOW();

    ySign = gc->constants.ySign;

    /*
    ** Check if current raster position is valid.  Do not render if invalid.
    ** Also, if selection is in progress skip the rendering of the
    ** bitmap.  Bitmaps are invisible to selection and do not generate
    ** selection hits.
    */
    rp = &gc->state.current.rasterPos;
    if (!gc->state.current.validRasterPos) {
        goto glBitmap_exit;
    }

    if (gc->renderMode == GL_SELECT) {
        rp->window.x += bitmap->xmove;
        rp->window.y += ySign * bitmap->ymove;
        goto glBitmap_exit;
    }

    if (gc->renderMode == GL_FEEDBACK) {
        __glFeedbackBitmap(gc, rp);
        /*
        ** Advance the raster position as if the bitmap had been rendered.
        */
        rp->window.x += bitmap->xmove;
        rp->window.y += ySign * bitmap->ymove;
        goto glBitmap_exit;
    }

    frag.color = *rp->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
        __GLfloat qInv;
        if (__GL_FLOAT_EQZ(rp->texture.w))
        {
            qInv = __glZero;
        }
        else
        {
            qInv = __glOne / rp->texture.w;
        }
        (*gc->procs.texture)(gc, &frag.color, rp->texture.x * qInv,
                               rp->texture.y * qInv, __glOne);
    }
    /* XXX - is this the correct test */
    if (gc->state.enables.general & __GL_FOG_ENABLE) {
        (*gc->procs.fogPoint)(gc, &frag, rp->eyeZ);
    }

    frag.z = rp->window.z;
    fx = (GLint) (rp->window.x - bitmap->xorig);
    frag.y = (GLint) (rp->window.y - ySign * bitmap->yorig);

    bit = 7;
    for (y = 0; y < bitmap->height; y++) {
        frag.x = fx;
        for (x = 0; x < bitmap->width; x++) {
            if (*data & (1<<bit)) {
                (*gc->procs.store)(gc->drawBuffer, &frag);
            }
            frag.x++;
            bit--;
            if (bit < 0) {
                bit = 7;
                data++;
            }
        }
        frag.y += ySign;
        if (bit != 7) {
            bit = 7;
            data++;
        }
    }

    /*
    ** Advance current raster position.
    */
    rp->window.x += bitmap->xmove;
    rp->window.y += ySign * bitmap->ymove;

glBitmap_exit:
    FPU_RESTORE_MODE_NO_EXCEPTIONS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_buffe.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.9 $
** $Date: 1993/04/22 00:20:39 $
*/
#include "precomp.h"
#pragma hdrstop

void FASTCALL __glInitGenericCB(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    cfb->buf.gc = gc;
    cfb->readSpan = __glReadSpan;
    cfb->returnSpan = __glReturnSpan;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_clip.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/07 18:43:05 $
*/
#include "precomp.h"
#pragma hdrstop

#ifdef _X86_
#include <gli386.h>
#endif

/*
** Clipping macros.  These are used to reduce the amount of code
** hand written below.
*/

#ifdef _X86_
// Do a four-component linear interpolation from b to a based on t

// Set up registers for multiple LERP4s
#ifdef NOT_FASTCALL
#define LERP_START(dst, a, b)                                                 \
    __asm mov ecx, dst							      \
    __asm mov edx, a							      \
    __asm mov eax, b
#else
// This relies on dst == ecx and a == edx due to fastcall argument passing
#define LERP_START(dst, a, b)                                                 \
    __asm mov eax, b
#endif
    
// Do a four-component linear interpolation from b to a based on t
// Offsets are assumed to be equal in a, b and d
// Offsets are assumed to increase by four for each component
// LERP_START must come before this
#define LERP4(t, offs)					                      \
    __asm fld t								      \
    __asm fld DWORD PTR [edx+offs]					      \
    __asm fsub DWORD PTR [eax+offs]					      \
    __asm fmul st(0), st(1)						      \
    __asm fld DWORD PTR [edx+offs+4]					      \
    __asm fsub DWORD PTR [eax+offs+4]					      \
    __asm fmul st(0), st(2)						      \
    __asm fld DWORD PTR [edx+offs+8]					      \
    __asm fsub DWORD PTR [eax+offs+8]					      \
    __asm fmul st(0), st(3)						      \
    __asm fld DWORD PTR [edx+offs+12]					      \
    __asm fsub DWORD PTR [eax+offs+12]					      \
    __asm fxch st(4)							      \
    __asm fmulp st(4), st(0)						      \
    /* Stack is now 8 4 0 12 */ 					      \
    __asm fadd DWORD PTR [eax+offs+8]					      \
    __asm fxch st(2)							      \
    /* Stack is now 0 4 8 12 */					              \
    __asm fadd DWORD PTR [eax+offs]					      \
    __asm fxch st(1)							      \
    /* Stack is now 4 0 8 12 */					              \
    __asm fadd DWORD PTR [eax+offs+4]					      \
    __asm fxch st(3)							      \
    /* Stack is now 12 0 8 4 */					              \
    __asm fadd DWORD PTR [eax+offs+12]					      \
    __asm fstp DWORD PTR [ecx+offs+12]					      \
    __asm fstp DWORD PTR [ecx+offs]					      \
    __asm fstp DWORD PTR [ecx+offs+8]					      \
    __asm fstp DWORD PTR [ecx+offs+4]					      \

#define __GL_CLIP_POS(d, a, b, t)       LERP4(t, VCLIP_x)
#define __GL_CLIP_COLOR(d, a, b, t)     LERP4(t, VFCOL_r)
#define __GL_CLIP_BACKCOLOR(d, a, b, t) LERP4(t, VBCOL_r)
#define __GL_CLIP_TEXTURE(d, a, b, t)   LERP4(t, VTEX_x)
#define __GL_CLIP_NORMAL(d, a, b, t)    LERP4(t, VNOR_x)
#define __GL_CLIP_EYE(d, a, b, t)       LERP4(t, VEYE_x)

#else // _X86_

#define LERP_START(dst, a, b)

#ifdef NT
// window is not used!
#define __GL_CLIP_POS(d,a,b,t) \
    d->clip.x = t*(a->clip.x - b->clip.x) + b->clip.x;	\
    d->clip.y = t*(a->clip.y - b->clip.y) + b->clip.y;	\
    d->clip.z = t*(a->clip.z - b->clip.z) + b->clip.z;  \
    d->clip.w = t*(a->clip.w - b->clip.w) + b->clip.w
#else
#define __GL_CLIP_POS(d,a,b,t) \
    d->clip.w = t*(a->clip.w - b->clip.w) + b->clip.w;	\
    /* XXX (mf) Handle w=0.0.  Mathematically incorrect, but prevents /0 */    \
    if( d->clip.w == (__GLfloat) 0.0 ) {		\
	d->window.w = (__GLfloat) 0.0;			\
    }							\
    else						\
    	d->window.w = ((__GLfloat) 1.0) / d->clip.w;    \
    d->clip.x = t*(a->clip.x - b->clip.x) + b->clip.x;	\
    d->clip.y = t*(a->clip.y - b->clip.y) + b->clip.y;	\
    d->clip.z = t*(a->clip.z - b->clip.z) + b->clip.z
#endif

#define __GL_CLIP_COLOR(d,a,b,t)				      \
    d->colors[__GL_FRONTFACE].r = t*(a->colors[__GL_FRONTFACE].r      \
        - b->colors[__GL_FRONTFACE].r) + b->colors[__GL_FRONTFACE].r; \
    d->colors[__GL_FRONTFACE].g = t*(a->colors[__GL_FRONTFACE].g      \
        - b->colors[__GL_FRONTFACE].g) + b->colors[__GL_FRONTFACE].g; \
    d->colors[__GL_FRONTFACE].b = t*(a->colors[__GL_FRONTFACE].b      \
        - b->colors[__GL_FRONTFACE].b) + b->colors[__GL_FRONTFACE].b; \
    d->colors[__GL_FRONTFACE].a = t*(a->colors[__GL_FRONTFACE].a      \
        - b->colors[__GL_FRONTFACE].a) + b->colors[__GL_FRONTFACE].a

#define __GL_CLIP_BACKCOLOR(d,a,b,t)				    \
    d->colors[__GL_BACKFACE].r = t*(a->colors[__GL_BACKFACE].r	    \
        - b->colors[__GL_BACKFACE].r) + b->colors[__GL_BACKFACE].r; \
    d->colors[__GL_BACKFACE].g = t*(a->colors[__GL_BACKFACE].g	    \
        - b->colors[__GL_BACKFACE].g) + b->colors[__GL_BACKFACE].g; \
    d->colors[__GL_BACKFACE].b = t*(a->colors[__GL_BACKFACE].b	    \
        - b->colors[__GL_BACKFACE].b) + b->colors[__GL_BACKFACE].b; \
    d->colors[__GL_BACKFACE].a = t*(a->colors[__GL_BACKFACE].a	    \
        - b->colors[__GL_BACKFACE].a) + b->colors[__GL_BACKFACE].a

#define __GL_CLIP_TEXTURE(d,a,b,t) \
    d->texture.x = t*(a->texture.x - b->texture.x) + b->texture.x; \
    d->texture.y = t*(a->texture.y - b->texture.y) + b->texture.y; \
    d->texture.z = t*(a->texture.z - b->texture.z) + b->texture.z; \
    d->texture.w = t*(a->texture.w - b->texture.w) + b->texture.w

#define __GL_CLIP_NORMAL(d,a,b,t)				      \
    d->normal.x = t*(a->normal.x - b->normal.x) + b->normal.x; \
    d->normal.y = t*(a->normal.y - b->normal.y) + b->normal.y; \
    d->normal.z = t*(a->normal.z - b->normal.z) + b->normal.z; 

#define __GL_CLIP_EYE(d,a,b,t)				      \
    d->eyeX = t*(a->eyeX - b->eyeX) + b->eyeX; \
    d->eyeY = t*(a->eyeY - b->eyeY) + b->eyeY; \
    d->eyeZ = t*(a->eyeZ - b->eyeZ) + b->eyeZ; 

#endif // _x86_

/*
** The following is done this way since when we are slow fogging we want to
** clip the eye.z coordinate only, while when we are cheap fogging we want
** to clip the fog value.  This way we avoid doubling the number of clip
** routines.
#ifdef GL_WIN_specular_fog
** anankan: If we are doing specularly lit textures, then we need to clip 
** the fog as well as eyeZ when both fog and specular_fog are enabled.
#endif //GL_WIN_specular_fog
*/

#define __GL_CLIP_FOG(d,a,b,t)	\
    if (a->has & __GL_HAS_FOG)  \
        d->fog = t * (a->fog - b->fog) + b->fog; \
    else \
        d->eyeZ = t*(a->eyeZ - b->eyeZ) + b->eyeZ

#define __GL_CLIP_INDEX(d,a,b,t)				     \
    d->colors[__GL_FRONTFACE].r = t*(a->colors[__GL_FRONTFACE].r     \
        - b->colors[__GL_FRONTFACE].r) + b->colors[__GL_FRONTFACE].r

#define __GL_CLIP_BACKINDEX(d,a,b,t)				   \
    d->colors[__GL_BACKFACE].r = t*(a->colors[__GL_BACKFACE].r	   \
        - b->colors[__GL_BACKFACE].r) + b->colors[__GL_BACKFACE].r

/************************************************************************/

/*
  Naming code:
   C = Front color
   B = Back color
   I = Front index
   X = Back index
   F = Fog
   T = Texture
   N = Normal
   Pos = <no letter>
  */


static void FASTCALL Clip(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
}

static void FASTCALL ClipC(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
}

static void FASTCALL ClipB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
}

static void FASTCALL ClipI(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
}

static void FASTCALL ClipX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
}


static void FASTCALL ClipCB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
}

static void FASTCALL ClipIX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
}

static void FASTCALL ClipT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipIT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipIXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipCT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipCBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

#ifdef GL_WIN_phong_shading
/************New Clip Procs*******************************/

static void FASTCALL ClipN(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNC(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNI(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}


static void FASTCALL ClipNCB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNIX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNIT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNIXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNCT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNCBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}


static void FASTCALL ClipNE(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEC(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEI(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}


static void FASTCALL ClipNECB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEIX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNET(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEIT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEIXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNECT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNECBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTUR