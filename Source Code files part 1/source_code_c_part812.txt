( strValue != NULL ){
                    nLevelIndex = (CHAR)_wtoi( strValue );
                }

            }else if( line[1] == 'v' || line[1] == 'V' ){ // version

                strValue =  wcstok( NULL,  L" \t\n\r" );
                if( strValue != NULL ){
                    nVersionIndex = (SHORT)_wtoi( strValue );
                }
                typeCount = 0;

            }else if( line[1] == 't' || line[1] == 'T' ){ // type
            
                SHORT nMatchCheck = 0;

                strType =  wcstok( NULL,   L" \t\n\r" );
                strValue =  wcstok( NULL,   L"\"\n,\r" );

                if( strType && strValue ){
                    nTypeIndex = (SHORT)_wtoi( strValue );
                }else{
                    continue;
                }

                typeCount++;
                if (typeCount >= MAXTYPE) {
                    //fwprintf(stderr,  L"Warning: Too many types defined\n");
                }

                pMofVersion = GetNewMofVersion( nTypeIndex, nVersionIndex, nLevelIndex );

                if( NULL != pMofVersion ){
                    InsertTailList( (&ListHead), &pMofVersion->Entry);
            
                    pMofVersion->strType = (LPWSTR)malloc( (lstrlenW(strType)+1) * sizeof(WCHAR) );
            
                    if( NULL != pMofVersion->strType ){
                         StringCchCopyW( pMofVersion->strType, lstrlenW(strType)+1, strType );
                    }

                    if( nTypeIndex == nType ){
                        nMatchCheck = 1;
                        if( nLevelIndex == nLevel ){
                            nMatchCheck++;
                        }
                        if( nVersionIndex == nVersion ){
                            nMatchCheck++;
                        }
                    }


                    if( nMatchCheck > nMatchLevel ){
                        nMatchLevel = nMatchCheck;
                        pMofLookup = pMofVersion;
                    }
                }
            }
        }
        else if (   (line[0] >= '0' && line[0] <= '9')
                 || (line[0] >= 'a' && line[0] <= 'f')
                 || (line[0] >= 'A' && line[0] <= 'F')) {

            LPWSTR strName = NULL;
            bInGuid = FALSE;

            typeCount = 0;

            wcsncpy(buffer, line, 8);
            buffer[8] = 0;
            guid.Data1 = ahextoi(&buffer[0]);
            
            wcsncpy(buffer, &line[9], 4);
            buffer[4] = 0;
            guid.Data2 = (USHORT) ahextoi(&buffer[0]);
            
            wcsncpy(buffer, &line[14], 4);
            buffer[4] = 0;
            guid.Data3 = (USHORT) ahextoi(buffer);
            
            for (i=0; i<2; i++) {
                wcsncpy(buffer, &line[19 + (i*2)], 2);
                buffer[2] = 0;
                guid.Data4[i] = (UCHAR) ahextoi(buffer);
            }
            for (i=2; i<8; i++) {
                wcsncpy(buffer, &line[20 + (i*2)], 2);
                buffer[2] = 0;
                guid.Data4[i] = (UCHAR) ahextoi(buffer);
            }
            
            if( ! IsEqualGUID( &Guid, &guid ) ){
                continue;
            }

            s = &line[36];

            strName =  wcstok( s,   L" \n\t\r" );

            if( NULL == strName ){  // Must have a name for the Guid. 
                continue;
            }
            
            bInGuid = TRUE;
            FlushMofVersionList(pMofInfo,  &ListHead);

            pMofInfo = GetMofInfoHead(&Guid);
            if (pMofInfo == NULL)  {
                return NULL;
            }
            pMofInfo->bKernelEvent = bKernelEvent;
            pMofInfo->strDescription = (LPWSTR)malloc((lstrlenW(strName)+1) * sizeof(WCHAR));
            if( NULL != pMofInfo->strDescription ){
                 StringCchCopyW(pMofInfo->strDescription, lstrlenW(strName)+1, strName);            
            }


            pMofVersion = GetNewMofVersion( 
                                           EVENT_TYPE_DEFAULT, 
                                           EVENT_VERSION_DEFAULT, 
                                           EVENT_LEVEL_DEFAULT 
                                          );

            if (pMofVersion == NULL) {
                return NULL;
            }

            pMofLookup = pMofVersion;
            InsertTailList( (&ListHead), &pMofVersion->Entry);
        }

    }

    FlushMofVersionList(pMofInfo,  &ListHead );
    return pMofLookup;
}

VOID
UpdateThreadPrintData(
    PPRINT_JOB_RECORD pJob,
    PEVENT_TRACE_HEADER pHeader,
    PTHREAD_RECORD pThread
    )
{
    unsigned long i = 0;
    BOOLEAN bFound = FALSE;

    if ( (pJob == NULL) || (pHeader == NULL) || (pThread == NULL) ) {
        return;
    }

    for (i = 0; i < pJob->NumberOfThreads; i++) {
        if (pJob->ThreadData[i].ThreadId == pHeader->ThreadId) {
            bFound = TRUE;
            break;
        }
    }
    if ((i < MAX_THREADS) && !bFound) {
        pJob->ThreadData[i].ThreadId = pHeader->ThreadId;
        pJob->NumberOfThreads++;
        bFound = TRUE;
    }

    if (bFound) {
        //
        // TODO: There is potential for double counting if the same thread
        // came back and did more work for this job after having done work for an other
        // job in between.
        //
        if (pJob->ThreadData[i].PrevKCPUTime > 0)
            pJob->ThreadData[i].KCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pJob->ThreadData[i].PrevKCPUTime;
        if (pJob->ThreadData[i].PrevUCPUTime > 0)
            pJob->ThreadData[i].UCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pJob->ThreadData[i].PrevUCPUTime;
        if (pJob->ThreadData[i].PrevReadIO > 0)
            pJob->ThreadData[i].ReadIO   += pThread->ReadIO - pJob->ThreadData[i].PrevReadIO;
        if (pJob->ThreadData[i].PrevWriteIO > 0)
            pJob->ThreadData[i].WriteIO  += pThread->WriteIO - pJob->ThreadData[i].PrevWriteIO;

        pJob->ThreadData[i].PrevKCPUTime = pHeader->KernelTime * CurrentSystem.TimerResolution;
        pJob->ThreadData[i].PrevUCPUTime = pHeader->UserTime * CurrentSystem.TimerResolution;
        pJob->ThreadData[i].PrevReadIO   = pThread->ReadIO;
        pJob->ThreadData[i].PrevWriteIO  = pThread->WriteIO;
    }
}

VOID
PrintJobCallback(
    PEVENT_TRACE pEvent
    )
{
    PTHREAD_RECORD pThread;
    PEVENT_TRACE_HEADER pHeader;
    PMOF_INFO pMofInfo;
    ULONG JobId = 0;
    PPRINT_JOB_RECORD pJob;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    //
    // Ignore Process/Thread Start/End transactions. Only go after
    // User Defined  Transactions.
    //
    pMofInfo = GetMofInfoHead( &pEvent->Header.Guid ); 
    if (pMofInfo == NULL){
         return;
    }

    if (!IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid))
        GetMofData(pEvent, L"JobId", &JobId, sizeof(ULONG));

    pThread = FindGlobalThreadById(pHeader->ThreadId, pEvent);


    if (JobId == 0) {
        if (pThread == NULL) return;
        JobId = pThread->JobId; // if Current Job Id is 0, use the cached one.
    }
    else {
        if (pThread != NULL) {
            if (JobId != pThread->JobId) {
                pJob = FindPrintJobRecord(pThread->JobId);
                UpdateThreadPrintData(pJob, pHeader, pThread);
            }

            pThread->JobId = JobId;
        }
    }

    if (JobId == 0) return; // To filter all th termination without print jobs.


    pJob = FindPrintJobRecord(JobId);
    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_SPOOLJOB) {
        if (pJob) {
            // A job id is being reused before it was deleted from the last
            // use.  We must have missed a delete event, so just through the old
            // job away.
            DeletePrintJobRecord(pJob, FALSE);
        }
        pJob = AddPrintJobRecord(JobId);
        if (pJob != NULL) {
            pJob->StartTime = pEvent->Header.TimeStamp.QuadPart;
        }
    }

    if (pJob == NULL)  // if a Start event is lost for this job, this could happen.
        return;

    UpdateThreadPrintData(pJob, pHeader, pThread);

    // If you see any of these things then stop tracking resources on the
    // thread.
    if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_DELETEJOB)      ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_PAUSE)          ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_RESUME)) {
        if (pThread != NULL)
            pThread->JobId = 0;
    }

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_PAUSE) {
        pJob->PauseStartTime = pEvent->Header.TimeStamp.QuadPart;
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_RESUME) {
        pJob->PauseTime += (pEvent->Header.TimeStamp.QuadPart - pJob->PauseStartTime) / 10000;
        pJob->PauseStartTime = 0;
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_PRINTJOB) {
        pJob->PrintJobTime = pEvent->Header.TimeStamp.QuadPart;
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_DELETEJOB) {
        unsigned long i;
        pJob->EndTime = pEvent->Header.TimeStamp.QuadPart;
        pJob->ResponseTime += (pEvent->Header.TimeStamp.QuadPart - pJob->StartTime) / 10000; // in msec
        GetMofData(pEvent, L"JobSize", &pJob->JobSize, sizeof(ULONG));
        GetMofData(pEvent, L"DataType", &pJob->DataType, sizeof(ULONG));
        GetMofData(pEvent, L"Pages", &pJob->Pages, sizeof(ULONG));
        GetMofData(pEvent, L"PagesPerSide", &pJob->PagesPerSide, sizeof(ULONG));
        GetMofData(pEvent, L"FilesOpened", &pJob->FilesOpened, sizeof(SHORT));

        pJob->KCPUTime = 0;
        pJob->UCPUTime = 0;
        pJob->ReadIO = 0;
        pJob->WriteIO = 0;
        for (i=0; i < pJob->NumberOfThreads; i++) {
            pJob->KCPUTime += pJob->ThreadData[i].KCPUTime;
            pJob->UCPUTime += pJob->ThreadData[i].UCPUTime;
            pJob->ReadIO += pJob->ThreadData[i].ReadIO;
            pJob->WriteIO += pJob->ThreadData[i].WriteIO;

        }
        DeletePrintJobRecord(pJob, TRUE);
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_JOBRENDERED) {
        GetMofData(pEvent, L"GdiJobSize", &pJob->GdiJobSize, sizeof(ULONG));
        GetMofData(pEvent, L"ICMMethod", &pJob->ICMMethod, sizeof(ULONG));
        GetMofData(pEvent, L"Color", &pJob->Color, sizeof(SHORT));
        GetMofData(pEvent, L"XRes", &pJob->XRes, sizeof(SHORT));
        GetMofData(pEvent, L"YRes", &pJob->YRes, sizeof(SHORT));
        GetMofData(pEvent, L"Quality", &pJob->Quality, sizeof(SHORT));
        GetMofData(pEvent, L"Copies", &pJob->Copies, sizeof(SHORT));
        GetMofData(pEvent, L"TTOption", &pJob->TTOption, sizeof(SHORT));
    }
}

VOID
UpdateThreadIisData(
    PHTTP_REQUEST_RECORD pReq,
    PEVENT_TRACE_HEADER pHeader,
    PTHREAD_RECORD pThread
    )
{
    unsigned long i = 0;
    BOOLEAN bFound = FALSE;

    if ( (pReq == NULL) || (pHeader == NULL) || (pThread == NULL) ) {
        return;
    }

    for (i = 0; i < pReq->NumberOfThreads; i++) {
        if (pReq->ThreadData[i].ThreadId == pHeader->ThreadId) {
            if (i != pReq->CurrentThreadIndex) {
                // This means the same thread worked on the same request multiple times after having done
                // work for another job in between.
                // This will result in double counting. We should set the previous time and exit.
                pReq->ThreadData[i].PrevKCPUTime = pHeader->KernelTime * CurrentSystem.TimerResolution;
                pReq->ThreadData[i].PrevUCPUTime = pHeader->UserTime * CurrentSystem.TimerResolution;
                pReq->ThreadData[i].PrevReadIO   = pThread->ReadIO;
                pReq->ThreadData[i].PrevWriteIO  = pThread->WriteIO;

                pReq->CurrentThreadIndex = i;

                return;
            }
            else {
                bFound = TRUE;
            }
            break;
        }
    }
    if ((i < MAX_THREADS) && !bFound) {
        pReq->ThreadData[i].ThreadId = pHeader->ThreadId;
        pReq->NumberOfThreads++;
        bFound = TRUE;
    }

    if (bFound) {

        if (pHeader->KernelTime * CurrentSystem.TimerResolution < pReq->ThreadData[i].PrevKCPUTime) {
            pReq->ThreadData[i].PrevKCPUTime = pHeader->KernelTime * CurrentSystem.TimerResolution;
        }
        if (pHeader->UserTime * CurrentSystem.TimerResolution < pReq->ThreadData[i].PrevUCPUTime) {
            pReq->ThreadData[i].PrevUCPUTime = pHeader->UserTime * CurrentSystem.TimerResolution;
        }

        // New for IIS Events
        // Due to the hook placements, we needed to tweak which routine (UL, W3core, W3filter,
        // ISAPI, ASP, CGI) we need to charge CPU time to. 
        if (pReq->ThreadData[i].PrevKCPUTime > 0)
            pReq->ThreadData[i].KCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
        if (pReq->ThreadData[i].PrevUCPUTime > 0)
            pReq->ThreadData[i].UCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
        if (pReq->ThreadData[i].PrevReadIO > 0)
            pReq->ThreadData[i].ReadIO   += pThread->ReadIO - pReq->ThreadData[i].PrevReadIO;
        if (pReq->ThreadData[i].PrevWriteIO > 0)
            pReq->ThreadData[i].WriteIO  += pThread->WriteIO - pReq->ThreadData[i].PrevWriteIO;

        if (IsEqualGUID(&pHeader->Guid, &UlGuid)) {
            if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                pReq->ULCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
            }
            if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                pReq->ULCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
            }
        }
        else if (IsEqualGUID(&pHeader->Guid, &W3CoreGuid)) {
            if (pReq->ASPStartTime == 0 || pReq->ASPEndTime != 0) {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->W3CPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->W3CPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
            else {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->ASPCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->ASPCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
        }
        else if (IsEqualGUID(&pHeader->Guid, &W3FilterGuid)) {
            if (pReq->W3FilterVisits > 0) {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->W3FltrCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->W3FltrCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
            else {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->W3CPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->W3CPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
        }
        else if (IsEqualGUID(&pHeader->Guid, &W3CgiGuid)) {
            if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                pReq->CGICPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
            }
            if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                pReq->CGICPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
            }
        }
        else if (IsEqualGUID(&pHeader->Guid, &W3IsapiGuid)) {
            if (pReq->ASPStartTime == 0 || pReq->ASPEndTime != 0) {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->ISAPICPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->ISAPICPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
            else {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->ASPCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->ASPCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
        }
        else if (IsEqualGUID(&pHeader->Guid, &IisAspGuid) ||
                 IsEqualGUID(&pHeader->Guid, &IisAspNetGuid) ||
                 IsEqualGUID(&pHeader->Guid, &IisCustomIsapiGuid)) {
            if (pReq->ASPStartTime == 0) {
                if (pReq->ISAPIStartTime == 0) {
                    if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                        pReq->W3CPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                    }
                    if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                        pReq->W3CPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                    }
                }
                else {
                    if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                        pReq->ISAPICPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                    }
                    if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                        pReq->ISAPICPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                    }
                }
            }
            else {
                if (pReq->ThreadData[i].PrevKCPUTime > 0) {
                    pReq->ASPCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevKCPUTime;
                }
                if (pReq->ThreadData[i].PrevUCPUTime > 0) {
                    pReq->ASPCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pReq->ThreadData[i].PrevUCPUTime;
                }
            }
        }

        pReq->ThreadData[i].PrevKCPUTime = pHeader->KernelTime * CurrentSystem.TimerResolution;
        pReq->ThreadData[i].PrevUCPUTime = pHeader->UserTime * CurrentSystem.TimerResolution;
        pReq->ThreadData[i].PrevReadIO   = pThread->ReadIO;
        pReq->ThreadData[i].PrevWriteIO  = pThread->WriteIO;

        pReq->CurrentThreadIndex = i;

    }
#ifdef DBG
    else { // MAX_THREADS (== 10) is reached.
        TrctrDbgPrint(("TRACERPT Warning Req: %I64u MAX_THREADS reached.\n", pReq->RequestId));
    }
#endif

}

//
// This routine sums up CPU time and IO counts to HTTP_REQUEST_RECORD
// so that the request can be written to a file.
//
VOID
SumUpCPUTime(
    PHTTP_REQUEST_RECORD pReq
    )
{
    ULONG i;
    if (NULL == pReq) {
        return;
    }
    pReq->KCPUTime = 0;
    pReq->UCPUTime = 0;
    pReq->ReadIO = 0;
    pReq->WriteIO = 0;
    for (i = 0; i < pReq->NumberOfThreads; i++) {
        pReq->KCPUTime += pReq->ThreadData[i].KCPUTime;
        pReq->UCPUTime += pReq->ThreadData[i].UCPUTime;
        pReq->ReadIO += pReq->ThreadData[i].ReadIO;
        pReq->WriteIO += pReq->ThreadData[i].WriteIO;
    }
}

PHTTP_REQUEST_RECORD
GetBestAspRequest(
    ULONGLONG ConnId,
    BOOLEAN AspStart
    )
{
    PHTTP_REQUEST_RECORD pReq1, pReq2;
    pReq1 = FindHttpReqRecordByConId(ConnId, NULL);
    if (pReq1 == NULL) {
        return NULL;
    }
    pReq2 = FindHttpReqRecordByConId(ConnId, pReq1);
    if (pReq2 == NULL) {
        return pReq1;
    }
    if (AspStart) {
        if (pReq1->ASPStartTime == 0 && pReq2->ASPStartTime == 0) {
            return ((pReq1->ISAPIStartTime < pReq1->ISAPIStartTime) ?
                        pReq1 : pReq2);
        }
        else if (pReq1->ASPStartTime != 0 && pReq2->ASPStartTime == 0) {
            return pReq2;
        }
        else if (pReq1->ASPStartTime == 0 && pReq2->ASPStartTime != 0) {
            return pReq1;
        }
        else {  // both ASPStartTimes are non-zero.
            DeleteHttpReqRecord(pReq1, FALSE);
            DeleteHttpReqRecord(pReq2, FALSE);
            return NULL;
        }
    }
    else {
        if (pReq1->ASPEndTime == 0 && pReq2->ASPEndTime == 0) {
            if (pReq1->ASPStartTime == 0 && pReq2->ASPStartTime != 0) {
                return pReq2;
            }
            else if (pReq1->ASPStartTime != 0 && pReq2->ASPStartTime == 0) {
                return pReq1;
            }
            else if (pReq1->ASPStartTime != 0 && pReq2->ASPStartTime != 0) {
                return ((pReq1->ASPStartTime < pReq1->ASPStartTime) ?
                            pReq1 : pReq2);
            }
            else {  // both ASPStartTimes are zero.
                DeleteHttpReqRecord(pReq1, FALSE);
                DeleteHttpReqRecord(pReq2, FALSE);
                return NULL;
            }
        }
        else if (pReq1->ASPEndTime != 0 && pReq2->ASPEndTime == 0) {
            return pReq2;
        }
        else if (pReq1->ASPEndTime == 0 && pReq2->ASPEndTime != 0) {
            return pReq1;
        }
        else {  // both ASPEndTimes are non-zero.
            DeleteHttpReqRecord(pReq1, FALSE);
            DeleteHttpReqRecord(pReq2, FALSE);
            return NULL;
        }
    }
}

VOID
IISEventCallback(
    PEVENT_TRACE pEvent
    )
{
    PTHREAD_RECORD pThread;
    PEVENT_TRACE_HEADER pHeader;
    PMOF_INFO pMofInfo;
    ULONGLONG RequestId = 0;
    ULONG IpAddr = 0;
    PHTTP_REQUEST_RECORD pReq = NULL;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    pMofInfo = GetMofInfoHead( &pEvent->Header.Guid ); 
    if (pMofInfo == NULL){
         return;
    }

    if (CurrentSystem.IISStartTime == 0) {
        CurrentSystem.IISStartTime = pEvent->Header.TimeStamp.QuadPart; 
    }
    CurrentSystem.IISEndTime = pEvent->Header.TimeStamp.QuadPart; 

    pThread = FindGlobalThreadById(pHeader->ThreadId, pEvent);

    if (IsEqualGUID(&pEvent->Header.Guid, &IisAspGuid) ||
        IsEqualGUID(&pEvent->Header.Guid, &IisAspNetGuid) ||
        IsEqualGUID(&pEvent->Header.Guid, &IisCustomIsapiGuid)) {
        ULONG ConId32 = 0;
        ULONGLONG ConId64 = 0;
        BOOLEAN AspStart;
        if (PointerSize == 32) {
            GetMofData(pEvent, L"ConnID", &ConId32, 4);
            ConId64 = (ULONGLONG)ConId32;
        }
        else {
            GetMofData(pEvent, L"ConnID", &ConId64, 8);
        }
        AspStart = (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISASP_START);
        pReq = GetBestAspRequest(ConId64, AspStart);
        if (pReq != NULL) {
            RequestId = pReq->RequestId;
            if (pThread != NULL) {
                if (RequestId != pThread->IisReqId) {
                    PHTTP_REQUEST_RECORD pThreadReq = FindHttpReqRecord(pThread->IisReqId);
                    UpdateThreadIisData(pThreadReq, pHeader, pThread);
                }
                pThread->IisReqId = RequestId;
            }
            if (IsEqualGUID(&pEvent->Header.Guid, &IisAspNetGuid)) {
                pReq->IsapiExt = ISAPI_EXTENTION_ASP_NET;
            } 
            else if (IsEqualGUID(&pEvent->Header.Guid, &IisCustomIsapiGuid)) {
                pReq->IsapiExt = ISAPI_EXTENTION_CUSTOM;
            }
            else {
                pReq->IsapiExt = ISAPI_EXTENTION_ASP;
            }
        }
        else { // ASP event with no previous RequestId. Exit.
            return;
        }
    }
    else { // non-ASP events 
        if (IsEqualGUID(&pEvent->Header.Guid, &IisStrmFilterGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &IisSslHandShakeGuid)) {
            // These events don't have request ID. We'll just use the request that this thread is working on.
            if (pThread != NULL) {
                RequestId = pThread->IisReqId;
            }
        }
        else if (!IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid)) {
            if ((IsEqualGUID(&pEvent->Header.Guid, &UlGuid)) &&
                ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_START) ||
                (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_PARSE) ||
                (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_DELIVER) ||
                (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_CACHEDEND))) {
                RequestId = 0;
                GetMofData(pEvent, L"RequestObj", &RequestId, (PointerSize / 8));
            }
            else {
                GetMofData(pEvent, L"RequestId", &RequestId, sizeof(ULONGLONG));
            }
        }

        if (RequestId == 0) {
            if (pThread == NULL) {
                return;
            }
            RequestId = pThread->IisReqId; // if Current Request Id is 0, use the cached one.
        }
        else {
            if (pThread != NULL) {
                if (RequestId != pThread->IisReqId) {
                    pReq = FindHttpReqRecord(pThread->IisReqId);
                    UpdateThreadIisData(pReq, pHeader, pThread);
                }
                pThread->IisReqId = RequestId;
            }
        }

        if (RequestId == 0) return; // To filter all the termination without any useful IIS activity.

        pReq = FindHttpReqRecord(RequestId);
        // If there no active request, look for it in the (almost finished) pending list.

        if (pReq == NULL) {
            pReq = FindPendingHttpReqRecord(RequestId);
        }
    }

    if (IsEqualGUID(&pEvent->Header.Guid, &UlGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_START) {
            // struct needed for IPV6 address format.
            struct {
                USHORT  TdiAddrType;
                union
                {
                    TDI_ADDRESS_IP  RemoteAddrIn;
                    TDI_ADDRESS_IP6 RemoteAddrIn6;
                };
            } TdiAddress;

            if (pReq != NULL) {
                // A request id is being reused before it was deleted from the last
                // use.  We must have missed a delete event, so just through the old
                // request away.
                EnterTracelibCritSection();
                RemoveEntryList( &pReq->Entry );
                LeaveTracelibCritSection();
                DeleteHttpReqRecord(pReq, FALSE);
                IISRequestsDiscarded++;
            }
            RtlZeroMemory(&TdiAddress, sizeof(TdiAddress));
            GetMofData(pEvent, L"AddressType", &TdiAddress, sizeof(TdiAddress));
            pReq = AddHttpReqRecord(RequestId, 
                                    TdiAddress.TdiAddrType, 
                                    TdiAddress.RemoteAddrIn.in_addr,
                                    TdiAddress.RemoteAddrIn6.sin6_addr);
            if (pReq != NULL) {
                pReq->ULStartTime = pEvent->Header.TimeStamp.QuadPart;
            }
            return;
        }
    }
    // if a Start event is lost for this job, this could happen.
    // We will not bother with transactions with missing
    // Start or Parse.
    if (pReq == NULL) {
        IISEventsDiscarded++;
        return;
    }

    if (IsEqualGUID(&pEvent->Header.Guid, &UlGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_PARSE) {
            ULONG URLSize = 0;
            PWCHAR URLStrTemp;
            PCHAR URLStr;

            pReq->ULParseTime = pEvent->Header.TimeStamp.QuadPart;
            if (pReq->URL != NULL) {
                free (pReq->URL);
            }
            // Get URL
            URLStrTemp = (PWCHAR)malloc(MAXSTR * sizeof(WCHAR));
            if (URLStrTemp != NULL) {
                RtlZeroMemory(URLStrTemp, MAXSTR * sizeof(WCHAR));
                URLSize = GetMofData(pEvent, L"Url", URLStrTemp, MAXSTR * sizeof(WCHAR));
                if (URLSize > (MAXSTR * sizeof(WCHAR))) {
                    free(URLStrTemp);
                    // We need to allocate one more char so that GetMofDat() can put an ending NULL in it.
                    URLStrTemp = (PWCHAR)malloc(URLSize + sizeof(WCHAR));
                    if (URLStrTemp != NULL) {
                        RtlZeroMemory(URLStrTemp, URLSize + sizeof(WCHAR));
                        GetMofData(pEvent, L"Url", URLStrTemp, URLSize);
                    }
                    else {
                        return;
                    }
                }
            }
            else {
                return;
            }
            // Save memory by just mallocing only the amount of space we need.
            URLSize = wcslen(URLStrTemp);
            if (URLSize > 0) {
                URLStr = (PCHAR)malloc((URLSize + 1)); 
                if (URLStr != NULL) {
                    WideCharToMultiByte(CP_ACP,
                                        0,
                                        URLStrTemp,
                                        URLSize,
                                        URLStr,
                                        (URLSize + 1),
                                        NULL,
                                        NULL);
                    URLStr[URLSize] = '\0';
                }
                pReq->URL = URLStr;
            }
            free(URLStrTemp);
        } 
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_DELIVER) {
            ULONG SiteId;
            ULONGLONG NewRequestId = 0;
            PHTTP_REQUEST_RECORD pPendingReq;

            // If the request is delivered to the user mode, no need to track it
            // on the thread.
            if (pThread != NULL) {
                pThread->IisReqId = 0;
            }
            // Update RequestId with the real one.
            GetMofData(pEvent, L"RequestId", &NewRequestId, sizeof(ULONGLONG));

            // There may be another (almost finished) request using the same RequestId.
            // Put that request to the pending request list.
            pPendingReq = FindHttpReqRecord(NewRequestId);
            if (pPendingReq != NULL) {
                EnterTracelibCritSection();
                RemoveEntryList( &pPendingReq->Entry );
                InsertHeadList( &CurrentSystem.PendingHttpReqListHead, &pPendingReq->Entry );
                LeaveTracelibCritSection();
            }
            pReq->RequestId = NewRequestId;

            pReq->ULDeliverTime = pEvent->Header.TimeStamp.QuadPart;
            GetMofData(pEvent, L"SiteId", &SiteId, sizeof(ULONG));
            pReq->SiteId = SiteId;
        } 
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_RECVRESP ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_RECVBODY ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_FASTRESP) {

            pReq->ULReceiveTime = pEvent->Header.TimeStamp.QuadPart;
            pReq->ULReceiveType = pEvent->Header.Class.Type;
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_CACHEDEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_CACHEANDSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_FASTSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_ZEROSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_SENDERROR ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_END) {

            if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_CACHEDEND) {
                GetMofData(pEvent, L"BytesSent", &(pReq->BytesSent), sizeof(ULONG));
                GetMofData(pEvent, L"SiteId", &(pReq->SiteId), sizeof(ULONG));
                pReq->HttpStatus = 200;
            }
            else {
                // This is UL End events for non-cached URL requests.
                // If W3StartTime or ULReceiveTime is missing, look for a pending 
                // request with the same RequestId.
                if (pReq->W3StartTime == 0 || pReq->ULReceiveTime == 0) {
                    PHTTP_REQUEST_RECORD pPendingReq = FindPendingHttpReqRecord(RequestId);
                    if (pPendingReq != NULL) {
                        pReq = pPendingReq;
                    }
                }
                GetMofData(pEvent, L"HttpStatus", &(pReq->HttpStatus), sizeof(USHORT));
            }
            pReq->ULEndTime = pEvent->Header.TimeStamp.QuadPart;
            pReq->ULEndType = pEvent->Header.Class.Type;
            pReq->ULResponseTime = (pReq->ULEndTime - pReq->ULStartTime); // in msec

            if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_UL_CACHEDEND) {
                UpdateThreadIisData(pReq, pHeader, pThread);
                SumUpCPUTime(pReq);
                DeleteHttpReqRecord(pReq, TRUE);
                return;
            }
            else if (pReq->ASPStartTime == 0) {
                if (pReq->W3EndTime != 0) { // Wait till W3 ends to get BytesSent
                    UpdateThreadIisData(pReq, pHeader, pThread);
                    SumUpCPUTime(pReq);
                    DeleteHttpReqRecord(pReq, TRUE);
                    return;
                }
            }
            else {
                if (pReq->W3EndTime != 0 && pReq->ASPEndTime != 0) { // Wait till W3 ends to get BytesSent
                    UpdateThreadIisData(pReq, pHeader, pThread);
                    SumUpCPUTime(pReq);
                    DeleteHttpReqRecord(pReq, TRUE);
                    return;
                }
            }
        }
    } 
    else if (IsEqualGUID(&pEvent->Header.Guid, &W3CoreGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_START) {
            pReq->W3StartTime = pEvent->Header.TimeStamp.QuadPart;
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_FILEREQ ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_CGIREQ ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_ISAPIREQ ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_OOPREQ) {
            pReq->W3ProcessType = pEvent->Header.Class.Type;
            pReq->FileReqTime = pEvent->Header.TimeStamp.QuadPart;
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_SENDBODY ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_SENDRESP ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_SENDENTITY ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_SENDFILTER ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_ERRSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_ERRSENDENT ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_ERRSENDCTX ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_ERRVECSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_VECTORSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CORE_END) {
                // This is W3 End events for non-cached URL requests.
                // If W3StartTime or ULReceiveTime is missing, look for a pending 
                // request with the same RequestId.
            if (pReq->W3StartTime == 0 || pReq->ULReceiveTime == 0) {
                PHTTP_REQUEST_RECORD pPendingReq = FindPendingHttpReqRecord(RequestId);
                if (pPendingReq != NULL) {
                    pReq = pPendingReq;
                }
            }
            GetMofData(pEvent, L"BytesSent", &(pReq->BytesSent), sizeof(ULONG));
            pReq->W3EndTime = pEvent->Header.TimeStamp.QuadPart;
            pReq->W3EndType = pEvent->Header.Class.Type;
            if (pReq->ASPStartTime != 0) {
                if (pReq->ULEndTime != 0 && pReq->ASPEndTime != 0) {
                    UpdateThreadIisData(pReq, pHeader, pThread);
                    SumUpCPUTime(pReq);
                    DeleteHttpReqRecord(pReq, TRUE);
                    return;
                }
            }
            else {
                if (pReq->ULEndTime != 0) {
                    UpdateThreadIisData(pReq, pHeader, pThread);
                    SumUpCPUTime(pReq);
                    DeleteHttpReqRecord(pReq, TRUE);
                    return;
                }
            }
        }
    }
    else if (IsEqualGUID(&pEvent->Header.Guid, &W3FilterGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3FILTER_START) {
            if (pReq->W3FilterStartTime == 0) {
                pReq->W3FilterStartTime = pEvent->Header.TimeStamp.QuadPart;
                pReq->W3FilterVisits++;
            }
            else {
                pReq->W3FilterStartTime = pEvent->Header.TimeStamp.QuadPart;
            }
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3FILTER_END) {
            if (pReq->W3FilterStartTime != 0) {
                pReq->W3FilterResponseTime += pEvent->Header.TimeStamp.QuadPart - pReq->W3FilterStartTime;
                pReq->W3FilterStartTime = 0;
            }
        }
    } 
    else if (IsEqualGUID(&pEvent->Header.Guid, &W3CgiGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CGI_START) {
            pReq->W3ProcessType = EVENT_TRACE_TYPE_W3CORE_CGIREQ;
            pReq->CGIStartTime = pEvent->Header.TimeStamp.QuadPart;
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3CGI_END) {
            pReq->CGIEndTime = pEvent->Header.TimeStamp.QuadPart;
        }
    } 
    else if (IsEqualGUID(&pEvent->Header.Guid, &W3IsapiGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_START) {
            ULONG ConId32 = 0;
            ULONGLONG ConId64 = 0;
            pReq->W3ProcessType = EVENT_TRACE_TYPE_W3CORE_ISAPIREQ;
            if (PointerSize == 32) {
                GetMofData(pEvent, L"connID", &ConId32, 4);
                ConId64 = (ULONGLONG)ConId32;
            }
            else {
                GetMofData(pEvent, L"connID", &ConId64, 8);
            }
            pReq->ConId = ConId64;
            pReq->ISAPIStartTime = pEvent->Header.TimeStamp.QuadPart;
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_SENDHDR ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_SENDHDREX ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_VECTORSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_ERRORSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_SSFSEND ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_SSDERROR ||
                 pEvent->Header.Class.Type == EVENT_TRACE_TYPE_W3ISAPI_END) {
            pReq->ISAPIEndType = pEvent->Header.Class.Type;
            pReq->ISAPIEndTime = pEvent->Header.TimeStamp.QuadPart;
        }
    }
    else if (IsEqualGUID(&pEvent->Header.Guid, &IisStrmFilterGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISSTRMFILTER_START) {
            if (pReq->StrmFltrResponseTime == 0) {
                pReq->StrmFltrResponseTime = pEvent->Header.TimeStamp.QuadPart;
            }
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISSTRMFILTER_END) {
            if (pReq->StrmFltrResponseTime != 0 && (ULONGLONG)(pEvent->Header.TimeStamp.QuadPart) > pReq->StrmFltrResponseTime) {
                pReq->StrmFltrResponseTime = pEvent->Header.TimeStamp.QuadPart - pReq->StrmFltrResponseTime;
            }
            else {
                pReq->StrmFltrResponseTime = 0;
            }
        }
    } 
    else if (IsEqualGUID(&pEvent->Header.Guid, &IisSslHandShakeGuid)) {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISSSLHANDLESHAKE_START) {
            if (pReq->SSLResponseTime == 0) {
                pReq->SSLResponseTime = pEvent->Header.TimeStamp.QuadPart;
            }
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISSSLHANDLESHAKE_END) {
            if (pReq->SSLResponseTime != 0 && (ULONGLONG)(pEvent->Header.TimeStamp.QuadPart) > pReq->SSLResponseTime) {
                pReq->SSLResponseTime = pEvent->Header.TimeStamp.QuadPart - pReq->SSLResponseTime;
            }
            else {
                pReq->SSLResponseTime = 0;
            }
        }
    } 
    else if (IsEqualGUID(&pEvent->Header.Guid, &IisAspGuid) ||
             IsEqualGUID(&pEvent->Header.Guid, &IisAspNetGuid) ||
             IsEqualGUID(&pEvent->Header.Guid, &IisCustomIsapiGuid)) { 
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISASP_START) {
            pReq->ASPStartTime = pEvent->Header.TimeStamp.QuadPart;
        }
        else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IISASP_END) {
            pReq->ASPEndTime = pEvent->Header.TimeStamp.QuadPart;
            if (pReq->ULEndTime != 0 && pReq->W3EndTime != 0) {
                UpdateThreadIisData(pReq, pHeader, pThread);
                SumUpCPUTime(pReq);
                DeleteHttpReqRecord(pReq, TRUE);
                return;
            }
        }
    }
    // Finally, charge CPU time on on-going requests.
    UpdateThreadIisData(pReq, pHeader, pThread);

}

VOID
GeneralEventCallback(
    PEVENT_TRACE pEvent
    )
{
    PTHREAD_RECORD pThread = NULL;

    if ((pEvent == NULL) || (TraceContext == NULL)) {
        return;
    }

    CurrentSystem.LastEventTime = (ULONGLONG) pEvent->Header.TimeStamp.QuadPart;

    if (XPorHigher) {
        // If the ThreadId is -1 or the FieldTypeFlags in the event
        // shows there is no CPU Time, ignore the event. This can happen
        // when PERFINFO headers are found in kernel data. 
        // 
        // However, we exclude FileIo events from this because we need 
        // those events. Later on, we may exclude network events as well.
        if (!IsEqualGUID(&pEvent->Header.Guid, &FileIoGuid)) {

            if ( (pEvent->Header.ThreadId == -1) || 
                 (pEvent->Header.FieldTypeFlags & EVENT_TRACE_USE_NOCPUTIME) ) {
                if (TraceContext->Flags & (TRACE_DUMP|TRACE_SUMMARY)) {
                    DumpEvent(pEvent);
                }
                return;
            }
        }
    }

    if (IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid))
    {
        LogHeaderCallback(pEvent);
    }

    //
    // Notes: This code is here to fix up the Event Record for the 
    // Idle Threads. Since Idle threads are not guaranteed to have 
    // Cid initialized, we could end up with bogus thread Ids. 
    // 
    // Assumption: In DC_START records, the first process record must
    // be the idle process followed by idle threads. 
    // 

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START) {
        if (bCaptureBogusThreads) {
            //
            // Here we will convert the next N threads into idle threads
            // N = Number of Processors. 

            if (IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid)) {
                if (pEvent->Header.ThreadId != 0) {
                    PULONG Ptr;
                    BogusThreads[BogusCount++] = pEvent->Header.ThreadId;
                    pEvent->Header.ThreadId = 0;
                    //
                    // Assumption: The first two ULONGs are the
                    // ThreadId and ProcessId in this record. If that changes
                    // this will corrupt memory! 
                    //
                    Ptr = (PULONG)pEvent->MofData;
                    *Ptr = 0;
                    Ptr++;
                    *Ptr = 0; 
                }
            }
            //
            // Once all the idle threads are seen, no need to capture anymore
            //
            if (IdleThreadCount++ == NumProc) bCaptureBogusThreads = FALSE;
        }
    } else {
        //
        // This is the TimeConsuming Part. We need to do this only if 
        // we found bogus threads earlier. 
        // 
        if (BogusCount > 0) {
            ULONG i;
            for (i=0; i < BogusCount; i++) {
                if (pEvent->Header.ThreadId == BogusThreads[i]) {
                    pEvent->Header.ThreadId = 0;

                    //
                    // If DC_END records also fix up the Mof for Thread End
                    //

                    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END) {
                        PULONG Ptr;

                        Ptr = (PULONG)pEvent->MofData;
                        *Ptr = 0;
                        Ptr++;
                        *Ptr = 0;
                    }
                }
            }
        }
    }

    if (CurrentSystem.fNoEndTime
        && CurrentSystem.EndTime < (ULONGLONG) pEvent->Header.TimeStamp.QuadPart)
    {
        CurrentSystem.EndTime = pEvent->Header.TimeStamp.QuadPart;
        if (fDSOnly && CurrentSystem.EndTime > DSEndTime) {
            CurrentSystem.EndTime = DSEndTime;
        }
    }

    //
    // After the above code we should not see any threadId's over 64K
    //
/*
#if DBG
    if (pEvent->Header.ThreadId > 65536)
        DbgPrint("%d: Bad ThreadId %x Found\n", EventCount+1, 
                                                pEvent->Header.ThreadId);
#endif
*/

    //
    // Dump the event in csv file, if required. 
    //
    if (TraceContext->Flags & (TRACE_DUMP|TRACE_SUMMARY)) {
            DumpEvent(pEvent);
    }
    else {
        PMOF_INFO pMofInfo;
        PMOF_VERSION pMofVersion = NULL;
        pMofInfo = GetMofInfoHead( &pEvent->Header.Guid );
        if (pMofInfo == NULL){
             return;
        }
        pMofInfo->EventCount++;

        pMofVersion = GetMofVersion(pMofInfo,
                                pEvent->Header.Class.Type,
                                pEvent->Header.Class.Version,
                                pEvent->Header.Class.Level
                                );
    }

    if ( (TraceContext->Flags & TRACE_REDUCE) == 0 ) {
        return;
    }
    
    // 
    // TODO: This may prevent DiskIO write events and TCP receive events to 
    // get ignored 
    //


    if (pEvent->Header.ThreadId == 0) {
        if (   (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_START)
          && (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_DC_START)
           && (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_END)
           && (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_DC_END)
           )
        {
            EventCount++;
            return;
        }
    }

    if (!IsEqualGUID(&pEvent->Header.Guid, &FileIoGuid) &&
        !IsEqualGUID(&pEvent->Header.Guid, &TcpIpGuid) &&
        !IsEqualGUID(&pEvent->Header.Guid, &UdpIpGuid)) {
        // FileIo events and network events have Perf Header with ThreadId == -1
        // No need to add this bogus thread
        pThread = FindGlobalThreadById(pEvent->Header.ThreadId, pEvent);
    }

    EventCount ++;

    if (IsEqualGUID(&pEvent->Header.Guid, &ProcessGuid))
    {
        AdjustThreadTime(pEvent, pThread);
        ProcessCallback(pEvent);
    }
    else if (IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid))
    {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START) 
        {
            AdjustThreadTime(pEvent, pThread);
        }
        ThreadCallback(pEvent);
    }
    else if (pEvent->Header.ThreadId != 0)
    {
        if (!IsEqualGUID(&pEvent->Header.Guid, &FileIoGuid) &&
            !IsEqualGUID(&pEvent->Header.Guid, &TcpIpGuid) &&
            !IsEqualGUID(&pEvent->Header.Guid, &UdpIpGuid)) {
            AdjustThreadTime(pEvent, pThread);
        }

        if (IsEqualGUID(&pEvent->Header.Guid, &DiskIoGuid))
        {
            DiskIoCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &FileIoGuid))
        {
            // No need to do callbacks on file rundown events.
            if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_FILEIO_NAME) {
                HotFileCallback(pEvent);
            }
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &ImageLoadGuid))
        {
            ModuleLoadCallback(pEvent);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &TcpIpGuid))
        {
            TcpIpCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &UdpIpGuid))
        {
            TcpIpCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &PageFaultGuid))
        {
            PageFaultCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &EventTraceConfigGuid)) {
            //  
            // We only need Logical Disk events for now. 
            //
            if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_CONFIG_LOGICALDISK) {
                LogDriveCallback(pEvent);
            }
            else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_CONFIG_CPU) {
                CpuCallback(pEvent);
            }
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &UlGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &W3CoreGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &W3FilterGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &W3CgiGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &W3IsapiGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &IisStrmFilterGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &IisSslHandShakeGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &IisAspGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &IisAspNetGuid) ||
            IsEqualGUID(&pEvent->Header.Guid, &IisCustomIsapiGuid)) {
            if (IsEqualGUID(&pEvent->Header.Guid, &UlGuid)) {
                bIISEvents = TRUE;
            }
            if (bIISEvents) {
                IISEventCallback(pEvent);
            }
            //
            // Cannot use EventCallBack() to compute the response time becase
            // one transaction goes through different Start/Stop through different
            // events.
            //
        }
        else
        {
            //
            // This is a hack specific to Print Servers.
            // Need to come up with a general solution.  MKR.
            //

            if (IsEqualGUID(&pEvent->Header.Guid, &PrintJobGuid) ||
                IsEqualGUID(&pEvent->Header.Guid, &RenderedJobGuid)) {
                PrintJobCallback(pEvent);
            }

            EventCallback(pEvent, pThread);
        }
    }
}

ULONG ahextoi( WCHAR *s)
{
    int len;
    ULONG num, base, hex;

    len = lstrlenW(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

ULONG StringToNumber( LPWSTR sz )
{
    if( NULL == sz ){
        return 0;
    }

    if( wcsstr( sz, L"x" ) || wcsstr( sz, L"X" ) ){
        return ahextoi( sz );
    }else{
        return _wtol( sz );
    }
}

void AnsiToUnicode(PCHAR str, PWCHAR wstr)
{
    int len, i;
    PUCHAR AnsiChar;

    if (str == NULL || wstr == NULL)
        return;

    len = strlen(str);
    for (i=0; i<len; i++)
    {
        AnsiChar = (PUCHAR) &str[i];
        wstr[i] = (WCHAR) RtlAnsiCharToUnicodeChar(&AnsiChar);
    }
    wstr[len] = 0;
}

void
PrintMapValue( PVALUEMAP pValueMap, DWORD dwValue )
{

    //
    // Function assumes TraceContext->hDumpFile 
    // is open and valid
    // 

    BOOL bFirst = TRUE;
    BOOL bDone = FALSE;

    LONG HUGEP *pValueMapData;
    BSTR HUGEP *pValuesData;

    LONG uMapBound, lMapBound;
    LONG uValuesBound, lValuesBound;

    if( NULL != pValueMap->saValueMap ){
        SafeArrayGetUBound( pValueMap->saValueMap, 1, &uMapBound );
        SafeArrayGetLBound( pValueMap->saValueMap, 1, &lMapBound );
        SafeArrayAccessData( pValueMap->saValueMap, (void HUGEP **)&pValueMapData );
    }

    if( NULL != pValueMap->saValues ){
        SafeArrayGetUBound( pValueMap->saValues, 1, &uValuesBound );
        SafeArrayGetLBound( pValueMap->saValues, 1, &lValuesBound );
        SafeArrayAccessData( pValueMap->saValues, (void HUGEP **)&pValuesData );
    }

    if( NULL != pValueMap->saValues && NULL != pValueMap->saValueMap ){
        for ( LONG i=lMapBound; i<=uMapBound && !bDone; i++) {

            switch( pValueMap->dwValueType ){
            case VALUETYPE_INDEX:
                if( dwValue == pValueMapData[i] ){
                    fwprintf( TraceContext->hDumpFile, L"\"%ws\", ", pValuesData[i] );
                    bDone = TRUE;
                }
                break;
            case VALUETYPE_FLAG:
                if( (dwValue & pValueMapData[i]) == pValueMapData[i] ){
                    if( bFirst ){
                        fwprintf( TraceContext->hDumpFile, L"\"%ws", pValuesData[i] );
                        bFirst = FALSE;
                    }else{
                        fwprintf( TraceContext->hDumpFile, L"|%ws", pValuesData[i] );
                    }
                }
                break;
            }
        }
    }else if( NULL != pValueMap->saValues ){
        if( (LONG)dwValue >= lValuesBound && (LONG)dwValue <= uValuesBound ){
            fwprintf( TraceContext->hDumpFile, L"\"%ws\", ", pValuesData[dwValue] );
            bDone = TRUE;
        }
    }


    if( !bFirst && !bDone ){
        
        // 
        // Flags were found; need to end the quotes
        //
        
        fwprintf( TraceContext->hDumpFile, L"\", " );
    }

    if( bFirst && !bDone ){
        
        //
        // No values mapped; just print the DWORD
        //

        fwprintf( TraceContext->hDumpFile, L"%d, ", dwValue );
    }

    if( NULL != pValueMap->saValueMap ){
        SafeArrayUnaccessData( pValueMap->saValueMap );
    }
    if( NULL != pValueMap->saValues ){
        SafeArrayUnaccessData( pValueMap->saValues );
    }
}

#define PRINTVALUE( s, v ) \
    if( NULL == pItem->pValueMap ){ \
        fwprintf(DumpFile, s, v); \
    }else{ \
        PrintMapValue( pItem->pValueMap, (DWORD)v ); \
    }

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG   i;
    PITEM_DESC pItem;
    PCHAR str;
    PWCHAR wstr;
    PCHAR ptr;
    ULONG ulongword;
    LONG  longword;
    USHORT ushortword;
    SHORT  shortword;
    PMOF_INFO pMofInfo;
    PMOF_VERSION pMofVersion;
    PLIST_ENTRY Head, Next;
    char iChar;
    WCHAR iwChar;
    ULONG MofDataUsed;
    FILE* DumpFile = NULL;

    TotalEventCount++;

    if (pEvent == NULL) {
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    if (MofData == NULL) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (LPSTR)malloc(MofLength);
    }
    else if ((pEvent->MofLength + sizeof(UNICODE_NULL)) > MofLength) {
        free(MofData);
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (LPSTR)malloc(MofLength);
    }

    if (MofData == NULL) {
        return;
    }
    if ((pEvent->MofData == NULL) && (0 != pEvent->MofLength)) {
        return;
    }

    if (pEvent->MofData != NULL) {
        RtlCopyMemory(MofData, pEvent->MofData, pEvent->MofLength);
    }

    MofData[pEvent->MofLength] = 0;
    MofData[pEvent->MofLength+1] = 0;
    ptr = MofData;
    MofDataUsed = 0;

    pMofInfo = GetMofInfoHead(  &pEvent->Header.Guid );

    if (pMofInfo == NULL) {
        return;
    }
    pMofInfo->EventCount++;

    pMofVersion = GetMofVersion(pMofInfo, 
                                pEvent->Header.Class.Type,
                                pEvent->Header.Class.Version,
                                pEvent->Header.Class.Level
                            );

    if( NULL == pMofVersion ){
        return;
    }

    pMofVersion->EventCountByType++;

    if( !(TraceContext->Flags & TRACE_DUMP) ){
        return;
    }

    DumpFile = TraceContext->hDumpFile;
    str = (PCHAR)malloc(MOFSTR);
    if (str == NULL) {
        return;
    }
    wstr = (PWCHAR)malloc(MOFWSTR * sizeof(WCHAR));
    if (wstr == NULL) {
        free(str);
        return;
    }

    if( pMofInfo->strDescription != NULL ){
        fwprintf( DumpFile, L"%12s, ", pMofInfo->strDescription );
    }else{
        fwprintf( DumpFile, L"%12s, ", CpdiGuidToString( wstr, MOFWSTR, &pMofInfo->Guid ) );
    }

    if(pMofVersion->strType != NULL && wcslen(pMofVersion->strType) ){
        fwprintf( DumpFile, L"%10s, ", pMofVersion->strType );
    }else{
        fwprintf( DumpFile,   L"%10d, ", pEvent->Header.Class.Type );
    }

    if( TraceContext->Flags & TRACE_EXTENDED_FMT ){
        fwprintf( DumpFile, L"%8d,%8d,%8d, ", 
                pEvent->Header.Class.Type,
                pEvent->Header.Class.Level,
                pEvent->Header.Class.Version
            );
    }

    // Thread ID
     fwprintf( DumpFile,   L"0x%08X, ", pHeader->ThreadId );
    
    // System Time
     fwprintf( DumpFile,   L"%20I64u, ", pHeader->TimeStamp.QuadPart);

    if( g_bUserMode == FALSE ){
        // Kernel Time
         fwprintf(DumpFile,   L"%10lu, ", pHeader->KernelTime * TimerResolution);

        // User Time
         fwprintf(DumpFile,   L"%10lu, ", pHeader->UserTime * TimerResolution);
    }else{
        // processor Time
         fwprintf(DumpFile,   L"%I64u, ", pHeader->ProcessorTime);
    }

    Head = &pMofVersion->ItemHeader;
    Next = Head->Flink;

    if ((Head == Next) && (pEvent->MofLength > 0)) {
         fwprintf(DumpFile,   L"DataSize=%d, ", pEvent->MofLength);
    }

    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;

        MofDataUsed = (ULONG) (ptr - MofData);
        
        if (MofDataUsed >= pEvent->MofLength){
            break;
        }

        switch (pItem->ItemType)
        {
        case ItemChar:
        case ItemUChar:
            if( NULL == pItem->pValueMap ){
                fwprintf(DumpFile, L"\"" );
                for (i = 0; i < pItem->ArraySize; i++){
                    iChar = *((PCHAR) ptr);
                    if (iChar != '\0') {
                        fwprintf(DumpFile,   L"%c", iChar);
                    }
                    ptr += sizeof(CHAR);
                } 
                fwprintf(DumpFile, L"\", " );
            }else{
                iChar = *((PCHAR) ptr);
                PrintMapValue( pItem->pValueMap, (DWORD)iChar );
                ptr += sizeof(CHAR);
            }
            break;
        case ItemCharHidden:
            ptr += sizeof(CHAR) * pItem->ArraySize;
            break;
        case ItemWChar:
            if( NULL == pItem->pValueMap ){
                fwprintf(DumpFile, L"\"" );
                for(i = 0; i < pItem->ArraySize; i++){
                    iwChar = *((PWCHAR) ptr);
                    if (iwChar != '\0') {
                        fwprintf(DumpFile,   L"%wc", iwChar);
                    }
                    ptr += sizeof(WCHAR);
                }
                fwprintf(DumpFile, L"\", ");
            }else{
                iwChar = *((PWCHAR) ptr);
                PrintMapValue( pItem->pValueMap, (DWORD)iwChar );
                ptr += sizeof(WCHAR);
            }
            break;
        case ItemCharSign:
        {
            char sign[5];
            RtlCopyMemory(&sign[0], ptr, sizeof(CHAR) * 2);
            sign[2] = '\0';
            StringCchCopyA(str, MOFSTR, sign);
            MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
            fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            ptr += sizeof(CHAR) * 2;
            break;
        }

        case ItemCharShort:
            iChar = *((PCHAR) ptr);
            PRINTVALUE( L"%d, ", iChar );
            ptr += sizeof(CHAR);
            break;

        case ItemShort:
            RtlCopyMemory(&shortword, ptr, sizeof(SHORT));
            PRINTVALUE( L"%6d, ", shortword);
            ptr += sizeof (SHORT);
            break;

        case ItemUShort:
            RtlCopyMemory(&ushortword, ptr, sizeof(USHORT));
            PRINTVALUE( L"%6u, ", ushortword );
            ptr += sizeof (USHORT);
            break;

        case ItemLong:
            RtlCopyMemory(&longword, ptr, sizeof(LONG));
            PRINTVALUE( L"%8d, ", longword );
            ptr += sizeof (LONG);
            break;

        case ItemULong:
            RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));
            PRINTVALUE( L"%8lu, ", ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemULongX:
            RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));
            PRINTVALUE( L"0x%08X, ", ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemPtr :
        {
            unsigned __int64 pointer;
            if (PointerSize == 64) {
                RtlCopyMemory(&pointer, ptr, PointerSize / 8);
                fwprintf(DumpFile,   L"0x%08X, ", pointer);
                ptr += PointerSize / 8;
            }
            else {      // assumes 32 bit otherwise
                RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));
                fwprintf(DumpFile,   L"0x%08X, ", ulongword);
                ptr += sizeof(ULONG);
            }
            break;
        }
        case ItemSizeT :
        {
            unsigned __int64 pointer;
            if (PointerSize == 64) {
                RtlCopyMemory(&pointer, ptr, PointerSize / 8);
                fwprintf(DumpFile,   L"%16I64d, ", pointer);
                ptr += PointerSize / 8;
            }
            else {      // assumes 32 bit otherwise
                RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));
                fwprintf(DumpFile,   L"%8d, ", ulongword);
                ptr += sizeof(ULONG);
            }
            break;
        }

        case ItemIPAddr:
        {
            RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));

            // Convert it to readable form
            //
            fwprintf(DumpFile,    L"%03d.%03d.%03d.%03d, ",
                    (ulongword >>  0) & 0xff,
                    (ulongword >>  8) & 0xff,
                    (ulongword >> 16) & 0xff,
                    (ulongword >> 24) & 0xff);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemTDIAddr:
        {
            WCHAR ipAddrBuffer[MAX_ADDRESS_LENGTH];
            PWCHAR pszW = &ipAddrBuffer[0];
            PTDI_ADDRESS_IP pIPv4Address;
            PTDI_ADDRESS_IP6 pIPv6Address;

            RtlCopyMemory(&ushortword, ptr, sizeof(USHORT));
            ptr += sizeof (USHORT);

            pIPv4Address = ((PTDI_ADDRESS_IP) ptr);
            pIPv6Address = ((PTDI_ADDRESS_IP6) ptr);

            // Right now, we only recognize PV4 and PV6
            DecodeIpAddressW(
                ushortword, 
                &pIPv4Address->in_addr,
                &pIPv6Address->sin6_addr[0],
                pszW
                );

            // Convert it to readable form
            //
            fwprintf(DumpFile,    L"%ws, ", ipAddrBuffer);
            ptr = MofData + pEvent->MofLength;  // ItemTDIAddr can only be the last member
            break;
        }

        case ItemPort:
        {
            RtlCopyMemory(&ushortword, ptr, sizeof(USHORT));
            fwprintf(DumpFile,   L"%u, ", NTOHS(ushortword));
            ptr += sizeof (USHORT);
            break;
        }

        case ItemLongLong:
        {
            LONGLONG n64;
            RtlCopyMemory(&n64, ptr, sizeof(LONGLONG));
            ptr += sizeof(LONGLONG);
            fwprintf(DumpFile,   L"%16I64d, ", n64);
            break;
        }

        case ItemULongLong:
        {
            ULONGLONG n64;
            RtlCopyMemory(&n64, ptr, sizeof(ULONGLONG));
            ptr += sizeof(ULONGLONG);
            fwprintf(DumpFile,   L"%16I64u, ", n64);
            break;
        }

        case ItemString:
        case ItemRString:
        {
            USHORT pLen = (USHORT)strlen((CHAR*) ptr);

            if (pLen > 0)
            {
                StringCchCopyA(str, MOFSTR, ptr);
                if (pItem->ItemType == ItemRString)
                {
                    reduceA(str);
                }
                str[pLen] = '\0';
                for (i= pLen - 1; i > 0; i--) {
                    if (str[i] == 0xFF)
                    {
                        str[i] = 0;
                    }
                    else break;
                }
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += (pLen + 1);
            break;
        }
        case ItemRWString:
        case ItemWString:
        {
            USHORT  pLen = 0;

            if (*(WCHAR *) ptr)
            {
                if (pItem->ItemType == ItemRWString)
                {
                    reduceW((WCHAR *) ptr);
                }
                pLen = ((lstrlenW((WCHAR*)ptr) + 1) * sizeof(WCHAR));
                RtlCopyMemory(wstr, ptr, pLen);
                wstr[(pLen / sizeof(WCHAR))] = L'\0';

                for (i = (pLen/sizeof(WCHAR)) - 1; i > 0; i--)
                {
                    if (((USHORT) wstr[i] == (USHORT) 0xFFFF))
                    {
                        wstr[i] = (USHORT) 0;
                    }
                    else break;
                }

                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += pLen;

            break;
        }

        case ItemDSString:   // Counted String
        {
            USHORT pLen = (USHORT)(256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)));
            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed - 1)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed - 1);
            }
            if (pLen > 0)
            {
                StringCchCopyA(str, MOFSTR, ptr);
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                replaceNLW(wstr);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemPString:   // Counted String
        {
            USHORT pLen;
            RtlCopyMemory(&pLen, ptr, sizeof(USHORT));
            ptr += sizeof(USHORT);

            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFSTR * sizeof(CHAR)) {
                pLen = MOFSTR * sizeof(CHAR);
            }
            if (pLen > 0) {
                RtlCopyMemory(str, ptr, pLen);
                str[pLen] = '\0';
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemDSWString:  // DS Counted Wide Strings
        case ItemPWString:  // Counted Wide Strings
        {
            USHORT pLen;
            if (pItem->ItemType == ItemDSWString) {
                pLen = (USHORT)(256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)));
            }
            else {
                RtlCopyMemory(&pLen, ptr, sizeof(USHORT));
            }
            ptr += sizeof(USHORT);

            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFWSTR * sizeof(WCHAR)) {
                pLen = MOFWSTR * sizeof(WCHAR);
            }
            if (pLen > 0) {
                RtlCopyMemory(wstr, ptr, pLen);
                wstr[pLen / sizeof(WCHAR)] = L'\0';
                if (pItem->ItemType == ItemDSWString) {
                    replaceNLW(wstr);
                }
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemNWString:   // Non Null Terminated String
        {
           USHORT Size;

           Size = (USHORT)(pEvent->MofLength - (ULONG)(ptr - MofData));
           if( Size > MOFSTR )
           {
               Size = MOFSTR;
           }
           if (Size > 0)
           {
               RtlCopyMemory(wstr, ptr, Size);
               wstr[Size / sizeof(WCHAR)] = '\0';
               fwprintf(DumpFile,   L"\"%ws\", ", wstr);
           }
           ptr += Size;
           break;
        }

        case ItemMLString:  // Multi Line String
        {
            USHORT   pLen;
            char   * src, * dest;
            BOOL     inQ       = FALSE;
            BOOL     skip      = FALSE;
            UINT     lineCount = 0;

            ptr += sizeof(UCHAR) * 2;
            pLen = (USHORT)strlen(ptr);
            if (pLen > 0)
            {
                src = ptr;
                dest = str;
                while (* src != '\0'){
                    if (* src == '\n'){
                        if (!lineCount){
                            * dest++ = ' ';
                        }
                        lineCount++;
                    }else if (* src == '\"'){ 
                        if (inQ){
                            char   strCount[32];
                            char * cpy;

                            StringCchPrintfA(strCount, 32, "{%dx}", lineCount);
                            cpy = & strCount[0];
                            while (* cpy != '\0'){
                                * dest ++ = * cpy ++;
                            }
                        }
                        inQ = !inQ;
                    }else if (!skip){
                        *dest++ = *src;
                    }
                    skip = (lineCount > 1 && inQ);
                    src++;
                }
                *dest = '\0';
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += (pLen);
            break;
        }

        case ItemSid:
        {
            WCHAR        UserName[64];
            WCHAR        Domain[64];
            WCHAR        FullName[256];
            ULONG        asize = 0;
            ULONG        bsize = 0;
            ULONG        SidMarker;
            SID_NAME_USE Se;
            ULONG        nSidLength;

            RtlCopyMemory(&SidMarker, ptr, sizeof(ULONG));
            if (SidMarker == 0){
                ptr += 4;
                fwprintf(DumpFile,   L"0, ");
            }
            else
            {
                if (PointerSize == 64) {
                    ptr += 16;           // skip the TOKEN_USER structure
                }
                else {
                    ptr += 8;            // skip the TOKEN_USER structure
                }
                nSidLength = 8 + (4*ptr[1]);

                asize = 64;
                bsize = 64;
                if (LookupAccountSidW(
                                NULL,
                               (PSID) ptr,
                               (LPWSTR) & UserName[0],
                               & asize,
                               (LPWSTR) & Domain[0],
                               & bsize,
                               & Se))
                {
                    LPWSTR pFullName = &FullName[0];
                    StringCchPrintfW(pFullName, 256, L"\\\\%s\\%s", Domain, UserName);
                    asize = (ULONG)  lstrlenW(pFullName);
                    if (asize > 0){
                         fwprintf(DumpFile,   L"\"%s\", ", pFullName);
                    }
                }
                else
                {
                     fwprintf(DumpFile,   L"\"System\", " );
                }
                SetLastError( ERROR_SUCCESS );
                ptr += nSidLength;
            }
            break;
        }

        case ItemChar4:
            fwprintf(DumpFile,
                      L"%c%c%c%c, ",
                      *ptr, ptr[1], ptr[2], ptr[3]);
            ptr += 4 * sizeof(CHAR);
            break;

        case ItemGuid:
        {
            WCHAR s[MAXGUIDSTR];
            
            fwprintf(DumpFile, L"%s, ", CpdiGuidToString(&s[0], MAXGUIDSTR, (LPGUID)ptr));
            ptr += sizeof(GUID);
            break;
        }

        case ItemCPUTime:
        {
            RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));
            fwprintf(DumpFile, L"%8lu, ", ulongword * TimerResolution);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemOptArgs:
        {
            DWORD    dwOptArgs = * ((PLONG) ptr);
            DWORD    dwMofLen  = pEvent->MofLength + sizeof(UNICODE_NULL);
            DWORD    dwMofUsed = MofDataUsed + sizeof(DWORD);
            DWORD    dwType;
            LPWSTR   wszString;
            LPSTR    aszString;
            LONG     lValue32;
            LONGLONG lValue64;

            ptr += sizeof(LONG);
            for (i = 0; i < 8; i ++) {
                if (dwMofUsed > dwMofLen) {
                    break;
                }
                dwType = (dwOptArgs >> (i * 4)) & 0x0000000F;
                switch (dwType) {
                case 0: // LONG
                    dwMofUsed += sizeof(LONG);
                    if (dwMofUsed <= dwMofLen) {
                        RtlCopyMemory(&lValue32, ptr, sizeof(LONG));
                        ptr       += sizeof(LONG);
                        PRINTVALUE( L"%d,", lValue32);
                    }
                    break;

                case 1: // WSTR
                    wszString  = (LPWSTR) ptr;
                    dwMofUsed += sizeof(WCHAR) * (lstrlenW(wszString) + 1);
                    if (dwMofUsed <= dwMofLen) {
                        fwprintf(DumpFile, L"\"%ws\",", wszString);
                        ptr += sizeof(WCHAR) * (lstrlenW(wszString) + 1);
                    }
                    break;

                case 2: // STR
                    aszString  = (LPSTR) ptr;
                    dwMofUsed += sizeof(CHAR) * (lstrlenA(aszString) + 1);
                    if (dwMofUsed <= dwMofLen) {
                        MultiByteToWideChar(CP_ACP, 0, aszString, -1, wstr, MOFWSTR);
                        fwprintf(DumpFile,   L"\"%ws\", ", wstr);
                        ptr += sizeof(CHAR) * (lstrlenA(aszString) + 1);
                    }
                    break;

                case 3:  // LONG64
                    dwMofUsed += sizeof(LONGLONG);
                    if (dwMofUsed <= dwMofLen) {
                        RtlCopyMemory(&lValue64, ptr, sizeof(LONGLONG));
                        ptr       += sizeof(LONGLONG);
                        fwprintf(DumpFile, L"%I64d,", lValue64);
                    }
                    break;

                case 4: // LONGX
                    dwMofUsed += sizeof(LONG);
                    if (dwMofUsed <= dwMofLen) {
                        RtlCopyMemory(&lValue32, ptr, sizeof(LONG));
                        ptr       += sizeof(LONG);
                        fwprintf(DumpFile, L"0x%08X,", lValue32);
                    }
                    break;

                case 5: // LONGLONGX
                    dwMofUsed += sizeof(LONGLONG);
                    if (dwMofUsed <= dwMofLen) {
                        RtlCopyMemory(&lValue64, ptr, sizeof(LONGLONG));
                        ptr       += sizeof(LONGLONG);
                        fwprintf(DumpFile, L"0x%016I64X,", lValue64);
                    }
                    break;
                }
            }
            break;
        }

        case ItemVariant:
        {
            //
            // Variable Size. First ULONG gives the sizee and the rest is blob
            //
            RtlCopyMemory(&ulongword, ptr, sizeof(ULONG));
            ptr += sizeof(ULONG);

            fwprintf(DumpFile,   L"DataSize=%d, ", ulongword);

            // No need to dump the contents of the Blob itself. 

            ptr += ulongword; 
        
            break;
        }
        case ItemBool:
        {
            BOOL Flag;
            RtlCopyMemory(&Flag, ptr, sizeof(BOOL));
            fwprintf(DumpFile,   L"%5s, " , (Flag) ?   L"TRUE" :   L"FALSE" );
            ptr += sizeof(BOOL);
            break;
        }

        default:
            ptr += sizeof (int);
        }
    }

    //Instance ID, Parent Instance ID
     fwprintf(DumpFile,   L"%d, %d\n", pEvent->InstanceId, pEvent->ParentInstanceId );

     free(str);
     free(wstr);
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\cpdata.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cpdata.h 

Abstract:

    cp data internal data structures

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

#ifndef __CPDATA__
#define __CPDATA__

#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#pragma warning (disable:4306)
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning (default:4306)
#include <windows.h>
#include <shellapi.h>
#include <wmistr.h>
#include <wtypes.h>
#pragma warning (disable:4201)
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <wmium.h>
#include <ntwmi.h>
#include <wmiumkm.h>

#include <wmiguid.h>
#include <evntrace.h>
#include <strsafe.h>
#pragma warning (default:4201)
// For TDI address decoding
#include <ipexport.h>
#include <tdi.h>

#include "list.h"
#include "workload.h"

#define MAX_FILE_TABLE_SIZE     64      // Must match ntos\wmi\callout.c

#define MAX_TRANS_LEVEL         32

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif
#define THREAD_HASH_TABLESIZE   29
#define URL_HASH_TABLESIZE      32

#define MAXSTR 1024

#define CHECK_HR(hr)     if( ERROR_SUCCESS != hr ){ goto cleanup; }

#define EVENT_TRACE_TYPE_FILEIO_NAME            0x00
#define EVENT_TRACE_TYPE_FIELIO_CREATE          0x20

#define EVENT_TRACE_TYPE_SPL_SPOOLJOB    EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_SPL_PRINTJOB    EVENT_TRACE_TYPE_DEQUEUE
#define EVENT_TRACE_TYPE_SPL_DELETEJOB   EVENT_TRACE_TYPE_END
#define EVENT_TRACE_TYPE_SPL_TRACKTHREAD EVENT_TRACE_TYPE_CHECKPOINT
#define EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD 0x0A
#define EVENT_TRACE_TYPE_SPL_JOBRENDERED 0x0B
#define EVENT_TRACE_TYPE_SPL_PAUSE 0x0C
#define EVENT_TRACE_TYPE_SPL_RESUME 0x0D

#define EVENT_TRACE_TYPE_UL_START               EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_UL_PARSE               0x0A
#define EVENT_TRACE_TYPE_UL_DELIVER             0x0B
#define EVENT_TRACE_TYPE_UL_RECVRESP            0x0C
#define EVENT_TRACE_TYPE_UL_RECVBODY            0x0D
#define EVENT_TRACE_TYPE_UL_CACHEDEND           0x0E
#define EVENT_TRACE_TYPE_UL_CACHEANDSEND        0x0F
#define EVENT_TRACE_TYPE_UL_FASTRESP            0x10
#define EVENT_TRACE_TYPE_UL_FASTSEND            0x11
#define EVENT_TRACE_TYPE_UL_ZEROSEND            0x12
#define EVENT_TRACE_TYPE_UL_SENDERROR           0x13
#define EVENT_TRACE_TYPE_UL_END                 EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_W3CORE_START           EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_W3CORE_FILEREQ         0x0A
#define EVENT_TRACE_TYPE_W3CORE_CGIREQ          0x0B
#define EVENT_TRACE_TYPE_W3CORE_ISAPIREQ        0x0C
#define EVENT_TRACE_TYPE_W3CORE_OOPREQ          0x0D
#define EVENT_TRACE_TYPE_W3CORE_SENDBODY        0x10
#define EVENT_TRACE_TYPE_W3CORE_SENDRESP        0x11
#define EVENT_TRACE_TYPE_W3CORE_SENDENTITY      0x12
#define EVENT_TRACE_TYPE_W3CORE_SENDFILTER      0x13
#define EVENT_TRACE_TYPE_W3CORE_ERRSEND         0x14
#define EVENT_TRACE_TYPE_W3CORE_ERRSENDENT      0x15
#define EVENT_TRACE_TYPE_W3CORE_ERRSENDCTX      0x16
#define EVENT_TRACE_TYPE_W3CORE_ERRVECSEND      0x17
#define EVENT_TRACE_TYPE_W3CORE_VECTORSEND      0x18
#define EVENT_TRACE_TYPE_W3CORE_END             EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_W3FILTER_START         EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_W3FILTER_END           EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_W3CGI_START            EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_W3CGI_END              EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_W3ISAPI_START          EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_W3ISAPI_SENDHDR        0x0A
#define EVENT_TRACE_TYPE_W3ISAPI_SENDHDREX      0x0B
#define EVENT_TRACE_TYPE_W3ISAPI_VECTORSEND     0x0C
#define EVENT_TRACE_TYPE_W3ISAPI_ERRORSEND      0x0D
#define EVENT_TRACE_TYPE_W3ISAPI_SSFSEND        0x0E
#define EVENT_TRACE_TYPE_W3ISAPI_SSDERROR       0x0F
#define EVENT_TRACE_TYPE_W3ISAPI_END            EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_IISSTRMFILTER_START    EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_IISSTRMFILTER_END      EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_IISSSLHANDLESHAKE_START EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_IISSSLHANDLESHAKE_END  EVENT_TRACE_TYPE_END

#define EVENT_TRACE_TYPE_IISASP_START           EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_IISASP_END             EVENT_TRACE_TYPE_END

#define ISAPI_EXTENTION_ASP                     0
#define ISAPI_EXTENTION_ASP_NET                 1
#define ISAPI_EXTENTION_CUSTOM                  2

#define MAX_ADDRESS_LENGTH  \
    sizeof("[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967295]:65535")

typedef struct _TRACE_CONTEXT_BLOCK {
    PEVENT_TRACE_PROPERTIES LoggerInfo;
    ULONG     LogFileCount;
    ULONG     LoggerCount;
    LPWSTR    LogFileName[MAXLOGGERS];
    LPWSTR    LoggerName[MAXLOGGERS];
    LPCSTR    PdhFileName;  // ANSI ??
    LPWSTR    ProcFileName;
    LPWSTR    DumpFileName;
    LPWSTR    MofFileName;
    LPWSTR    XSLDocName;
    LPWSTR    DefMofFileName;
    LPWSTR    MergeFileName;
    LPWSTR    SummaryFileName;
    LPWSTR    CompFileName;
    HANDLE    hEvent;
    FILE*     hDumpFile;
    ULONGLONG StartTime;    // If Sequential, start, End Times to window. 
    ULONGLONG EndTime;      //  
    ULONG     Flags;
    BOOLEAN   LoggerStartedHere;
    void    (*StatusFunction)(int, double);
    HANDLE    hThreadVector;
    TRACEHANDLE HandleArray[MAXLOGGERS];
    PVOID       pUserContext;
} TRACE_CONTEXT_BLOCK, *PTRACE_CONTEXT_BLOCK;

typedef struct _HPF_FILE_RECORD
{
    LIST_ENTRY Entry;
    ULONG      RecordID;
    ULONG      IrpFlags;
    ULONG      DiskNumber;
    ULONG      BytesCount;
    ULONGLONG  ByteOffset;
    PVOID      fDO;
} HPF_FILE_RECORD, *PHPF_FILE_RECORD;

typedef struct _HPF_RECORD
{
    LIST_ENTRY     Entry;
    ULONG          RecordID;
    ULONG          lProgramCounter;
    ULONG          lFaultAddress;
    PVOID          fDO;
    LONG           lByteCount;
    LONGLONG       lByteOffset;
    LIST_ENTRY     HPFReadListHead;
} HPF_RECORD, *PHPF_RECORD;

typedef struct _TDISK_RECORD
{
    LIST_ENTRY Entry;
    ULONG   DiskNumber;
    LPWSTR  DiskName;
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   HPF;
    ULONG   HPFSize; 
    LIST_ENTRY  FileListHead;
    LIST_ENTRY  ProcessListHead;
} TDISK_RECORD, *PTDISK_RECORD; 

typedef struct _FILE_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY ProtoProcessListHead; // List of Processes touching this file. 
    PWCHAR  Drive;
    PWCHAR  FileName;
    ULONG   DiskNumber;
    ULONG   ReadCount;
    ULONG   HPF;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   HPFSize;
} FILE_RECORD, *PFILE_RECORD;

typedef struct _FILE_OBJECT 
{
    PVOID        fDO;
    PFILE_RECORD fileRec;
    ULONG        ThreadId;
    ULONG        DiskNumber;
    ULONGLONG    LastByteOffset;
    LIST_ENTRY   ProtoFileRecordListHead;
}FILE_OBJECT, *PFILE_OBJECT;

typedef struct _PROTO_FILE_RECORD
{
    LIST_ENTRY Entry;
    BOOLEAN    ReadFlag;
    ULONG      DiskNumber;
    ULONG      IoSize;
} PROTO_FILE_RECORD, *PPROTO_FILE_RECORD;

typedef struct _TRANS_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY SubTransListHead;
    LPGUID pGuid;
    BOOL    bStarted;
    ULONG   UCpu;
    ULONG   KCpu;
    ULONG   DeltaReadIO;
    ULONG   DeltaWriteIO;
    ULONG   RefCount;
    ULONG   RefCount1;
} TRANS_RECORD, *PTRANS_RECORD;

typedef struct _PROCESS_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY ThreadListHead;
    LIST_ENTRY DiskListHead;
    LIST_ENTRY FileListHead;    // All the Files this process touched. 
    LIST_ENTRY ModuleListHead;  // All the modules this process loaded.
    LIST_ENTRY HPFListHead;
    PWCHAR UserName;
    PWCHAR ImageName;
    ULONG PID;
    ULONG DeadFlag;
    ULONG ReadIO;
    ULONG WriteIO;
    ULONG SendCount;
    ULONG RecvCount;
    ULONG SendSize;
    ULONG RecvSize;
    ULONG HPF;
    ULONG HPFSize;
    ULONG SPF;
    ULONG PrivateWSet;
    ULONG GlobalWSet;
    ULONG ReadIOSize;
    ULONG WriteIOSize;
    ULONG lDataFaultHF;
    ULONG lDataFaultTF;
    ULONG lDataFaultDZF;
    ULONG lDataFaultCOW;
    ULONG lCodeFaultHF;
    ULONG lCodeFaultTF;
    ULONG lCodeFaultDZF;
    ULONG lCodeFaultCOW;
    ULONGLONG ResponseTime;
    ULONGLONG TxnStartTime;
    ULONGLONG TxnEndTime;
} PROCESS_RECORD, *PPROCESS_RECORD;

typedef struct _THREAD_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY DiskListHead;
    LIST_ENTRY TransListHead; // transactions list
    LIST_ENTRY HPFReadListHead;
    LIST_ENTRY HPFWriteListHead;
    WCHAR      strSortKey[MAXSTR];
    ULONG      TID;
    PPROCESS_RECORD pProcess;
    BOOLEAN         fOrphan;
    ULONG DeadFlag;
    ULONG ProcessorID;
    ULONG ClassNumber;    // Class to which this thread is assigned.
    ULONG ReadIO;
    ULONG WriteIO;
    ULONG SendCount;
    ULONG RecvCount;
    ULONG SendSize;
    ULONG RecvSize;
    ULONG HPF;
    ULONG SPF;
    ULONG ReadIOSize;
    ULONG WriteIOSize;
    ULONG HPFSize;

    ULONGLONG TimeStart;
    ULONGLONG TimeEnd;
    ULONG KCPUStart;
    ULONG KCPUEnd;
    ULONG UCPUStart;
    ULONG UCPUEnd;

    // The Following fields are used in getting the Delta  
    // CPU, I/O to charge on a transaction basis. 
    // The Current Transaction being executed by this thread is 
    // given by pMofInfo and when the trans is completed the Delta CPU, I/O
    // are charged to that transaction. 

    ULONG   DeltaReadIO;
    ULONG   DeltaWriteIO;
    ULONG   DeltaSend;
    ULONG   DeltaRecv;
    ULONG   RefCount;
    ULONG   JobId;    // Keeps track of the Current Job this thread is working on
    PVOID   pMofData; // Keep Track of the  Current transaction Guid

    ULONG   KCPU_Trans;
    ULONG   UCPU_Trans;
    ULONG   KCPU_NoTrans;
    ULONG   UCPU_NoTrans;
    ULONG   KCPU_PrevTrans;
    ULONG   UCPU_PrevTrans;
    LONG    TransLevel;

    ULONG     KCPU_PrevEvent;
    ULONG     UCPU_PrevEvent;
    ULONGLONG Time_PrevEvent;

    PTRANS_RECORD TransStack[MAX_TRANS_LEVEL];
    // for IIS event
    ULONGLONG IisReqId;

}THREAD_RECORD, *PTHREAD_RECORD;

typedef struct _MODULE_RECORD MODULE_RECORD, *PMODULE_RECORD;
struct _MODULE_RECORD
{
    LIST_ENTRY      Entry;
    PPROCESS_RECORD pProcess;
    ULONG           lBaseAddress;
    ULONG           lModuleSize;
    ULONG           lDataFaultHF;
    ULONG           lDataFaultTF;
    ULONG           lDataFaultDZF;
    ULONG           lDataFaultCOW;
    ULONG           lCodeFaultHF;
    ULONG           lCodeFaultTF;
    ULONG           lCodeFaultDZF;
    ULONG           lCodeFaultCOW;
    WCHAR         * strModuleName;
    PMODULE_RECORD  pGlobalPtr;
};

typedef struct _SYSTEM_RECORD {
    ULONGLONG   StartTime;
    ULONGLONG   EndTime;
    ULONGLONG   LastEventTime;
    ULONGLONG   IISStartTime;
    ULONGLONG   IISEndTime;
    FILE*       TempPrintFile;
    FILE*       TempIisFile;
    BOOLEAN     fNoEndTime;
    ULONG       CurrentThread0;
    ULONG       ElapseTime;
    ULONG       TimerResolution;
    ULONG       NumberOfEvents;
    ULONG       NumberOfProcessors;
    ULONG       CpuSpeed;
    ULONG       MemorySize;
    PWCHAR      ComputerName;
    ULONG       NumberOfWorkloads;
    ULONG       BuildNumber;
    PFILE_OBJECT *FileTable;
    PLIST_ENTRY ThreadHashList;
    LIST_ENTRY  ProcessListHead;
    LIST_ENTRY  GlobalThreadListHead;
    LIST_ENTRY  GlobalDiskListHead;
    LIST_ENTRY  HotFileListHead;
    LIST_ENTRY  WorkloadListHead;
    LIST_ENTRY  InstanceListHead;
    LIST_ENTRY  EventListHead;
    LIST_ENTRY  GlobalModuleListHead;  // Global module list.
    LIST_ENTRY  ProcessFileListHead;
    LIST_ENTRY  PrintJobListHead;
    LIST_ENTRY  HttpReqListHead;
    LIST_ENTRY  PendingHttpReqListHead;
    PLIST_ENTRY  URLHashList;
    LIST_ENTRY  ClientListHead;
    LIST_ENTRY  SiteListHead;
    LIST_ENTRY  LogicalDriveHead;
    // memory recyling list
    // For Trans and Job, we will recycle the allocated structures.
    // URLs do not nned to be recycled because they are allocated together 
    // at the report time and freed all at the same time. However, we'll
    // just keep them just in case.
    LIST_ENTRY  FreePrintJobListHead;
    LIST_ENTRY  FreeHttpReqListHead;
    LIST_ENTRY  FreeTransListHead;
    LIST_ENTRY  FreeURLListHead;

    HANDLE      hLoggerUpEvent;
} SYSTEM_RECORD, *PSYSTEM_RECORD;

typedef struct _PROCESS_FILE_RECORD {
    LIST_ENTRY  Entry;
    ULONGLONG   StartTime;
    ULONGLONG   EndTime;
    LPWSTR      FileName;
    LPWSTR      TraceName;
} PROCESS_FILE_RECORD, *PPROCESS_FILE_RECORD;

typedef struct _PROTO_PROCESS_RECORD
{
    LIST_ENTRY Entry;
    PPROCESS_RECORD ProcessRecord;
    ULONG ReadCount;
    ULONG WriteCount;
    ULONG HPF;
    ULONG ReadSize;
    ULONG WriteSize;
    ULONG HPFSize;
} PROTO_PROCESS_RECORD, *PPROTO_PROCESS_RECORD;

typedef struct _LOGICAL_DRIVE_RECORD
{
    LIST_ENTRY  Entry;
    ULONGLONG   StartOffset;
    ULONGLONG   PartitionSize;
    ULONG       DiskNumber;
    ULONG       Size;
    ULONG       DriveType;
    PWCHAR      DriveLetterString;
} LOGICAL_DRIVE_RECORD, *PLOGICAL_DRIVE_RECORD;

//
// MOF_INFO  structure maintains the global information for the GUID. 
// For each GUID, the event layouts are maintained by Version, Level and Type. 
// 

typedef struct _MOF_INFO {
    LIST_ENTRY   Entry;
    LIST_ENTRY   DataListHead;
    LPWSTR       strDescription;        // Class Name
    LPWSTR       strSortField;
    ULONG        EventCount;    
    GUID         Guid;
    LIST_ENTRY   VersionHeader;
    BOOL         bKernelEvent;
}  MOF_INFO, *PMOF_INFO;


//
// MOF_VERSION structure ic created one per Version, Level Type combination. 
//

typedef struct _MOF_VERSION {
    LIST_ENTRY Entry;
    LIST_ENTRY ItemHeader;     // Maintains the list of ITEM_DESC for this type. 
    LPWSTR  strType;
    SHORT   Version;
    SHORT   TypeIndex;
    CHAR    Level;
    ULONG   EventCountByType;    // Count of Events by this type for this Guid
} MOF_VERSION, *PMOF_VERSION;


typedef struct _MOF_DATA {
    LIST_ENTRY   Entry;
    PWCHAR       strSortKey;
    ULONG        CompleteCount;
    LONG         InProgressCount;
    LONGLONG     AverageResponseTime;
    LONGLONG     TotalResponseTime;
    ULONGLONG    PrevClockTime;
    ULONG        MmTf;
    ULONG        MmDzf;
    ULONG        MmCow;
    ULONG        MmGpf;
    ULONG        UserCPU;
    ULONG        KernelCPU;
    ULONG        EventCount;
    ULONG        ReadCount;
    ULONG        WriteCount;
    ULONG        SendCount;
    ULONG        RecvCount;
    LONG         MinKCpu;
    LONG         MaxKCpu;
    LONG         MinUCpu;
    LONG         MaxUCpu;
} MOF_DATA, *PMOF_DATA;

// A Job record is one that passses through several threads to complete.
// Jobs are identified by a Job Id, usually created during the Start
// event and recorded as an additional field in the mof data.
// Since there can be any number of jobs in the system over the data
// collection interval, we will flush the completed jobs to a temp file
// and reread it back at the end to print a report.
//  Note: Job_record needs to be Guid based. (ie., per type of transaction).
// Currently it is not.
//

#define MAX_THREADS 10  // Upto threads can be working on a Job.

typedef struct _THREAD_DATA {
    ULONG ThreadId;
    ULONG PrevKCPUTime;
    ULONG PrevUCPUTime;
    ULONG PrevReadIO;
    ULONG PrevWriteIO;
    ULONG KCPUTime;
    ULONG UCPUTime;
    ULONG ReadIO;
    ULONG WriteIO;
    ULONG Reserved;
} THREAD_DATA, *PTHREAD_DATA;

typedef struct _PRINT_JOB_RECORD {
    LIST_ENTRY  Entry;
    ULONG       JobId;
    ULONG       KCPUTime;
    ULONG       UCPUTime;
    ULONG       ReadIO;
    ULONG       WriteIO;
    ULONG       DataType;
    ULONG       JobSize;
    ULONG       Pages;
    ULONG       PagesPerSide;
    ULONG       ICMMethod;
    ULONG       GdiJobSize;
    ULONGLONG   StartTime;
    ULONGLONG   EndTime;
    ULONGLONG   ResponseTime;
    ULONGLONG   PauseTime;
    ULONGLONG   PauseStartTime;
    ULONGLONG   PrintJobTime;
    SHORT       FilesOpened;
    SHORT       Color;
    SHORT       XRes;
    SHORT       YRes;
    SHORT       Quality;
    SHORT       Copies;
    SHORT       TTOption;
    ULONG       NumberOfThreads; // Total Number of Threads worked on this Job
    THREAD_DATA ThreadData[MAX_THREADS];
} PRINT_JOB_RECORD, *PPRINT_JOB_RECORD;

// URL records for IIS events
typedef struct _URL_RECORD {
    LIST_ENTRY  Entry;
    ULONG       SiteId;
    ULONG       KCPUTime;
    ULONG       UCPUTime;
    ULONG       ReadIO;
    ULONG       WriteIO;
    ULONG       Hits;
    ULONG       Requests;
    ULONG       UrlType;
    ULONG       BytesSent;
    ULONGLONG   TotalResponseTime;
    PCHAR       URL;
} URL_RECORD, *PURL_RECORD;

// Site records for IIS events
typedef struct _SITE_RECORD {
    LIST_ENTRY  Entry;
    ULONG       SiteId;
    ULONG       KCPUTime;
    ULONG       UCPUTime;
    ULONG       ReadIO;
    ULONG       WriteIO;
    ULONG       Hits;
    ULONG       Requests;
    ULONG       BytesSent;
    ULONGLONG   TotalResponseTime;
    ULONG       FileRequests;
    ULONG       CGIRequests;
    ULONG       ISAPIRequests;
    ULONG       OOPRequests;
    ULONG       ASPRequests;
} SITE_RECORD, *PSITE_RECORD;

// Client records for IIS events
typedef struct _CLIENT_RECORD {
    LIST_ENTRY  Entry;
    ULONG       Hits;
    ULONG       Requests;
    ULONG       BytesSent;
    ULONGLONG   TotalResponseTime;
    USHORT      IpAddrType;
    ULONG       IpAddrV4;
    USHORT      IpAddrV6[8];
} CLIENT_RECORD, *PCLIENT_RECORD;

// This is IIS Request Record for IIS events
typedef struct _HTTP_REQUEST_RECORD {
    LIST_ENTRY  Entry;
    ULONGLONG   RequestId;
    ULONGLONG   ConId;
    ULONG       SiteId;
    ULONG       BytesSent;
    ULONG       KCPUTime;
    ULONG       UCPUTime;
    ULONG       ULCPUTime;
    ULONG       W3CPUTime;
    ULONG       W3FltrCPUTime;
    ULONG       ISAPICPUTime;
    ULONG       ASPCPUTime;
    ULONG       CGICPUTime;
    ULONG       ReadIO;
    ULONG       WriteIO;
    ULONGLONG   ULStartTime;
    ULONGLONG   ULEndTime;
    ULONGLONG   ULResponseTime;
    ULONGLONG   ULParseTime;
    ULONGLONG   ULDeliverTime;
    ULONGLONG   ULReceiveTime;
    SHORT       ULReceiveType;
    SHORT       ULEndType;
    ULONGLONG   W3StartTime;
    ULONGLONG   W3EndTime;
    ULONGLONG   W3FilterResponseTime;
    ULONGLONG   W3FilterStartTime;
    ULONGLONG   W3FilterEndTime;
    ULONG       W3FilterVisits;
    SHORT       W3ProcessType;
    SHORT       W3EndType;
    ULONGLONG   FileReqTime;
    ULONGLONG   CGIStartTime;
    ULONGLONG   CGIEndTime;
    ULONGLONG   ISAPIStartTime;
    ULONGLONG   ISAPIEndTime;
    SHORT       ISAPIEndType;
    ULONGLONG   ASPStartTime;
    ULONGLONG   ASPEndTime;
    ULONGLONG   SSLResponseTime;
    ULONGLONG   StrmFltrResponseTime;
    USHORT      HttpStatus;
    USHORT      IsapiExt;
    ULONG       NumberOfThreads; // Total Number of Threads worked on this reqeust
    ULONG       CurrentThreadIndex;
    THREAD_DATA ThreadData[MAX_THREADS];
    USHORT      IpAddrType;
    ULONG       IpAddrV4;
    USHORT      IpAddrV6[8];
    PCHAR       URL;
    PURL_RECORD URLRecord;
    PCLIENT_RECORD ClientRecord;
} HTTP_REQUEST_RECORD, *PHTTP_REQUEST_RECORD;

typedef struct _IIS_REPORT_RECORD {
    ULONG TotalRequests;
    ULONG CachedResponses;
    ULONGLONG TotalCachedResponseTime;
    ULONGLONG TotalNonCachedResponseTime;
    ULONG W3FileRequests;
    ULONG W3CGIRequests; 
    ULONG W3ISAPIRequests;
    ULONG W3ASPRequests;
    ULONG W3OOPRequests;
    ULONG W3FilterRequests;
    ULONG W3Error;
    ULONGLONG TotalW3FilterResponseTime;
    ULONG TotalW3FilterCPUTime;

    ULONG TotalFileULOnlyCPUTime;
    ULONG TotalFileW3OnlyCPUTime;
    ULONG TotalFileW3FilterCPUTime;
    ULONGLONG TotalFileResponseTime;
    ULONGLONG TotalFileULOnlyResponseTime;
    ULONGLONG TotalFileW3OnlyResponseTime;
    ULONGLONG TotalFileW3FilterResponseTime;

    ULONG TotalCGIOnlyCPUTime;
    ULONG TotalCGIULOnlyCPUTime;
    ULONG TotalCGIW3OnlyCPUTime;
    ULONG TotalCGIW3FilterCPUTime;
    ULONGLONG TotalCGIResponseTime;
    ULONGLONG TotalCGIOnlyResponseTime;
    ULONGLONG TotalCGIULOnlyResponseTime;
    ULONGLONG TotalCGIW3OnlyResponseTime;
    ULONGLONG TotalCGIW3FilterResponseTime;

    ULONG TotalASPOnlyCPUTime;
    ULONG TotalASPULOnlyCPUTime;
    ULONG TotalASPW3OnlyCPUTime;
    ULONG TotalASPISAPIOnlyCPUTime;
    ULONG TotalASPW3FilterCPUTime;
    ULONGLONG TotalISAPIResponseTime;
    ULONGLONG TotalASPResponseTime;
    ULONGLONG TotalASPOnlyResponseTime;
    ULONGLONG TotalASPULOnlyResponseTime;
    ULONGLONG TotalASPW3OnlyResponseTime;
    ULONGLONG TotalASPISAPIOnlyResponseTime;
    ULONGLONG TotalASPW3FilterResponseTime;

    ULONG TotalErrorULOnlyCPUTime;
    ULONG TotalErrorW3OnlyCPUTime;
    ULONG TotalErrorW3FilterCPUTime;
    ULONG TotalErrorCGIOnlyCPUTime;
    ULONG TotalErrorISAPIOnlyCPUTime;
    ULONG TotalErrorASPOnlyCPUTime;
    ULONGLONG TotalErrorResponseTime;
    ULONGLONG TotalErrorULOnlyResponseTime;
    ULONGLONG TotalErrorW3OnlyResponseTime;
    ULONGLONG TotalErrorW3FilterResponseTime;

    ULONGLONG TotalOOPResponseTime;

    ULONG TotalCPUTime;
    ULONG CachedCPUTime;
    ULONG NonCachedCPUTime;
    ULONG FileCPUTime;
    ULONG CGICPUTime;
    ULONG ISAPICPUTime; 
    ULONG ASPCPUTime;
    ULONG ErrorCPUTime;
    ULONG OOPCPUTime;
} IIS_REPORT_RECORD, *PIIS_REPORT_RECORD;
//
// Global that  holds everything about the current session
//
extern SYSTEM_RECORD CurrentSystem;
extern BOOLEAN       fDSOnly;
extern ULONGLONG     DSStartTime;
extern ULONGLONG     DSEndTime;

extern RTL_CRITICAL_SECTION TLCritSect;
#define EnterTracelibCritSection() RtlEnterCriticalSection(&TLCritSect)
#define LeaveTracelibCritSection() RtlLeaveCriticalSection(&TLCritSect)

//
// Initialization Routines. 
//

VOID 
InitDiskRecord(
    PTDISK_RECORD pDisk,
    ULONG DiskNumber
    );

VOID 
InitMofData(
    PMOF_DATA pMofData
    );

VOID 
InitThreadRecord(
    PTHREAD_RECORD pThread
    );

VOID 
InitProcessRecord(
    PPROCESS_RECORD pProcess
    );

VOID 
InitFileRecord(
    PFILE_RECORD pFile
    );

//
// Add, Delete and Find routines

PTRANS_RECORD
CreateTransRecord();

BOOLEAN
AddModuleRecord(
    PMODULE_RECORD * pModule,
    ULONG            lBaseAddress,
    ULONG            lModuleSize,
    WCHAR          * strModuleName
    );

BOOLEAN
AddHPFFileRecord(
    PHPF_FILE_RECORD * ppHPFFileRecord,
    ULONG              RecordID,
    ULONG              IrpFlags,
    ULONG              DiskNumber,
    ULONGLONG          ByteOffset,
    ULONG              BytesCount,
    PVOID              fDO
    );

BOOLEAN
AddHPFRecord(
    PHPF_RECORD * ppHPFRRecord,
    ULONG         lFaultAddress,
    PVOID         fDO,
    LONG          ByteCount,
    LONGLONG      ByteOffset
    );

void
DeleteHPFRecord(
    PHPF_RECORD pHPFRecord
    );

BOOLEAN 
AddProcess( 
    ULONG ProcessId, 
    PPROCESS_RECORD *Process 
    );

BOOLEAN
DeleteTrans(
    PTRANS_RECORD Trans
    );

BOOLEAN
DeleteTransList(
    PLIST_ENTRY Head,
    ULONG level
    );

PTRANS_RECORD
FindTransByList(
    PLIST_ENTRY Head,
    LPGUID pGuid,
    ULONG  level
    );

PMOF_DATA
FindMofData(
    PMOF_INFO pMofInfo,
    PWCHAR    strSortKey
    );

BOOLEAN 
DeleteProcess( 
    PPROCESS_RECORD Process 
    );

BOOLEAN 
AddThread( 
    ULONG            ThreadId,
    PEVENT_TRACE     pEvent,
    PTHREAD_RECORD * Thread
    );

BOOLEAN 
DeleteThread( 
    PTHREAD_RECORD Thread 
    );

BOOLEAN 
AddFile( 
    WCHAR* fileName, 
    PFILE_RECORD  *ReturnedFile,
    PLOGICAL_DRIVE_RECORD pLogDrive
    );

BOOLEAN 
DeleteFileRecord( 
    PFILE_RECORD fileRec 
    );

BOOLEAN 
DeleteFileObject( 
    PFILE_OBJECT fileObj 
    );

PLOGICAL_DRIVE_RECORD 
FindLogicalDrive(
    ULONGLONG AccessedOffset,
    ULONG DiskNumber
    );

VOID
AddLogicalDrive(
    ULONGLONG StartOffset,
    ULONGLONG PartitionSize,
    ULONG DiskNumber,
    ULONG Size,
    ULONG DriveType,
    PWCHAR DriveLetterString
    );

PPROCESS_RECORD 
FindProcessById( 
    ULONG    Id,
    BOOLEAN CheckAlive 
    );

PTDISK_RECORD
FindLocalDiskById(
    PLIST_ENTRY Head,
    ULONG DiskNumber
    );
PTDISK_RECORD
FindProcessDiskById(
    PPROCESS_RECORD pProcess,
    ULONG DiskNumber
    );

PFILE_RECORD 
FindFileInProcess( 
    PPROCESS_RECORD pProcess,
    WCHAR* Name 
    );

PPROTO_PROCESS_RECORD
FindProtoProcessRecord(
    PFILE_RECORD pFile,
    PPROCESS_RECORD pProcess
    );

PFILE_RECORD 
FindFileRecordByName( 
    WCHAR* Name, 
    PLOGICAL_DRIVE_RECORD pLogDrive
    );

PTHREAD_RECORD 
FindGlobalThreadById( 
    ULONG         ThreadId,
    PEVENT_TRACE  pEvent
    );

PTDISK_RECORD 
FindGlobalDiskById( 
    ULONG Id 
    );

PPROCESS_RECORD 
FindDiskProcessById(
    PTDISK_RECORD Disk,
    ULONG    Id
    );

ULONGLONG CalculateProcessLifeTime(PPROCESS_RECORD pProcess);
ULONG CalculateProcessKCPU(PPROCESS_RECORD pProcess);
ULONG CalculateProcessUCPU(PPROCESS_RECORD pProcess);

VOID 
Cleanup();

BOOLEAN 
AddDisk( 
    ULONG DiskNumber, 
    PTDISK_RECORD *ReturnedDisk 
    );

BOOLEAN
DeleteDisk(
    PTDISK_RECORD Disk
    );

ULONG
DeletePrintJobRecord(
    PPRINT_JOB_RECORD pJob,
    ULONG             bSave
    );

PPRINT_JOB_RECORD
AddPrintJobRecord(
    ULONG JobId
    );

PPRINT_JOB_RECORD
FindPrintJobRecord(
    ULONG JobId
    );

ULONG
DeleteHttpReqRecord(
    PHTTP_REQUEST_RECORD pReq,
    ULONG                bSave
    );

PHTTP_REQUEST_RECORD
AddHttpReqRecord(
    ULONGLONG RequestId,
    USHORT    IpAddrType,
    ULONG     IpAddrV4,
    USHORT    *IpAddrV6
    );

PHTTP_REQUEST_RECORD
FindHttpReqRecord(
    ULONGLONG RequestId
    );

PHTTP_REQUEST_RECORD 
FindHttpReqRecordByConId(
    ULONGLONG ConId,
    PHTTP_REQUEST_RECORD pPrevReq
    );

PHTTP_REQUEST_RECORD
FindPendingHttpReqRecord(
    ULONGLONG RequestId
    );

PURL_RECORD
AddUrlRecord(
    PUCHAR URL
    );

PURL_RECORD
FindUrlRecord(
    PUCHAR URL
    );

PURL_RECORD
FindOrAddUrlRecord(
    PUCHAR URL
    );

PURL_RECORD
GetHeadUrlRecord(
     ULONG index
     );

ULONG
DeleteUrlRecord(
    PURL_RECORD pUrl
    );

PCLIENT_RECORD
AddClientRecord(
    USHORT IpAddrType,
    ULONG IpAddrV4,
    USHORT *IpAddrV6
    );

PCLIENT_RECORD 
FindClientRecord(
    USHORT IpAddrType,
    ULONG IpAddrV4,
    USHORT *IpAddrV6
    );

PCLIENT_RECORD
FindOrAddClientRecord(
    USHORT IpAddrType,
    ULONG IpAddrV4,
    USHORT *IpAddrV6
    );

PCLIENT_RECORD
GetHeadClientRecord();

ULONG
DeleteClientRecord(
    PCLIENT_RECORD pClient
    );

PSITE_RECORD
AddSiteRecord(
    ULONG SiteId
    );

PSITE_RECORD 
FindSiteRecord(
    ULONG SiteId
    );

PSITE_RECORD
FindOrAddSiteRecord(
    ULONG SiteId
    );

PSITE_RECORD
GetHeadSiteRecord();

ULONG
DeleteSiteRecord(
    PSITE_RECORD pSite
    );

int EtwRelogEtl(
    PTRACE_CONTEXT_BLOCK TraceContext,
    PULONG pMergedEventsLost
    );

// 
// Trace Event Callbacks
//
VOID
ShutdownThreads(); // Shuts down the running threads before finishing
VOID
ShutdownProcesses(); // Shuts down the running processes before finishing

ULONG
GetMofData(
    PEVENT_TRACE pEvent,
    WCHAR *strName,
    PVOID ReturnValue,
    ULONG ReturnLength
    );

VOID GeneralEventCallback(PEVENT_TRACE pEvent);
VOID DeclareKernelEvents();

VOID 
ProcessCallback(
    PEVENT_TRACE pEvent
    );
VOID 
PsStartCallback(
    PEVENT_TRACE pEvent
    );
VOID 
PsEndCallback(
    PEVENT_TRACE pEvent
    );
VOID
ThreadCallback(
    PEVENT_TRACE pEvent
    );
VOID 
ThStartCallback(
    PEVENT_TRACE pEvent
    );
VOID 
ThEndCallback(
    PEVENT_TRACE pEvent
    );
VOID
DiskIoCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );
VOID 
IoReadCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
   );
VOID 
IoWriteCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );
VOID 
HotFileCallback(
    PEVENT_TRACE pEvent
    );
VOID 
LogDriveCallback(
    PEVENT_TRACE pEvent
    );
VOID 
LogHeaderCallback(
    PEVENT_TRACE pEvent
    );
VOID 
EventCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );

VOID AddEvent(
        IN PFILE_OBJECT fileObject,
        IN ULONG DiskNumber,
        IN ULONG IoSize,
        IN BOOLEAN ReadFlag);

PFILE_OBJECT FindFileInTable (
                IN PVOID fDO
                );


//VOID
//ProcessPdh(
//    IN LPCSTR LogFileName,
//    IN ULONGLONG StartTime,
//    IN ULONGLONG EndTime
//    );

//
// Workload Classification Routines
//

VOID
Classify();

VOID
InitClass();

VOID
AssignClass(
    IN PPROCESS_RECORD pProcess,
    IN PTHREAD_RECORD pThread
    );

PMOF_INFO
GetMofInfoHead(
    LPCGUID  pGuid
    );

void
WriteSummary();

#define IsNotEmpty( string )  ((BOOL)( (NULL != string) && ( L'\0' != string[0]) ))

#endif  // __CPDATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\guids.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    guids.h

Abstract:

    guids header file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

// PrintJobsGuid needs to be removed once spoooler changes are checked in
//

GUID PrintJobGuid =
    {0x127eb555, 0x3b06, 0x46ea, 0xa0, 0x8b, 0x5d, 0xc2, 0xc3, 0xc5, 0x7c, 0xfd};

GUID RenderedJobGuid =
    {0x1d32b239, 0x92a6, 0x485a, 0x96, 0xd2, 0xdc, 0x36, 0x59, 0xfb, 0x80, 0x3e};

GUID UlGuid =
    {0x3c419e3d, 0x1d18, 0x415b, 0xa9, 0x1a, 0x9b, 0x55, 0x89, 0x38, 0xde, 0x4b};

GUID W3CoreGuid =
    {0xd42cf7ef, 0xde92, 0x473e, 0x8b, 0x6c, 0x62, 0x1e, 0xa6, 0x63, 0x11, 0x3a};

GUID W3FilterGuid =
    {0x00237f0d, 0x73eb, 0x4bcf, 0xa2, 0x32, 0x12, 0x66, 0x93, 0x59, 0x58, 0x47};

GUID W3CgiGuid =
    {0xe2e55403, 0x0d2e, 0x4609, 0xa4, 0x70, 0xbe, 0x0d, 0xa0, 0x40, 0x13, 0xc0};

GUID W3IsapiGuid =
    {0x2e94e6c7, 0xeda0, 0x4b73, 0x90, 0x10, 0x25, 0x29, 0xed, 0xce, 0x1c, 0x27};

GUID IisStrmFilterGuid =
    {0x0ecf983b, 0x7115, 0x4b77, 0xa5, 0x43, 0x95, 0xd1, 0x38, 0xee, 0x44, 0x00};

GUID IisSslHandShakeGuid =
    {0xd353dc2d, 0x3e55, 0x4b88, 0xa4, 0xac, 0x18, 0x3c, 0x36, 0x83, 0x62, 0xa3};

GUID IisAspGuid =
    {0x1fc299fa, 0x3fc4, 0x4c37, 0x91, 0x0d, 0xde, 0x5b, 0x91, 0x1d, 0x02, 0x70};

GUID IisAspNetGuid =
    {0x06a01367, 0x79d3, 0x4594, 0x8e, 0xb3, 0xc7, 0x21, 0x60, 0x3c, 0x46, 0x79};

// GUID for user developed custom ISAPI extention
// 71bda656-663c-4eae-977a-a749f1fa0fcd 
GUID IisCustomIsapiGuid =
    {0x71bda656, 0x663c, 0x4eae, 0x97, 0x7a, 0xa7, 0x49, 0xf1, 0xfa, 0x0f, 0xcd};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\report.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    report.c

Abstract:

    Manipulation routines for cpdata structures.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:
    Corey Morgan (coreym) 04-June-2002
    
      Reformatted report output to XML.

--*/

#include <stdlib.h>
#include <stdio.h>
#include "cpdata.h"
#include "tracectr.h"
#include <ntverp.h>
#include "item.h"

#define MODULE_STRING_SIZE      256
#define FILE_NAME_COLUMN_SIZE   80
#define URL_NAME_COLUMN_SIZE    79
#define MAX_GUID_STRING_SIZE    64

#define DISPLAY_SIZE 10

extern PTRACE_CONTEXT_BLOCK TraceContext;
extern ULONG TotalEventsLost;
extern ULONG TotalEventCount;
extern ULONG TimerResolution;
extern __int64 ElapseTime;
extern ULONG TotalBuffersRead;

extern BOOLEAN XPorHigher;

extern FARPROC EtwpIpv4ToStringA;
extern FARPROC EtwpIpv4ToStringW;
extern FARPROC EtwpIpv6ToStringA;
extern FARPROC EtwpIpv6ToStringW;

static FILE* procFile;
static void  PrintDiskTotals();
static void PrintProcessCpuTime();
static void PrintProcessData();
static void PrintPerThreadPerDiskTable();
static void WriteTransactionStatistics();
static void WriteTransactionCPUTime();
static void PrintProcessSubDataInclusive();
static void PrintProcessSubDataExclusive();
void TransInclusive( 
    PLIST_ENTRY TrHead,
    ULONG level
    );

static void ReportHotFileInfo();
static void ReportPrintJobInfo();

PIIS_REPORT_RECORD IIS = NULL;
ULONG RequestsDiscarded = 0;
ULONG SendErrorRequests = 0;
void ProcessIisRequest(HTTP_REQUEST_RECORD *pReq);
static void ReportIisEvents();

extern GUID PrintJobGuid;
extern GUID UlGuid;

#ifdef DBG
BOOLEAN TracectrDbgEnabled = FALSE;
#endif

PWCHAR CpdiGuidToString(
    PWCHAR s,
    ULONG len,
    LPGUID piid
    );

PCHAR RemoveCtrlCharA(
    PCHAR String,
    ULONG NumChars
    );

PCHAR ReduceStringA(
    PCHAR OutString,
    ULONG NumChars,
    PCHAR LongString
    );

PWCHAR ReduceStringW(
    PWCHAR OutString,
    ULONG NumChars,
    PWCHAR LongString
    );

ULONG ReportFlags = 0;

void DecodeIpAddressA(
    USHORT AddrType, 
    PULONG IpAddrV4,
    PUSHORT IpAddrV6,
    PCHAR pszA
    )
{
    if (AddrType == TDI_ADDRESS_TYPE_IP) {
        if (XPorHigher && EtwpIpv4ToStringA != NULL) {
            struct in_addr IPv4Addr
                = * (struct in_addr UNALIGNED*) IpAddrV4;

            pszA = (PCHAR)(*EtwpIpv4ToStringA)(&IPv4Addr, pszA);
            *pszA = '\0';
        }
        else {
            StringCchCopyA(pszA, MAX_ADDRESS_LENGTH, "Undecodable IP Address");
        }
    }
    else if (AddrType == TDI_ADDRESS_TYPE_IP6) {
        if (XPorHigher && EtwpIpv6ToStringA != NULL) {
            struct in6_addr IPv6Addr
                = * (struct in6_addr UNALIGNED*) IpAddrV6;

            pszA = (PCHAR)(*EtwpIpv6ToStringA)(&IPv6Addr, pszA);
            *pszA = '\0';
        }
        else {
            StringCchCopyA(pszA, MAX_ADDRESS_LENGTH, "Undecodable IP Address");
        }
    }
    else {
        StringCchCopyA(pszA, MAX_ADDRESS_LENGTH, "Unknown IP Address Type");
    }
}

void DecodeIpAddressW(
    USHORT AddrType, 
    PULONG IpAddrV4,
    PUSHORT IpAddrV6,
    PWCHAR pszW
    )
{
    if (AddrType == TDI_ADDRESS_TYPE_IP) {
        if (XPorHigher && EtwpIpv4ToStringW != NULL) {
            struct in_addr IPv4Addr
                = * (struct in_addr UNALIGNED*) IpAddrV4;

            pszW = (PWCHAR)(*EtwpIpv4ToStringW)(&IPv4Addr, pszW);
            *pszW = L'\0';
        }
        else {
            StringCchCopyW(pszW, MAX_ADDRESS_LENGTH, L"Undecodable IP Address");
        }
    }
    else if (AddrType == TDI_ADDRESS_TYPE_IP6) {
        if (XPorHigher && EtwpIpv6ToStringW != NULL) {
            struct in6_addr IPv6Addr
                = * (struct in6_addr UNALIGNED*) IpAddrV6;

            pszW = (PWCHAR)(*EtwpIpv6ToStringW)(&IPv6Addr, pszW);
            *pszW = L'\0';
        }
        else {
            StringCchCopyW(pszW, MAX_ADDRESS_LENGTH, L"Undecodable IP Address");
        }
    }
    else {
        StringCchCopyW(pszW, MAX_ADDRESS_LENGTH, L"Unknown IP Address Type");
    }
}

// URLs may contain non-printable characters. This routine removes them.
PCHAR RemoveCtrlCharA(
    PCHAR String,
    ULONG NumChars
    )
{
    ULONG i;
    for (i = 0 ; i <= NumChars && String[i] != '\0'; i++) {
        if ( isprint(String[i]) == 0 || 
             String[i] == '\t' ||
             String[i] == '\b' ||
             String[i] == '\n' ||
             String[i] == '\'' ||
             String[i] == '\"') {
             
            String[i] = '?';
        }
    }

    return String;
}

PCHAR ReduceStringA(
    PCHAR OutString,
    ULONG NumChars,
    PCHAR LongString
    )
{
    ULONG Size;
    ULONG i;

    if (LongString == NULL) {
        return NULL;
    }
    // We assume here that LongString is not junk.
    Size = strlen(LongString);

    if (OutString == NULL) {
        return NULL;
    }
    RtlZeroMemory(OutString, NumChars);
    // This function is only useful when the length of LongString exceeds NumChars.
    // However, it still works when the length of LongString is smaller than NumChars.
    if (Size <= (NumChars - 1)) {
        StringCchCopyA(OutString, NumChars, LongString);
        return OutString;
    }

    i = Size - 1;
    while (LongString[i] != '\\' && LongString[i] != '/' && i > 0) {
        i--;
    }
    if (i == 0) { // there's no /s or \s. Just truncate.
        StringCchCopyA(OutString, NumChars, LongString);
        return OutString;
    }
    else {
        if ((Size - i) >= NumChars - 3) { // only name exceeds given chars.
            StringCchPrintfA(OutString, NumChars, "..%s", &LongString[1]);
            return OutString;
        }
        else {
            ULONG SpareChars = (NumChars - 3) - (Size - i);
            StringCchCopyA(OutString, SpareChars + 1, LongString);
            StringCchCatA(OutString, NumChars + 1, "..");
            StringCchCatA(OutString, NumChars + 1, &LongString[i]);
            return OutString;
        }
    }
}

PWCHAR ReduceStringW(
    PWCHAR OutString,
    ULONG NumChars,
    PWCHAR LongString
    )
{
    ULONG Size;
    ULONG i;

    if (LongString == NULL) {
        return NULL;
    }
    // We assume here that LongString is not junk.
    Size = wcslen(LongString);

    if (OutString == NULL) {
        return NULL;
    }
    RtlZeroMemory(OutString, NumChars * sizeof(WCHAR));
    // This function is only useful when the length of LongString exceeds NumChars.
    // However, it still works when the length of LongString is smaller than NumChars.
    if (Size <= (NumChars - 1)) {
        StringCchCopyW(OutString, NumChars, LongString);
        return OutString;
    }

    i = Size - 1;
    while (LongString[i] != L'\\' && LongString[i] != L'/' && i > 0) {
        i--;
    }
    if (i == 0) { // there's no /s or \s. Just truncate.
        StringCchCopyW(OutString, NumChars, LongString);
        return OutString;
    }
    else {
        if ((Size - i) >= NumChars - 3) { // only name exceeds given chars.
            StringCchPrintfW(OutString, NumChars, L"..%ws", &LongString[1]);
            return OutString;
        }
        else {
            ULONG SpareChars = (NumChars - 3) - (Size - i);
            StringCchCopyW(OutString, SpareChars + 1, LongString);
            StringCchCatW(OutString, NumChars + 1, L"..");
            StringCchCatW(OutString, NumChars + 1, &LongString[i]);
            return OutString;
        }
    }
}

void CollapseTree(
    PLIST_ENTRY OldTree,
    PLIST_ENTRY NewTree,
    BOOL flat
    )
{
    PLIST_ENTRY OldNext;
    PTRANS_RECORD pTrans;
    PTRANS_RECORD pNewTrans;

    OldNext = OldTree->Flink;

    while (OldNext != OldTree)
    {
        pTrans = CONTAINING_RECORD(OldNext, TRANS_RECORD, Entry);
        OldNext = OldNext->Flink;
        pNewTrans = FindTransByList(NewTree, pTrans->pGuid, 0);
        if( NULL != pNewTrans ){
            pNewTrans->KCpu += pTrans->KCpu;
            pNewTrans->UCpu += pTrans->UCpu;
            pNewTrans->RefCount += pTrans->RefCount;
            pNewTrans->RefCount1 += pTrans->RefCount1;

            if (flat)
            {
                CollapseTree(&pTrans->SubTransListHead, NewTree, TRUE );
            }
            else
            {
                CollapseTree(& pTrans->SubTransListHead,
                             & pNewTrans->SubTransListHead,
                             FALSE);
            }
        }
    }
}

#define BARLEN          70

char*
TimeWindowBar(
    char* buffer,
    ULONGLONG min,
    ULONGLONG max
    )
{
    double unit;
    ULONGLONG duration;
    int pre, bar, count, index;

    if(buffer == NULL){
        return NULL;
    }
    duration = ((CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000);
    unit = (double)BARLEN/(ULONG)duration;
    pre = (int)((ULONG)((min - CurrentSystem.StartTime)/10000000) * unit);
    bar = (int)((ULONG)((max - min)/10000000) * unit);
    buffer[0] = '\0';
    count = 0;
    index = 0;
    while(count < pre) { 
        buffer[index] = ' ';
        index++;
        count++;
    }
    buffer[index] = '|';
    index++;
    count = 0;
    while(count < bar) { 
        buffer[index] = '_'; 
        index++;
        count++;
    }
    buffer[index] = '|';
    buffer[index + 1] = '\0';
    return buffer;
}

char*
GetDateString( char* buffer, size_t cchBuffer, ULONGLONG llTime )
{
    FILETIME   ft, lft;
    SYSTEMTIME st;
    LARGE_INTEGER LargeTmp;
    BOOL bResult;
    HRESULT hr;
    WCHAR wDate[128];
    CHAR aDate[128];

    LargeTmp.QuadPart = llTime;
    ft.dwHighDateTime = LargeTmp.HighPart;
    ft.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&ft, &lft);

    bResult = FileTimeToSystemTime (
        &lft,
        &st
        );

    if( ! bResult || st.wMonth > 12 ){
        buffer[0] = '\0';
    }else{

        GetDateFormatW( 
            LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, wDate, 128 );

        WideCharToMultiByte( 
            CP_UTF8, 0, wDate, wcslen(wDate)+1, aDate, 128, NULL, NULL );

        hr = StringCchCopyA( buffer, cchBuffer, aDate );
        hr = StringCchCatA( buffer, cchBuffer, " " );

        GetTimeFormatW( 
            LOCALE_USER_DEFAULT, 0, &st, NULL, wDate, 128 );

        WideCharToMultiByte( 
            CP_UTF8, 0, wDate, wcslen(wDate)+1, aDate, 128, NULL, NULL );

        hr = StringCchCatA( buffer, cchBuffer, aDate );
    }

    return buffer;
}

void 
WriteProc(
    LPWSTR ProcFileName,
    ULONG  flags,
    PVOID  pUserContext
    )
{
    ULONGLONG duration;
    PLIST_ENTRY Next, Head;
    PPROCESS_FILE_RECORD pFileRec;
    char buffer[MAXSTR];
    BOOL bResult;

    ReportFlags = flags;

    procFile = _wfopen(ProcFileName, L"w");
    if (procFile == NULL)
        return;

    fprintf( procFile, "<?xml version=\"1.0\" encoding='UTF-8'?>\n" );

    if( !(TraceContext->Flags & TRACE_TRANSFORM_XML ) && TraceContext->XSLDocName != NULL ){
        fprintf( procFile, "<?xml-stylesheet type=\"text/xsl\" href=\"%ws\"?>\n", TraceContext->XSLDocName ); 
    }
  
    fprintf( procFile, "<report>\n<header>\n" );

    fprintf( procFile, "<version>%d</version>\n", VER_PRODUCTBUILD );
    
    fprintf( procFile, "<type>%s</type>\n", ( ReportFlags & TRACE_TOTALS_REPORT ) ? "Total" : "Default" );
    fprintf( procFile, "<build>%d</build>\n",CurrentSystem.BuildNumber );
    fprintf( procFile, "<processors>%d</processors>\n", CurrentSystem.NumberOfProcessors );

    if (CurrentSystem.CpuSpeed > 0) {
        fprintf(procFile,
                "<cpu_speed units='MHz'>%d</cpu_speed>\n",
                CurrentSystem.CpuSpeed
                );
    } else {
        fprintf(procFile,  "<cpu_speed/>\n"  );
    }
    if (CurrentSystem.MemorySize > 0) {
        fprintf(procFile,
                "<memory units='Mb'>%d</memory>\n",
                CurrentSystem.MemorySize
                );
    } else {
        fprintf(procFile,  "<memory/>\n"  );
    }

    if (CurrentSystem.ComputerName != NULL) {
        fprintf(procFile,
                "<computer_name>%ws</computer_name>\n",
                CurrentSystem.ComputerName
                );
    } else {
        fprintf(procFile, "<computer_name/>\n" );
    }

    fprintf( procFile, "<start>%s</start>\n", 
        GetDateString( buffer, MAXSTR, CurrentSystem.StartTime ) );

    fprintf( procFile, "<end>%s</end>\n", 
        GetDateString( buffer, MAXSTR, CurrentSystem.EndTime)  );

    duration = (CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000;
    fprintf( procFile, "<duration>%I64u</duration>\n",duration );

    Head = &CurrentSystem.ProcessFileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pFileRec = CONTAINING_RECORD( Next, PROCESS_FILE_RECORD, Entry );
        Next = Next->Flink;

        fprintf( procFile, "<trace name=\"%ws\">\n", pFileRec->TraceName ? pFileRec->TraceName : L"-" );
        fprintf( procFile, "<file>%ws</file>\n", pFileRec->FileName ? pFileRec->FileName : L"-" );

        if (pFileRec->StartTime == 0){
            pFileRec->StartTime = CurrentSystem.StartTime;
        }
        if (pFileRec->EndTime == 0){
            pFileRec->EndTime = CurrentSystem.EndTime;
        }

        fprintf( procFile, "<start>%s</start>\n", 
            GetDateString( buffer, MAXSTR, pFileRec->StartTime ) );
         
        duration = (pFileRec->EndTime - pFileRec->StartTime) / 10000000;
        fprintf( procFile, 
                "<end>%s</end>\n"
                "<duration>%I64u</duration>\n",
                GetDateString( buffer, MAXSTR, pFileRec->EndTime ),
                duration );
        fprintf( procFile,
                "<duration_window xml:space='preserve'>%s</duration_window>\n",
                TimeWindowBar(buffer, pFileRec->StartTime, pFileRec->EndTime) );
        
        fprintf( procFile, "</trace>\n" );

    }

    fprintf( procFile, "</header>\n" );

    if (flags & (TRACE_BASIC_REPORT|TRACE_TOTALS_REPORT)){
        PMOF_INFO pMofInfo;
        WriteTransactionStatistics();
        WriteTransactionCPUTime();

        pMofInfo = GetMofInfoHead ((LPCGUID)&PrintJobGuid);
        if ( pMofInfo != NULL ){
            if (pMofInfo->EventCount > 0) {
                ReportPrintJobInfo();
           }
        }

        pMofInfo = GetMofInfoHead ((LPCGUID)&UlGuid);
        if ( pMofInfo != NULL ){
            if (pMofInfo->EventCount > 0) {
                ReportIisEvents();
           }
        }

        // PrintProcessData() must be run before others to set the process
        // time from the added thread times
        PrintProcessData(); 

        PrintProcessSubDataExclusive();
        PrintProcessSubDataInclusive();
        
        /*
        PrintProcessCpuTime();
        */

        PrintDiskTotals();
        PrintPerThreadPerDiskTable();

        pMofInfo = GetMofInfoHead ((LPCGUID)&FileIoGuid);
        if ( pMofInfo != NULL ) {
            pMofInfo = GetMofInfoHead ((LPCGUID)&DiskIoGuid);
            if ( pMofInfo != NULL ) {
                ReportHotFileInfo();
            }
        }
    }

    fprintf( procFile, "</report>\n" );
    
    fclose(procFile);
}

static void 
PrintDiskTotals()
{
    // Print the Disk Table. 

    PTDISK_RECORD pDisk;
    PLIST_ENTRY Next, Head;
    ULONG rio, wio;

    ULONGLONG Duration = (ULONGLONG)((CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000);

    if (Duration == 0) {
        return;
    }

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    if( Next == Head ){
        return; 
    }

    fprintf(procFile, "<table title='Disk Totals'>\n" );

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    
    while (Next != Head) {
        pDisk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        rio = pDisk->ReadCount + pDisk->HPF;
        wio = pDisk->WriteCount;

        fprintf( procFile, "<disk number=\"%d\">\n", pDisk->DiskNumber );
        fprintf( procFile, "<read_rate>%1.3f</read_rate>\n", (double)rio / ((double)Duration) );
        fprintf( procFile, "<read_size>%d</read_size>\n", (rio == 0) ? 0 : (pDisk->ReadSize + pDisk->HPFSize) / rio );
        fprintf( procFile, "<write_rate>%1.3f</write_rate>\n", (double)wio / ((double)Duration));
        fprintf( procFile, "<write_size>%d</write_size>\n", (wio == 0) ? 0 : pDisk->WriteSize / wio );
        fprintf( procFile, "</disk>\n" );

        Next = Next->Flink;
    }

    fprintf(procFile, "</table>\n" );
}

void TotalTransChildren( 
    PLIST_ENTRY Head,
    ULONG *Kernel,
    ULONG *User,
    LONG level )
{
    PTRANS_RECORD pTrans;
    PLIST_ENTRY Next;
    
    Next = Head->Flink;
    while( Next != Head ){
        pTrans = CONTAINING_RECORD( Next, TRANS_RECORD, Entry );
        Next = Next->Flink;
        TotalTransChildren( &pTrans->SubTransListHead, Kernel, User, level+1 );
        *Kernel += pTrans->KCpu;
        *User += pTrans->UCpu;
    }
}

void PrintTransList( PLIST_ENTRY TrHead, LONG level )
{
    PTRANS_RECORD pTrans;
    PMOF_INFO pMofInfo;
    ULONG Kernel;
    ULONG User;
    WCHAR str[MAXSTR];
    WCHAR buffer[MAXSTR];
    PLIST_ENTRY TrNext = TrHead->Flink;
    
    while( TrNext != TrHead ){
        int count = 0;
        pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
        TrNext = TrNext->Flink;
        Kernel = pTrans->KCpu;
        User = pTrans->UCpu;
        pMofInfo = GetMofInfoHead( pTrans->pGuid);
        if (pMofInfo == NULL) {
            return;
        }

        
        StringCchCopyW ( buffer, 
                            MAXSTR,
                            ( pMofInfo->strDescription ? 
                              pMofInfo->strDescription : 
                              CpdiGuidToString( str, MAXSTR, &pMofInfo->Guid ) ));

        TotalTransChildren( &pTrans->SubTransListHead, &Kernel, &User, 0 );

        fprintf( procFile, "<transaction name=\"%ws\">\n", buffer );
        fprintf( procFile, "<count>%d</count>\n", pTrans->RefCount );
        fprintf( procFile, "<kernel>%d</kernel>\n", Kernel );
        fprintf( procFile, "<user>%d</user>\n", User );
        fprintf( procFile, "\n<transaction>\n" );

        if( level <= MAX_TRANS_LEVEL ){
            PrintTransList( &pTrans->SubTransListHead, level+1 );
        }
    }
}

static void PrintProcessCpuTime()
{
    PTHREAD_RECORD  pThread;
    PPROCESS_RECORD pProcess; 
    ULONGLONG     lLifeTime;
    ULONG TotalUserTime = 0;
    ULONG TotalKernelTime = 0;
    ULONG TotalCPUTime = 0;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY ThNext, ThHead;
    BOOL titled;
    ULONG usedThreadCount;
    ULONG ThreadCount;
    ULONG ProcessUTime;
    ULONG ProcessKTime;
    ULONG ThreadKCPU;
    ULONG ThreadUCPU;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    if( Head == Next ){
        return;
    }

    fprintf( procFile, "<table title='Process/Thread CPU Time Statistics'>\n" );

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
    
        lLifeTime = CalculateProcessLifeTime(pProcess);

        fprintf(procFile, 
                "<process name=\"%ws\">"
                "<pid>0x%04X</pid>"
                "<kernel>%d</kernel>"
                "<user>%d</user>"
                "<read>%d</read>"
                "<read_size>%1.2f</read_size>"
                "<write>%d</write>"
                "<write_size>%1.2f</write_size>"
                "<send>%d</send>"
                "<send_size>%1.2f</send_size>"
                "<recv>%5d</recv>"
                "<recv_size>%.2f</recv_size>"
                "<duation>%I64u</duation>\n",
                (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                pProcess->PID,
                CalculateProcessKCPU(pProcess),
                CalculateProcessUCPU(pProcess),
                pProcess->ReadIO + pProcess->HPF,
                (pProcess->ReadIO + pProcess->HPF) ?
                (double)(pProcess->ReadIOSize + pProcess->HPFSize)/
                (double)(pProcess->ReadIO + pProcess->HPF) : 0,
                pProcess->WriteIO,
                pProcess->WriteIO ? (double)pProcess->WriteIOSize/(double)pProcess->WriteIO : 0,
                pProcess->SendCount,
                pProcess->SendCount ? 
                (double)(pProcess->SendSize / 1024)/(double)pProcess->SendCount : 0,
                pProcess->RecvCount,
                pProcess->RecvCount ?
                (double)(pProcess->RecvSize / 1024) / (double)pProcess->RecvCount : 0,
                (lLifeTime / 10000000 )
                );

        ThHead = &pProcess->ThreadListHead; 
        ThNext = ThHead->Flink;
        titled = FALSE;
        usedThreadCount = 0;
        ThreadCount = 0;
        ProcessUTime = 0;
        ProcessKTime = 0;
        while (ThNext != ThHead) {
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThreadKCPU = (pThread->KCPUEnd - pThread->KCPUStart)
                       * CurrentSystem.TimerResolution;
            ThreadUCPU = (pThread->UCPUEnd - pThread->UCPUStart)
                       * CurrentSystem.TimerResolution;
            if(   pThread->ReadIO
               || pThread->WriteIO
               || ThreadKCPU
               || ThreadUCPU
               || pThread->SendCount
               || pThread->RecvCount
               || pThread->HPF ){

                fprintf(procFile, 
                        "<thread>"
                        "<tid>0x%04I64X</tid>"
                        "<kernel>%d</kernel>"
                        "<user>%d</user>"
                        "<read>%d</read>"
                        "<read_size>%1.2f</read_size>"
                        "<write>%d</write>"
                        "<write_size>%1.2f</write_size>"
                        "<send>%d</send>"
                        "<send_size>%1.2f</send_size>"
                        "<recv>%d</recv>"
                        "<recv_size>%1.2f</recv_size>"
                        "<duration>%I64u</duration>"
                        "</thread>\n",
                        pThread->TID,
                        ThreadKCPU,
                        ThreadUCPU,
                        pThread->ReadIO + pThread->HPF,
                        pThread->ReadIO + pThread->HPF ? 
                        (double)(pThread->ReadIOSize + pThread->HPFSize)/
                        (double)(pThread->ReadIO + pThread->HPF) : 0,
                        pThread->WriteIO,
                        pThread->WriteIO ? (double)pThread->WriteIOSize/
                        (double)pThread->WriteIO : 0,
                        pThread->SendCount,
                        pThread->SendCount ?
                        (double)(pThread->SendSize / 1024)/(double)pThread->SendCount : 0,
                        pThread->RecvCount,
                        pThread->RecvCount ?
                        (double)(pThread->RecvSize / 1024)/(double)pThread->RecvCount : 0,
                        ((pThread->TimeEnd - pThread->TimeStart) / 10000000)
                    );
            }

            PrintTransList( &pThread->TransListHead, 0 );
            TotalUserTime += ThreadUCPU;
            TotalKernelTime += ThreadKCPU;
            TotalCPUTime += ThreadKCPU + ThreadUCPU;
            ThNext = ThNext->Flink;
        }

        fprintf( procFile, "</process>\n" );

        Next = Next->Flink;
    }

    fprintf( procFile, "</table>\n" );
}

static void PrintProcessData()
{
    PTHREAD_RECORD  pThread;
    PPROCESS_RECORD pProcess; 
    PTRANS_RECORD pTrans;

    PLIST_ENTRY Next, Head;
    PLIST_ENTRY ThNext, ThHead;
    PLIST_ENTRY TrNext, TrHead;
   
    ULONG usedThreadCount;
    ULONG ThreadCount;
    ULONG TotalusedThreadCount = 0;
    ULONG TotalThreadCount = 0;

    ULONG ThreadUTime;
    ULONG ThreadKTime;
    ULONG ThreadUTimeTrans;
    ULONG ThreadKTimeTrans;
    ULONG ThreadUTimeNoTrans;
    ULONG ThreadKTimeNoTrans;

    ULONG  CountThreadNoTrans;
    ULONG  TotalKCPUThreadNoTrans;
    ULONG  TotalUCPUThreadNoTrans;
    double PercentThreadNoTrans;

    ULONG  CountThreadTrans;
    ULONG  TotalKCPUThreadTrans;
    ULONG  TotalUCPUThreadTrans;
    double PercentThreadTrans;

    ULONG TransUTime;
    ULONG TransKTime;
    ULONG Processors;

    ULONG TotalKThread = 0;
    ULONG TotalUThread = 0;

    ULONG TotalKTrans = 0;
    ULONG TotalUTrans = 0;
    
    double PerTotal = 0.0;
    double IdlePercent = 0.0;
    double percent;
    double percentTrans;
    double lDuration;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    if( Head == Next ){
        return;
    }

    Processors = CurrentSystem.NumberOfProcessors ? CurrentSystem.NumberOfProcessors : 1;
    lDuration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime)))
              / 10000000.00;

    fprintf( procFile, "<table title='Image Statistics'>\n" );

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );

        ThHead = &pProcess->ThreadListHead; 
        ThNext = ThHead->Flink;

        usedThreadCount = 0;
        ThreadCount = 0;
        ThreadUTime = 0;
        ThreadKTime = 0;
        ThreadUTimeTrans = 0;
        ThreadKTimeTrans = 0;
        ThreadUTimeNoTrans = 0;
        ThreadKTimeNoTrans = 0;
        TransKTime = 0;
        TransUTime = 0;
        percent = 0;

        CountThreadNoTrans = 0;
        TotalKCPUThreadNoTrans = 0;
        TotalUCPUThreadNoTrans = 0;

        CountThreadTrans = 0;
        TotalKCPUThreadTrans = 0;
        TotalUCPUThreadTrans = 0;

        while (ThNext != ThHead) {
            LIST_ENTRY NewTransList;

            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            if(   pThread->ReadIO
               || pThread->WriteIO
               || pThread->KCPUEnd > pThread->KCPUStart
               || pThread->UCPUEnd > pThread->UCPUStart
               || pThread->SendCount
               || pThread->RecvCount
               || pThread->HPF )
            {
                usedThreadCount++;
                TotalusedThreadCount++;
            }
            ThreadCount++;
            TotalThreadCount++;

            ThreadUTime += (pThread->UCPUEnd - pThread->UCPUStart)
                         * CurrentSystem.TimerResolution;
            ThreadKTime += (pThread->KCPUEnd - pThread->KCPUStart)
                         * CurrentSystem.TimerResolution;
            ThreadKTimeTrans += pThread->KCPU_Trans
                                * CurrentSystem.TimerResolution;
            ThreadUTimeTrans += pThread->UCPU_Trans
                                * CurrentSystem.TimerResolution;
            ThreadKTimeNoTrans += pThread->KCPU_NoTrans
                                * CurrentSystem.TimerResolution;
            ThreadUTimeNoTrans += pThread->UCPU_NoTrans
                                * CurrentSystem.TimerResolution;

            if (pThread->KCPU_Trans + pThread->UCPU_Trans == 0)
            {
                CountThreadNoTrans ++;
                TotalKCPUThreadNoTrans += pThread->KCPU_NoTrans
                                        * CurrentSystem.TimerResolution;
                TotalUCPUThreadNoTrans += pThread->UCPU_NoTrans
                                        * CurrentSystem.TimerResolution;
            }
            else
            {
                CountThreadTrans ++;
                TotalKCPUThreadTrans += (  pThread->KCPU_Trans
                                         + pThread->KCPU_NoTrans)
                                      * CurrentSystem.TimerResolution;
                TotalUCPUThreadTrans += (  pThread->UCPU_Trans
                                         + pThread->UCPU_NoTrans)
                                      * CurrentSystem.TimerResolution;
            }

            InitializeListHead(& NewTransList);
            CollapseTree(& pThread->TransListHead, & NewTransList, TRUE);
            TrHead = & NewTransList;
            TrNext = TrHead->Flink;
            while( TrNext != TrHead ){
                pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
                TransUTime += pTrans->UCpu;
                TransKTime += pTrans->KCpu;
                TrNext = TrNext->Flink;
            }
            DeleteTransList(& NewTransList, 0);

            ThNext = ThNext->Flink;
        }

        TotalKThread += ThreadKTime;
        TotalUThread += ThreadUTime;
        
        TotalKTrans += TransKTime;
        TotalUTrans += TransUTime;
        percent = (((ThreadKTime + ThreadUTime + 0.0)/lDuration)/1000.0) * 100.0;

        if (ThreadKTime + ThreadUTime == 0)
        {
            percentTrans = 0.0;
            PercentThreadTrans = 0.0;
            PercentThreadNoTrans = 0.0;
        }
        else
        {
            percentTrans = (  (ThreadKTimeTrans + ThreadUTimeTrans + 0.0)
                            / (ThreadKTime + ThreadUTime + 0.0))
                         * 100.00;
            PercentThreadTrans = ((TotalKCPUThreadTrans + TotalUCPUThreadTrans + 0.0)
                               / (ThreadKTime + ThreadUTime + 0.0)) * 100.00;
            PercentThreadNoTrans = ((TotalKCPUThreadNoTrans + TotalUCPUThreadNoTrans + 0.0)
                               / (ThreadKTime + ThreadUTime + 0.0)) * 100.00;
        }
        PerTotal += percent;
        fprintf(procFile, 
                "<image name=\"%ws\">"
                "<pid>0x%08X</pid>"
                "<threads>%d</threads>"
                "<used_threads>%d</used_threads>"
                "<process_kernel>%d</process_kernel>"
                "<process_user>%d</process_user>"
                "<transaction_kernel>%d</transaction_kernel>"
                "<transaction_user>%d</transaction_user>"
                "<cpu>%1.2f</cpu>"
                "</image>\n",
                (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                pProcess->PID,
                ThreadCount,
                usedThreadCount,
                ThreadKTime,
                ThreadUTime,
                ThreadKTimeTrans,
                ThreadUTimeTrans,
                (percent / Processors)
            );

        if(pProcess->PID == 0){
            IdlePercent += (percent / Processors );
        }
        Next = Next->Flink;
    }

    fprintf( procFile, "</table>\n" );
}

void TransInclusive( 
    PLIST_ENTRY TrHead,
    ULONG level
    )
{
    ULONG Kernel, User;
    PLIST_ENTRY TrNext = TrHead->Flink;
    PMOF_INFO pMofInfo;
    PTRANS_RECORD pTrans;
    WCHAR buffer[MAXSTR];
    WCHAR str[MAXSTR];

    while( TrNext != TrHead ){
        ULONG count = 0;
        pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
        TrNext = TrNext->Flink;
        pMofInfo = GetMofInfoHead( pTrans->pGuid);
        if (pMofInfo == NULL) {
            return;
        }
        Kernel = pTrans->KCpu;
        User = pTrans->UCpu;
        TotalTransChildren( &pTrans->SubTransListHead, &Kernel, &User, 0 );

        StringCchCopyW ( buffer, 
                        MAXSTR,
                        ( pMofInfo->strDescription ? 
                          pMofInfo->strDescription : 
                          CpdiGuidToString( str, MAXSTR, &pMofInfo->Guid ) ));

        fprintf(procFile, 
                "<transaction level='%d' name=\"%ws\">"
                "<count>%d</count>"
                "<kernel>%d</kernel>"
                "<user>%d</user>",
                level,
                buffer,
                pTrans->RefCount,
                Kernel,
                User
            );
        
        TransInclusive( &pTrans->SubTransListHead, level+1 );

        fprintf(procFile, "</transaction>\n" );
    }
}

static void PrintProcessSubDataInclusive()
{
    PPROCESS_RECORD pProcess; 
    PTHREAD_RECORD pThread;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY TrNext;
    PLIST_ENTRY ThNext, ThHead;
    LIST_ENTRY NewHead;
    BOOL bTable = FALSE;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head && !bTable ) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }

        // Total up all the threads into one list
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, FALSE );
        }

        TrNext = NewHead.Flink;

        if( TrNext != &NewHead ){
            bTable = TRUE;
        }
        DeleteTransList( &NewHead, 0 );
    }
    if( !bTable ){
        return;
    }

    // Walk through the Process List and Print the report. 
    fprintf(procFile, "<table title='Inclusive Transactions Per Process'>\n" );

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }

        // Total up all the threads into one list
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, FALSE );
        }

        TrNext = NewHead.Flink;

        if( TrNext != &NewHead ){
            fprintf(procFile, 
                    "<process name=\"%ws\">"
                    "<pid>0x%04X</pid>\n",
                    (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                    pProcess->PID
                );
            TransInclusive( &NewHead, 0 );
            fprintf( procFile, "</process>\n" );
        }
        DeleteTransList( &NewHead, 0 );
    }

    fprintf(procFile, "</table>\n" );
}

static void PrintProcessSubDataExclusive()
{
    PPROCESS_RECORD pProcess; 
    PTRANS_RECORD pTrans;
    PTHREAD_RECORD pThread;
    PLIST_ENTRY ThNext, ThHead;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY TrNext;
    LIST_ENTRY NewHead;
    double percent, percentCPU, totalPerCPU;
    double processPart;
    double transPart;
    double totalPercent;
    double trans, KCPU, UCPU;
    WCHAR str[MAXSTR];
    double duration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime))) / 10000000.00;
    BOOL bTable = FALSE;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head && !bTable ) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, TRUE );
        }

        TrNext = NewHead.Flink;
        if( TrNext != &NewHead ){
            bTable = TRUE;
        }
        DeleteTransList( &NewHead, 0 );        
    }

    if( !bTable ){
        return;
    }

    // Walk through the Process List and Print the report. 
    fprintf(procFile, "<table title='Exclusive Transactions Per Process'>\n" );

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        BOOL titled = FALSE;
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, TRUE );
        }

        TrNext = NewHead.Flink;
        totalPercent = 0.0;
        totalPerCPU = 0.0;
        while( TrNext != &NewHead ){
            if(!titled){
                fprintf(procFile, 
                        "<process name=\"%ws\">"
                        "<pid>0x%04X</pid>\n",
                        (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                        pProcess->PID
                    );
                    
                titled = TRUE;
            }
            pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
            TrNext = TrNext->Flink;
            pMofInfo = GetMofInfoHead( pTrans->pGuid);
            if (pMofInfo == NULL) {
                return;
            }
            transPart = pTrans->UCpu + pTrans->KCpu;
            processPart = CalculateProcessKCPU(pProcess)
                        + CalculateProcessUCPU(pProcess);
            percentCPU = ((((double)pTrans->KCpu + (double)pTrans->UCpu ) / 10.0 ) / duration) / ((double) CurrentSystem.NumberOfProcessors);
            totalPerCPU += percentCPU;
            if(processPart)
                percent = (transPart/processPart) * 100.0;
            else
                percent = 0;
            totalPercent += percent;
            if (!(ReportFlags & TRACE_TOTALS_REPORT) ){
                if (pTrans->RefCount == 0 && pTrans->RefCount1 == 0)
                    KCPU = UCPU = 0.0;
                else if (pTrans->RefCount == 0) {
                    KCPU = (double) pTrans->KCpu;
                    UCPU = (double) pTrans->UCpu;
                }
                else {
                    KCPU = (double) pTrans->KCpu / (double) pTrans->RefCount;
                    UCPU = (double) pTrans->UCpu / (double) pTrans->RefCount;
                }
            }
            else{
                KCPU = (double)pTrans->KCpu;
                UCPU = (double)pTrans->UCpu;
            }

            trans = (double)pTrans->RefCount / duration;
            fprintf(procFile, 
                    "<transaction name=\"%ws\">"
                    "<count>%d</count>"
                    "<rate>%1.2f</rate>"
                    "<kernel>%1.0f</kernel>"
                    "<user>%1.0f</user>"
                    "<process_cpu>%1.2f</process_cpu>"
                    "<cpu>%1.2f</cpu>"
                    "</transaction>\n",
                    (pMofInfo->strDescription != NULL) ? pMofInfo->strDescription : CpdiGuidToString( str, MAXSTR, &pMofInfo->Guid ),
                    pTrans->RefCount,
                    trans,
                    KCPU,
                    UCPU,
                    percent, 
                    percentCPU
                );
        }
        if( titled ){
                fprintf( procFile, "</process>\n" );
        }
        DeleteTransList( &NewHead, 0 );
        
    }
    fprintf(procFile, "</table>\n" );
}


static void PrintPerThreadPerDiskTable( )
{
    PPROCESS_RECORD pProcess; 
    PTDISK_RECORD pDisk;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY GNext, GHead;
    PLIST_ENTRY DiNext, DiHead;
    ULONG rio, wio, DiskNumber;
    BOOL bTable = FALSE;
    ULONGLONG Duration = (ULONGLONG)((CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000);

    if (Duration == 0) {
        return;
    }

    // Walk through the Process List and Print the report. 
    GHead = &CurrentSystem.GlobalDiskListHead;
    GNext = GHead->Flink;
    while (GNext != GHead && !bTable) {

        pDisk = CONTAINING_RECORD( GNext, TDISK_RECORD, Entry);
        DiskNumber =  pDisk->DiskNumber;

        Head = &CurrentSystem.ProcessListHead;
        Next = Head->Flink;
        while (Next != Head) {
            pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
            DiHead = &pProcess->DiskListHead;
            DiNext = DiHead->Flink;
            while (DiNext != DiHead && !bTable) {
                pDisk = CONTAINING_RECORD( DiNext, TDISK_RECORD, Entry );

                if (DiskNumber != pDisk->DiskNumber) {
                    DiNext =  DiNext->Flink;
                    continue;
                }else{
                    bTable = TRUE;
                    break;
                }

            }
        
            Next = Next->Flink;
        
        }
        GNext = GNext->Flink;
    }

    if( !bTable ){
        return;
    }

    GHead = &CurrentSystem.GlobalDiskListHead;
    GNext = GHead->Flink;
    while (GNext != GHead) {

        pDisk = CONTAINING_RECORD( GNext, TDISK_RECORD, Entry);
        DiskNumber =  pDisk->DiskNumber;
        fprintf( procFile, "<table title='Disk' number='%d'>\n", DiskNumber );

        Head = &CurrentSystem.ProcessListHead;
        Next = Head->Flink;
        while (Next != Head) {
            pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );


            DiHead = &pProcess->DiskListHead;
            DiNext = DiHead->Flink;
            while (DiNext != DiHead) {
                pDisk = CONTAINING_RECORD( DiNext, TDISK_RECORD, Entry );

                if (DiskNumber != pDisk->DiskNumber) {
                    DiNext =  DiNext->Flink;
                    continue;
                }
                rio = pDisk->ReadCount + pDisk->HPF;
                wio = pDisk->WriteCount;
                fprintf(procFile, 
                        "<image name='%ws'>"
                        "<pid>0x%08X</pid>"
                        "<authority>%ws</authority>"
                        "<read_rate>%1.3f</read_rate>"
                        "<read_size>%d</read_size>"
                        "<write_rate>%1.3f</write_rate>"
                        "<write_size>%d</write_size>"
                        "</image>\n",
                        (pProcess->ImageName) ? pProcess->ImageName : L"-",
                        pProcess->PID,
                        (pProcess->UserName) ? pProcess->UserName : L"-",
                        (double)rio / ((double)Duration),
                        (rio == 0) ? 0 : (pDisk->ReadSize + pDisk->HPFSize) / rio,
                        (double)wio / ((double)Duration),
                        (wio == 0) ? 0 : pDisk->WriteSize / wio
                    );
            
                DiNext = DiNext->Flink;
            }
        
            Next = Next->Flink;
        
        }

        fprintf( procFile, "</table>\n" );
        GNext = GNext->Flink;
    }
}

static void WriteTransactionStatistics()
{
    PLIST_ENTRY Head, Next;
    PLIST_ENTRY Dhead, DNext;
    ULONG trans;
    double KCPU, UCPU, PerCpu;
    double RIO, WIO, Send, Recv;
    PMOF_INFO pMofInfo;
    PMOF_DATA pMofData;
    double AvgRT;
    double TransRate;
    WCHAR str[MAXSTR];
    double duration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime)))
                   / 10000000.00;
    BOOL bTable = FALSE;

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next && !bTable ) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = pMofData->CompleteCount;
            if (trans > 0) {
                bTable = TRUE;
                break;
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }
    
    if( !bTable ){
        return;
    }

    fprintf( procFile, "<table title='Transaction Statistics'>\n" );

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = pMofData->CompleteCount;
            if (trans > 0) {
                UCPU = pMofData->UserCPU;
                KCPU = pMofData->KernelCPU;
                PerCpu = (((UCPU + KCPU)/1000.0)/duration) * 100.0;
                UCPU /= trans;
                KCPU /=  trans;
                if(CurrentSystem.NumberOfProcessors)
                    PerCpu/=CurrentSystem.NumberOfProcessors;
                if( ReportFlags & TRACE_TOTALS_REPORT ){
                    RIO  = pMofData->ReadCount;
                    WIO  = pMofData->WriteCount;
                    Send  = pMofData->SendCount;
                    Recv  = pMofData->RecvCount;
                }else{
                    RIO  = pMofData->ReadCount / trans;
                    WIO  = pMofData->WriteCount / trans;
                    Send  = pMofData->SendCount / trans;
                    Recv  = pMofData->RecvCount / trans;
                }
                AvgRT = (double)pMofData->TotalResponseTime;
                AvgRT /= trans;
                TransRate = ( (float)trans / duration );

                // TODO: NOT /trans if TRACE_TOTALS_REPORT
                fprintf(procFile, 
                        "<transaction name='%ws'>"
                        "<count>%d</count>"
                        "<response_time>%1.0f</response_time>"
                        "<rate>%1.2f</rate>"
                        "<cpu>%1.2f</cpu>"
                        "<disk_read_per_trans>%1.2f</disk_read_per_trans>"
                        "<disk_write_per_trans>%1.2f</disk_write_per_trans>"
                        "<tcp_send_per_trans>%1.2f</tcp_send_per_trans>"
                        "<tcp_recv_per_trans>%1.2f</tcp_recv_per_trans>"
                        "</transaction>\n",
                        (pMofInfo->strDescription) ? pMofInfo->strDescription : CpdiGuidToString( str, MAXSTR, &pMofInfo->Guid ),
                        pMofData->CompleteCount,
                        AvgRT,
                        TransRate,
                        PerCpu, 
                        RIO, 
                        WIO,
                        Send,
                        Recv
                    );                
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }

    fprintf(procFile, "</table>" );

}

static void WriteTransactionCPUTime()
{
    PLIST_ENTRY Head, Next;
    PLIST_ENTRY Dhead, DNext;
    double KCPU, UCPU;
    PMOF_INFO pMofInfo;
    PMOF_DATA pMofData;
    double trans;
    double PerCpu;
    WCHAR str[MAXSTR];
    double duration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime))) / 10000000.00;
    BOOL bTable = FALSE;
    
    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next && !bTable ) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = (double)pMofData->CompleteCount;
            if (trans > 0) {
                bTable = TRUE;
                break;
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }
    
    if( !bTable ){
        return;
    }

    
    fprintf( procFile, "<table title='Transaction CPU Utilization'>\n" );

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = (double)pMofData->CompleteCount;
            if (trans > 0) {
                UCPU = pMofData->UserCPU;
                UCPU /= trans;
                KCPU = pMofData->KernelCPU;
                KCPU /=  trans;
                PerCpu = (((pMofData->UserCPU + pMofData->KernelCPU + 0.0)/1000.0)/duration) * 100.0;
                if( !(ReportFlags & TRACE_TOTALS_REPORT) ){
                    trans /= duration;
                }
                if(CurrentSystem.NumberOfProcessors){
                    PerCpu/=CurrentSystem.NumberOfProcessors;
                }
                // NOTE: RATE should be COUNT if TRACE_TOTALS_REPORT
                fprintf(procFile,
                        "<transaction name='%ws'>"
                        "<rate>%1.2f</rate>"
                        "<min_kernel>%d</min_kernel>"
                        "<min_user>%d</min_user>"
                        "<max_kernel>%d</max_kernel>"
                        "<max_user>%d</max_user>"
                        "<per_trans_kernel>%1.0f</per_trans_kernel>"
                        "<per_trans_user>%1.0f</per_trans_user>"
                        "<total_kernel>%d</total_kernel>"
                        "<total_user>%d</total_user>"
                        "<cpu>%1.2f</cpu>"
                        "</transaction>\n",
                        (pMofInfo->strDescription) ? pMofInfo->strDescription : CpdiGuidToString( str, MAXSTR, &pMofInfo->Guid ),
                        trans,
                        pMofData->MinKCpu,
                        pMofData->MinUCpu,
                        pMofData->MaxKCpu,
                        pMofData->MaxUCpu,
                        KCPU,
                        UCPU, 
                        pMofData->KernelCPU,
                        pMofData->UserCPU,
                       PerCpu
                    );
                
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }

    fprintf(procFile, "</table>\n" );
}

PWCHAR CpdiGuidToString(
    PWCHAR s,
    ULONG len,
    LPGUID piid
    )
{
    StringCchPrintf(s, len,
                    L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                    piid->Data1, piid->Data2,
                    piid->Data3,
                    piid->Data4[0], piid->Data4[1],
                    piid->Data4[2], piid->Data4[3],
                    piid->Data4[4], piid->Data4[5],
                    piid->Data4[6], piid->Data4[7]);

    return(s);
}

#define MAX_LOGS    1024 * 1024

typedef struct _PTR_RECORD
{
    PVOID ptrRecord;
    ULONG keySort;
} PTR_RECORD, * PPTR_RECORD;

static PPTR_RECORD PtrBuffer = NULL;
static ULONG       PtrMax    = MAX_LOGS;
static ULONG       PtrTotal  = 0;
static ULONG       PtrIndex;

int __cdecl
CompareFileRecord(const void * p1, const void * p2)
{
    PPTR_RECORD   pp1      = (PPTR_RECORD) p1;
    PPTR_RECORD   pp2      = (PPTR_RECORD) p2;
    PFILE_RECORD  pFile1   = (PFILE_RECORD) pp1->ptrRecord;
    PFILE_RECORD  pFile2   = (PFILE_RECORD) pp2->ptrRecord;

    LONG diffFault = pp2->keySort - pp1->keySort;
    if (diffFault == 0)
    {
        diffFault = pFile1->DiskNumber - pFile2->DiskNumber;
        if (diffFault == 0)
        {
            diffFault = wcscmp(pFile1->FileName, pFile2->FileName);
        }
    }

    return diffFault;
}

void
ReportHotFileInfo()
{
    PLIST_ENTRY  pHead = & CurrentSystem.HotFileListHead;
    PLIST_ENTRY  pNext = pHead->Flink;
    PFILE_RECORD pFile;
    BOOLEAN      fDone = FALSE;
    ULONGLONG    Duration = ((CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000);
    PMOF_INFO    pMofInfo;

    pMofInfo = GetMofInfoHead ((LPCGUID)&ProcessGuid);
    if ( pMofInfo == NULL ) {
        return;
    }
    pMofInfo = GetMofInfoHead ((LPCGUID)&ThreadGuid);
    if ( pMofInfo == NULL ) {
        return;
    }

    ASSERT(!PtrBuffer);
    PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                              NULL,
                              sizeof(PTR_RECORD) * PtrMax,
                              MEM_COMMIT,
                              PAGE_READWRITE);
    
    if( NULL == PtrBuffer ){
        goto Cleanup;
    }

    while (!fDone)
    {
        for (PtrTotal = 0, fDone = TRUE;
             pNext != pHead;
             pNext  = pNext->Flink)
        {
            if (PtrTotal == PtrMax)
            {
                fDone = FALSE;
                break;
            }

            pFile = CONTAINING_RECORD(pNext, FILE_RECORD, Entry);

            if (pFile->ReadCount + pFile->WriteCount > 0)
            {
                PtrBuffer[PtrTotal].ptrRecord = (PVOID) pFile;
                PtrBuffer[PtrTotal].keySort   =
                                        pFile->ReadCount + pFile->WriteCount;
                PtrTotal ++;
            }
        }

        if (!fDone)
        {
            VirtualFree(PtrBuffer, 0, MEM_RELEASE);
            PtrMax += MAX_LOGS;
            PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                                      NULL,
                                      sizeof(PTR_RECORD) * PtrMax,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
            if (PtrBuffer == NULL)
            {
                goto Cleanup;
            }
        }
    }

    if (PtrTotal > 1) {
        qsort((void *) PtrBuffer,
              (size_t) PtrTotal,
              (size_t) sizeof(PTR_RECORD),
              CompareFileRecord);
    }
    else {
        return;
    }

    if (PtrTotal > DISPLAY_SIZE) {
        PtrTotal =  DISPLAY_SIZE;
    }

    // output HotFile report title
    //
    fprintf( procFile, "<table title='Files Causing Most Disk IOs' top='%d'>\n", DISPLAY_SIZE );

    for (PtrIndex = 0; PtrIndex < PtrTotal; PtrIndex ++)
    {
        PLIST_ENTRY           pProtoHead;
        PLIST_ENTRY           pProtoNext;
        PPROTO_PROCESS_RECORD pProto;
        WCHAR ReducedFileName[FILE_NAME_COLUMN_SIZE + 1];
        LPWSTR szFile;
        PWCHAR szLongFile;
        LPWSTR szDrive = L"";

        pFile = (PFILE_RECORD) PtrBuffer[PtrIndex].ptrRecord;

        if (NULL != pFile->Drive) {
            szDrive = pFile->Drive;
        }
        if (_wcsnicmp(pFile->FileName, L"\\Device\\", 8) == 0) {
            szLongFile = (PWCHAR)(pFile->FileName) + 8;
            while (*szLongFile != L'\\' && *szLongFile != L'\0') {
                szLongFile++;
            }
        }
        else {
            szLongFile = (PWCHAR)(pFile->FileName);
        }

        if (wcslen(szLongFile) > FILE_NAME_COLUMN_SIZE) {
            ReduceStringW(ReducedFileName, FILE_NAME_COLUMN_SIZE + 1, szLongFile);
            szFile = ReducedFileName;
        }else{
            szFile = szLongFile;
        }

        fprintf(procFile, 
                "<file name='%ws'>"
                "<disk>%d</disk>"
                "<drive>%ws</drive>"
                "<read_rate>%1.3f</read_rate>"
                "<read_size>%d</read_size>"
                "<write_rate>%1.3f</write_rate>"
                "<write_size>%d</write_size>\n",
                szFile,
                pFile->DiskNumber,
                szDrive,
                Duration ? ((double)pFile->ReadCount / (double)Duration) : 0.0,
                (pFile->ReadCount) ? (pFile->ReadSize / pFile->ReadCount) : 0,
                Duration ? ((double)pFile->WriteCount / (double)Duration) : 0.0,
                (pFile->WriteCount) ? (pFile->WriteSize / pFile->WriteCount) : 0);
            

        pProtoHead = & pFile->ProtoProcessListHead;
        pProtoNext = pProtoHead->Flink;

        while (pProtoNext != pProtoHead)
        {
            pProto = CONTAINING_RECORD(pProtoNext, PROTO_PROCESS_RECORD, Entry);
            pProtoNext = pProtoNext->Flink;

            if (pProto->ReadCount + pProto->WriteCount > 0)
            {
                fprintf(procFile,
                        "<image name='%ws'>"
                        "<pid>0x%08X</pid>"
                        "<read_rate>%1.3f</read_rate>"
                        "<read_size>%d</read_size>"
                        "<write_rate>%1.3f</write_rate>"
                        "<write_size>%d</write_size>"
                        "</image>\n",
                        pProto->ProcessRecord->ImageName,
                        pProto->ProcessRecord->PID,
                        Duration ? ((double)pProto->ReadCount / (double)Duration) : 0.0,
                        (pProto->ReadCount) ? (pProto->ReadSize / pProto->ReadCount) : 0,
                        Duration ? ((double)pProto->WriteCount / (double)Duration) : 0.0,
                        (pProto->WriteCount) ? (pProto->WriteSize / pProto->WriteCount) : 0);
            }
        }
        fprintf( procFile, "</file>\n" );
    }

    fprintf( procFile, "</table>\n" );

Cleanup:
    if (PtrBuffer)
    {
        VirtualFree(PtrBuffer, 0, MEM_RELEASE);
    }
}

#define CHECKTOK( x )   if( NULL == x ) { continue; }

static void ReportPrintJobInfo2(void)
{
    PRINT_JOB_RECORD Job, *pJob;
    char* s; 
    char line[MAXSTR];

    ULONG TotalCount = 0;
    ULONGLONG TotalRT = 0;
    ULONG     TotalCPUTime = 0;

    pJob = &Job;

    if( NULL == CurrentSystem.TempPrintFile ){
        return;
    }

    rewind( CurrentSystem.TempPrintFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempPrintFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            return;
        }
    }

    fprintf(procFile, "<table title='Spooler Transaction Instance (Job) Data'>\n"); 

    RtlZeroMemory(pJob, sizeof(PRINT_JOB_RECORD));
    RtlZeroMemory(line, MAXSTR * sizeof(char));

    rewind( CurrentSystem.TempPrintFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempPrintFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            continue;
        }

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->KCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->UCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ReadIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->StartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->EndTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ResponseTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PrintJobTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->WriteIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->DataType = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->JobSize = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Pages = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PagesPerSide = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->FilesOpened = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->GdiJobSize = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Color = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->XRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->YRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Quality = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Copies = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->TTOption = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->NumberOfThreads = atol(s);

        fprintf(procFile,
            "<job id='%d'>"
            "<type>%d</type>"
            "<size>%d</size>"
            "<pages>%d</pages>"
            "<PPS>%d</PPS>"
            "<files>%hd</files>"
            "<gdisize>%d</gdisize>"
            "<color>%hd</color>"
            "<xres>%hd</xres>"
            "<yres>%hd</yres>"
            "<qlty>%hd</qlty>"
            "<copies>%hd</copies>"
            "<ttopt>%hd</ttopt>"
            "<threads>%d</threads>"
            "</job>\n",
            pJob->JobId,
            pJob->DataType,
            ((pJob->JobSize) / 1024),
            pJob->Pages,
            pJob->PagesPerSide,
            pJob->FilesOpened,
            pJob->GdiJobSize,
            pJob->Color,
            pJob->XRes,
            pJob->YRes,
            pJob->Quality,
            pJob->Copies,
            pJob->TTOption,
            pJob->NumberOfThreads
            );
    }

    fprintf(procFile, "</table>\n" );
}

static void ReportPrintJobInfo(void)
{
    PRINT_JOB_RECORD Job, *pJob;
    char* s; 
    char line[MAXSTR];

    FILETIME  StTm, StlTm;
    LARGE_INTEGER LargeTmp;
    SYSTEMTIME stStart, stEnd, stDequeue;

    ULONG TotalCount = 0;
    ULONGLONG TotalRT = 0;
    ULONG     TotalCPUTime = 0;

    if( NULL == CurrentSystem.TempPrintFile ){
        return;
    }

    pJob = &Job;

    rewind( CurrentSystem.TempPrintFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempPrintFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            return;
        }
    }

    fprintf(procFile, "<table title='Transaction Instance (Job) Statistics'>\n" );

    RtlZeroMemory(pJob, sizeof(PRINT_JOB_RECORD));
    RtlZeroMemory(line,    MAXSTR * sizeof(char));

    rewind( CurrentSystem.TempPrintFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempPrintFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            continue;
        }

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->KCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->UCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ReadIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->StartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->EndTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ResponseTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PrintJobTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->WriteIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->DataType = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->JobSize = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Pages = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PagesPerSide = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->FilesOpened = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->GdiJobSize = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Color = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->XRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->YRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Quality = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Copies = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->TTOption = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->NumberOfThreads = atol(s);


        LargeTmp.QuadPart = pJob->StartTime;
        StTm.dwHighDateTime = LargeTmp.HighPart;
        StTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&StTm, &StlTm);


        FileTimeToSystemTime (
            &StlTm,
            &stStart
            );

        LargeTmp.QuadPart = pJob->EndTime;
        StTm.dwHighDateTime = LargeTmp.HighPart;
        StTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&StTm, &StlTm);


        FileTimeToSystemTime (
            &StlTm,
            &stEnd
            );

        LargeTmp.QuadPart = pJob->PrintJobTime;
        StTm.dwHighDateTime = LargeTmp.HighPart;
        StTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&StTm, &StlTm);

        FileTimeToSystemTime (
            &StlTm,
            &stDequeue
            );

        fprintf(procFile,
            "<job id='%d'>"
            "<start>%2d:%02d:%02d.%03d</start>"
            "<dequeue>%2d:%02d:%02d.%03d</dequeue>"
            "<end>%2d:%02d:%02d.%03d</end>"
            "<response_time>%I64u</response_time>"
            "<cpu>%d</cpu>"
            "</job>\n",
            pJob->JobId,
            stStart.wHour, stStart.wMinute, stStart.wSecond, stStart.wMilliseconds, 
            stDequeue.wHour, stDequeue.wMinute, stDequeue.wSecond, stDequeue.wMilliseconds, 
            stEnd.wHour, stEnd.wMinute, stEnd.wSecond, stEnd.wMilliseconds, 
            pJob->ResponseTime,
            pJob->KCPUTime + pJob->UCPUTime
            );
        TotalCount++;
        TotalRT += pJob->ResponseTime;
        TotalCPUTime += (pJob->KCPUTime + pJob->UCPUTime);
    }

    if (TotalCount > 0) {
        TotalRT /= TotalCount;
        TotalCPUTime /= TotalCount;
    }

    fprintf(procFile, 
        "<summary>"
        "<count>%d</count>"
        "<total_response_time>%I64u</total_response_time>"
        "<total_cpu>%d</total_cpu>"
        "</summary>\n",
        TotalCount, TotalRT, TotalCPUTime );

    fprintf(procFile, "</table>\n" );

    ReportPrintJobInfo2();
}

PUCHAR CopyUrlStr(PUCHAR UrlStr) {
    PUCHAR CopiedStr;
    if (UrlStr == NULL) {
        return NULL;
    }
    CopiedStr = (PUCHAR)malloc(strlen(UrlStr) + 1);
    if (CopiedStr != NULL) {
        RtlCopyMemory(CopiedStr, UrlStr, strlen(UrlStr) + 1);
        return CopiedStr;
    }
    else {
        return NULL;
    }
}

void ProcessIisRequest(HTTP_REQUEST_RECORD *pReq)
{
    // Global variable IIS must not be NULL here.

    PURL_RECORD pUrl;
    PCLIENT_RECORD pClient;
    PSITE_RECORD pSite;

    pUrl = FindOrAddUrlRecord(pReq->URL);
    if (pUrl != NULL) {
        pUrl->SiteId = pReq->SiteId;
        pUrl->Requests++;
        pUrl->TotalResponseTime += pReq->ULResponseTime;
        pUrl->KCPUTime += pReq->KCPUTime;
        pUrl->UCPUTime += pReq->UCPUTime;
        pUrl->ReadIO += pReq->ReadIO;
        pUrl->WriteIO += pReq->WriteIO;
        pUrl->BytesSent += pReq->BytesSent;
        // Cached responses don't have this field filled
        // Thus need to check for Hits field as well
        pUrl->UrlType = pReq->W3ProcessType;
    }

    pClient = FindOrAddClientRecord(pReq->IpAddrType, pReq->IpAddrV4, pReq->IpAddrV6);
    if (pClient != NULL) {
        pClient->Requests++;
        pClient->TotalResponseTime += pReq->ULResponseTime;
        pClient->BytesSent += pReq->BytesSent;
    }

    pSite = FindOrAddSiteRecord(pReq->SiteId);
    if (pSite != NULL) {
        pSite->Requests++;
        pSite->TotalResponseTime += pReq->ULResponseTime;
        pSite->KCPUTime += pReq->KCPUTime;
        pSite->UCPUTime += pReq->UCPUTime;
        pSite->ReadIO += pReq->ReadIO;
        pSite->WriteIO += pReq->WriteIO;
        pSite->BytesSent += pReq->BytesSent;
    }

    if (pReq->ULEndType == EVENT_TRACE_TYPE_UL_CACHEDEND) {
        IIS->CachedResponses++;
        IIS->TotalCachedResponseTime += pReq->ULResponseTime;
        IIS->CachedCPUTime += pReq->KCPUTime + pReq->UCPUTime;
        if (pUrl != NULL) {
            pUrl->Hits++;
        }
        if (pClient != NULL) {
            pClient->Hits++;
        } 
        if (pSite != NULL) {
            pSite->Hits++;
        }
    }
    else {
        ULONGLONG localCGIEndTime = pReq->CGIEndTime;
        ULONGLONG localISAPIEndTime = pReq->ISAPIEndTime;
        ULONGLONG localASPEndTime = pReq->ASPEndTime;
        ULONGLONG W3ResponseTime;
        
#ifdef DBG
        // we'll check the validity of HTTP Requests Here.
        ULONGLONG ULSum = 0, W3Res = 0;
        if (pReq->ULDeliverTime == 0 || pReq->ULReceiveTime == 0) {
            TrctrDbgPrint(("TRACERPT Error Req: %I64u UL DeliverTime nad/or ReceiveTime not available, should throw this away.\n", pReq->RequestId));
        }
        else {
            ULSum = (pReq->ULDeliverTime - pReq->ULStartTime) + (pReq->ULEndTime - pReq->ULReceiveTime);
        }
        if (pReq->W3StartTime == 0) {
            TrctrDbgPrint(("TRACERPT Error Req: %I64u W3 StartTime not available, should throw this away.\n", pReq->RequestId));
        }
        if (pReq->W3EndTime == 0) {
            TrctrDbgPrint(("TRACERPT Warning Req: %I64u W3 EndTime not available.\n", pReq->RequestId));
        }
        if (pReq->W3StartTime != 0 && pReq->W3EndTime != 0 && pReq->W3EndTime < pReq->W3StartTime) {
            TrctrDbgPrint(("TRACERPT Warning Req: %I64u W3 EndTime smaller than pReq->W3StartTime.\n", pReq->RequestId));
        }
        if (ULSum != 0 && pReq->W3StartTime != 0 && pReq->W3EndTime != 0) {
            double ULRatio = 0.0;
            W3Res = pReq->W3EndTime - pReq->W3StartTime;
            ULRatio = (double)ULSum / (double)(pReq->ULResponseTime - W3Res);
            if (ULRatio < 0.5 || ULRatio > 2.0) {
                TrctrDbgPrint(("TRACERPT Warning Req: %I64u UL Ratio is unreal.\n", pReq->RequestId));
            }
        }
        if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_CGIREQ) {
            if (pReq->CGIStartTime == 0) {
                TrctrDbgPrint(("TRACERPT Error Req: %I64u CGI StartTime not available, should throw this away.\n", pReq->RequestId));
            }
            if (pReq->CGIEndTime == 0) {
                TrctrDbgPrint(("TRACERPT Warning Req: %I64u CGI EndTime not available.\n", pReq->RequestId));
                if (pReq->W3EndTime != 0 && (pReq->CGIStartTime > pReq->W3EndTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u CGI StartTime > pReq->W3EndTime.\n", pReq->RequestId));
                }
                else if (pReq->W3EndTime == 0 && (pReq->CGIStartTime > pReq->ULReceiveTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u CGI StartTime > pReq->ULReceiveTime.\n", pReq->RequestId));
                }
            }
        }
        else if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_ISAPIREQ) {
            if (pReq->ISAPIStartTime == 0) {
                TrctrDbgPrint(("TRACERPT Error Req: %I64u ISAPI StartTime not available, should throw this away.\n", pReq->RequestId));
            }
            if (pReq->ISAPIEndTime == 0) {
                TrctrDbgPrint(("TRACERPT Warning Req: %I64u ISAPI EndTime not available.\n", pReq->RequestId));
                if (pReq->W3EndTime != 0 && (pReq->ISAPIStartTime > pReq->W3EndTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u ISAPI StartTime > pReq->W3EndTime.\n", pReq->RequestId));
                }
                else if (pReq->W3EndTime == 0 && (pReq->ISAPIStartTime > pReq->ULReceiveTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u ISAPI StartTime > pReq->ULReceiveTime.\n", pReq->RequestId));
                }
            }
            if (pReq->ASPStartTime == 0) {
                TrctrDbgPrint(("TRACERPT Warning Req: %I64u ASP StartTime not available.\n", pReq->RequestId));
            }
            if (pReq->ASPEndTime == 0) {
                TrctrDbgPrint(("TRACERPT Warning Req: %I64u ASP EndTime not available.\n", pReq->RequestId));
                if (pReq->ISAPIEndTime != 0 && (pReq->ASPStartTime > pReq->ISAPIEndTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u ASP StartTime > pReq->ISAPIEndTime.\n", pReq->RequestId));
                }
                else if (pReq->W3EndTime != 0 && (pReq->ASPStartTime > pReq->W3EndTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u ASP StartTime > pReq->W3EndTime.\n", pReq->RequestId));
                }
                else if (pReq->W3EndTime == 0 && (pReq->ASPStartTime > pReq->ULReceiveTime)) {
                    TrctrDbgPrint(("TRACERPT Warning Req: %I64u ASP StartTime > pReq->ULReceiveTime.\n", pReq->RequestId));
                }
            }
        }
#endif
        // Fix the time inconsistency in transactions
        if (pReq->W3StartTime == 0 || (pReq->W3EndTime != 0 && pReq->W3EndTime < pReq->W3StartTime)) {
            RequestsDiscarded++;
            if (pReq->URL != NULL) {
                free(pReq->URL);
            }
            return;
        }
        if (pReq->W3EndTime == 0 || pReq->W3EndTime > pReq->ULReceiveTime) {
            pReq->W3EndTime = pReq->ULReceiveTime;
            if (pReq->W3EndTime == 0 || pReq->W3EndTime < pReq->W3StartTime) {
                RequestsDiscarded++;
                if (pReq->URL != NULL) {
                    free(pReq->URL);
                }
                return;
            }
        }
        W3ResponseTime = pReq->W3EndTime - pReq->W3StartTime;
        if (W3ResponseTime < pReq->W3FilterResponseTime) {
            pReq->W3FilterResponseTime = W3ResponseTime;
        }

        if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_CGIREQ) {
            if (pReq->CGIStartTime == 0) {
                RequestsDiscarded++;
                if (pReq->URL != NULL) {
                    free(pReq->URL);
                }
                return;
            }
            else if (pReq->CGIEndTime == 0 || pReq->CGIEndTime > pReq->W3EndTime) {
                localCGIEndTime = pReq->W3EndTime;
                if (pReq->CGIStartTime > localCGIEndTime) {
                    RequestsDiscarded++;
                    if (pReq->URL != NULL) {
                        free(pReq->URL);
                    }
                    return;
                }
            }
            else {
                localCGIEndTime = pReq->CGIEndTime;
            }

            if (pReq->CGIStartTime < pReq->W3StartTime) {
                pReq->CGIStartTime = pReq->W3StartTime;
            }
            if (localCGIEndTime < pReq->CGIStartTime) {
                localCGIEndTime = pReq->CGIStartTime;
            }
            if ((pReq->W3FilterResponseTime + (localCGIEndTime - pReq->CGIStartTime)) > W3ResponseTime) {
                pReq->W3FilterResponseTime = W3ResponseTime - (localCGIEndTime - pReq->CGIStartTime);
            }
        }
        else if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_ISAPIREQ) {
            if (pReq->ISAPIStartTime == 0) {
                RequestsDiscarded++;
                if (pReq->URL != NULL) {
                    free(pReq->URL);
                }
                return;
            }
            if (pReq->ISAPIEndTime == 0 || pReq->ISAPIEndTime > pReq->W3EndTime) {
                localISAPIEndTime = pReq->W3EndTime;
                if (pReq->ISAPIStartTime > localISAPIEndTime) {
                    RequestsDiscarded++;
                    if (pReq->URL != NULL) {
                        free(pReq->URL);
                    }
                    return;
                }
            }
            else {
                localISAPIEndTime = pReq->ISAPIEndTime;
            }

            if (pReq->ISAPIStartTime < pReq->W3StartTime) {
                pReq->ISAPIStartTime = pReq->W3StartTime;
            }
            if (localISAPIEndTime < pReq->ISAPIStartTime) {
                localISAPIEndTime = pReq->ISAPIStartTime;
            }
            if ((pReq->W3FilterResponseTime + (localISAPIEndTime - pReq->ISAPIStartTime)) > W3ResponseTime) {
                pReq->W3FilterResponseTime = W3ResponseTime - (localISAPIEndTime - pReq->ISAPIStartTime);
            }

            if (pReq->ASPStartTime != 0) {
                if (pReq->ASPEndTime == 0) {
                    localASPEndTime = localISAPIEndTime;
                    if (pReq->ASPStartTime > localASPEndTime) {
                        RequestsDiscarded++;
                        if (pReq->URL != NULL) {
                            free(pReq->URL);
                        }
                        return;
                    }
                }
                else {
                    localASPEndTime = pReq->ASPEndTime;
                }

                if (pReq->ASPStartTime < pReq->ISAPIStartTime) {
                    pReq->ASPStartTime = pReq->ISAPIStartTime;
                }
                if (localASPEndTime < pReq->ASPStartTime) {
                    localASPEndTime = pReq->ASPStartTime;
                }
                if ((localISAPIEndTime - pReq->ISAPIStartTime) < (localASPEndTime - pReq->ASPStartTime)) {
                    localASPEndTime = localISAPIEndTime;
                }
            }
        } // Fix done. All end times are fixed.


        IIS->TotalNonCachedResponseTime += pReq->ULResponseTime;
        IIS->NonCachedCPUTime += pReq->KCPUTime + pReq->UCPUTime;

        if (pReq->W3FilterResponseTime != 0) {
            IIS->W3FilterRequests += pReq->W3FilterVisits;
            IIS->TotalW3FilterResponseTime += pReq->W3FilterResponseTime;
            IIS->TotalW3FilterCPUTime += pReq->W3FltrCPUTime;
        }
        if (pReq->ULEndType == EVENT_TRACE_TYPE_UL_SENDERROR && pReq->ISAPIStartTime == 0) {
            // This is a request ended with SENDERROR.
            SendErrorRequests++;
        }                
        
        if (pReq->HttpStatus != 0 && pReq->HttpStatus >= 400) {
            // This is a request with http error.
            IIS->W3Error++;
            IIS->TotalErrorResponseTime += pReq->ULResponseTime;
            IIS->ErrorCPUTime += pReq->KCPUTime + pReq->UCPUTime;
            IIS->TotalErrorULOnlyCPUTime += pReq->ULCPUTime;
            IIS->TotalErrorW3OnlyCPUTime += pReq->W3CPUTime;
            IIS->TotalErrorW3FilterCPUTime += pReq->W3FltrCPUTime;
            IIS->TotalErrorCGIOnlyCPUTime += pReq->CGICPUTime;
            IIS->TotalErrorISAPIOnlyCPUTime += pReq->ISAPICPUTime;
            IIS->TotalErrorASPOnlyCPUTime += pReq->ASPCPUTime;

            IIS->TotalErrorW3OnlyResponseTime += (pReq->W3EndTime - pReq->W3StartTime)
                                            - pReq->W3FilterResponseTime;
            if (pReq->ULStartTime != 0 && pReq->ULEndTime != 0 && pReq->ULDeliverTime != 0 && pReq->ULReceiveTime != 0) {
                // ????????????????????????????????????????????????????????????????????????
                // TotalErrorULOnlyResponseTime += (pReq->ULDeliverTime - pReq->ULStartTime)
                //                                + (pReq->ULEndTime - pReq->ULReceiveTime);
                IIS->TotalErrorULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            else { 
                IIS->TotalErrorULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            IIS->TotalErrorW3FilterResponseTime += pReq->W3FilterResponseTime;
        }                
        else if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_FILEREQ) {
            IIS->W3FileRequests++;
            IIS->TotalFileResponseTime += pReq->ULResponseTime;
            IIS->FileCPUTime += pReq->KCPUTime + pReq->UCPUTime;
            IIS->TotalFileULOnlyCPUTime += pReq->ULCPUTime;
            IIS->TotalFileW3OnlyCPUTime += pReq->W3CPUTime;
            IIS->TotalFileW3FilterCPUTime += pReq->W3FltrCPUTime;
            if (pSite != NULL) { 
                pSite->FileRequests++;
            }
            IIS->TotalFileW3OnlyResponseTime += (pReq->W3EndTime - pReq->W3StartTime)
                                            - pReq->W3FilterResponseTime;
            if (pReq->ULStartTime != 0 && pReq->ULEndTime != 0 && pReq->ULDeliverTime != 0 && pReq->ULReceiveTime != 0) {
                // ????????????????????????????????????????????????????????????????????????
                // TotalFileULOnlyResponseTime += (pReq->ULDeliverTime - pReq->ULStartTime)
                //                                 + (pReq->ULEndTime - pReq->ULReceiveTime);
                IIS->TotalFileULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            else {
                IIS->TotalFileULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            IIS->TotalFileW3FilterResponseTime += pReq->W3FilterResponseTime;
        }
        else if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_CGIREQ) {
            IIS->W3CGIRequests++;
            IIS->TotalCGIResponseTime += pReq->ULResponseTime;
            IIS->TotalCGIOnlyResponseTime += (localCGIEndTime - pReq->CGIStartTime); 
            IIS->CGICPUTime += pReq->KCPUTime + pReq->UCPUTime;
            IIS->TotalCGIOnlyCPUTime += pReq->CGICPUTime;
            IIS->TotalCGIULOnlyCPUTime += pReq->ULCPUTime;
            IIS->TotalCGIW3OnlyCPUTime += pReq->W3CPUTime;
            IIS->TotalCGIW3FilterCPUTime += pReq->W3FltrCPUTime;
            if (pSite != NULL) {
                pSite->CGIRequests++;
            }
            IIS->TotalCGIW3OnlyResponseTime += (pReq->W3EndTime - pReq->W3StartTime)
                                            - (localCGIEndTime - pReq->CGIStartTime)
                                            - pReq->W3FilterResponseTime;
            if (pReq->ULStartTime != 0 && pReq->ULEndTime != 0 && pReq->ULDeliverTime != 0 && pReq->ULReceiveTime != 0) {
                // ????????????????????????????????????????????????????????????????????????
                // TotalCGIULOnlyResponseTime += (pReq->ULDeliverTime - pReq->ULStartTime)
                //                                 + (pReq->ULEndTime - pReq->ULReceiveTime);
                IIS->TotalCGIULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            else {
                IIS->TotalCGIULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            IIS->TotalCGIW3FilterResponseTime += pReq->W3FilterResponseTime;
        }
        else if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_ISAPIREQ) {
            ULONGLONG TimeSpentInAsp = 0;
            ULONGLONG TimeSpentInISAPI = 0;

            if (pReq->ASPStartTime != 0 && localASPEndTime != 0) {
                TimeSpentInAsp = localASPEndTime - pReq->ASPStartTime;
            }
            if (pReq->ISAPIStartTime != 0 && localISAPIEndTime != 0) {
                TimeSpentInISAPI = localISAPIEndTime - pReq->ISAPIStartTime;
                if (TimeSpentInAsp > TimeSpentInISAPI) {
                    TimeSpentInISAPI = 0;
                }
                else {
                    TimeSpentInISAPI -= TimeSpentInAsp;
                }
            }

            IIS->W3ISAPIRequests++;
            IIS->TotalISAPIResponseTime += pReq->ULResponseTime;
            IIS->ISAPICPUTime += pReq->KCPUTime + pReq->UCPUTime;
            if (pSite != NULL) {
                pSite->ISAPIRequests++;
            }
            IIS->TotalASPW3OnlyResponseTime += (((pReq->W3EndTime - pReq->W3StartTime) - pReq->W3FilterResponseTime)
                                             - (TimeSpentInISAPI + TimeSpentInAsp));
            IIS->W3ASPRequests++;
            IIS->TotalASPResponseTime += pReq->ULResponseTime;
            IIS->TotalASPOnlyResponseTime += TimeSpentInAsp; 
            IIS->ASPCPUTime += pReq->KCPUTime + pReq->UCPUTime;
            IIS->TotalASPOnlyCPUTime += pReq->ASPCPUTime;
            IIS->TotalASPULOnlyCPUTime += pReq->ULCPUTime;
            IIS->TotalASPW3OnlyCPUTime += pReq->W3CPUTime;
            IIS->TotalASPW3FilterCPUTime += pReq->W3FltrCPUTime;
            IIS->TotalASPISAPIOnlyCPUTime += pReq->ISAPICPUTime;
            if (pSite != NULL) {
                pSite->ASPRequests++;
            } 
            IIS->TotalASPISAPIOnlyResponseTime += TimeSpentInISAPI;
            if (pReq->ULStartTime != 0 && pReq->ULEndTime != 0 && pReq->ULDeliverTime != 0 && pReq->ULReceiveTime != 0) {
                // ????????????????????????????????????????????????????????????????????????
                // TotalASPULOnlyResponseTime += (pReq->ULDeliverTime - pReq->ULStartTime)
                //                                 + (pReq->ULEndTime - pReq->ULReceiveTime);
                IIS->TotalASPULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            else {
                IIS->TotalASPULOnlyResponseTime += pReq->ULResponseTime - (pReq->W3EndTime - pReq->W3StartTime);
            }
            IIS->TotalASPW3FilterResponseTime += pReq->W3FilterResponseTime;
        }
        else if (pReq->W3ProcessType == EVENT_TRACE_TYPE_W3CORE_OOPREQ) { // ???
            IIS->W3OOPRequests++;
            IIS->TotalOOPResponseTime += pReq->ULResponseTime; 
            IIS->OOPCPUTime += pReq->KCPUTime + pReq->UCPUTime;
            if (pSite != NULL) {
                pSite->OOPRequests++;
            }
        }
    }

    IIS->TotalRequests++;
    IIS->TotalCPUTime += pReq->KCPUTime + pReq->UCPUTime;

    if (pReq->URL != NULL) {
        free(pReq->URL);
    }
}

static void ReportIisEvents(void)
{
    HTTP_REQUEST_RECORD Req, *pReq;
    char* s; 
    char line[MAXSTR];

    URL_RECORD TopHitURLs[DISPLAY_SIZE];
    URL_RECORD TopHitStaticURLs[DISPLAY_SIZE];
    URL_RECORD TopSlowURLs[DISPLAY_SIZE];
    URL_RECORD TopConsumingURLs[DISPLAY_SIZE];
    URL_RECORD TopBytesURLs[DISPLAY_SIZE];
    PURL_RECORD pUrl;

    CLIENT_RECORD TopHitClients[DISPLAY_SIZE];
    CLIENT_RECORD TopSlowClients[DISPLAY_SIZE];
    CLIENT_RECORD TopBytesClients[DISPLAY_SIZE];
    PCLIENT_RECORD pClient;

    SITE_RECORD TopHitSites[DISPLAY_SIZE];
    SITE_RECORD TopSlowSites[DISPLAY_SIZE];
    SITE_RECORD TopConsumingSites[DISPLAY_SIZE];
    SITE_RECORD TopBytesSites[DISPLAY_SIZE];
    PSITE_RECORD pSite;

    ULONG i, k;
    ULONG Duration = (ULONG)((CurrentSystem.IISEndTime - CurrentSystem.IISStartTime) / 10000000);
    ULONG MilDuration = (ULONG)((CurrentSystem.IISEndTime - CurrentSystem.IISStartTime) * CurrentSystem.NumberOfProcessors / 10000);
    double Rates = 0.0;
    PLIST_ENTRY Next, Head;
    ULONG PrintCPUUsage = TRUE;

    if( NULL == CurrentSystem.TempIisFile ){
        return;
    }

    IIS = (PIIS_REPORT_RECORD)malloc(sizeof(IIS_REPORT_RECORD));
    if (IIS == NULL) {
        return;
    }
    RtlZeroMemory(IIS, sizeof(IIS_REPORT_RECORD));

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    if( Head == Next ){
        PrintCPUUsage = FALSE;
    }

    pReq = &Req;

    RtlZeroMemory(pReq, sizeof(HTTP_REQUEST_RECORD));
    RtlZeroMemory(line, MAXSTR * sizeof(char));

    // Process requests written in the file
    rewind( CurrentSystem.TempIisFile );
    while ( fgets(line, MAXSTR, CurrentSystem.TempIisFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pReq->RequestId = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->SiteId = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->KCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->UCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ReadIO = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->WriteIO = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULStartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULEndTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULResponseTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULParseTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULDeliverTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULReceiveTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULReceiveType = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULEndType = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3StartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3EndTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3FilterResponseTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3ProcessType = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3EndType = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->FileReqTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->CGIStartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->CGIEndTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ISAPIStartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ISAPIEndTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ASPStartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ASPEndTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->SSLResponseTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->StrmFltrResponseTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->HttpStatus = (USHORT) atol(s);;
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IsapiExt = (USHORT) atol(s);;
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrType = (USHORT) atol(s);;

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV4 = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[0] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[1] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[2] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[3] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[4] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[5] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[6] = (USHORT) atol(s);;
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->IpAddrV6[7] = (USHORT) atol(s);;
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->NumberOfThreads = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->BytesSent = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ULCPUTime = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3CPUTime = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->W3FltrCPUTime = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ISAPICPUTime = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->ASPCPUTime = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pReq->CGICPUTime = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        if (strlen(s) > 0) {
            LPSTR strptr = (LPSTR)malloc(strlen(s) + 1);
            if (strptr != NULL) {
                RtlCopyMemory((PUCHAR)strptr, (PUCHAR)s, strlen(s));
                if (*(strptr + strlen(s) - 1) == '\n') {
                    *(strptr + strlen(s) - 1) = '\0';
                }
                else {
                    *(strptr + strlen(s)) = '\0';
                }
                pReq->URL = (PCHAR)strptr;
            }
            else {
                continue;
            }
        }
        else {
            continue;
        }

        ProcessIisRequest(pReq);

    }

    if (IIS->TotalRequests != 0) {
        if (Duration != 0) {
            Rates = (double)(IIS->TotalRequests) / (double)Duration;
        }
        else {
            Rates = 0.0;
        }
    }
    else {
        free(IIS);
        return;
    }

    fprintf(procFile, "<table title='Http Requests Response Time Statistics'>\n");
    fprintf(procFile, 
        "<requests cached='true' type='Static HTTP'>"
        "<rate>%1.3f</rate>"
        "<response_time>%1.3f</response_time>"
        "<component name='UL'>%3d.0</component>"
        "<component name='W3'>0.0</component>"
        "<component name='W3Fltr'>0.0</component>"
        "<component name='ISAPI'>0.0</component>"
        "<component name='ASP'>0.0</component>"
        "<component name='CGI'>0.0</component>"
        "</requests>\n",
        Duration ? (double)(IIS->CachedResponses) / (double)Duration : 0.0,
        IIS->CachedResponses ? (double)(IIS->TotalCachedResponseTime / IIS->CachedResponses) / 10000.0 : 0.0,
        IIS->CachedResponses ? 100 : 0);
    fprintf(procFile, 
        "<requests cached='false' type='ASP'>"
        "<rate>%1.3f</rate>"
        "<response_time>%1.3f</response_time>"
        "<component name='UL'>%1.1f</component>"
        "<component name='W3'>%1.1f</component>"
        "<component name='W3Fltr'>%1.1f</component>"
        "<component name='ISAPI'>%1.1f</component>"
        "<component name='ASP'>%1.1f</component>"
        "<component name='CGI'>%1.1f</component>"
        "</requests>\n",
        Duration ? (double)(IIS->W3ISAPIRequests) / (double)Duration : 0.0,
        (IIS->W3ISAPIRequests) ? ((double)IIS->TotalISAPIResponseTime / (double)IIS->W3ISAPIRequests) / 10000.0 : 0.0,
        ((IIS->TotalASPResponseTime) ? ((double)(IIS->TotalASPULOnlyResponseTime) / (double)(IIS->TotalASPResponseTime)) * 100.0 : 0.0),
        ((IIS->TotalASPResponseTime) ? ((double)(IIS->TotalASPW3OnlyResponseTime) / (double)(IIS->TotalASPResponseTime)) * 100.0 : 0.0),
        ((IIS->TotalASPResponseTime) ? ((double)(IIS->TotalASPW3FilterResponseTime) / (double)(IIS->TotalASPResponseTime)) * 100.0 : 0.0),
        ((IIS->TotalASPResponseTime) ? ((double)(IIS->TotalASPISAPIOnlyResponseTime) / (double)(IIS->TotalASPResponseTime)) * 100.0 : 0.0),
        ((IIS->TotalASPResponseTime) ? ((double)(IIS->TotalASPOnlyResponseTime) / (double)(IIS->TotalASPResponseTime)) * 100.0 : 0.0),
        0.0);
    fprintf(procFile, 
        "<requests cached='false' type='Static HTTP'>"
        "<rate>%1.3f</rate>"
        "<response_time>%1.3f</response_time>"
        "<component name='UL'>%1.1f</component>"
        "<component name='W3'>%1.1f</component>"
        "<component name='W3Fltr'>%1.1f</component>"
        "<component name='ISAPI'>%1.1f</component>"
        "<component name='ASP'>%1.1f</component>"
        "<component name='CGI'>%1.1f</component>"
        "</requests>\n",
        Duration ? (double)(IIS->W3FileRequests) / (double)Duration : 0.0,
        (IIS->W3FileRequests) ? ((double)IIS->TotalFileResponseTime / (double)IIS->W3FileRequests) / 10000.0 : 0.0,
        (IIS->TotalFileResponseTime ? ((double)(IIS->TotalFileULOnlyResponseTime) / (double)(IIS->TotalFileResponseTime)) * 100.0 : 0.0),
        (IIS->TotalFileResponseTime ? ((double)(IIS->TotalFileW3OnlyResponseTime) / (double)(IIS->TotalFileResponseTime)) * 100.0 : 0.0),
        (IIS->TotalFileResponseTime ? ((double)(IIS->TotalFileW3FilterResponseTime) / (double)(IIS->TotalFileResponseTime)) * 100.0 : 0.0),
        0.0,
        0.0,
        0.0);
    fprintf(procFile, 
        "<requests cached='false' type='CGI'>"
        "<rate>%1.3f</rate>"
        "<response_time>%1.3f</response_time>"
        "<component name='UL'>%1.1f</component>"
        "<component name='W3'>%1.1f</component>"
        "<component name='W3Fltr'>%1.1f</component>"
        "<component name='ISAPI'>%1.1f</component>"
        "<component name='ASP'>%1.1f</component>"
        "<component name='CGI'>%1.1f</component>"
        "</requests>\n",
        Duration ? (double)(IIS->W3CGIRequests) / (double)Duration : 0.0,
        (IIS->W3CGIRequests) ? ((double)IIS->TotalCGIResponseTime / (double)IIS->W3CGIRequests) / 10000.0 : 0.0,
        ((IIS->TotalCGIResponseTime) ? ((double)(IIS->TotalCGIULOnlyResponseTime) / (double)(IIS->TotalCGIResponseTime)) * 100.0 : 0.0),
        ((IIS->TotalCGIResponseTime) ? ((double)(IIS->TotalCGIW3OnlyResponseTime) / (double)(IIS->TotalCGIResponseTime)) * 100.0 : 0.0),
        ((IIS->TotalCGIResponseTime) ? ((double)(IIS->TotalCGIW3FilterResponseTime) / (double)(IIS->TotalCGIResponseTime)) * 100.0 : 0.0),
        0.0,
        0.0,
        ((IIS->TotalCGIResponseTime) ? ((double)(IIS->TotalCGIOnlyResponseTime) / (double)(IIS->TotalCGIResponseTime)) * 100.0 : 0.0));

    if (IIS->W3Error != 0) {
        fprintf(procFile, 
            "<requests cached='false' type='Error'>"
            "<rate>%1.3f</rate>"
            "<response_time>%1.3f</response_time>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</requests>\n",
            Duration ? (double)(IIS->W3Error) / (double)Duration : 0.0,
            (IIS->W3Error) ? ((double)IIS->TotalErrorResponseTime / (double)IIS->W3Error) / 10000.0 : 0.0,
            ((IIS->TotalErrorResponseTime) ? ((double)(IIS->TotalErrorULOnlyResponseTime) / (double)(IIS->TotalErrorResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalErrorResponseTime) ? ((double)(IIS->TotalErrorW3OnlyResponseTime) / (double)(IIS->TotalErrorResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalErrorResponseTime) ? ((double)(IIS->TotalErrorW3FilterResponseTime) / (double)(IIS->TotalErrorResponseTime)) * 100.0 : 0.0),
            0.0,
            0.0,
            0.0);
    }

    fprintf(procFile, 
            "<summary cached='true'>"
            "<rate>%1.3f</rate>"
            "<response_time>%1.3f</response_time>"
            "<component name='UL'>%3d.0</component>"
            "<component name='W3'>0.0</component>"
            "<component name='W3Fltr'>0.0</component>"
            "<component name='ISAPI'>0.0</component>"
            "<component name='ASP'>0.0</component>"
            "<component name='CGI'>0.0</component>"
            "</summary>\n",
            Duration ? (double)(IIS->CachedResponses) / (double)Duration : 0.0,
            IIS->CachedResponses ? (double)(IIS->TotalCachedResponseTime / IIS->CachedResponses) / 10000.0 : 0.0,
            IIS->CachedResponses ? 100 : 0);

    fprintf(procFile, 
            "<summary cached='false'>"
            "<rate percent='%1.3f'>%1.3f</rate>"
            "<response_time>%1.3f</response_time>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</summary>\n",
            ((double)(IIS->TotalRequests - IIS->CachedResponses) / ((double)IIS->TotalRequests)) * 100.0,
            Duration ? (double)(IIS->TotalRequests - IIS->CachedResponses) / (double)Duration : 0.0,
            (IIS->TotalRequests - IIS->CachedResponses) ? ((double)IIS->TotalNonCachedResponseTime / (double)(IIS->TotalRequests - IIS->CachedResponses)) / 10000.0 : 0.0,
            ((IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalFileULOnlyResponseTime + IIS->TotalCGIULOnlyResponseTime + IIS->TotalASPULOnlyResponseTime + IIS->TotalErrorULOnlyResponseTime) / (double)(IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalFileW3OnlyResponseTime + IIS->TotalCGIW3OnlyResponseTime + IIS->TotalASPW3OnlyResponseTime + IIS->TotalErrorW3OnlyResponseTime) / (double)(IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalW3FilterResponseTime) / (double)(IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalASPISAPIOnlyResponseTime) / (double)(IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalASPOnlyResponseTime) / (double)(IIS->TotalNonCachedResponseTime)) * 100.0: 0.0),
            ((IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalCGIOnlyResponseTime) / (double)(IIS->TotalNonCachedResponseTime)) * 100.0: 0.0));

    fprintf(procFile, 
            "<summary type='totals'>"
            "<rate>%1.3f</rate>"
            "<response_time>%1.3f</response_time>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</summary>\n",
            Duration ? (double)(IIS->TotalRequests) / (double)Duration : 0.0,
            ((double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) / (double)IIS->TotalRequests) / 10000.0,
            ((IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalCachedResponseTime + IIS->TotalFileULOnlyResponseTime + IIS->TotalCGIULOnlyResponseTime + IIS->TotalASPULOnlyResponseTime + IIS->TotalErrorULOnlyResponseTime) / (double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalFileW3OnlyResponseTime + IIS->TotalCGIW3OnlyResponseTime + IIS->TotalASPW3OnlyResponseTime + IIS->TotalErrorW3OnlyResponseTime) / (double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalW3FilterResponseTime) / (double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalASPISAPIOnlyResponseTime) / (double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalASPOnlyResponseTime) / (double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0),
            ((IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime) ? ((double)(IIS->TotalCGIOnlyResponseTime) / (double)(IIS->TotalCachedResponseTime + IIS->TotalNonCachedResponseTime)) * 100.0 : 0.0));
    
    fprintf(procFile, "</table>\n");

    if (PrintCPUUsage) {
        fprintf(procFile, "<table title='Http Requests CPU Time Usage Statistics'>\n");
        fprintf(procFile, 
            "<requests cached='true'  type='Static HTTP'>"
            "<rate>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%3d.0</component>"
            "<component name='W3'>0.0</component>"
            "<component name='W3Fltr'>0.0</component>"
            "<component name='ISAPI'>0.0</component>"
            "<component name='ASP'>0.0</component>"
            "<component name='CGI'>0.0</component>"
            "</requests>\n",
            Duration ? (double)(IIS->CachedResponses) / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->CachedCPUTime) / (double)MilDuration) * 100.0) : 0.0,
            IIS->CachedResponses ? 100 : 0);
        fprintf(procFile, 
            "<requests cached='false' type='ASP'>"
            "<rate>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</requests>\n",
            Duration ? (double)(IIS->W3ISAPIRequests) / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->ISAPICPUTime) / (double)MilDuration) * 100.0) : 0.0,
            ((IIS->ASPCPUTime) ? ((double)(IIS->TotalASPULOnlyCPUTime) / (double)(IIS->ASPCPUTime)) * 100.0 : 0.0),
            ((IIS->ASPCPUTime) ? ((double)(IIS->TotalASPW3OnlyCPUTime) / (double)(IIS->ASPCPUTime)) * 100.0 : 0.0),
            ((IIS->ASPCPUTime) ? ((double)(IIS->TotalASPW3FilterCPUTime) / (double)(IIS->ASPCPUTime)) * 100.0 : 0.0),
            ((IIS->ASPCPUTime) ? ((double)(IIS->TotalASPISAPIOnlyCPUTime) / (double)(IIS->ASPCPUTime)) * 100.0 : 0.0),
            ((IIS->ASPCPUTime) ? ((double)(IIS->TotalASPOnlyCPUTime) / (double)(IIS->ASPCPUTime)) * 100.0: 0.0),
            0.0);
        fprintf(procFile, 
            "<requests cached='false' type='Static HTTP'>"
            "<rate>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</requests>\n",
            Duration ? (double)(IIS->W3FileRequests) / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->FileCPUTime) / (double)MilDuration) * 100.0) : 0.0,
            ((IIS->FileCPUTime) ? ((double)(IIS->TotalFileULOnlyCPUTime) / (double)(IIS->FileCPUTime)) * 100.0 : 0.0),
            ((IIS->FileCPUTime) ? ((double)(IIS->TotalFileW3OnlyCPUTime) / (double)(IIS->FileCPUTime)) * 100.0 : 0.0),
            ((IIS->FileCPUTime) ? ((double)(IIS->TotalFileW3FilterCPUTime) / (double)(IIS->FileCPUTime)) * 100.0 : 0.0),
            0.0,
            0.0,
            0.0);
        fprintf(procFile, 
            "<requests cached='false' type='CGI'>"
            "<rate>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</requests>\n",
            Duration ? (double)(IIS->W3CGIRequests) / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->CGICPUTime) / (double)MilDuration) * 100.0) : 0.0,
            ((IIS->CGICPUTime) ? ((double)(IIS->TotalCGIULOnlyCPUTime) / (double)(IIS->CGICPUTime)) * 100.0 : 0.0),
            ((IIS->CGICPUTime) ? ((double)(IIS->TotalCGIW3OnlyCPUTime) / (double)(IIS->CGICPUTime)) * 100.0 : 0.0),
            ((IIS->CGICPUTime) ? ((double)(IIS->TotalCGIW3FilterCPUTime) / (double)(IIS->CGICPUTime)) * 100.0 : 0.0),
            0.0,
            0.0,
            ((IIS->CGICPUTime) ? ((double)(IIS->TotalCGIOnlyCPUTime) / (double)(IIS->CGICPUTime)) * 100.0 : 0.0));

        if (IIS->W3Error != 0) {
            fprintf(procFile, 
                "<requests cached='false' type='Error'>"
                "<rate>%1.3f</rate>"
                "<cpu>%1.1f</cpu>"
                "<component name='UL'>%1.1f</component>"
                "<component name='W3'>%1.1f</component>"
                "<component name='W3Fltr'>%1.1f</component>"
                "<component name='ISAPI'>%1.1f</component>"
                "<component name='ASP'>%1.1f</component>"
                "<component name='CGI'>%1.1f</component>"
                "</requests>\n",
                Duration ? (double)(IIS->W3Error) / (double)Duration : 0.0,
                MilDuration ? (((double)(IIS->ErrorCPUTime) / (double)MilDuration) * 100.0) : 0.0,
                ((IIS->ErrorCPUTime) ? ((double)(IIS->TotalErrorULOnlyCPUTime) / (double)(IIS->ErrorCPUTime)) * 100.0 : 0.0),
                ((IIS->ErrorCPUTime) ? ((double)(IIS->TotalErrorW3OnlyCPUTime) / (double)(IIS->ErrorCPUTime)) * 100.0 : 0.0),
                ((IIS->ErrorCPUTime) ? ((double)(IIS->TotalErrorW3FilterCPUTime) / (double)(IIS->ErrorCPUTime)) * 100.0 : 0.0),
                0.0,
                0.0,
                0.0);
        }
        
        fprintf(procFile, 
            "<summary cached='true'>"
            "<rate>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%3d.0</component>"
            "<component name='W3'>0.0</component>"
            "<component name='W3Fltr'>0.0</component>"
            "<component name='ISAPI'>0.0</component>"
            "<component name='ASP'>0.0</component>"
            "<component name='CGI'>0.0</component>"
            "</summary>\n",
            Duration ? (double)(IIS->CachedResponses) / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->CachedCPUTime) / (double)MilDuration) * 100.0) : 0.0,
            IIS->CachedResponses ? 100 : 0);

        fprintf(procFile, 
            "<summary cached='false'>"
            "<rate percent='%1.1f'>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</summary>\n",
            ((double)(IIS->TotalRequests - IIS->CachedResponses) / ((double)IIS->TotalRequests)) * 100.0,
            Duration ? (double)(IIS->TotalRequests - IIS->CachedResponses) / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->NonCachedCPUTime) / (double)MilDuration) * 100.0) : 0.0,
            ((IIS->NonCachedCPUTime) ? ((double)(IIS->TotalFileULOnlyCPUTime + IIS->TotalCGIULOnlyCPUTime + IIS->TotalASPULOnlyCPUTime + IIS->TotalErrorULOnlyCPUTime) / (double)(IIS->NonCachedCPUTime)) * 100.0 : 0.0),
            ((IIS->NonCachedCPUTime) ? ((double)(IIS->TotalFileW3OnlyCPUTime + IIS->TotalCGIW3OnlyCPUTime + IIS->TotalASPW3OnlyCPUTime + IIS->TotalErrorW3OnlyCPUTime) / (double)(IIS->NonCachedCPUTime)) * 100.0 : 0.0),
            ((IIS->NonCachedCPUTime) ? ((double)(IIS->TotalW3FilterCPUTime) / (double)(IIS->NonCachedCPUTime)) * 100.0 : 0.0),
            ((IIS->NonCachedCPUTime) ? ((double)(IIS->TotalASPISAPIOnlyCPUTime) / (double)(IIS->NonCachedCPUTime)) * 100.0 : 0.0),
            ((IIS->NonCachedCPUTime) ? ((double)(IIS->TotalASPOnlyCPUTime) / (double)(IIS->NonCachedCPUTime)) * 100.0: 0.0),
            ((IIS->NonCachedCPUTime) ? ((double)(IIS->TotalCGIOnlyCPUTime) / (double)(IIS->NonCachedCPUTime)) * 100.0: 0.0));

        fprintf(procFile, 
            "<summary type='totals'>"
            "<rate>%1.3f</rate>"
            "<cpu>%1.1f</cpu>"
            "<component name='UL'>%1.1f</component>"
            "<component name='W3'>%1.1f</component>"
            "<component name='W3Fltr'>%1.1f</component>"
            "<component name='ISAPI'>%1.1f</component>"
            "<component name='ASP'>%1.1f</component>"
            "<component name='CGI'>%1.1f</component>"
            "</summary>\n",
            Duration ? (double)IIS->TotalRequests / (double)Duration : 0.0,
            MilDuration ? (((double)(IIS->TotalCPUTime) / (double)MilDuration) * 100.0) : 0.0,
            ((IIS->TotalCPUTime) ? ((double)(IIS->CachedCPUTime + IIS->TotalFileULOnlyCPUTime + IIS->TotalCGIULOnlyCPUTime + IIS->TotalASPULOnlyCPUTime + IIS->TotalErrorULOnlyCPUTime) / (double)(IIS->TotalCPUTime)) * 100.0 : 0.0),
            ((IIS->TotalCPUTime) ? ((double)(IIS->TotalFileW3OnlyCPUTime + IIS->TotalCGIW3OnlyCPUTime + IIS->TotalASPW3OnlyCPUTime + IIS->TotalErrorW3OnlyCPUTime) / (double)(IIS->TotalCPUTime)) * 100.0 : 0.0),
            ((IIS->TotalCPUTime) ? ((double)(IIS->TotalW3FilterCPUTime) / (double)(IIS->TotalCPUTime)) * 100.0 : 0.0),
            ((IIS->TotalCPUTime) ? ((double)(IIS->TotalASPISAPIOnlyCPUTime) / (double)(IIS->TotalCPUTime)) * 100.0 : 0.0),
            ((IIS->TotalCPUTime) ? ((double)(IIS->TotalASPOnlyCPUTime) / (double)(IIS->TotalCPUTime)) * 100.0: 0.0),
            ((IIS->TotalCPUTime) ? ((double)(IIS->TotalCGIOnlyCPUTime) / (double)(IIS->TotalCPUTime)) * 100.0: 0.0));
    
        fprintf(procFile, "</table>\n");

    }

    RtlZeroMemory(TopHitURLs, sizeof(URL_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopHitStaticURLs, sizeof(URL_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopSlowURLs, sizeof(URL_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopConsumingURLs, sizeof(URL_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopBytesURLs, sizeof(URL_RECORD) * DISPLAY_SIZE);
    for (k = 0; k < URL_HASH_TABLESIZE; k++) {
        pUrl = GetHeadUrlRecord(k);
        while (pUrl != NULL) {
            ULONGLONG AverageURLResponseTime = 0;
            ULONG Found;
            URL_RECORD tmpUrl1, tmpUrl2;
            if (pUrl->Requests != 0) {
                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                RtlZeroMemory(&tmpUrl2, sizeof(URL_RECORD));
                Found = FALSE;
                for (i = 0; i < DISPLAY_SIZE; i++) {
                    if (Found && tmpUrl1.Requests != 0) {
                        RtlCopyMemory(&tmpUrl2, &TopHitURLs[i], sizeof(URL_RECORD));
                        RtlCopyMemory(&TopHitURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                        RtlCopyMemory(&tmpUrl1, &tmpUrl2, sizeof(URL_RECORD));
                    }
                    else if (!Found) {
                        if (TopHitURLs[i].Requests == 0) {
                            RtlCopyMemory(&TopHitURLs[i], pUrl, sizeof(URL_RECORD));
                            TopHitURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopHitURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlZeroMemory(&TopHitURLs[i], sizeof(URL_RECORD));
                            }
                        }
                        else if (pUrl->Requests > TopHitURLs[i].Requests) {
                            RtlCopyMemory(&tmpUrl1, &TopHitURLs[i], sizeof(URL_RECORD));
                            RtlCopyMemory(&TopHitURLs[i], pUrl, sizeof(URL_RECORD));
                            TopHitURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopHitURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlCopyMemory(&TopHitURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                            }
                        }
                    }
                }
                if (tmpUrl1.Requests != 0) {
                    free(tmpUrl1.URL);
                }
                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                RtlZeroMemory(&tmpUrl2, sizeof(URL_RECORD));
                Found = FALSE;
                for (i = 0; i < DISPLAY_SIZE; i++) {
                    if (Found && tmpUrl1.Requests != 0) {
                        RtlCopyMemory(&tmpUrl2, &TopHitStaticURLs[i], sizeof(URL_RECORD));
                        RtlCopyMemory(&TopHitStaticURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                        RtlCopyMemory(&tmpUrl1, &tmpUrl2, sizeof(URL_RECORD));
                    }
                    else if (!Found) {
                        if ((pUrl->UrlType == EVENT_TRACE_TYPE_W3CORE_FILEREQ || pUrl->Hits > 0) && 
                            TopHitStaticURLs[i].Requests == 0) {

                            RtlCopyMemory(&TopHitStaticURLs[i], pUrl, sizeof(URL_RECORD));
                            TopHitStaticURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopHitStaticURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlZeroMemory(&TopHitStaticURLs[i], sizeof(URL_RECORD));
                            }
                        }
                        else if ((pUrl->UrlType == EVENT_TRACE_TYPE_W3CORE_FILEREQ || pUrl->Hits > 0) && 
                            pUrl->Requests > TopHitStaticURLs[i].Requests) {

                            RtlCopyMemory(&tmpUrl1, &TopHitStaticURLs[i], sizeof(URL_RECORD));
                            RtlCopyMemory(&TopHitStaticURLs[i], pUrl, sizeof(URL_RECORD));
                            TopHitStaticURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopHitStaticURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlCopyMemory(&TopHitStaticURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                            }
                        }
                    }
                }
                if (tmpUrl1.Requests != 0) {
                    free(tmpUrl1.URL);
                }
                AverageURLResponseTime = pUrl->TotalResponseTime / pUrl->Requests;
                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                RtlZeroMemory(&tmpUrl2, sizeof(URL_RECORD));
                Found = FALSE;
                for (i = 0; i < DISPLAY_SIZE; i++) {
                    if (Found && tmpUrl1.Requests != 0) {
                        RtlCopyMemory(&tmpUrl2, &TopSlowURLs[i], sizeof(URL_RECORD));
                        RtlCopyMemory(&TopSlowURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                        RtlCopyMemory(&tmpUrl1, &tmpUrl2, sizeof(URL_RECORD));
                    }
                    else if (!Found) {
                        if (TopSlowURLs[i].Requests == 0) {
                            RtlCopyMemory(&TopSlowURLs[i], pUrl, sizeof(URL_RECORD));
                            TopSlowURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopSlowURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlZeroMemory(&TopSlowURLs[i], sizeof(URL_RECORD));
                            }
                        }
                        else if (AverageURLResponseTime > (TopSlowURLs[i].TotalResponseTime / TopSlowURLs[i].Requests)) {
                            RtlCopyMemory(&tmpUrl1, &TopSlowURLs[i], sizeof(URL_RECORD));
                            RtlCopyMemory(&TopSlowURLs[i], pUrl, sizeof(URL_RECORD));
                            TopSlowURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopSlowURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlCopyMemory(&TopSlowURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                            }
                        }
                    }
                }
                if (tmpUrl1.Requests != 0) {
                    free(tmpUrl1.URL);
                }
                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                RtlZeroMemory(&tmpUrl2, sizeof(URL_RECORD));
                Found = FALSE;
                for (i = 0; i < DISPLAY_SIZE; i++) {
                    if (Found && tmpUrl1.Requests != 0) {
                        RtlCopyMemory(&tmpUrl2, &TopConsumingURLs[i], sizeof(URL_RECORD));
                        RtlCopyMemory(&TopConsumingURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                        RtlCopyMemory(&tmpUrl1, &tmpUrl2, sizeof(URL_RECORD));
                    }
                    else if (!Found) {
                        if (TopConsumingURLs[i].Requests == 0) {
                            RtlCopyMemory(&TopConsumingURLs[i], pUrl, sizeof(URL_RECORD));
                            TopConsumingURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopConsumingURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlZeroMemory(&TopConsumingURLs[i], sizeof(URL_RECORD));
                            }
                        }
                        else if ((pUrl->KCPUTime + pUrl->UCPUTime) > (TopConsumingURLs[i].KCPUTime + TopConsumingURLs[i].UCPUTime)) {
                            RtlCopyMemory(&tmpUrl1, &TopConsumingURLs[i], sizeof(URL_RECORD));
                            RtlCopyMemory(&TopConsumingURLs[i], pUrl, sizeof(URL_RECORD));
                            TopConsumingURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopConsumingURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlCopyMemory(&TopConsumingURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                            }
                        }
                    }
                }
                if (tmpUrl1.Requests != 0) {
                    free(tmpUrl1.URL);
                }
                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                RtlZeroMemory(&tmpUrl2, sizeof(URL_RECORD));
                Found = FALSE;
                for (i = 0; i < DISPLAY_SIZE; i++) {
                    if (Found && tmpUrl1.Requests != 0) {
                        RtlCopyMemory(&tmpUrl2, &TopBytesURLs[i], sizeof(URL_RECORD));
                        RtlCopyMemory(&TopBytesURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                        RtlCopyMemory(&tmpUrl1, &tmpUrl2, sizeof(URL_RECORD));
                    }
                    else if (!Found) {
                        if (TopBytesURLs[i].Requests == 0) {
                            RtlCopyMemory(&TopBytesURLs[i], pUrl, sizeof(URL_RECORD));
                            TopBytesURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopBytesURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlZeroMemory(&TopBytesURLs[i], sizeof(URL_RECORD));
                            }
                        }
                        else if (pUrl->BytesSent > TopBytesURLs[i].BytesSent) {
                            RtlCopyMemory(&tmpUrl1, &TopBytesURLs[i], sizeof(URL_RECORD));
                            RtlCopyMemory(&TopBytesURLs[i], pUrl, sizeof(URL_RECORD));
                            TopBytesURLs[i].URL = CopyUrlStr(pUrl->URL);
                            if (TopBytesURLs[i].URL != NULL) {
                                Found = TRUE;
                            }
                            else {
                                RtlCopyMemory(&TopBytesURLs[i], &tmpUrl1, sizeof(URL_RECORD));
                                RtlZeroMemory(&tmpUrl1, sizeof(URL_RECORD));
                            }
                        }
                    }
                }
                if (tmpUrl1.Requests != 0) {
                    free(tmpUrl1.URL);
                }
            }
            if (pUrl->URL) {
                free(pUrl->URL);
            }
            free(pUrl);
 
            pUrl = GetHeadUrlRecord(k);
        }
    }

    fprintf( procFile, "<table title='Most Requested URLs' top='%d'>", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopHitURLs[i].Requests != 0; i++) {
        ULONGLONG AverageURLResponseTime = 0;
        CHAR ReducedUrl[URL_NAME_COLUMN_SIZE + 1];
        char* strPrint;

        if (TopHitURLs[i].Requests != 0) {
            AverageURLResponseTime = TopHitURLs[i].TotalResponseTime / TopHitURLs[i].Requests;
        }
        RemoveCtrlCharA(TopHitURLs[i].URL, strlen(TopHitURLs[i].URL));
        if (strlen(TopHitURLs[i].URL) > URL_NAME_COLUMN_SIZE) {
            ReduceStringA(ReducedUrl, URL_NAME_COLUMN_SIZE + 1, TopHitURLs[i].URL);
            strPrint = ReducedUrl;
        }else{
            strPrint = TopHitURLs[i].URL;
        }
        fprintf(procFile, 
            "<url name='%s'>"
            "<site_id>%d</site_id>"
            "<rate>%1.3f</rate>"
            "<cache_hit>%1.1f</cache_hit>"
            "<response_time>%1.1f</response_time>"
            "</url>\n", 
            strPrint,
            TopHitURLs[i].SiteId,
            (Duration ? ((double)TopHitURLs[i].Requests / (double)Duration) : 0.0),
            TopHitURLs[i].Requests ? ((double)TopHitURLs[i].Hits / (double)TopHitURLs[i].Requests * 100.0) : 0.0,
            ((double)AverageURLResponseTime) / 10000.0);

    }
    
    fprintf( procFile, "</table>\n" );
    fprintf(procFile,  "<table title='Most Requested Static URLs' top='%d'>\n", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopHitStaticURLs[i].Requests != 0; i++) {
        char* strPrint;
        ULONGLONG AverageURLResponseTime = 0;
        CHAR ReducedUrl[URL_NAME_COLUMN_SIZE + 1];

        if (TopHitStaticURLs[i].Requests != 0) {
            AverageURLResponseTime = TopHitStaticURLs[i].TotalResponseTime / TopHitStaticURLs[i].Requests;
        }
        RemoveCtrlCharA(TopHitStaticURLs[i].URL, strlen(TopHitStaticURLs[i].URL));
        if (strlen(TopHitStaticURLs[i].URL) > URL_NAME_COLUMN_SIZE) {
            ReduceStringA(ReducedUrl, URL_NAME_COLUMN_SIZE + 1, TopHitStaticURLs[i].URL);
            strPrint = ReducedUrl;
        }else{
            strPrint = TopHitStaticURLs[i].URL;
        }
        fprintf(procFile,
            "<url name='%s'>"
            "<site_id>%d</site_id>"
            "<rate>%1.3f</rate>"
            "<cache_hit>%1.1f</cache_hit>"
            "<response_time>%1.1f</response_time>"
            "</url>\n", 
            strPrint,
            TopHitStaticURLs[i].SiteId,
            (Duration ? ((double)TopHitStaticURLs[i].Requests / (double)Duration) : 0.0),
            TopHitStaticURLs[i].Requests ? ((double)TopHitStaticURLs[i].Hits / (double)TopHitStaticURLs[i].Requests * 100.0) : 0.0,
            ((double)AverageURLResponseTime) / 10000.0);
    }
    
    fprintf(procFile,  "</table>\n");
    fprintf(procFile,  "<table title='Slowest URLs' top='%d'>\n", DISPLAY_SIZE );

    for (i = 0; i < DISPLAY_SIZE && TopSlowURLs[i].Requests != 0; i++) {
        char* strPrint;
        ULONGLONG AverageURLResponseTime = 0;
        CHAR ReducedUrl[URL_NAME_COLUMN_SIZE + 1];

        if (TopSlowURLs[i].Requests != 0) {
            AverageURLResponseTime = TopSlowURLs[i].TotalResponseTime / TopSlowURLs[i].Requests;
        }
        RemoveCtrlCharA(TopSlowURLs[i].URL, strlen(TopSlowURLs[i].URL));
        if (strlen(TopSlowURLs[i].URL) > URL_NAME_COLUMN_SIZE) {
            ReduceStringA(ReducedUrl, URL_NAME_COLUMN_SIZE + 1, TopSlowURLs[i].URL);
            strPrint = ReducedUrl;
        }else{
            strPrint = TopSlowURLs[i].URL;
        }
        fprintf(procFile, 
            "<url name='%s'>"
            "<site_id>%d</site_id>"
            "<rate>%1.3f</rate>"
            "<cache_hit>%1.1f</cache_hit>"
            "<response_time>%1.1f</response_time>"
            "</url>\n", 
            strPrint,
            TopSlowURLs[i].SiteId,
            (Duration ? ((double)TopSlowURLs[i].Requests / (double)Duration) : 0.0),
            TopSlowURLs[i].Requests ? ((double)TopSlowURLs[i].Hits / (double)TopSlowURLs[i].Requests * 100.0) : 0.0,
            ((double)AverageURLResponseTime) / 10000.0);
    }
    fprintf(procFile,  "</table>\n" );

    if (PrintCPUUsage) {
        
        fprintf(procFile, "<table title='URLs with the Most CPU Usage' top='%d'>\n", DISPLAY_SIZE);

        for (i = 0; i < DISPLAY_SIZE && TopConsumingURLs[i].Requests != 0; i++) {
            
            char* strPrint;
            CHAR ReducedUrl[URL_NAME_COLUMN_SIZE + 1];
            RemoveCtrlCharA(TopConsumingURLs[i].URL, strlen(TopConsumingURLs[i].URL));
            if (strlen(TopConsumingURLs[i].URL) > URL_NAME_COLUMN_SIZE) {
                ReduceStringA(ReducedUrl, URL_NAME_COLUMN_SIZE + 1, TopConsumingURLs[i].URL);
                strPrint = ReducedUrl;
            }else{
                strPrint = TopConsumingURLs[i].URL;
            }

            fprintf(procFile, 
                "<url name='%s'>"
                "<site_id>%d</site_id>"
                "<rate>%1.3f</rate>"
                "<cpu>%1.2f</cpu>"
                "</url>\n", 
                strPrint,
                TopConsumingURLs[i].SiteId,
                (Duration ? ((double)TopConsumingURLs[i].Requests / (double)Duration) : 0.0),
                MilDuration ? ((((double)TopConsumingURLs[i].KCPUTime + (double)TopConsumingURLs[i].UCPUTime) / (double)MilDuration) * 100.0) : 0.0);
        }

        fprintf(procFile, "</table>\n" );
    }

    fprintf(procFile, "<table title='URLs with the Most Bytes Sent' top='%d'>\n", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopBytesURLs[i].Requests != 0; i++) {
        char* strPrint;
        CHAR ReducedUrl[URL_NAME_COLUMN_SIZE + 1];

        RemoveCtrlCharA(TopBytesURLs[i].URL, strlen(TopBytesURLs[i].URL));
        if (strlen(TopBytesURLs[i].URL) > URL_NAME_COLUMN_SIZE) {
            ReduceStringA(ReducedUrl, URL_NAME_COLUMN_SIZE + 1, TopBytesURLs[i].URL);
            strPrint = ReducedUrl;
        }else{
            strPrint = TopBytesURLs[i].URL;
        }
            
        fprintf(procFile,
            "<url name='%s'>"
            "<site_id>%d</site_id>"
            "<rate>%1.3f</rate>"
            "<cache_hit>%1.1f</cache_hit>"
            "<bytes_sent_per_sec>%d</bytes_sent_per_sec>"
            "</url>\n", 
            strPrint,
            TopBytesURLs[i].SiteId,
            (Duration ? ((double)TopBytesURLs[i].Requests / (double)Duration) : 0.0),
            TopBytesURLs[i].Requests ? ((double)TopBytesURLs[i].Hits / (double)TopBytesURLs[i].Requests * 100.0) : 0.0,
            Duration ? TopBytesURLs[i].BytesSent/ Duration : 0);
    }
    fprintf(procFile, "</table>\n" );

    for (i = 0; i < DISPLAY_SIZE; i++) {
        if (TopHitURLs[i].Requests != 0 && TopHitURLs[i].URL != NULL) {
            free(TopHitURLs[i].URL);
        }
        if (TopHitStaticURLs[i].Requests != 0 && TopHitStaticURLs[i].URL != NULL) {
            free(TopHitStaticURLs[i].URL);
        }
        if (TopSlowURLs[i].Requests != 0 && TopSlowURLs[i].URL != NULL) {
            free(TopSlowURLs[i].URL);
        }
        if (TopConsumingURLs[i].Requests != 0 && TopConsumingURLs[i].URL != NULL) {
            free(TopConsumingURLs[i].URL);
        }
        if (TopBytesURLs[i].Requests != 0 && TopBytesURLs[i].URL != NULL) {
            free(TopBytesURLs[i].URL);
        }
    }


    RtlZeroMemory(TopHitClients, sizeof(CLIENT_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopSlowClients, sizeof(CLIENT_RECORD) * DISPLAY_SIZE);
    pClient = GetHeadClientRecord();
    while (pClient != NULL) {
        ULONGLONG AverageClientResponseTime = 0;
        ULONG Found;
        CLIENT_RECORD tmpClient1, tmpClient2;
        if (pClient->Requests != 0) {
            RtlZeroMemory(&tmpClient1, sizeof(CLIENT_RECORD));
            RtlZeroMemory(&tmpClient2, sizeof(CLIENT_RECORD));
            Found = FALSE;
            for (i = 0; i < DISPLAY_SIZE; i++) {
                if (Found && tmpClient1.Requests != 0) {
                    RtlCopyMemory(&tmpClient2, &TopHitClients[i], sizeof(CLIENT_RECORD));
                    RtlCopyMemory(&TopHitClients[i], &tmpClient1, sizeof(CLIENT_RECORD));
                    RtlCopyMemory(&tmpClient1, &tmpClient2, sizeof(CLIENT_RECORD));
                }
                else if (!Found) {
                    if (TopHitClients[i].Requests == 0) {
                        RtlCopyMemory(&TopHitClients[i], pClient, sizeof(CLIENT_RECORD));
                        Found = TRUE;
                    }
                    else if (pClient->Requests > TopHitClients[i].Requests) {
                        RtlCopyMemory(&tmpClient1, &TopHitClients[i], sizeof(CLIENT_RECORD));
                        RtlCopyMemory(&TopHitClients[i], pClient, sizeof(CLIENT_RECORD));
                        Found = TRUE;
                    }
                }
            }
            AverageClientResponseTime = pClient->TotalResponseTime / pClient->Requests;
            RtlZeroMemory(&tmpClient1, sizeof(CLIENT_RECORD));
            RtlZeroMemory(&tmpClient2, sizeof(CLIENT_RECORD));
            Found = FALSE;
            for (i = 0; i < DISPLAY_SIZE; i++) {
                if (Found && tmpClient1.Requests != 0) {
                    RtlCopyMemory(&tmpClient2, &TopSlowClients[i], sizeof(CLIENT_RECORD));
                    RtlCopyMemory(&TopSlowClients[i], &tmpClient1, sizeof(CLIENT_RECORD));
                    RtlCopyMemory(&tmpClient1, &tmpClient2, sizeof(CLIENT_RECORD));
                }
                else if (!Found) {
                    if (TopSlowClients[i].Requests == 0) {
                        RtlCopyMemory(&TopSlowClients[i], pClient, sizeof(CLIENT_RECORD));
                        Found = TRUE;
                    }
                    else if (AverageClientResponseTime > (TopSlowClients[i].TotalResponseTime / TopSlowClients[i].Requests)) {
                        RtlCopyMemory(&tmpClient1, &TopSlowClients[i], sizeof(CLIENT_RECORD));
                        RtlCopyMemory(&TopSlowClients[i], pClient, sizeof(CLIENT_RECORD));
                        Found = TRUE;
                    }
                }
            }
        }
        free(pClient);
 
        pClient = GetHeadClientRecord();
    }

    fprintf(procFile, "<table title='Clients with the Most Requests' top='%d'>\n", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopHitClients[i].Requests != 0; i++) {
        ULONGLONG AverageClientResponseTime = 0;
        CHAR ipAddrBuffer[MAX_ADDRESS_LENGTH];
        PCHAR pszA = &ipAddrBuffer[0];

        if (TopHitClients[i].Requests != 0) {
            AverageClientResponseTime = TopHitClients[i].TotalResponseTime / TopHitClients[i].Requests;
        }

        DecodeIpAddressA(TopHitClients[i].IpAddrType, 
                        &TopHitClients[i].IpAddrV4,
                        &TopHitClients[i].IpAddrV6[0],
                        pszA); 

        fprintf(procFile, 
            "<client ip='%s'>"
            "<rate>%1.3f</rate>"
            "<cache_hit>%1.1f</cache_hit>"
            "<response_time>%I64u</response_time>"
            "</client>\n",
            ipAddrBuffer, 
            (Duration ? ((double)TopHitClients[i].Requests / (double)Duration) : 0.0),
            TopHitClients[i].Requests ? ((double)TopHitClients[i].Hits / (double)TopHitClients[i].Requests * 100.0) : 0.0,
            AverageClientResponseTime / 10000);
    }
    fprintf(procFile, "</table>\n" );
    fprintf(procFile, "<table title='Clients with the Slowest Responses' top='%d'>", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopSlowClients[i].Requests != 0; i++) {
        ULONGLONG AverageClientResponseTime = 0;
        CHAR ipAddrBuffer[MAX_ADDRESS_LENGTH];
        PCHAR pszA = &ipAddrBuffer[0];

        if (TopSlowClients[i].Requests != 0) {
            AverageClientResponseTime = TopSlowClients[i].TotalResponseTime / TopSlowClients[i].Requests;
        }

        DecodeIpAddressA(TopHitClients[i].IpAddrType, 
                        &TopHitClients[i].IpAddrV4,
                        &TopHitClients[i].IpAddrV6[0],
                        pszA); 

        fprintf(procFile, 
            "<client ip='%s'>"
            "<rate>%1.3f</rate>"
            "<cache_hit>%1.1f</cache_hit>"
            "<response_time>%I64u</response_time>"
            "</client>\n",
            ipAddrBuffer, 
            (Duration ? ((double)TopSlowClients[i].Requests / (double)Duration) : 0.0),
            TopSlowClients[i].Requests ? ((double)TopSlowClients[i].Hits / (double)TopSlowClients[i].Requests * 100.0) : 0.0,
            AverageClientResponseTime / 10000);
    }
    fprintf(procFile, "</table>" );

    RtlZeroMemory(TopHitSites, sizeof(SITE_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopSlowSites, sizeof(SITE_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopConsumingSites, sizeof(SITE_RECORD) * DISPLAY_SIZE);
    RtlZeroMemory(TopBytesSites, sizeof(SITE_RECORD) * DISPLAY_SIZE);
    pSite = GetHeadSiteRecord();
    while (pSite != NULL) {
        ULONGLONG AverageSiteResponseTime = 0;
        ULONG Found;
        SITE_RECORD tmpSite1, tmpSite2;
        if (pSite->Requests != 0) {
            RtlZeroMemory(&tmpSite1, sizeof(SITE_RECORD));
            RtlZeroMemory(&tmpSite2, sizeof(SITE_RECORD));
            Found = FALSE;
            for (i = 0; i < DISPLAY_SIZE; i++) {
                if (Found && tmpSite1.Requests != 0) {
                    RtlCopyMemory(&tmpSite2, &TopHitSites[i], sizeof(SITE_RECORD));
                    RtlCopyMemory(&TopHitSites[i], &tmpSite1, sizeof(SITE_RECORD));
                    RtlCopyMemory(&tmpSite1, &tmpSite2, sizeof(SITE_RECORD));
                }
                else if (!Found) {
                    if (TopHitSites[i].Requests == 0) {
                        RtlCopyMemory(&TopHitSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                    else if (pSite->Requests > TopHitSites[i].Requests) {
                        RtlCopyMemory(&tmpSite1, &TopHitSites[i], sizeof(SITE_RECORD));
                        RtlCopyMemory(&TopHitSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                }
            }
            AverageSiteResponseTime = pSite->TotalResponseTime / pSite->Requests;
            RtlZeroMemory(&tmpSite1, sizeof(SITE_RECORD));
            RtlZeroMemory(&tmpSite2, sizeof(SITE_RECORD));
            Found = FALSE;
            for (i = 0; i < DISPLAY_SIZE; i++) {
                if (Found && tmpSite1.Requests != 0) {
                    RtlCopyMemory(&tmpSite2, &TopSlowSites[i], sizeof(SITE_RECORD));
                    RtlCopyMemory(&TopSlowSites[i], &tmpSite1, sizeof(SITE_RECORD));
                    RtlCopyMemory(&tmpSite1, &tmpSite2, sizeof(SITE_RECORD));
                }
                else if (!Found) {
                    if (TopSlowSites[i].Requests == 0) {
                        RtlCopyMemory(&TopSlowSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                    else if (AverageSiteResponseTime > (TopSlowSites[i].TotalResponseTime / TopSlowSites[i].Requests)) {
                        RtlCopyMemory(&tmpSite1, &TopSlowSites[i], sizeof(SITE_RECORD));
                        RtlCopyMemory(&TopSlowSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                }
            }
            RtlZeroMemory(&tmpSite1, sizeof(SITE_RECORD));
            RtlZeroMemory(&tmpSite2, sizeof(SITE_RECORD));
            Found = FALSE;
            for (i = 0; i < DISPLAY_SIZE; i++) {
                if (Found && tmpSite1.Requests != 0) {
                    RtlCopyMemory(&tmpSite2, &TopConsumingSites[i], sizeof(SITE_RECORD));
                    RtlCopyMemory(&TopConsumingSites[i], &tmpSite1, sizeof(SITE_RECORD));
                    RtlCopyMemory(&tmpSite1, &tmpSite2, sizeof(SITE_RECORD));
                }
                else if (!Found) {
                    if (TopConsumingSites[i].Requests == 0) {
                        RtlCopyMemory(&TopConsumingSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                    else if ((pSite->KCPUTime + pSite->UCPUTime) > (TopConsumingSites[i].KCPUTime + TopConsumingSites[i].UCPUTime)) {
                        RtlCopyMemory(&tmpSite1, &TopConsumingSites[i], sizeof(SITE_RECORD));
                        RtlCopyMemory(&TopConsumingSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                }
            }
            RtlZeroMemory(&tmpSite1, sizeof(SITE_RECORD));
            RtlZeroMemory(&tmpSite2, sizeof(SITE_RECORD));
            Found = FALSE;
            for (i = 0; i < DISPLAY_SIZE; i++) {
                if (Found && tmpSite1.Requests != 0) {
                    RtlCopyMemory(&tmpSite2, &TopBytesSites[i], sizeof(SITE_RECORD));
                    RtlCopyMemory(&TopBytesSites[i], &tmpSite1, sizeof(SITE_RECORD));
                    RtlCopyMemory(&tmpSite1, &tmpSite2, sizeof(SITE_RECORD));
                }
                else if (!Found) {
                    if (TopBytesSites[i].Requests == 0) {
                        RtlCopyMemory(&TopBytesSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                    else if (pSite->BytesSent > TopBytesSites[i].BytesSent) {
                        RtlCopyMemory(&tmpSite1, &TopBytesSites[i], sizeof(SITE_RECORD));
                        RtlCopyMemory(&TopBytesSites[i], pSite, sizeof(SITE_RECORD));
                        Found = TRUE;
                    }
                }
            }
        }
        free(pSite);
 
        pSite = GetHeadSiteRecord();
    }
    fprintf(procFile, "<table title='Sites with the Most Requests' top='%d'>\n", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopHitSites[i].Requests != 0; i++) {
        ULONGLONG AverageSiteResponseTime = 0;

        if (TopHitSites[i].Requests != 0) {
            AverageSiteResponseTime = TopHitSites[i].TotalResponseTime / TopHitSites[i].Requests;
        }
        fprintf(procFile, 
            "<site id='%d'>"
            "<rate>%1.3f</rate>"
            "<response_time>%I64u</response_time>"
            "<cache_hits>%1.1f</cache_hits>"
            "<static>%1.1f</static>"
            "<cgi>%1.1f</cgi>"
            "<asp>%1.1f</asp>"
            "</site>\n", 
            TopHitSites[i].SiteId,
            (Duration ? ((double)TopHitSites[i].Requests / (double)Duration) : 0.0),
            AverageSiteResponseTime / 10000,
            TopHitSites[i].Requests ? ((double)TopHitSites[i].Hits / (double)TopHitSites[i].Requests * 100.0) : 0.0,
            TopHitSites[i].Requests ? ((double)TopHitSites[i].FileRequests / (double)TopHitSites[i].Requests * 100.0) : 0.0,
            TopHitSites[i].Requests ? ((double)TopHitSites[i].CGIRequests / (double)TopHitSites[i].Requests * 100.0) : 0.0,
            TopHitSites[i].Requests ? ((double)TopHitSites[i].ISAPIRequests / (double)TopHitSites[i].Requests * 100.0) : 0.0);
    }
    
    fprintf(procFile, "</table>\n" );
    fprintf(procFile, "<table title='Sites with the Slowest Responses' top='%d'>\n", DISPLAY_SIZE);

    for (i = 0; i < DISPLAY_SIZE && TopSlowSites[i].Requests != 0; i++) {
        ULONGLONG AverageSiteResponseTime = 0;

        if (TopSlowSites[i].Requests != 0) {
            AverageSiteResponseTime = TopSlowSites[i].TotalResponseTime / TopSlowSites[i].Requests;
        }
        fprintf(procFile,
            "<site id='%d'>"
            "<rate>%1.3f</rate>"
            "<response_time>%I64u</response_time>"
            "<cache_hits>%1.1f</cache_hits>"
            "<static>%1.1f</static>"
            "<cgi>%1.1f</cgi>"
            "<asp>%1.1f</asp>"
            "</site>\n", 
            TopSlowSites[i].SiteId,
            (Duration ? ((double)TopSlowSites[i].Requests / (double)Duration) : 0.0),
            AverageSiteResponseTime / 10000,
            TopSlowSites[i].Requests ? ((double)TopSlowSites[i].Hits / (double)TopSlowSites[i].Requests * 100.0) : 0.0,
            TopSlowSites[i].Requests ? ((double)TopSlowSites[i].FileRequests / (double)TopSlowSites[i].Requests * 100.0) : 0.0,
            TopSlowSites[i].Requests ? ((double)TopSlowSites[i].CGIRequests / (double)TopSlowSites[i].Requests * 100.0) : 0.0,
            TopSlowSites[i].Requests ? ((double)TopSlowSites[i].ISAPIRequests / (double)TopSlowSites[i].Requests * 100.0) : 0.0);
    }
    fprintf(procFile, "</table>\n" );

    if (PrintCPUUsage) {
        
        fprintf(procFile, "<table title='Sites with the Most CPU Time Usage' top='%d'>\n", DISPLAY_SIZE );

        for (i = 0; i < DISPLAY_SIZE && TopConsumingSites[i].Requests != 0; i++) {
            ULONGLONG AverageSiteResponseTime = 0;

            if (TopConsumingSites[i].Requests != 0) {
                AverageSiteResponseTime = TopConsumingSites[i].TotalResponseTime / TopConsumingSites[i].Requests;
            }
            fprintf(procFile, 
                "<site id='%d'>"
                "<rate>%1.3f</rate>"
                "<cache_hits>%1.1f</cache_hits>"
                "<response_time>%I64u</response_time>"
                "<cpu_time units='ms'>%d</cpu_time>"
                "<cpu>%1.1f</cpu>"
                "</site>\n", 
                TopConsumingSites[i].SiteId,
                (Duration ? ((double)TopConsumingSites[i].Requests / (double)Duration) : 0.0),
                TopConsumingSites[i].Requests ? ((double)TopConsumingSites[i].Hits / (double)TopConsumingSites[i].Requests * 100.0) : 0.0,
                AverageSiteResponseTime / 10000,
                TopConsumingSites[i].Requests ? (TopConsumingSites[i].KCPUTime + TopConsumingSites[i].UCPUTime) / TopConsumingSites[i].Requests : 0,
                MilDuration ? ((((double)TopConsumingSites[i].KCPUTime + (double)TopConsumingSites[i].UCPUTime) / (double)MilDuration) * 100.0) : 0.0);
        }
        fprintf(procFile, "</table>\n" );
    }

    fprintf(procFile, "<table title='Sites with the Most Bytes Sent' top='%d'>\n", DISPLAY_SIZE );
    
    for (i = 0; i < DISPLAY_SIZE && TopBytesSites[i].Requests != 0; i++) {
        fprintf(procFile,
            "<site id='%d'>"
            "<rate>%1.3f</rate>"
            "<bytes>%d</bytes>"
            "<cache_hits>%1.1f</cache_hits>"
            "<static>%1.1f</static>"
            "<cgi>%1.1f</cgi>"
            "<asp>%1.1f</asp>"
            "</site>\n",
            TopBytesSites[i].SiteId,
            (Duration ? ((double)TopBytesSites[i].Requests / (double)Duration) : 0.0),
            Duration ? TopBytesSites[i].BytesSent / Duration : 0,
            TopBytesSites[i].Requests ? ((double)TopBytesSites[i].Hits / (double)TopBytesSites[i].Requests * 100.0) : 0.0,
            TopBytesSites[i].Requests ? ((double)TopBytesSites[i].FileRequests / (double)TopBytesSites[i].Requests * 100.0) : 0.0,
            TopBytesSites[i].Requests ? ((double)TopBytesSites[i].CGIRequests / (double)TopBytesSites[i].Requests * 100.0) : 0.0,
            TopBytesSites[i].Requests ? ((double)TopBytesSites[i].ISAPIRequests / (double)TopBytesSites[i].Requests * 100.0) : 0.0);
    }

    fprintf(procFile, "</table>\n" );

    free(IIS);
}

void
WriteSummary()
{
    FILE* SummaryFile;
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    ULONG i;

    WCHAR buffer[MAXSTR];
    FILETIME  StTm, StlTm;
    LARGE_INTEGER LargeTmp;
    SYSTEMTIME tmf, emf;
    BOOL bResult;

    if( NULL == TraceContext->SummaryFileName ){
        return;
    }

    if( 0 == TotalEventCount ){
        return;
    }

    SummaryFile = _wfopen( TraceContext->SummaryFileName, L"w" );
    if (SummaryFile == NULL){
        return;
    }

    fwprintf(SummaryFile,L"Files Processed:\n");

    for (i=0; i<TraceContext->LogFileCount; i++) {
        fwprintf(SummaryFile,L"\t%s\n",TraceContext->LogFileName[i]);
    }

    LargeTmp.QuadPart = CurrentSystem.StartTime;
    StTm.dwHighDateTime = LargeTmp.HighPart;
    StTm.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&StTm, &StlTm);


    bResult = FileTimeToSystemTime (
        &StlTm,
        &tmf
        );

    if( ! bResult || tmf.wMonth > 12 ){
        ZeroMemory( &tmf, sizeof(SYSTEMTIME) );
        buffer[0] = '\0';
    }else{
        GetDateFormatW( LOCALE_USER_DEFAULT, DATE_LONGDATE, &tmf, NULL, buffer, MAXSTR );
    }


    fwprintf(SummaryFile,
                L"Total Buffers Processed %d\n"
                L"Total Events  Processed %d\n"
                L"Total Events  Lost      %d\n"
                L"Start Time              %ws\n",
              TotalBuffersRead,
              TotalEventCount,
              TotalEventsLost,
              buffer );

    LargeTmp.QuadPart = CurrentSystem.EndTime;
    StTm.dwHighDateTime = LargeTmp.HighPart;
    StTm.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&StTm, &StlTm);

    bResult = FileTimeToSystemTime (
        &StlTm,
        &emf
        );

    if( ! bResult || tmf.wMonth > 12 ){
        ZeroMemory( &tmf, sizeof(SYSTEMTIME) );
        buffer[0] = '\0';
    }else{
        GetDateFormatW( LOCALE_USER_DEFAULT, DATE_LONGDATE, &emf, NULL, buffer, MAXSTR );
    }

    ElapseTime = CurrentSystem.EndTime - CurrentSystem.StartTime;
    fwprintf(SummaryFile,
                L"End Time                %ws\n" 
                L"Elapsed Time            %I64d sec\n",
                buffer,
                (ElapseTime / 10000000) );



    fwprintf(SummaryFile,
         L"+-------------------------------------------------------------------------------------+\n"
         L"|%10s   %-20s %-10s  %-38s|\n"
         L"+-------------------------------------------------------------------------------------+\n",
         L"Event Count",
         L"Event Name",
         L"Event Type",
         L"Guid"
        );

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;
    while (Head != Next) {
        WCHAR wstr[MAXSTR];
        PWCHAR str;
        WCHAR s[MAX_GUID_STRING_SIZE];
        PLIST_ENTRY vHead, vNext;
        PMOF_VERSION pMofVersion;

        RtlZeroMemory(&wstr[0], MAXSTR*sizeof(WCHAR));

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;

        if (pMofInfo->EventCount > 0) {
            str = CpdiGuidToString(&s[0], MAX_GUID_STRING_SIZE, (LPGUID)&pMofInfo->Guid);

            if( pMofInfo->strDescription != NULL ){
                StringCchCopyW( wstr, MAXSTR, pMofInfo->strDescription );
            }

            //
            // Get event count by type from MOF_VERSION structure
            //

            vHead = &pMofInfo->VersionHeader;
            vNext = vHead->Flink;

            while (vHead != vNext) {

                pMofVersion = CONTAINING_RECORD(vNext, MOF_VERSION, Entry);
                vNext = vNext->Flink;

                if (pMofVersion->EventCountByType != 0) {

                    fwprintf(SummaryFile,L"| %10d   %-20s %-10s  %38s|\n",
                          pMofVersion->EventCountByType,
                          wstr,
                          pMofVersion->strType ? pMofVersion->strType : GUID_TYPE_DEFAULT,
                          str);
                }
            }
        }
    }


    fwprintf(SummaryFile,
           L"+-------------------------------------------------------------------------------------+\n"
        );
    
    fclose( SummaryFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\process.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    process.c

Abstract:

    Manipulation routines for cpdata structures.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include "cpdata.h"
#include "tracectr.h"
#include "item.h"

extern PTRACE_CONTEXT_BLOCK TraceContext;
extern PWCHAR CpdiGuidToString(PWCHAR s, ULONG len, LPGUID piid);
extern LIST_ENTRY g_ValueMapTable;

VOID
Aggregate(
    IN PTHREAD_RECORD pThread
    );

ULONG
CPDAPI
GetTempName( LPTSTR strFile, size_t cchSize )
{
    HRESULT hr;
    DWORD dwStatus;
    GUID guid;
    WCHAR strGUID[128];
    DWORD nChar = 0;

    dwStatus = UuidCreate( &guid );
    if( dwStatus == RPC_S_OK || dwStatus == RPC_S_UUID_LOCAL_ONLY ){
        nChar = StringFromGUID2( (const GUID*)&guid, strGUID, 128 );
        dwStatus = ERROR_SUCCESS;
    }

    if( 0 == nChar ){
        hr = StringCchPrintf( strGUID, 128, L"{d41c99ea-c303-4d06-b779-f9e8e20acb8f}.%08d", rand() );
    }

    nChar = GetTempPath( cchSize, strFile );
    if( 0 == nChar ){
        dwStatus = GetLastError();
    }

    if( ERROR_SUCCESS == dwStatus ){
        hr = StringCchCat( strFile, cchSize, strGUID );
    }

    return dwStatus;
}

__inline
USHORT
UrlHashKey(
    PUCHAR UrlStr,
    ULONG StrSize
    )
{
    USHORT i, l, key = 0;
    i = (USHORT)(StrSize - 1);
    // Use only the last 25 chars
    l = (StrSize > 25) ? (USHORT)(StrSize - 25) : 0;

    // UrlStr cannot be NULL when this function is called.
    for ( ; i >= l; i--) {
        key = 37 * key + (USHORT)(*(UrlStr + i));
        if (i == 0) {
            break;
        }
    }

    key = key % (URL_HASH_TABLESIZE);

    return key;
}

VOID
InitDiskRecord(
    PTDISK_RECORD pDisk,
    ULONG DiskNumber
    )
{
    PWCHAR name;
    if (pDisk == NULL){
        return;
    }
    memset(pDisk, 0, sizeof(TDISK_RECORD));
    InitializeListHead(&pDisk->ProcessListHead);
    InitializeListHead(&pDisk->FileListHead);
    pDisk->DiskNumber = DiskNumber;

    name = (PWCHAR)malloc(16 * sizeof(WCHAR));
    if (name != NULL) {
        StringCbPrintfW(name, 16 * sizeof(WCHAR), L"Disk%d", DiskNumber);
    }
    pDisk->DiskName = name;
}

VOID
InitFileRecord(
    PFILE_RECORD pFile
    )
{
    if (pFile == NULL){
        return;
    }
    memset(pFile, 0, sizeof(FILE_RECORD));
    InitializeListHead(&pFile->ProtoProcessListHead);
}

VOID
InitThreadRecord(
    PTHREAD_RECORD pThread
    )
{
    if (pThread == NULL)
        return;
    memset(pThread, 0, sizeof(THREAD_RECORD));
    InitializeListHead( &pThread->DiskListHead );
    InitializeListHead( &pThread->TransListHead );
    InitializeListHead( &pThread->HPFReadListHead );
    InitializeListHead( &pThread->HPFWriteListHead );
}

PTRANS_RECORD
CreateTransRecord()
{
    PLIST_ENTRY Head, Next;
    PTRANS_RECORD pTrans = NULL; 
        
    EnterTracelibCritSection();
    Head = &CurrentSystem.FreeTransListHead;

    Next = Head->Flink;

    if (Next != Head) {
        pTrans = CONTAINING_RECORD ( Next, TRANS_RECORD, Entry );
        RemoveEntryList( &pTrans->Entry );
    }
    LeaveTracelibCritSection();

    if (pTrans == NULL) {
        pTrans = malloc(sizeof(TRANS_RECORD));
        if (pTrans == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            return NULL;
        }
    }
    memset(pTrans, 0, sizeof(TRANS_RECORD));
    InitializeListHead(&pTrans->SubTransListHead);
    return pTrans;
}

VOID
InitMofData(
    PMOF_DATA pMofData
    )
{
    if (pMofData == NULL)
        return;
    memset(pMofData, 0, sizeof(MOF_DATA));
    pMofData->MaxKCpu = -1;
    pMofData->MinKCpu = -1;
    pMofData->MaxUCpu = -1;
    pMofData->MinUCpu = -1;
}

VOID
InitProcessRecord(
    PPROCESS_RECORD pProcess
    )
{
    if (pProcess == NULL)
        return;
    memset(pProcess, 0, sizeof(PROCESS_RECORD));
    InitializeListHead( &pProcess->ThreadListHead );
    InitializeListHead( &pProcess->DiskListHead );
    InitializeListHead( &pProcess->FileListHead );
    InitializeListHead( &pProcess->ModuleListHead );
    InitializeListHead( &pProcess->HPFListHead );
}

BOOLEAN AddModuleRecord(PMODULE_RECORD * ppModule,
                        ULONG            lBaseAddress,
                        ULONG            lModuleSize,
                        WCHAR          * strModuleName)
{
    PMODULE_RECORD pModule;

    if ( (ppModule == NULL) || (strModuleName == NULL) ) {
        return FALSE;
    }

    pModule = (PMODULE_RECORD)malloc(sizeof(MODULE_RECORD));

    if(NULL != pModule){
        memset(pModule, 0, sizeof(MODULE_RECORD));

        pModule->strModuleName =
                       malloc(sizeof(WCHAR) * (lstrlenW(strModuleName) + 1));

        if (pModule->strModuleName == NULL)
        {
            free(pModule);
            pModule = NULL;
        }
        else
        {
            StringCchCopyW(pModule->strModuleName, (lstrlenW(strModuleName) + 1), strModuleName);

            pModule->lBaseAddress  = lBaseAddress;
            pModule->lModuleSize   = lModuleSize;
        }
    }

    * ppModule = pModule;

    return (BOOLEAN) (* ppModule != NULL);
}

BOOLEAN AddHPFFileRecord(
    PHPF_FILE_RECORD * ppHPFFileRecord,
    ULONG              RecordID,
    ULONG              IrpFlags,
    ULONG              DiskNumber,
    ULONGLONG          ByteOffset,
    ULONG              BytesCount,
    PVOID              fDO
    )
{
    PHPF_FILE_RECORD pHPFFileRecord = malloc(sizeof(HPF_FILE_RECORD));

    if (pHPFFileRecord)
    {
        pHPFFileRecord->RecordID   = RecordID;
        pHPFFileRecord->IrpFlags   = IrpFlags;
        pHPFFileRecord->DiskNumber = DiskNumber;
        pHPFFileRecord->ByteOffset = ByteOffset;
        pHPFFileRecord->BytesCount = BytesCount;
        pHPFFileRecord->fDO        = fDO;
    }

    * ppHPFFileRecord = pHPFFileRecord;
    return (BOOLEAN) (* ppHPFFileRecord != NULL);
}

BOOLEAN AddHPFRecord(
        PHPF_RECORD * ppHPFRecord,
        ULONG         lFaultAddress,
        PVOID         fDO,
        LONG          ByteCount,
        LONGLONG      ByteOffset
        )
{
    PHPF_RECORD pHPFRecord = malloc(sizeof(HPF_RECORD));

    if (pHPFRecord)
    {
        pHPFRecord->fDO           = fDO;
        pHPFRecord->lFaultAddress = lFaultAddress;
        pHPFRecord->lByteCount    = ByteCount;
        pHPFRecord->lByteOffset   = ByteOffset;
        InitializeListHead(& pHPFRecord->HPFReadListHead);
    }

    * ppHPFRecord = pHPFRecord;
    return (BOOLEAN) (* ppHPFRecord != NULL);
}

void DeleteHPFRecord(
        PHPF_RECORD pHPFRecord
        )
{
    PLIST_ENTRY      pHead;
    PLIST_ENTRY      pNext;
    PHPF_FILE_RECORD pHPFFileRecord;

    if (!pHPFRecord)
        return;

    RemoveEntryList(& pHPFRecord->Entry);
    pHead = & pHPFRecord->HPFReadListHead;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;
        RemoveEntryList(& pHPFFileRecord->Entry);
        free(pHPFFileRecord);
    }
    free(pHPFRecord);
    return;
}

VOID
InitWorkloadRecord(
        PWORKLOAD_RECORD pWorkload
    )
{
    if (pWorkload == NULL)
        return;
    memset(pWorkload, 0, sizeof(WORKLOAD_RECORD));
    InitializeListHead( &pWorkload->DiskListHead );
}

VOID
DeleteWorkloadRecord(
    PWORKLOAD_RECORD pWorkload
    )
{
    if (pWorkload == NULL)
        return;

}

PPROTO_PROCESS_RECORD
AddProtoProcess(
    PFILE_RECORD pFile,
    PPROCESS_RECORD pProcess
    )
{
    PPROTO_PROCESS_RECORD pProto;

    if (pFile == NULL || pProcess == NULL)
        return NULL;

    pProto = malloc(sizeof(PROTO_PROCESS_RECORD));
    if (pProto == NULL) {
        return NULL;
    }
    memset(pProto, 0, sizeof(PROTO_PROCESS_RECORD));

    pProto->ProcessRecord = pProcess;
    InsertHeadList( &pFile->ProtoProcessListHead, &pProto->Entry );
    return pProto;
}

PPROTO_PROCESS_RECORD
FindProtoProcessRecord(
    PFILE_RECORD pFile,
    PPROCESS_RECORD pProcess
    )
{
    PLIST_ENTRY Next, Head;
    PPROTO_PROCESS_RECORD pProto;
    if (pFile == NULL || pProcess == NULL)
        return NULL;

    Head = &pFile->ProtoProcessListHead;
    Next = Head->Flink;
    while (Next  != Head) {
        pProto  = CONTAINING_RECORD(Next, PROTO_PROCESS_RECORD, Entry);
        if (pProcess == pProto->ProcessRecord)
            return pProto;
        Next = Next->Flink;
    }
    return (AddProtoProcess(pFile, pProcess));
}

BOOLEAN
AddProcess(
    ULONG    ProcessId,
    PPROCESS_RECORD *ReturnedProcess
    )
{
    PPROCESS_RECORD Process;
    PMODULE_RECORD  pModule = NULL;

    Process = malloc(sizeof(PROCESS_RECORD));
    if (Process == NULL) {
        return FALSE;
    }

    InitProcessRecord( Process );
    Process->PID = ProcessId;
    if (!AddModuleRecord(& pModule, 0, 0, L"other")) {
        free(Process);
        return FALSE;
    }

    pModule->pProcess = Process;

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.ProcessListHead, &Process->Entry );
    InsertHeadList(& Process->ModuleListHead, & pModule->Entry);
    LeaveTracelibCritSection();
    *ReturnedProcess = Process;

    return TRUE;
}

BOOLEAN
DeleteProcess(
    PPROCESS_RECORD Process
    )
{
    PLIST_ENTRY Next, Head;
    PTHREAD_RECORD Thread;
    PTDISK_RECORD Disk;
    PFILE_RECORD pFile;
    PMODULE_RECORD pModule;
    PHPF_RECORD    pHPFRecord;

    if (Process == NULL)
        return FALSE;

    EnterTracelibCritSection();
    RemoveEntryList( &Process->Entry );
    LeaveTracelibCritSection();

    Head = &Process->ThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
        Next = Next->Flink;
        DeleteThread( Thread );
    }

    Head = &Process->DiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        Next = Next->Flink;
        DeleteDisk( Disk );
    }

    Head = &Process->HPFListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pHPFRecord = CONTAINING_RECORD(Next, HPF_RECORD, Entry);
        Next = Next->Flink;
        DeleteHPFRecord(pHPFRecord);
    }

    Head = &Process->FileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pFile = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList( &pFile->Entry );
        if (pFile->FileName != NULL)
            free(pFile->FileName);
        free(pFile);
    }

    Head = &Process->ModuleListHead;
    Next = Head->Flink;
    while (Next != Head)
    {
        pModule = CONTAINING_RECORD(Next, MODULE_RECORD, Entry);
        Next    = Next->Flink;
        RemoveEntryList(& pModule->Entry);
        if(pModule->strModuleName)
        {
            free(pModule->strModuleName);
        }
        free(pModule);
    }

    if (Process->ImageName != NULL)
        free(Process->ImageName);
    if (Process->UserName != NULL)
        free(Process->UserName);

    free( Process );
    return TRUE;
}

BOOLEAN
AddThread(
    ULONG                 ThreadId,
    PEVENT_TRACE          pEvent,
    PTHREAD_RECORD      * ResultThread
    )
{
    PTHREAD_RECORD Thread = NULL;
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    int i;

    Thread = malloc(sizeof(THREAD_RECORD));
    if (Thread == NULL) {
        return FALSE;
    }

    InitThreadRecord(Thread);

    Thread->TimeStart   = Thread->TimeEnd
                        = (ULONGLONG) pHeader->TimeStamp.QuadPart;
    Thread->TID         = ThreadId;
    Thread->ProcessorID = pEvent->ClientContext & 0x000000FF;
    i = (int)Thread->TID;
    i = i % THREAD_HASH_TABLESIZE;
    InsertHeadList(&CurrentSystem.ThreadHashList[i], &Thread->Entry);
    *ResultThread     = Thread;

    return TRUE;
}

BOOLEAN
DeleteThread(
    PTHREAD_RECORD Thread
    )
{
    PLIST_ENTRY      pHead;
    PLIST_ENTRY      pNext;
    PHPF_FILE_RECORD pHPFFileRecord;

    if (Thread == NULL) {
        return FALSE;
    }

    RemoveEntryList( &Thread->Entry );
    DeleteTransList( &Thread->TransListHead, 0 );

    pHead = & Thread->HPFReadListHead;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;
        RemoveEntryList(& pHPFFileRecord->Entry);
        free(pHPFFileRecord);
    }
    pHead = & Thread->HPFWriteListHead;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;
        RemoveEntryList(& pHPFFileRecord->Entry);
        free(pHPFFileRecord);
    }

    free( Thread );
    return TRUE;
}

PTRANS_RECORD
FindTransByList(
    PLIST_ENTRY Head,
    LPGUID pGuid,
    ULONG  level
    )
{
    PLIST_ENTRY   Next;
    PTRANS_RECORD pTrans = NULL;

    // Recursively look for the list that does
    // not contain a running guid
    //
    if (level <= MAX_TRANS_LEVEL && Head != NULL)
    {
        Next = Head->Flink;
        while (Next != Head)
        {
            pTrans = CONTAINING_RECORD(Next, TRANS_RECORD, Entry);
            if (pTrans->bStarted)
            {
                if (   (level == 0 || level == 1)
                    && IsEqualGUID(pTrans->pGuid, pGuid))
                {
                    return pTrans;
                }
                else if (level > 0)
                {
                    return FindTransByList(& pTrans->SubTransListHead,
                                           pGuid,
                                           level - 1);
                }
            }
            Next = Next->Flink;
        }
    }

    // Found the correct list; now find
    // the matching transaction
    //
    if (level == 0 && Head != NULL)
    {
        Next = Head->Flink;
        while (Next != Head)
        {
            pTrans = CONTAINING_RECORD(Next, TRANS_RECORD, Entry);
            if (IsEqualGUID( pTrans->pGuid, pGuid))
            {
                return pTrans;
            }
            Next = Next->Flink;
        }
        //
        // If not Found, go ahead and add it.
        //
        pTrans = CreateTransRecord();
        if (pTrans != NULL) {
            pTrans->pGuid = pGuid;
            InsertHeadList( Head, &pTrans->Entry );
        }
    }
    return pTrans;
}

PMOF_DATA
FindMofData(
    PMOF_INFO pMofInfo,
    PWCHAR    strSortKey
    )
{
    PLIST_ENTRY Next;
    PLIST_ENTRY Head;
    PMOF_DATA pMofData = NULL;

    if (pMofInfo == NULL) {
        return NULL;
    }

    Head = &pMofInfo->DataListHead;

    if (Head != NULL)
    {
        Next = Head->Flink;
        while (Next != Head)
        {
            pMofData = CONTAINING_RECORD(Next, MOF_DATA, Entry);
            if (strSortKey == NULL && pMofData->strSortKey == NULL)
            {
                return pMofData;
            }
            else if (   strSortKey != NULL
                     && pMofData->strSortKey != NULL
                     && !wcscmp(pMofData->strSortKey, strSortKey))
            {
                return pMofData;
            }
            Next = Next->Flink;
        }

        // If not Found, go ahead and add it.
        //
        pMofData = (PMOF_DATA)malloc(sizeof(MOF_DATA));
        if (pMofData == NULL)
        {
            return NULL;
        }
        InitMofData(pMofData);
        if (strSortKey != NULL)
        {
            pMofData->strSortKey =
                    (PWCHAR) malloc((lstrlenW(strSortKey) + 1) * sizeof(WCHAR));
            if (pMofData->strSortKey != NULL) {
                StringCchCopyW(pMofData->strSortKey, (lstrlenW(strSortKey) + 1), strSortKey);
            }
        }
        InsertHeadList(Head, &pMofData->Entry);
    }
    return pMofData;
}

BOOLEAN
DeleteTrans(
    PTRANS_RECORD Trans
    )
{
    if (Trans ==  NULL)
        return FALSE;
    EnterTracelibCritSection();
    RemoveEntryList( &Trans->Entry );
    InsertHeadList( &CurrentSystem.FreeTransListHead, &Trans->Entry );
    LeaveTracelibCritSection();

    return TRUE;
}

BOOLEAN
DeleteTransList(
    PLIST_ENTRY Head,
    ULONG level
    )
{
    PLIST_ENTRY Next;
    PTRANS_RECORD pTrans;

    if( Head == NULL || level > MAX_TRANS_LEVEL )
        return FALSE;

    Next = Head->Flink;

    while(Next != Head){
        pTrans = CONTAINING_RECORD( Next, TRANS_RECORD, Entry );
        Next = Next->Flink;
        DeleteTransList( &pTrans->SubTransListHead, level+1);
        DeleteTrans( pTrans );
    }

    return TRUE;
}

PPROCESS_RECORD
FindProcessById(
    ULONG    Id,
    BOOLEAN CheckAlive
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_RECORD Process=NULL;

    EnterTracelibCritSection();

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        if (Process->PID == Id) {
            LeaveTracelibCritSection();
            if ((Process->DeadFlag) && (CheckAlive))
                return NULL;
            else
                return Process;
        }

        Next = Next->Flink;
    }
    LeaveTracelibCritSection();
    return NULL;
}

PTHREAD_RECORD
FindGlobalThreadById(
    ULONG               ThreadId,
    PEVENT_TRACE        pEvent
    )
{
    PLIST_ENTRY    Next,
                   Head;
    PTHREAD_RECORD Thread;
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    ULONG i = ThreadId;
    ULONG Depth = 0;

    i = i % THREAD_HASH_TABLESIZE;

    Head = &CurrentSystem.ThreadHashList[i];
    Next = Head->Flink;
    while (Next != Head)
    {
        Thread = CONTAINING_RECORD(Next, THREAD_RECORD, Entry);
        Next   = Next->Flink;
        Depth++;

        if (Thread->TID == ThreadId)
        {
            if (ThreadId == 0)
            {
                ULONG ProcessorId = pEvent->ClientContext & 0x000000FF;
                if (ProcessorId != Thread->ProcessorID)
                {
                    continue;
                }
            }
            if (!Thread->DeadFlag)
            {
                if (Depth > 40) {
                    RemoveEntryList( &Thread->Entry );
                    InsertHeadList( Head, &Thread->Entry );
                }
                return Thread;
            }
            else if (   Thread->TimeEnd
                     == (ULONGLONG) pHeader->TimeStamp.QuadPart)
            {
                if (Depth > 40) {
                    RemoveEntryList( &Thread->Entry );
                    InsertHeadList( Head, &Thread->Entry );
                }
                return Thread;
            }
            else
            {
                // The alive thead must be at the head of the list
                // otherwise bail
                //
                return NULL;
            }
        }
    }
    return NULL;
}

PWORKLOAD_RECORD
FindWorkloadById(
    ULONG   Id
    )
{
    PLIST_ENTRY Next, Head;
    PWORKLOAD_RECORD Workload = NULL;

    Head = &CurrentSystem.WorkloadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Workload = CONTAINING_RECORD( Next, WORKLOAD_RECORD, Entry );
        if (Workload->ClassNumber == Id) {
            return Workload;
        }

        Next = Next->Flink;
    }
    return NULL;
}

BOOLEAN
AddDisk(
    ULONG DiskNumber,
    PTDISK_RECORD *ReturnedDisk
    )
{
    PTDISK_RECORD Disk;

    Disk = malloc(sizeof(TDISK_RECORD));
    if (Disk == NULL) {
        return FALSE;
    }
    InitDiskRecord(Disk, DiskNumber);
    Disk->DiskNumber = DiskNumber;

    InsertHeadList( &CurrentSystem.GlobalDiskListHead, &Disk->Entry );
    *ReturnedDisk = Disk;

    return TRUE;
}


BOOLEAN
DeleteDisk(
    PTDISK_RECORD Disk
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_RECORD Process;
    PFILE_RECORD File;
    if (Disk == NULL)
        return FALSE;
    RemoveEntryList( &Disk->Entry );

    if (Disk->DiskName != NULL)
        free(Disk->DiskName);

    Head = &Disk->ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        DeleteProcess( Process );
    }
    Head = &Disk->FileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        File = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        DeleteFileRecord( File );
    }

    free( Disk );
    return TRUE;
}

PTDISK_RECORD
FindLocalDiskById(
    PLIST_ENTRY Head,
    ULONG Id
    )
{
    PLIST_ENTRY Next;
    PTDISK_RECORD Disk = NULL;

    if (Head == NULL)
        return NULL;

    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        if (Disk->DiskNumber == Id) {
            return Disk;
        }
        Next = Next->Flink;
    }

    // If not Found, go ahead and add it.
    //
    Disk = malloc(sizeof(TDISK_RECORD));
    if (Disk == NULL) {
        return FALSE;
    }
    InitDiskRecord(Disk, Id);

    Disk->DiskNumber = Id;
    InsertHeadList( Head, &Disk->Entry );
    return Disk;
}

PTDISK_RECORD
FindProcessDiskById(
    PPROCESS_RECORD pProcess,
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PTDISK_RECORD Disk = NULL;

    if (pProcess == NULL)
        return NULL;

    Head = &pProcess->DiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        if (Disk->DiskNumber == Id) {
            return Disk;
        }
        Next = Next->Flink;
    }

    // If not Found, go ahead and add it.
    //
    Disk = malloc(sizeof(TDISK_RECORD));
    if (Disk == NULL) {
        return NULL;
    }
    InitDiskRecord(Disk, Id);

    Disk->DiskNumber = Id;
    InsertHeadList( &pProcess->DiskListHead, &Disk->Entry );
    return Disk;
}

PPROCESS_RECORD
FindDiskProcessById(
    PTDISK_RECORD pDisk,
    ULONG    Id
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_RECORD Process = NULL;
    PPROCESS_RECORD gProcess = NULL;

    if (pDisk == NULL)
        return NULL;

    Head = &pDisk->ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        if (Process->PID == Id) {
            return Process;
        }
        Next = Next->Flink;
    }

    // If not Found, go ahead and add it.
    //
    Process = malloc(sizeof(PROCESS_RECORD));
    if (Process == NULL) {
        return FALSE;
    }
    InitProcessRecord(Process);

    Process->PID = Id;

    // Find the global Process Record and copy the UserName and Image.
    //
    gProcess = FindProcessById(Id, FALSE);
    if (gProcess != NULL) {
        if ( IsNotEmpty( gProcess->UserName ) ) {
            Process->UserName = (LPWSTR)malloc( (wcslen(gProcess->UserName) + 1) * sizeof(WCHAR) );
            if (NULL != Process->UserName) {
                StringCchCopyW(Process->UserName, (wcslen(gProcess->UserName) + 1), gProcess->UserName);
            }
        }
        if ( IsNotEmpty( gProcess->ImageName ) ) {
            Process->ImageName = (LPWSTR)malloc( (wcslen(gProcess->ImageName) + 1) * sizeof(WCHAR) );
            if (NULL != Process->ImageName) {
                StringCchCopyW(Process->ImageName, (wcslen(gProcess->ImageName) + 1), gProcess->ImageName);
            }
        }
    }
    InsertHeadList( &pDisk->ProcessListHead, &Process->Entry );
    return Process;
}

PTDISK_RECORD
FindGlobalDiskById(
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PTDISK_RECORD Disk = NULL;

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        if (Disk->DiskNumber == Id) {
            return Disk;
        }
        Next = Next->Flink;
    }
    return NULL;
}

VOID
DeleteMofVersion(
    PMOF_VERSION pMofVersion,
    FILE* file
    )
{
    PLIST_ENTRY Next, Head;
    PITEM_DESC pMofItem;


    //
    // Traverse through the MOF_VERSION list and
    // delete each one
    //
    if (pMofVersion == NULL)
        return;
    if( NULL != file ){
        fwprintf(  file, L"   %s (Type:%d Level:%d Version:%d)\n", 
                pMofVersion->strType ? pMofVersion->strType : L"Default", 
                pMofVersion->TypeIndex, 
                pMofVersion->Level, 
                pMofVersion->Version 
            );
    }
    Head = &pMofVersion->ItemHeader;
    Next = Head->Flink;
    while (Head  != Next) {
        pMofItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pMofItem->Entry );
        if (pMofItem->strDescription != NULL){
            if( NULL != file ){
                fwprintf( file, L"           %s\n", 
                        pMofItem->strDescription 
                    );
            }
            free (pMofItem->strDescription);
        }

        free (pMofItem);
    }
}


VOID
DeleteMofInfo(
    PMOF_INFO pMofInfo,
    FILE* f
    )
{
    PLIST_ENTRY Next, Head;
    PMOF_VERSION pMofVersion;

    //
    // Traverse through the MOF_VERSION list and 
    // delete each one
    //

    if (pMofInfo == NULL){
        return;
    }

    if( NULL != f ){
        WCHAR buffer[MAXSTR];
        fwprintf( f, L"%s\n", 
            pMofInfo->strDescription ? pMofInfo->strDescription : CpdiGuidToString( buffer, MAXSTR, &pMofInfo->Guid ) );
    }
    
    Head = &pMofInfo->VersionHeader;
    Next = Head->Flink;
    while (Head  != Next) {
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pMofVersion->Entry );

        DeleteMofVersion( pMofVersion, f );
    }

    //
    // Delete any strings allocated for this structure
    //
    if (pMofInfo->strDescription){
        free(pMofInfo->strDescription);
    }

    //
    // Finally delete the object
    //
    free(pMofInfo);
}

VOID
Cleanup()
{
    PTDISK_RECORD    Disk;
    PTHREAD_RECORD   Thread;
    PPROCESS_RECORD  Process;
    PFILE_RECORD     FileRec;
    PWORKLOAD_RECORD pWorkload;
    PMODULE_RECORD   pModule;
    PTRANS_RECORD    pTrans;
    PMOF_INFO        pMofInfo;
    PPRINT_JOB_RECORD       pJob;
    PHTTP_REQUEST_RECORD    pReq;
    PURL_RECORD             pUrl;
    PCLIENT_RECORD          pClient;
    PSITE_RECORD            pSite;
    PLOGICAL_DRIVE_RECORD   pLogDrive;
    PVALUEMAP       pValueMap;

    PLIST_ENTRY Next, Head;
    PLIST_ENTRY EventListHead;
    FILE* f = NULL;

    ULONG i;

    // Clean up the Global Disk List for now.
    //
    EventListHead = &CurrentSystem.EventListHead;
    Head = EventListHead;
    Next = Head->Flink;

    if( (TraceContext->Flags & TRACE_INTERPRET) && NULL != TraceContext->CompFileName ){
        f = _wfopen( TraceContext->CompFileName, L"w" );
    }

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pMofInfo->Entry );
        DeleteMofInfo(pMofInfo, f);
    }

    if( NULL != f ){
        fclose( f );
        f = NULL;
    }

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        Next = Next->Flink;
        DeleteDisk( Disk );
    }

    // Clean up the Global Thread List for now.
    //
    Head = &CurrentSystem.GlobalThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
        Next = Next->Flink;
        DeleteThread( Thread );
    }
    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        DeleteProcess( Process );
    }
    Head = &CurrentSystem.GlobalModuleListHead;
    Next = Head->Flink;
    while (Next != Head)
    {
        pModule = CONTAINING_RECORD(Next, MODULE_RECORD, Entry);
        Next = Next->Flink;
        RemoveEntryList(& pModule->Entry);
        if(pModule->strModuleName)
        {
            free(pModule->strModuleName);
        }
        free(pModule);
    }

    Head = &CurrentSystem.HotFileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        FileRec = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        DeleteFileRecord( FileRec );
    }
    // Cleanup workload structures
    //
    Head = &CurrentSystem.WorkloadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pWorkload = CONTAINING_RECORD( Next, WORKLOAD_RECORD, Entry );
        Next = Next->Flink;
        DeleteWorkloadRecord( pWorkload );
    }
    //
    // Cleanup the Print Job List structures
    //
    Head = &CurrentSystem.PrintJobListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pJob = CONTAINING_RECORD( Next, PRINT_JOB_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pJob->Entry);
        free(pJob);
    }
    //
    // Cleanup the Http Request List structures
    //
    Head = &CurrentSystem.HttpReqListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pReq = CONTAINING_RECORD( Next, HTTP_REQUEST_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pReq->Entry);
        if (pReq->URL != NULL) {
            free(pReq->URL);
        }
        free(pReq);
    }
    //
    // Cleanup the Pending Http Request List structures
    //
    Head = &CurrentSystem.PendingHttpReqListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pReq = CONTAINING_RECORD( Next, HTTP_REQUEST_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pReq->Entry);
        if (pReq->URL != NULL) {
            free(pReq->URL);
        }
        free(pReq);
    }
    //
    // Cleanup the URL List structures
    //
    for (i = 0; i < URL_HASH_TABLESIZE; i++) {
        Head = &CurrentSystem.URLHashList[i];
        Next = Head->Flink;
        while (Next != Head) {
            pUrl = CONTAINING_RECORD( Next, URL_RECORD, Entry );
            Next = Next->Flink;
            RemoveEntryList(&pUrl->Entry);
            free(pUrl);
        }
    }
    //
    // Cleanup the Client List structures
    //
    Head = &CurrentSystem.ClientListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pClient = CONTAINING_RECORD( Next, CLIENT_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pClient->Entry);
        free(pClient);
    }
    //
    // Cleanup the Site List structures
    //
    Head = &CurrentSystem.SiteListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pSite = CONTAINING_RECORD( Next, SITE_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pSite->Entry);
        free(pSite);
    }
    //
    // Cleanup the Logical Drive structures
    //
    Head = &CurrentSystem.LogicalDriveHead;
    Next = Head->Flink;
    while (Next != Head) {
        pLogDrive = CONTAINING_RECORD( Next, LOGICAL_DRIVE_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pLogDrive->Entry);
        if (NULL != pLogDrive->DriveLetterString) {
            free(pLogDrive->DriveLetterString);
        }
        free(pLogDrive);
    }

    //
    // Clean up recyled memory structures
    //
    Head = &CurrentSystem.FreePrintJobListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pJob = CONTAINING_RECORD( Next, PRINT_JOB_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pJob->Entry);
        free(pJob);
    }
    Head = &CurrentSystem.FreeTransListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pTrans = CONTAINING_RECORD( Next, TRANS_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pTrans->Entry);
        free(pTrans);
    }
    Head = &CurrentSystem.FreeHttpReqListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pReq = CONTAINING_RECORD( Next, HTTP_REQUEST_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pReq->Entry);
        free(pReq);
    }
    Head = &CurrentSystem.FreeURLListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pUrl = CONTAINING_RECORD( Next, URL_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pUrl->Entry);
        free(pUrl);
    }

    Head = &g_ValueMapTable;
    Next = Head->Flink;
    while (Next != Head) {
        pValueMap = CONTAINING_RECORD( Next, VALUEMAP, Entry );
        Next = Next->Flink;
        RemoveEntryList(&pValueMap->Entry);
        if( NULL != pValueMap->saValueMap ){
            SafeArrayDestroy( pValueMap->saValueMap );
        }
        if( NULL != pValueMap->saValues ){
            SafeArrayDestroy( pValueMap->saValues );
        }
     
        free( pValueMap );
    }
}

PLOGICAL_DRIVE_RECORD 
FindLogicalDrive(
    ULONGLONG AccessedOffset,
    ULONG DiskNumber
    )
{
    PLOGICAL_DRIVE_RECORD pLogDrive = NULL;
    PLIST_ENTRY Next, Head;

    EnterTracelibCritSection();
    // Find drive letter when logical drive info is available.
    Head = &CurrentSystem.LogicalDriveHead;
    Next = Head->Flink;
    if (Next != Head) {
        while (Next != Head) {
            pLogDrive = CONTAINING_RECORD( Next, LOGICAL_DRIVE_RECORD, Entry );
            if (DiskNumber == pLogDrive->DiskNumber && 
                AccessedOffset < pLogDrive->StartOffset && 
                Next->Blink != Head) {
                pLogDrive = CONTAINING_RECORD( Next->Blink, LOGICAL_DRIVE_RECORD, Entry );
                break;
            }
            Next = Next->Flink;
        }
    }
    LeaveTracelibCritSection();
    if (NULL != pLogDrive && DiskNumber == pLogDrive->DiskNumber) {
        return pLogDrive;
    }
    else {
        return NULL;
    }
}

BOOLEAN
AddFile(
    WCHAR* fileName,
    PFILE_RECORD *ReturnedFile,
    PLOGICAL_DRIVE_RECORD pLogDrive
    )
{
    PFILE_RECORD fileRec;
    PLIST_ENTRY Next, Head;

    if (fileName == NULL)
        return FALSE;

    fileRec = malloc(sizeof(FILE_RECORD));
    if (fileRec == NULL) {
        return FALSE;
    }
    InitFileRecord( fileRec );
    fileRec->FileName = malloc( (lstrlenW(fileName)+ 1) * sizeof(WCHAR));
    if (fileRec->FileName != NULL) {
        StringCchCopyW(fileRec->FileName, (lstrlenW(fileName)+ 1), fileName);
    }
    if (NULL != pLogDrive) {
        fileRec->DiskNumber = pLogDrive->DiskNumber;
        if (NULL != pLogDrive->DriveLetterString) {
            fileRec->Drive = malloc( (lstrlenW(pLogDrive->DriveLetterString)+ 1) * sizeof(WCHAR));
            if (fileRec->Drive != NULL) {
                StringCchCopyW(fileRec->Drive, lstrlenW(pLogDrive->DriveLetterString)+ 1, pLogDrive->DriveLetterString);
            }
        }
    }
    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.HotFileListHead, &fileRec->Entry );
    LeaveTracelibCritSection();
    *ReturnedFile = fileRec;

    return TRUE;
}

BOOLEAN
DeleteFileRecord(
    PFILE_RECORD fileRec
    )
{
    PLIST_ENTRY Next, Head;
    PPROTO_PROCESS_RECORD pProto;

    if (fileRec == NULL)
        return FALSE;

    EnterTracelibCritSection();
    RemoveEntryList( &fileRec->Entry );
    LeaveTracelibCritSection();

    if (fileRec->FileName != NULL)
        free(fileRec->FileName);
    if (fileRec->Drive != NULL)
        free(fileRec->Drive);

    Head = &fileRec->ProtoProcessListHead;
    Next = Head->Flink;
    while (Head != Next) {
        pProto = CONTAINING_RECORD( Next, PROTO_PROCESS_RECORD, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pProto->Entry );
        free(pProto);
    }
    free( fileRec );
    return TRUE;
}

PFILE_RECORD
FindFileRecordByName(
    WCHAR* fileName,
    PLOGICAL_DRIVE_RECORD pLogDrive
    )
{
    PLIST_ENTRY Next, Head;
    PFILE_RECORD fileRec = NULL;

    if (fileName == NULL)
        return NULL;
    EnterTracelibCritSection();
    Head = &CurrentSystem.HotFileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        fileRec = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        if (!wcscmp(fileName, fileRec->FileName)) {
            if (NULL != pLogDrive && pLogDrive->DiskNumber == fileRec->DiskNumber) { 
                if (NULL != pLogDrive->DriveLetterString && 
                    NULL != fileRec->Drive &&
                    !wcscmp(pLogDrive->DriveLetterString, fileRec->Drive)) {
                    LeaveTracelibCritSection();
                    return fileRec;
                }
                else if (NULL == pLogDrive->DriveLetterString && 
                    NULL == fileRec->Drive) {
                    LeaveTracelibCritSection();
                    return fileRec;
                }
            }
            else if (NULL == pLogDrive) {
                LeaveTracelibCritSection();
                return fileRec;
            }
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();
    return NULL;
}

PFILE_RECORD
FindFileInProcess(
    PPROCESS_RECORD pProcess,
    WCHAR* fileName
    )
{
    PLIST_ENTRY Next, Head;
    PFILE_RECORD fileRec = NULL;
    if (pProcess == NULL || fileName == NULL)
        return NULL;
    EnterTracelibCritSection();
    Head = &pProcess->FileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        fileRec = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        if (!wcscmp(fileName, fileRec->FileName)) {
            //ReleaseMutex(CurrentSystem.HotFileListMutex);
            LeaveTracelibCritSection();
            return fileRec;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();
    return NULL;
}

VOID
AddLogicalDrive(
    ULONGLONG StartOffset,
    ULONGLONG PartitionSize,
    ULONG DiskNumber,
    ULONG Size,
    ULONG DriveType,
    PWCHAR DriveLetterString
    ) 
{
    PLOGICAL_DRIVE_RECORD pLogDrive = NULL, pTempLogDrive = NULL;
    PLIST_ENTRY Next, Head;

    pLogDrive = malloc(sizeof(LOGICAL_DRIVE_RECORD));
    if (pLogDrive == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return;
    }

    RtlZeroMemory(pLogDrive, sizeof(LOGICAL_DRIVE_RECORD));
    pLogDrive->StartOffset = StartOffset;
    pLogDrive->PartitionSize = PartitionSize;
    pLogDrive->DiskNumber = DiskNumber;
    pLogDrive->Size = Size;
    pLogDrive->DriveType = DriveType;
    if (DriveLetterString != NULL) {
        pLogDrive->DriveLetterString = malloc( (lstrlenW(DriveLetterString)+ 1) * sizeof(WCHAR));
        if (pLogDrive->DriveLetterString != NULL) {
            StringCchCopyW(pLogDrive->DriveLetterString, lstrlenW(DriveLetterString)+ 1, DriveLetterString);
        }
    }
    EnterTracelibCritSection();
    // When inserting logical drives, do it in StartOffset order.
    Head = &CurrentSystem.LogicalDriveHead;
    Next = Head->Flink;
    while (Next != Head) {
        pTempLogDrive = CONTAINING_RECORD( Next, LOGICAL_DRIVE_RECORD, Entry );
        if (pLogDrive->StartOffset < pTempLogDrive->StartOffset) {
            break;
        }
        Next = Next->Flink;
    }
    InsertTailList( Next, &pLogDrive->Entry );
    LeaveTracelibCritSection();

}

VOID
AssignClass(
    PPROCESS_RECORD pProcess,
    PTHREAD_RECORD  pThread
    )
{
    UNREFERENCED_PARAMETER(pProcess);

    pThread->ClassNumber = 1;   // For the Time being make it single class.
}

VOID
Classify()
{
    //  Assign Class to each Thread or Process.
    //
    PLIST_ENTRY Head, Next;
    PTHREAD_RECORD pThread;

    Head = &CurrentSystem.GlobalThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pThread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );

        AssignClass(NULL, pThread);

        Aggregate(pThread);

        Next = Next->Flink;
    }
}

// Given the number of classes this routine
// creates and initializes the workload object
//
VOID
InitClass()
{
    PWORKLOAD_RECORD pWorkload;
    ULONG nclass;
    ULONG i;

    //  Create the Class records here.
    //
    nclass = 1;
    CurrentSystem.NumberOfWorkloads = 1;
    for (i = 1; i <= nclass; i++) {

        pWorkload = malloc(sizeof(WORKLOAD_RECORD));
        if (pWorkload == NULL) {
            return;
        }
        InitWorkloadRecord( pWorkload );
        pWorkload->ClassNumber = i;
        InsertHeadList( &CurrentSystem.WorkloadListHead, &pWorkload->Entry );
    }
}

PTDISK_RECORD
FindDiskInList(
    IN PLIST_ENTRY Head,
    IN ULONG Id
    )
{
    PLIST_ENTRY Next;
    PTDISK_RECORD pDisk = NULL;

    if (Head != NULL) {

        Next = Head->Flink;

        while (Next != Head) {
            pDisk = CONTAINING_RECORD ( Next, TDISK_RECORD, Entry );
            if (pDisk->DiskNumber == Id) {
                return pDisk;
            }
            Next = Next->Flink;
        }

        pDisk = malloc(sizeof(TDISK_RECORD));
        if (pDisk == NULL) {
            return NULL;
        }
        InitDiskRecord( pDisk, Id );

        InsertHeadList( Head, &pDisk->Entry );
    }
    return pDisk;
}

VOID
Aggregate(
    IN PTHREAD_RECORD pThread
    )
{
    PWORKLOAD_RECORD pWorkload;
    PTDISK_RECORD pDisk, pClassDisk;
    PLIST_ENTRY Next, Head;

    // Aggregate the metrics over each class.
    //
    if ((pWorkload = FindWorkloadById(pThread->ClassNumber)) != NULL) {
        pWorkload->UserCPU += (pThread->UCPUEnd - pThread->UCPUStart)
                            * CurrentSystem.TimerResolution;
        pWorkload->KernelCPU += (pThread->KCPUEnd - pThread->KCPUStart)
                            * CurrentSystem.TimerResolution;
        //
        // Walk through the Thread Disk records and aggregate them
        // to the class

        Head = &pThread->DiskListHead;
        Next = Head->Flink;
        while (Next != Head) {
            pDisk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
            Next = Next->Flink;

            pClassDisk = FindDiskInList(&pWorkload->DiskListHead,
                                         pDisk->DiskNumber) ;
            if (pClassDisk != NULL) {
                pClassDisk->ReadCount += pDisk->ReadCount;
                pClassDisk->WriteCount += pDisk->WriteCount;
                pClassDisk->ReadSize += (pDisk->ReadCount * pDisk->ReadSize);
                pClassDisk->WriteSize += (pDisk->WriteCount * pDisk->WriteSize);

                pWorkload->ReadCount += pDisk->ReadCount;
            }
        }
    }
}

ULONGLONG
CalculateProcessLifeTime(
        PPROCESS_RECORD pProcess
    )
{
    BOOLEAN     fFirst    = TRUE;
    ULONGLONG   TimeStart = 0;
    ULONGLONG   TimeEnd   = 0;
    PLIST_ENTRY pHead     = &pProcess->ThreadListHead;
    PLIST_ENTRY pNext     = pHead->Flink;
    PTHREAD_RECORD pThread;

    while (pNext != pHead)
    {
        pThread = CONTAINING_RECORD(pNext, THREAD_RECORD, Entry);
        pNext   = pNext->Flink;

        if (fFirst)
        {
            TimeStart = pThread->TimeStart;
            TimeEnd   = pThread->TimeEnd;
            fFirst    = FALSE;
        }
        else if (pThread->TimeStart < TimeStart)
        {
            TimeStart = pThread->TimeStart;
        }
        else if (pThread->TimeEnd > TimeEnd)
        {
            TimeEnd = pThread->TimeEnd;
        }
    }
    return (TimeEnd - TimeStart);
}

ULONG
CalculateProcessKCPU(
        PPROCESS_RECORD pProcess
    )
{
    ULONG       KCPUTotal = 0;
    ULONG       KCPUMissing = 0;
    PLIST_ENTRY pHead     = &pProcess->ThreadListHead;
    PLIST_ENTRY pNext     = pHead->Flink;
    PTHREAD_RECORD pThread;

    while (pNext != pHead)
    {
        pThread = CONTAINING_RECORD(pNext, THREAD_RECORD, Entry);
        pNext   = pNext->Flink;

        if (pThread->KCPUEnd > pThread->KCPUStart)
        {

            if ((pProcess->PID != 0) || 
                ((pProcess->PID == 0) && (pThread->TID == 0)) ){

                KCPUTotal += pThread->KCPUEnd - pThread->KCPUStart;
            }
            else {
                KCPUMissing += pThread->KCPUEnd - pThread->KCPUStart;
            }
        }
    }
    return (ULONG) (KCPUTotal * CurrentSystem.TimerResolution);
}

ULONG
CalculateProcessUCPU(
        PPROCESS_RECORD pProcess
    )
{
    ULONG       UCPUTotal = 0;
    ULONG       UCPUMissing = 0;
    PLIST_ENTRY pHead     = &pProcess->ThreadListHead;
    PLIST_ENTRY pNext     = pHead->Flink;
    PTHREAD_RECORD pThread;


    while (pNext != pHead)
    {
        pThread = CONTAINING_RECORD(pNext, THREAD_RECORD, Entry);
        pNext   = pNext->Flink;

        if (pThread->UCPUEnd > pThread->UCPUStart)
        {
            if ((pProcess->PID != 0) ||
                ((pProcess->PID == 0) && (pThread->TID == 0)) ) {
                UCPUTotal += pThread->UCPUEnd - pThread->UCPUStart;
            }
            else {
                UCPUMissing += pThread->UCPUEnd - pThread->UCPUStart;
            }
        }
    }
    return (ULONG) (UCPUTotal * CurrentSystem.TimerResolution);
}

PPRINT_JOB_RECORD 
FindPrintJobRecord(
    ULONG JobId
    )
{
    PLIST_ENTRY Head, Next;
    PPRINT_JOB_RECORD pJob;

    EnterTracelibCritSection();
    Head = &CurrentSystem.PrintJobListHead;

    Next = Head->Flink;

    while (Next != Head) {
        pJob = CONTAINING_RECORD ( Next, PRINT_JOB_RECORD, Entry );
        if (pJob->JobId == JobId) {
            LeaveTracelibCritSection();
            return pJob;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();

    return NULL;
}

PHTTP_REQUEST_RECORD 
FindHttpReqRecord(
    ULONGLONG RequestId
    )
{
    PLIST_ENTRY Head, Next;
    PHTTP_REQUEST_RECORD pReq;
    ULONG Depth = 0;

    EnterTracelibCritSection();
    Head = &CurrentSystem.HttpReqListHead;

    Next = Head->Flink;

    while (Next != Head) {
        pReq = CONTAINING_RECORD ( Next, HTTP_REQUEST_RECORD, Entry );
        if (pReq->RequestId == RequestId) {
            if (Depth > 40) {
                RemoveEntryList( &pReq->Entry );
                InsertHeadList( Head, &pReq->Entry );
            }
            LeaveTracelibCritSection();
            return pReq;
        }
        Next = Next->Flink;
        Depth++;
    }
    LeaveTracelibCritSection();

    return NULL;
}

PHTTP_REQUEST_RECORD 
FindHttpReqRecordByConId(
    ULONGLONG ConId,
    PHTTP_REQUEST_RECORD pPrevReq
    )
{
    PLIST_ENTRY Head, Next;
    PHTTP_REQUEST_RECORD pReq;
    ULONG Depth = 0;

    EnterTracelibCritSection();

    Head = &CurrentSystem.HttpReqListHead;
    Next = Head->Flink;

    while (Next != Head) {
        pReq = CONTAINING_RECORD ( Next, HTTP_REQUEST_RECORD, Entry );
        if (pReq->ConId == ConId) {
            if (pPrevReq == NULL || pPrevReq != pReq) {
                if (Depth > 40) {
                    RemoveEntryList( &pReq->Entry );
                    InsertHeadList( Head, &pReq->Entry );
                }
                LeaveTracelibCritSection();
                return pReq;
            }
        }
        Next = Next->Flink;
        Depth++;
    }

    Depth = 0;
    Head = &CurrentSystem.PendingHttpReqListHead;
    Next = Head->Flink;

    while (Next != Head) {
        pReq = CONTAINING_RECORD ( Next, HTTP_REQUEST_RECORD, Entry );
        if (pReq->ConId == ConId) {
            if (pPrevReq == NULL || pPrevReq != pReq) {
                if (Depth > 40) {
                    RemoveEntryList( &pReq->Entry );
                    InsertHeadList( Head, &pReq->Entry );
                }
                LeaveTracelibCritSection();
                return pReq;
            }
        }
        Next = Next->Flink;
        Depth++;
    }

    LeaveTracelibCritSection();

    return NULL;
}

PHTTP_REQUEST_RECORD 
FindPendingHttpReqRecord(
    ULONGLONG RequestId
    )
{
    PLIST_ENTRY Head, Next;
    PHTTP_REQUEST_RECORD pReq;
    ULONG Depth = 0;

    EnterTracelibCritSection();
    Head = &CurrentSystem.PendingHttpReqListHead;

    Next = Head->Flink;

    while (Next != Head) {
        pReq = CONTAINING_RECORD ( Next, HTTP_REQUEST_RECORD, Entry );
        if (pReq->RequestId == RequestId) {
            if (Depth > 40) {
                RemoveEntryList( &pReq->Entry );
                InsertHeadList( Head, &pReq->Entry );
            }
            LeaveTracelibCritSection();
            return pReq;
        }
        Next = Next->Flink;
        Depth++;
    }
    LeaveTracelibCritSection();

    return NULL;
}

PURL_RECORD 
FindUrlRecord(
    PUCHAR Url
    )
{
    PLIST_ENTRY Head, Next;
    PURL_RECORD pUrl;
    ULONG Depth = 0;
    ULONG UrlStrSize;
    PUCHAR UrlChar;
    BOOL bMatch;
    UCHAR TempEndChar;
    USHORT HashKey;
    
    if (Url == NULL) {
        return NULL;
    }
    
    UrlStrSize = 0;
    UrlChar = Url;
    while (*UrlChar != '\0' && *UrlChar != '?') {
        UrlStrSize++;
        UrlChar++;
    }

    // No URL will end with '/'
    if (*(UrlChar - 1) == '/') {
        UrlStrSize--;
    }
    TempEndChar = *(Url + UrlStrSize);
    *(Url + UrlStrSize) = '\0';
    HashKey = UrlHashKey(Url, UrlStrSize);

    EnterTracelibCritSection();
    Head = &CurrentSystem.URLHashList[HashKey];

    Next = Head->Flink;
    
    while (Next != Head) {
        
        pUrl = CONTAINING_RECORD ( Next, URL_RECORD, Entry );
        // pUrl->URL cannot be NULL. If it is, it shouldn't even be created.
        
        if ( _stricmp( Url, pUrl->URL ) == 0 ) {
            if (Depth > 20) {
                RemoveEntryList( &pUrl->Entry );
                InsertHeadList( Head, &pUrl->Entry );
            }
            LeaveTracelibCritSection();
            return pUrl;
        }
        Next = Next->Flink;
        Depth++;
    }
    LeaveTracelibCritSection();

    *(Url + UrlStrSize) = TempEndChar;

    return NULL;
}

PCLIENT_RECORD 
FindClientRecord(
    USHORT IpAddrType,
    ULONG IpAddrV4,
    USHORT *IpAddrV6
    )
{
    PLIST_ENTRY Head, Next;
    PCLIENT_RECORD pClient;

    if (IpAddrV6 == NULL) {
        return NULL;
    }

    EnterTracelibCritSection();
    Head = &CurrentSystem.ClientListHead;

    Next = Head->Flink;

    while (Next != Head) {
        pClient = CONTAINING_RECORD ( Next, CLIENT_RECORD, Entry );
        if (pClient->IpAddrType == IpAddrType &&
            pClient->IpAddrV4 == IpAddrV4 && 
            RtlCompareMemory(IpAddrV6, pClient->IpAddrV6, sizeof(USHORT) * 8) == sizeof(USHORT) * 8) {
            LeaveTracelibCritSection();
            return pClient;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();

    return NULL;
}

PSITE_RECORD 
FindSiteRecord(
    ULONG SiteId
    )
{
    PLIST_ENTRY Head, Next;
    PSITE_RECORD pSite;

    EnterTracelibCritSection();
    Head = &CurrentSystem.SiteListHead;

    Next = Head->Flink;

    while (Next != Head) {
        pSite = CONTAINING_RECORD ( Next, SITE_RECORD, Entry );
        if (pSite->SiteId == SiteId) {
            LeaveTracelibCritSection();
            return pSite;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();

    return NULL;
}

//
// A New Job with a JobId has been found. This routine will create a
// new job record to track it through various threads in the system
//

PPRINT_JOB_RECORD
AddPrintJobRecord(
    ULONG JobId
    )
{
    PLIST_ENTRY Head, Next;
    PPRINT_JOB_RECORD pJob = NULL;

    EnterTracelibCritSection();
    Head = &CurrentSystem.FreePrintJobListHead;

    Next = Head->Flink;

    if (Next != Head) {
        pJob = CONTAINING_RECORD ( Next, PRINT_JOB_RECORD, Entry );
        RemoveEntryList( &pJob->Entry );
    }
    LeaveTracelibCritSection();

    if (pJob == NULL) {
        pJob = malloc(sizeof(PRINT_JOB_RECORD));
        if (pJob == NULL) {
            SetLastError( ERROR_OUTOFMEMORY);
            return NULL;
        }
    }

    RtlZeroMemory(pJob, sizeof(PRINT_JOB_RECORD));
    pJob->JobId = JobId;

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.PrintJobListHead, &pJob->Entry );
    LeaveTracelibCritSection();

    return pJob;
}

PHTTP_REQUEST_RECORD
AddHttpReqRecord(
    ULONGLONG RequestId,
    USHORT    IpAddrType,
    ULONG     IpAddrV4,
    USHORT    *IpAddrV6
    )
{
    PLIST_ENTRY Head, Next;
    PHTTP_REQUEST_RECORD pReq = NULL;

    EnterTracelibCritSection();
    Head = &CurrentSystem.FreeHttpReqListHead;

    Next = Head->Flink;

    if (Next != Head) {
        pReq = CONTAINING_RECORD ( Next, HTTP_REQUEST_RECORD, Entry );
        RemoveEntryList( &pReq->Entry );
    }
    LeaveTracelibCritSection();

    if (pReq == NULL) {
        pReq = malloc(sizeof(HTTP_REQUEST_RECORD));
        if (pReq == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            return NULL;
        }
    }

    RtlZeroMemory(pReq, sizeof(HTTP_REQUEST_RECORD));
    pReq->RequestId = RequestId;
    pReq->IpAddrType = IpAddrType;
    pReq->IpAddrV4 = IpAddrV4;
    if (IpAddrV6 != NULL && IpAddrType == TDI_ADDRESS_TYPE_IP6) {
        RtlCopyMemory(&pReq->IpAddrV6, IpAddrV6, sizeof(USHORT) * 8);
    }

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.HttpReqListHead, &pReq->Entry );
    LeaveTracelibCritSection();

    return pReq;
}

PURL_RECORD
AddUrlRecord(
    PUCHAR Url
    )
{
    PLIST_ENTRY Head, Next;
    PUCHAR UrlStr = NULL, UrlChar;
    PURL_RECORD pUrl = NULL;
    ULONG UrlStrSize;
    USHORT HashKey;

    if (Url == NULL) {
        return NULL;
    }

    EnterTracelibCritSection();
    Head = &CurrentSystem.FreeURLListHead;

    Next = Head->Flink;

    if (Next != Head) {
        pUrl = CONTAINING_RECORD ( Next, URL_RECORD, Entry );
        RemoveEntryList( &pUrl->Entry );
    }
    LeaveTracelibCritSection();

    if (pUrl == NULL) {
        pUrl = malloc(sizeof(URL_RECORD));
        if (pUrl == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            return NULL;
        }
    }

    UrlStrSize = 0;
    UrlChar = Url;
    while (*UrlChar != '\0' && *UrlChar != '?') {
        UrlStrSize++;
        UrlChar++;
    }

    // No URL will end with '/'
    if (*(UrlChar - 1) == '/') {
        *(UrlChar - 1) = '\0';
        UrlStrSize--;
    }

    RtlZeroMemory(pUrl, sizeof(URL_RECORD));
    pUrl->URL = (PUCHAR)malloc(UrlStrSize + 1);
    if (pUrl->URL == NULL) {
        EnterTracelibCritSection();
        InsertHeadList( &CurrentSystem.FreeURLListHead, &pUrl->Entry );
        LeaveTracelibCritSection();
        return NULL;
    }
    strncpy(pUrl->URL, Url, UrlStrSize);
    *(pUrl->URL + UrlStrSize) = '\0';
    HashKey = UrlHashKey(pUrl->URL, UrlStrSize);
    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.URLHashList[HashKey], &pUrl->Entry );
    LeaveTracelibCritSection();

    return pUrl;
}

PURL_RECORD
FindOrAddUrlRecord(
    PUCHAR Url
    )
{
    PURL_RECORD pUrl = NULL;

    pUrl = FindUrlRecord(Url);
    if (pUrl == NULL) {
        pUrl = AddUrlRecord(Url);
    }
    return pUrl;
}

PCLIENT_RECORD
AddClientRecord(
    USHORT IpAddrType,
    ULONG IpAddrV4,
    USHORT *IpAddrV6
    )
{
    PCLIENT_RECORD pClient = NULL;

    pClient = malloc(sizeof(CLIENT_RECORD));
    if (pClient == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    RtlZeroMemory(pClient, sizeof(CLIENT_RECORD));
    pClient->IpAddrType = IpAddrType;
    pClient->IpAddrV4 = IpAddrV4;
    if (IpAddrV6 != NULL && IpAddrType == TDI_ADDRESS_TYPE_IP6) {
        RtlCopyMemory(pClient->IpAddrV6, IpAddrV6, sizeof(USHORT) * 8);
    }

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.ClientListHead, &pClient->Entry );
    LeaveTracelibCritSection();

    return pClient;
}

PCLIENT_RECORD
FindOrAddClientRecord(
    USHORT IpAddrType,
    ULONG IpAddrV4,
    USHORT *IpAddrV6
    )
{
    PCLIENT_RECORD pClient = NULL;

    pClient = FindClientRecord(IpAddrType, IpAddrV4, IpAddrV6);
    if (pClient == NULL) {
        pClient = AddClientRecord(IpAddrType, IpAddrV4, IpAddrV6);
    }
    return pClient;
}

PSITE_RECORD
AddSiteRecord(
    ULONG SiteId
    )
{
    PSITE_RECORD pSite = NULL;

    pSite = malloc(sizeof(SITE_RECORD));
    if (pSite == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    RtlZeroMemory(pSite, sizeof(SITE_RECORD));
    pSite->SiteId = SiteId;

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.SiteListHead, &pSite->Entry );
    LeaveTracelibCritSection();

    return pSite;
}

PSITE_RECORD
FindOrAddSiteRecord(
    ULONG SiteId
    )
{
    PSITE_RECORD pSite = NULL;

    pSite = FindSiteRecord(SiteId);
    if (pSite == NULL) {
        pSite = AddSiteRecord(SiteId);
    }
    return pSite;
}

PURL_RECORD
GetHeadUrlRecord(
     ULONG index
     )
{
    PLIST_ENTRY Head, Next;
    PURL_RECORD pUrl = NULL;
    
    EnterTracelibCritSection();
    Head = &CurrentSystem.URLHashList[index];
    Next = Head->Flink;

    if (Next != Head) {
        pUrl = CONTAINING_RECORD ( Next, URL_RECORD, Entry );
        RemoveEntryList( &pUrl->Entry );
    }
    LeaveTracelibCritSection();
    return pUrl;
}

PCLIENT_RECORD
GetHeadClientRecord()
{
    PLIST_ENTRY Head, Next;
    PCLIENT_RECORD pClient = NULL;

    EnterTracelibCritSection();
    Head = &CurrentSystem.ClientListHead;

    Next = Head->Flink;

    if (Next != Head) {
        pClient = CONTAINING_RECORD ( Next, CLIENT_RECORD, Entry );
        RemoveEntryList( &pClient->Entry );
    }
    LeaveTracelibCritSection();
    return pClient;
}

PSITE_RECORD
GetHeadSiteRecord()
{
    PLIST_ENTRY Head, Next;
    PSITE_RECORD pSite = NULL;

    EnterTracelibCritSection();
    Head = &CurrentSystem.SiteListHead;

    Next = Head->Flink;

    if (Next != Head) {
        pSite = CONTAINING_RECORD ( Next, SITE_RECORD, Entry );
        RemoveEntryList( &pSite->Entry );
    }
    LeaveTracelibCritSection();
    return pSite;
}

//
// Deletes a Job record with the JobId. Before deleting the contents
// of the job record is dumped to a temp file for later reporting.
//
ULONG
DeletePrintJobRecord(
    PPRINT_JOB_RECORD pJob, 
    ULONG            bSave
    )
{
    if (pJob == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // Print the Contents of pJob to file.
    //

    // If the -spooler option isn't given to the reducer this fprintf causes the
    // program to crash.  Maybe TRACE_SPOOLER should alway be set.

    if (CurrentSystem.TempPrintFile != NULL && bSave) {
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->JobId);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->KCPUTime);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->UCPUTime);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->ReadIO);
        fprintf(CurrentSystem.TempPrintFile, "%I64u, ", pJob->StartTime);
        fprintf(CurrentSystem.TempPrintFile, "%I64u, ", pJob->EndTime);
        fprintf(CurrentSystem.TempPrintFile, "%I64u, ", (pJob->ResponseTime - pJob->PauseTime));
        fprintf(CurrentSystem.TempPrintFile, "%I64u, ", pJob->PrintJobTime);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->WriteIO);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->DataType);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->JobSize);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->Pages);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->PagesPerSide);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->FilesOpened);
        fprintf(CurrentSystem.TempPrintFile, "%d, ", pJob->GdiJobSize);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->Color);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->XRes);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->YRes);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->Quality);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->Copies);
        fprintf(CurrentSystem.TempPrintFile, "%hd, ", pJob->TTOption);
        fprintf(CurrentSystem.TempPrintFile, "%d\n", pJob->NumberOfThreads);
    }

    EnterTracelibCritSection();
    RemoveEntryList( &pJob->Entry );
    InsertHeadList( &CurrentSystem.FreePrintJobListHead, &pJob->Entry );
    LeaveTracelibCritSection();
    return ERROR_SUCCESS;
}

ULONG
DeleteHttpReqRecord(
    PHTTP_REQUEST_RECORD pReq, 
    ULONG                bSave
    )
{
    if (pReq == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // Print the Contents of pReq to file.
    //

    if (CurrentSystem.TempIisFile != NULL && bSave) {
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->RequestId);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->SiteId);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->KCPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->UCPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->ReadIO);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->WriteIO);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ULStartTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ULEndTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ULResponseTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ULParseTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ULDeliverTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ULReceiveTime);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->ULReceiveType);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->ULEndType);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->W3StartTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->W3EndTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->W3FilterResponseTime);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->W3ProcessType);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->W3EndType);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->FileReqTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->CGIStartTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->CGIEndTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ISAPIStartTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ISAPIEndTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ASPStartTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->ASPEndTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->SSLResponseTime);
        fprintf(CurrentSystem.TempIisFile, "%I64u, ", pReq->StrmFltrResponseTime);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->HttpStatus);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IsapiExt);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrType);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->IpAddrV4);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[0]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[1]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[2]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[3]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[4]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[5]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[6]);
        fprintf(CurrentSystem.TempIisFile, "%hd, ", pReq->IpAddrV6[7]);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->NumberOfThreads);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->BytesSent);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->ULCPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->W3CPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->W3FltrCPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->ISAPICPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d, ", pReq->ASPCPUTime);
        fprintf(CurrentSystem.TempIisFile, "%d,", pReq->CGICPUTime);
        if (pReq->URL != NULL) {
            fprintf(CurrentSystem.TempIisFile, "%s\n", pReq->URL);
            free(pReq->URL);
        }
        else {
            fprintf(CurrentSystem.TempIisFile, "Unknown\n");
        }
    }

    EnterTracelibCritSection();
    RemoveEntryList( &pReq->Entry );
    InsertHeadList( &CurrentSystem.FreeHttpReqListHead, &pReq->Entry );
    LeaveTracelibCritSection();
    return ERROR_SUCCESS;
}

ULONG
DeleteUrlRecord(
    PURL_RECORD pUrl
    )
{
    if (pUrl == NULL)
        return ERROR_INVALID_PARAMETER;
    if (pUrl->URL != NULL) {
        free(pUrl->URL);
    }
    EnterTracelibCritSection();
    RemoveEntryList( &pUrl->Entry );
    InsertHeadList( &CurrentSystem.FreeURLListHead, &pUrl->Entry );
    LeaveTracelibCritSection();
    return ERROR_SUCCESS;
}

ULONG
DeleteClientRecord(
    PCLIENT_RECORD pClient
    )
{
    if (pClient == NULL)
        return ERROR_INVALID_PARAMETER;
    EnterTracelibCritSection();
    RemoveEntryList( &pClient->Entry );
    LeaveTracelibCritSection();
    free(pClient);
    return ERROR_SUCCESS;
}

ULONG
DeleteSiteRecord(
    PSITE_RECORD pSite
    )
{
    if (pSite == NULL)
        return ERROR_INVALID_PARAMETER;
    EnterTracelibCritSection();
    RemoveEntryList( &pSite->Entry );
    LeaveTracelibCritSection();
    free(pSite);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\main.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.c

Abstract:

    TRACELIB dll main file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

#include <stdio.h>
#include "cpdata.h"
#include "tracectr.h"

SYSTEM_RECORD CurrentSystem;
static ULONG   lCachedFlushTimer = 1;
PTRACE_CONTEXT_BLOCK TraceContext = NULL;
RTL_CRITICAL_SECTION TLCritSect;

BOOLEAN fDSOnly       = FALSE;
BOOLEAN XPorHigher    = FALSE;
ULONGLONG DSStartTime = 0;
ULONGLONG DSEndTime   = 0;
ULONG TotalBuffersRead = 0;
ULONG TotalBuffersExpected = 0;
WCHAR TempPrintFile[MAXSTR] = L"";
WCHAR TempIisFile[MAXSTR] = L"";

FARPROC EtwpIpv4ToStringA = NULL;
FARPROC EtwpIpv4ToStringW = NULL;
FARPROC EtwpIpv6ToStringA = NULL;
FARPROC EtwpIpv6ToStringW = NULL;
HINSTANCE ntdll;

extern LIST_ENTRY g_ValueMapTable;

ULONG
WINAPI
TerminateOnBufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

extern WriteProc(
    LPWSTR filename,
    ULONG flags,
    PVOID pUserContext
);

HRESULT 
OnProcess(
    PTRACE_CONTEXT_BLOCK TraceContext
);        

ULONG GetMoreBuffers(
    PEVENT_TRACE_LOGFILE logfile 
);

void
ReorderThreadList()
{
    PLIST_ENTRY Head, Next;
    PTHREAD_RECORD Thread;
    int i;
    PPROCESS_RECORD Process;
    for (i=0; i < THREAD_HASH_TABLESIZE; i++) {

        Head = &CurrentSystem.ThreadHashList[i];
        Next = Head->Flink;
        while (Next != Head) {
            Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
            Next = Next->Flink;
            RemoveEntryList( &Thread->Entry );
            Process = Thread->pProcess;
            if(Process != NULL){
                InsertTailList( &Process->ThreadListHead, &Thread->Entry );
            }
        }
    }
}
    
ULONG
CPDAPI
GetMaxLoggers()
{
    return MAXLOGGERS;
}

//
// The second argument is only for merging trace files. pMergedEventsLost 
// can be NULL.
// EventsLost in the file header may not have the correct event lost count 
// when merging multiple files.
//
ULONG
CPDAPI
InitTraceContextW(
    PTRACE_BASIC_INFOW pUserInfo,
    PULONG pMergedEventsLost
    )
{
    UINT i, j;
    PFILE_OBJECT *fileTable;
    ULONG SizeNeeded, SizeIncrement;
    char * pStorage;
    HRESULT hr;
    BOOL bProcessing = FALSE;
    OSVERSIONINFO OSVersion;

    if (pUserInfo == NULL) {
        return ERROR_INVALID_DATA;
    }

    //
    // Must provide at least one logfile or a trace seassion to process
    //

    if ( (pUserInfo->LoggerCount == 0) && (pUserInfo->LogFileCount == 0) ) {
        return ERROR_INVALID_DATA;
    }

    //
    // Can not process both RealTime stream and a logfile at the same time
    //

    if ( (pUserInfo->LoggerCount > 0) && (pUserInfo->LogFileCount > 0) ) {
        return ERROR_INVALID_DATA;
    }

    //
    // Compute the Size Needed for allocation. 
    //

    SizeNeeded = sizeof(TRACE_CONTEXT_BLOCK);

    // Add LogFileName Strings

    for (i = 0; i < pUserInfo->LogFileCount; i++) {
        SizeNeeded +=  sizeof(WCHAR) * ( wcslen( pUserInfo->LogFileName[i] ) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    // Add LoggerName Strings

    for (i = 0; i < pUserInfo->LoggerCount; i++) {
        SizeNeeded += sizeof(WCHAR) * ( wcslen(pUserInfo->LoggerName[i]) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    //
    // Add ProcFile, MofFile, DumpFile, SummaryFile, TempFile name strings

    if (pUserInfo->ProcFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->ProcFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->MofFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->MofFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->DefMofFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->DefMofFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->DumpFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->DumpFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->MergeFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->MergeFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->CompFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->CompFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->SummaryFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->SummaryFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->XSLDocName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->XSLDocName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    //
    // Add Room for the FileTable Caching
    //

    SizeNeeded += sizeof(PFILE_OBJECT) * MAX_FILE_TABLE_SIZE;


    //
    // Add Room for Thread Hash List 
    //

    SizeNeeded += sizeof(LIST_ENTRY) * THREAD_HASH_TABLESIZE;

    //
    // Add Room for URL Hash List 
    //

    SizeNeeded += sizeof(LIST_ENTRY) * URL_HASH_TABLESIZE;


    //
    // Allocate Memory for TraceContext 
    // 

    pStorage = malloc(SizeNeeded);
    if (pStorage == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(pStorage, SizeNeeded);

    TraceContext = (PTRACE_CONTEXT_BLOCK)pStorage;

    pStorage += sizeof(TRACE_CONTEXT_BLOCK);

    //
    // Initialize HandleArray
    //
   
    for (i=0; i < MAXLOGGERS; i++) {
        TraceContext->HandleArray[i] = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    //
    // Copy LogFileNames
    //

    for (i = 0; i < pUserInfo->LogFileCount; i++) {
        TraceContext->LogFileName[i] = (LPWSTR)pStorage; 
        StringCchCopyW(TraceContext->LogFileName[i], 
                       wcslen(pUserInfo->LogFileName[i]) + 1, 
                       pUserInfo->LogFileName[i]);
        SizeIncrement = (wcslen(TraceContext->LogFileName[i]) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    //
    // Copy LoggerNames
    //

    for (i = 0; i < pUserInfo->LoggerCount; i++) {
        j = i + pUserInfo->LogFileCount;
        TraceContext->LoggerName[j] =(LPWSTR) pStorage;
        StringCchCopyW(TraceContext->LoggerName[i], 
                       wcslen(pUserInfo->LoggerName[i]) + 1, 
                       pUserInfo->LoggerName[i]);
        SizeIncrement = (wcslen(TraceContext->LoggerName[j]) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }
    
    //
    // Copy Other File Names
    //

    if (pUserInfo->ProcFileName != NULL) {
        TraceContext->ProcFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->ProcFileName, 
                       wcslen(pUserInfo->ProcFileName) + 1, 
                       pUserInfo->ProcFileName);
        SizeIncrement = (wcslen(TraceContext->ProcFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->DumpFileName != NULL) {
        TraceContext->DumpFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->DumpFileName, 
                       wcslen(pUserInfo->DumpFileName) + 1, 
                       pUserInfo->DumpFileName);
        SizeIncrement = (wcslen(TraceContext->DumpFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->MofFileName != NULL) {
        TraceContext->MofFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->MofFileName, 
                       wcslen(pUserInfo->MofFileName) + 1, 
                       pUserInfo->MofFileName);
        SizeIncrement = (wcslen(TraceContext->MofFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->DefMofFileName != NULL) {
        TraceContext->DefMofFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->DefMofFileName, 
                       wcslen(pUserInfo->DefMofFileName) + 1, 
                       pUserInfo->DefMofFileName);
        SizeIncrement = (wcslen(TraceContext->DefMofFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->MergeFileName != NULL) {
        TraceContext->MergeFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->MergeFileName, 
                       wcslen(pUserInfo->MergeFileName) + 1, 
                       pUserInfo->MergeFileName);
        SizeIncrement = (wcslen(TraceContext->MergeFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->CompFileName != NULL) {
        TraceContext->CompFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->CompFileName, 
                       wcslen(pUserInfo->CompFileName) + 1, 
                       pUserInfo->CompFileName);
        SizeIncrement = (wcslen(TraceContext->CompFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->SummaryFileName != NULL) {
        TraceContext->SummaryFileName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->SummaryFileName, 
                       wcslen(pUserInfo->SummaryFileName) + 1, 
                       pUserInfo->SummaryFileName);
        SizeIncrement = (wcslen(TraceContext->SummaryFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->XSLDocName != NULL) {
        TraceContext->XSLDocName = (LPWSTR)pStorage;
        StringCchCopyW(TraceContext->XSLDocName, 
                       wcslen(pUserInfo->XSLDocName) + 1, 
                       pUserInfo->XSLDocName);
        SizeIncrement = (wcslen(TraceContext->XSLDocName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    TraceContext->LogFileCount = pUserInfo->LogFileCount;
    TraceContext->LoggerCount = pUserInfo->LoggerCount;
    TraceContext->StartTime = pUserInfo->StartTime;
    TraceContext->EndTime   = pUserInfo->EndTime;
    TraceContext->Flags     = pUserInfo->Flags;
    TraceContext->hEvent    = pUserInfo->hEvent;
    TraceContext->pUserContext = pUserInfo->pUserContext;

    RtlZeroMemory(&CurrentSystem, sizeof(SYSTEM_RECORD));
    InitializeListHead ( &CurrentSystem.ProcessListHead );
    InitializeListHead ( &CurrentSystem.GlobalThreadListHead );
    InitializeListHead ( &CurrentSystem.GlobalDiskListHead );
    InitializeListHead ( &CurrentSystem.HotFileListHead );
    InitializeListHead ( &CurrentSystem.WorkloadListHead );
    InitializeListHead ( &CurrentSystem.InstanceListHead );
    InitializeListHead ( &CurrentSystem.EventListHead );
    InitializeListHead ( &CurrentSystem.GlobalModuleListHead );
    InitializeListHead ( &CurrentSystem.ProcessFileListHead );
    InitializeListHead ( &CurrentSystem.PrintJobListHead);
    InitializeListHead ( &CurrentSystem.HttpReqListHead);
    InitializeListHead ( &CurrentSystem.PendingHttpReqListHead);
    InitializeListHead ( &CurrentSystem.ClientListHead);
    InitializeListHead ( &CurrentSystem.SiteListHead);
    InitializeListHead ( &CurrentSystem.LogicalDriveHead);

    InitializeListHead ( &CurrentSystem.FreePrintJobListHead);
    InitializeListHead ( &CurrentSystem.FreeTransListHead);
    InitializeListHead ( &CurrentSystem.FreeHttpReqListHead);
    InitializeListHead ( &CurrentSystem.FreeURLListHead);

    InitializeListHead ( &g_ValueMapTable );

    CurrentSystem.FileTable = (PFILE_OBJECT *) pStorage; 
    pStorage +=  ( sizeof(PFILE_OBJECT) * MAX_FILE_TABLE_SIZE);

    CurrentSystem.ThreadHashList = (PLIST_ENTRY)pStorage; 
    pStorage += (sizeof(LIST_ENTRY) * THREAD_HASH_TABLESIZE);

    RtlZeroMemory(CurrentSystem.ThreadHashList, sizeof(LIST_ENTRY) * THREAD_HASH_TABLESIZE);

    for (i=0; i < THREAD_HASH_TABLESIZE; i++) { 
        InitializeListHead (&CurrentSystem.ThreadHashList[i]); 
    }

    CurrentSystem.URLHashList = (PLIST_ENTRY)pStorage; 
    pStorage += (sizeof(LIST_ENTRY) * URL_HASH_TABLESIZE);

    RtlZeroMemory(CurrentSystem.URLHashList, sizeof(LIST_ENTRY) * URL_HASH_TABLESIZE);

    for (i=0; i < URL_HASH_TABLESIZE; i++) { 
        InitializeListHead (&CurrentSystem.URLHashList[i]); 
    }

    if( (pUserInfo->Flags & TRACE_DUMP) && NULL != pUserInfo->DumpFileName ){
        TraceContext->Flags |= TRACE_DUMP;
    }

    if( (pUserInfo->Flags & TRACE_SUMMARY) && NULL != pUserInfo->SummaryFileName ){
        TraceContext->Flags |= TRACE_SUMMARY;
    }

    if( (pUserInfo->Flags & TRACE_INTERPRET) && NULL != pUserInfo->CompFileName ){
        TraceContext->Flags |= TRACE_INTERPRET;
    }
    
    hr = GetTempName( TempPrintFile, MAXSTR );
    CHECK_HR(hr);

    CurrentSystem.TempPrintFile = _wfopen( TempPrintFile, L"w+");
    if( CurrentSystem.TempPrintFile == NULL ){
        hr = GetLastError();
    }
    CHECK_HR(hr);

    hr = GetTempName( TempIisFile, MAXSTR );
    CHECK_HR(hr);

    CurrentSystem.TempIisFile = _wfopen( TempIisFile, L"w+");
    if( CurrentSystem.TempIisFile == NULL ){
        hr = GetLastError();
    }
    CHECK_HR(hr);
    
    CurrentSystem.fNoEndTime = FALSE;
    fileTable = CurrentSystem.FileTable;
    for ( i= 0; i<MAX_FILE_TABLE_SIZE; i++){ fileTable[i] = NULL; }

    //
    // Set the default Processing Flags to Dump
    //

    if( pUserInfo->Flags & TRACE_EXTENDED_FMT ){
        TraceContext->Flags |= TRACE_EXTENDED_FMT;
    }

    if( pUserInfo->Flags & TRACE_REDUCE ) {
        TraceContext->Flags |= TRACE_REDUCE;
        TraceContext->Flags |= TRACE_BASIC_REPORT;
    }

    if( pUserInfo->Flags & TRACE_TRANSFORM_XML ){
        TraceContext->Flags |= TRACE_TRANSFORM_XML;
    }

    if( pUserInfo->StatusFunction != NULL ){
        TraceContext->StatusFunction = pUserInfo->StatusFunction;
    }
    
    if (TraceContext->Flags & TRACE_DS_ONLY)    {
        fDSOnly = TRUE;
        DSStartTime = pUserInfo->DSStartTime;
        DSEndTime   = pUserInfo->DSEndTime;
    }

    if( TraceContext->Flags & TRACE_MERGE_ETL ){
        // Update merged events lost count.
        ULONG EventsLost;
        hr = EtwRelogEtl( TraceContext, &EventsLost );
        if (NULL != pMergedEventsLost) {
            *pMergedEventsLost = EventsLost;
        }
        goto cleanup;
    }
       
    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&OSVersion)) {
        XPorHigher = (OSVersion.dwMajorVersion > 5) || 
                     ((OSVersion.dwMajorVersion == 5) && (OSVersion.dwMinorVersion >= 1));
        if (XPorHigher) {
        ntdll = LoadLibraryW(L"ntdll.dll");
            if (ntdll != NULL) {
                EtwpIpv4ToStringA = GetProcAddress(ntdll, "RtlIpv4AddressToStringA");
                EtwpIpv4ToStringW = GetProcAddress(ntdll, "RtlIpv4AddressToStringW");
                EtwpIpv6ToStringA = GetProcAddress(ntdll, "RtlIpv6AddressToStringA");
                EtwpIpv6ToStringW = GetProcAddress(ntdll, "RtlIpv6AddressToStringW");
            }
        }
    }

    bProcessing = TRUE;

    RtlInitializeCriticalSection(&TLCritSect);

    //
    // Startup a Thread to update the counters. 
    // For Logfile replay we burn a thread and throttle it at the 
    // BufferCallbacks. 
    //

    hr = OnProcess(TraceContext);// Then process Trace Event Data. 

    ShutdownThreads();
    ShutdownProcesses();
    ReorderThreadList();

cleanup:
    if( ERROR_SUCCESS != hr ){
        __try{
            if( TraceContext->hDumpFile ){
                fclose( TraceContext->hDumpFile );
            }
            if( bProcessing ){
                Cleanup();
                RtlDeleteCriticalSection(&TLCritSect);
            }
            if( CurrentSystem.ComputerName != NULL ) {
                free(CurrentSystem.ComputerName);
            }
            if( CurrentSystem.TempPrintFile != NULL ){
                fclose( CurrentSystem.TempPrintFile );
                CurrentSystem.TempPrintFile = NULL;
                DeleteFile( TempPrintFile );
            }
            if( CurrentSystem.TempIisFile != NULL ){
                fclose( CurrentSystem.TempIisFile );
                CurrentSystem.TempIisFile = NULL;
                DeleteFile( TempIisFile );
            }
            if( NULL != TraceContext ){
                free(TraceContext);
                TraceContext = NULL;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return hr;
}

//  Buffer Callback. Used to send a flag to the logstream processing thread.
//
ULONG
GetMoreBuffers(
    PEVENT_TRACE_LOGFILE logfile 
    )
{
    TotalBuffersRead++;

    if( NULL != TraceContext->StatusFunction ){
        if( TotalBuffersExpected > 0 && (TotalBuffersRead % 2 == 0) ){
            __try{
                TraceContext->StatusFunction(
                    TRACE_STATUS_PROCESSING,
                    (double)TotalBuffersRead/(double)TotalBuffersExpected
                    );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                TraceContext->StatusFunction = NULL;
            }
        }
    }

    if (TraceContext->hEvent) {
        SetEvent(TraceContext->hEvent); 
    }
    //
    // While processing logfile playback, we can throttle the processing
    // of buffers by the FlushTimer value (in Seconds)
    //

    if (TraceContext->Flags & TRACE_LOG_REPLAY) {
        _sleep(TraceContext->LoggerInfo->FlushTimer * 1000);
    }
    if(logfile->EventsLost) {
#if DBG
        DbgPrint("(TRACECTR) GetMorBuffers(Lost: %9d   Filled: %9d\n",
                logfile->EventsLost, logfile->Filled );
#endif
    }
    return (TRUE);
}

ULONG 
CPDAPI
DeinitTraceContext(
    PTRACE_BASIC_INFOW pUserInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG LogFileCount, i;

    if (TraceContext == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    LogFileCount = TraceContext->LogFileCount + TraceContext->LoggerCount;
    for (i=0; i < LogFileCount; i++) {
        if (TraceContext->HandleArray[i] != (TRACEHANDLE)INVALID_HANDLE_VALUE) {

            CloseTrace(TraceContext->HandleArray[i]);
            TraceContext->HandleArray[i] = (TRACEHANDLE)INVALID_HANDLE_VALUE;
        }
    }

    //
    // Write the Summary File
    //

    if (TraceContext->Flags & TRACE_SUMMARY) {
        WriteSummary();
    }
        
    if (TraceContext->Flags & TRACE_REDUCE) {
        if ((TraceContext->ProcFileName != NULL) && 
            (lstrlenW(TraceContext->ProcFileName) ) ){
            
            WCHAR buffer[MAXSTR];
            HRESULT hr;

            if( TraceContext->Flags & TRACE_TRANSFORM_XML &&
                TraceContext->XSLDocName != NULL ){
                
                GetTempName( buffer, MAXSTR );
            }else{
                hr = StringCchCopy( buffer, MAXSTR, TraceContext->ProcFileName );
            }

            WriteProc( buffer, 
                      TraceContext->Flags, 
                      TraceContext->pUserContext
                      );

            if( TraceContext->Flags & TRACE_TRANSFORM_XML &&
                TraceContext->XSLDocName != NULL ){

                Status = TransformXML( 
                        buffer, 
                        TraceContext->XSLDocName, 
                        TraceContext->ProcFileName );

                DeleteFile( buffer );

            }

        }
    }

    if( CurrentSystem.ComputerName != NULL ) {
        free(CurrentSystem.ComputerName);
    }
    if( CurrentSystem.TempPrintFile != NULL ){
        fclose( CurrentSystem.TempPrintFile );
        CurrentSystem.TempPrintFile = NULL;
        DeleteFile( TempPrintFile );
    }
    if( CurrentSystem.TempIisFile != NULL ){
        fclose( CurrentSystem.TempIisFile );
        CurrentSystem.TempIisFile = NULL;
        DeleteFile( TempIisFile );
    }

    if (TraceContext->Flags & TRACE_DUMP) {
        if (TraceContext->hDumpFile != NULL) {
            fclose(TraceContext->hDumpFile);
        }
    }

    Cleanup();
    
    RtlDeleteCriticalSection(&TLCritSect);

    free (TraceContext);
    TraceContext = NULL;

    return (Status);
}

void
CountFileBuffers( LPWSTR szFile )
{
    HANDLE hFile;
    DWORD dwStatus;
    DWORD dwFileSize;
    ULONG BufferSize;
    BOOL bStatus;
    DWORD dwBytesRead;
    
    hFile = CreateFile(
                szFile,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    
    if( hFile == INVALID_HANDLE_VALUE){
        dwStatus = GetLastError();
    }else{

        dwFileSize = GetFileSize( hFile, NULL );
        
        if( INVALID_FILE_SIZE != dwFileSize && dwFileSize > 0){
            bStatus = ReadFile( 
                    hFile, 
                    &BufferSize, 
                    sizeof(ULONG), 
                    &dwBytesRead, 
                    NULL );
            if( bStatus && BufferSize > 0 ){
                TotalBuffersExpected += (dwFileSize / BufferSize );
            }
        }

        
        CloseHandle(hFile);
    }
}


HRESULT 
OnProcess(
    PTRACE_CONTEXT_BLOCK TraceContext
    )
{
    ULONG LogFileCount;
    ULONG i;

    ULONG Status;
    PEVENT_TRACE_LOGFILE LogFile[MAXLOGGERS];
    BOOL bRealTime;

    RtlZeroMemory( &LogFile[0], sizeof(PVOID) * MAXLOGGERS );

    if( TraceContext->LogFileCount > 0 ){
        LogFileCount = TraceContext->LogFileCount;
        bRealTime = FALSE;
    }else{
        LogFileCount = TraceContext->LoggerCount;
        bRealTime = TRUE;
    }

    for (i = 0; i < LogFileCount; i++) {
        LogFile[i] = malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (LogFile[i] == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        RtlZeroMemory(LogFile[i], sizeof(EVENT_TRACE_LOGFILE));

        if (bRealTime) {
            LogFile[i]->LoggerName = TraceContext->LoggerName[i];
            LogFile[i]->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
        }
        else {

            LogFile[i]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACK)&TerminateOnBufferCallback;
            LogFile[i]->LogFileName = TraceContext->LogFileName[i];
            CountFileBuffers( LogFile[i]->LogFileName );
        }
    }

    if (!bRealTime) {

        for (i = 0; i < LogFileCount; i++) {

            TraceContext->HandleArray[i] = OpenTrace(LogFile[i]);
        
            if ((TRACEHANDLE)INVALID_HANDLE_VALUE == TraceContext->HandleArray[i] ) {
                Status = GetLastError();
                goto cleanup;
            }

            Status = ProcessTrace( &(TraceContext->HandleArray[i]), 1, NULL, NULL);
            if( ERROR_CANCELLED != Status && ERROR_SUCCESS != Status ){
                goto cleanup;
            }
        }
 
        for (i = 0; i < LogFileCount; i++){
            Status = CloseTrace(TraceContext->HandleArray[i]);
        }
    }


    for (i=0; i<LogFileCount; i++) {
        
        LogFile[i]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACK)&GetMoreBuffers;
        LogFile[i]->EventCallback = (PEVENT_CALLBACK)GeneralEventCallback;

        TraceContext->HandleArray[i] = OpenTrace( (PEVENT_TRACE_LOGFILE)LogFile[i]);

        if ( TraceContext->HandleArray[i] == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
            Status =  GetLastError();
            goto cleanup;
        }
    }

    if( TraceContext->Flags & TRACE_DUMP ){
        FILE* f = _wfopen ( TraceContext->DumpFileName, L"w" );
        if( f == NULL) {
            Status = GetLastError();
            goto cleanup;
        }
        if( TraceContext->Flags & TRACE_EXTENDED_FMT ){
            fwprintf( f, 
                    L"%12s, %10s, %8s,%8s,%8s,%11s,%21s,%11s,%11s, User Data\n",
                    L"Event Name", L"Type", 
                    L"Type", L"Level", L"Version", 
                    L"TID", L"Clock-Time",
                    L"Kernel(ms)", L"User(ms)"
                    );
        }else{
            fwprintf( f,
                    L"%12s, %10s,%11s,%21s,%11s,%11s, User Data\n",
                    L"Event Name", L"Type", L"TID", L"Clock-Time",
                    L"Kernel(ms)", L"User(ms)"
                    );
        }
        
        TraceContext->hDumpFile = f;
    }

    DeclareKernelEvents();

    if( bRealTime ){
        GetSystemTimeAsFileTime((LPFILETIME)&CurrentSystem.StartTime);
    }

    Status = ProcessTrace(TraceContext->HandleArray,
                 LogFileCount,
                 NULL,
                 NULL);
    
    if( bRealTime && (0 == CurrentSystem.EndTime )) {
       GetSystemTimeAsFileTime((LPFILETIME)&CurrentSystem.EndTime); 
    }

    if( bRealTime && (ERROR_WMI_INSTANCE_NOT_FOUND == Status) ){
        Status = ERROR_SUCCESS;
    }

    CurrentSystem.ElapseTime = (ULONG) (  CurrentSystem.EndTime
                                        - CurrentSystem.StartTime);

cleanup:
    for (i=0; i < LogFileCount; i++){
        
        if( (TRACEHANDLE)INVALID_HANDLE_VALUE != TraceContext->HandleArray[i] ){

            CloseTrace(TraceContext->HandleArray[i]);
            TraceContext->HandleArray[i] = (TRACEHANDLE)INVALID_HANDLE_VALUE;
        }
        
        if( NULL != LogFile[i] ){
            free(LogFile[i]);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\transform.cpp ===
#include <stdio.h>
#include <atlbase.h>
#include <msxml2.h>

template <class Base>
class  __declspec(novtable) StackUnknown : public Base
{
public:
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef() {return 1;}
    virtual ULONG STDMETHODCALLTYPE Release() {return 1;}
};


template <class Base>
HRESULT STDMETHODCALLTYPE
StackUnknown<Base>::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == __uuidof(Base) || riid == __uuidof(IUnknown))
    {
        //
        // No need to AddRef since this class 
        // will only be created on the stack
        //
        *ppv = this;
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

class FileOutputStream : public StackUnknown<ISequentialStream>
{
public:
    FileOutputStream() {_fClose = false;}
    ~FileOutputStream() {Close();}

    HRESULT Init(HANDLE h) { _h = h; _fClose = false; return S_OK;}
    HRESULT Init(const WCHAR * pwszFileName);

    void Close() {if (_fClose) {::CloseHandle(_h); _fClose = false;} }

    virtual HRESULT STDMETHODCALLTYPE 
        Read(void * pv, ULONG cb, ULONG * pcbRead) {return E_NOTIMPL;}

    virtual HRESULT STDMETHODCALLTYPE 
        Write(void const * pv, ULONG cb, ULONG * pcbWritten);

private:
    HANDLE  _h;
    bool    _fClose;
};

HRESULT
FileOutputStream::Init(const WCHAR * pwszFileName)
{
    HRESULT hr = S_OK;

    _h =::CreateFileW(
            pwszFileName,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if( INVALID_HANDLE_VALUE != _h ){
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    _fClose = true;

    return hr;
}

HRESULT STDMETHODCALLTYPE
FileOutputStream::Write(void const * pv, ULONG cb, ULONG * pcbWritten)
{
    HRESULT hr = S_OK;
    BOOL bResult;
    
    bResult = ::WriteFile(
                _h,
                pv,
                cb,
                pcbWritten,
                NULL);
    
    if( !bResult ){
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}

extern "C" {

HRESULT TransformXML( LPWSTR szXML, LPWSTR szXSL, LPWSTR szResult )
{
    HRESULT hr;
    
    IXMLDOMDocument* pXMLDoc = NULL;
    IXMLDOMDocument* pXSLDoc = NULL;
    IXSLTemplate* pTemplate = NULL;
    IXSLProcessor * pProcessor = NULL;
    FileOutputStream OutputStream;
    
    BSTR bszResult = NULL;
    VARIANT_BOOL vStatus;
    VARIANT vXML;
    VARIANT vXSL;
    VARIANT vDoc;
    
    VariantInit( &vXML );
    VariantInit( &vXSL );

    hr = OutputStream.Init(szResult);
    if(FAILED(hr)){ goto cleanup; }

    vXML.vt = VT_BSTR;
    vXML.bstrVal = SysAllocString( szXML );

    vXSL.vt = VT_BSTR;
    vXSL.bstrVal = SysAllocString( szXSL );

    hr = CoInitialize(0);

    hr = CoCreateInstance(
                CLSID_FreeThreadedDOMDocument, 
                NULL, 
                CLSCTX_SERVER, 
                IID_IXMLDOMDocument, 
                (void**)&pXMLDoc );
    if(FAILED(hr)){ goto cleanup; }

    hr = CoCreateInstance(
                CLSID_FreeThreadedDOMDocument, 
                NULL, 
                CLSCTX_SERVER, 
                IID_IXMLDOMDocument, 
                (void**)&pXSLDoc );
    if(FAILED(hr)){ goto cleanup; }

    hr = CoCreateInstance(
                CLSID_XSLTemplate, 
                NULL, 
                CLSCTX_SERVER, 
                IID_IXSLTemplate, 
                (void**)&pTemplate );
    if(FAILED(hr)){ goto cleanup; }

    hr = pXMLDoc->put_preserveWhiteSpace(VARIANT_TRUE);
    hr = pXMLDoc->put_async(VARIANT_FALSE);
    hr = pXMLDoc->load( vXML, &vStatus );
    if(FAILED(hr) || vStatus == false ){ goto cleanup; }

    hr = pXSLDoc->put_preserveWhiteSpace(VARIANT_TRUE);
    hr = pXSLDoc->put_async(VARIANT_FALSE);
    hr = pXSLDoc->load( vXSL, &vStatus );
    if(FAILED(hr) || vStatus == false ){ goto cleanup; }

    hr = pTemplate->putref_stylesheet(pXSLDoc);

    vDoc.vt = VT_UNKNOWN;
    vDoc.punkVal = (IUnknown*)pXMLDoc;
    
    pTemplate->createProcessor(&pProcessor);    
    hr = pProcessor->put_input( vDoc );
    
    vDoc.punkVal = &OutputStream;
    hr = pProcessor->put_output( vDoc );

    hr = pProcessor->transform( &vStatus );

cleanup:
    if( NULL != pTemplate ){
        pTemplate->Release();
    }
    if( NULL != pProcessor ){
        pProcessor->Release();
    }
    if( NULL != pXMLDoc ){
        pXMLDoc->Release();
    }
    if( NULL != pXSLDoc ){
        pXSLDoc->Release();
    }
    
    VariantClear( &vXML );
    VariantClear( &vXSL );

    return hr;
}

} //extern C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracefmt\tracefmt.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceformat.c

Abstract:

    Formats trace entries into messages based on the original sample trace
    consumer program (tracedmp).

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    Ian Service (ianserv) 1999 - converted to message formatting

--*/

#ifdef __cplusplus
extern "C"{
#endif 
#define UNICODE
#define _UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#define POBJECT_ATTRIBUTES PVOID
#include <ntwmi.h>
#include "traceprt.h"

#define DUMP_FILE_NAME          _T("FmtFile.txt")
#define SUMMARY_FILE_NAME       _T("FmtSum.txt")
#define DEFAULT_LOGFILE_NAME    _T("C:\\Logfile.Etl")

FILE* DumpFile = NULL;
FILE* SummaryFile = NULL;

BOOL fDebugDisplay = FALSE ;
BOOL fDisplayOnly  = FALSE ;
BOOL fSummaryOnly  = FALSE ;
BOOL fNoSummary    = FALSE ;
BOOL fVerbose	   = FALSE ;
BOOL fFixUp		   = FALSE ;
BOOL fODSOutput    = FALSE ;
BOOL fTMFSpecified = FALSE ;
BOOL fCSVMode      = FALSE ;
BOOL fNoCSVHeader  = TRUE ;
BOOL fCSVHeader    = FALSE ;

#define SIZESUMMARYBLOCK 16384
TCHAR SummaryBlock[SIZESUMMARYBLOCK];

#define TRACE_FORMAT_SEARCH_PATH L"TRACE_FORMAT_SEARCH_PATH"
LPTSTR TraceFormatSearchPath = NULL;

static FILETIME      lastTime ;

static ULONG TotalBuffersRead = 0;
static ULONG TotalEventsLost = 0;
static ULONG TotalEventCount = 0;
static ULONG TimerResolution = 10;
static ULONG BufferWrap = 0 ;
__int64 ElapseTime;

PLIST_ENTRY EventListHead = NULL;

void 
DumpMofList();

void
PrintMofInfo();

BOOL
CheckFile(
    LPTSTR fileName
    );

ULONG
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    );

void 
AddMofFromWbem(
    LPTSTR EventGuid,
    LPTSTR PropName,
    DWORD  PropType
    );

void
DumpEvent(
    PEVENT_TRACE pEvent
    );

PEVENT_TRACE_LOGFILE EvmFile[MAXLOGFILES];
ULONG LogFileCount = 0;
ULONG UserMode = FALSE; // TODO: Pick this up from the stream itself.
TCHAR * szTraceMask = NULL;
void DisplayVersionInfo();

int
 __cdecl main (argc, argv)
    int argc;
    char **argv;
{
    TCHAR GuidFileName[MAXSTR];
    TCHAR DumpFileName[MAXSTR];
    TCHAR SummaryFileName[MAXSTR];
    LPTSTR *commandLine;
    LPTSTR *targv,  *cmdargv;
    PEVENT_TRACE_LOGFILE pLogFile;
    ULONG Action = 0;
    ULONG Status;
    ULONG GuidCount = 0;
    ULONG i, j;
    int targc;
    TRACEHANDLE HandleArray[MAXLOGFILES];

    if ((cmdargv = CommandLineToArgvW(
                        GetCommandLineW(),
                        &argc
                        )) == NULL)
    {
        return (GetLastError());
    } 
    targv = cmdargv;

    _tcscpy(DumpFileName, DUMP_FILE_NAME);
    _tcscpy(SummaryFileName, SUMMARY_FILE_NAME);

    // By default look for Define.guid in the image location

    if ((Status = GetModuleFileName(NULL, GuidFileName, MAXSTR)) == MAXSTR) {
        GuidFileName[MAXSTR-1] = _T('\0');
    }

    if( Status != 0 ){
        TCHAR drive[10];
        TCHAR path[MAXSTR];
        TCHAR file[MAXSTR];
        TCHAR ext[MAXSTR];

        _tsplitpath( GuidFileName, drive, path, file, ext );
        _tcscpy(ext, GUID_EXT );
        _tcscpy(file, GUID_FILE );
        _tmakepath( GuidFileName, drive, path, file, ext );
    }else{
        _tcscpy( GuidFileName, GUID_FILE );
        _tcscat( GuidFileName, _T(".") );
        _tcscat( GuidFileName, GUID_EXT );
    }

    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if( **targv == '/' ){
                **targv = '-';
            }

           if (targv[0][1] == 'h' || targv[0][1] == 'H'
                                       || targv[0][1] == '?')
           {
               DisplayVersionInfo();

               _tprintf(
                   _T("Usage: traceformat [options]  <evmfile>| [-h | -?]\n")
                   _T("\t-o <file>    Output file\n")
                   _T("\t-csv         Format the output as a comma seperated file")
                    //_T("\t-nocsvheader Suppress the csv header line")
                   _T("\t-tmf <file>  Format definition file\n")
                   _T("\t-p <path>    TMF file search path\n")
                   _T("\t-rt [loggername] Realtime formatting\n")
                   _T("\t-h           Display this information\n")
                   _T("\t-display     Display output\n")
                   _T("\t-displayonly Display output. Don't write to the file\n")
                   _T("\t-nosummary   Don't create the summary file\n")
                   _T("\t-noprefix    Suppress any defined TRACE_FORMAT_PREFIX")
                   _T("\t-ods         do Display output using OutputDebugString\n")
                   _T("\t-summaryonly Don't create the listing file.\n")
		           _T("\t-v           Verbose Display\n")
                   _T("\t-?           Display this information\n")
                   _T("\n")
                   _T("\tDefault evmfile is    ") DEFAULT_LOGFILE_NAME _T("\n")
                   _T("\tDefault outputfile is ") DUMP_FILE_NAME _T("\n")
                   _T("\tDefault TMF file is   ") GUID_FILE _T(".") GUID_EXT _T("\n")
                   _T("\n")
                   //_T("\tTMF file search path is read from environment variable\n")
                   //_T("\t\tTRACE_FORMAT_SEARCH_PATH\n")
                   );
               return 0;
           }
           else if (!_tcsicmp(targv[0], _T("-debug"))) {
               fDebugDisplay = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-display"))) {
               fDebugDisplay = TRUE ;
           }
           else if (!_tcsicmp(targv[0], _T("-displayonly"))) {
               fDisplayOnly = TRUE ;
           }
           else if (!_tcsicmp(targv[0], _T("-fixup"))) {
               fFixUp = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-summary"))) {
               fSummaryOnly = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-seq"))) {
               SetTraceFormatParameter(ParameterSEQUENCE, ULongToPtr(1));
           }
           else if (!_tcsicmp(targv[0], _T("-gmt"))) {
               SetTraceFormatParameter(ParameterGMT, ULongToPtr(1));
           }
           else if (!_tcsicmp(targv[0], _T("-utc"))) {
               SetTraceFormatParameter(ParameterGMT, ULongToPtr(1));
           } else if (!_tcsicmp(targv[0], _T("-nosummary"))) {
               fNoSummary = TRUE;
           } else if (!_tcsicmp(targv[0], _T("-csv"))) {
               fCSVMode = TRUE ;
               fCSVHeader = TRUE ;
               SetTraceFormatParameter(ParameterStructuredFormat,UlongToPtr(1));
           } else if (!_tcsicmp(targv[0], _T("-nocsvheader"))) {
               fNoCSVHeader = FALSE ;
           }
           else if (!_tcsicmp(targv[0], _T("-noprefix"))) {
               SetTraceFormatParameter(ParameterUsePrefix,UlongToPtr(0));
           }
           else if (!_tcsicmp(targv[0], _T("-rt"))) {
               TCHAR LoggerName[MAXSTR];
               _tcscpy(LoggerName, KERNEL_LOGGER_NAME);
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       _tcscpy(LoggerName, targv[0]);
                   }
               }
               
               pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
               if (pLogFile == NULL){
                   _tprintf(_T("Allocation Failure\n"));
                   
                   goto cleanup;
               }
               RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
               EvmFile[LogFileCount] = pLogFile;
               
               EvmFile[LogFileCount]->LogFileName = NULL;
               EvmFile[LogFileCount]->LoggerName =
                   (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
               
               if ( EvmFile[LogFileCount]->LoggerName == NULL ) {
                   _tprintf(_T("Allocation Failure\n"));
                   goto cleanup;
               }
               _tcscpy(EvmFile[LogFileCount]->LoggerName, LoggerName);
               
               _tprintf(_T("Setting RealTime mode for  %s\n"),
                        EvmFile[LogFileCount]->LoggerName);
               
               EvmFile[LogFileCount]->Context = NULL;
               EvmFile[LogFileCount]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)BufferCallback;
               EvmFile[LogFileCount]->BuffersRead = 0;
               EvmFile[LogFileCount]->CurrentTime = 0;
               EvmFile[LogFileCount]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
               EvmFile[LogFileCount]->LogFileMode =
                   EVENT_TRACE_REAL_TIME_MODE;
               LogFileCount++;
            }
            else if ( !_tcsicmp(targv[0], _T("-guid")) ) {    // maintain for compatabillity
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tcscpy(GuidFileName, targv[1]);
                        ++targv; --argc;
                        fTMFSpecified = TRUE ;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-tmf")) ) { 
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tcscpy(GuidFileName, targv[1]);
                        ++targv; --argc;
                        fTMFSpecified = TRUE ;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-p")) ){
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        SetTraceFormatParameter(ParameterTraceFormatSearchPath, targv[1]);
                        ++targv; --argc;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-v")) ) {
					fVerbose = TRUE ;
            }
            else if ( !_tcsicmp(targv[0], _T("-ods")) ) {
					fODSOutput = TRUE ;
            }
			else if ( !_tcsicmp(targv[0], _T("-onlyshow")) ) {
                if (argc > 1) {
                    szTraceMask = malloc((_tcslen(targv[1])+1) * sizeof(TCHAR));
                    _tcscpy(szTraceMask,targv[1]);
                    ++targv; --argc;
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-o")) ) {
                if (argc > 1) {

                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR drive[10];
                        TCHAR path[MAXSTR];
                        TCHAR file[MAXSTR];
                        TCHAR ext[MAXSTR];
                        ++targv; --argc;

                        _tfullpath(DumpFileName, targv[0], MAXSTR);
                        _tsplitpath( DumpFileName, drive, path, file, ext );
                        _tcscat(ext,_T(".sum"));  
                        _tmakepath( SummaryFileName, drive, path, file, ext );

                    }
                }
            }
        }
        else {
            pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
            if (pLogFile == NULL){ 
                _tprintf(_T("Allocation Failure(EVENT_TRACE_LOGFILE)\n")); // Need to cleanup better. 
                goto cleanup;
            }
            RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
            EvmFile[LogFileCount] = pLogFile;

            EvmFile[LogFileCount]->LoggerName = NULL;
            EvmFile[LogFileCount]->LogFileName = 
                (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
            if (EvmFile[LogFileCount]->LogFileName == NULL) {
                _tprintf(_T("Allocation Failure (LogFileName)\n"));
                goto cleanup;
            }
            
            _tfullpath(EvmFile[LogFileCount]->LogFileName, targv[0], MAXSTR);
            _tprintf(_T("Setting log file to: %s\n"),
                     EvmFile[LogFileCount]->LogFileName);
			            
            if (!CheckFile(EvmFile[LogFileCount]->LogFileName)) {
                _tprintf(_T("Cannot open logfile for reading\n"));
                goto cleanup;
            }
            EvmFile[LogFileCount]->Context = NULL;
            EvmFile[LogFileCount]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)BufferCallback;
            EvmFile[LogFileCount]->BuffersRead = 0;
            EvmFile[LogFileCount]->CurrentTime = 0;
            EvmFile[LogFileCount]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
            LogFileCount++;
        }
    }

    if( _tcslen( GuidFileName ) ){
        TCHAR str[MAXSTR];
        _tfullpath( str, GuidFileName, MAXSTR);
        _tcscpy( GuidFileName, str );
        _tprintf(_T("Getting guids from %s\n"), GuidFileName);
        GuidCount = GetTraceGuids(GuidFileName, (PLIST_ENTRY *) &EventListHead);
        if ((GuidCount <= 0) && fTMFSpecified)
        {
            _tprintf(_T("GetTraceGuids returned %d, GetLastError=%d, for %s\n"),
                        GuidCount,
                        GetLastError(),
                        GuidFileName);
        }
    }

    if (LogFileCount <= 0) {
        pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (pLogFile == NULL){ 
            _tprintf(_T("Allocation Failure\n")); // Need to cleanup better. 
            goto cleanup;
        }
        RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
        EvmFile[0] = pLogFile;
        EvmFile[0]->LoggerName = NULL;
        LogFileCount = 1;
        EvmFile[0]->LogFileName = (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
        if (EvmFile[0]->LogFileName == NULL) {
            _tprintf(_T("Allocation Failure\n"));
            goto cleanup;
        }
        _tcscpy(EvmFile[0]->LogFileName, DEFAULT_LOGFILE_NAME);
        EvmFile[0]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
    }

    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;
        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            _tprintf(_T("Error Opening Trace %d with status=%d\n"), 
                                                           i, GetLastError());

            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }
    if (!fDisplayOnly) {
        DumpFile = _tfopen(DumpFileName, _T("w"));
        if (DumpFile == NULL) {
            _tprintf(_T("Format File \"%s\" Could not be opened for writing 0X%X\n"),
                        DumpFileName,GetLastError());
            goto cleanup;
        }
        SummaryFile = NULL ;
        if (!fNoSummary) {
            SummaryFile = _tfopen(SummaryFileName, _T("w"));
            if (SummaryFile == NULL) {
                _tprintf(_T("Summary File \"%s\" could not be opened for writing 0X%X\n"),
                            SummaryFileName,GetLastError());
                goto cleanup;
            }
        }
    } else {
        DumpFile = stdout;
        SummaryFile = stdout;
    }

    Status = ProcessTrace(HandleArray,
                 LogFileCount,
                 NULL, NULL);
    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Error processing trace entry with status=0x%x (GetLastError=0x%x)\n"),
                Status, GetLastError());
    }

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Error Closing Trace %d with status=%d\n"), j, Status);
        }
    }


    if (!fNoSummary) {
        _ftprintf(SummaryFile,_T("Files Processed:\n"));
        for (i=0; i<LogFileCount; i++) {
            _ftprintf(SummaryFile,_T("\t%s\n"),EvmFile[i]->LogFileName);
        }
    
        GetTraceElapseTime(&ElapseTime);
    
        _ftprintf(SummaryFile,
                  _T("Total Buffers Processed %d\n")
                  _T("Total Events  Processed %d\n")
                  _T("Total Events  Lost      %d\n")
                  _T("Elapsed Time            %I64d sec\n"), 
                  TotalBuffersRead,
                  TotalEventCount,
                  TotalEventsLost,
                  (ElapseTime / 10000000) );
    
        _ftprintf(SummaryFile,
           _T("+-----------------------------------------------------------------------------------+\n")
           _T("|%10s    %-20s %-10s  %-36s|\n")
           _T("+-----------------------------------------------------------------------------------+\n"),
           _T("EventCount"),
           _T("EventName"),
           _T("EventType"),
           _T("Guid")
            );
    
        SummaryTraceEventList(SummaryBlock, SIZESUMMARYBLOCK, EventListHead);
        _ftprintf(SummaryFile,
               _T("%s+-----------------------------------------------------------------------------------+\n"),
               SummaryBlock);
    }

cleanup:
	
    CleanupTraceEventList(EventListHead);
    if (fVerbose) {
        _tprintf(_T("\n"));  // need a newline after the block updates
    }
    if (DumpFile != NULL)  {
        _tprintf(_T("Event traces dumped to %s\n"), DumpFileName);
        fclose(DumpFile);
    }

    if(SummaryFile != NULL){
        _tprintf(_T("Event Summary dumped to %s\n"), SummaryFileName);
        fclose(SummaryFile);
    }

    for (i = 0; i < LogFileCount; i ++)
    {
        if (EvmFile[i]->LoggerName != NULL)
        {
            free(EvmFile[i]->LoggerName);
            EvmFile[i]->LoggerName = NULL;
        }
        if (EvmFile[i]->LogFileName != NULL)
        {
            free(EvmFile[i]->LogFileName);
            EvmFile[i]->LogFileName = NULL;
        }
        free(EvmFile[i]);
    }

    GlobalFree(cmdargv);
    Status = GetLastError();
    if(Status != ERROR_SUCCESS ){
        _tprintf(_T("Exit Status: %d\n"), Status );
    }
    return 0;
}

void DisplayVersionInfo()
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    if ((dw = GetModuleFileName(NULL, strProgram, MAXSTR)) == MAXSTR) {
        strProgram[MAXSTR-1] = _T('\0');
    }

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _tprintf( _T("\nMicrosoft (R) %s (%s)\n%s\n\n"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }
}

ULONG
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
{
    ULONG i;
    ULONG Status;
    EVENT_TRACE_PROPERTIES LoggerProp;

    TotalBuffersRead++;
    TotalEventsLost += pLog->EventsLost;

	if (fVerbose) {

       FILETIME      stdTime, localTime;
       SYSTEMTIME    sysTime;

       RtlCopyMemory(&stdTime , &pLog->CurrentTime, sizeof(FILETIME));

       FileTimeToSystemTime(&stdTime, &sysTime);

       _tprintf(_T("%02d/%02d/%04d-%02d:%02d:%02d.%03d :: %8d: Filled=%8d, Lost=%3d"),
                    sysTime.wMonth,
                    sysTime.wDay,
                    sysTime.wYear,
                    sysTime.wHour,
                    sysTime.wMinute,
                    sysTime.wSecond,
                    sysTime.wMilliseconds,
					TotalBuffersRead,
					pLog->Filled,
					pLog->EventsLost);
	   _tprintf(_T(" TotalLost= %d\r"), TotalEventsLost);

	   if (CompareFileTime(&lastTime,&stdTime) == 1) {
		   _tprintf(_T("\nWARNING: time appears to have wrapped here (Block = %d)!\n"),TotalBuffersRead);
           BufferWrap = TotalBuffersRead;
	   }
	   lastTime = stdTime ;
	}

    return (TRUE);
}
#define DEFAULT_LOG_BUFFER_SIZE	1024

BOOL
CheckFile(
    LPTSTR fileName
    )
{
    HANDLE hFile;
	BYTE   LogHeaderBuffer[DEFAULT_LOG_BUFFER_SIZE];
	ULONG  nBytesRead ;
	ULONG  hResult ;
	PEVENT_TRACE pEvent;
	PTRACE_LOGFILE_HEADER logfileHeader ;
	LARGE_INTEGER lFileSize ;
	LARGE_INTEGER lFileSizeMB ;
	DWORD dwDesiredAccess , dwShareMode ;
	FILETIME      stdTime, localTime, endlocalTime, endTime;
	SYSTEMTIME    sysTime, endsysTime;
	PEVENT_TRACE_LOGFILE	pLogBuffer ;

	if (fFixUp) {
		dwShareMode = 0 ;
		dwDesiredAccess = GENERIC_READ | GENERIC_WRITE ;
	} else {
		dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;
		dwDesiredAccess = GENERIC_READ ;
	}
    hFile = CreateFile(
                fileName,
                dwDesiredAccess,
                dwShareMode,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if (hFile == INVALID_HANDLE_VALUE) {
		if (fFixUp) {
			_tprintf(_T("ERROR: Fixup could not open file, Error = 0x%X\n"),GetLastError());
			exit(GetLastError());
		}
		return(FALSE);
    }

	// While we are here we will look to see if the file is ok and fix up
	// Circular buffer anomolies
	if (((hResult = ReadFile(hFile,
					  (LPVOID)LogHeaderBuffer,
						DEFAULT_LOG_BUFFER_SIZE,
						&nBytesRead,
						NULL)) == 0) || nBytesRead < DEFAULT_LOG_BUFFER_SIZE) {
        _tprintf(_T("ERROR: Fixup could not read file, Error = 0x%X, bytes read = %d(of %d)\n"),
                 GetLastError(),nBytesRead,DEFAULT_LOG_BUFFER_SIZE);
        exit(ERROR_BAD_ARGUMENTS);
    }
	pEvent = (PEVENT_TRACE)LogHeaderBuffer ;
	logfileHeader = (PTRACE_LOGFILE_HEADER)&LogHeaderBuffer[sizeof(WMI_BUFFER_HEADER) + 
															sizeof(SYSTEM_TRACE_HEADER)];
	if (fVerbose) {

		_tprintf(_T("Dumping Logfile Header\n"));
        RtlCopyMemory(&stdTime , &(logfileHeader->StartTime), sizeof(FILETIME));
	    FileTimeToLocalFileTime(&stdTime, &localTime);
	    FileTimeToSystemTime(&localTime, &sysTime);

        RtlCopyMemory(&endTime , &(logfileHeader->EndTime), sizeof(FILETIME));
	    FileTimeToLocalFileTime(&endTime, &endlocalTime);
	    FileTimeToSystemTime(&endlocalTime, &endsysTime);

	    _tprintf(_T("\tStart Time	%02d/%02d/%04d-%02d:%02d:%02d.%03d\n"),
					sysTime.wMonth,
					sysTime.wDay,
					sysTime.wYear,
					sysTime.wHour,
					sysTime.wMinute,
					sysTime.wSecond,
					sysTime.wMilliseconds);
		_tprintf(_T("\tBufferSize           %d\n"), 
						logfileHeader->BufferSize);
		_tprintf(_T("\tVersion              %d\n"), 
						logfileHeader->Version);
		_tprintf(_T("\tProviderVersion      %d\n"), 
						logfileHeader->ProviderVersion);
		_tprintf(_T("\tEnd Time	%02d/%02d/%04d-%02d:%02d:%02d.%03d\n"),
					endsysTime.wMonth,
					endsysTime.wDay,
					endsysTime.wYear,
					endsysTime.wHour,
					endsysTime.wMinute,
					endsysTime.wSecond,
					endsysTime.wMilliseconds);
		_tprintf(_T("\tTimer Resolution     %d\n"), 
						logfileHeader->TimerResolution);
		_tprintf(_T("\tMaximum File Size    %d\n"), 
						logfileHeader->MaximumFileSize);
		_tprintf(_T("\tBuffers  Written     %d\n"), 
						logfileHeader->BuffersWritten);

/*
		_tprintf(_T("\tLogger Name          %ls\n"), 
						logfileHeader->LoggerName);
		_tprintf(_T("\tLogfile Name         %ls\n"), 
						logfileHeader->LogFileName);
*/
		_tprintf(_T("\tTimezone is %s (Bias is %dmins)\n"),
				logfileHeader->TimeZone.StandardName,logfileHeader->TimeZone.Bias);
        _tprintf(_T("\tLogfile Mode         %X "), 
						logfileHeader->LogFileMode);
		if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_NONE) {
			_tprintf(_T("Logfile is off(?)\n"));
		} else if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
			_tprintf(_T("Logfile is sequential\n"));
		} else if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) {
			_tprintf(_T("Logfile is circular\n"));
		}
		_tprintf(_T("\tProcessorCount        %d\n"), 
						logfileHeader->NumberOfProcessors);
	}

	if (GetFileSizeEx(hFile, &lFileSize) == 0) {
		_tprintf(_T("WARNING: Could not get file size, continuing\n"));
	} else {
		lFileSizeMB.QuadPart = lFileSize.QuadPart / (1024*1024) ;
		if (lFileSizeMB.QuadPart > logfileHeader->MaximumFileSize) {
			_tprintf(_T("WARNING: File size given as %dMB, should be %dMB\n"),
				logfileHeader->MaximumFileSize,lFileSizeMB.QuadPart);
			if (lFileSize.HighPart != 0) {
				_tprintf(_T("WARNING: Log file is TOO big"));
			}
			if (fFixUp) {
				logfileHeader->MaximumFileSize = lFileSizeMB.LowPart + 1 ;
			}
		}
	}

	if ((logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) &&
		(logfileHeader->BuffersWritten== 0 )) {
		_tprintf(_T("WARNING: Circular Trace File did not have 'wrap' address\n"));
		if (fFixUp) {
			// Figure out the wrap address
			INT LowBuff = 1, HighBuff, CurrentBuff, MaxBuff ;
			FILETIME LowTime, HighTime, CurrentTime, MaxTime ;
			if (lFileSize.HighPart != 0) {
				_tprintf(_T("ERROR: File TOO big\n"));
				exit(-1);
			}
			MaxBuff = (LONG)(lFileSize.QuadPart / logfileHeader->BufferSize) - 1 ;
            _tprintf(_T("MaxBuff=%d\n"),MaxBuff);
			pLogBuffer = malloc(logfileHeader->BufferSize);
			if (SetFilePointer(hFile,0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
				_tprintf(_T("ERROR: Could not reset file to beginning for FixUp, Error = 0x%X"),
						GetLastError());
				exit(GetLastError());
			}
			for (CurrentBuff = 1 ; CurrentBuff <= MaxBuff; CurrentBuff++) {
				if (SetFilePointer(hFile,logfileHeader->BufferSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
					_tprintf(_T("ERROR: Could not set file to next buffer for FixUp, Error = 0x%X"),
							GetLastError());
					exit(GetLastError());
				}
				hResult = ReadFile(hFile,
								   (LPVOID)pLogBuffer,
									logfileHeader->BufferSize,
									&nBytesRead,
									NULL);
				BufferCallback((PEVENT_TRACE_LOGFILE)pLogBuffer);
			}
		}
	}
	if (fFixUp) {
		if (SetFilePointer(hFile,0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			_tprintf(_T("ERROR: Could not reset file to beginning for FixUp, Error = 0x%X"),
					GetLastError());
			exit(GetLastError());
		}

        logfileHeader->BuffersWritten= BufferWrap ;

		if (!WriteFile(hFile,(LPVOID)LogHeaderBuffer,DEFAULT_LOG_BUFFER_SIZE,&nBytesRead, NULL)) {
			_tprintf(_T("ERROR: Could not Write file for FixUp, Error = 0x%X"),
					GetLastError());
			exit(GetLastError());
		}
        _tprintf(_T("INFO: Buffer Wrap reset to %d\n"),BufferWrap);
	}
	

    CloseHandle(hFile);

    return (TRUE);
}

#define SIZEEVENTBUF 32768
TCHAR EventBuf[SIZEEVENTBUF];
BYTE EventBufCSV[SIZEEVENTBUF * sizeof(TCHAR)];

#ifdef UNICODE
CHAR  EventBufA[SIZEEVENTBUF*sizeof(WCHAR)];
#endif

void
DumpEvent(
    PEVENT_TRACE pEvent
    )
{

    TotalEventCount++;

    if (pEvent == NULL) {
        _tprintf(_T("pEvent is NULL\n"));
        return;
    }
    // DumpEvent() is only a wrapper, it calls FormatTraceEvent() in TracePrt.
    //
    if (FormatTraceEvent(EventListHead,pEvent,EventBuf,SIZEEVENTBUF,NULL) > 0)
    {
        TCHAR * EventBufWork = &EventBuf[0] ;
#ifdef UNICODE
        //sprintf(_T("Name,\"SubName(File+line#)\",ThreadID,ProcessId,SequenceNumber,CPUNumber,Indent,Function,Component,TraceLevel,TraceFlags,Text\n"));
        if (fCSVMode) {
            PSTRUCTUREDMESSAGE pStructuredMessage = (PSTRUCTUREDMESSAGE)&EventBuf[0];
          /*  if (fCSVHeader && fNoCSVHeader) {
                fCSVHeader = FALSE ;
                _stprintf((TCHAR *)EventBufCSV,_T("GUIDname,TypeName,ThreadId,ProcessId,SequenceNum,CpuNumber,Indent,CompnentName,SubComponentName,FunctionName,LevelName,FlagsName, String"));
            }  */
            _stprintf((TCHAR *)EventBufCSV,_T("%s,%s,%08X,%08X,%d,%d,%d,%s,%s,%s,%s,%s,\"%s\""),
                                (pStructuredMessage->GuidName?&EventBuf[pStructuredMessage->GuidName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->GuidTypeName?&EventBuf[pStructuredMessage->GuidTypeName/sizeof(TCHAR)]:_T("")),
                                pStructuredMessage->ThreadId,
                                pStructuredMessage->ProcessId,
                                pStructuredMessage->SequenceNum,
                                pStructuredMessage->CpuNumber,
                                pStructuredMessage->Indent,
                                (pStructuredMessage->ComponentName?&EventBuf[pStructuredMessage->ComponentName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->SubComponentName?&EventBuf[pStructuredMessage->SubComponentName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->FunctionName?&EventBuf[pStructuredMessage->FunctionName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->LevelName?&EventBuf[pStructuredMessage->LevelName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->FlagsName?&EventBuf[pStructuredMessage->FlagsName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->FormattedString?&EventBuf[pStructuredMessage->FormattedString/sizeof(TCHAR)]:_T("")));
            EventBufWork = (TCHAR *)&EventBufCSV[0] ;

        }
        //
        // Convert Unicode to MultiByte
        //
        if (WideCharToMultiByte(GetConsoleOutputCP(),
                                0,
                                EventBufWork,
                                -1,
                                EventBufA,
                                SIZEEVENTBUF * sizeof(WCHAR),
                                NULL,
                                NULL ) == 0 )
	{
            //
            // do nothing, let the _ftprintf handle it.
            //
	}
        else
        {
            if (!fSummaryOnly && !fDisplayOnly) {
                fprintf(DumpFile, "%s\n", EventBufA);
            }
            if (fDebugDisplay || fDisplayOnly) {
                if (fODSOutput) {
                   OutputDebugStringA(EventBufA);
                   OutputDebugStringA("\n");
                } else {
                   printf("%s\n", EventBufA);
                }
            }
            return ;
        }
#endif	
        if (!fSummaryOnly && !fDisplayOnly) {
            _ftprintf(DumpFile, _T("%s\n"),EventBuf);
        }
        if (fDebugDisplay || fDisplayOnly) {
            if (fODSOutput) {
                OutputDebugString(EventBuf);
                OutputDebugString(_T("\n"));
            } else {
               _tprintf(_T("%s\n"),EventBuf);
            }
        }
    }
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\mergetl.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    mergetl.c

Abstract:

    Converts multiple ETL files into a single ordered ETL files. 

Author:

    Melur Raghuraman (Mraghu)  9-Dec-2000   

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <wmium.h>
#include <ntwmi.h>
#include <wmiumkm.h>
#include <evntrace.h>
#include "cpdata.h"
#include "tracectr.h"


#define MAXSTR              1024
#define LOGGER_NAME         L"{28ad2447-105b-4fe2-9599-e59b2aa9a634}"
#define LOGGER_NAME_SIZE    38

#define MAX_RETRY_COUNT      10

#define ETW_PROC_MISMATCH       0x00000001
#define ETW_MACHINE_MISMATCH    0x00000002 
#define ETW_CLOCK_MISMATCH      0x00000004
#define ETW_BOOTTIME_MISMATCH   0x00000008
#define ETW_VERSION_MISMATCH    0x00000010
#define ETW_POINTER_MISMATCH    0x00000020

TRACEHANDLE LoggerHandle;
ULONG TotalRelogBuffersRead = 0;
ULONG TotalRelogEventsRead = 0;
ULONG FailedEvents=0;
ULONG NumHdrProcessed = 0;

GUID TransactionGuid =
    {0xab8bb8a1, 0x3d98, 0x430c, 0x92, 0xb0, 0x78, 0x8f, 0x1d, 0x3f, 0x6e, 0x94};
GUID   ControlGuid[2]  =
{
    {0x42ae6427, 0xb741, 0x4e69, 0xb3, 0x95, 0x38, 0x33, 0x9b, 0xb9, 0x91, 0x80},
    {0xb9e2c2d6, 0x95fb, 0x4841, 0xa3, 0x73, 0xad, 0x67, 0x2b, 0x67, 0xb6, 0xc1}
};

typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;

PSYSTEM_TRACE_HEADER MergedSystemTraceHeader;
PTRACE_LOGFILE_HEADER MergedLogFileHeader; 
ULONG HeaderMisMatch = 0;

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};


TRACEHANDLE RegistrationHandle[2];


ULONG InitializeTrace();

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

void
WINAPI
EtwDumpEvent(
    PEVENT_TRACE pEvent
);

void
WINAPI
EtwProcessLogHeader(
    PEVENT_TRACE pEvent
    );

ULONG
WINAPI
TerminateOnBufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    );


USER_MOF_EVENT      UserMofEvent;

BOOLEAN bLoggerStarted = FALSE;
PEVENT_TRACE_LOGFILE pLogFile=NULL;

PEVENT_TRACE_LOGFILE EvmFile[MAXLOGGERS];

ULONG LogFileCount = 0;
PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
ULONG LoggerInfoSize = 0;

ULONG DifferentPointer = FALSE;

int EtwRelogEtl(
    IN OUT PTRACE_CONTEXT_BLOCK TraceContext,
    OUT PULONG pMergedEventsLost
    )
{
    ULONG Status=ERROR_SUCCESS;
    ULONG i, j;
    TRACEHANDLE HandleArray[MAXLOGGERS];
    ULONG SizeNeeded = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;

    //
    // Allocate Storage for the MergedSystemTraceHeader
    //

    LoggerInfoSize = sizeof(SYSTEM_TRACE_HEADER) +
                     sizeof(TRACE_LOGFILE_HEADER) +
                     MAXSTR * sizeof(WCHAR) +
                     (LOGGER_NAME_SIZE + 1) * sizeof(WCHAR);

    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 
                 2 * MAXSTR * sizeof(WCHAR) + 
                 LoggerInfoSize; 

    // Need to allocate more to consider different pointer size case
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded + 8); 
    if (pLoggerInfo == NULL) {
        Status = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    RtlZeroMemory(pLoggerInfo, SizeNeeded + 8);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    //
    // The relogged file contains a standard time stamp format.
    //
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + LoggerInfoSize;

    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(WCHAR);
    pLoggerInfo->LogFileMode =  (EVENT_TRACE_PRIVATE_LOGGER_MODE |
                                 EVENT_TRACE_RELOG_MODE |
                                 EVENT_TRACE_FILE_MODE_SEQUENTIAL
                                );
    pLoggerInfo->MinimumBuffers = 2;
    pLoggerInfo->MaximumBuffers = 50;

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    StringCchCopyW(LoggerName, MAXSTR, LOGGER_NAME);

    Status = UuidCreate(&ControlGuid[0]);

    if (Status != ERROR_SUCCESS) {
        goto cleanup;
    }

    pLoggerInfo->Wnode.Guid = ControlGuid[0];

    if ( wcslen(TraceContext->MergeFileName) > 0 ) {
        StringCchCopyW(LogFileName, MAXSTR, TraceContext->MergeFileName);
    }

    MergedSystemTraceHeader = (PSYSTEM_TRACE_HEADER) ((PUCHAR) pLoggerInfo +
                                             sizeof(EVENT_TRACE_PROPERTIES));

    MergedLogFileHeader = (PTRACE_LOGFILE_HEADER) (
                          (PUCHAR)MergedSystemTraceHeader + 
                          sizeof(SYSTEM_TRACE_HEADER));

    LogFileCount = 0;

    for (i = 0; i < TraceContext->LogFileCount; i++) {
        pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (pLogFile == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }
        RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
        EvmFile[i] =  pLogFile;
        pLogFile->LogFileName = TraceContext->LogFileName[i];
        EvmFile[i]->EventCallback = (PEVENT_CALLBACK) &EtwProcessLogHeader;
        EvmFile[i]->BufferCallback = TerminateOnBufferCallback;
        LogFileCount++;
    }

    if (LogFileCount == 0) {
        Status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Initialize Trace
    //

    Status = InitializeTrace();
    if (Status != ERROR_SUCCESS) {
        goto cleanup;
    }
    //
    // Set up the Relog Event
    //

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));
    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR; 


    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;

        EvmFile[i]->LogfileHeader.ReservedFlags |= EVENT_TRACE_GET_RAWEVENT; 

        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
            Status = GetLastError();
            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
        Status = ProcessTrace(&x, 1, NULL, NULL);
    }
 
    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
    }


    if (HeaderMisMatch) {
        if (HeaderMisMatch & ETW_CLOCK_MISMATCH) {
            Status = ERROR_INVALID_TIME;
        }
        else if (HeaderMisMatch & ETW_PROC_MISMATCH || HeaderMisMatch & ETW_POINTER_MISMATCH) 
            Status = ERROR_INVALID_DATA;
    
        goto cleanup;
    }

    if ( (MergedLogFileHeader->BufferSize == 0) ||
         (MergedLogFileHeader->NumberOfProcessors == 0) ) {
        goto cleanup;
    }


    //
    // We are past the Error checks. Go ahead and Allocate
    // Storage to Start a logger
    //

    pLoggerInfo->Wnode.ClientContext = MergedLogFileHeader->ReservedFlags;
    pLoggerInfo->Wnode.ProviderId = MergedLogFileHeader->NumberOfProcessors;
    pLoggerInfo->BufferSize = MergedLogFileHeader->BufferSize / 1024;

    //
    // We are Past the Error Checks. Go ahead and redo ProcessTrace
    //

    for (i = 0; i < TraceContext->LogFileCount; i++) {
        TRACEHANDLE x;
        EvmFile[i]->EventCallback = (PEVENT_CALLBACK) &EtwDumpEvent;
        EvmFile[i]->BufferCallback = BufferCallback;

        EvmFile[i]->LogfileHeader.ReservedFlags |= EVENT_TRACE_GET_RAWEVENT;

        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            Status = GetLastError();
            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }

    Status = ProcessTrace(
                          HandleArray,
                          LogFileCount,
                          NULL, 
                          NULL
                         );

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
    }

    //
    // Need to Stop Trace
    //
    if (bLoggerStarted) {
        RtlZeroMemory(pLoggerInfo, SizeNeeded);
        pLoggerInfo->Wnode.BufferSize =  sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(WCHAR);
        pLoggerInfo->Wnode.Guid = ControlGuid[0];
        pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES); 
        pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(WCHAR);
        pLoggerInfo->LogFileMode =  (EVENT_TRACE_PRIVATE_LOGGER_MODE | 
                                     EVENT_TRACE_RELOG_MODE | 
                                     EVENT_TRACE_FILE_MODE_SEQUENTIAL
                                    );        
        Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_STOP);
    }

    //
    // We need to cleanup and reset properly to allow this library
    // to be used by perf tools
    //

    bLoggerStarted = FALSE;

    Status = UnregisterTraceGuids(RegistrationHandle[0]);

cleanup:
    if (NULL != pMergedEventsLost) {
        *pMergedEventsLost = FailedEvents;
    }

    for (i = 0; i < LogFileCount; i ++){
        if (EvmFile[i] != NULL) 
            free(EvmFile[i]);
    }
    if (pLoggerInfo != NULL) 
        free (pLoggerInfo);

    return Status;
}


void
WINAPI
EtwProcessLogHeader(
    PEVENT_TRACE pEvent
    )
/*++

Routine Description:

    This routine checks to see if the pEvent is a LOGFILE_HEADER
    and if so captures the information on the logfile for validation. 
    
    The following checks are performed. 
    1. Files must be from the same machine. (Verified using machine name)
    2. If different buffersizes are used, largest  buffer size is 
       selected for relogging.
    3. The StartTime and StopTime are the outer most from the files.
    4. The CPUClock type must be the same for all files. If different 
       clock types are used, then the files will be rejected. 

    The routine assumes that the first Event Callback from each file is the
    LogFileHeader callback. 

    Other Issues that could result in a not so useful merged logfile are:
    1. Multiple RunDown records when kernel logfiles are merged. 
    2. Multiple SystemConfig records when kernel logfiles are merged
    3. Multiple and conflicting GUidMap records when Application logfiles are merged.
    4. ReLogging 32 bit data in 64 bit system
    

Arguments:


Return Value:

    None. 
--*/
{
    ULONG NumProc;

    if( IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid) &&
       pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {

       PSYSTEM_TRACE_HEADER pSysHeader;
       PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)((PUCHAR)pEvent->MofData + sizeof(SYSTEM_TRACE_HEADER) );
       ULONG BufferSize = head->BufferSize;
       pSysHeader = (PSYSTEM_TRACE_HEADER) pEvent->MofData;

        if (MergedSystemTraceHeader->Packet.Size == 0) {
            ULONG HeaderSize;
            LPTSTR LoggerName;
            ULONG SizeToCopy = sizeof(SYSTEM_TRACE_HEADER) +
                               sizeof(TRACE_LOGFILE_HEADER);
            if (4 == head->PointerSize && 8 == sizeof(PVOID) ||
                8 == head->PointerSize && 4 == sizeof(PVOID)) {
                DifferentPointer = TRUE;
                if (4 == sizeof(PVOID)) {
                    SizeToCopy += 8;
                    pLoggerInfo->Wnode.BufferSize += 8;
                }
                else if (8 == sizeof(PVOID)) {
                    SizeToCopy -= 8;
                    pLoggerInfo->Wnode.BufferSize -= 8;
                }
            }
            RtlCopyMemory(MergedSystemTraceHeader,  pSysHeader, SizeToCopy);
            HeaderSize  =  SizeToCopy + 
                           MAXSTR * sizeof(WCHAR) + 
                           (LOGGER_NAME_SIZE + 1) * sizeof(WCHAR);
            MergedSystemTraceHeader->Packet.Size = (USHORT)HeaderSize;
            // 
            // Copy the LoggerName and the LogFileName
            //
             
            LoggerName = (PWCHAR)((PUCHAR)MergedSystemTraceHeader + SizeToCopy);

            StringCchCopyW(LoggerName, (LOGGER_NAME_SIZE + 1), LOGGER_NAME);


        }
        else {
           //
           // Sum up Events Lost from each file
           //
           MergedLogFileHeader->EventsLost += head->EventsLost;
           if (DifferentPointer && 4 == sizeof(PVOID)) {
                ULONG CurrentBuffersLost, MoreBuffersLost;
                RtlCopyMemory(&CurrentBuffersLost,
                              (PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, BuffersLost) + 8,
                              sizeof(ULONG));
                RtlCopyMemory(&MoreBuffersLost,
                              (PUCHAR)head + FIELD_OFFSET(TRACE_LOGFILE_HEADER, BuffersLost) + 8,
                              sizeof(ULONG));
                CurrentBuffersLost += MoreBuffersLost;
                RtlCopyMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, BuffersLost) + 8,
                              &CurrentBuffersLost,
                              sizeof(ULONG));
           }
           else if (DifferentPointer && 8 == sizeof(PVOID)) {
                ULONG CurrentBuffersLost, MoreBuffersLost;
                RtlCopyMemory(&CurrentBuffersLost,
                              (PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, BuffersLost) - 8,
                              sizeof(ULONG));
                RtlCopyMemory(&MoreBuffersLost,
                              (PUCHAR)head + FIELD_OFFSET(TRACE_LOGFILE_HEADER, BuffersLost) - 8,
                              sizeof(ULONG));
                CurrentBuffersLost += MoreBuffersLost;
                RtlCopyMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, BuffersLost) - 8,
                              &CurrentBuffersLost,
                              sizeof(ULONG));
           }
           else {
                MergedLogFileHeader->BuffersLost += head->BuffersLost;
           }
        }

       //
       // Pick up the Largest BufferSize
       //

        if (BufferSize > MergedLogFileHeader->BufferSize) {
            MergedLogFileHeader->BufferSize = BufferSize;
        }

       //
       // Verify the NumberOfProcessors
       //

       NumProc = head->NumberOfProcessors;

        if ( MergedLogFileHeader->NumberOfProcessors != NumProc) {
            HeaderMisMatch |= ETW_PROC_MISMATCH;
        }

       // 
       // Pick up the Earliest StartTime (always in SystemTime)
       //
        if (DifferentPointer && 4 == sizeof(PVOID)) {
            LARGE_INTEGER CurrentStartTime, NewStartTime;
            RtlCopyMemory(&CurrentStartTime,
                          (PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, StartTime) + 8,
                          sizeof(LARGE_INTEGER));
            RtlCopyMemory(&NewStartTime,
                          (PUCHAR)head+ FIELD_OFFSET(TRACE_LOGFILE_HEADER, StartTime) + 8,
                          sizeof(LARGE_INTEGER));
            if (CurrentStartTime.QuadPart > NewStartTime.QuadPart) {
                RtlCopyMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, StartTime) + 8,
                              &NewStartTime,
                              sizeof(LARGE_INTEGER));
            }
        }
        else if (DifferentPointer && 8 == sizeof(PVOID)) {
            LARGE_INTEGER CurrentStartTime, NewStartTime;
            RtlCopyMemory(&CurrentStartTime,
                          (PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, StartTime) - 8,
                          sizeof(LARGE_INTEGER));
            RtlCopyMemory(&NewStartTime,
                          (PUCHAR)head+ FIELD_OFFSET(TRACE_LOGFILE_HEADER, StartTime) - 8,
                          sizeof(LARGE_INTEGER));
            if (CurrentStartTime.QuadPart > NewStartTime.QuadPart) {
                RtlCopyMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, StartTime) - 8,
                              &NewStartTime,
                              sizeof(LARGE_INTEGER));
            }
        }
        else {
            if (MergedLogFileHeader->StartTime.QuadPart > head->StartTime.QuadPart) {
                MergedLogFileHeader->StartTime.QuadPart = head->StartTime.QuadPart;
            }
        }

       //
       // Pick up the latest EndTime
       //
        if (MergedLogFileHeader->EndTime.QuadPart < head->EndTime.QuadPart) {
            MergedLogFileHeader->EndTime.QuadPart = head->EndTime.QuadPart;
        }

       // 
       // This StartPerfClock is in the ClockType used.
       //
        if (pSysHeader->SystemTime.QuadPart < MergedSystemTraceHeader->SystemTime.QuadPart) {
            MergedSystemTraceHeader->SystemTime = pSysHeader->SystemTime;
        }

       //
       // Verify the pointer size
       //
        if (MergedLogFileHeader->PointerSize != head->PointerSize) {
            HeaderMisMatch |= ETW_POINTER_MISMATCH;
        }

       //
       // Verify the Clock Type
       //
        if (DifferentPointer && 4 == sizeof(PVOID)) {
            if (RtlCompareMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, ReservedFlags) + 8,
                                 (PUCHAR)head + FIELD_OFFSET(TRACE_LOGFILE_HEADER, ReservedFlags) + 8,
                                 sizeof(ULONG)) != sizeof(ULONG)) {
                HeaderMisMatch |= ETW_CLOCK_MISMATCH;
            }
            if (RtlCompareMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, PerfFreq) + 8,
                                 (PUCHAR)head + FIELD_OFFSET(TRACE_LOGFILE_HEADER, PerfFreq) + 8,
                                 sizeof(LARGE_INTEGER)) != sizeof(LARGE_INTEGER)) {
                HeaderMisMatch |= ETW_MACHINE_MISMATCH;
            }
        }
        else if (DifferentPointer && 8 == sizeof(PVOID)) {
            if (RtlCompareMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, ReservedFlags) - 8,
                                 (PUCHAR)head + FIELD_OFFSET(TRACE_LOGFILE_HEADER, ReservedFlags) - 8,
                                 sizeof(ULONG)) != sizeof(ULONG)) {
                HeaderMisMatch |= ETW_CLOCK_MISMATCH;
            }
            if (RtlCompareMemory((PUCHAR)MergedLogFileHeader + FIELD_OFFSET(TRACE_LOGFILE_HEADER, PerfFreq) - 8,
                                 (PUCHAR)head + FIELD_OFFSET(TRACE_LOGFILE_HEADER, PerfFreq) - 8,
                                 sizeof(LARGE_INTEGER)) != sizeof(LARGE_INTEGER)) {
                HeaderMisMatch |= ETW_MACHINE_MISMATCH;
            }
        }
        else {
            if (head->ReservedFlags != MergedLogFileHeader->ReservedFlags) {
                HeaderMisMatch |= ETW_CLOCK_MISMATCH;
            }
            if (head->PerfFreq.QuadPart != MergedLogFileHeader->PerfFreq.QuadPart) {
                HeaderMisMatch |= ETW_MACHINE_MISMATCH;
            }
        }

       //
       // Verify Machine Name
       //

       // CPU Name is in the CPU Configuration record 
       // which can be version dependent and found only on Kernel Logger

       // 
       // Verify Build Number
       //
//        if (head->ProviderVersion != MergedLogFileHeader->ProviderVersion) {
//            HeaderMisMatch |= ETW_VERSION_MISMATCH;
//        }

       //
       // Boot Time Verification?
       //
//      if (head->BootTime.QuadPart != MergedLogFileHeader->BootTime.QuadPart) {
//            HeaderMisMatch |= ETW_BOOTTIME_MISMATCH;
//        }

       //
       // Sum up Events Lost from each file
       //
    
       NumHdrProcessed++;

    }
}

void
WINAPI
EtwDumpEvent(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG Status = ERROR_SUCCESS;
    ULONG CachedFlags;
    USHORT CachedSize;
    ULONG RetryCount = 0;

    if (pEvent == NULL) {
        return;
    }
    
    TotalRelogEventsRead++;

    if (!bLoggerStarted) {
        Status = StartTraceW(&LoggerHandle, LOGGER_NAME, pLoggerInfo);

        if (Status != ERROR_SUCCESS) {
           return;
        }
        bLoggerStarted = TRUE;

    }

    pHeader = (PEVENT_TRACE_HEADER)pEvent->MofData;

    //
    // Ignore LogFileHeader Events
    // 
    if( IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid) &&
       pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {
        return;
    }

    CachedSize = pEvent->Header.Size;
    CachedFlags = pEvent->Header.Flags;

    pEvent->Header.Size = sizeof(EVENT_TRACE);
    pEvent->Header.Flags |= (WNODE_FLAG_TRACED_GUID | WNODE_FLAG_NO_HEADER);

    do {
        Status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER)pEvent );
        if ((Status == ERROR_NOT_ENOUGH_MEMORY || Status == ERROR_OUTOFMEMORY) && 
            (RetryCount++ < MAX_RETRY_COUNT)) {
            _sleep(500);    // Sleep for half a second. 
        }
        else {
            break;
        }   
    } while (TRUE);   

    if (Status != ERROR_SUCCESS) {
        FailedEvents++;
    }

    //
    // Restore Cached values
    //
    pEvent->Header.Size = CachedSize;
    pEvent->Header.Flags = CachedFlags;
}


ULONG InitializeTrace(
    )
{
    ULONG Status;

    Status = RegisterTraceGuids(
                    (WMIDPREQUEST)ControlCallback,
                    NULL,
                    (LPCGUID)&ControlGuid[0],
                    1,
                    &TraceGuidReg[0],
                    NULL,
                    NULL, 
                    &RegistrationHandle[0]
                 );

    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{

    return ERROR_SUCCESS;

}



ULONG
WINAPI
TerminateOnBufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
{
    if (LogFileCount == NumHdrProcessed) 
        return (FALSE); // Terminate ProcessTrace on First BufferCallback
    else 
        return (TRUE);
}

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
{
    TotalRelogBuffersRead++;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceprt\traceprt.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    traceprt.h

Abstract:

    Trace formatting external definitions.

Revision History:

--*/
#ifdef __cplusplus
extern "C"{
#endif
#ifndef _TRACEPRT_
#define _TRACEPRT_

#define MAXLOGFILES       16
#define MAXSTR          1024

#define GUID_FILE       _T("default")
#define GUID_EXT        _T("tmf")

//
// Now the routines we export
//

#ifndef TRACE_API
#ifdef TRACE_EXPORTS
#define TRACE_API __declspec(dllexport)
#else
#define TRACE_API __declspec(dllimport)
#endif
#endif

#ifdef UNICODE
#define FormatTraceEvent               FormatTraceEventW
#define GetTraceGuids                  GetTraceGuidsW
#define SummaryTraceEventList          SummaryTraceEventListW
#else
#define FormatTraceEvent               FormatTraceEventA
#define GetTraceGuids                  GetTraceGuidsA
#define SummaryTraceEventList          SummaryTraceEventListA
#endif

TRACE_API 
HRESULT
InitializeCSharpDecoder();

TRACE_API 
void
UninitializeCSharpDecoder();


TRACE_API SIZE_T
WINAPI
FormatTraceEventA(
        PLIST_ENTRY  HeadEventList,
        PEVENT_TRACE pEvent,
        CHAR       * EventBuf,
        ULONG        SizeEventBuf,
        CHAR       * pszMask
        );

TRACE_API ULONG 
WINAPI
GetTraceGuidsA(
        CHAR        * GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListA(
        CHAR      * SummaryBlock ,
        ULONG       SizeSummaryBlock ,
        PLIST_ENTRY EventListhead
        );

TRACE_API SIZE_T
WINAPI
FormatTraceEventW(
        PLIST_ENTRY    HeadEventList,
        PEVENT_TRACE   pEvent,
        TCHAR        * EventBuf,
        ULONG          SizeEventBuf,
        TCHAR        * pszMask
        );


TRACE_API ULONG 
WINAPI
GetTraceGuidsW(
        LPTSTR        GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListW(
        TCHAR     * SummaryBlock,
        ULONG       SizeSummaryBlock,
        PLIST_ENTRY EventListhead
        );

TRACE_API void
WINAPI
CleanupTraceEventList(
        PLIST_ENTRY EventListHead
        );

TRACE_API void
WINAPI
GetTraceElapseTime(
        __int64 * pElpaseTime
        );

#define TRACEPRT_INTERFACE_VERSION 1

typedef enum _PARAM_TYPE
{
    ParameterINDENT,
    ParameterSEQUENCE,
    ParameterGMT,
    ParameterTraceFormatSearchPath,
    ParameterInterfaceVersion,
    ParameterUsePrefix,
    ParameterSetPrefix,
    ParameterStructuredFormat,
    ParameterDebugPrint
} PARAMETER_TYPE ;


TRACE_API ULONG
WINAPI
SetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

TRACE_API ULONG
WINAPI
GetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

TRACE_API LPTSTR
WINAPI
GetTraceFormatSearchPath(void);


#define NAMESIZE 256
#define STRUCTUREDMESSAGEVERSION  0
typedef struct _STRUCTUREDMESSAGE {
        ULONG    Version  ;             // Structure Version Number
        GUID     TraceGuid ;            // Message Guid
        ULONG    GuidName ;             // %1   Guid Friendly Name  Offset
        ULONG    GuidTypeName ;         // %2   Guid Type Name Offset
        ULONG    ThreadId ;             // %3   Thread ID  Value
        SYSTEMTIME SystemTime ;         // %4   System Time Value
        ULONG    UserTime ;             // %5   Kernel Time Value
        ULONG    KernelTime ;           // %6   User Time Value
        ULONG    SequenceNum ;          // %7   Sequence Number Value
        ULONG    ProcessId ;            // %8   Process ID Value
        ULONG    CpuNumber ;            // %9   CPU Number Value
        ULONG    Indent ;               //  Indentation level Value
        ULONG    FlagsName ;            //  Trace Flag settings Name Offset
        ULONG    LevelName ;            //  Trace Level Name Offset
        ULONG    FunctionName ;         //  Function Name Offset
        ULONG    ComponentName ;        //  Component Name Offset
        ULONG    SubComponentName ;     //  Sub Component Name Offset
        ULONG    FormattedString ;      //  Formatted String Offset
// Version 0 values before this comment, all new values after this point.
}  STRUCTUREDMESSAGE, *PSTRUCTUREDMESSAGE ;

#define TRACEPRINT(a,b) {PVOID lTracePrint ; if(!((lTracePrint = TracePrint) != NULL)) { *(lTracePrint) b } };

#endif  // #ifndef _TRACEPRT_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracectr\workload.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    workload.h

Abstract:

    Workload Header file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/


typedef struct _METRICS {
    double Thruput;
    double Response;
    double Queue;
    double Wait;
} METRICS, *PMETRICS;

typedef struct _WORKLOAD_RECORD {
    LIST_ENTRY Entry;   

    METRICS Metrics;

    ULONG   ClassNumber;
    PVOID   ClassFilter;
    LIST_ENTRY DiskListHead;    // Per class disk list; 

    double  TransCount;
    double  UserCPU;
    double  KernelCPU;
    double  CpuPerTrans;
    double  ReadCount;
    double  WriteCount;
    double  IoPerTrans;
    double  Wset;
} WORKLOAD_RECORD, *PWORKLOAD_RECORD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracelog\tracelog.c ===
// begin_sdk
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    Sample trace control program. Allows user to start, stop event tracing

// end_sdk

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    Insung Park (insungp)   28-Nov-2000

          Now tracelog can be used to set the registry keys to start or stop 
        GlobalLogger. Other options also works except a few (such as -enable).
        e.g.
            tracelog -start GlobalLogger
            tracelog -stop GlobalLogger
            tracelog -q GlobalLogger

          However, "-start" option does not start GlobalLogger immediately. The
        machine must be rebooted. "-stop" option resets the registry keys and
        stop GlobalLogger.
          Users can use other options to customize the GlobalLogger sessions
        such as minimum and maximum buffers, buffer size, flush timer, and so on.
        One catch is, if any of the enable flags is set, GlobalLogger turns into
        NT Kernel Logger and its instance vanishes. Any attempt to access 
        GlobalLogger with its name will fail with ERROR_WMI_INSTANCE_NOT_FOUND. 
        "-stop" option will still reset registry keys so that the next time the
        machine boots GlobalLogger will not start.
        
          If any of the flags is set, users should access NT Kernel Logger to
        control it.

          Modified/updated functions include GetGlobalLoggerSettings,
        SetGlobalLoggerSettings, main, PrintLoggerStatus.

    Insung Park (insungp)   19-Dec-2000
        
          Changed trace function calls so that tracelog can be used on Win2K.
        FlushTrace and EnumTraceGuids are not implemented on Win2K, but they do 
        not stop the execution of tracelog. An attempt to use FlushTrace or
        EnumTraceGuids on W2K will generate an error message.
          Fixed "-flags -1" bug. tracelog does not accept any flag with MSB=1.

    Insung Park (insungp)   21-Dec-2000
          Added a version display.
          Fixed PrintHelpMessage() so that options not available on Win2K will
        not be printed. ("-paged", "-flush", "-enumguid", "-append", "-newfile",
        "-eflag", "-ls", "-gs")
          Cleaned up the if blocks in main() so that tracelog frees allocated
        space properly before exiting regardless of error status.

// begin_sdk

--*/
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#include <stdio.h>
#include <stdlib.h>
// end_sdk
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// begin_sdk
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>
#include <wmiguid.h>
// end_sdk
#include <ntwmi.h>
// begin_sdk

#define MAXSTR                          1024
#define DEFAULT_LOGFILE_NAME            _T("C:\\LogFile.Etl")

// end_sdk
#define GLOBAL_LOGGER                   _T("GlobalLogger")
#define EVENT_LOGGER                    _T("WMI Event Logger")
#define MAXENABLEFLAGS                  10
// begin_sdk
#define MAXIMUM_LOGGERS_W2K             32
#define MAXIMUM_LOGGERS_XP              64
#define MAXGUIDS                        128

#define ACTION_QUERY                    0
#define ACTION_START                    1
#define ACTION_STOP                     2
#define ACTION_UPDATE                   3
#define ACTION_LIST                     4
#define ACTION_ENABLE                   5
#define ACTION_HELP                     6
#define ACTION_FLUSH                    7
#define ACTION_ENUM_GUID                8
// end_sdk
#define ACTION_REMOVE                   9
// begin_sdk
#define ACTION_UNDEFINED               10

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#define WSTRSIZE(str) (ULONG) ( (str) ? ((PCHAR) &str[wcslen(str)] - (PCHAR)str) + sizeof(UNICODE_NULL) : 0 )

// Functions not implemented on Win2K need to be searched and loaded separately.
// To make further accesses easy, an array of function pointers will be used.
// The following list serves as indices to that array.
//
// If new functions are added to evntrace.h, the following list should be updated
// as well as the array initialization routine at the beginning of main(). 
#define FUNC_FLUSH_TRACE        0
#define FUNC_ENUM_TRACE_GUIDS   1
// Funtion pointer array for unimplemented functions on Win2K.
// Note: This may not work if this code is ported to C++, because
// all the function pointers may be typedefed differently.
#define MAXFUNC                 10
FARPROC FuncArray[MAXFUNC];
HINSTANCE advapidll;

BOOLEAN XP;

//keep track of whether or not the kernel debugging option has been turned on to assure the buffer size is no greater than 3 kb
BOOLEAN kdOn = FALSE;

void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
// end_sdk
    IN ULONG GlobalLoggerStartValue,
// begin_sdk
    IN ULONG Status,
    IN BOOL PrintStatus
    );

#define PRINTSTATUS TRUE
#define NOPRINTSTATUS FALSE

LPTSTR
DecodeStatus(
    IN ULONG Status
    );

LONG
GetGuids(
    IN LPTSTR GuidFile, 
    OUT LPGUID *GuidArray
    );

ULONG 
ahextoi(
    IN TCHAR *s
    );

void 
StringToGuid(
    IN TCHAR *str,
    OUT LPGUID guid
    );

PTCHAR 
GuidToString(
    IN OUT PTCHAR s,
    IN LPGUID piid
    );

TCHAR ErrorMsg[MAXSTR];

void 
PrintHelpMessage();

// end_sdk
ULONG
SetGlobalLoggerSettings(
    IN DWORD StartValue,
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN DWORD ClockType
);

ULONG
GetGlobalLoggerSettings(
    IN OUT PEVENT_TRACE_PROPERTIES LoggerInfo,
    OUT PULONG ClockType,
    OUT PDWORD pdwStart
);
// begin_sdk

//
//  main function
//
__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    It is the main function.

Arguments:
  

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).


--*/{
    ULONG i, j;
    LONG GuidCount;
    USHORT Action = ACTION_UNDEFINED;
    ULONG Status = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;
    TCHAR GuidFile[MAXSTR];
    PEVENT_TRACE_PROPERTIES pLoggerInfo;
    TRACEHANDLE LoggerHandle = 0;
    LPTSTR *targv, *utargv = NULL;
    LPGUID *GuidArray;
    char *Space;
    char *save;
    BOOL bKill = FALSE;
    BOOL bForceKill = FALSE ;
    BOOL bEnable = TRUE;
    ULONG iLevel = 0;
    ULONG iFlags = 0;
    ULONG SizeNeeded = 0;
    ULONG specialLogger = 0;
    ULONG GlobalLoggerStartValue = 0;
    PULONG pFlags = NULL;

    BOOL bProcess = TRUE;
    BOOL bThread  = TRUE;
    BOOL bDisk    = TRUE;
    BOOL bNetwork = TRUE;

    OSVERSIONINFO OSVersion;

    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    XP = FALSE;
    if (GetVersionEx(&OSVersion)) {
        XP = (OSVersion.dwMajorVersion > 5) ||
                    ((OSVersion.dwMajorVersion == 5) && (OSVersion.dwMinorVersion > 0));
    }

    // Load functions that are not implemented on Win2K
    for (i = 0; i < MAXFUNC; ++i)
        FuncArray[i] = NULL;
    if (XP) {
        advapidll = LoadLibrary(_T("advapi32.dll"));
        if (advapidll != NULL) {
#ifdef UNICODE
            FuncArray[FUNC_FLUSH_TRACE] = GetProcAddress(advapidll, "FlushTraceW");
#else
            FuncArray[FUNC_FLUSH_TRACE] = GetProcAddress(advapidll, "FlushTraceA");
#endif
            FuncArray[FUNC_ENUM_TRACE_GUIDS] = GetProcAddress(advapidll, "EnumerateTraceGuids");
        }
    }

    // Initialize structure first
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
// end_sdk
    SizeNeeded += MAXENABLEFLAGS * sizeof(ULONG); // for extension enable flags
// begin_sdk
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return (ERROR_OUTOFMEMORY);
    }
    

    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(TCHAR);

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    _tcscpy(LoggerName, KERNEL_LOGGER_NAME);

    Space = (char*) malloc( (MAXGUIDS * sizeof(GuidArray)) +
                            (MAXGUIDS * sizeof(GUID) ));
    if (Space == NULL) {
        free(pLoggerInfo);
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return(ERROR_OUTOFMEMORY);
    }
    save = Space;
    GuidArray = (LPGUID *) Space;
    Space += MAXGUIDS * sizeof(GuidArray);

    for (GuidCount=0; GuidCount<MAXGUIDS; GuidCount++) {
        GuidArray[GuidCount] = (LPGUID) Space;
        Space += sizeof(GUID);
    }
    GuidCount = 0;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL) {
        free(pLoggerInfo);
        free(save);
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return (GetLastError());
    };
    utargv = targv;
#else
    targv = argv;
#endif

    pFlags = &pLoggerInfo->EnableFlags;
    //
    // Add default flags. Should consider options to control this independently
    //
    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0], _T("-start"))) {
                Action = ACTION_START;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enable"))) {
                Action = ACTION_ENABLE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-disable"))) {
                Action = ACTION_ENABLE;
                bEnable = FALSE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-stop"))) {
                Action = ACTION_STOP;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-update"))) {
                Action = ACTION_UPDATE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
// end_sdk
            else if (!_tcsicmp(targv[0], _T("-remove"))) {
                Action = ACTION_REMOVE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
                // if it is not GlobalLogger, nothing happens.
            }
// begin_sdk
            else if (!_tcsicmp(targv[0], _T("-q"))) {
                Action = ACTION_QUERY;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flush"))) {
                Action = ACTION_FLUSH;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enumguid"))) {
                Action = ACTION_ENUM_GUID;
            }
            else if (!_tcsicmp(targv[0], _T("-f"))) {
                if (argc > 1) {
                    if (XP) 
                        _tcscpy(LogFileName, targv[1]);
                    else 
                        _tfullpath(LogFileName, targv[1], MAXSTR);

                    ++targv; --argc;
                    // _tprintf(_T("Setting log file to: %s\n"), LogFileName);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-append"))) {
                // _tprintf(_T("Appending log file: %s\n"), LogFileName);
                pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
            }
            else if (!_tcsicmp(targv[0], _T("-prealloc"))) {
                // _tprintf(_T("Preallocating log file: %s\n"), LogFileName);
                pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_PREALLOCATE;
            }
            else if (!_tcsicmp(targv[0], _T("-kb"))) {
                // _tprintf(_T("Using KBytes for maximum file size\n"));
                pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_KBYTES_FOR_SIZE;
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {
                if (argc > 1) {
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], GuidArray[0]);
                        ++targv; --argc;
                        GuidCount = 1;
                    }
                    else if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tfullpath(GuidFile, targv[1], MAXSTR);
                        ++targv; --argc;
                        // _tprintf(_T("Getting guids from %s\n"), GuidFile);
                        GuidCount = GetGuids(GuidFile, GuidArray);
                        if (GuidCount < 0) {
                            _tprintf( _T("Error: %s does no exist\n"), GuidFile );
                        }
                        else if (GuidCount == 0){
                            _tprintf( _T("Error: %s is invalid\n"), GuidFile );
                            Status = ERROR_INVALID_PARAMETER;
                            goto CleanupExit;
                        }
                    }
                }
            }
// end_sdk
            else if (!_tcsicmp(targv[0], _T("-UsePerfCounter"))) {
                pLoggerInfo->Wnode.ClientContext = 1;
            }
            else if (!_tcsicmp(targv[0], _T("-UseSystemTime"))) {
                pLoggerInfo->Wnode.ClientContext = 2;
            }
            else if (!_tcsicmp(targv[0], _T("-UseCPUCycle"))) {
                pLoggerInfo->Wnode.ClientContext = 3;
            }
// begin_sdk
            else if (!_tcsicmp(targv[0], _T("-seq"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting maximum sequential logfile size to: %d\n"),
                    //    pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-newfile"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_NEWFILE;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting maximum logfile size to: %d\n"),
                    //    pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cir"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting maximum circular logfile size to: %d\n"),
                    //    pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-b"))) {
                if (argc > 1) {
                    ULONG ulSize = _ttoi(targv[1]);
                    if (kdOn && ulSize > 3) {
                        _tprintf(_T("Kernel Debugging has been enabled: Buffer size has been set to 3kBytes\n"));
                        ulSize = 3;
                    }
                    pLoggerInfo->BufferSize = ulSize;                 	
                    ++targv; --argc;
                    // _tprintf(_T("Changing buffer size to %d\n"),
                    //    pLoggerInfo->BufferSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flag")) || !_tcsicmp(targv[0], _T("-flags"))) {
                if (argc > 1) {
                    if (targv[1][1] == _T('x') || targv[1][1] == _T('X')) {
                        pLoggerInfo->EnableFlags |= ahextoi(targv[1]);
                    } else {
                        pLoggerInfo->EnableFlags |= _ttoi(targv[1]);
                    }
                    iFlags =  pLoggerInfo->EnableFlags ;   // Copy for EnableTrace
                    ++targv; --argc;
                    // Do not accept flags with MSB = 1.

                    if (0x80000000 & pLoggerInfo->EnableFlags) {
                        _tprintf(_T("Invalid Flags: 0x%0X(%d.)\n"),
                            pLoggerInfo->EnableFlags, pLoggerInfo->EnableFlags);
                        Status = ERROR_INVALID_PARAMETER;
                        goto CleanupExit;
                    }

                    // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                    //    pLoggerInfo->EnableFlags, pLoggerInfo->EnableFlags );
                }
            }
// end_sdk
            else if (!_tcsicmp(targv[0], _T("-eflag"))) {
                if (argc > 2) {
                    USHORT nFlag = (USHORT) _ttoi(targv[1]);
                    USHORT offset;
                    PTRACE_ENABLE_FLAG_EXTENSION FlagExt;

                    ++targv; --argc;
                    if (nFlag > MAXENABLEFLAGS || nFlag < 1) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       Status = ERROR_INVALID_PARAMETER;
                       goto CleanupExit;
                    }
                    offset = (USHORT) 
                             (SizeNeeded - (sizeof(ULONG) * MAXENABLEFLAGS));
                    pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                    FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &pLoggerInfo->EnableFlags;
                    FlagExt->Offset = offset;
                    FlagExt->Length = (UCHAR) nFlag;

                    pFlags = (PULONG) ( offset + (PCHAR) pLoggerInfo );
                    for (i=0; i<nFlag && argc > 1; i++) {
                        if (targv[1][0] == '/' || targv[1][0] == '-') {
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            break;
                        }
                        pFlags[i] = ahextoi(targv[1]);
                        ++targv; --argc;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    nFlag = (USHORT)i;
                    for ( ; i < MAXENABLEFLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (FlagExt->Length != (UCHAR)nFlag) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        FlagExt->Length = (UCHAR)nFlag;
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-pids"))) {

                if (argc > 2) {
                    USHORT nFlag = (USHORT) _ttoi(targv[1]);
                    USHORT offset;
                    PTRACE_ENABLE_FLAG_EXTENSION FlagExt;

                    ++targv; --argc;
                    if (nFlag > MAXENABLEFLAGS || nFlag < 1) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       Status = ERROR_INVALID_PARAMETER;
                       goto CleanupExit;
                    }
                    offset = (USHORT) 
                             (SizeNeeded - (sizeof(ULONG) * MAXENABLEFLAGS));
                    pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                    FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &pLoggerInfo->EnableFlags;
                    FlagExt->Offset = offset;
                    FlagExt->Length = (UCHAR) nFlag;

                    pFlags = (PULONG) ( offset + (PCHAR) pLoggerInfo );
                    for (i=0; i<nFlag && argc > 1; i++) {
                        if (targv[1][0] == '/' || targv[1][0] == '-') {
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            break;
                        }
                        pFlags[i] = _ttol((PTCHAR)targv[1]);
                        ++targv; --argc;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    nFlag = (USHORT)i;
                    for ( ; i < MAXENABLEFLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (FlagExt->Length != (UCHAR)nFlag) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        FlagExt->Length = (UCHAR)nFlag;
                    }
                }
            }
            else if (!_tcsicmp(targv[0],_T("-heap"))) {
                GuidCount = 1;
                RtlCopyMemory(GuidArray[0], &HeapGuid, sizeof(HeapGuid));
                pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
            }
            else if (!_tcsicmp(targv[0],_T("-critsec"))) {
                GuidCount = 1;
                RtlCopyMemory(GuidArray[0], &CritSecGuid, sizeof(CritSecGuid));
                pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
            }
            else if (!_tcsicmp(targv[0],_T("-ls"))) {
                pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_LOCAL_SEQUENCE  ;
            }
            else if (!_tcsicmp(targv[0],_T("-gs"))) {
                pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_GLOBAL_SEQUENCE ;
            }
// begin_sdk
            else if (!_tcsicmp(targv[0], _T("-min"))) {
                if (argc > 1) {
                    pLoggerInfo->MinimumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing Minimum Number of Buffers to %d\n"),
                    //    pLoggerInfo->MinimumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-max"))) {
                if (argc > 1) {
                    pLoggerInfo->MaximumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing Maximum Number of Buffers to %d\n"),
                    //    pLoggerInfo->MaximumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-level"))) {
                if (argc > 1) {
                    iLevel = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting tracing level to %d\n"), iLevel);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-ft"))) {
                if (argc > 1) {
                    pLoggerInfo->FlushTimer = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting buffer flush timer to %d seconds\n"),
                    //    pLoggerInfo->FlushTimer);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-um"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
                    // _tprintf(_T("Setting Private Logger Flags\n"));
            }
            else if (!_tcsicmp(targv[0], _T("-paged"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY;
                    // _tprintf(_T("Setting Paged Memory Flag\n"));
            }
            else if (!_tcsicmp(targv[0], _T("-rt"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
                    // _tprintf(_T("Setting real time mode\n"));
// end_sdk
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       if (targv[0][0] == 'b')
                           pLoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
                   }
               }
// begin_sdk
            }            
            else if(!_tcsicmp(targv[0], _T("-kd"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_KD_FILTER_MODE;
                    pLoggerInfo->BufferSize = 3;
                    kdOn = TRUE;
            }
            else if (!_tcsicmp(targv[0], _T("-age"))) {
                if (argc > 1) {
                    pLoggerInfo->AgeLimit = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing Aging Decay Time to %d\n"),
                    //    pLoggerInfo->AgeLimit);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-l"))) {
                Action  = ACTION_LIST;
                bKill   = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-x"))) {
                Action  = ACTION_LIST;
                bKill   = TRUE;
            }
            else if (!_tcsicmp(targv[0], _T("-xf"))) {
                Action  = ACTION_LIST;
                bKill   = TRUE;
                bForceKill = TRUE ;
            }
            else if (!_tcsicmp(targv[0], _T("-noprocess"))) {
                bProcess = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nothread"))) {
                bThread = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nodisk"))) {
                bDisk = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nonet"))) {
                bNetwork = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-dbg"))) {
            	//comment out for now until this functionality is supported
              /* if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_DBGPRINT;
                }
                */
            }
            else if (!_tcsicmp(targv[0], _T("-ntsuccess"))){
            	  //comment out for now until this functionality is supported
                /*if(pFlags == &pLoggerInfo->EnableFlags) {
                	*pFlags |= EVENT_TRACE_FLAG_NTSUCCESS;
                }
                */
            	}
            else if (!_tcsicmp(targv[0], _T("-fio"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
                }
                else {
                    _tprintf(_T("Option -fio cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-pf"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
                }
                else {
                    _tprintf(_T("Option -pf cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-hf"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
                }
                else {
                    _tprintf(_T("Option -hf cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-img"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_IMAGE_LOAD;
                }
                else {
                    _tprintf(_T("Option -img cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cm"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_REGISTRY;
                }
                else {
                    _tprintf(_T("Option -cm cannot be used with -eflags. Ignored\n"));
                }
            }
            else if ( targv[0][1] == 'h' || targv[0][1] == 'H' || targv[0][1] == '?'){
                Action = ACTION_HELP;
                PrintHelpMessage();
                goto CleanupExit;
            }
            else Action = ACTION_UNDEFINED;
        }
        else { // get here if "-" or "/" given
            _tprintf(_T("Invalid option given: %s\n"), targv[0]);
            Status = ERROR_INVALID_PARAMETER;
            goto CleanupExit;
        }
    }
    if (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME)) {
        if (pFlags == &pLoggerInfo->EnableFlags) {
            if (bProcess)
                *pFlags |= EVENT_TRACE_FLAG_PROCESS;
            if (bThread)
                *pFlags |= EVENT_TRACE_FLAG_THREAD;
            if (bDisk)
                *pFlags |= EVENT_TRACE_FLAG_DISK_IO;
            if (bNetwork)
                *pFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
        }

        pLoggerInfo->Wnode.Guid = SystemTraceControlGuid; // defaults to OS
        specialLogger = 1;
    }
// end_sdk
    if (!_tcscmp(LoggerName, GLOBAL_LOGGER)) {
        pLoggerInfo->Wnode.Guid = GlobalLoggerGuid;
        specialLogger = 3;
    }
    else if (!_tcscmp(LoggerName, EVENT_LOGGER)) {
        pLoggerInfo->Wnode.Guid = WmiEventLoggerGuid;
        specialLogger = 2;
    }
// begin_sdk
    if ( !(pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if (specialLogger != 3 && _tcslen(LogFileName) <= 0 && Action == ACTION_START) {
            _tcscpy(LogFileName, DEFAULT_LOGFILE_NAME); // for now...
        }
    }

    switch (Action) {
        case  ACTION_START:
        {

           if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
               if (GuidCount != 1) {
                   _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                   Status = ERROR_INVALID_PARAMETER;
                   break;
               }
               pLoggerInfo->Wnode.Guid = *GuidArray[0];
           }

           if (pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE  &&
               pLoggerInfo->MaximumFileSize == 0) {
               _tprintf(_T("Need file size for preallocated log file\n"));
               Status = ERROR_INVALID_PARAMETER;
               break;
           }
// end_sdk
            if (specialLogger == 3) {  // Global Logger
                Status = SetGlobalLoggerSettings(1L, pLoggerInfo, pLoggerInfo->Wnode.ClientContext);
                if (Status != ERROR_SUCCESS)
                    break;
                Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                break;
            }
// begin_sdk
            if(pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION){
                if(IsEqualGUID(&CritSecGuid,GuidArray[0]) ||
                    IsEqualGUID(&HeapGuid,GuidArray[0])){
                    pLoggerInfo->Wnode.HistoricalContext = 0x1000001;
                }
            }
            Status = StartTrace(&LoggerHandle, LoggerName, pLoggerInfo);

            if (Status != ERROR_SUCCESS) {
                _tprintf(_T("Could not start logger: %s\n") 
                         _T("Operation Status:       %uL\n")
                         _T("%s\n"),
                         LoggerName,
                         Status,
                         DecodeStatus(Status));

                break;
            }
            _tprintf(_T("Logger Started...\n"));

        case ACTION_ENABLE:

            if (Action == ACTION_ENABLE ){

                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                {
                    if (GuidCount != 1)
                    {
                        _tprintf(_T("Need one GUID for PRIVATE loggers\n"));
                        Status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    pLoggerInfo->Wnode.Guid = *GuidArray[0];
                }

                Status = ControlTrace((TRACEHANDLE) 0, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                if( Status != ERROR_SUCCESS ){
                    if( Status != ERROR_SUCCESS ){
                        if( IsEqualGUID(&HeapGuid,&pLoggerInfo->Wnode.Guid) 
                        || IsEqualGUID(&CritSecGuid,&pLoggerInfo->Wnode.Guid) 
                        ){
                            //do nothing 
                        } else {

                            _tprintf( _T("ERROR: Logger not started\n")
                                      _T("Operation Status:    %uL\n")
                                      _T("%s\n"),
                                      Status,
                                      DecodeStatus(Status));
							break;
                        }
                    }
                }
                LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            }

            if ( (GuidCount > 0) && (specialLogger == 0)) {
                _tprintf(_T("Enabling trace to logger %d\n"), LoggerHandle);
                for (i=0; i<(ULONG)GuidCount; i++) {
                    Status = EnableTrace (
                                    bEnable,
                                    iFlags,
                                    iLevel,
                                    GuidArray[i], 
                                    LoggerHandle);

                    //
                    // If the Guid can not be enabled, it is a benign 
                    // failure. Print Warning message and continue. 
                    //
                    if (Status == 4317) {
                       _tprintf(_T("WARNING: Could not enable some guids.\n")); 
                       _tprintf(_T("Check your Guids file\n")); 
                        Status = ERROR_SUCCESS;
                    }

                    if (Status != ERROR_SUCCESS) {
                        _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), i);
                        _tprintf(_T("Operation Status:       %uL\n"), Status);
                        _tprintf(_T("%s\n"),DecodeStatus(Status));
                        break;
                    }
                }
            }
            else {
                if (GuidCount > 0) {
                    _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
            break;
        }

        case ACTION_STOP :
            LoggerHandle = (TRACEHANDLE) 0;

            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
// end_sdk
            if (specialLogger == 3)
                Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
// begin_sdk
            if ( (GuidCount > 0) && 
                 !( IsEqualGUID(&HeapGuid,GuidArray[0]) || 
                    IsEqualGUID(&CritSecGuid,GuidArray[0]) ))  {
                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                    Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                    if (Status != ERROR_SUCCESS)
                        break;
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
                    Status = EnableTrace( FALSE,
                                          EVENT_TRACE_PRIVATE_LOGGER_MODE,
                                          0,
                                          GuidArray[0],
                                          LoggerHandle );
                }
                else {
                    Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                    if (Status == ERROR_WMI_INSTANCE_NOT_FOUND)
                        break;
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;

                    for (i=0; i<(ULONG)GuidCount; i++) {
                    Status = EnableTrace( FALSE,
                                              0,
                                              0,
                                              GuidArray[i],
                                              LoggerHandle);
                    }

                }
            }

            Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_STOP);
            break;
// end_sdk
        case ACTION_REMOVE :
            if (specialLogger == 3) {  // Global Logger
                Status = SetGlobalLoggerSettings(0L, pLoggerInfo, pLoggerInfo->Wnode.ClientContext);
                if (Status != ERROR_SUCCESS)
                    break;
                Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                if (Status != ERROR_SUCCESS)
                    break;
            }
            break;
// begin_sdk

        case ACTION_LIST :
        {
            ULONG returnCount ;
            ULONG ListSizeNeeded;
            PEVENT_TRACE_PROPERTIES pListLoggerInfo[MAXIMUM_LOGGERS_XP];
            PEVENT_TRACE_PROPERTIES pStorage;
            PVOID Storage;

            ListSizeNeeded = MAXIMUM_LOGGERS_XP * (sizeof(EVENT_TRACE_PROPERTIES)
                                      + 2 * MAXSTR * sizeof(TCHAR));

            Storage =  malloc(ListSizeNeeded);
            if (Storage == NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(Storage, ListSizeNeeded);

            pStorage = (PEVENT_TRACE_PROPERTIES)Storage;
            for (i=0; i<MAXIMUM_LOGGERS_XP; i++) {
                pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)
                                         + 2 * MAXSTR * sizeof(TCHAR);
                pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                        + MAXSTR * sizeof(TCHAR);
                pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                pListLoggerInfo[i] = pStorage;
                pStorage = (PEVENT_TRACE_PROPERTIES) (
                                 (char*)pStorage + 
                                  pStorage->Wnode.BufferSize);
            }
            
            if (XP) {
                Status = QueryAllTraces(pListLoggerInfo,
                                    MAXIMUM_LOGGERS_XP,
                                    & returnCount);
            }
            else {
                Status = QueryAllTraces(pListLoggerInfo,
                                    MAXIMUM_LOGGERS_W2K,
                                    & returnCount);
            }
    
            if (Status == ERROR_SUCCESS)
            {
                for (j= 0; j < returnCount; j++)
                {
                    LPTSTR ListLoggerName;
                    TCHAR asked = _T('?') ;
                    BOOL StatusPrint = FALSE ;
                    if (bKill)
                    {

                        ListLoggerName = (LPTSTR) ((char*)pListLoggerInfo[j] + 
                                      pListLoggerInfo[j]->LoggerNameOffset);
                        if (!bForceKill) {
                            while (!(asked == _T('y')) && !(asked == _T('n'))) {
                                ULONG ReadChars = 0;
                                _tprintf(_T("Do you want to kill Logger \"%s\" (Y or N)?"), ListLoggerName);
                                ReadChars = _tscanf(_T(" %c"), &asked);
                                if (ReadChars == 0 || ReadChars == EOF) {
                                    continue;
                                }
                                if (asked == _T('Y')) {
                                    asked = _T('y') ;
                                } else if (asked == _T('N')) {
                                    asked = _T('n') ;
                                }
                            }
                        } else {
                            asked = _T('y');
                        }
                        if (asked == _T('y')) {
                            if (!IsEqualGUID(& pListLoggerInfo[j]->Wnode.Guid,
                                         & SystemTraceControlGuid))
                            {
                                LoggerHandle = pListLoggerInfo[j]->Wnode.HistoricalContext;
                                Status = EnableTrace(
                                          FALSE,
                                          (pListLoggerInfo[j]->LogFileMode &
                                                  EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                              ? (EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                              : (0),
                                          0,
                                          & pListLoggerInfo[j]->Wnode.Guid,
                                          LoggerHandle);
                            }
                            Status = ControlTrace((TRACEHANDLE) 0,
                                            ListLoggerName,
                                            pListLoggerInfo[j],
                                            EVENT_TRACE_CONTROL_STOP);
                            _tprintf(_T("Logger \"%s\" has been killed\n"), ListLoggerName);
                            StatusPrint = TRUE ;
                        } else {
                            _tprintf(_T("Logger \"%s\" has not been killed, current Status is\n"), ListLoggerName);
                            StatusPrint = FALSE ;
                        }
                    }
                    PrintLoggerStatus(pListLoggerInfo[j], 
// end_sdk
                                        0, 
// begin_sdk
                                        Status, 
                                        StatusPrint);
                    _tprintf(_T("\n"));
                }
            }

            free(Storage);
            break;
        }

        case ACTION_UPDATE :
        case ACTION_FLUSH  :
        case ACTION_QUERY  :
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
            if (Action == ACTION_QUERY) {
// end_sdk
                if (specialLogger == 3) {
                    Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                }
// begin_sdk
                Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
            }

            else if (Action == ACTION_UPDATE) {
// end_sdk               
                if (specialLogger == 3) {
                    Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                }
// begin_sdk
                Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_UPDATE);
            }
            else if (Action == ACTION_FLUSH) {
                // Since FlushTrace is not implemented on Win2K, use the function pointer
                // loaded from advapi32.dll separately.
                // Originally, this block had one line: 
                // Status = FlushTrace(LoggerHandle, LoggerName, pLoggerInfo);
                if (FuncArray[FUNC_FLUSH_TRACE] == NULL) {
                    _tprintf(_T("Flush Trace is not supported on this system\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                Status = (ULONG)(*FuncArray[FUNC_FLUSH_TRACE])(LoggerHandle, LoggerName, pLoggerInfo);
            }

            break;

        case ACTION_ENUM_GUID:
        {
            ULONG PropertyArrayCount=10;
            PTRACE_GUID_PROPERTIES  *GuidPropertiesArray;
            ULONG EnumGuidCount;
            ULONG SizeStorage;
            PVOID StorageNeeded;
            PTRACE_GUID_PROPERTIES CleanStorage;
            TCHAR str[MAXSTR];

            // Since EnumTraceGuids is not implemented on Win2K, use the function pointer
            // loaded from advapi32.dll separately.
            if (FuncArray[FUNC_ENUM_TRACE_GUIDS] == NULL) {
                _tprintf(_T("Enumerating trace GUIDS is not supported on this system\n"));
                Status = ERROR_INVALID_PARAMETER;
                break;
            }

Retry:
            SizeStorage = PropertyArrayCount * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));
            StorageNeeded =  malloc(SizeStorage);
            if (StorageNeeded== NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(StorageNeeded, SizeStorage);
            GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)StorageNeeded;
            CleanStorage = (PTRACE_GUID_PROPERTIES)((char*)StorageNeeded + PropertyArrayCount * sizeof(PTRACE_GUID_PROPERTIES));
            for (i=0; i < PropertyArrayCount; i++) {
                GuidPropertiesArray[i] = CleanStorage;
                CleanStorage = (PTRACE_GUID_PROPERTIES) (
                                    (char*)CleanStorage + sizeof(TRACE_GUID_PROPERTIES)
                                    );
            }
            // Use function pointer for EnumTraceGuids
            Status = (ULONG)(*FuncArray[FUNC_ENUM_TRACE_GUIDS])(GuidPropertiesArray,PropertyArrayCount,&EnumGuidCount);
            if(Status == ERROR_MORE_DATA)
            {
                PropertyArrayCount=EnumGuidCount;
                free(StorageNeeded);
                goto Retry;

            }

            //
            // print the GUID_PROPERTIES and Free Strorage
            //

            _tprintf(_T("    Guid                     Enabled  LoggerId Level Flags\n"));
            _tprintf(_T("------------------------------------------------------------\n"));
            for (i=0; i < EnumGuidCount; i++) {
                _tprintf(_T("%s     %5s  %d    %d    %d\n"),
                                           GuidToString(&str[0],&GuidPropertiesArray[i]->Guid), 
                                           (GuidPropertiesArray[i]->IsEnable) ? _T("TRUE") : _T("FALSE"),
                                            GuidPropertiesArray[i]->LoggerId,
                                           GuidPropertiesArray[i]->EnableLevel,
                                           GuidPropertiesArray[i]->EnableFlags 
                                                               );
            }
            free(StorageNeeded);
        }
        break;

        case ACTION_HELP:
            PrintHelpMessage();
            break;
        default :
            _tprintf(_T("Error: no action specified\n"));
            PrintHelpMessage();
            break;
    }
    
    if ((Action != ACTION_HELP) && (Action != ACTION_ENUM_GUID) 
        && (Action != ACTION_UNDEFINED) && (Action != ACTION_LIST))
        PrintLoggerStatus(pLoggerInfo,
// end_sdk
                            GlobalLoggerStartValue,
// begin_sdk
                            Status, 
                            PRINTSTATUS);
CleanupExit: 
    SetLastError(Status);
    if (utargv != NULL) {
        GlobalFree(utargv);
    }
    free(pLoggerInfo);
    free(save);
    if (advapidll != NULL)
        FreeLibrary(advapidll);
    return(Status);
}


void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
// end_sdk
    IN ULONG GlobalLoggerStartValue,
// begin_sdk
    IN ULONG Status,
    IN BOOL PrintStatus
    )
/*++

Routine Description:

    Prints out the status of the specified logger.

Arguments:

    LoggerInfo - The pointer to the resident EVENT_TRACE_PROPERTIES that has
        the information about the current logger.
// end_sdk
    GlobalLoggerStartValue - The Start value for GlobalLogger (not used if it is
        not GlobalLogger).
// begin_sdk
    Status - The returned status of the last executed command 
        or
        the operation status of the current logger.

    PrintStatus - Determines which type of status it is using.

Return Value:

    None

--*/
{
    LPTSTR LoggerName, LogFileName;
    
    if ((LoggerInfo->LoggerNameOffset > 0) &&
        (LoggerInfo->LoggerNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LoggerName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LoggerNameOffset);
    }
    else LoggerName = NULL;

    if ((LoggerInfo->LogFileNameOffset > 0) &&
        (LoggerInfo->LogFileNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;

    if (PrintStatus) {
        _tprintf(_T("Operation Status:       %uL\t"), Status);
        _tprintf(_T("%s\n"), DecodeStatus(Status));
    }
    
    _tprintf(_T("Logger Name:            %s\n"),
            (LoggerName == NULL) ?
            _T(" ") : LoggerName);
// end_sdk
    if (LoggerName == NULL || !_tcscmp(LoggerName, GLOBAL_LOGGER)) {
        // Logger ID
        _tprintf(_T("Status:                 %s\n"), 
                GlobalLoggerStartValue ?
                _T("Registry set to start") : _T("Registry set to stop"));
        _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %p\n"), LoggerInfo->LoggerThreadId);
        if (LoggerInfo->BufferSize == 0)
            _tprintf(_T("Buffer Size:            default value\n"));
        else
            _tprintf(_T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);

        if (LoggerInfo->MaximumBuffers == 0)
            _tprintf(_T("Maximum Buffers:        default value\n"));
        else
            _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
        if (LoggerInfo->MinimumBuffers == 0)
            _tprintf(_T("Minimum Buffers:        default value\n"));
        else
            _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
        
        _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), LoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (LoggerInfo->MaximumFileSize > 0) {
            if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE)
                _tprintf(_T("Maximum File Size:      %d Kb\n"), LoggerInfo->MaximumFileSize);
            else
                _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);
        }
        if (LoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);
        if (LoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));
            if ((LoggerName != NULL) && (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME))) {

                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }
            else {
                _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName == NULL || _tcslen(LogFileName) == 0) {
            _tprintf(_T("Log Filename:           default location\n"));
            _tprintf(_T("                        %%SystemRoot%%\\System32\\LogFiles\\WMI\\trace.log\n"));
        }
        else
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);

        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
            _tprintf(_T("Local Sequence numbers in use\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
            _tprintf(_T("Global Sequence numbers in use\n"));
        }
    }
    else {
// begin_sdk
        _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %p\n"), LoggerInfo->LoggerThreadId);
        if (Status != 0)
            return;

        _tprintf(_T("Buffer Size:            %d Kb"), LoggerInfo->BufferSize);
        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
            _tprintf(_T(" using paged memory\n"));
        }
        else {
            _tprintf(_T("\n"));
        }
        _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
        _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
        _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), LoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            _tprintf(_T("Real Time mode enabled"));
// end_sdk
            if (LoggerInfo->LogFileMode & EVENT_TRACE_BUFFERING_MODE) {
                _tprintf(_T(": buffering only"));
            }
// begin_sdk
            _tprintf(_T("\n"));
        }

        if (LoggerInfo->MaximumFileSize > 0) {
            if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE)
                _tprintf(_T("Maximum File Size:      %d Kb\n"), LoggerInfo->MaximumFileSize);
            else
                _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);
        }

        if (LoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

        if (LoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));

            if ((LoggerName != NULL) && (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME))) {

                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }else{
                _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName != NULL) {
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);
        }
// end_sdk
        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
            _tprintf(_T("Local Sequence numbers in use\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
            _tprintf(_T("Global Sequence numbers in use\n"));
        }
    }
// begin_sdk

}

LPTSTR
DecodeStatus(
    IN ULONG Status
    )
/*++

Routine Description:

    Decodes WIN32 error into a string in the default language.

Arguments:

    Status - The error status from the last executed command 
        or
        the operation status of the current logger.

Return Value:

    LPTSTR - String containing the decoded message.


--*/
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}

LONG
GetGuids(
    IN LPTSTR GuidFile, 
    IN OUT LPGUID *GuidArray
)
/*++

Routine Description:

    Reads GUIDs from a file and stores them in an GUID array.

Arguments:

    GuidFile - The file containing GUIDs. 
    GuidArray - The GUID array that will have GUIDs read from the file.

Return Value:

    ULONG - The number of GUIDs processed.


--*/
{
    FILE *f;
    TCHAR line[MAXSTR], arg[MAXSTR];
    LPGUID Guid;
    int i, n;

    f = _tfopen((TCHAR*)GuidFile, _T("r"));

    if (f == NULL)
        return -1;

    n = 0;
    while ( _fgetts(line, MAXSTR, f) != NULL ) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        Guid = (LPGUID) GuidArray[n];
        n ++;
        StringToGuid(line, Guid);
    }
    fclose(f);
    return (ULONG)n;
}

ULONG 
ahextoi(
    IN TCHAR *s
    )
/*++

Routine Description:

    Converts a hex string into a number.

Arguments:

    s - A hex string in TCHAR. 

Return Value:

    ULONG - The number in the string.


--*/
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}


void 
StringToGuid(
    IN TCHAR *str, 
    IN OUT LPGUID guid
)
/*++

Routine Description:

    Converts a string into a GUID.

Arguments:

    str - A string in TCHAR.
    guid - The pointer to a GUID that will have the converted GUID.

Return Value:

    None.


--*/
{
    TCHAR temp[10];
    int i;

    try {

        _tcsncpy(temp, str, 8);
        temp[8] = 0;
        guid->Data1 = ahextoi(temp);
        _tcsncpy(temp, &str[9], 4);
        temp[4] = 0;
        guid->Data2 = (USHORT) ahextoi(temp);
        _tcsncpy(temp, &str[14], 4);
        temp[4] = 0;
        guid->Data3 = (USHORT) ahextoi(temp);

        for (i=0; i<2; i++) {
            _tcsncpy(temp, &str[19 + (i*2)], 2);
            temp[2] = 0;
            guid->Data4[i] = (UCHAR) ahextoi(temp);
        }
        for (i=2; i<8; i++) {
            _tcsncpy(temp, &str[20 + (i*2)], 2);
            temp[2] = 0;
            guid->Data4[i] = (UCHAR) ahextoi(temp);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        _tprintf( _T("Error: Invalid GuidFile!\n") );
        exit(0);
    }
}

void 
DisplayVersionInfo()
/*++

Routine Description:

    prints out a version information.

Arguments:

    None.

Return Value:

    None.


--*/
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, MAXSTR);

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){

            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _tprintf( _T("\nMicrosoft (R) %s (%s)\n%s\n\n"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }
}

void PrintHelpMessage()
/*++

Routine Description:

    prints out a help message.

Arguments:

    None.

Return Value:

    None.


--*/
{
// end_sdk
    DisplayVersionInfo();
// begin_sdk
    _tprintf(_T("Usage: tracelog [actions] [options] | [-h | -help | -?]\n"));
    _tprintf(_T("\n    actions:\n"));
    _tprintf(_T("\t-start   [LoggerName] Starts up the [LoggerName] trace session\n"));
    _tprintf(_T("\t-stop    [LoggerName] Stops the [LoggerName] trace session\n"));
    _tprintf(_T("\t-update  [LoggerName] Updates the [LoggerName] trace session\n"));
    _tprintf(_T("\t-enable  [LoggerName] Enables providers for the [LoggerName] session\n"));
    _tprintf(_T("\t-disable [LoggerName] Disables providers for the [LoggerName] session\n"));
    if (XP)
        _tprintf(_T("\t-flush   [LoggerName] Flushes the [LoggerName] active buffers\n"));
// end_sdk
    _tprintf(_T("\t-remove  GlobalLogger Removes registry keys that activate GlobalLogger\n"));
// begin_sdk
    if (XP)
        _tprintf(_T("\t-enumguid             Enumerate Registered Trace Guids\n"));
    _tprintf(_T("\t-q       [LoggerName] Query status of [LoggerName] trace session\n"));
    _tprintf(_T("\t-l                    List all trace sessions\n"));
    _tprintf(_T("\t-x                    Stops all active trace sessions\n"));

    _tprintf(_T("\n    options:\n"));
    _tprintf(_T("\t-b   <n>              Sets buffer size to <n> Kbytes\n"));
    _tprintf(_T("\t-min <n>              Sets minimum buffers\n"));
    _tprintf(_T("\t-max <n>              Sets maximum buffers\n"));
    _tprintf(_T("\t-f <name>             Log to file <name>\n"));
    if (XP) {
        _tprintf(_T("\t-append               Append to file\n"));
        _tprintf(_T("\t-prealloc             Pre-allocate\n"));
    }
    _tprintf(_T("\t-seq <n>              Sequential logfile of up to n Mbytes\n"));
    _tprintf(_T("\t-cir <n>              Circular logfile of n Mbytes\n"));
    if (XP)
        _tprintf(_T("\t-newfile <n>          Log to a new file after every n Mbytes\n"));
    _tprintf(_T("\t-ft <n>               Set flush timer to n seconds\n"));
    if (XP)
        _tprintf(_T("\t-paged                Use pageable memory for buffers\n"));
    _tprintf(_T("\t-noprocess            Disable Process Start/End tracing\n"));
    _tprintf(_T("\t-nothread             Disable Thread Start/End tracing\n"));
    _tprintf(_T("\t-nodisk               Disable Disk I/O tracing\n"));
    _tprintf(_T("\t-nonet                Disable Network TCP/IP tracing\n"));
    _tprintf(_T("\t-fio                  Enable file I/O tracing\n"));
    _tprintf(_T("\t-pf                   Enable page faults tracing\n"));
    _tprintf(_T("\t-hf                   Enable hard faults tracing\n"));
    _tprintf(_T("\t-img                  Enable image load tracing\n"));
    _tprintf(_T("\t-cm                   Enable registry calls tracing\n"));
    _tprintf(_T("\t-um                   Enable Process Private tracing\n"));
    _tprintf(_T("\t-guid <file>          Start tracing for providers in file\n"));
    _tprintf(_T("\t-rt                   Enable tracing in real time mode\n"));
    _tprintf(_T("\t-kd                   Enable tracing in kernel debugger\n"));
   // _tprintf(_T("\t-dbg                  Enable debug tracing in DbgPrint(Ex) statements\n"));
   // _tprintf(_T("\t-ntsuccess                  Enable debug tracing in NT_SUCCESS macro\n"));
    _tprintf(_T("\t-age <n>              Modify aging decay time to n minutes\n"));
    _tprintf(_T("\t-level <n>            Enable Level passed to the providers\n"));
    _tprintf(_T("\t-flag <n>             Enable Flags passed to the providers\n"));
// end_sdk
    if (XP) {
        _tprintf(_T("\t-eflag <n> <flag...>  Enable flags (several) to providers\n"));
        _tprintf(_T("\t-ls                   Generate Local Sequence Numbers\n"));
        _tprintf(_T("\t-gs                   Generate Global Squence Numbers\n"));
        _tprintf(_T("\t-heap                 Use this for Heap Guid\n"));
        _tprintf(_T("\t-critsec              Use this for CritSec Guid\n"));
        _tprintf(_T("\t-pids <n> <pid1 pid2 ... >\n"));
        _tprintf(_T("\t                      Tracing for Heap and CritSec for different process\n"));
    }
// begin_sdk
    _tprintf(_T("\n"));
    _tprintf(_T("\t-h\n"));
    _tprintf(_T("\t-help\n"));
    _tprintf(_T("\t-?                    Display usage information\n"));
}


PTCHAR 
GuidToString(
    IN OUT PTCHAR s,
    LPGUID piid
    )
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - A string in TCHAR that will have the converted GUID.
    piid - The pointer to a GUID.

Return Value:

    PTCHAR - The string containig the convereted GUID.


--*/
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    return(s);
}

// end_sdk
LPCWSTR cszGlobalLoggerKey = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\WMI\\GlobalLogger";
LPCWSTR cszStartValue = L"Start";
LPCWSTR cszBufferSizeValue = L"BufferSize";
LPCWSTR cszMaximumBufferValue = L"MaximumBuffers";
LPCWSTR cszMinimumBufferValue = L"MinimumBuffers";
LPCWSTR cszFlushTimerValue = L"FlushTimer";
LPCWSTR cszFileNameValue = L"FileName";
LPCWSTR cszEnableKernelValue = L"EnableKernelFlags";
LPCWSTR cszClockTypeValue = L"ClockType";

//
// GlobalLogger functions
// 
ULONG
SetGlobalLoggerSettings(
    IN DWORD StartValue,
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN DWORD ClockType
)
/*++

Since it is a standalone utility, there is no need for extensive comments. 

Routine Description:

    Depending on the value given in "StartValue", it sets or resets event
    trace registry. If the StartValue is 0 (Global logger off), it deletes
    all the keys (that the user may have set previsouly).
    
    Users are allowed to set or reset individual keys using this function,
    but only when "-start GlobalLogger" is used.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    StartValue - The "Start" value to be set in the registry.
                    0: Global logger off
                    1: Global logger on
    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are used to set registry keys.

    ClockType - The type of the clock to be set.

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    DWORD  dwValue;
    NTSTATUS status;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey, UnicodeString;
    ULONG Disposition, TitleIndex;

    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );

    // instead of opening, create a new key because it may not exist.
    // if one exists already, that handle will be passed.
    // if none exists, it will create one.
    status = NtCreateKey(&KeyHandle,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &ObjectAttributes,
                         0L,    // not used within this call anyway.
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &Disposition);

    if(!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    TitleIndex = 0L;


    if (StartValue == 1) { // ACTION_START: set filename only when it is given by a user.
        // setting BufferSize
        if (LoggerInfo->BufferSize > 0) {
            dwValue = LoggerInfo->BufferSize;
            RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MaximumBuffers
        if (LoggerInfo->MaximumBuffers > 0) {
            dwValue = LoggerInfo->MaximumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MinimumBuffers 
        if (LoggerInfo->MinimumBuffers > 0) {
            dwValue = LoggerInfo->MinimumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting FlushTimer
        if (LoggerInfo->FlushTimer > 0) {
            dwValue = LoggerInfo->FlushTimer;
            RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting EnableFlags
        if (LoggerInfo->EnableFlags > 0) {
            dwValue = LoggerInfo->EnableFlags;
            RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }

        dwValue = 0;
        if (LoggerInfo->LogFileNameOffset > 0) {
            UNICODE_STRING UnicodeFileName;
#ifndef UNICODE
            WCHAR TempString[MAXSTR];
            MultiByteToWideChar(CP_ACP,
                                0,
                                (PCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo),
                                strlen((PCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo)),
                                TempString,
                                MAXSTR
                                );
            RtlInitUnicodeString((&UnicodeFileName), TempString);
#else
            RtlInitUnicodeString((&UnicodeFileName), (PWCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo));
#endif
            RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_SZ,
                        UnicodeFileName.Buffer,
                        UnicodeFileName.Length + sizeof(UNICODE_NULL)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
    }
    else { // if ACTION_STOP then delete the keys that users might have set previously.
        // delete buffer size
        RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete maximum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete minimum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete flush timer
        RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete enable falg
        RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete filename
        RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
    }

    // setting ClockType
    if (ClockType > 0) {
        dwValue = ClockType;
        RtlInitUnicodeString((&UnicodeString),(cszClockTypeValue));
        status = NtSetValueKey(
                    KeyHandle,
                    &UnicodeString,
                    TitleIndex,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue)
                    );
        if (!NT_SUCCESS(status)) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        TitleIndex++;
    }

     // Setting StartValue
    dwValue = StartValue;
    RtlInitUnicodeString((&UnicodeString),(cszStartValue));
    status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                TitleIndex,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue)
                );
    if (!NT_SUCCESS(status)) {
        NtClose(KeyHandle);
        return RtlNtStatusToDosError(status);
    }
    TitleIndex++;

    NtClose(KeyHandle);
    return 0;
}

ULONG
GetGlobalLoggerSettings(
    IN OUT PEVENT_TRACE_PROPERTIES LoggerInfo,
    OUT PULONG ClockType,
    OUT PDWORD pdwStart
)
/*++

Routine Description:

    It reads registry for golbal logger and updates LoggerInfo. It uses 
    NtEnumerateValueKey() to retrieve the values of the required subkeys.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are updated as the result.

    ClockType - The type of the clock to be updated.
    pdwStart - The "Start" value of currently retained in the registry.

Return Value:

    WINERROR - Error Code defined in winerror.h. If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    ULONG i, j;
    NTSTATUS status;
    HANDLE KeyHandle;
    WCHAR SubKeyName[MAXSTR];
    PVOID Buffer;
    ULONG BufferLength, RequiredLength, KeyNameLength, KeyDataOffset, KeyDataLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey;

    *pdwStart = 0;

    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );
    status = NtOpenKey(
                &KeyHandle,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(status)) 
        return RtlNtStatusToDosError(status);

    // KEY_VALUE_FULL_INFORMATION + name (1 WSTR) + data.
    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + 2 * MAXSTR * sizeof(TCHAR);
    Buffer = (PVOID) malloc(BufferLength);
    if (Buffer == NULL) {
        NtClose(KeyHandle);
        return (ERROR_OUTOFMEMORY);
    }

    i = 0;
    do {
        // Using Key Enumeration
        status = NtEnumerateValueKey(
                    KeyHandle,
                    i++,
                    KeyValueFullInformation,
                    Buffer,
                    BufferLength,
                    &RequiredLength
                    );


        if (!NT_SUCCESS(status)) {
            if (status == STATUS_NO_MORE_ENTRIES)
                break;
            else if (status == STATUS_BUFFER_OVERFLOW) {
                free(Buffer);
                Buffer = malloc(RequiredLength);
                if (Buffer == NULL) {
                    NtClose(KeyHandle);
                    return (ERROR_OUTOFMEMORY);
                }

                status = NtEnumerateValueKey(
                            KeyHandle,
                            i++,
                            KeyValueFullInformation,
                            Buffer,
                            BufferLength,
                            &RequiredLength
                            );
                if (!NT_SUCCESS(status)) {
                    NtClose(KeyHandle);
                    free(Buffer);
                    return RtlNtStatusToDosError(status);
                }
            }
            else {
                NtClose(KeyHandle);
                free(Buffer);
                return RtlNtStatusToDosError(status);
            }
        }
        KeyNameLength = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->NameLength;
        RtlCopyMemory(SubKeyName, 
            (PUCHAR)(((PKEY_VALUE_FULL_INFORMATION)Buffer)->Name), 
            KeyNameLength
            );
        KeyNameLength /= sizeof(WCHAR);
        SubKeyName[KeyNameLength] = L'\0';
        KeyDataOffset = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->DataOffset;
        KeyDataLength = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->DataLength;
        // Find out what the key is
        if (!_wcsicmp(SubKeyName, cszStartValue)) { //StartValue
            RtlCopyMemory(pdwStart, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszBufferSizeValue)) { // BufferSizeValue
            RtlCopyMemory(&(LoggerInfo->BufferSize), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszMaximumBufferValue)) { // MaximumBufferValue
            RtlCopyMemory(&(LoggerInfo->MaximumBuffers), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszMinimumBufferValue)) { // MinimumBuffers
            RtlCopyMemory(&(LoggerInfo->MinimumBuffers), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszFlushTimerValue)) { // FlushTimer
            RtlCopyMemory(&(LoggerInfo->FlushTimer), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszEnableKernelValue)) { // EnableKernelValue
            RtlCopyMemory(&(LoggerInfo->EnableFlags), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszClockTypeValue)) { // ClockTypeValue
            RtlCopyMemory(ClockType, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszFileNameValue)) { // FileName
#ifndef UNICODE
            WCHAR TempString[MAXSTR];
            RtlCopyMemory(TempString, (PUCHAR)Buffer + KeyDataOffset, KeyDataLength);
            WideCharToMultiByte(CP_ACP, 
                                0, 
                                TempString, 
                                wcslen(TempString), 
                                (PUCHAR)LoggerInfo + LoggerInfo->LogFileNameOffset,
                                KeyDataLength, 
                                NULL, 
                                NULL);
#else
            RtlCopyMemory((PUCHAR)LoggerInfo + LoggerInfo->LogFileNameOffset, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
#endif
        }
        else { // Some other keys are in there
            _tprintf(_T("Warning: Unidentified Key in the trace registry: %s\n"), SubKeyName);
        }
        
    }
    while (1);

    NtClose(KeyHandle);
    free(Buffer);
    return 0; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceprt\traceprt.cpp ===
/*++                                                                  
Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

traceprt.c

Abstract:

Trace formatting library. Converts binary trace file to CSV format,
and other formattted string formats.

Author:

Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

GorN: 10/09/2000: ItemHRESULT added

--*/



#ifdef __cplusplus 
extern "C"{ 
#endif


#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#include <ntwmi.h>
#include <netevent.h>
#include <netevent.dbg>
#include <winerror.dbg>
#pragma warning( disable : 4005)  // Disable warning message 4005
#include <ntstatus.h>
#include <ntstatus.dbg>
#pragma warning( default : 4005)  // Enable warning message 4005
#define TRACE_EXPORTS 1
#include "traceint.h"
#undef TRACE_API
#define TRACE_API
#include "traceprt.h"

#include <sddl.h> // for ConvertStringSidToSid //


#ifdef __cplusplus 
} 
#endif 

#ifdef MANAGED_TRACING
//For importing COM types from C# decoder
    #pragma warning (disable: 4278)
//#import "mscorlib.tlb" raw_interfaces_only
    #import "traceevent.tlb"  no_namespace named_guids  //this file is obtained by executing "tlbexp traceevent.dll". 
#endif

#include <set> 

// %1                   GUID Friendly Name                      string
// %2                   GUID SubType Name                       string
// %3                   Thread ID                               ULONG_PTR
// %4                   System Time                             String
// %5                   Kernel Time     or User Time            String
// %6                   User Time       or NULL                 String
// %7                   Sequence Number                         LONG
// %8                   Unused                                  String
// %9                   CPU Number                              LONG
// %128                 Indent                                  String

ULONG TimerResolution = 10;
__int64 ElapseTime;


#define MAXBUFS    16384
#define MAXCHARS    MAXBUFS/sizeof(TCHAR)
#define MAXBUFS2    2 * MAXBUFS
#define MAXCHARS2   MAXBUFS2/sizeof(TCHAR)
#define MAXITEMS    256
#define MAXINDENT   256
#define MAXNAMEARG  256
#define MAXHEXDUMP  512

TCHAR   ItemBuf[MAXBUFS];      // Temporary String Item buffer
TCHAR   ItemBBuf[MAXBUFS2];     // Item String Buffer
TCHAR * ItemBBufEnd ;
TCHAR * pItemBuf[MAXITEMS];    // Pointer to items in the String Item Buffer.
BYTE    ItemRBuf[MAXBUFS];     // Item Raw Byte Buffer
ULONG_PTR * pItemRBuf[MAXITEMS];   // Pointer to Raw Byte Items
SIZE_T  ItemRSize;             // Size of Item in Raw Buffer.
BOOL    bItemIsString = FALSE ; // And type of item
LONG    ItemsInRBuf = 0;
ULONG PointerSize = sizeof(PVOID) ;
BYTE  Event[4096];
HANDLE hLibrary ;
TCHAR   StdPrefix[MAXSTR];
TCHAR   IndentBuf[MAXINDENT + 1];

CHAR         StrA[MAXBUFS];      //tempory Ansi String Buffer
WCHAR        StrW[MAXBUFS];     //tempory Unicode String Buffer
TCHAR        IList[MAXBUFS];    //tempory List for List Long



LPTSTR gTraceFormatSearchPath = NULL;

#define TRACE_FORMAT_SEARCH_PATH L"TRACE_FORMAT_SEARCH_PATH"
#define TRACE_FORMAT_PREFIX      L"TRACE_FORMAT_PREFIX"

//#define STD_PREFIX               L"[%!CPU!]%!PID!.%!TID!::%!NOW! [%!FILE!] "
#define STD_PREFIX_NOSEQ         L"[%9!d!]%8!04X!.%3!04X!::%4!s! [%1!s!]"
#define STD_PREFIX_SEQ           L"[%9!d!]%8!04X!.%3!04X!::%4!s! %7!08x! [%1!s!]"

static TCHAR *STD_PREFIX = STD_PREFIX_NOSEQ;
static BOOL   bGMT = FALSE;
static BOOL   bSequence = FALSE;
static BOOL   bIndent = FALSE;
static BOOL   bUsePrefix = TRUE ;
static BOOL   bStructuredFormat = FALSE ;
DWORD  fIPV6 = 0 ;              //Determins if RtlIpv6AddressToString supported (1 if yes, 2 if no, 0 not checked yet)
typedef LPWSTR (*RTLIPV6ADDRESSTOSTRING)(const in6_addr * IP6Addr, LPWSTR S);
RTLIPV6ADDRESSTOSTRING  pRtlIpv6AddressToString = NULL ;

const TCHAR *pNoValueString = _T("<NoValue>");

#ifdef MANAGED_TRACING
ITraceMessageDecoder *pCSharpDecoder = NULL;  //pointer to CSharp decoder
TCHAR* ptCSFormattedMessage = NULL; //Will point to the formatted message returned by CSharp message decoder
#endif

DWORD
LoadGuidFile(OUT PLIST_ENTRY *HeadEventList,
             IN  LPGUID      pGuid
            );

struct mofinfo_less {
    bool operator() (const PMOF_INFO& a, const PMOF_INFO &b) const 
    { 
        //
        // Two MOF_INFO instances are considered equivalent if they
        // have the same Guid and TypeIndex.
        // If Guids match, strDescription is copied.
        // 
        int result = memcmp(&a->Guid, &b->Guid, sizeof(b->Guid));

        if (result == 0) {
            if ((b->strDescription == NULL ) &&
                (a->strDescription != NULL )) {
                b->strDescription = a->strDescription;
            } else {
                if ((a->strDescription == NULL ) &&
                    (b->strDescription != NULL )) {
                    a->strDescription = b->strDescription;
                }
            }
            return a->TypeIndex < b->TypeIndex;
        }
        return result < 0;
    }
};

typedef std::set<PMOF_INFO, mofinfo_less> MOF_SET;

MOF_SET *pFmtInfoSet = 0;


DWORD InsertFmtInfoSet(PMOF_INFO pMofInfo)
/*++

Routine Description:

    Insert pMofInfo into pFmtInfoSet.

Arguments:


Return Value:
  
  ERROR_SUCCESS if succeeded.
  ERROR_OUTOFMEMORY if out of memory.

Notes:

--*/
{
    if (pFmtInfoSet == 0) {
        pFmtInfoSet = new MOF_SET();
        if (pFmtInfoSet == NULL) {
            return(ERROR_OUTOFMEMORY);
        }
    }

    pFmtInfoSet->insert(pMofInfo); 

    return ERROR_SUCCESS;
} // InsertFmtInfoSet()


void ReplaceStringUnsafe(TCHAR* buf, TCHAR* find, TCHAR* replace)
{
    TCHAR source[MAXSTR], *src, *dst;
    int nf = _tcslen(find);
    int nr = _tcslen(replace);

    src = source;
    dst = buf;

    _tcsncpy(source, buf, MAXSTR );

    for (;;) {
        TCHAR* p = src;
        for (;;) {
            p = _tcsstr(p, find);
            if (!p) goto exit_outer_loop;
            // special kludge not to replace
            // %!Someting! when it is actually %%!Something!
            if (p == source || p[0] != '%' || p[-1] != '%') {
                break;
            }
            p += nf;
        }
        memcpy(dst, src, (p-src) * sizeof(TCHAR) );
        dst += p-src;
        src = p + nf;
        _tcsncpy(dst, replace,(MAXSTR - (p-source)));
        dst += nr;
    }
    exit_outer_loop:
    _tcscpy(dst, src);
}

TCHAR* FindValue(TCHAR* buf, TCHAR* ValueName) 
{
    static TCHAR valueBuf[256]; // largest identifier in PDB
    TCHAR *p = _tcsstr(buf, ValueName); 
    TCHAR *q = p;   
    if (p) {
        p += _tcslen(ValueName);
        q = p;
        while ( *p && !_istspace(*p) ) ++p;
        memcpy(valueBuf, q, (p-q) * sizeof(TCHAR) );
    }
    valueBuf[p-q] = 0;
    return valueBuf;
}

int FindIntValue(TCHAR* buf, TCHAR* ValueName)
{
    TCHAR* v = FindValue(buf, ValueName), *end;
    int sgn = 1;

    if (v[0] == '+') {
        ++v;
    } else if (v[0] == '-') {
        sgn = -1;
        ++v;
    }
    return sgn * _tcstol(v, &end, 10);
}




PMOF_INFO
GetMofInfoHead(
              OUT PLIST_ENTRY * EventListhead,
              IN  LPGUID        pGuid,
              IN  LPTSTR        strType,
              IN  LONG          TypeIndex,
              IN  ULONG         TypeOfType,
              IN  LPTSTR        TypeFormat,
              IN  BOOL          bBestMatch
              );

void   RemoveMofInfo(PLIST_ENTRY pMofInfo);
ULONG  ahextoi(TCHAR *s);
PTCHAR GuidToString(PTCHAR s, LPGUID piid);


ULONG
WINAPI
GetTraceGuidsW(
              TCHAR       * GuidFile,
              PLIST_ENTRY * HeadEventList
              );



VOID 
EtwpConvertHex4(OUT WCHAR *buffer, 
                IN DWORD n,
                IN DWORD count
               )
                /*++

                Routine Description:

                Implementing _snwprintf(buffer, 
                count,
                L"0x%04X", 
                n);

                Arguments:


                Return Value:

                None.

                Notes:


                --*/
{
    const WCHAR hexdigit[] = L"0123456789ABCDEF";

    if (count <= 4) {
        return;
    }

    buffer[0] = hexdigit[(n / 16 / 16 / 16) % 16];
    buffer[1] = hexdigit[(n / 16 / 16) % 16];
    buffer[2] = hexdigit[(n / 16) % 16];
    buffer[3] = hexdigit[n % 16]; 
    buffer[4] = 0;

    return;
} // EtwpConvertHex4()


VOID
EtwpConvertUnsignedInt(OUT WCHAR *buffer, 
                       IN DWORD n,
                       IN DWORD count
                      ) 
                       /*++

                       Routine Description:

                       Implementing _snwprintf(buffer, 
                       count,
                       L"%u", 
                       n);

                       Arguments:


                       Return Value:

                       None.

                       Notes:


                       --*/
{
    WCHAR buffer2[64];
    WCHAR* p = buffer2 + 64;
    DWORD NumDigits = 1;

    *--p = 0;
    do {
        *--p = (WCHAR)(n % 10 + '0'); 
        n /= 10; 
        NumDigits ++;
    } 
    while ((n > 0) && (NumDigits < 32));

    if (count < NumDigits) {
        return;
    }

    memcpy(buffer, p, NumDigits*sizeof(WCHAR));

    return;
} // EtwpConvertUnsignedInt()


VOID 
EtwpConvertUnsignedLong(OUT WCHAR *buffer, 
                        IN DWORD n,
                        IN DWORD count
                       )
                        /*++

                        Routine Description:

                        Implementing _snwprintf(buffer, 
                        count,
                        L"%8lu", 
                        n);

                        Arguments:


                        Return Value:

                        None.

                        Notes:


                        --*/
{
    if (count <= 8) {
        return;
    }

    buffer[8] = 0;
    buffer[7] = (n % 10) + '0';
    buffer[6] = (n / 10) % 10 + '0';
    buffer[5] = (n / 10 / 10) % 10 + '0';
    buffer[4] = (n / 10 / 10 / 10) % 10 + '0';
    buffer[3] = (n / 10 / 10 / 10 / 10) % 10 + '0';
    buffer[2] = (n / 10 / 10 / 10 / 10 / 10) % 10 + '0';
    buffer[1] = (n / 10 / 10 / 10 / 10 / 10 / 10) % 10 + '0';
    buffer[0] = (n / 10 / 10 / 10 / 10 / 10 / 10 / 10) % 10 + '0';

    return;
}   // EtwpConvertUnsignedLong


VOID 
EtwpConvertTimeStamp(OUT WCHAR * buffer,
                     IN SYSTEMTIME sysTime,
                     IN DWORD count
                    )
                     /*++

                     Routine Description:

                     Implementing  _snwprintf(buffer, 
                     count,
                     L"%02d/%02d/%04d-%02d:%02d:%02d.%03d",
                     sysTime.wMonth,
                     sysTime.wDay,
                     sysTime.wYear,
                     sysTime.wHour,
                     sysTime.wMinute,
                     sysTime.wSecond,
                     sysTime.wMilliseconds
                     );

                     Arguments:


                     Return Value:

                     None.

                     Notes:


                     --*/
{
    if (count <= 23) {   // 23 = wcslen(L"%02d/%02d/%04d-%02d:%02d:%02d.%03d")

        return;
    }

    memcpy(buffer, 
           L"00/00/2000-00:00:00.000",
           48 // 48 = (wcslen(L"00/00/2000-00:00:00.000")+1)*sizeof(WCHAR)
          );

    buffer[0] = (WCHAR)(sysTime.wMonth / 10 + '0');
    buffer[1] = (WCHAR)(sysTime.wMonth % 10 + '0');
    buffer[3] = (WCHAR)(sysTime.wDay / 10 + '0');
    buffer[4] = (WCHAR)(sysTime.wDay % 10 + '0');
    buffer[8] = (WCHAR)(sysTime.wYear % 100 / 10 + '0');
    buffer[9] = (WCHAR)(sysTime.wYear % 10 + '0');

    buffer[11] = (WCHAR)(sysTime.wHour / 10 + '0');
    buffer[12] = (WCHAR)(sysTime.wHour % 10 + '0');

    buffer[14] = (WCHAR)(sysTime.wMinute / 10 + '0');
    buffer[15] = (WCHAR)(sysTime.wMinute % 10 + '0');

    buffer[17] = (WCHAR)(sysTime.wSecond / 10 + '0');
    buffer[18] = (WCHAR)(sysTime.wSecond % 10 + '0');

    buffer[20] = (WCHAR)(sysTime.wMilliseconds / 100 + '0');
    buffer[21] = (WCHAR)((sysTime.wMilliseconds / 10) % 10 + '0');
    buffer[22] = (WCHAR)(sysTime.wMilliseconds % 10 + '0');
    buffer[23] = 0;

} // EtwpConvertTimeStamp()


static
void
reduce(
      PCHAR Src
      )
{
    char *Start = Src;
    if (!Src) {
        return;
    }
    while (*Src) {
        if ('\t' == *Src)
            *Src = ' ';
        else if (',' == *Src)
            *Src = ' ';
        else if ('\n' == *Src)
            *Src = ',';
        else if ('\r' == *Src)
            *Src = ' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((' ' == *Src) || (',' == *Src))) {
        *Src = 0x00;
        --Src;
    }
}

static void reduceW(WCHAR *Src)
{
    WCHAR *Start = Src;
    if (!Src) {
        return;
    }
    while (*Src) {
        if (L'\t' == *Src) {
            *Src = L' ';
        } else if (L',' == *Src) {
            *Src = L' ';
        } else if (L'\n' == *Src) {
            *Src = L',';
        } else if (L'\r' == *Src) {
            *Src = L' ';
        }
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((L' ' == *Src) || (L',' == *Src))) {
        *Src = 0x00;
        --Src;
    }
}

#ifdef UNICODE
    #define _stnprintf _snwprintf
#else
    #define _stnprintf _snprintf
#endif

int FormatTimeDelta(TCHAR *buffer, size_t count, LONGLONG time)
{
    SYSTEMTIME st;
    int s = 0, result;
    ZeroMemory(&st, sizeof(st) );

    if (count == 0) {
        return -1;
    }

    if (time < 0) {
        *buffer++ = '-'; 
        --count;
        time = -time;
        s = 1;
    }

    // Get rid of the nano and micro seconds

    time /= 10000;

    st.wMilliseconds = (USHORT)(time % 1000);
    time /= 1000;

    if (time == 0) {
        result = _stnprintf(buffer,count,L"%dms",st.wMilliseconds); 
        goto end;
    }

    st.wSecond = (USHORT)(time % 60);

    time /= 60;

    st.wMinute = (USHORT)(time % 60);

    time /= 60;

    if (time == 0) {
        if (st.wMinute <= 10) {
            result = _stnprintf(buffer,count,L"%d.%03ds",st.wMinute * 60 + st.wSecond, st.wMilliseconds); 
        } else {
            result = _stnprintf(buffer,count,L"%d:%d.%03ds",st.wMinute, st.wSecond, st.wMilliseconds); 
        }
        goto end;
    }
    st.wHour = (USHORT)(time % 24);

    time /= 24;
    if (time == 0) {
        result = _stnprintf(buffer,count,L"%d:%d:%d.%03ds",st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); 
        goto end;
    }
    st.wDay = (USHORT)time;

    result = _stnprintf(buffer,count,L"%d~%d:%d:%d.%03ds",st.wDay,st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); 
    end:
    if (result >= 0) {
        result += s;
    }
    return result;
}

typedef struct _ERROR_MAP {
    NTSTATUS MessageId;
    char *SymbolicName;
} ERROR_MAP;



PMOF_INFO 
EtwpFindMsgFmt(const GUID& guid, 
               int MessageNo, 
               LPTSTR wstr
              )
               /*++

               Routine Description:

               Find message format given guid and MessageNo. If only
               guid is matched, strDescription is copied to wstr.

               Arguments:


               Return Value:

               Matched format.

               Notes:


               --*/
{
    MOF_INFO Key;
    DWORD    Status;

    if (pFmtInfoSet == NULL) {
        return NULL;
    }

    memcpy(&Key.Guid, &guid, sizeof(guid));
    Key.TypeIndex = MessageNo;
    Key.strDescription = NULL;

    MOF_SET::const_iterator iter;

    iter = pFmtInfoSet->find(&Key);  

    if (iter == pFmtInfoSet->end()) {
        if (Key.strDescription != NULL) {
          // Unknown MessageNo
            _tcscpy(wstr, Key.strDescription);
        } else {
          // Unknown Guid. 
        }
        return NULL;
    }

    if (Key.strDescription != NULL) {
        _tcscpy(wstr, (*iter)->strDescription);
    }

    return *iter;
} // EtwpFindMsgFmt()

#ifdef MANAGED_TRACING
HRESULT InitializeCSharpDecoder(){        
    // Initialize COM and create an instance of the InterfaceImplementation class:
    CoInitialize(NULL);
    HRESULT hr = CoCreateInstance(CLSID_TraceProvider,
                                  NULL, CLSCTX_ALL,
                                  IID_ITraceMessageDecoder, reinterpret_cast<void**>(&pCSharpDecoder));
    if (FAILED(hr)) {
        pCSharpDecoder = NULL;
        CoUninitialize();

    }
    return hr;
}
#endif

#ifdef MANAGED_TRACING
void UninitializeCSharpDecoder(){
    if (NULL != pCSharpDecoder) {
        pCSharpDecoder->Release();
        CoUninitialize();
    }
}
#endif

SIZE_T
WINAPI
FormatTraceEventW(
                 PLIST_ENTRY HeadEventList,
                 PEVENT_TRACE pInEvent,
                 TCHAR *EventBuf,
                 ULONG SizeEventBuf,
                 TCHAR * pszMask
                 )
{
    PEVENT_TRACE_HEADER pHeader;
    PEVENT_TRACE        pEvent = NULL;
    ULONG               TraceMarker, TraceType;
    TCHAR               tstrName[MAXSTR];
    TCHAR               tstrType[MAXSTR];
    ULONG               tstrTypeOfType = 0;
    TCHAR             * tstrFormat;
    int                 iItemCount;
    ULONG_PTR           MessageSequence = -1 ;
    USHORT              MessageNumber = 0 ;
    USHORT              MessageFlags = 0 ;
    char              * pMessageData;
    ULONG               MessageLength ;
    PMOF_INFO           pMofInfo = NULL;  
    DWORD               TempLen;


    char                *pCSMessageData ;
    BOOL                bCSharpEvent = 0;    
    const TCHAR         tstrCSharpMsgGuid[]=_T("b4955bf0-3af1-4740-b475-99055d3fe9aa");    
    TCHAR               tstrFailureInfo[128];   
    BOOL                bManagedTracingEnabled = FALSE;
#ifdef MANAGED_TRACING    
    static BOOL         bFirstTime=TRUE;
    HRESULT hr;
#endif
    PSTRUCTUREDMESSAGE  pStructuredMessage = (PSTRUCTUREDMESSAGE)EventBuf;
    ULONG_PTR   pStructuredOffset = (ULONG_PTR)pStructuredMessage + sizeof(STRUCTUREDMESSAGE);

    RtlZeroMemory(EventBuf, SizeEventBuf);    // just in case the caller was untidy

#ifdef MANAGED_TRACING
    bManagedTracingEnabled = TRUE;
#endif

    ItemBBufEnd = ItemBBuf + MAXBUFS2 -1;  //initialise pointer to end of buffer

    if (pInEvent == NULL) {
        return(0);
    }

    pEvent = pInEvent ;
    // Make a copy of the PTR and length as we may adjust these depending
    // on the header
    pMessageData = (char *) pEvent->MofData ;
    MessageLength = pEvent->MofLength ;

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    TCHAR  mguid[100];


    //#ifdef MANAGED_TRACING
    if (_tcscmp(GuidToString(mguid,&pEvent->Header.Guid),tstrCSharpMsgGuid) == 0) {
        bCSharpEvent = 1;
        pCSMessageData = pMessageData;
    }
    //#endif

    TraceMarker =  ((PSYSTEM_TRACE_HEADER)pInEvent)->Marker;

    if ((TraceMarker & TRACE_MESSAGE)== TRACE_MESSAGE ) {

        // This handles the TRACE_MESSAGE type.

        TraceType = TRACE_HEADER_TYPE_MESSAGE ;             // This one has special processing

        //
        // Now Process the header options
        //

        MessageNumber =  ((PMESSAGE_TRACE_HEADER)pEvent)->Packet.MessageNumber ;    // Message Number
        MessageFlags =   ((PMESSAGE_TRACE_HEADER)pEvent)->Packet.OptionFlags ;

        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            RtlCopyMemory(&MessageSequence, pMessageData, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
            MessageLength -= sizeof(ULONG);
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(&pEvent->Header.Guid,pMessageData,sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
            MessageLength -= sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            RtlCopyMemory(&pEvent->Header.Guid,pMessageData, sizeof(GUID));
            pMessageData += sizeof(GUID) ;
            MessageLength -= sizeof(GUID);
        }

        // [Third Entry] Timestamp?
        // After a certain point the OS moved this timestamp into place for us
        // And canonicalised it, fortunately prior to that it was always zero
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            if ((pEvent->Header.TimeStamp.HighPart == 0) && (pEvent->Header.TimeStamp.LowPart == 0)) 
            {
                RtlCopyMemory(&pEvent->Header.TimeStamp.LowPart, pMessageData, sizeof(ULONG));
                pMessageData += sizeof(ULONG);
                RtlCopyMemory(&pEvent->Header.TimeStamp.HighPart, pMessageData, sizeof(ULONG));
                pMessageData += sizeof(ULONG);
            } else {
                pMessageData += sizeof(LARGE_INTEGER);
            }

            MessageLength -= sizeof(LARGE_INTEGER);
        }

        // [Fourth Entry] System Information?
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;
            RtlCopyMemory(&pHeader->ThreadId, pMessageData, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG);
            MessageLength -=sizeof(ULONG);
            RtlCopyMemory(&pHeader->ProcessId,pMessageData, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG);
            MessageLength -=sizeof(ULONG);
        }
        //
        // Add New Header Entries immediately before this comment!
        //
    } else {
        // Must be WNODE_HEADER
        //
        TraceType = 0;
        pEvent = pInEvent ;

        MessageNumber = pEvent->Header.Class.Type ;
        if (MessageNumber == 0xFF) {   // W2K Compatability escape code
            if (pEvent->MofLength >= sizeof(USHORT)) {
                // The real Message Number is in the first USHORT
                memcpy(&MessageNumber,pEvent->MofData,sizeof(USHORT)) ;
                pMessageData += sizeof(USHORT);
                MessageLength -= sizeof(USHORT);
            }
        }
    }
    // Reset the Pointer and length if they have been adjusted
    pEvent->MofData = pMessageData ;
    pEvent->MofLength = MessageLength ;

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    if (   IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid)
           && pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO) {
        PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)pEvent->MofData;
        if (head->TimerResolution > 0) {
            TimerResolution = head->TimerResolution / 10000;
        }
        ElapseTime = head->EndTime.QuadPart -
                     pEvent->Header.TimeStamp.QuadPart;
        PointerSize =  head->PointerSize;
        if (PointerSize < 2 )       // minimum is 16 bits
            PointerSize = 4 ;       // defaults = 32 bits
    }


    for (int attempt = 1;  attempt <= 2; attempt++) {
        DWORD Status;

        tstrName[0] = L'\0'; 
        pMofInfo = EtwpFindMsgFmt((pEvent->Header.Guid), 
                                  MessageNumber,
                                  tstrName
                                 );

        if ((pMofInfo != NULL) || (tstrName[0] != L'\0')) {
            break;
        }

        if (attempt == 2) {
            _tcscpy(tstrName, GUID_TYPE_UNKNOWN);
            break;
        }

        Status = LoadGuidFile(&HeadEventList,
                              &(pEvent->Header.Guid)
                             );
        switch (Status) {
        case ERROR_BAD_FORMAT:
            _tcscpy(tstrName, GUID_TYPE_OBSOLETE);
            break;
        case ERROR_PATH_NOT_FOUND:
            _tcscpy(tstrName, GUID_TYPE_UNKNOWN);
            break;
        default:
            break;
        }

        if ((Status == ERROR_BAD_FORMAT) ||
            (Status == ERROR_PATH_NOT_FOUND)
           ) {
            break;
        }
    } // for


    if (IsEqualGUID(&(pEvent->Header.Guid), &EventTraceGuid)) {
        _tcscpy(tstrName, GUID_TYPE_HEADER);
    }



    if (pEvent != NULL) {


        PITEM_DESC  pItem;
        PCHAR       ptr     = NULL;
        PCHAR       iMofPtr = NULL;
        ULONG       ulongword;
        PLIST_ENTRY Head, Next;
        int         i;


        if ((pMofInfo != NULL) && (pMofInfo->strType != NULL)) {
            _sntprintf(tstrType,MAXSTR,_T("%s"),pMofInfo->strType);
            tstrFormat     = pMofInfo->TypeFormat; //  Pointer to the format string
            tstrTypeOfType = pMofInfo->TypeOfType; // And the type of Format

        } else {
            _sntprintf(tstrType,MAXSTR,_T("%3d"),MessageNumber);
            tstrFormat = NULL ;
            tstrTypeOfType = 0 ;
        }

        // From here on we start processing the parameters, we actually do
        // two versions. One is built for original #type format statements,
        // and everything is converted to being an ASCII string.
        // The other is built for #type2 format statements and everything is
        // converted into a string of raw bytes aliggned on a 64-bit boundary.

        iItemCount = 0 ;                    // How many Items we process
        pItemBuf[iItemCount] = ItemBBuf;       // Where they go (Strings)

        // Make Parameter %1 Type Name
        TempLen =  _tcslen(tstrName);
        memcpy(pItemBuf[iItemCount],
               tstrName,
               min(TempLen + 1, ItemBBufEnd - pItemBuf[iItemCount]) * sizeof(WCHAR)
              );
        pItemBuf[iItemCount + 1] = pItemBuf[iItemCount] + TempLen + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same for Raw bytes
        iItemCount ++;

        if (bStructuredFormat) {
            pStructuredMessage->TraceGuid = EventTraceGuid ;
            RtlCopyMemory((PVOID)pStructuredOffset,tstrName, min(_tcslen(tstrName) + 1, NAMESIZE) * sizeof(WCHAR));
            pStructuredMessage->GuidName = pStructuredOffset - (ULONG_PTR)pStructuredMessage;
            pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
        }


        // Make Parameter %2 Type sub Type
        TempLen = _tcslen(tstrType);
        memcpy(pItemBuf[iItemCount],
               tstrType,
               min(TempLen + 1, ItemBBufEnd - pItemBuf[iItemCount]) * sizeof(WCHAR)
              );
        pItemBuf[iItemCount + 1] = pItemBuf[iItemCount] + TempLen + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *)pItemBuf[iItemCount]; // just use the same for raw bytes
        iItemCount ++;

       if (bStructuredFormat) {
            RtlCopyMemory((PVOID)pStructuredOffset,tstrType,min(_tcslen(tstrType) + 1, NAMESIZE) * sizeof(WCHAR));
            pStructuredMessage->GuidTypeName= pStructuredOffset - (ULONG_PTR)pStructuredMessage;
            pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
        }



        // Make Parameter %3 ThreadId
        RtlCopyMemory(&pItemRBuf[iItemCount] , &pHeader->ThreadId, sizeof(ULONG)) ;
        EtwpConvertHex4(pItemBuf[iItemCount], 
                        pHeader->ThreadId,
                        ItemBBufEnd - pItemBuf[iItemCount]
                       );
        TempLen = _tcslen(pItemBuf[iItemCount]);


        pItemBuf[iItemCount + 1] = pItemBuf[iItemCount] + TempLen + 1;
        iItemCount++;

        if (bStructuredFormat) {
            RtlCopyMemory(&pStructuredMessage->ThreadId,&pHeader->ThreadId,sizeof(ULONG));
        }


            // Make Parameter %4 System Time
        if (tstrFormat != NULL) {

            FILETIME      stdTime, localTime;
            SYSTEMTIME    sysTime;

            stdTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
            stdTime.dwLowDateTime  = pEvent->Header.TimeStamp.LowPart;
            if (bGMT) {
                FileTimeToSystemTime(&stdTime, &sysTime);
            } else {
                FileTimeToLocalFileTime(&stdTime, &localTime);
                FileTimeToSystemTime(&localTime, &sysTime);
            }

            if (bStructuredFormat) {
                RtlCopyMemory(&pStructuredMessage->SystemTime,&sysTime,sizeof(SYSTEMTIME));
            }

            EtwpConvertTimeStamp(pItemBuf[iItemCount],
                                 sysTime,
                                 ItemBBufEnd - pItemBuf[iItemCount]
                                );

        } else {
            _sntprintf(pItemBuf[iItemCount], ItemBBufEnd - pItemBuf[iItemCount],  _T("%20I64u"), pHeader->TimeStamp.QuadPart);
        }

        TempLen = _tcslen(pItemBuf[iItemCount]);

        pItemBuf[iItemCount + 1] =
        pItemBuf[iItemCount] + TempLen + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *)pItemBuf[iItemCount]; // just use the same
        iItemCount ++;

            // Make Parameter %5 Kernel Time
        EtwpConvertUnsignedLong(pItemBuf[iItemCount],
                                pHeader->KernelTime * TimerResolution,
                                ItemBBufEnd - pItemBuf[iItemCount] 
                               );
        TempLen = _tcslen(pItemBuf[iItemCount]);

        pItemBuf[iItemCount + 1] =
        pItemBuf[iItemCount] + TempLen + 1; 
        pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same
        iItemCount ++;

        if (bStructuredFormat) {
            ULONG kTime =  pHeader->KernelTime * TimerResolution ;
            RtlCopyMemory(&pStructuredMessage->KernelTime,&kTime,sizeof(ULONG));
        }

            // Make Parameter %6 User Time
        EtwpConvertUnsignedLong(pItemBuf[iItemCount],
                                pHeader->UserTime * TimerResolution,
                                ItemBBufEnd - pItemBuf[iItemCount] 
                               );
        TempLen = _tcslen(pItemBuf[iItemCount]);

        pItemBuf[iItemCount + 1] =
        pItemBuf[iItemCount] + TempLen + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same
        iItemCount ++;

        if (bStructuredFormat) {
            ULONG uTime =  pHeader->UserTime * TimerResolution ;
            RtlCopyMemory(&pStructuredMessage->UserTime,&uTime,sizeof(ULONG));
        }

            // Make Parameter %7  Sequence Number
        EtwpConvertUnsignedInt(pItemBuf[iItemCount],
                               MessageSequence,
                               ItemBBufEnd - pItemBuf[iItemCount] 
                              );
        TempLen = _tcslen(pItemBuf[iItemCount]);
        pItemBuf[iItemCount + 1] =
        pItemBuf[iItemCount] + TempLen + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) MessageSequence ; // Raw just point at the value
        iItemCount ++;

        if (bStructuredFormat) {
            RtlCopyMemory(&pStructuredMessage->SequenceNum,&MessageSequence,sizeof(ULONG));
        }

            // Make Parameter %8 ProcessId
        RtlCopyMemory(&pItemRBuf[iItemCount],&pHeader->ProcessId,sizeof(ULONG));
        EtwpConvertHex4(pItemBuf[iItemCount], 
                        pHeader->ProcessId,
                        ItemBBufEnd - pItemBuf[iItemCount] 
                       );
        TempLen = _tcslen(pItemBuf[iItemCount]);
        pItemBuf[iItemCount + 1] =
        pItemBuf[iItemCount] + TempLen + 1;
        iItemCount ++;

        if (bStructuredFormat) {
            RtlCopyMemory(&pStructuredMessage->ProcessId,&pHeader->ProcessId,sizeof(ULONG));
        }


             // Make Parameter %9 CPU Number
        EtwpConvertUnsignedInt(pItemBuf[iItemCount],
                               ((PWMI_CLIENT_CONTEXT)&(pEvent->ClientContext))->ProcessorNumber,
                               ItemBBufEnd - pItemBuf[iItemCount] 
                              );
        TempLen = _tcslen(pItemBuf[iItemCount]);
        pItemBuf[iItemCount + 1] = pItemBuf[iItemCount] + TempLen + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) (((PWMI_CLIENT_CONTEXT)&(pEvent->ClientContext))->ProcessorNumber) ;
        iItemCount ++;

        if (bStructuredFormat) {
            RtlCopyMemory(&pStructuredMessage->CpuNumber,
                          &(((PWMI_CLIENT_CONTEXT)&(pEvent->ClientContext))->ProcessorNumber),
                          sizeof(UCHAR));
        }

        if ((pMofInfo != NULL) && bStructuredFormat) {
            pStructuredMessage->Indent = pMofInfo->Indent ;
            if (pMofInfo->FunctionName != NULL) {
                RtlCopyMemory((PVOID)pStructuredOffset,pMofInfo->FunctionName,min(_tcslen(pMofInfo->FunctionName) + 1, NAMESIZE) * sizeof(WCHAR));
                pStructuredMessage->FunctionName= pStructuredOffset - (ULONG_PTR)pStructuredMessage;
                pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
            }
            if (pMofInfo->TraceFlagsName != NULL) {
                RtlCopyMemory((PVOID)pStructuredOffset,pMofInfo->TraceFlagsName,min(_tcslen(pMofInfo->TraceFlagsName) + 1, NAMESIZE) * sizeof(WCHAR));
                pStructuredMessage->FlagsName= pStructuredOffset - (ULONG_PTR)pStructuredMessage;
                pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
            }
            if (pMofInfo->TraceLevelsName != NULL) {
                RtlCopyMemory((PVOID)pStructuredOffset,pMofInfo->TraceLevelsName,min(_tcslen(pMofInfo->TraceLevelsName) + 1, NAMESIZE) * sizeof(WCHAR));
                pStructuredMessage->LevelName= pStructuredOffset - (ULONG_PTR)pStructuredMessage;
                pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
            }
            if (pMofInfo->ComponentName != NULL) {
                RtlCopyMemory((PVOID)pStructuredOffset,pMofInfo->ComponentName,min(_tcslen(pMofInfo->ComponentName) + 1, NAMESIZE) * sizeof(WCHAR));
                pStructuredMessage->ComponentName= pStructuredOffset - (ULONG_PTR)pStructuredMessage;
                pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
            }
            if (pMofInfo->SubComponentName != NULL) {
                RtlCopyMemory((PVOID)pStructuredOffset,pMofInfo->SubComponentName,min(_tcslen(pMofInfo->SubComponentName) + 1, NAMESIZE) * sizeof(WCHAR));
                pStructuredMessage->SubComponentName= pStructuredOffset - (ULONG_PTR)pStructuredMessage;
                pStructuredOffset +=  (_tcslen((TCHAR *)pStructuredOffset) +1) * sizeof(WCHAR) ;
            }
        }

             // Done processing Parameters
        
        if (pMofInfo != NULL) {
            Head = pMofInfo->ItemHeader;
            pMofInfo->EventCount ++;
            Next = Head->Flink;
        } else {
            Head = Next = NULL ;

        }

#ifdef MANAGED_TRACING
        if (bCSharpEvent && NULL == pCSharpDecoder && bFirstTime) {
            hr = InitializeCSharpDecoder();
        }
#endif
#ifdef MANAGED_TRACING
             //Now we branch out depending on whether the current
             //event was generated by C# or not.
        if (bCSharpEvent) {
            if (NULL != pCSharpDecoder) {
                     //TODO[1]: Is there a potential for pMessageData to be updated ?
                long dataSize;
                int result;
                ptCSFormattedMessage = ItemBuf;
                result = pCSharpDecoder->DecodeTraceMessage((BYTE*)pCSMessageData, ptCSFormattedMessage, MAXBUFS*sizeof(TCHAR)/2, &dataSize);
                if (0 == result) {
                    ptCSFormattedMessage = (TCHAR *)malloc(2*dataSize);
                    if (NULL != ptCSFormattedMessage) {
                        result = pCSharpDecoder->DecodeTraceMessage((BYTE*)pCSMessageData, ptCSFormattedMessage, MAXBUFS*sizeof(TCHAR)/2, &dataSize);                    
                    } else {
                        _stprintf(tstrFailureInfo,_T("Out of memory"));
                        pItemRBuf[iItemCount++] = (ULONG_PTR*)tstrFailureInfo;
                        tstrTypeOfType = 2;
                    }        
                }
                if (-1 == result) {
                         //An exception would have been thrown in the C# decoder.
                    _stprintf(tstrFailureInfo,_T("Badly formed arguments to C# decoder"));
                    pItemRBuf[iItemCount++] = (ULONG_PTR*)tstrFailureInfo;
                    tstrTypeOfType = 2;
                } else if (NULL != ptCSFormattedMessage) {
                    pItemRBuf[iItemCount++] = (ULONG_PTR*)ptCSFormattedMessage;
                    tstrTypeOfType = 2;
                }
            } else {
                if (bFirstTime)
                    _stprintf(tstrFailureInfo,_T("%s [0x%x]"),_T("Failed to initalize C# decoder"),hr);
                else _stprintf(tstrFailureInfo,_T("Failed to initalize C# decoder"));
                pItemRBuf[iItemCount++] = (ULONG_PTR*)tstrFailureInfo;
                tstrTypeOfType = 2;
            }
            bFirstTime = FALSE;
        }
#endif

#ifdef MANAGED_TRACING
        else {
#endif
            if (!bManagedTracingEnabled && bCSharpEvent) {
                _sntprintf(tstrFailureInfo,sizeof(tstrFailureInfo)/sizeof(TCHAR) - sizeof(TCHAR),_T("C# decoding is not enabled"));
                pItemRBuf[iItemCount++] = (ULONG_PTR*)tstrFailureInfo;
                tstrTypeOfType = 2;
            } else {
                __try {

                    if ( Head != Next ) {
                        iMofPtr = (char *) malloc(pEvent->MofLength + sizeof(UNICODE_NULL));

                        if (iMofPtr == NULL) {
                            return -1;
                        }

                        RtlCopyMemory(iMofPtr, pEvent->MofData, pEvent->MofLength);

                        ptr = iMofPtr;
                        while (Head != Next) {
                            ULONG     * ULongPtr     = (ULONG *)     & ItemRBuf[0];
                            USHORT    * UShortPtr    = (USHORT *)    & ItemRBuf[0];
                            LONGLONG  * LongLongPtr  = (LONGLONG *)  & ItemRBuf[0];
                            ULONGLONG * ULongLongPtr = (ULONGLONG *) & ItemRBuf[0];
                            double    * DoublePtr    = (double *)    & ItemRBuf[0];

                            TCHAR * PtrFmt1, * PtrFmt2 ;

                            pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);

                            if ((ULONG) (ptr - iMofPtr) >= pEvent->MofLength) {
                                break;
                            }


                            bItemIsString = FALSE ; // Assume its a RAW value
                            ItemRSize = 0 ;         // Raw length of zero                
                            switch (pItem->ItemType) {
                            case ItemChar:
                            case ItemUChar:
                                ItemRSize = sizeof(CHAR);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemCharSign:
                                ItemRSize = sizeof(CHAR) * 2;
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ItemRBuf[2] = '\0';
                                ptr += ItemRSize;
                                break;

                            case ItemCharShort:
                                ItemRSize = sizeof(CHAR);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemShort:
                                ItemRSize = sizeof(USHORT);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemDouble:
                                ItemRSize = sizeof(double);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                _sntprintf(ItemBuf,MAXBUFS, _T("%g"), * DoublePtr);
                                ptr += ItemRSize;
                                ItemRSize = 0; // FormatMessage cannot print 8 byte stuff properly on x86
                                break;

                            case ItemUShort:
                                ItemRSize = sizeof(USHORT);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemLong:
                                ItemRSize = sizeof(LONG);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemULong:
                                ItemRSize = sizeof(ULONG);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemULongX:
                                ItemRSize = sizeof(ULONG);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                ptr += ItemRSize;
                                break;

                            case ItemPtr :
                                PtrFmt2 = _T("%08X%08X") ;
                                PtrFmt1 = _T("%08X") ;
                                     // goto ItemPtrCommon ;
                                     //ItemPtrCommon:
                                {
                                    ULONG ulongword2;
                                    if (PointerSize == 8) {     // 64 bits 
                                        RtlCopyMemory(&ulongword,ptr,4);
                                        RtlCopyMemory(&ulongword2,ptr+4,4);
                                        _sntprintf(ItemBuf,MAXBUFS, PtrFmt2 , ulongword2,ulongword);
                                    } else {      // assumes 32 bit otherwise
                                        RtlCopyMemory(&ulongword,ptr,PointerSize);
                                        _sntprintf(ItemBuf,MAXBUFS, PtrFmt1 , ulongword);                  
                                    }               
                                    ItemRSize = 0 ;             // Pointers are always co-erced to be strings
                                    ptr += PointerSize;
                                }
                                break;

                            case ItemIPAddr:
                                ItemRSize = 0; // Only String form exists
                                memcpy(&ulongword, ptr, sizeof(ULONG));

                                     // Convert it to readable form
                                     //
                                _sntprintf(
                                          ItemBuf, MAXBUFS,
                                          _T("%03d.%03d.%03d.%03d"),
                                          (ulongword >>  0) & 0xff,
                                          (ulongword >>  8) & 0xff,
                                          (ulongword >> 16) & 0xff,
                                          (ulongword >> 24) & 0xff);
                                ptr += sizeof (ULONG);
                                break;

                            case ItemIPV6Addr:
#define SIZEOFIPV6 16
                                ItemRSize = 0; // Only String form exists
                                {
                                    TCHAR Addr_Str[40] ;
                                    BYTE Bin6_Addr[SIZEOFIPV6] ;

                                    if (fIPV6 == 0) {       // Don't know if IPV is supported
                                        HMODULE hNTDLL = NULL ;
                                        fIPV6 = 2 ;        //Assume failure
                                        if ((hNTDLL=LoadLibraryEx(L"ntdll.dll",NULL,0)) != NULL) {
                                            if ((pRtlIpv6AddressToString=(RTLIPV6ADDRESSTOSTRING)GetProcAddress(hNTDLL,"RtlIpv6AddressToStringW")) != NULL) {
                                                fIPV6 = 1 ;    //got it
                                            }
                                        }
                                    } 
                                    // By now we know whether we have IPV6 or not
                                    if (fIPV6 == 1) {       // IPV6 is Supported
                                       memcpy(Bin6_Addr, ptr, SIZEOFIPV6);
                                       // Convert it to readable form
                                       pRtlIpv6AddressToString ((const in6_addr *)Bin6_Addr,Addr_Str);
                                       _sntprintf(ItemBuf, MAXBUFS,_T("%s"),Addr_Str);
                                    } else if (fIPV6 == 2) {      // IPV6 is not supported
                                        _sntprintf(ItemBuf, MAXBUFS,_T("Cannot decode IPV6 on this System"));
                                    }

                                    ptr += SIZEOFIPV6;
                                }
                                break;

                            case ItemMACAddr:
                                ItemRSize = 0; // Only String form exists
#define SIZEOFMAC 6 // MAC Addresses are 6 Bytes
                                {
                                    BYTE MACBuff[SIZEOFMAC + 1] =  {0} ;
                                    memcpy(MACBuff, ptr, SIZEOFMAC);

                                         // Convert it to readable form
                                         //
                                    _sntprintf(
                                              ItemBuf, MAXBUFS,
                                              _T("%02X-%02X-%02X-%02X-%02X-%02X"),
                                              MACBuff[0],MACBuff[1],MACBuff[2],MACBuff[3],MACBuff[4],MACBuff[5]);

                                    ptr += SIZEOFMAC ;
                                }
                                break;


                            case ItemPort:
                                ItemRSize = 0; // Only String form exists
                                _sntprintf(ItemBuf,MAXBUFS, _T("%u"), (UCHAR)ptr[0] * 256 + (UCHAR)ptr[1] * 1);
                                ptr += sizeof (USHORT);
                                break;

                            case ItemLongLong:
                                ItemRSize = sizeof(LONGLONG);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                _sntprintf(ItemBuf,MAXBUFS, _T("%16I64x"), *LongLongPtr);
                                ptr += sizeof(LONGLONG);
                                ItemRSize = 0; // FormatMessage cannot print 8 byte stuff properly on x86
                                break;

                            case ItemULongLong:
                                ItemRSize = sizeof(ULONGLONG);
                                RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
                                _sntprintf(ItemBuf,MAXBUFS, _T("%16I64x"), *ULongLongPtr);
                                ptr += sizeof(ULONGLONG);
                                ItemRSize = 0; // FormatMessage cannot print 8 byte stuff properly on x86
                                break;

                            case ItemString:
                            case ItemRString:
                                {
                                    SIZE_T pLen = strlen((CHAR *) ptr);
                                    if (pLen > 0) {
                                        if (pLen >= MAXBUFS) {
                                            strncpy(StrA, ptr,MAXBUFS);
                                            StrA[MAXBUFS-1] = '\0';
                                        } else {
                                            strcpy(StrA,ptr);
                                        }
                                        if (pItem->ItemType == ItemRString) {
                                            reduce(StrA);
                                        }
#ifdef UNICODE
                                        MultiByteToWideChar(CP_ACP, 0, StrA, -1, StrW, MAXBUFS);
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] =_T('\0');
#else
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%s"), StrA);
                                        ItemRBuf[MAXCHARS-1] = '\0';
#endif    /* #ifdef UNICODE */
                                    } else {
                                        _sntprintf((TCHAR *)ItemRBuf,MAXCHARS,_T("<NULL>"));
                                    }
                                    ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
                                    bItemIsString = TRUE;
                                    ptr += (pLen + 1);
                                    break;
                                }
                            case ItemRWString:
                            case ItemWString:
                                {
                                    size_t  pLen = 0;
                                    size_t     iTemp;

                                    if (*(WCHAR *) ptr) {
                                        if (pItem->ItemType == ItemRWString) {
                                            reduceW((WCHAR *) ptr);
                                        }
                                        pLen = ((wcslen((WCHAR*)ptr) + 1) * sizeof(WCHAR));
                                        if (pLen > MAXBUFS* sizeof(WCHAR)) {
                                            pLen = MAXBUFS * sizeof(WCHAR);
                                        }
                                        memcpy(StrW, ptr, pLen);
                                        for (iTemp = 0; iTemp < pLen / 2; iTemp++) {
                                            if (((USHORT) StrW[iTemp] == (USHORT) 0xFFFF)) {
                                                StrW[iTemp] = (USHORT) 0;
                                            }
                                        }

                                        StrW[pLen / 2] = StrW[(pLen / 2) + 1]= '\0';
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
                                        bItemIsString = TRUE;
                                    }
                                    ptr += pLen; // + sizeof(ULONG);

                                    break;
                                }

                            case ItemDSString:   // Counted String
                                {
                                    USHORT pLen = 256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1));
                                    ptr += sizeof(USHORT);
                                    if (pLen > MAXBUFS) {
                                        pLen = MAXBUFS;
                                    }

                                    if (pLen > 0) {

                                        memcpy(StrA, ptr, pLen);
                                        StrA[pLen] = 0 ;
#ifdef UNICODE
                                        MultiByteToWideChar(CP_ACP, 0, StrA, -1, StrW, MAXBUFS);
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');
#else
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), StrA);
                                        ItemRBuf[MAXCHARS-1] = '\0';
#endif
                                    }
                                    ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
                                    bItemIsString = TRUE;
                                    ptr += (pLen);
                                    break;
                                }

                            case ItemPString:   // Counted String
                                {
                                    SHORT pLen = ((BYTE)((char) * ptr)) + (256 * (BYTE)((char) * (ptr + 1)));
                                    ptr += sizeof(USHORT);
                                    if ((!strncmp((const char*)ptr,"NULL",4))) {
                                        ptr += 5;
                                        _sntprintf(ItemBuf,MAXBUFS, _T("<NULL>"));
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE ;
                                        break;
                                    }
                                    if (pLen > MAXBUFS) {
                                        pLen = MAXBUFS;
                                    }
                                    if ((ULONG) ((ptr+pLen) - iMofPtr) >= pEvent->MofLength) {
                                        pLen = pEvent->MofLength - (ptr -iMofPtr) ;
                                    }

                                    if (pLen > 0) {
                                        memcpy(StrA, ptr, pLen);
                                        StrA[pLen] = 0 ;
#ifdef UNICODE
                                        MultiByteToWideChar(CP_ACP, 0, StrA, -1, StrW, MAXBUFS);
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');
#else
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), StrA);
                                        ItemRBuf[MAXCHARS-1] = '\0';

#endif    /* #ifdef UNICODE */
                                    } else {
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
                                        ItemRBuf[MAXCHARS-1] = '\0';
                                    }
                                    ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
                                    bItemIsString = TRUE;
                                    ptr += (pLen);
                                    break;
                                }

                            case ItemDSWString:  // DS Counted Wide Strings
                            case ItemPWString:  // Counted Wide Strings
                                {
                                    USHORT pLen;
                                    PCHAR oriptr = ptr;

                                    ptr += sizeof(USHORT);
                                    if ( (!wcsncmp((const wchar_t*)ptr,L"NULL",4)) && (pItem->ItemType == ItemPWString)) {
                                        ptr += ((wcslen((WCHAR*)ptr) + 1) * sizeof(WCHAR));
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), L"<NULL>");
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE ;
                                        break;
                                    }

                                    pLen = ( pItem->ItemType == ItemDSWString)
                                           ? (256 * ((USHORT) * oriptr) + ((USHORT) * (oriptr + 1)))
                                           : (* ((USHORT *) oriptr));
                                    if (pLen > MAXBUFS* sizeof(WCHAR)) {
                                        pLen = MAXBUFS * sizeof(WCHAR);
                                    }
                                    if (pLen > 0) {
                                        memcpy(StrW, ptr, pLen);
                                        StrW[pLen / sizeof(WCHAR)] = L'\0';
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE;
                                    }
                                    ptr += pLen;
                                    break;
                                }

                            case ItemNWString:   // Non Null Terminated String
                                {
                                    USHORT Size;

                                    Size = (USHORT) (pEvent->MofLength -
                                                     (ULONG) (ptr - iMofPtr));
                                    if (Size > MAXBUFS) {
                                        Size = MAXBUFS;
                                    }
                                    if (Size > 0) {
                                        memcpy(StrW, ptr, Size);
                                        StrW[Size / 2] = '\0';
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE;
                                    }
                                    ptr += Size;
                                    break;
                                }

                            case ItemMLString:  // Multi Line String
                                {
                                    SIZE_T   pLen;
                                    char   * src, * dest;
                                    BOOL     inQ       = FALSE;
                                    BOOL     skip      = FALSE;
                                    UINT     lineCount = 0;

                                    ptr += sizeof(UCHAR) * 2;
                                    pLen = strlen(ptr);
                                    if (pLen > 0) {
                                        src  = ptr;
                                        dest = StrA;
                                        while (*src != '\0') {
                                            if (*src == '\n') {
                                                if (!lineCount) {
                                                    * dest ++ = ' ';
                                                }
                                                lineCount ++;
                                            } else if (*src == '\"') {
                                                if (inQ) {
                                                    char   strCount[32];
                                                    char * cpy;

                                                    sprintf(strCount, "{%dx}", lineCount);
                                                    cpy = &strCount[0];
                                                    while (*cpy != '\0') {
                                                        * dest ++ = * cpy ++;
                                                    }
                                                }
                                                inQ = !inQ;
                                            } else if (!skip) {
                                                *dest++ = *src;
                                            }
                                            skip = (lineCount > 1 && inQ);
                                            src++;
                                        }
                                        *dest = '\0';
#ifdef UNICODE
                                        MultiByteToWideChar(CP_ACP, 0, StrA, -1, StrW, MAXBUFS);
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), StrW);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');
#else
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), StrA);
                                        ItemRBuf[MAXCHARS-1] = '\0';
#endif    /* #ifdef UNICODE */
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE;
                                    }
                                    ptr += (pLen);
                                    break;
                                }

                            case ItemSid:
                                {
                                    TCHAR        UserName[64];
                                    TCHAR        Domain[64];
                                    TCHAR        FullName[256];
                                    ULONG        asize = 0;
                                    ULONG        bsize = 0;
                                    ULONG        Sid[64];
                                    PULONG       pSid = &Sid[0];
                                    SID_NAME_USE Se;
                                    ULONG        nSidLength;
                                    pSid = (PULONG) ptr;
                                    if (* pSid == 0) {
                                        ptr += 4;
                                        _sntprintf(ItemBuf,MAXBUFS, _T("<NULL>"));
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE ;
                                    } else if ((!strncmp((const char*)pSid,"NULL",4))) {
                                        ptr += 5;
                                        _sntprintf(ItemBuf,MAXBUFS, _T("<NULL>"));
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE ;
                                    } else {
                                        ptr       += 8;       // skip the TOKEN_USER structure
                                        nSidLength = 8 + (4 * ptr[1]);
                                        asize      = 64;
                                        bsize      = 64;

                                             // LookupAccountSid cannot accept asize, bsize as size_t
                                        if (LookupAccountSid(
                                                            NULL,
                                                            (PSID) ptr,
                                                            (LPTSTR) & UserName[0],
                                                            &asize,
                                                            (LPTSTR) & Domain[0],
                                                            & bsize,
                                                            & Se)) {
                                            LPTSTR pFullName = & FullName[0];

                                            _sntprintf(pFullName, 256, _T("\\\\%s\\%s"), Domain, UserName);
                                            FullName[255] = _T('\0');

                                            asize = (ULONG) _tcslen(pFullName); // Truncate here
                                            if (asize > 0) {
                                                _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), pFullName);
                                            }
                                        } else {
                                            LPTSTR sidStr;
                                            if ( ConvertSidToStringSid(pSid, &sidStr) ) {
                                                _sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%s"), sidStr);
                                            } else {
                                                _sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%s(%d)"), _T("System"), GetLastError() );
                                            }
                                        }
                                        SetLastError(ERROR_SUCCESS);
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
                                        bItemIsString = TRUE;
                                        ptr += nSidLength;
                                    }
                                    break;
                                }

                            case ItemChar4:
                                ItemRSize = 4 * sizeof(TCHAR);
                                _sntprintf(ItemBuf,MAXBUFS,
                                           _T("%c%c%c%c"),
                                           ptr[0], ptr[1], ptr[2], ptr[3]);
                                ptr += ItemRSize ;
                                _tcsncpy((LPTSTR)ItemRBuf, ItemBuf,MAXCHARS);
                                bItemIsString = TRUE;
                                break;

                            case ItemCharHidden:
                                ItemRSize = 0 ;
                                if ( EOF != _stscanf(pItem->ItemList,_T("%d"),&ItemRSize) ) {
                                    if (ItemRSize > MAXBUFS) {
                                        ItemRSize = MAXBUFS ;
                                    }
                                    RtlCopyMemory(ItemBuf,ptr,ItemRSize);
                                    ptr += ItemRSize ;
                                    _tcsncpy((LPTSTR)ItemRBuf, ItemBuf,MAXCHARS);
                                    bItemIsString = TRUE ;
                                }
                                break;

                            case ItemWChar:
                                ItemRSize = 0 ;
                                if ( EOF != _stscanf(pItem->ItemList,_T("%d"),&ItemRSize) ) {
                                    if (ItemRSize > MAXBUFS/sizeof(WCHAR)) {
                                        ItemRSize = MAXBUFS/sizeof(WCHAR) ;
                                    }
                                    RtlCopyMemory(ItemBuf,ptr,ItemRSize*sizeof(WCHAR));
                                    ptr += ItemRSize*sizeof(WCHAR) ;
                                    _tcsncpy((LPTSTR)ItemRBuf, ItemBuf,MAXCHARS);
                                    bItemIsString = TRUE ;
                                }
                                break;

                            case ItemSetByte:
                                ItemRSize = sizeof(BYTE);
                                goto ItemSetCommon;

                            case ItemSetShort:
                                ItemRSize = sizeof(USHORT);
                                goto ItemSetCommon;

                            case ItemSetLong:
                                ItemRSize = sizeof(ULONG);
                                     // goto ItemSetCommon;

                                ItemSetCommon:
                                {
                                    TCHAR * name;
                                    ULONG   Countr    = 0;
                                    ULONG   ItemMask = 0;
                                    BOOL first = TRUE;

                                    RtlCopyMemory(&ItemMask, ptr, ItemRSize);
                                    RtlZeroMemory(IList, MAXBUFS * sizeof(TCHAR));
                                    ptr += ItemRSize;

                                    _tcscpy(ItemBuf, _T("["));
                                    _sntprintf(IList, MAXBUFS,_T("%s"), pItem->ItemList);
                                    name = _tcstok(IList, _T(","));
                                    while ( name != NULL ) {
                                             // While there are tokens in "string"
                                             //
                                        if (ItemMask & (1 << Countr) ) {
                                            if (!first) _tcscat(ItemBuf, _T(","));
                                            _tcscat(ItemBuf, name); first = FALSE;
                                        }
                                             // Get next token:
                                             //
                                        name = _tcstok( NULL, _T(","));
                                        Countr++;
                                    }
                                    while (Countr < ItemRSize * 8) {
                                        if (ItemMask & (1 << Countr) ) {
                                            TCHAR smallBuf[20];
                                            EtwpConvertUnsignedInt(smallBuf,
                                                                   Countr,
                                                                   20
                                                                  );

                                            if (!first) _tcscat(ItemBuf, _T(","));
                                            _tcscat(ItemBuf, smallBuf); first = FALSE;
                                        }
                                        Countr++;
                                    }
                                    _tcscat(ItemBuf, _T("]") );
                                    ItemRSize = 0; // Strings will be the same Raw and otherwise
                                }
                                break;

                            case ItemListByte:
                                ItemRSize = sizeof(BYTE);
                                goto ItemListCommon;

                            case ItemListShort:
                                ItemRSize = sizeof(USHORT);
                                goto ItemListCommon;

                            case ItemListLong:
                                ItemRSize = sizeof(ULONG);
                                     // goto ItemListCommon;

                                ItemListCommon:
                                {
                                    TCHAR * name;
                                    ULONG   Countr    = 0;
                                    ULONG   ItemIndex = 0;

                                    RtlCopyMemory(&ItemIndex, ptr, ItemRSize);
                                    RtlZeroMemory(IList, MAXBUFS * sizeof(TCHAR));
                                    ptr += ItemRSize;
                                    ItemRSize = 0; // Strings will be the same Raw and otherwise

                                    _sntprintf(ItemBuf,MAXBUFS, _T("!%X!"),ItemIndex);
                                    _sntprintf(IList, MAXBUFS, _T("%s"), pItem->ItemList);
                                    name = _tcstok(IList, _T(","));
                                    while ( name != NULL ) {
                                             // While there are tokens in "string"
                                             //
                                        if (ItemIndex == Countr ++) {
                                            _sntprintf(ItemBuf,MAXBUFS, _T("%s"), name);
                                            break;
                                        }
                                             // Get next token:
                                             //
                                        name = _tcstok( NULL, _T(","));
                                    }
                                }
                                break;

                            case ItemNTerror:
                                ItemRSize = 0; // Only string form exists
                                RtlCopyMemory(ItemRBuf, ptr, sizeof(ULONG));
                                ptr += sizeof(ULONG);
                                     // Translate the NT Error Message
                                if ((FormatMessage(
                                                  FORMAT_MESSAGE_FROM_SYSTEM |
                                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                                  NULL,
                                                  *ULongPtr,
                                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                                  ItemBuf,
                                                  MAXBUFS,
                                                  NULL )) == 0) {

                                    _sntprintf(ItemBuf,MAXBUFS,_T("!NT Error %u unrecognised!"),*ULongPtr);
                                }
                                break;

                            case ItemMerror:
                                ItemRSize = 0; // Only string form exists
                                RtlCopyMemory(ItemRBuf, ptr, sizeof(ULONG));
                                ptr += sizeof(ULONG);
                                     // Translate the Module Message
                                if (pItem->ItemList == NULL) {
                                    _sntprintf(ItemBuf,MAXBUFS,_T("! Error %u No Module Name!"),*ULongPtr);
                                } else {
                                    if ((hLibrary = LoadLibraryEx(
                                                                 pItem->ItemList,    // file name of module
                                                                 NULL,               // reserved, must be NULL
                                                                 LOAD_LIBRARY_AS_DATAFILE // entry-point execution flag
                                                                 )) == NULL) {
                                        _sntprintf(ItemBuf,MAXBUFS,_T("!ItemMerror %u : LoadLibrary of %s failed %d!"),
                                                   *ULongPtr,
                                                   pItem->ItemList,
                                                   GetLastError());
                                    } else {
                                        if ((FormatMessage(
                                                          FORMAT_MESSAGE_FROM_HMODULE |
                                                          FORMAT_MESSAGE_FROM_SYSTEM |
                                                          FORMAT_MESSAGE_IGNORE_INSERTS,
                                                          hLibrary,
                                                          *ULongPtr,
                                                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                                          ItemBuf,
                                                          MAXBUFS,
                                                          NULL )) == 0) {
                                            _sntprintf(ItemBuf,MAXBUFS,_T("!Module Error %u unrecognised!"),*ULongPtr);
                                        }
                                        if (!FreeLibrary((HMODULE) hLibrary)) {
                                            _sntprintf(ItemBuf,MAXBUFS,_T("Failed to free library (%s) handle, err = %d"),
                                                       pItem->ItemList, GetLastError());
                                        }
                                    }
                                }
                                break;

                            case ItemHRESULT:
                                {
                                    NTSTATUS TempNTSTATUS, Error ;
                                    ItemRSize = 0 ;
                                    RtlCopyMemory(&TempNTSTATUS, ptr, sizeof(NTSTATUS));
                                    ptr += sizeof(ULONG);
                                    Error = TempNTSTATUS;
                                    if (TempNTSTATUS == 0) { // Special case STATUS_SUCCESS just like everyone else!
                                        _sntprintf(ItemBuf,MAXBUFS,_T("S_OK"));
                                    } else {
                                        const ERROR_MAP* map = (ERROR_MAP*)winerrorSymbolicNames;

                                        _sntprintf(ItemBuf,MAXBUFS,_T("HRESULT=%8X"),TempNTSTATUS);
                                        if ( FACILITY_NT_BIT & TempNTSTATUS ) {
                                            map =  (ERROR_MAP*)ntstatusSymbolicNames;
                                            Error &= ~FACILITY_NT_BIT;
                                        } else if (HRESULT_FACILITY(Error) == FACILITY_WIN32) {
                                            Error &= 0xFFFF;
                                        }
                                        while (map->MessageId != 0xFFFFFFFF) {
                                            if (map->MessageId == Error) {
                                                _sntprintf(ItemBuf,MAXBUFS,_T("0x%08x(%S)"), TempNTSTATUS, map->SymbolicName);
                                                break;
                                            }
                                            ++map;
                                        }
                                    }
                                }
                                break;

                            case ItemNTSTATUS:
                                {
                                    int iTemp = 0 ;
                                    NTSTATUS TempNTSTATUS ;
                                    ItemRSize = 0 ;
                                    RtlCopyMemory(&TempNTSTATUS, ptr, sizeof(NTSTATUS));
                                    ptr += sizeof(ULONG);
                                    if (TempNTSTATUS == 0) { // Special case STATUS_SUCCESS just like everyone else!
                                        _sntprintf(ItemBuf,MAXBUFS,_T("STATUS_SUCCESS"));
                                    } else {
                                        _sntprintf(ItemBuf,MAXBUFS,_T("NTSTATUS=%8X"),TempNTSTATUS);
                                        while (ntstatusSymbolicNames[iTemp].MessageId != 0xFFFFFFFF) {
                                            if (ntstatusSymbolicNames[iTemp].MessageId == TempNTSTATUS) {
                                                _sntprintf(ItemBuf,MAXBUFS,_T("0x%08x(%S)"), TempNTSTATUS, ntstatusSymbolicNames[iTemp].SymbolicName);
                                                break;
                                            }
                                            iTemp++ ;
                                        }
                                    }
                                }
                                break;

                            case ItemWINERROR:
                                {
                                    int iTemp = 0 ;
                                    DWORD TempWINERROR ;
                                    ItemRSize = 0 ;
                                    RtlCopyMemory(&TempWINERROR, ptr, sizeof(DWORD));
                                    ptr += sizeof(ULONG);
                                    _sntprintf(ItemBuf,MAXBUFS,_T("WINERROR=%8X"),TempWINERROR);
                                    while (winerrorSymbolicNames[iTemp].MessageId != 0xFFFFFFFF) {
                                        if (winerrorSymbolicNames[iTemp].MessageId == TempWINERROR) {
                                            _sntprintf(ItemBuf,MAXBUFS,_T("%d(%S)"), TempWINERROR, winerrorSymbolicNames[iTemp].SymbolicName);
                                            break;
                                        }
                                        iTemp++ ;
                                    }
                                }
                                break;


                            case ItemNETEVENT:
                                {
                                    int iTemp = 0 ;
                                    DWORD TempNETEVENT ;
                                    ItemRSize = 0 ;
                                    RtlCopyMemory(&TempNETEVENT, ptr, sizeof(DWORD));
                                    ptr += sizeof(ULONG);
                                    _sntprintf(ItemBuf,MAXBUFS,_T("NETEVENT=%8X"),TempNETEVENT);
                                    while (neteventSymbolicNames[iTemp].MessageId != 0xFFFFFFFF) {
                                        if (neteventSymbolicNames[iTemp].MessageId == TempNETEVENT) {
                                            _sntprintf(ItemBuf,MAXBUFS,_T("%S"), neteventSymbolicNames[iTemp].SymbolicName);
                                            break;
                                        }
                                        iTemp++ ;
                                    }
                                }
                                break;

                            case ItemGuid:
                                GuidToString(ItemBuf, (LPGUID) ptr);
                                ItemRSize = 0; // Only string form exists
                                ptr += sizeof(GUID);
                                break;

                            case ItemTimeDelta:
                                {
                                    LONGLONG time;
                                    RtlCopyMemory(&time, ptr, sizeof(time));

                                    FormatTimeDelta(ItemBuf, MAXBUFS, time);

                                    ItemRSize = 0; // Only string form exists
                                    ptr += sizeof(LONGLONG);
                                }
                                break;

                            case ItemWaitTime:
                                {
                                    LONGLONG time;
                                    RtlCopyMemory(&time, ptr, sizeof(time));

                                    if (time <= 0) {
                                        time = -time;
                                        ItemBuf[0]='+';
                                        FormatTimeDelta(ItemBuf+1, MAXBUFS-1, time);
                                        ItemRSize = 0; // Only string form exists
                                        ptr += sizeof(LONGLONG);
                                        break;
                                    }
                                         // Fall thru
                                }
                            case ItemTimestamp:
                                {
                                    LARGE_INTEGER LargeTmp;
                                    FILETIME      stdTime, localTime;
                                    SYSTEMTIME    sysTime;

                                    RtlCopyMemory(&LargeTmp, ptr, sizeof(ULONGLONG));
                                    stdTime.dwHighDateTime = LargeTmp.HighPart;
                                    stdTime.dwLowDateTime  = LargeTmp.LowPart;
                                    if (!FileTimeToLocalFileTime(&stdTime, &localTime)) {
                                        _sntprintf(ItemBuf,MAXBUFS,_T("FileTimeToLocalFileTime error 0x%8X\n"),GetLastError());
                                        break;
                                    }
                                    if (!FileTimeToSystemTime(&localTime, &sysTime)) {
                                        _sntprintf(ItemBuf,MAXBUFS,_T("FileTimeToSystemTime error 0x%8X\n"),GetLastError());
                                        break;
                                    }

                                    EtwpConvertTimeStamp(ItemBuf,
                                                         sysTime,
                                                         MAXBUFS
                                                        );

                                }
                                ItemRSize = 0; // Only string form exists
                                ptr += sizeof(ULONGLONG);

                                break;
                                     // Dump an arbitrary block of data in Hex
                            case ItemHexDump:

                                {   USHORT hLen = ((char) * ptr) + (256 * ((char) * (ptr + 1)));

                                    ptr += sizeof(USHORT);
                                    if ((!strncmp((const char*)ptr,"NULL",4))) {
                                        ptr += 5;
                                        _sntprintf(ItemBuf,MAXBUFS, _T("<NULL>"));
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
                                        ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
                                        bItemIsString = TRUE ;
                                        break;
                                    }
                                    if (hLen > MAXHEXDUMP) {
                                        hLen = MAXHEXDUMP;
                                    }

                                    if (hLen > 0) {

#define MAXHEXBUFF  8
                                        TCHAR HexBuff[MAXHEXBUFF+1] ; // "XX "
                                        BYTE  StrX[MAXHEXDUMP +1] ;

                                        memcpy(StrX, ptr, hLen);
                                        StrX[hLen] = 0 ;
                                        *ItemRBuf = _T('\0');

                                        for (i=0 ; i < hLen; i++) {
                                            if ((i & 0xF)== 0) {
                                                _sntprintf((TCHAR *)HexBuff, MAXHEXBUFF,_T("\n\t"));
                                                _tcsncat((TCHAR *)ItemRBuf,HexBuff, MAXCHARS);
                                            }

                                            _sntprintf((TCHAR *)HexBuff,MAXHEXBUFF,_T("%02X "),StrX[i]);
                                            _tcsncat((TCHAR *)ItemRBuf,HexBuff, MAXCHARS);
                                        }
                                        _sntprintf((TCHAR *)HexBuff, MAXHEXBUFF,_T("\n\t"));
                                        _tcsncat((TCHAR *)ItemRBuf,HexBuff, MAXCHARS);
                                        ((TCHAR*)ItemRBuf)[MAXCHARS-1] = _T('\0');

                                    } else {
                                        _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
                                        ItemRBuf[MAXCHARS-1] = '\0';
                                    }
                                    ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
                                    bItemIsString = TRUE;
                                    ptr += (hLen);
                                }

                                break;


                            default:
                                ptr += sizeof (int);
                            } // switch (pItem->ItemType)


                            if (ItemRSize == 0) {
                                     // Raw and String are the same
                                memcpy(pItemBuf[iItemCount],
                                       ItemBuf,
                                       min(wcslen(ItemBuf)+1, ItemBBufEnd - pItemBuf[iItemCount])*sizeof(WCHAR)
                                      );

                                pItemBuf[iItemCount + 1] = pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1; 

                                pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount];
                            } else {
                                if (ItemRSize > MAXBUFS) {
                                    ItemRSize = MAXBUFS ;
                                }
                                pItemRBuf[iItemCount] = pItemRBuf[iItemCount+1] = 0 ; 
                                pItemBuf[iItemCount+1] = pItemBuf[iItemCount];
                                if (!bItemIsString) {
                                    RtlCopyMemory(&pItemRBuf[iItemCount],ItemRBuf,ItemRSize);
                                } else {
                                         // Share scratch buffer
                                    if (ItemRSize < sizeof(WCHAR) * (ItemBBufEnd - pItemBuf[iItemCount])) {
                                        pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount] ;
                                        RtlCopyMemory(pItemRBuf[iItemCount], ItemRBuf, ItemRSize + sizeof(WCHAR));
                                        pItemBuf[iItemCount+1] =(TCHAR *)pItemRBuf[iItemCount] + 
                                                                ItemRSize/sizeof(WCHAR) + 
                                                                1; 

                                    } else {
                                        pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount];
                                    }
                                }
                            }

                            iItemCount ++;
                            Next = Next->Flink;

                        } // while (Head != Next)
                             // Ok we are finished with the MofData
                             //
                        free(iMofPtr);
                    } // if (Head!= Next)
                } // try
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    TCHAR * Buffer = EventBuf ;
                    DWORD BufferSize = SizeEventBuf ; 
                    if (bStructuredFormat) {
                        Buffer = (TCHAR *)pStructuredOffset;
                        BufferSize -= DWORD((pStructuredOffset - (ULONG_PTR)pStructuredMessage) & 0xFFFFFFFF);
                        pStructuredMessage->FormattedString = pStructuredOffset - (ULONG_PTR)pStructuredMessage ;
                    }
                    _sntprintf(Buffer, 
                               BufferSize,
                               _T("\n*****FormatMessage %s(%s) of %s, parameter %d raised an exception*****\n"),
                               tstrName,
                               tstrType,
                               tstrFormat,
                               iItemCount);
                    if (iMofPtr) free(iMofPtr);
                    if (!bStructuredFormat) {
                        return( (SIZE_T)_tcslen(EventBuf));
                    } else {
                        return(pStructuredOffset - (ULONG_PTR)pStructuredMessage + _tcslen((TCHAR *) &pStructuredMessage + pStructuredMessage->FormattedString));
                    }
                }
            } // else condition for if(!bManagedTracingEnabled && bCSharpEvent)



#ifdef MANAGED_TRACING
        }//else condition for if (bCSharpEvent)
#endif
    }

    // All argument processing is complete
    // No prepare the final formatting.

    if ((tstrFormat == NULL) || (tstrFormat[0] == 0)) {
        TCHAR GuidString[32] ;
        // Build a helpful format


        if (!IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid) ) {
            GuidToString(GuidString, (LPGUID) &pEvent->Header.Guid);
            TCHAR * Buffer = EventBuf ;
            DWORD BufferSize = SizeEventBuf ; 
            if (bStructuredFormat) {
                Buffer = (TCHAR *)pStructuredOffset;
                BufferSize -= DWORD((pStructuredOffset - (ULONG_PTR)pStructuredMessage) & 0xFFFFFFFF);
                pStructuredMessage->FormattedString = pStructuredOffset - (ULONG_PTR)pStructuredMessage ;
            }
            _sntprintf(Buffer, 
                       BufferSize,
                       _T("%s(%s): GUID=%s (No Format Information found)."),
                       pItemBuf[0],      // name if any 
                       pItemBuf[1],      // sub name or number
                       GuidString       // GUID
                      );
        } else {
            // Display nothing for a header for now
            // Might be a good place to display some general info ?
        }
    } else {
        DWORD dwResult;
        TCHAR * TBuffer = EventBuf ;
        DWORD TBufferSize = SizeEventBuf ;

        if (tstrTypeOfType == 2) {


            if (pItemBuf[iItemCount] < ItemBBufEnd) {
                *( pItemBuf[iItemCount] ) = 0; 

            } else {
                ItemBBuf[MAXBUFS2 - 1] = 0; 
            }
            if (bStructuredFormat) {
                TBuffer = (TCHAR *)pStructuredOffset;
                TBufferSize -= DWORD((pStructuredOffset - (ULONG_PTR)pStructuredMessage) & 0xFFFFFFFF);
                pStructuredMessage->FormattedString = pStructuredOffset - (ULONG_PTR)pStructuredMessage ;
            }


            __try
            {
                ULONG ReturnLength ;
                dwResult = (DWORD)TraceFormatMessage(
                                                    tstrFormat,             // message format
                                                    0,
                                                    FALSE,                   // Don't ignore inserts,
#if defined(UNICODE)
                                                    FALSE,                   // Arguments Are not Ansi,
#else // #if defined(UNICODE)
                                                    TRUE,                    // Arguments are Ansi
#endif // #if defined(UNICODE)
                                                    TRUE,                    // Arguments Are An Array,
                                                    (va_list *) pItemRBuf,   // Arguments,
                                                    TBuffer,                  // Buffer,
                                                    TBufferSize,              // maximum size of message buffer
                                                    &ReturnLength            // Coutnof Data Returned
                                                    );
                if (ReturnLength == 0) {
                    TCHAR * LBuffer = EventBuf ;
                    DWORD LBufferSize = SizeEventBuf ; 
                    if (bStructuredFormat) {
                        LBuffer = (TCHAR *)pStructuredOffset;
                        LBufferSize -= DWORD((pStructuredOffset - (ULONG_PTR)pStructuredMessage) & 0xFFFFFFFF);
                        pStructuredMessage->FormattedString = pStructuredOffset - (ULONG_PTR)pStructuredMessage ;
                    }
                    _sntprintf(LBuffer, 
                               LBufferSize,
                              _T("FormatMessage (#Typev) Failed 0x%X (%s/%s) (\n"),
                              dwResult,
                              pItemBuf[0],
                              pItemBuf[1]);
                    if (!bStructuredFormat) {
                        return( (SIZE_T)_tcslen(EventBuf));
                    } else {
                        return(pStructuredOffset - (ULONG_PTR)pStructuredMessage + _tcslen((TCHAR *) &pStructuredMessage + pStructuredMessage->FormattedString));
                    }
                } else {

                }
#ifdef MANAGED_TRACING
                //Need to free memory, if allocated before the call to DecodeTraceMessage
                if (ptCSFormattedMessage != NULL && ptCSFormattedMessage != ItemBuf) {
                    free(ptCSFormattedMessage);
                    ptCSFormattedMessage = NULL;
                }
#endif
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                TCHAR * EBuffer = EventBuf ;
                DWORD EBufferSize = SizeEventBuf ; 
                if (bStructuredFormat) {
                    EBuffer = (TCHAR *)pStructuredOffset;
                    EBufferSize -= DWORD((pStructuredOffset - (ULONG_PTR)pStructuredMessage) & 0xFFFFFFFF);
                    pStructuredMessage->FormattedString = pStructuredOffset - (ULONG_PTR)pStructuredMessage ;
                }
                _sntprintf(EBuffer, 
                           EBufferSize,
                            _T("\n*****FormatMessage (#Typev) raised an exception (Format = %s) ****\n**** [Check for missing \"!\" Formats]*****\n"), tstrFormat);
                if (!bStructuredFormat) {
                    return( (SIZE_T)_tcslen(EventBuf));
                } else {
                    return(pStructuredOffset - (ULONG_PTR)pStructuredMessage + _tcslen((TCHAR *) &pStructuredMessage + pStructuredMessage->FormattedString));
                }
            }
        } else {
            return(-12);
        }
    }

    if (pszMask != NULL) {
        // Has he imposed a Filter?
        //
        if (_tcsstr(_tcslwr(pszMask), _tcslwr(tstrName)) !=0) {
            if (!bStructuredFormat) {
                return( (SIZE_T)_tcslen(EventBuf));
            } else {
                return(pStructuredOffset - (ULONG_PTR)pStructuredMessage + _tcslen((TCHAR *) &pStructuredMessage + pStructuredMessage->FormattedString));
            }
        } else {
            return(0);
        }
    }

    if (!bStructuredFormat) {
        return( (SIZE_T)_tcslen(EventBuf));
    } else {
        return(pStructuredOffset - (ULONG_PTR)pStructuredMessage + _tcslen((TCHAR *) &pStructuredMessage + pStructuredMessage->FormattedString));
    }
}



PMOF_INFO
GetMofInfoHead(
              PLIST_ENTRY * HeadEventList,
              LPGUID        pGuid,
              LPTSTR        strType,
              LONG          TypeIndex,
              ULONG         TypeOfType,
              LPTSTR        TypeFormat,
              BOOL          bBestMatch
              )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;
    TCHAR       *p;
    DWORD       Status;

    // Search the eventList for this Guid and find the head
    //
    if (HeadEventList == NULL) {
        return NULL ;
    }
    if (*HeadEventList == NULL) {
        if ( (*HeadEventList = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY))) == NULL)
            return NULL;

        RtlZeroMemory(*HeadEventList, sizeof(LIST_ENTRY));
        InitializeListHead(*HeadEventList);
    }

    // Traverse the list and look for the Mof info head for this Guid.
    //
    Head = *HeadEventList;
    Next = Head->Flink;
    if (bBestMatch) {
        PMOF_INFO pBestMatch = NULL;

        while (Head != Next) {
            pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
            if (IsEqualGUID(&pMofInfo->Guid, pGuid)) {
                if (pMofInfo->TypeIndex == TypeIndex) {
                    return  pMofInfo;
                } else if (pMofInfo->strType == NULL) {
                    pBestMatch = pMofInfo;
                }
            }
            Next = Next->Flink;
        }
        if (pBestMatch != NULL) {
            return pBestMatch;
        }
    } else {
        while (Head != Next) {
            pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);

            if (   (strType != NULL)
                   && (pMofInfo->strType != NULL)
                   && (IsEqualGUID(&pMofInfo->Guid, pGuid))
                   && (!(_tcscmp(strType, pMofInfo->strType)))) {
                return  pMofInfo;
            } else if (   (strType == NULL)
                          && (pMofInfo->strType == NULL)
                          && (IsEqualGUID(&pMofInfo->Guid, pGuid))) {
                return  pMofInfo;
            }
            Next = Next->Flink;
        }
    }

    // If One does not exist, create one.
    //
    if ( (pMofInfo = (PMOF_INFO) malloc(sizeof(MOF_INFO))) == NULL) {
        return NULL;
    }
    RtlZeroMemory(pMofInfo, sizeof(MOF_INFO));
    memcpy(&pMofInfo->Guid, pGuid, sizeof(GUID));
    pMofInfo->ItemHeader = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
    if ( pMofInfo->ItemHeader == NULL) {
        free(pMofInfo);
        return NULL;
    }
    RtlZeroMemory(pMofInfo->ItemHeader, sizeof(LIST_ENTRY));
    if (strType != NULL) {
        if ((pMofInfo->strType = (LPTSTR) malloc((_tcslen(strType) + 1) * sizeof(TCHAR))) == NULL ) {
            free(pMofInfo->ItemHeader);
            free(pMofInfo);
            return NULL ;
        }
        _tcscpy(pMofInfo->strType,strType);
    }
    if (TypeOfType != 0) {
        pMofInfo->TypeOfType = TypeOfType;
    }
    if (TypeFormat != NULL) {
        if ((pMofInfo->TypeFormat =
             (LPTSTR) malloc((_tcslen(TypeFormat) + 1) * sizeof(TCHAR)))== NULL) {
            free(pMofInfo->strType);
            free(pMofInfo->ItemHeader);
            free(pMofInfo);
            return NULL ;
        }
        _tcscpy(pMofInfo->TypeFormat,TypeFormat);

    }

    p = pMofInfo->TypeFormat;
    if (p) {
        while (*p != 0) {
            if (*p == 'Z' && p > (pMofInfo->TypeFormat) && p[-1] == '!' && p[1] == '!') {
                *p = 's';
            }
            ++p;
        }
    }

    pMofInfo->TypeIndex = bBestMatch ? -1 : TypeIndex;
    InitializeListHead(pMofInfo->ItemHeader);
    InsertTailList(*HeadEventList, &pMofInfo->Entry);

    Status = InsertFmtInfoSet(pMofInfo);
    if (Status == ERROR_OUTOFMEMORY) {
        return NULL;
    }

    return pMofInfo;
}   // GetMofInfoHead()



DWORD
LoadGuidFile(OUT PLIST_ENTRY *HeadEventList,
             IN  LPGUID      pGuid
            )

             /*++

             Routine Description:

             Load GUID file specified by pGuid, and insert event description into
             HeadEventList.

             Arguments:


             Return Value:

             ERROR_SUCCESS            if succeeded,
             ERROR_BAD_FORMAT         obselete format used, 
             ERROR_PATH_NOT_FOUND     other failures. 

             Notes:


             --*/
{
    TCHAR filename[MAX_PATH], filepath[MAX_PATH];
    LPTSTR lpFilePart ;
    LPTSTR lppath = NULL;
    INT len, waslen = 0 ;
    DWORD Status = ERROR_PATH_NOT_FOUND;

    if (gTraceFormatSearchPath != NULL) {

        //a trace path has been assigned, so use it instead of the environment variable
        lppath = (LPTSTR)malloc((_tcslen(gTraceFormatSearchPath)+1) * sizeof(TCHAR));
        if (lppath != NULL) {
            _tcscpy(lppath, gTraceFormatSearchPath);
        }
    }

    if (lppath == NULL) {
        //no path passed in, so get it off the environment variable
        while (((len = GetEnvironmentVariable(TRACE_FORMAT_SEARCH_PATH, lppath, waslen )) - waslen) > 0) {
            if (len - waslen > 0 ) {
                if (lppath != NULL) {
                    free(lppath);
                }
                if ( !(lppath = (LPTSTR) malloc((len+1) * sizeof(TCHAR)) ) ) {
                    break;
                }

                waslen = len ;
            }
        }
    }

    if (lppath != NULL) {
        // Try to find it on the path //
        swprintf(filename,L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x.tmf",
                 pGuid->Data1,pGuid->Data2,pGuid->Data3,
                 pGuid->Data4[0],pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                 pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],pGuid->Data4[7] );

        if ((len = SearchPath(
                             lppath,        // search path semi-colon seperated
                             filename,      // file name with extension
                             NULL,          // file extension (not reqd.)
                             MAX_PATH,      // size of buffer
                             filepath,      // found file name buffer
                             &lpFilePart    // file component
                             ) !=0) && (len <= MAX_PATH)) {
                //_tprintf(_T("Opening file %s\n"),filepath);

            Status = GetTraceGuidsW(filepath, HeadEventList);
        }

        free(lppath);

    }

    return Status;

} // LoadGuidFile()


void
MapGuidToName(
             OUT PLIST_ENTRY *HeadEventList,
             IN  LPGUID      pGuid,
             IN  ULONG       nType,
             OUT LPTSTR      wstr
             )
{
    if (IsEqualGUID(pGuid, &EventTraceGuid)) {
        _tcscpy(wstr, GUID_TYPE_HEADER);
    } else if (!UserDefinedGuid(*HeadEventList,pGuid, wstr)) {
        BOOL Success;

        Success = LoadGuidFile(HeadEventList, pGuid);
        if (Success) {
            if (!UserDefinedGuid(*HeadEventList,pGuid, wstr)) {
                _tcscpy(wstr, GUID_TYPE_UNKNOWN);
            }
            return;
        }
    }
}

ULONG
UserDefinedGuid(
               OUT PLIST_ENTRY HeadEventList,
               IN  LPGUID      pGuid,
               OUT LPTSTR      wstr
               )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;

    // Search the eventList for this Guid and find the head
    //
    if (HeadEventList == NULL) {
        /*
        HeadEventList = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
        if(HeadEventList == NULL)
        return FALSE; 

        InitializeListHead(HeadEventList); */
        return FALSE; 
    }

    // Traverse the list and look for the Mof info head for this Guid.
    //
    Head = HeadEventList;
    Next = Head->Flink;
    while (Head  != Next && Next != NULL) {

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        if (pMofInfo != NULL && IsEqualGUID(&pMofInfo->Guid, pGuid)) {
            if ( pMofInfo->strDescription == NULL) {
                return FALSE;
            } else {
                _tcscpy(wstr, pMofInfo->strDescription);
                return TRUE;
            }
        }
        Next = Next->Flink;
    }
    return FALSE;
}

ULONG
WINAPI
GetTraceGuidsW(
              TCHAR       * GuidFile,
              PLIST_ENTRY * HeadEventList )
{
    FILE     * f=NULL;
    TCHAR      line[MAXSTR],
    nextline[MAXSTR],
    arg[MAXSTR],
    strGuid[MAXSTR];
    PMOF_TYPE  types;
    LPGUID     Guid;
    UINT       i,
    n;
    TCHAR    * name,
    * s,
    * guidName;
    PMOF_INFO  pMofInfo;
    SIZE_T     len       = 0;
    UINT       typeCount = 0;
    BOOL inInfo = FALSE;
    BOOL eof = FALSE ;
    BOOL nextlineF = FALSE ;

    if (HeadEventList == NULL) {
        return 0 ;
    }
    if (*HeadEventList == NULL) {
        if ( (*HeadEventList = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY))) == NULL)
            return 0 ;

        RtlZeroMemory(*HeadEventList, sizeof(LIST_ENTRY));
        InitializeListHead(*HeadEventList);
    }

    Guid = (LPGUID) malloc(sizeof(GUID));
    if (Guid == NULL) {
        return 0;
    }

    types = (PMOF_TYPE) malloc(MAXTYPE * sizeof(MOF_TYPE));
    if (types == NULL) {
        free(Guid);
        return 0;
    }

    RtlZeroMemory(types,   MAXTYPE * sizeof(MOF_TYPE));
    RtlZeroMemory(line,    MAXSTR  * sizeof(TCHAR));
    RtlZeroMemory(strGuid, MAXSTR  * sizeof(TCHAR));


    f = _tfopen( GuidFile, _T("r"));
    if (f == NULL) {
        free(Guid);
        free(types);
        return 0;
    }
    n = 0;

    while (!eof ) {
        if (nextlineF) { // Sometimes we read ahead a bit
            _tcscpy(line, nextline);
            nextlineF = FALSE ;
        } else {
            if (_fgetts(line, MAXSTR, f) == NULL) {
                eof = TRUE ;
                break;
            }
        }
        line[MAXSTR-1] = _T('\0');
        //    jump_inside:;
        if (line[0] == '/') {
            continue;
        } else if (line[0] == '{') {
            inInfo = TRUE;
        } else if ( line[0] == '}') {
            typeCount = 0;
            inInfo = FALSE;
        } else if (inInfo) {
            ITEM_TYPE   type;
            PTCHAR      ItemListValue = NULL;

            name = _tcstok(line, _T("\n\t,"));
            s    = _tcstok(NULL, _T(" \n\t,(["));
            if (s != NULL && name != NULL ) {
                if (!_tcsicmp(s,STR_ItemChar))           type = ItemChar;
                else if (!_tcsicmp(s,STR_ItemUChar))     type = ItemUChar;
                else if (!_tcsicmp(s,STR_ItemCharShort)) type = ItemCharShort;
                else if (!_tcsicmp(s,STR_ItemCharSign))  type = ItemCharSign;
                else if (!_tcsicmp(s,STR_ItemShort))     type = ItemShort;
                else if (!_tcsicmp(s,STR_ItemHRESULT))   type = ItemHRESULT;
                else if (!_tcsicmp(s,STR_ItemDouble))    type = ItemDouble;
                else if (!_tcsicmp(s,STR_ItemUShort))    type = ItemUShort;
                else if (!_tcsicmp(s,STR_ItemLong))      type = ItemLong;
                else if (!_tcsicmp(s,STR_ItemULong))     type = ItemULong;
                else if (!_tcsicmp(s,STR_ItemULongX))    type = ItemULongX;
                else if (!_tcsicmp(s,STR_ItemLongLong))  type = ItemLongLong;
                else if (!_tcsicmp(s,STR_ItemULongLong)) type = ItemULongLong;
                else if (!_tcsicmp(s,STR_ItemString))    type = ItemString;
                else if (!_tcsicmp(s,STR_ItemWString))   type = ItemWString;
                else if (!_tcsicmp(s,STR_ItemRString))   type = ItemRString;
                else if (!_tcsicmp(s,STR_ItemRWString))  type = ItemRWString;
                else if (!_tcsicmp(s,STR_ItemPString))   type = ItemPString;
                else if (!_tcsicmp(s,STR_ItemMLString))  type = ItemMLString;
                else if (!_tcsicmp(s,STR_ItemNWString))  type = ItemNWString;
                else if (!_tcsicmp(s,STR_ItemPWString))  type = ItemPWString;
                else if (!_tcsicmp(s,STR_ItemDSString))  type = ItemDSString;
                else if (!_tcsicmp(s,STR_ItemDSWString)) type = ItemDSWString;
                else if (!_tcsicmp(s,STR_ItemPtr))       type = ItemPtr;
                else if (!_tcsicmp(s,STR_ItemSid))       type = ItemSid;
                else if (!_tcsicmp(s,STR_ItemChar4))     type = ItemChar4;
                else if (!_tcsicmp(s,STR_ItemIPAddr))    type = ItemIPAddr;
                else if (!_tcsicmp(s,STR_ItemIPV6Addr))    type = ItemIPV6Addr;
                else if (!_tcsicmp(s,STR_ItemMACAddr))    type = ItemMACAddr;
                else if (!_tcsicmp(s,STR_ItemPort))      type = ItemPort;
                else if (!_tcsicmp(s,STR_ItemListLong))  type = ItemListLong;
                else if (!_tcsicmp(s,STR_ItemListShort)) type = ItemListShort;
                else if (!_tcsicmp(s,STR_ItemListByte))  type = ItemListByte;
                else if (!_tcsicmp(s,STR_ItemSetLong))  type = ItemSetLong;
                else if (!_tcsicmp(s,STR_ItemSetShort)) type = ItemSetShort;
                else if (!_tcsicmp(s,STR_ItemSetByte))  type = ItemSetByte;
                else if (!_tcsicmp(s,STR_ItemNTerror))   type = ItemNTerror;
                else if (!_tcsicmp(s,STR_ItemMerror))    type = ItemMerror;
                else if (!_tcsicmp(s,STR_ItemTimestamp)) type = ItemTimestamp;
                else if (!_tcsicmp(s,STR_ItemGuid))      type = ItemGuid;
                else if (!_tcsicmp(s,STR_ItemWaitTime)) type = ItemWaitTime;
                else if (!_tcsicmp(s,STR_ItemTimeDelta))      type = ItemTimeDelta;
                else if (!_tcsicmp(s,STR_ItemNTSTATUS))  type = ItemNTSTATUS;
                else if (!_tcsicmp(s,STR_ItemWINERROR))  type = ItemWINERROR;
                else if (!_tcsicmp(s,STR_ItemNETEVENT))  type = ItemNETEVENT;
                else if (!_tcsicmp(s,STR_ItemCharHidden))  type = ItemCharHidden;
                else if (!_tcsicmp(s,STR_ItemWChar))  type = ItemWChar;
                else if (!_tcsicmp(s,STR_ItemHexDump))  type = ItemHexDump;
                else                                     type = ItemUnknown;

                // Get List elements
                if ((type == ItemListLong) || (type == ItemListShort) || (type == ItemListByte)
                    ||(type == ItemSetLong)  || (type == ItemSetShort)  || (type == ItemSetByte) ) {
                    s = _tcstok(NULL, _T("()"));
                    ItemListValue =
                    (TCHAR *) malloc((_tcslen(s) + 1) * sizeof(TCHAR));
                    if (ItemListValue == NULL) {
                        fclose(f);
                        free(Guid);
                        free(types);
                        return 1 ;
                    }
                    RtlCopyMemory(
                                 ItemListValue,
                                 s,
                                 (_tcslen(s) + 1) * sizeof(TCHAR));
                }
                // Get Module specification for ItemMerror
                if ((type == ItemMerror)) {
                    TCHAR * ppos ;
                    s = _tcstok(NULL, _T(" \t"));
                    ppos = _tcsrchr(s,'\n');
                    if (ppos != NULL) {
                        *ppos  = UNICODE_NULL ;
                        ItemListValue =
                        (TCHAR *) malloc((_tcslen(s) + 1) * sizeof(TCHAR));
                        if (ItemListValue == NULL) {
                            fclose(f);
                            free(Guid);
                            free(types);
                            return 1 ;
                        }
                        RtlCopyMemory(
                                     ItemListValue,
                                     s,
                                     (_tcslen(s) + 1) * sizeof(TCHAR));
                    }
                }
                // Get size for ItemCharHidden or other counted value
                if ((type == ItemCharHidden)||(type == ItemWChar)) {
                    TCHAR * ppos ;
                    s = _tcstok(NULL, _T("["));
                    ppos = _tcsrchr(s,']');
                    if (ppos != NULL) {
                        *ppos  = UNICODE_NULL ;
                        ItemListValue =
                        (TCHAR *) malloc((_tcslen(s) + 1) * sizeof(TCHAR));
                        if (ItemListValue == NULL) {
                            fclose(f);
                            free(Guid);
                            free(types);
                            return 1 ;
                        }
                        RtlCopyMemory(
                                     ItemListValue,
                                     s,
                                     (_tcslen(s) + 1) * sizeof(TCHAR));
                    }
                }

                if (typeCount == 0) {
                    AddMofInfo(
                              * HeadEventList,
                              Guid,
                              NULL,
                              -1,
                              name,
                              type,
                              NULL,
                              0,
                              NULL);
                } else {
                    for (i = 0; i < typeCount; i ++) {
                        AddMofInfo(
                                  * HeadEventList,
                                  Guid,
                                  types[i].strType,
                                  types[i].TypeIndex,
                                  name,
                                  type,
                                  ItemListValue,
                                  types[i].TypeType,
                                  types[i].TypeFormat);
                    }
                }
            }
        } else if (line[0] == '#') {
            TCHAR * token, * etoken;
            int Indent ;                    // Special parameter values(numeric) from comments
            TCHAR FuncName[MAXNAMEARG],     // Special parameter values from comment
            LevelName[MAXNAMEARG],
            CompIDName[MAXNAMEARG],
            SubCompName[MAXNAMEARG],
            *v ;

            FuncName[0] = LevelName[0] = CompIDName[0] = SubCompName[0] = '\0' ;

            //This is a workaround to defend against newlines in TMF files.
            while (!nextlineF && !eof) {
                if (_fgetts(nextline,MAXSTR,f) != NULL) {
                    if ((nextline[0] != '{') && nextline[0] != '#') {
                        TCHAR * eol ;
                        if ((eol = _tcsrchr(line,'\n')) != NULL) {
                            *eol = 0 ;
                        }
                        _tcsncat(line,nextline,MAXSTR-_tcslen(line)) ;
                        line[MAXSTR-1] = _T('\0');
                    } else {
                        nextlineF = TRUE ;
                    }
                } else {
                    eof = TRUE ;
                }
            }

            // Find any special names in the comments
            // As this gets longer we should make it generic
            Indent = FindIntValue(line,_T("INDENT="));  // Indentation Level 
            v = FindValue(line,_T("FUNC="));            // Function Name
            _tcsncpy(FuncName, v,  MAXNAMEARG);
            v = FindValue(line,_T("LEVEL="));           // Tracing level or Flags
            _tcsncpy(LevelName, v, MAXNAMEARG);
            v = FindValue(line,_T("COMPNAME="));          // Component ID
            _tcsncpy(CompIDName, v, MAXNAMEARG);
            v = FindValue(line,_T("SUBCOMP="));           // Sub Component ID
            _tcsncpy(SubCompName, v, MAXNAMEARG);
            token = _tcstok(line,_T(" \t"));
            if (_tcsicmp(token,_T("#typev")) == 0) {
                types[typeCount].TypeType = 2 ;
            } else {
                DWORD Status = -10;

                if (_tcsicmp(token,_T("#type")) == 0) {
                    Status = ERROR_BAD_FORMAT;
                }
                fclose(f);
                free(Guid);
                free(types);
                return(Status);
            }
            token = _tcstok( NULL, _T(" \t\n"));        // Get Type Name
            _tcscpy(types[typeCount].strType,token);
            token =_tcstok( NULL, _T("\"\n,"));         // Look for a Format String
            if (token != NULL) {
                types[typeCount].TypeIndex = _ttoi(token);  // Get the type Index
                token =_tcstok( NULL, _T("\n"));
            }
            etoken = NULL;
            if (token != NULL) {
                etoken = _tcsrchr(token,_T('\"'));  // Find the closing quote
            }

            if (etoken !=NULL) {
                etoken[0] = 0;
            } else {
                token = NULL;
            }

            if (token != NULL) {
                if (token[0] == '%' && token[1] == '0') {
                    // add standard prefix
                    if (bUsePrefix && StdPrefix[0] == 0) {
                        // need to initialize it.
                        LPTSTR Prefix = NULL ; int newlen, waslen = 0 ;        
                        while (((newlen = GetEnvironmentVariable(TRACE_FORMAT_PREFIX, Prefix, waslen )) - waslen) > 0) {
                            if (newlen - waslen > 0 ) {
                                if (Prefix != NULL) {
                                    free(Prefix);
                                }
                                Prefix = (LPTSTR) malloc((newlen+1) * sizeof(TCHAR)) ;
                                if (Prefix == NULL) {
                                    fclose(f);
                                    free(Guid);
                                    free(types);
                                    return -11 ;
                                }
                                waslen = newlen ;
                            }
                        }

                        if (Prefix) {
                            _tcsncpy(StdPrefix, Prefix, MAXSTR);
                        } else {
                            _tcscpy(StdPrefix, STD_PREFIX);
                        }
                        free(Prefix) ;
                    }
                    _tcscpy(types[typeCount].TypeFormat,StdPrefix);
                    _tcscat(types[typeCount].TypeFormat,token + 2);
                } else {
                    _tcscpy(types[typeCount].TypeFormat,token);
                }
                // process the special variable names
                // Make generic in future
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!FUNC!"), FuncName);
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!LEVEL!"), LevelName);
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!COMPNAME!"), CompIDName);
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!SUBCOMP!"), SubCompName);

            } else {
                types[typeCount].TypeFormat[0] = types[typeCount].TypeFormat[1]
                                                 = 0;
            }

            if (   types[typeCount].TypeFormat[0] == 0
                   && types[typeCount].TypeFormat[1] == 0) {
                pMofInfo = GetMofInfoHead(
                                         HeadEventList,
                                         Guid,
                                         types[typeCount].strType,
                                         types[typeCount].TypeIndex,
                                         types[typeCount].TypeType,
                                         NULL,
                                         FALSE);
            } else {
                pMofInfo = GetMofInfoHead(
                                         HeadEventList,
                                         Guid,
                                         types[typeCount].strType,
                                         types[typeCount].TypeIndex,
                                         types[typeCount].TypeType,
                                         types[typeCount].TypeFormat,
                                         FALSE);
            }

            if (pMofInfo == NULL) {
                fclose(f);
                free(Guid);
                free(types);
                return 0;

            }
            if (_tcslen(strGuid) > 0) {
                pMofInfo->strDescription = (PTCHAR) malloc((_tcslen(strGuid) + 1) * sizeof(TCHAR));
                if (pMofInfo->strDescription == NULL) {
                    fclose(f);
                    free(Guid);
                    free(types);
                    return 0;
                }
                _tcscpy(pMofInfo->strDescription, strGuid);
            }
           if (bStructuredFormat) {
              pMofInfo->Indent = Indent ;
              pMofInfo->FunctionName = pMofInfo->TraceFlagsName = pMofInfo->TraceLevelsName = pMofInfo->ComponentName = pMofInfo->SubComponentName = NULL ;
              if ((FuncName[0] != '\0') && (pMofInfo->FunctionName = (PTCHAR) malloc((_tcslen(FuncName) + 1) * sizeof(TCHAR))) != NULL) {
                RtlCopyMemory(pMofInfo->FunctionName,FuncName,min(_tcslen(FuncName) + 1, MAXNAMEARG) * sizeof(WCHAR));
              }
              if ((LevelName[0] != '\0') && (pMofInfo->TraceLevelsName = (PTCHAR) malloc((_tcslen(LevelName) + 1) * sizeof(TCHAR))) != NULL) {
                RtlCopyMemory(pMofInfo->TraceLevelsName,LevelName,min(_tcslen(LevelName) + 1, MAXNAMEARG) * sizeof(WCHAR));
              }
              if ((CompIDName[0] != '\0') && (pMofInfo->ComponentName = (PTCHAR) malloc((_tcslen(CompIDName) + 1) * sizeof(TCHAR))) != NULL) {
                RtlCopyMemory(pMofInfo->ComponentName,CompIDName,min(_tcslen(CompIDName) + 1, MAXNAMEARG) * sizeof(WCHAR));
              }
              if ((SubCompName[0] != '\0') && (pMofInfo->SubComponentName = (PTCHAR) malloc((_tcslen(SubCompName) + 1) * sizeof(TCHAR))) != NULL) {
                RtlCopyMemory(pMofInfo->SubComponentName,SubCompName,min(_tcslen(SubCompName) + 1, MAXNAMEARG) * sizeof(WCHAR));
              }
           }

            typeCount++;
            if (typeCount >= MAXTYPE) {
                fclose(f);
                free(Guid);
                free(types);
                return(-11);
            }
        } else if (   (line[0] >= '0' && line[0] <= '9')
                      || (line[0] >= 'a' && line[0] <= 'f')
                      || (line[0] >= 'A' && line[0] <= 'F')) {
            typeCount = 0;

            _tcsncpy(arg, line, 8);
            arg[8]      = 0;
            Guid->Data1 = ahextoi(arg);

            _tcsncpy(arg, &line[9], 4);
            arg[4]      = 0;
            Guid->Data2 = (USHORT) ahextoi(arg);

            _tcsncpy(arg, &line[14], 4);
            arg[4]      = 0;
            Guid->Data3 = (USHORT) ahextoi(arg);

            for (i = 0; i < 2; i ++) {
                _tcsncpy(arg, &line[19 + (i * 2)], 2);
                arg[2]         = 0;
                Guid->Data4[i] = (UCHAR) ahextoi(arg);
            }

            for (i = 2; i < 8; i ++) {
                _tcsncpy(arg, &line[20 + (i * 2)], 2);
                arg[2]         = 0;
                Guid->Data4[i] = (UCHAR) ahextoi(arg);
            }

            // Find the next non whitespace character
            //
            guidName = &line[36];

            while (*guidName == ' '|| *guidName == '\t') {
                guidName++;
            }

            // cut comment out (if present)
            {
                TCHAR* comment = _tcsstr(guidName, TEXT("//"));
                if (comment) {
                    // remove whitespace
                    --comment;
                    while (comment >= guidName && _istspace(*comment)) --comment;
                    *++comment = 0;
                }
            }

            len = _tcslen(guidName);
            s   = guidName;

            while (len > 0) {
                len -= 1;
                if (*s == '\n' || *s == '\0' || *s == '\t') {
                    *s = '\0';
                    break;
                }
                s++;
            }

            pMofInfo = GetMofInfoHead(
                                     HeadEventList, Guid, NULL, -1, 0, NULL, FALSE);

            if (pMofInfo == NULL) {
                fclose(f);
                free(Guid);
                free(types);
                return(ULONG) 0;
            }

            if (pMofInfo->strDescription != NULL) {
                free(pMofInfo->strDescription);
                pMofInfo->strDescription = NULL;
            }
            _tcsncpy(strGuid, guidName,MAXSTR);
            strGuid[MAXSTR-1] = _T('\0');

            pMofInfo->strDescription = (PTCHAR) malloc((_tcslen(guidName) + 1) * sizeof(TCHAR));
            if (pMofInfo->strDescription == NULL ) {
                // We really have problems
                fclose(f);
                free(Guid);
                free(types);
                return(ULONG) 0 ;
            }
            _tcscpy(pMofInfo->strDescription, strGuid);
            n++ ;                                      // Thats one more GUID
        }
        RtlZeroMemory(line, MAXSTR * sizeof(TCHAR));
    }

    fclose(f);
    free(Guid);
    free(types);
    return(ULONG) n;
}

ULONG
ahextoi(
       TCHAR *s
       )
{
    SSIZE_T   len;
    ULONG num, base, hex;

    len  = _tcslen(s);
    hex  = 0;
    base = 1;
    num  = 0;
    while (--len >= 0) {
        if ((s[len] == 'x' || s[len] == 'X') && (s[len-1] == '0')) {
            break;
        }

        if (s[len] >= '0' && s[len] <= '9') {
            num = s[len] - '0';
        } else if (s[len] >= 'a' && s[len] <= 'f') {
            num = (s[len] - 'a') + 10;
        } else if (s[len] >= 'A' && s[len] <= 'F') {
            num = (s[len] - 'A') + 10;
        } else {
            continue;
        }

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void
WINAPI
SummaryTraceEventListW(
                      TCHAR       * SummaryBlock,
                      ULONG         SizeSummaryBlock,
                      PLIST_ENTRY   EventListHead
                      )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;
    TCHAR       strGuid[MAXSTR];
    TCHAR       strName[MAXSTR];
    TCHAR       strBuffer[MAXSTR];


    if ((EventListHead == NULL) || (SummaryBlock == NULL)) {
        return;
    }
    RtlZeroMemory(SummaryBlock, sizeof(TCHAR) * SizeSummaryBlock);

    Head = EventListHead;
    Next = Head->Flink;
    while (Head != Next) {
        RtlZeroMemory(strName, 256);
        RtlZeroMemory(strBuffer, 256);
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        if (pMofInfo->EventCount > 0) {
            GuidToString((PTCHAR) strGuid, &pMofInfo->Guid);
            MapGuidToName(&EventListHead, &pMofInfo->Guid, 0, strName);
            _sntprintf(strBuffer,
                       MAXSTR,
                       _T("|%10d    %-20s %-10s  %36s|\n"),
                       pMofInfo->EventCount,
                       strName,
                       pMofInfo->strType ? pMofInfo->strType : _T("General"),
                       strGuid);

            _tcscat(SummaryBlock, strBuffer);
            if (_tcslen(SummaryBlock) >= SizeSummaryBlock) {
                return;
            }
        }

        Next = Next->Flink;
    }
}

PTCHAR
GuidToString(
            PTCHAR s,
            LPGUID piid
            )
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
              piid->Data1,
              piid->Data2,
              piid->Data3,
              piid->Data4[0],
              piid->Data4[1],
              piid->Data4[2],
              piid->Data4[3],
              piid->Data4[4],
              piid->Data4[5],
              piid->Data4[6],
              piid->Data4[7]);
    return(s);
}

// This routine is called by the WBEM interface routine for each property
// found for this Guid. The ITEM_DESC structure is allocted for each Property.
//
VOID
AddMofInfo(
          PLIST_ENTRY   HeadEventList,
          const GUID        * Guid,
          LPTSTR        strType,
          ULONG         typeIndex,
          LPTSTR        strDesc,
          ITEM_TYPE     ItemType,
          TCHAR       * ItemList,
          ULONG         typeOfType,
          LPTSTR        typeFormat
          )
{
    PITEM_DESC  pItem;
    PLIST_ENTRY pListHead;
    PMOF_INFO   pMofInfo;

    if (strDesc == NULL) {
        return;
    }

    pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
    if (pItem == NULL)return;    //silent error 

    RtlZeroMemory(pItem, sizeof(ITEM_DESC));
    pItem->strDescription =
    (LPTSTR) malloc((_tcslen(strDesc) + 1) * sizeof(TCHAR));

    if ( pItem->strDescription == NULL ) {
        free(pItem);
        return;
    }

    _tcscpy(pItem->strDescription, strDesc);
    pItem->ItemType = ItemType;
    pItem->ItemList = ItemList ;
    pMofInfo = GetMofInfoHead(
                             (PLIST_ENTRY *) HeadEventList,
                             (LPGUID) Guid,
                             strType,
                             typeIndex,
                             typeOfType,
                             typeFormat,
                             FALSE);
    if (pMofInfo != NULL) {
        pListHead = pMofInfo->ItemHeader;
        InsertTailList(pListHead, &pItem->Entry);
    } else {

        free(pItem->strDescription); 
        free(pItem);
    }

}

void
WINAPI
CleanupTraceEventList(
                     PLIST_ENTRY HeadEventList
                     )
{

    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;


    if (HeadEventList == NULL) {
        return;
    }

    Head = HeadEventList;
    Next = Head->Flink;
    while (Head != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        RemoveEntryList(&pMofInfo->Entry);
        RemoveMofInfo(pMofInfo->ItemHeader);
        free(pMofInfo->ItemHeader);
        free(pMofInfo->strDescription);
        free(pMofInfo->TypeFormat);
        free(pMofInfo->strType);
        free(pMofInfo->FunctionName);
        free(pMofInfo->TraceFlagsName);
        free(pMofInfo->TraceLevelsName);
        free(pMofInfo->ComponentName);
        free(pMofInfo->SubComponentName);
        Next = Next->Flink;
        pFmtInfoSet->erase(pMofInfo);  //remove from the cache
        free(pMofInfo);
    }

    free(HeadEventList);
#ifdef MANAGED_TRACING
    UninitializeCSharpDecoder();
#endif
}

void
RemoveMofInfo(
             PLIST_ENTRY pMofInfo
             )
{
    PLIST_ENTRY Head, Next;
    PITEM_DESC  pItem;

    Head = pMofInfo;
    Next = Head->Flink;
    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList(&pItem->Entry);

        if (pItem->strDescription != NULL) {
            free(pItem->strDescription);
        }
        if (pItem->ItemList != NULL) {
            free(pItem->ItemList);
        }
        free(pItem);
    }

}

// Now for some of the ASCII Stuff
//



SIZE_T
WINAPI
FormatTraceEventA(
                 PLIST_ENTRY   HeadEventList,
                 PEVENT_TRACE  pInEvent,
                 CHAR        * EventBuf,
                 ULONG         SizeEventBuf,
                 CHAR        * pszMask
                 )
{
    SIZE_T  Status;
    ULONG   uSizeEventBuf;
    TCHAR * EventBufW;
    TCHAR * pszMaskW;

    EventBufW = (TCHAR *) malloc(SizeEventBuf * sizeof(TCHAR) + 2);
    if (EventBufW == (TCHAR *) NULL) {
        return -1;
    }

    pszMaskW = (TCHAR *) NULL;

    if (pszMask != NULL && strlen(pszMask) != 0) {
        pszMaskW = (TCHAR *) malloc(strlen(pszMask) * sizeof(TCHAR));
        if (pszMaskW == (TCHAR *) NULL) {
            free(EventBufW);
            return -1;
        }
        RtlZeroMemory(pszMaskW, strlen(pszMask) * sizeof(TCHAR));
    }



    uSizeEventBuf = SizeEventBuf;

    Status = FormatTraceEventW(
                              HeadEventList,
                              pInEvent,
                              EventBufW,
                              SizeEventBuf,
                              pszMaskW);
    if (Status == 0) {
        free(EventBufW);
        free(pszMaskW);
        return -1;
    }

    RtlZeroMemory(EventBuf,uSizeEventBuf);

    WideCharToMultiByte(
                       CP_ACP,
                       0,
                       EventBufW,
                       (int) _tcslen(EventBufW),   // Truncate in Sundown!!
                       EventBuf,
                       uSizeEventBuf,
                       NULL,
                       NULL);

    free(EventBufW);
    free(pszMaskW);

    return Status;
}

ULONG
WINAPI
GetTraceGuidsA(
              CHAR        * GuidFile,
              PLIST_ENTRY * HeadEventList
              )
{
    INT     Status;
    WCHAR * GuidFileW;
    SIZE_T len;

    if ((len = strlen(GuidFile)) == 0) {
        return 0;
    }

    GuidFileW = (TCHAR *) malloc(sizeof(WCHAR) * strlen(GuidFile) + 2);
    if (GuidFileW == NULL) {
        return 0;
    }

    if ((MultiByteToWideChar(
                            CP_ACP,
                            0,
                            GuidFile,
                            -1,
                            GuidFileW,
                            (int) strlen(GuidFile) + 1)) // Truncate in Sundown!!
        == 0) {
        free(GuidFileW);
        return 0;
    }

    Status = GetTraceGuidsW(GuidFileW, HeadEventList);

    free (GuidFileW);
    return Status;
}

void
WINAPI
SummaryTraceEventListA(
                      CHAR       * SummaryBlock,
                      ULONG        SizeSummaryBlock,
                      PLIST_ENTRY  EventListhead
                      )
{
    TCHAR * SummaryBlockW;

    if (SizeSummaryBlock <= 0 || SizeSummaryBlock * sizeof(TCHAR) <= 0 ) {
        return;
    }

    SummaryBlockW = (TCHAR *) malloc(SizeSummaryBlock * sizeof(TCHAR));
    if (SummaryBlockW == (TCHAR *)NULL) {
        return;
    }

    //RtlZeroMemory(SummaryBlock, SizeSummaryBlock);
    RtlZeroMemory(SummaryBlockW, SizeSummaryBlock*sizeof(TCHAR));
    SummaryTraceEventListW(
                          SummaryBlockW,
                          SizeSummaryBlock * ((ULONG)sizeof(TCHAR)),
                          EventListhead);

    WideCharToMultiByte(
                       CP_ACP,
                       0,
                       SummaryBlockW,
                       (int)_tcslen(SummaryBlockW), // Truncate in Sundown!!
                       SummaryBlock,
                       SizeSummaryBlock,
                       NULL,
                       NULL);
    free(SummaryBlockW);
}

void
WINAPI
GetTraceElapseTime(
                  __int64 * pElapseTime
                  )
{
    * pElapseTime = ElapseTime;
}

ULONG
WINAPI
SetTraceFormatParameter(
                       PARAMETER_TYPE  Parameter ,
                       PVOID           ParameterValue 
                       )
{
    ULONG ulLen;

    switch (Parameter) {
    case ParameterINDENT: 
        bIndent = PtrToUlong(ParameterValue);
        break;

    case ParameterSEQUENCE: 
        bSequence = PtrToUlong(ParameterValue);
        if (bSequence) {
            STD_PREFIX = STD_PREFIX_SEQ;
        } else {
            STD_PREFIX = STD_PREFIX_NOSEQ;
        }
        break;

    case ParameterGMT: 
        bGMT = PtrToUlong(ParameterValue);
        break;

    case ParameterTraceFormatSearchPath:
        ulLen = _tcslen((LPTSTR)ParameterValue);

        if (gTraceFormatSearchPath != NULL) {
            free(gTraceFormatSearchPath);
        }
        gTraceFormatSearchPath = (LPTSTR)malloc((ulLen+1) * sizeof(TCHAR));
        if (gTraceFormatSearchPath != NULL) {
            _tcscpy(gTraceFormatSearchPath, (const wchar_t *) ParameterValue);
            gTraceFormatSearchPath[ulLen] = L'\000';
        }
        break;

    case ParameterUsePrefix: 
        bUsePrefix = PtrToUlong(ParameterValue);
        break;

    case ParameterSetPrefix:
        ulLen = _tcslen((LPTSTR)ParameterValue);

        gTraceFormatSearchPath = (LPTSTR)malloc((ulLen+1) * sizeof(TCHAR));
        if (ulLen < MAXSTR) {
            _tcscpy(StdPrefix, (const wchar_t *) ParameterValue);
            StdPrefix[ulLen] = L'\000';
        }
        break;

    case ParameterStructuredFormat:
        bStructuredFormat = PtrToUlong(ParameterValue);
        break;
    }

    return 0 ;
}

ULONG
WINAPI
GetTraceFormatParameter(
                       PARAMETER_TYPE  Parameter ,
                       PVOID           ParameterValue 
                       )
{
    switch (Parameter) {
    case ParameterINDENT: return bIndent;
    case ParameterSEQUENCE: return bSequence; 
    case ParameterGMT: return bGMT;
    case ParameterUsePrefix: return bUsePrefix;
    case ParameterStructuredFormat: return bStructuredFormat;
    case ParameterInterfaceVersion: return TRACEPRT_INTERFACE_VERSION ;
    }

    return 0 ;

}

LPTSTR
WINAPI
GetTraceFormatSearchPath(void) {
    return gTraceFormatSearchPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceprt\traceint.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceint.h

Abstract:

    Trace formatting internal definitions.

Revision History:

--*/
#ifdef __cplusplus
extern "C"{
#endif
 
#ifndef _TRACEINT_
#define _TRACEINT_

#define MAXLOGFILES    16
#define MAXSTR       1024
#define MAXFORMAT    1024
#define MAXTYPE       256
#define MAXGUIDS      128
#define UC(x)        ((UINT)((x) & 0xFF))
#define NTOHS(x)     ((UC(x) * 256) + UC((x) >> 8))

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define GUID_TYPE_HEADER    _T("Header")
#define GUID_TYPE_UNKNOWN   _T("Unknown")
#define GUID_TYPE_OBSOLETE  _T("ObsoleteGUID")
    
#define STR_ItemChar        _T("ItemChar")
#define STR_ItemUChar       _T("ItemUChar")
#define STR_ItemCharShort   _T("ItemCharShort")
#define STR_ItemCharSign    _T("ItemCharSign")
#define STR_ItemDouble      _T("ItemDouble")
#define STR_ItemShort       _T("ItemShort")
#define STR_ItemUShort      _T("ItemUShort")
#define STR_ItemLong        _T("ItemLong")
#define STR_ItemULong       _T("ItemULong")
#define STR_ItemULongX      _T("ItemULongX")
#define STR_ItemLongLong    _T("ItemLongLong")
#define STR_ItemULongLong   _T("ItemULongLong")
#define STR_ItemString      _T("ItemString")
#define STR_ItemWString     _T("ItemWString")
#define STR_ItemRString     _T("ItemRString")
#define STR_ItemRWString    _T("ItemRWString")
#define STR_ItemPString     _T("ItemPString")
#define STR_ItemPWString    _T("ItemPWString")
#define STR_ItemMLString    _T("ItemMLString")
#define STR_ItemNWString    _T("ItemNWString")
#define STR_ItemPtr         _T("ItemPtr")
#define STR_ItemDSString    _T("ItemDSString")
#define STR_ItemDSWString   _T("ItemDSWString")
#define STR_ItemSid         _T("ItemSid")
#define STR_ItemChar4       _T("ItemChar4")
#define STR_ItemIPAddr      _T("ItemIPAddr")
#define STR_ItemIPV6Addr    _T("ItemIPV6Addr")
#define STR_ItemMACAddr     _T("ItemMACAddr")
#define STR_ItemPort        _T("ItemPort")
#define STR_ItemNWString    _T("ItemNWString")
#define STR_ItemListLong    _T("ItemListLong")
#define STR_ItemListShort   _T("ItemListShort")
#define STR_ItemListByte    _T("ItemListByte")
#define STR_ItemNTerror     _T("ItemNTerror")
#define STR_ItemMerror      _T("ItemMerror")
#define STR_ItemTimestamp   _T("ItemTimestamp")
#define STR_ItemHRESULT     _T("ItemHRESULT")
#define STR_ItemNTSTATUS    _T("ItemNTSTATUS")
#define STR_ItemWINERROR    _T("ItemWINERROR")
#define STR_ItemNETEVENT    _T("ItemNETEVENT")
#define STR_ItemGuid        _T("ItemGuid")
#define STR_ItemWaitTime    _T("ItemWaitTime")
#define STR_ItemTimeDelta   _T("ItemTimeDelta")
#define STR_ItemSetLong    _T("ItemSetLong")
#define STR_ItemSetShort   _T("ItemSetShort")
#define STR_ItemSetByte    _T("ItemSetByte")
#define STR_ItemCharHidden    _T("ItemCharHidden")
#define STR_ItemWChar    _T("ItemWChar")
#define STR_ItemHexDump    _T("ItemHexDump")

typedef struct _MOF_INFO
{
    LIST_ENTRY   Entry;
    LPTSTR       strDescription;        // Class Name
    ULONG        EventCount;            
    GUID         Guid;
    PLIST_ENTRY  ItemHeader;            
    LPTSTR       strType;
    LONG         TypeIndex;
    ULONG        TypeOfType;
    LPTSTR       TypeFormat;
    LPTSTR       FunctionName  ;
    LPTSTR       ComponentName ;
    LPTSTR       SubComponentName ;
    LPTSTR       TraceFlagsName ;
    LPTSTR       TraceLevelsName ;
    INT          Indent;

}  MOF_INFO, *PMOF_INFO;

typedef struct _MOF_TYPE
{
    TCHAR     strType[MAXSTR];
    LONG      TypeIndex;
    ULONG     TypeType;
    TCHAR     TypeFormat[MAXFORMAT];
} MOF_TYPE, *PMOF_TYPE;

typedef enum _ITEM_TYPE
{
    ItemChar,
    ItemUChar,
    ItemCharShort,
    ItemCharSign,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemString,
    ItemWString,
    ItemRString,
    ItemRWString,
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemChar4,
    ItemIPAddr,
    ItemIPV6Addr,
    ItemMACAddr,
    ItemPort,
    ItemMLString,
    ItemNWString,        // Non-null terminated Wide Char String
    ItemPtr,
    ItemListLong,        // Sort of Enumerated List, field is a long
    ItemListShort,       // Sort of Enumerated List, field is a Short
    ItemListByte,        // Sort of Enumerated List, field is a Byte
	ItemNTerror,		 // Convert an NT error number to the usual error string
	ItemMerror,			 // Convert an error number to a module message
	ItemTimestamp,		 // Convert a LongLong to a timestamp string
    ItemGuid,            // convert a GUID to the usual string
	ItemNTSTATUS,
	ItemWINERROR,
	ItemNETEVENT,
    ItemWaitTime,
    ItemTimeDelta,
    ItemSetLong,     
    ItemSetShort,    
    ItemSetByte,     
    ItemDouble,
    ItemHRESULT,
    ItemCharHidden,     //Just a block of chars ( name from ETW)
    ItemWChar,
    ItemHexDump,
    ItemUnknown
} ITEM_TYPE;

typedef struct _ITEM_DESC *PITEM_DESC;
typedef struct _ITEM_DESC
{
    LIST_ENTRY Entry;
    LPTSTR     strDescription;
    ULONG      DataSize;
    LPTSTR     ItemList;
    ITEM_TYPE  ItemType;
} ITEM_DESC;

//
// Now the routines we export
//
#ifndef TRACE_API
#ifdef TRACE_EXPORTS
#define TRACE_API __declspec(dllexport)
#else
#define TRACE_API __declspec(dllimport)
#endif
#endif

TRACE_API void
MapGuidToName(
        OUT PLIST_ENTRY * HeadEventList,
        IN  LPGUID      pGuid,
        IN  ULONG       nType,
        OUT LPTSTR      wstr
        );

TRACE_API ULONG
UserDefinedGuid(
        OUT PLIST_ENTRY HeadEventList,
        IN  LPGUID      Guid,
        OUT LPTSTR      wstr
        );

TRACE_API VOID
AddMofInfo(
        PLIST_ENTRY   HeadEventList,
        const GUID  * Guid,
        LPTSTR        strType,
        ULONG         typeIndex,
        LPTSTR        strDesc,
        ITEM_TYPE     ItemType,
        TCHAR       * ItemList,
        ULONG         TypeOfType,
        LPTSTR        strFormat
        );
// the following segment is used to impose our own formatting via a copy of RtlTraceFormat,
// but which fixes up selected formats that we cannot handle correctly.

NTSTATUS
TraceFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

#endif  // #ifndef _TRACEINT_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\childview.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ChildView.cpp : implementation of the CChildView class
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <objbase.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "ChildView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CChildView

CChildView::CChildView()
{
}

CChildView::~CChildView()
{
}


BEGIN_MESSAGE_MAP(CChildView, CWnd)
	ON_WM_PAINT()
END_MESSAGE_MAP()



// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) 
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	cs.dwExStyle |= WS_EX_CLIENTEDGE;
	cs.style &= ~WS_BORDER;
	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);

	return TRUE;
}

void CChildView::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracerpt\resource.h ===
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//

#define IDS_PARAM_LOGFILE       103
#define IDS_PARAM_DUMPFILE      104
#define IDS_PARAM_MOFFILE       105
#define IDS_PARAM_REPORTFILE    106
#define IDS_PARAM_REALTIME      107
#define IDS_PARAM_LOGGERNAME    108
#define IDS_PARAM_EXFMT         111
#define IDS_PARAM_SUMMARY       113
#define IDS_PARAM_MERGE         114
#define IDS_PARAM_COMP          115
#define IDS_PARAM_YES           116
#define IDS_PARAM_FORMAT        117

#define IDS_DEFAULT_DUMP        200
#define IDS_DEFAULT_MOF         201
#define IDS_DEFAULT_REPORT      202
#define IDS_DEFAULT_SUMMARY     203
#define IDS_DEFAULT_MERGED      204
#define IDS_DEFAULT_COMP        205

#define IDS_MESSAGE_INPUT       300
#define IDS_MESSAGE_OUTPUT      301
#define IDS_MESSAGE_BADFILE     302
#define IDS_MESSAGE_LOGGERS     303
#define IDS_MESSAGE_FILES       304
#define IDS_MESSAGE_DEFINE      305
#define IDS_MESSAGE_CSVFILE     306
#define IDS_MESSAGE_REPORT      307
#define IDS_MESSAGE_SUMMARY     308
#define IDS_MESSAGE_DFLTSRC     310
#define IDS_MESSAGE_MERGED      311
#define IDS_MESSAGE_COMP        312

#define IDS_EXAMPLE_DUMPFILE    800
#define IDS_EXAMPLE_SUMMARY     801
#define IDS_EXAMPLE_REALTIME    802
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracerpt\tracerpt.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracerpt.c

Abstract:

    Event Trace Reporting Tool

Author:

    08-Apr-1998 Melur Raghuraman

Revision History:

--*/

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "tracectr.h"
#include "resource.h"
#include "varg.c"

#define GROUP_SRC       0x01
#define GROUP_REALTIME  0x02

VARG_DECLARE_COMMANDS
    VARG_DEBUG ( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP  ( VARG_FLAG_OPTIONAL )
    VARG_MSZ   ( IDS_PARAM_LOGFILE,     VARG_FLAG_NOFLAG|VARG_FLAG_EXPANDFILES|VARG_FLAG_ARG_FILENAME, NULL )
    VARG_STR   ( IDS_PARAM_DUMPFILE,    VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_DUMP )
    VARG_STR   ( IDS_PARAM_SUMMARY,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_SUMMARY )
    VARG_STR   ( IDS_PARAM_MOFFILE,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_HIDDEN|VARG_FLAG_DEFAULTABLE, NULL )
    VARG_STR   ( IDS_PARAM_REPORTFILE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_REPORT )
    VARG_MSZ   ( IDS_PARAM_LOGGERNAME,  0, NULL )
    VARG_INI   ( IDS_PARAM_SETTINGS,    VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL  ( IDS_PARAM_EXFMT,       VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN, FALSE )
    VARG_STR   ( IDS_PARAM_MERGE,       VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT|VARG_FLAG_HIDDEN, IDS_DEFAULT_MERGED )
    VARG_STR   ( IDS_PARAM_COMP,        VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_HIDDEN|VARG_FLAG_RCDEFAULT|VARG_FLAG_DEFAULTABLE, IDS_DEFAULT_COMP )
    VARG_BOOL  ( IDS_PARAM_YES,         VARG_FLAG_OPTIONAL, FALSE )
    VARG_STR   ( IDS_PARAM_FORMAT,      VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("TXT") )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eLogFile,
    eDump,
    eSummary,
    eMofFile,
    eReport,
    eRealTime,
    eConfig,
    eExFormat,
    eMerge,
    eInterpret,
    eYes,
    eFormat,
VARG_DECLARE_FORMAT
    VARG_GROUP( eLogFile,  VARG_EXCL(GROUP_SRC)|VARG_COND(GROUP_SRC) )
    VARG_GROUP( eRealTime, VARG_EXCL(GROUP_SRC)|VARG_COND(GROUP_SRC) )
    VARG_GROUP( eRealTime, VARG_EXCL(GROUP_REALTIME) )
    VARG_GROUP( eReport,   VARG_EXCL(GROUP_REALTIME) )
    VARG_EXHELP( eDump,         IDS_EXAMPLE_DUMPFILE)
    VARG_EXHELP( eSummary,      IDS_EXAMPLE_SUMMARY )
    VARG_EXHELP( eRealTime,     IDS_EXAMPLE_REALTIME)
VARG_DECLARE_END

#define MAXLOGFILES         32
#define MAX_BUFFER_SIZE     1048576
#define CHECK_HR( hr )      if( ERROR_SUCCESS != hr ){ goto cleanup; }

DWORD ExtractResourceFile( LPWSTR szResourceName, LPWSTR szFileName );
void ReportStatus( int Status, double Progress );

int __cdecl _tmain (int argc, LPTSTR* argv)
{
    LPTSTR* EvmFile = NULL;    // List Of LogFiles To Process
    LPTSTR* Loggers = NULL;    // List of Loggers to process

    ULONG LogFileCount = 0;
    ULONG LoggerCount = 0;
    TCHAR strEventDef[MAXSTR];
    TCHAR strDefinitionFile[MAXSTR] = _T("");
    DWORD dwCheckFileFlag = 0;
    HRESULT hr = ERROR_SUCCESS;
    TCHAR strXSLFile[MAXSTR] = _T("");

    TRACE_BASIC_INFO TraceBasicInfo;
    //
    //  Parse the Command line arguments
    // 
   
    ParseCmd( argc, argv );
    EvmFile = (LPTSTR*)VARG_ALLOC( GetMaxLoggers() * sizeof(LPTSTR) );
    if( NULL == EvmFile ){
        hr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    Loggers = (LPTSTR*)VARG_ALLOC( GetMaxLoggers() * sizeof(LPTSTR) );
    if( NULL == Loggers ){
        hr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    memset(&TraceBasicInfo, 0, sizeof(TRACE_BASIC_INFO));
    
    PrintMessage( g_normal, IDS_MESSAGE_INPUT );

    if( Commands[eRealTime].bDefined && Commands[eRealTime].strValue != NULL ) {
                
        LPTSTR strLogger = Commands[eRealTime].strValue;
        PrintMessage( g_normal, IDS_MESSAGE_LOGGERS );

        while( *strLogger != _T('\0') ){

            Loggers[LoggerCount] = strLogger;
            LoggerCount++;
            
            varg_printf( g_normal, _T("     %1!s!\n"), strLogger );

            strLogger += (_tcslen(strLogger)+1);
        }
    
        varg_printf( g_normal, _T("\n") );
    }
 
    if( Commands[eLogFile].bDefined && Commands[eLogFile].strValue != NULL ) {

        LPTSTR strLogger = Commands[eLogFile].strValue;
        PrintMessage( g_normal, IDS_MESSAGE_FILES );

        while( *strLogger != '\0' ){
            EvmFile[LogFileCount] = strLogger;
            LogFileCount++;
            hr = CheckFile(strLogger, VARG_CF_EXISTS);
            CHECK_HR( hr );

            varg_printf( g_normal, _T("     %1!s!\n"), strLogger );
            strLogger += (_tcslen(strLogger)+1);
        }

        varg_printf( g_normal, _T("\n") );
    }
 
    
    if( Commands[eMofFile].bDefined ) {

        hr = GetTempName( strDefinitionFile, MAXSTR );
        CHECK_HR( hr );

        LoadString( NULL, IDS_MESSAGE_DFLTSRC, strEventDef, MAXSTR );
        TraceBasicInfo.DefMofFileName = strDefinitionFile;

        hr = ExtractResourceFile( L"MOFFILE", strDefinitionFile );
        CHECK_HR( hr );
        
        if ( Commands[eMofFile].strValue != NULL ) {
            TraceBasicInfo.MofFileName = Commands[eMofFile].strValue;
            hr = StringCchCopy( strEventDef, MAXSTR, Commands[eMofFile].strValue );
        }
    }else{
        TraceBasicInfo.Flags |= TRACE_USE_WBEM;
        *strEventDef = _T('\0');
    }
    
    dwCheckFileFlag = Commands[eYes].bValue ? VARG_CF_OVERWRITE : (VARG_CF_PROMPT|VARG_CF_OVERWRITE);

    if( Commands[eMerge].bDefined ){
        TraceBasicInfo.Flags |= TRACE_MERGE_ETL;
        TraceBasicInfo.MergeFileName = Commands[eMerge].strValue;
    }else if ( _tcslen( strEventDef ) ){
        PrintMessage( g_normal, IDS_MESSAGE_DEFINE, strEventDef );
    }

    if( Commands[eInterpret].bDefined ) {
        TraceBasicInfo.Flags |= TRACE_INTERPRET;
        TraceBasicInfo.CompFileName = Commands[eInterpret].strValue;
        hr = CheckFile( Commands[eInterpret].strValue, dwCheckFileFlag );
        CHECK_HR(hr);

    }
    
    if( Commands[eReport].bDefined ) {
        TraceBasicInfo.Flags |= TRACE_REDUCE;
        TraceBasicInfo.ProcFileName = Commands[eReport].strValue;
        hr = CheckFile( Commands[eReport].strValue, dwCheckFileFlag );
        CHECK_HR(hr);

        DeleteFile( Commands[eReport].strValue );
        
        if( _wcsicmp( Commands[eFormat].strValue, L"XML" ) == 0 ){
            LPWSTR szScan;
            hr = StringCchCopy( strXSLFile, MAXSTR, Commands[eReport].strValue );
            szScan = strXSLFile + wcslen(strXSLFile) - 1;
            while( szScan > strXSLFile ){
                if( *szScan == L'\\' ){
                    szScan++;
                    *szScan = L'\0';
                    hr = StringCchCat( strXSLFile, MAXSTR, L"report.xsl" );
                    break;
                }
                szScan--;
            }
            if( szScan == strXSLFile ){
                hr = StringCchCopy( strXSLFile, MAXSTR, L"report.xsl" );
            }

            ExtractResourceFile( L"XREPORT.XSL", strXSLFile );
            TraceBasicInfo.XSLDocName = L"report.xsl";

        }else if( _wcsicmp( Commands[eFormat].strValue, L"TXT" ) == 0 ){
            
            GetTempName( strXSLFile, MAXSTR );
            ExtractResourceFile( L"XTEXT.XSL", strXSLFile );
            TraceBasicInfo.Flags |= TRACE_TRANSFORM_XML;
            TraceBasicInfo.XSLDocName = strXSLFile;

        }else if( _wcsicmp( Commands[eFormat].strValue, L"HTML" ) == 0 ){

            GetTempName( strXSLFile, MAXSTR );
            ExtractResourceFile( L"XREPORT.XSL", strXSLFile );
            TraceBasicInfo.Flags |= TRACE_TRANSFORM_XML;
            TraceBasicInfo.XSLDocName = strXSLFile;
        }

    }
    if( Commands[eExFormat].bValue ){
        TraceBasicInfo.Flags |= TRACE_EXTENDED_FMT;
    }
    

    if( Commands[eDump].bDefined ){
        TraceBasicInfo.Flags |= TRACE_DUMP;
        TraceBasicInfo.DumpFileName = Commands[eDump].strValue;
        hr = CheckFile( Commands[eDump].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }
    if( Commands[eSummary].bDefined ) {
        TraceBasicInfo.Flags |= TRACE_SUMMARY;
        TraceBasicInfo.SummaryFileName = Commands[eSummary].strValue;
        hr = CheckFile( Commands[eSummary].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }

    //
    // Make dump & summary the default
    //
    if( !(TraceBasicInfo.Flags & (TRACE_DUMP|TRACE_REDUCE|TRACE_MERGE_ETL|TRACE_SUMMARY) ) ) {  
        TraceBasicInfo.Flags |= (TRACE_DUMP|TRACE_SUMMARY);
        TraceBasicInfo.DumpFileName = Commands[eDump].strValue;
        TraceBasicInfo.SummaryFileName = Commands[eSummary].strValue;

        hr = CheckFile( Commands[eDump].strValue, dwCheckFileFlag );
        CHECK_HR(hr);

        hr = CheckFile( Commands[eSummary].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }

    TraceBasicInfo.LogFileName  = EvmFile;
    TraceBasicInfo.LogFileCount = LogFileCount;
    TraceBasicInfo.LoggerName   = Loggers;
    TraceBasicInfo.LoggerCount  = LoggerCount;
    if( ! Commands[eRealTime].bDefined ){
        TraceBasicInfo.StatusFunction = ReportStatus;
        varg_printf( g_normal, _T("\n") );
        ReportStatus( 0, 0.0 );
    }

    hr = InitTraceContext(&TraceBasicInfo, NULL);
    CHECK_HR( hr );

    if( ! Commands[eRealTime].bDefined ){
        ReportStatus( 0, 1.0 );
        varg_printf( g_normal, _T("\n") );
    }

    PrintMessage( g_normal, IDS_MESSAGE_OUTPUT );
    if( TraceBasicInfo.Flags & TRACE_DUMP ){
        PrintMessage( g_normal, IDS_MESSAGE_CSVFILE, TraceBasicInfo.DumpFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_SUMMARY ){
        PrintMessage( g_normal, IDS_MESSAGE_SUMMARY, TraceBasicInfo.SummaryFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_REDUCE ){
        PrintMessage( g_normal, IDS_MESSAGE_REPORT, TraceBasicInfo.ProcFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_MERGE_ETL ){
        PrintMessage( g_normal, IDS_MESSAGE_MERGED, TraceBasicInfo.MergeFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_INTERPRET ){
        PrintMessage( g_normal, IDS_MESSAGE_COMP, TraceBasicInfo.CompFileName );
    }

    hr = DeinitTraceContext(&TraceBasicInfo);
    CHECK_HR( hr );


cleanup:
    
    VARG_FREE( Loggers );
    VARG_FREE( EvmFile );

    if( ! IsEmpty( strDefinitionFile ) ){
        DeleteFile( strDefinitionFile );
    }
    if( TraceBasicInfo.Flags & TRACE_TRANSFORM_XML ){
        DeleteFile( strXSLFile );
    }

    varg_printf( g_normal, _T("\n") );
    switch( hr ){
    case ERROR_SUCCESS:
        PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        break;
    case ERROR_INVALID_HANDLE:
        PrintMessage( g_debug, IDS_MESSAGE_BADFILE );
        break;
    default:
        PrintError( hr );
    }

    return hr;
}

void ReportStatus( int Status, double Progress )
{
    HRESULT hr;
    TCHAR buffer[16];
    hr = StringCchPrintf( buffer, 16, _T("%1.2f%%"), Progress*100 );
    
    _tprintf( _T("\r") );
    varg_printf( g_normal, _T("%1!s!"), buffer );
    
}

DWORD 
ExtractResourceFile( LPWSTR szResourceName, LPWSTR szFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;

    HANDLE f;

    f = CreateFile(
            szFileName, 
            GENERIC_WRITE, 
            0, 
            NULL, 
            CREATE_ALWAYS, 
            FILE_ATTRIBUTE_TEMPORARY,
            NULL );

    if( f ){
        HRSRC hRes;
        HGLOBAL hResData;
        LPSTR buffer = NULL;
        hRes = FindResource( NULL, szResourceName, RT_HTML );
        if( hRes != NULL ){
            DWORD dwSize = SizeofResource( NULL, hRes );
            hResData = LoadResource( NULL, hRes );
            buffer = (LPSTR)LockResource(hResData);
            if( buffer != NULL ){
                DWORD dwSizeWritten = 0;
                BOOL bResult = WriteFile( f, buffer, dwSize, &dwSizeWritten, NULL );
                if( !bResult ){
                    dwStatus = GetLastError();
                }
            }
        }
    
        CloseHandle(f);
    
    }else{
        dwStatus = GetLastError();
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceprt\trfmtmsg.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceprt.c

Abstract:

    Trace formatting library. Converts binary trace file to CSV format,
    and other formattted string formats.

Author:

    Ian Service (IanServ) 3rd May 2000

Revision History:

    Source taken from RtlFormatMessage and adapted for the needs of TraceFmt processing.
    
    Due to the way we pre format strings and get information about 64 and 32 bit strings, the odditties
    like %p do not work correctly when handled on a machine of the other type.
    This module contains a special version of RtlFormatMessage that does fixups in conjunction
    with TracePrt's processing of ItemPtr.

--*/

#ifdef __cplusplus
extern "C"{
#endif 

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>\

#define MAX_INSERTS 200

NTSTATUS
TraceFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Column;
    int cchRemaining, cchWritten;
    PULONG_PTR ArgumentsArray = (PULONG_PTR)Arguments;
    ULONG_PTR rgInserts[ MAX_INSERTS ];
    ULONG cSpaces;
    ULONG MaxInsert, CurInsert;
    ULONG PrintParameterCount;
    ULONG_PTR PrintParameter1;
    ULONG_PTR PrintParameter2;
    WCHAR PrintFormatString[ 32 ];
    BOOLEAN DefaultedFormatString;
    WCHAR c;
    PWSTR s, s1;
    PWSTR lpDst, lpDstBeg, lpDstLastSpace;

    cchRemaining = Length / sizeof( WCHAR );
    lpDst = Buffer;
    MaxInsert = 0;
    lpDstLastSpace = NULL;
    Column = 0;
    s = MessageFormat;
    while (*s != UNICODE_NULL) {
        if (*s == L'%') {
            s++;
            lpDstBeg = lpDst;
            if (*s >= L'1' && *s <= L'9') {
                CurInsert = *s++ - L'0';
                if (*s >= L'0' && *s <= L'9') {
                    CurInsert = (CurInsert * 10) + (*s++ - L'0');
                    if (*s >= L'0' && *s <= L'9') {
                        CurInsert = (CurInsert * 10) + (*s++ - L'0');
                        if (*s >= L'0' && *s <= L'9') {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }
                    }
                CurInsert -= 1;

                PrintParameterCount = 0;
                if (*s == L'!') {
                    DefaultedFormatString = FALSE;
                    s1 = PrintFormatString;
                    *s1++ = L'%';
                    s++;
                    while (*s != L'!') {
                        if (*s != UNICODE_NULL) {
                            if (s1 >= &PrintFormatString[ 31 ]) {
                                return( STATUS_INVALID_PARAMETER );
                                }

                            if (*s == L'*') {
                                if (PrintParameterCount++ > 1) {
                                    return( STATUS_INVALID_PARAMETER );
                                    }
                                }

                            *s1++ = *s++;
                            }
                        else {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }

                    s++;
                    *s1 = UNICODE_NULL;
                    }
                else {
                    DefaultedFormatString = TRUE;
                    wcscpy( PrintFormatString, L"%s" );
                    s1 = PrintFormatString + wcslen( PrintFormatString );
                    }

                if (IgnoreInserts) {
                    if (!wcscmp( PrintFormatString, L"%s" )) {
                        cchWritten = _snwprintf( lpDst,
                                                 cchRemaining,
                                                 L"%%%u",
                                                 CurInsert+1
                                               );
                        }
                    else {
                        cchWritten = _snwprintf( lpDst,
                                                 cchRemaining,
                                                 L"%%%u!%s!",
                                                 CurInsert+1,
                                                 &PrintFormatString[ 1 ]
                                               );
                        }

                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                        }
                    }
                else
                if (ARGUMENT_PRESENT( Arguments )) {
                    if ((CurInsert+PrintParameterCount) >= MAX_INSERTS) {
                        return( STATUS_INVALID_PARAMETER );
                        }

                    if (ArgumentsAreAnsi) {
                        if (s1[ -1 ] == L'c' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hc" );
                            }
                        else
                        if (s1[ -1 ] == L's' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hs" );
                            }
                        else if (s1[ -1 ] == L'S') {
                            s1[ -1 ] = L's';
                            }
                        else if (s1[ -1 ] == L'C') {
                            s1[ -1 ] = L'c';
                            }
                        }

                    while (CurInsert >= MaxInsert) {
                        if (ArgumentsAreAnArray) {
                            rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            rgInserts[ MaxInsert++ ] = va_arg(*Arguments, ULONG_PTR);
                            }
                        }

                    s1 = (PWSTR)rgInserts[ CurInsert ];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0) {
                        if (ArgumentsAreAnArray) {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }

                        if (PrintParameterCount > 1) {
                            if (ArgumentsAreAnArray) {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                                }
                            else {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                                }
                            }
                        }
                    // Here is where we diverage and fro Trace Formatting we fixup parameters
                    // %p becomes %s because thats the way we guarantee that its 64/32 compatible
                    {
                        SIZE_T len = _tcslen(PrintFormatString);
                        if (_tcschr(PrintFormatString,L'p') != NULL || 
                            (len >= 2) && (PrintFormatString[len-2] == 'I') ||
                            (len >= 4) && (PrintFormatString[len-4] == 'I') &&
                            (PrintFormatString[len-3] == '6') &&
                            (PrintFormatString[len-2] == '4') )
                        {
                            _stprintf(PrintFormatString,_T("%%s"));
                        }
                    }
                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             PrintFormatString,
                                             s1,
                                             PrintParameter1,
                                             PrintParameter2
                                           );
                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                        }
                    }
                else {
                    return( STATUS_INVALID_PARAMETER );
                    }

                if ((cchRemaining -= cchWritten) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDst += cchWritten;
                }
            else
            if (*s == L'0') {
                break;
                }
            else
            if (!*s) {
                return( STATUS_INVALID_PARAMETER );
                }
            else
            if (*s == L'r') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L'n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L't') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (Column % 8) {
                    Column = (Column + 7) & ~7;
                    }
                else {
                    Column += 8;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L'\t';
                s++;
                }
            else
            if (*s == L'b') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L' ';
                s++;
                }
            else
            if (IgnoreInserts) {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'%';
                *lpDst++ = *s++;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = *s++;
                }

            if (lpDstBeg == NULL) {
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                Column += (ULONG)(lpDst - lpDstBeg);
                }
            }
        else {
            c = *s++;
            if (c == L'\r' || c == L'\n') {
                if ((c == L'\n' && *s == L'\r') ||
                    (c == L'\r' && *s == L'\n')
                   ) {
                    s++;
                    }

                if (MaximumWidth != 0) {
                    lpDstLastSpace = lpDst;
                    c = L' ';
                    }
                else {
                    c = L'\n';
                    }
                }


            if (c == L'\n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (c == L' ') {
                    lpDstLastSpace = lpDst;
                    }

                *lpDst++ = c;
                Column += 1;
                }
            }

        if (MaximumWidth != 0 &&
            MaximumWidth != 0xFFFFFFFF &&
            Column >= MaximumWidth
           ) {
            if (lpDstLastSpace != NULL) {
                lpDstBeg = lpDstLastSpace;
                while (*lpDstBeg == L' ' || *lpDstBeg == L'\t') {
                    lpDstBeg += 1;
                    if (lpDstBeg == lpDst) {
                        break;
                        }
                    }
                while (lpDstLastSpace > Buffer) {
                    if (lpDstLastSpace[ -1 ] == L' ' || lpDstLastSpace[ -1 ] == L'\t') {
                        lpDstLastSpace -= 1;
                        }
                    else {
                        break;
                        }
                    }

                cSpaces = (ULONG)(lpDstBeg - lpDstLastSpace);
                if (cSpaces == 1) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }
                    }
                else
                if (cSpaces > 2) {
                    cchRemaining += (cSpaces - 2);
                    }

                memmove( lpDstLastSpace + 2,
                         lpDstBeg,
                         (ULONG) ((lpDst - lpDstBeg) * sizeof( WCHAR ))
                       );
                *lpDstLastSpace++ = L'\r';
                *lpDstLastSpace++ = L'\n';
                Column = (ULONG)(lpDst - lpDstBeg);
                lpDst = lpDstLastSpace + Column;
                lpDstLastSpace = NULL;
                }
            else {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            }
        }

    if ((cchRemaining -= 1) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\0';
    if ( ARGUMENT_PRESENT(ReturnLength) ) {
        *ReturnLength = (ULONG)(lpDst - Buffer) * sizeof( WCHAR );
        }
    return( STATUS_SUCCESS );
}
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\childview.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ChildView.h : interface of the CChildView class
//////////////////////////////////////////////////////////////////////////////

#pragma once


// CChildView window

class CChildView : public CWnd
{
// Construction
public:
	CChildView();

// Attributes
public:

// Operations
public:

// Overrides
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	virtual ~CChildView();

	// Generated message map functions
protected:
	afx_msg void OnPaint();
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\formatsourceselectdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// FormatSourceSelectDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "ProviderFormatInfo.h"
#include "PathDlg.h"
#include "FormatSourceSelectDlg.h"

// CFormatSourceSelectDlg dialog

IMPLEMENT_DYNAMIC(CFormatSourceSelectDlg, CDialog)
CFormatSourceSelectDlg::CFormatSourceSelectDlg(CWnd* pParent, CTraceSession *pTraceSession)
	: CDialog(CFormatSourceSelectDlg::IDD, pParent)
{
    //
    // Store off the trace session pointer
    //
    m_pTraceSession = pTraceSession;
}

CFormatSourceSelectDlg::~CFormatSourceSelectDlg()
{
}

BOOL CFormatSourceSelectDlg::OnInitDialog()
{
    BOOL retVal;

    retVal = CDialog::OnInitDialog();

    //
    // Default to using the path select
    //
    ((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->SetCheck(BST_UNCHECKED);
    ((CButton *)GetDlgItem(IDC_TMF_SEARCH_RADIO))->SetCheck(BST_CHECKED);

    return retVal;
}

void CFormatSourceSelectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CFormatSourceSelectDlg, CDialog)
    ON_BN_CLICKED(IDC_TMF_SELECT_RADIO, OnBnClickedTmfSelectRadio)
    ON_BN_CLICKED(IDC_TMF_SEARCH_RADIO, OnBnClickedTmfSearchRadio)
END_MESSAGE_MAP()


// CFormatSourceSelectDlg message handlers

void CFormatSourceSelectDlg::OnOK()
{
    //
    // Determine which dialog to popup next
    //
    if(((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->GetCheck()) {
        //
        // Pop up the TMF select dialog
        //
        CProviderFormatInfo *pDialog = new CProviderFormatInfo(this, m_pTraceSession);
        if(pDialog == NULL) {
            EndDialog(2);

            return;
        }

        pDialog->DoModal();

	    delete pDialog;
        
        EndDialog(1);

        return;

    } else {
        //
        // Pop up the path select dialog
        //

        DWORD	flags = 0;

	    CString	path;

	    flags |= (OFN_SHOWHELP | OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLETEMPLATE);
    	
	    CPathDlg pathDlg(FALSE, NULL, NULL, flags, NULL);

        if(IDOK != pathDlg.DoModal()) {
            EndDialog(2);

            return;
        }

	    WORD    fileOffset;
        CString directory;

	    fileOffset = pathDlg.m_ofn.nFileOffset;

	    pathDlg.m_ofn.lpstrFile[fileOffset - 1] = 0;

	    directory = pathDlg.m_ofn.lpstrFile;

	    m_pTraceSession->m_tmfPath = directory + "\\";

        EndDialog(1);
    }
}

void CFormatSourceSelectDlg::OnBnClickedTmfSelectRadio()
{
    ((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->SetCheck(BST_CHECKED);
    ((CButton *)GetDlgItem(IDC_TMF_SEARCH_RADIO))->SetCheck(BST_UNCHECKED);
}

void CFormatSourceSelectDlg::OnBnClickedTmfSearchRadio()
{
    ((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->SetCheck(BST_UNCHECKED);
    ((CButton *)GetDlgItem(IDC_TMF_SEARCH_RADIO))->SetCheck(BST_CHECKED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\displaydlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// DisplayDlg.h : header for logger list dialog
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// 100 mS time limit before resorting and updating event list
//
CONST ULONG EVENT_TIME_LIMIT = 100;

// CDisplayDlg dialog

class CDisplayDlg : public CDialog
{
    DECLARE_DYNAMIC(CDisplayDlg)

public:
    CDisplayDlg(CWnd* pParent, LONG DisplayID);
    virtual ~CDisplayDlg();

    BOOL OnInitDialog();

    VOID SetDisplayFlags(LONG DisplayFlags);
    VOID AddSession(CLogSession *pLogSession);
    BOOL BeginTrace(BOOL   bUseExisting = FALSE);
    BOOL EndTrace(HANDLE DoneEvent = NULL);
    BOOL UpdateSession(CLogSession *pLogSession);
    BOOL SetupTraceSessions();
    VOID EventHandler(PEVENT_TRACE pEvent);
    void OnNcPaint();
    void OnSize(UINT nType, int cx,int cy);
    VOID RemoveSession(CLogSession *pLogSession);
    BOOL SetItemText(int nItem, int nSubItem, LPCTSTR lpszText);
    void SortTable(int Column = MaxLogSessionOptions);
    VOID WriteSummaryFile();
    VOID SetState(LOG_SESSION_STATE StateValue);
    void AutoSizeColumns();

	static UINT RealTimeEventThread(LPVOID  pParam);
    static UINT EndTraceThread(LPVOID  pParam);

    static int __cdecl CompareOnName(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnMessage(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnFileName(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnLineNumber(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnFunctionName(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnProcessId(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnThreadId(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnCpuNumber(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnSeqNumber(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnSystemTime(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnKernelTime(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnUserTime(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnIndent(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnFlagsName(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnLevelName(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnComponentName(const void *pMessage1, const void *pMessage2);
    static int __cdecl CompareOnSubComponentName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnMessage(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnFileName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnLineNumber(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnFunctionName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnProcessId(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnThreadId(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnCpuNumber(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnSeqNumber(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnSystemTime(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnKernelTime(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnUserTime(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnIndent(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnFlagsName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnLevelName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnComponentName(const void *pMessage1, const void *pMessage2);
    static int __cdecl ReverseCompareOnSubComponentName(const void *pMessage1, const void *pMessage2);

    void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    
    INLINE BOOL SetGroupActive(BOOL bActive)
    {
        LONG active = (LONG)bActive;

        return (BOOL)InterlockedExchange(&m_bGroupActive, active);
    }

    INLINE BOOL SetGroupInActive(BOOL bActive)
    {
        LONG active = (LONG)bActive;

        return (BOOL)InterlockedExchange(&m_bGroupInActive, active);
    }

    INLINE PVOID GetDockDialogBar()
    {
        return m_pDockDialogBar;
    }

    INLINE VOID SetDockDialogBar(PVOID pDockDialogBar)
    {
        m_pDockDialogBar = pDockDialogBar;
    }

    INLINE LONG GetDisplayFlags()
    {
        return m_displayFlags;
    }

    INLINE LONG GetDisplayID()
    {
        return m_displayID;
    }

    INLINE VOID SetDisplayID(LONG DisplayID)
    {
        m_displayID = DisplayID;
    }

    // Dialog Data
    enum { IDD = IDD_DISPLAY_DIALOG };

    LONG            m_displayID;
    CListCtrl       m_displayCtrl;
    PVOID           m_pDockDialogBar;
    LONG            m_displayFlags;
    CStringArray    m_columnName;
    LONG            m_columnWidth[MaxTraceSessionOptions];
    int             m_retrievalArray[MaxTraceSessionOptions + 1];
    int             m_insertionArray[MaxTraceSessionOptions + 1];
    CPtrArray       m_sessionArray;
    int             m_columnArray[MaxTraceSessionOptions];
    BOOL            m_bShowLatest;
    CWinThread     *m_pRealTimeOutputThread;        // pointer to the log session data output thread
    HANDLE          m_hRealTimeOutputThread;        // handle to the real time data output thread
    HANDLE          m_hRealTimeProcessingDoneEvent; // real time data output process complete event
    HANDLE          m_hRealTimeProcessingStartEvent;// start processing event for the real time thread
    HANDLE          m_hRealTimeTerminationEvent;    // termination event for the real time thread
    TRACEHANDLE     m_traceHandleArray[MAX_LOG_SESSIONS];
    LONG            m_traceHandleCount;
    LONG            m_totalBuffersRead;
    LONG            m_totalEventsLost;
    LONG            m_totalEventCount;
    PEVENT_CALLBACK m_pEventCallback;
    PLIST_ENTRY     m_pEventListHead;
    BOOL            m_bWriteListingFile;
    BOOL            m_bWriteSummaryFile;
    BOOL            m_bListingFileOpen;
    CStdioFile      m_listingFile;
    CString         m_listingFileName;          // File name for event output
    CString         m_summaryFileName;          // File name for summary output
    LONG            m_messageType;
    HANDLE          m_hEndTraceEvent;           // Event to signal stopping of session group
    CWinThread     *m_pEndTraceThread;          // pointer to the real time session cleanup thread
    LONG            m_bGroupActive;
    LONG            m_bGroupInActive;
    CArray<CTraceMessage*, CTraceMessage*> m_traceArray;
    HANDLE          m_hTraceEventMutex;
    HANDLE          m_hSessionArrayMutex;
    HWND            m_hMainWnd;
    TCHAR           m_pEventBuf[EVENT_BUFFER_SIZE];
    LONG            m_lastSorted;
    BOOL            m_bOrder;
    UINT_PTR        m_eventTimer;               //  Trace event update timer

    int (__cdecl *m_traceSortRoutine[MaxTraceSessionOptions])(const void *, const void *);
    int (__cdecl *m_traceReverseSortRoutine[MaxTraceSessionOptions])(const void *, const void *);

protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

public:
    //{{AFX_MSG(CDisplayDlg)
    afx_msg void OnNMClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnNMRClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnLvnBeginScrollDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnClearDisplay();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    afx_msg void OnNameDisplayColumnCheck();
    afx_msg void OnMessageDisplayColumnCheck();
    afx_msg void OnFileNameDisplayColumnCheck();
    afx_msg void OnLineNumberDisplayColumnCheck();
    afx_msg void OnFunctionNameDisplayColumnCheck();
    afx_msg void OnProcessIDDisplayColumnCheck();
    afx_msg void OnThreadIDDisplayColumnCheck();
    afx_msg void OnCpuNumberDisplayColumnCheck();
    afx_msg void OnSeqNumberDisplayColumnCheck();
    afx_msg void OnSystemTimeDisplayColumnCheck();
    afx_msg void OnKernelTimeDisplayColumnCheck();
    afx_msg void OnUserTimeDisplayColumnCheck();
    afx_msg void OnIndentDisplayColumnCheck();
    afx_msg void OnFlagsNameDisplayColumnCheck();
    afx_msg void OnLevelNameDisplayColumnCheck();
    afx_msg void OnComponentNameDisplayColumnCheck();
    afx_msg void OnSubComponentNameDisplayColumnCheck();
    afx_msg void OnTraceDone(WPARAM wParam, LPARAM lParam);
    afx_msg void OnTimer(UINT nIDEvent);

    BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    VOID CDisplayDlg::OnDoSort(NMHDR * pNmhdr, LRESULT * pResult);
};

VOID WINAPI DumpEvent0(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent1(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent2(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent3(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent4(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent5(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent6(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent7(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent8(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent9(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent10(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent11(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent12(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent13(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent14(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent15(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent16(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent17(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent18(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent19(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent20(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent21(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent22(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent23(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent24(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent25(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent26(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent27(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent28(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent29(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent30(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent31(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent32(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent33(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent34(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent35(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent36(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent37(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent38(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent39(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent40(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent41(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent42(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent43(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent44(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent45(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent46(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent47(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent48(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent49(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent50(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent51(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent52(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent53(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent54(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent55(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent56(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent57(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent58(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent59(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent60(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent61(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent62(PEVENT_TRACE pEvent);
VOID WINAPI DumpEvent63(PEVENT_TRACE pEvent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\formatsourceselectdlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// FormatSourceSelectDlg.h : CFormatSourceSelectDlg header
//////////////////////////////////////////////////////////////////////////////

#pragma once


// CFormatSourceSelectDlg dialog

class CFormatSourceSelectDlg : public CDialog
{
	DECLARE_DYNAMIC(CFormatSourceSelectDlg)

public:
	CFormatSourceSelectDlg(CWnd* pParent, CTraceSession *pTraceSession);
	virtual ~CFormatSourceSelectDlg();

    BOOL OnInitDialog();
    void OnOK();

// Dialog Data
	enum { IDD = IDD_FORMAT_INFO_SELECT };

    CTraceSession  *m_pTraceSession;
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
    afx_msg void OnBnClickedTmfSelectRadio();
    afx_msg void OnBnClickedTmfSearchRadio();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\dockdialogbar.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// DockDialogBar.cpp - implementation of the CDockDialogBar class
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "DockDialogBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDockDialogBar

IMPLEMENT_DYNAMIC(CDockDialogBar, CControlBar);

CDockDialogBar::CDockDialogBar() : 
m_clrBtnHilight(::GetSysColor(COLOR_BTNHILIGHT)),
m_clrBtnShadow(::GetSysColor(COLOR_BTNSHADOW))
{
    m_sizeMin       = CSize(32, 32);
    m_sizeHorz      = CSize(200, 200);
    m_sizeVert      = CSize(200, 200);
    m_sizeFloat     = CSize(200, 200);
    m_bTracking     = FALSE;
    m_bInRecalcNC   = FALSE;
    m_cxEdge        = 6;
	m_cxBorder      = 3;
	m_cxGripper     = 15;
	m_pDialog       = NULL;
	m_brushBkgd.CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

	m_cyBorder	    = 3;		
	m_cCaptionSize  = GetSystemMetrics(SM_CYSMCAPTION);
	m_cMinWidth	    = GetSystemMetrics(SM_CXMIN);
	m_cMinHeight	= GetSystemMetrics(SM_CYMIN);
    m_bKeepSize     = TRUE;
    m_bShowTitleInGripper = FALSE;
}

CDockDialogBar::~CDockDialogBar()
{
}

BEGIN_MESSAGE_MAP(CDockDialogBar, CControlBar)
    //{{AFX_MSG_MAP(CDockDialogBar)
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SETCURSOR()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_WINDOWPOSCHANGED()
    ON_WM_NCPAINT()
    ON_WM_NCLBUTTONDOWN()
    ON_WM_NCHITTEST()
    ON_WM_NCCALCSIZE()
    ON_WM_LBUTTONDOWN()
    ON_WM_CAPTURECHANGED()
    ON_WM_LBUTTONDBLCLK()
	ON_WM_NCLBUTTONDBLCLK()
    ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDockDialogBar message handlers

void CDockDialogBar::OnUpdateCmdUI(class CFrameWnd *pTarget, int bDisableIfNoHndler)
{
    UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

BOOL CDockDialogBar::Create(CWnd    *pParentWnd, 
                            CDialog *pDialog, 
                            CString &pTitle, 
                            UINT    nID, 
                            DWORD   dwStyle, 
                            BOOL    bShowTitleInGripper) 
{
    ASSERT_VALID(pParentWnd);   // must have a parent
    ASSERT (!((dwStyle & CBRS_SIZE_FIXED) && (dwStyle & CBRS_SIZE_DYNAMIC)));
	
    //
    // save the style
    //
    m_dwStyle = dwStyle & CBRS_ALL;

    //
    // Determine whether or not to display the title
    // in the gripper bar
    //
    m_bShowTitleInGripper = bShowTitleInGripper;

    //
    // Adjust the gripper width if necessary
    //
    if(m_bShowTitleInGripper) {
        m_cxGripper = 25;
    }

    //
	// create the base window
    //
    CString wndclass = AfxRegisterWndClass(CS_DBLCLKS, LoadCursor(NULL, IDC_ARROW),
        m_brushBkgd, 0);
    if (!CWnd::Create(wndclass, pTitle, dwStyle, CRect(0,0,0,0),
            pParentWnd, 0)) {
        return FALSE;
    }

    m_pTitle = (LPCTSTR)pTitle;

    //
	// create the child dialog
    //
	m_pDialog = pDialog;
	m_pDialog->Create(nID, this);

    //
	// use the dialog dimensions as default base dimensions
    //
	CRect rc;

    m_pDialog->GetWindowRect(rc);

    m_sizeHorz = m_sizeVert = m_sizeFloat = rc.Size();

	m_sizeHorz.cy += m_cxEdge + m_cxBorder;
	m_sizeVert.cx += m_cxEdge + m_cxBorder;

    return TRUE;
}

CSize CDockDialogBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
    CRect           rc;
    LONG            availableHeight;
    LONG            actualHeight;
    LONG            rowHeight;
    LONG            diff;
    LONG            oldDiff;
    LONG            adjustment;
    CString         str;
    LONG            ii;
    BOOL            bFound;
    BOOL            bIsMinimum;
    CDockBar       *pDockBar;
    CDockDialogBar *pBar;
    CPtrArray       barArray;

    m_pDockSite->GetControlBar(AFX_IDW_DOCKBAR_TOP)->GetWindowRect(rc);

    int nHorzDockBarWidth = bStretch ? 32767 : rc.Width() + 4;

    m_pDockSite->GetControlBar(AFX_IDW_DOCKBAR_LEFT)->GetWindowRect(rc);

    int nVertDockBarHeight = bStretch ? 32767 : rc.Height() + 4;

    if(IsFloating()) {
		return m_sizeFloat;
    }

    CFrameWnd *pFrame = GetParentFrame();

    if(pFrame == NULL) {
        if (bHorz)
            return CSize(nHorzDockBarWidth, m_sizeHorz.cy);
        else
            return CSize(m_sizeVert.cx, nVertDockBarHeight);
    }

    //
    // Get the available screen height
    //
    pFrame->GetClientRect(rc);

    ScreenToClient(rc);

    //
    // Client rect height minus the status bar height
    //
    availableHeight = rc.Height() - 18;

    actualHeight = 0;

    pDockBar = (CDockBar *)m_pDockSite->GetControlBar(AFX_IDW_DOCKBAR_TOP);

    if(pDockBar == NULL) {
        if (bHorz)
            return CSize(nHorzDockBarWidth, m_sizeHorz.cy);
        else
            return CSize(m_sizeVert.cx, nVertDockBarHeight);
    }

    bFound = FALSE;

    rowHeight = 0;

    //
    // Walk the top rows
    //
    for(ii = 0; ii < pDockBar->m_arrBars.GetSize(); ii++) {

        pBar = (CDockDialogBar *)pDockBar->m_arrBars[ii];

        if(pBar == NULL) {
            if(!bFound) {
                availableHeight -= rowHeight;
            }
            rowHeight = 0;
            continue;
        }

        if(pBar->IsKindOf(RUNTIME_CLASS(CDockDialogBar))) {
            if(!bFound && pBar != this) {
                if (bHorz)
                    return CSize(nHorzDockBarWidth, m_sizeHorz.cy);
                else
                    return CSize(m_sizeVert.cx, nVertDockBarHeight);
            }

            bFound = TRUE;

            barArray.Add(pBar);

            //
            // We position these with one border overlapping
            // so subtract one part of a border width from the size
            //
            actualHeight += (pBar->m_sizeHorz.cy - 2);

            continue;
        }

        pBar->GetWindowRect(rc);

        rowHeight = max(rowHeight, rc.Height());
    }


    pDockBar = (CDockBar *)m_pDockSite->GetControlBar(AFX_IDW_DOCKBAR_BOTTOM);

    if(pDockBar == NULL) {
        if (bHorz)
            return CSize(nHorzDockBarWidth, m_sizeHorz.cy);
        else
            return CSize(m_sizeVert.cx, nVertDockBarHeight);
    }

    bFound = FALSE;

    rowHeight = 0;

    //
    // Walk the bottom rows
    //
    for(ii = 0; ii < pDockBar->m_arrBars.GetSize(); ii++) {
        pBar = (CDockDialogBar *)pDockBar->m_arrBars[ii];

        if(pBar == NULL) {
            if(!bFound) {
                availableHeight -= rowHeight;
            }
            rowHeight = 0;
            continue;
        }

        if(pBar->IsKindOf(RUNTIME_CLASS(CDockDialogBar))) {
            bFound = TRUE;

            barArray.Add(pBar);

            //
            // We position these with one border overlapping
            // so subtract one part of a border width from the size
            //
            actualHeight += (pBar->m_sizeHorz.cy - 2);

            continue;
        }

        pBar->GetWindowRect(rc);

        rowHeight = max(rowHeight, rc.Height());
    }

    diff = availableHeight - actualHeight;

    if(diff == 0) {
        if (bHorz)
            return CSize(nHorzDockBarWidth, m_sizeHorz.cy);
        else
            return CSize(m_sizeVert.cx, nVertDockBarHeight);
    }

    adjustment = (diff > 0) ? 1 : -1;
    
    //
    // walk through our array and adjust the heights
    //
    while(diff != 0) {
        oldDiff = diff;
        for(ii = 0; ii < barArray.GetSize(); ii++) {
            pBar = (CDockDialogBar *)barArray[ii];

            if(pBar->m_bKeepSize) {
                continue;
            }
            if((pBar->m_sizeHorz.cy + adjustment) >= pBar->m_sizeMin.cy) {
                pBar->m_sizeHorz.cy += adjustment;
                diff -= adjustment;
                if(diff == 0) {
                    break;
                }
            }
        }
        if(oldDiff == diff) {
            bIsMinimum = TRUE;
            for(ii = 0; ii < barArray.GetSize(); ii++) {
                pBar = (CDockDialogBar *)barArray[ii];
                
                if(pBar->m_bKeepSize == TRUE) {
                    bIsMinimum = FALSE;
                }

                pBar->m_bKeepSize = FALSE;
            }
            if(bIsMinimum) {
                break;
            }
        }
    }

    for(ii = 0; ii < barArray.GetSize(); ii++) {
        pBar = (CDockDialogBar *)barArray[ii];

        pBar->m_bKeepSize = FALSE;
    }

    if (bHorz)
        return CSize(nHorzDockBarWidth, m_sizeHorz.cy);
    else
        return CSize(m_sizeVert.cx, nVertDockBarHeight);
}

CSize CDockDialogBar::CalcDynamicLayout(int nLength, DWORD dwMode)
{
	if (IsFloating())
	{
        // 
        // Get the frame window for this dock dialog bar
        // It better not be the main window
        //
        CFrameWnd* pFrameWnd = GetParentFrame(); 

        if ( pFrameWnd != AfxGetMainWnd() ) 
        { 
            //
            // Disable the SC_CLOSE Control for floating window 
            //
            EnableMenuItem(::GetSystemMenu(pFrameWnd->m_hWnd, FALSE),
                           SC_CLOSE,
                           MF_BYCOMMAND | MF_GRAYED); 
        } 

        //
		// Enable diagonal arrow cursor for resizing
        //
		GetParent()->GetParent()->ModifyStyle(0, MFS_4THICKFRAME);
	}    

	if (dwMode & (LM_HORZDOCK | LM_VERTDOCK))
	{
		SetWindowPos(NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER |
			SWP_NOACTIVATE | SWP_FRAMECHANGED);
	 	m_pDockSite->RecalcLayout();

	    return CControlBar::CalcDynamicLayout(nLength,dwMode);
	}

    if (dwMode & LM_MRUWIDTH)
        return m_sizeFloat;

    if (dwMode & LM_COMMIT)
    {
        m_sizeFloat.cx = nLength;
        return m_sizeFloat;
    }

	if (IsFloating())
	{
		RECT	window_rect;
		POINT	cursor_pt;
		
		GetCursorPos(&cursor_pt);
		GetParent()->GetParent()->GetWindowRect(&window_rect);
		
		switch (m_pDockContext->m_nHitTest)
		{
		case HTTOPLEFT:
			m_sizeFloat.cx = max(window_rect.right - cursor_pt.x,
				m_cMinWidth) - m_cxBorder;
			m_sizeFloat.cy = max(window_rect.bottom - m_cCaptionSize - 
				cursor_pt.y,m_cMinHeight) - 1;
			m_pDockContext->m_rectFrameDragHorz.top = min(cursor_pt.y,
				window_rect.bottom - m_cCaptionSize - m_cMinHeight) - 
				m_cyBorder;
			m_pDockContext->m_rectFrameDragHorz.left = min(cursor_pt.x,
				window_rect.right - m_cMinWidth) - 1;
			return m_sizeFloat;
			
		case HTTOPRIGHT:
			m_sizeFloat.cx = max(cursor_pt.x - window_rect.left,
				m_cMinWidth);
			m_sizeFloat.cy = max(window_rect.bottom - m_cCaptionSize - 
				cursor_pt.y,m_cMinHeight) - 1;
			m_pDockContext->m_rectFrameDragHorz.top = min(cursor_pt.y,
				window_rect.bottom - m_cCaptionSize - m_cMinHeight) - 
				m_cyBorder;
			return m_sizeFloat;
			
		case HTBOTTOMLEFT:
			m_sizeFloat.cx = max(window_rect.right - cursor_pt.x,
				m_cMinWidth) - m_cxBorder;
			m_sizeFloat.cy = max(cursor_pt.y - window_rect.top - 
				m_cCaptionSize,m_cMinHeight);
			m_pDockContext->m_rectFrameDragHorz.left = min(cursor_pt.x,
				window_rect.right - m_cMinWidth) - 1;
			return m_sizeFloat;
			
		case HTBOTTOMRIGHT:
			m_sizeFloat.cx = max(cursor_pt.x - window_rect.left,
				m_cMinWidth);
			m_sizeFloat.cy = max(cursor_pt.y - window_rect.top - 
				m_cCaptionSize,m_cMinHeight);
			return m_sizeFloat;
		}
	}
	
	if (dwMode & LM_LENGTHY)
        return CSize(m_sizeFloat.cx,
            m_sizeFloat.cy = max(m_sizeMin.cy, nLength));
    else
        return CSize(max(m_sizeMin.cx, nLength), m_sizeFloat.cy);
}

void CDockDialogBar::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanging(lpwndpos);
}

void CDockDialogBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanged(lpwndpos);

	if(!::IsWindow(m_hWnd) || m_pDialog==NULL)
		return;
	if(!::IsWindow(m_pDialog->m_hWnd))
		return;
    if (m_bInRecalcNC) 
	{
		CRect rc;
		GetClientRect(rc);
		m_pDialog->MoveWindow(rc);
		return;
	}

    //
    // Find on which side are we docked
    //
    UINT nDockBarID = GetParent()->GetDlgCtrlID();

    //
    // Return if dropped at same location
    //
    if (nDockBarID == m_nDockBarID // no docking side change
        && (lpwndpos->flags & SWP_NOSIZE) // no size change
        && ((m_dwStyle & CBRS_BORDER_ANY) != CBRS_BORDER_ANY))
        return; 

    m_nDockBarID = nDockBarID;

    //
    // Force recalc the non-client area
    //
    m_bInRecalcNC = TRUE;
    SetWindowPos(NULL, 0,0,0,0,
        SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
    m_bInRecalcNC = FALSE;
}

BOOL CDockDialogBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
    if ((nHitTest != HTSIZE) || m_bTracking)
        return CControlBar::OnSetCursor(pWnd, nHitTest, message);

    if (IsHorz())
        SetCursor(LoadCursor(NULL, IDC_SIZENS));
    else
        SetCursor(LoadCursor(NULL, IDC_SIZEWE));
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// Mouse Handling
//
void CDockDialogBar::OnLButtonUp(UINT nFlags, CPoint point) 
{
    if (!m_bTracking)
        CControlBar::OnLButtonUp(nFlags, point);
    else
    {
        ClientToWnd(point);
        StopTracking(TRUE);
    }
}

void CDockDialogBar::OnMouseMove(UINT nFlags, CPoint point) 
{
    if (IsFloating() || !m_bTracking)
    {
        CControlBar::OnMouseMove(nFlags, point);
        return;
    }

    CPoint cpt = m_rectTracker.CenterPoint();

    ClientToWnd(point);

    if (IsHorz())
    {
        if (cpt.y != point.y)
        {
            OnInvertTracker(m_rectTracker);
            m_rectTracker.OffsetRect(0, point.y - cpt.y);
            OnInvertTracker(m_rectTracker);
        }
    }
    else 
    {
        if (cpt.x != point.x)
        {
            OnInvertTracker(m_rectTracker);
            m_rectTracker.OffsetRect(point.x - cpt.x, 0);
            OnInvertTracker(m_rectTracker);
        }
    }
}

void CDockDialogBar::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp) 
{
    //
    // Compute the rectangle of the mobile edge
    //
    GetWindowRect(m_rectBorder);
    m_rectBorder = CRect(0, 0, m_rectBorder.Width(), m_rectBorder.Height());
    
    DWORD dwBorderStyle = m_dwStyle | CBRS_BORDER_ANY;

    switch(m_nDockBarID)
    {
    case AFX_IDW_DOCKBAR_TOP:
        dwBorderStyle &= ~CBRS_BORDER_BOTTOM;
        lpncsp->rgrc[0].left += m_cxGripper;
        lpncsp->rgrc[0].bottom += -m_cxEdge;
        lpncsp->rgrc[0].top += m_cxBorder;
        lpncsp->rgrc[0].right += -m_cxBorder;
	    m_rectBorder.top = m_rectBorder.bottom - m_cxEdge;
        break;
    case AFX_IDW_DOCKBAR_BOTTOM:
        dwBorderStyle &= ~CBRS_BORDER_TOP;
        lpncsp->rgrc[0].left += m_cxGripper;
        lpncsp->rgrc[0].top += m_cxEdge;
        lpncsp->rgrc[0].bottom += -m_cxBorder;
        lpncsp->rgrc[0].right += -m_cxBorder;
        m_rectBorder.bottom = m_rectBorder.top + m_cxEdge;
        break;
    case AFX_IDW_DOCKBAR_LEFT:
        dwBorderStyle &= ~CBRS_BORDER_RIGHT;
        lpncsp->rgrc[0].right += -m_cxEdge;
        lpncsp->rgrc[0].left += m_cxBorder;
        lpncsp->rgrc[0].bottom += -m_cxBorder;
        lpncsp->rgrc[0].top += m_cxGripper;
        m_rectBorder.left = m_rectBorder.right - m_cxEdge;
        break;
    case AFX_IDW_DOCKBAR_RIGHT:
        dwBorderStyle &= ~CBRS_BORDER_LEFT;
        lpncsp->rgrc[0].left += m_cxEdge;
        lpncsp->rgrc[0].right += -m_cxBorder;
        lpncsp->rgrc[0].bottom += -m_cxBorder;
        lpncsp->rgrc[0].top += m_cxGripper;
        m_rectBorder.right = m_rectBorder.left + m_cxEdge;
        break;
    default:
        m_rectBorder.SetRectEmpty();
        break;
    }

    SetBarStyle(dwBorderStyle);
}

void CDockDialogBar::OnNcPaint() 
{
    EraseNonClient();

	CWindowDC dc(this);
    dc.Draw3dRect(m_rectBorder, GetSysColor(COLOR_BTNHIGHLIGHT),
                    GetSysColor(COLOR_BTNSHADOW));

	DrawGripper(dc);
	
	CRect pRect;
	GetClientRect( &pRect );
	InvalidateRect( &pRect, TRUE );
}

void CDockDialogBar::OnNcLButtonDown(UINT nHitTest, CPoint point) 
{
    if (m_bTracking) return;

	if((nHitTest == HTSYSMENU) && !IsFloating())
        GetDockingFrame()->ShowControlBar(this, FALSE, FALSE);
    else if ((nHitTest == HTMINBUTTON) && !IsFloating())
        m_pDockContext->ToggleDocking();
	else if ((nHitTest == HTCAPTION) && !IsFloating() && (m_pDockBar != NULL))
    {
        // start the drag
        ASSERT(m_pDockContext != NULL);
        m_pDockContext->StartDrag(point);
    }
    else if ((nHitTest == HTSIZE) && !IsFloating()) {
        m_bKeepSize = TRUE;

        StartTracking();
    } else {
        CControlBar::OnNcLButtonDown(nHitTest, point);
    }
}

UINT CDockDialogBar::OnNcHitTest(CPoint point) 
{
    if (IsFloating())
        return CControlBar::OnNcHitTest(point);

    CRect rc;
    GetWindowRect(rc);
    point.Offset(-rc.left, -rc.top);
	if(m_rectClose.PtInRect(point))
		return HTSYSMENU;
	else if (m_rectUndock.PtInRect(point))
		return HTMINBUTTON;
	else if (m_rectGripper.PtInRect(point))
		return HTCAPTION;
    else if (m_rectBorder.PtInRect(point))
        return HTSIZE;
    else
        return CControlBar::OnNcHitTest(point);
}

void CDockDialogBar::OnLButtonDown(UINT nFlags, CPoint point) 
{
    //
    // only start dragging if clicked in "void" space
    //
    if (m_pDockBar != NULL)
    {
        //
        // start the drag
        //
        ASSERT(m_pDockContext != NULL);
        ClientToScreen(&point);
        m_pDockContext->StartDrag(point);
    }
    else
    {
        CWnd::OnLButtonDown(nFlags, point);
    }
}

void CDockDialogBar::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
    //
    // only toggle docking if clicked in "void" space
    //
    if (m_pDockBar != NULL)
    {
        //
        // toggle docking
        //
        ASSERT(m_pDockContext != NULL);
        m_pDockContext->ToggleDocking();
    }
    else
    {
        CWnd::OnLButtonDblClk(nFlags, point);
    }
}

void CDockDialogBar::StartTracking()
{
    SetCapture();

    //
    // make sure no updates are pending
    //
    RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW);
    m_pDockSite->LockWindowUpdate();

    m_ptOld = m_rectBorder.CenterPoint();
    m_bTracking = TRUE;
    
    m_rectTracker = m_rectBorder;
    if (!IsHorz()) m_rectTracker.bottom -= 4;

    OnInvertTracker(m_rectTracker);
}

void CDockDialogBar::OnCaptureChanged(CWnd *pWnd) 
{
    if (m_bTracking && pWnd != this)
        //
        // cancel tracking
        //
        StopTracking(FALSE);

    CControlBar::OnCaptureChanged(pWnd);
}

void CDockDialogBar::StopTracking(BOOL bAccept)
{
    CDockDialogBar *pBar;
    CDockBar       *pDockBar;
    LONG            beforeIndex;
    LONG            afterIndex;
    LONG            ii;
    BOOL            bFound = FALSE;

    OnInvertTracker(m_rectTracker);
    m_pDockSite->UnlockWindowUpdate();
    m_bTracking = FALSE;
    ReleaseCapture();
    
    if (!bAccept) return;

    int maxsize, minsize, newsize;
    CRect rcc;
    m_pDockSite->GetWindowRect(rcc);

    newsize = IsHorz() ? m_sizeHorz.cy : m_sizeVert.cx;
    maxsize = newsize + (IsHorz() ? rcc.Height() : rcc.Width());
    minsize = IsHorz() ? m_sizeMin.cy : m_sizeMin.cx;

    CPoint point = m_rectTracker.CenterPoint();
    switch (m_nDockBarID)
    {
    case AFX_IDW_DOCKBAR_TOP:
        newsize += point.y - m_ptOld.y; break;
    case AFX_IDW_DOCKBAR_BOTTOM:
        newsize += -point.y + m_ptOld.y; break;
    case AFX_IDW_DOCKBAR_LEFT:
        newsize += point.x - m_ptOld.x; break;
    case AFX_IDW_DOCKBAR_RIGHT:
        newsize += -point.x + m_ptOld.x; break;
    }

    pDockBar = (CDockBar *)m_pDockSite->GetControlBar(AFX_IDW_DOCKBAR_TOP);

    //
    // Mark all bars to keep their size
    //
    for(ii = 0; ii < pDockBar->m_arrBars.GetSize(); ii++) {

        pBar = (CDockDialogBar *)pDockBar->m_arrBars[ii];

        if(pBar == NULL) {
            continue;
        }

        if(pBar->IsKindOf(RUNTIME_CLASS(CDockDialogBar))) {
            //
            // Mark all bars to keep their size for now
            //
            pBar->m_bKeepSize = TRUE;
        }
    }

    //
    // Have all windows keep there size except those directly next
    // to the window changing size if possible.  Normally only the 
    // window below, or after, the window changing size will need
    // to change size as well, unless the user attempted to resize
    // the window to smaller than its minimum.  Then both the window
    // above and below will need to change size.
    //
    for(ii = 0; ii < pDockBar->m_arrBars.GetSize(); ii++) {

        pBar = (CDockDialogBar *)pDockBar->m_arrBars[ii];

        if(pBar == NULL) {
            continue;
        }

        if(pBar->IsKindOf(RUNTIME_CLASS(CDockDialogBar))) {
            //
            // Mark all bars to keep their size for now
            //
            pBar->m_bKeepSize = TRUE;

            if(pBar == this) {
                bFound = TRUE;
                continue;
            }

            if(bFound) {
                afterIndex = ii;
                break;
            }

            if(!bFound) {
                beforeIndex = ii;
            }
        }
    }

    //
    // The window below, or after the one being modified will 
    // alway need to change size
    //
    pBar = (CDockDialogBar *)pDockBar->m_arrBars[afterIndex];

    pBar->m_bKeepSize = FALSE;

    //
    // If the modified window is being shrunk past its minimum
    // then the window above, or before this one needs to change
    // as well
    //
    if(newsize < minsize) {
        pBar = (CDockDialogBar *)pDockBar->m_arrBars[beforeIndex];

        pBar->m_bKeepSize = FALSE;
    }

    newsize = max(minsize, min(maxsize, newsize));

    if (IsHorz())
        m_sizeHorz.cy = newsize;
    else
        m_sizeVert.cx = newsize;

    m_pDockSite->RecalcLayout();
}

void CDockDialogBar::OnInvertTracker(const CRect& rect)
{
    ASSERT_VALID(this);
    ASSERT(!rect.IsRectEmpty());
    ASSERT(m_bTracking);

    CRect rct = rect, rcc, rcf;
    GetWindowRect(rcc);
    m_pDockSite->GetWindowRect(rcf);

    rct.OffsetRect(rcc.left - rcf.left, rcc.top - rcf.top);
    rct.DeflateRect(1, 1);

    CDC *pDC = m_pDockSite->GetDCEx(NULL,
        DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);

    CBrush* pBrush = CDC::GetHalftoneBrush();
    HBRUSH hOldBrush = NULL;
    if (pBrush != NULL)
        hOldBrush = (HBRUSH)SelectObject(pDC->m_hDC, pBrush->m_hObject);

    pDC->PatBlt(rct.left, rct.top, rct.Width(), rct.Height(), PATINVERT);

    if (hOldBrush != NULL)
        SelectObject(pDC->m_hDC, hOldBrush);

    m_pDockSite->ReleaseDC(pDC);
}

BOOL CDockDialogBar::IsHorz() const
{
    return (m_nDockBarID == AFX_IDW_DOCKBAR_TOP ||
        m_nDockBarID == AFX_IDW_DOCKBAR_BOTTOM);
}

CPoint& CDockDialogBar::ClientToWnd(CPoint& point)
{
    if (m_nDockBarID == AFX_IDW_DOCKBAR_BOTTOM)
        point.y += m_cxEdge;
    else if (m_nDockBarID == AFX_IDW_DOCKBAR_RIGHT)
        point.x += m_cxEdge;

    return point;
}

void CDockDialogBar::DrawGripper(CDC & dc)
{
    CString groupNumber;

    //
    // no gripper if floating
    //
    if( m_dwStyle & CBRS_FLOATING ) {
		return;
    }

	m_pDockSite->RecalcLayout();
	CRect gripper;
	GetWindowRect( gripper );
	ScreenToClient( gripper );
	gripper.OffsetRect( -gripper.left, -gripper.top );
	
	if( m_dwStyle & CBRS_ORIENT_HORZ ) {
	
        //
		// gripper at left
        //
		m_rectGripper.top		= gripper.top;
		m_rectGripper.bottom	= gripper.bottom;
		m_rectGripper.left		= gripper.left;

        m_rectGripper.right = gripper.left + 15;

		gripper.top += 10;
		gripper.bottom -= 10;
		gripper.left += 5;
		gripper.right = gripper.left + 3;

        //
        // Draw first bar
        //
        dc.Draw3dRect(gripper, m_clrBtnHilight, m_clrBtnShadow);

        gripper.OffsetRect(4, 0);

        //
        // Draw second bar
        //
        dc.Draw3dRect(gripper, m_clrBtnHilight, m_clrBtnShadow);

        //
        // Display title if requested
        //
        if(m_bShowTitleInGripper) {
            gripper.OffsetRect(8, 0);

            gripper.DeflateRect(-4, 0);

            dc.SelectStockObject(SYSTEM_FONT);
            dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
            dc.SetTextColor(GetSysColor(COLOR_3DSHADOW));

            //
            // Gripper title format -- ID #
            //
            dc.DrawText('I', gripper, DT_CENTER);
            gripper.OffsetRect(0, 8);
            gripper.DeflateRect(0, 8);

            dc.DrawText('D', gripper, DT_CENTER);
            gripper.OffsetRect(0, 8);
            gripper.DeflateRect(0, 8);

            dc.DrawText(' ', gripper, DT_CENTER);
            gripper.OffsetRect(0, 4);
            gripper.DeflateRect(0, 4);

            groupNumber = m_pTitle.Right(m_pTitle.GetLength() - m_pTitle.ReverseFind(' ') - 1);

            for(int ii = 0; ii < groupNumber.GetLength(); ii++) {
                dc.DrawText(groupNumber[ii], gripper, DT_CENTER);
                gripper.OffsetRect(0, 8);
                gripper.DeflateRect(0, 8);
            }
        }
	}
	
	else {
		
        //
		// gripper at top
        //
		m_rectGripper.top		= gripper.top;
		m_rectGripper.bottom	= gripper.top + 20;
		m_rectGripper.left		= gripper.left;
		m_rectGripper.right		= gripper.right - 10;

		gripper.right -= 38;
		gripper.left += 5;
		gripper.top += 10;
		gripper.bottom = gripper.top + 3;
        dc.Draw3dRect( gripper, RGB(0, 255, 0), RGB(0, 255, 255));
		
		gripper.OffsetRect(0, 4);
        dc.Draw3dRect( gripper, RGB(255, 255, 0), RGB(255, 0, 0));
	}

}

void CDockDialogBar::OnNcLButtonDblClk(UINT nHitTest, CPoint point) 
{
    if ((m_pDockBar != NULL) && (nHitTest == HTCAPTION))
    {
        //
        // toggle docking
        //
        ASSERT(m_pDockContext != NULL);
        m_pDockContext->ToggleDocking();
    }
    else
    {
        CWnd::OnNcLButtonDblClk(nHitTest, point);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\displaydlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// DisplayDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <ks.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "logsession.h"
#include "DockDialogBar.h"
#include "DisplayDlg.h"
#include "utils.h"

// GLOBALS

//
// global event callbacks
// We need these because there is no context we can
// pass into the trace event callback routines, thus 
// we must have a unique callback for each instance 
// of this class.  We can't use a global hash like
// we are doing for the buffer callbacks, as we don't
// get any information in the EVENT_TRACE struct that
// allows us to lookup a value.  This struct is filled
// in by the call to FormatTraceEvents, and we are
// supposed to treat this struct as opaque.  We must 
// have a unique EventListHead for the call to 
// FormatTraceEvents, so we need these separate callbacks.
// Yuck!
//
PEVENT_CALLBACK g_pDumpEvent[MAX_LOG_SESSIONS];

//
// Global hash table used in the event callbacks
// to get the proper CDisplayDlg instance.
//
CMapWordToPtr g_displayIDToDisplayDlgHash(16);

//
// Global hash table used in the buffer callback
// to get the proper CDisplayDlg instance.
//
CMapStringToPtr g_loggerNameToDisplayDlgHash(16);

//
// Yet another global hash table, this one is used
// to prevent multiple sessions from starting using
// the same format GUIDs.  Format info as it turns out
// is stored in a global hash table in traceprt.dll.
// If multiple sessions in the same process attempt 
// to use the same format GUID, only one entry is 
// entered into the traceprt hash as expected.  But,
// the hash entries are removed when a session ends.
// So, if multiple sessions in the same process were
// use the same format GUID, as soon as one of those
// sessions ended, the other sessions will lose their
// hash entries.
//
CMapStringToPtr g_formatInfoHash(16);

//
// Synchronization event for GetTraceGuids, FormatTraceEvent,
// and CleanupEventListHead in traceprt.dll.  These are not 
// inherently thread safe.
//
HANDLE g_hGetTraceEvent = CreateEvent(NULL, FALSE, TRUE, NULL);

//
// Buffer callback prototype
//
ULONG WINAPI BufferCallback(PEVENT_TRACE_LOGFILE Buffer);

//
// Memory Tracking
//
BOOLEAN RecoveringMemory = FALSE;
LONG MaxTraceEntries = 50000;

// CDisplayDlg dialog

IMPLEMENT_DYNAMIC(CDisplayDlg, CDialog)
CDisplayDlg::CDisplayDlg(CWnd* pParent, LONG DisplayID)
    : CDialog(CDisplayDlg::IDD, pParent)
{
    ASSERT(DisplayID < MAX_LOG_SESSIONS);

    //
    // Get a handle to the main frame
    //
    m_hMainWnd = pParent->GetSafeHwnd();

    //
    // Save the ID for this DisplayDlg
    //
    m_displayID = DisplayID;

    //
    // Setup the default flags and names for the listing and summary files
    //
    m_bWriteListingFile = FALSE;
    m_bWriteSummaryFile = FALSE;
    m_listingFileName.Format(_T("Output%d.out"), m_displayID);
    m_summaryFileName.Format(_T("Summary%d.sum"), m_displayID);

    //
    // initialize the column names
    //
    m_columnName.Add("Name");
    m_columnName.Add("File Name");
    m_columnName.Add("Line#");
    m_columnName.Add("Func Name");
    m_columnName.Add("Process ID");
    m_columnName.Add("Thread ID");
    m_columnName.Add("CPU#");
    m_columnName.Add("Sequence#");
    m_columnName.Add("System Time");
    m_columnName.Add("Kernel Time");
    m_columnName.Add("User Time");
    m_columnName.Add("Indent");
    m_columnName.Add("Flags Name");
    m_columnName.Add("Level Name");
    m_columnName.Add("Component Name");
    m_columnName.Add("SubComponent Name");
    m_columnName.Add("Message");

    //
    // Set the initial column widths
    //
    for(LONG ii = 0; ii < MaxTraceSessionOptions; ii++) {
        m_columnWidth[ii] = 100;
    }

    //
    // Set the default display flags
    //
    m_displayFlags = TRACEOUTPUT_DISPLAY_PROVIDERNAME |
                     TRACEOUTPUT_DISPLAY_MESSAGE      | 
                     TRACEOUTPUT_DISPLAY_FILENAME     |
                     TRACEOUTPUT_DISPLAY_LINENUMBER   |
                     TRACEOUTPUT_DISPLAY_FUNCTIONNAME |
                     TRACEOUTPUT_DISPLAY_PROCESSID    |
                     TRACEOUTPUT_DISPLAY_THREADID     |
                     TRACEOUTPUT_DISPLAY_CPUNUMBER    |
                     TRACEOUTPUT_DISPLAY_SEQNUMBER    |
                     TRACEOUTPUT_DISPLAY_SYSTEMTIME;

    //
    // setup the lookup tables for the column positions
    //
    for(LONG ii = 0; ii < MaxTraceSessionOptions; ii++) {
        //
        // This lookup table allows a retrieval of the current 
        // position of a given column like m_retrievalArray[Flags]
        // will return the correct column value for the Flags
        // column
        //
        m_retrievalArray[ii] = ii;

        //
        // This lookup table allows correct placement of 
        // a column being added.  So, if the Flags column
        // needed to be inserted, then m_insertionArray[Flags]
        // would give the correct insertion column value
        //
        m_insertionArray[ii] = ii;
    }

    //
    // initialize the dock dialog bar pointer
    //
    m_pDockDialogBar = NULL;

    //
    // Show latest event trace entry
    //
    m_bShowLatest = TRUE;

    //
    // Setup the sort related compare function table
    // There are two functions for each column, an 
    // ascending compare and a descending compare.
    //
    m_traceSortRoutine[ProviderName]    = CompareOnName;
    m_traceSortRoutine[Message]         = CompareOnMessage;
    m_traceSortRoutine[FileName]        = CompareOnFileName;
    m_traceSortRoutine[LineNumber]      = CompareOnLineNumber;
    m_traceSortRoutine[FunctionName]    = CompareOnFunctionName;
    m_traceSortRoutine[ProcessId]       = CompareOnProcessId;
    m_traceSortRoutine[ThreadId]        = CompareOnThreadId;
    m_traceSortRoutine[CpuNumber]       = CompareOnCpuNumber;
    m_traceSortRoutine[SeqNumber]       = CompareOnSeqNumber;
    m_traceSortRoutine[SystemTime]      = CompareOnSystemTime;
    m_traceSortRoutine[KernelTime]      = CompareOnKernelTime;
    m_traceSortRoutine[UserTime]        = CompareOnUserTime;
    m_traceSortRoutine[Indent]          = CompareOnIndent;
    m_traceSortRoutine[FlagsName]       = CompareOnFlagsName;
    m_traceSortRoutine[LevelName]       = CompareOnLevelName;
    m_traceSortRoutine[ComponentName]   = CompareOnComponentName;
    m_traceSortRoutine[SubComponentName]= CompareOnSubComponentName;
    m_traceReverseSortRoutine[ProviderName]    = ReverseCompareOnName;
    m_traceReverseSortRoutine[Message]         = ReverseCompareOnMessage;
    m_traceReverseSortRoutine[FileName]        = ReverseCompareOnFileName;
    m_traceReverseSortRoutine[LineNumber]      = ReverseCompareOnLineNumber;
    m_traceReverseSortRoutine[FunctionName]    = ReverseCompareOnFunctionName;
    m_traceReverseSortRoutine[ProcessId]       = ReverseCompareOnProcessId;
    m_traceReverseSortRoutine[ThreadId]        = ReverseCompareOnThreadId;
    m_traceReverseSortRoutine[CpuNumber]       = ReverseCompareOnCpuNumber;
    m_traceReverseSortRoutine[SeqNumber]       = ReverseCompareOnSeqNumber;
    m_traceReverseSortRoutine[SystemTime]      = ReverseCompareOnSystemTime;
    m_traceReverseSortRoutine[KernelTime]      = ReverseCompareOnKernelTime;
    m_traceReverseSortRoutine[UserTime]        = ReverseCompareOnUserTime;
    m_traceReverseSortRoutine[Indent]          = ReverseCompareOnIndent;
    m_traceReverseSortRoutine[FlagsName]       = ReverseCompareOnFlagsName;
    m_traceReverseSortRoutine[LevelName]       = ReverseCompareOnLevelName;
    m_traceReverseSortRoutine[ComponentName]   = ReverseCompareOnComponentName;
    m_traceReverseSortRoutine[SubComponentName]= ReverseCompareOnSubComponentName;

    //
    // Zero our column array buffer
    //
    memset(m_columnArray, 0, sizeof(int) * MaxTraceSessionOptions);

    //
    // Setup the array of event handler pointers
    //
    g_pDumpEvent[0] = DumpEvent0;
    g_pDumpEvent[1] = DumpEvent1;
    g_pDumpEvent[2] = DumpEvent2;
    g_pDumpEvent[3] = DumpEvent3;
    g_pDumpEvent[4] = DumpEvent4;
    g_pDumpEvent[5] = DumpEvent5;
    g_pDumpEvent[6] = DumpEvent6;
    g_pDumpEvent[7] = DumpEvent7;
    g_pDumpEvent[8] = DumpEvent8;
    g_pDumpEvent[9] = DumpEvent9;
    g_pDumpEvent[10] = DumpEvent10;
    g_pDumpEvent[11] = DumpEvent11;
    g_pDumpEvent[12] = DumpEvent12;
    g_pDumpEvent[13] = DumpEvent13;
    g_pDumpEvent[14] = DumpEvent14;
    g_pDumpEvent[15] = DumpEvent15;
    g_pDumpEvent[16] = DumpEvent16;
    g_pDumpEvent[17] = DumpEvent17;
    g_pDumpEvent[18] = DumpEvent18;
    g_pDumpEvent[19] = DumpEvent19;
    g_pDumpEvent[20] = DumpEvent20;
    g_pDumpEvent[21] = DumpEvent21;
    g_pDumpEvent[22] = DumpEvent22;
    g_pDumpEvent[23] = DumpEvent23;
    g_pDumpEvent[24] = DumpEvent24;
    g_pDumpEvent[25] = DumpEvent25;
    g_pDumpEvent[26] = DumpEvent26;
    g_pDumpEvent[27] = DumpEvent27;
    g_pDumpEvent[28] = DumpEvent28;
    g_pDumpEvent[29] = DumpEvent29;
    g_pDumpEvent[30] = DumpEvent30;
    g_pDumpEvent[31] = DumpEvent31;
    g_pDumpEvent[32] = DumpEvent32;
    g_pDumpEvent[33] = DumpEvent33;
    g_pDumpEvent[34] = DumpEvent34;
    g_pDumpEvent[35] = DumpEvent35;
    g_pDumpEvent[36] = DumpEvent36;
    g_pDumpEvent[37] = DumpEvent37;
    g_pDumpEvent[38] = DumpEvent38;
    g_pDumpEvent[39] = DumpEvent39;
    g_pDumpEvent[40] = DumpEvent40;
    g_pDumpEvent[41] = DumpEvent41;
    g_pDumpEvent[42] = DumpEvent42;
    g_pDumpEvent[43] = DumpEvent43;
    g_pDumpEvent[44] = DumpEvent44;
    g_pDumpEvent[45] = DumpEvent45;
    g_pDumpEvent[46] = DumpEvent46;
    g_pDumpEvent[47] = DumpEvent47;
    g_pDumpEvent[48] = DumpEvent48;
    g_pDumpEvent[49] = DumpEvent49;
    g_pDumpEvent[50] = DumpEvent50;
    g_pDumpEvent[51] = DumpEvent51;
    g_pDumpEvent[52] = DumpEvent52;
    g_pDumpEvent[53] = DumpEvent53;
    g_pDumpEvent[54] = DumpEvent54;
    g_pDumpEvent[55] = DumpEvent55;
    g_pDumpEvent[56] = DumpEvent56;
    g_pDumpEvent[57] = DumpEvent57;
    g_pDumpEvent[58] = DumpEvent58;
    g_pDumpEvent[59] = DumpEvent59;
    g_pDumpEvent[60] = DumpEvent60;
    g_pDumpEvent[61] = DumpEvent61;
    g_pDumpEvent[62] = DumpEvent62;
    g_pDumpEvent[63] = DumpEvent63;

    // 
    // Put this session in the global hash table by display ID
    //
    g_displayIDToDisplayDlgHash.SetAt((WORD)m_displayID, this);

    //
    // Set our event callback
    //
    m_pEventCallback = g_pDumpEvent[m_displayID];

    //
    // Set our event list head to NULL
    //
    m_pEventListHead = NULL;

    //
    // initialize the group flags
    //
    m_bGroupActive = FALSE;
    m_bGroupInActive = FALSE;

    //
    // Initialize the end trace event
    //
    m_hEndTraceEvent = NULL;

    //
    // Initialize the last sorted column value to be
    // an invalid column so as to not sort, we track
    // the column so sorts can be reversed.
    //
    m_lastSorted = MaxTraceSessionOptions;

    //
    // Sort order for trace array, TRUE == descending, FALSE == ascending
    //
    m_bOrder = TRUE;

    //
    // Initialize handles
    //
    m_hRealTimeOutputThread = INVALID_HANDLE_VALUE;
    m_hRealTimeProcessingDoneEvent = NULL;
    m_hRealTimeProcessingStartEvent = NULL;
    m_hRealTimeTerminationEvent = NULL;
    m_hTraceEventMutex = NULL;
    m_hSessionArrayMutex = NULL;
}

CDisplayDlg::~CDisplayDlg()
{
    ULONG           exitCode = STILL_ACTIVE;
    CTraceViewApp  *pMainWnd;

    //
    // Clear the trace log
    //

    //
    // Get a pointer to the app
    //
    pMainWnd = (CTraceViewApp *)AfxGetApp();

    //
    // Get our trace event array protection
    //
    WaitForSingleObject(m_hTraceEventMutex,INFINITE);

    //
    // Send all elements to be freed
    //
    int elCount;
    
    elCount = (int)m_traceArray.GetSize();

    while (elCount > 0 ) {

        delete m_traceArray.GetAt( --elCount );
    }

    //
    // Remove the elements from the array
    //
    m_traceArray.RemoveAll();

    //
    // Release our trace event array protection
    //
    ReleaseMutex(m_hTraceEventMutex);

    //
    // empty the list control
    //
    m_displayCtrl.DeleteAllItems();

    //
    // Reset the flag
    //
    exitCode = STILL_ACTIVE;

    //
    // Terminate the real time thread
    //
    SetEvent(m_hRealTimeTerminationEvent);
    
    // 
    // Wait on the real time thread to exit
    //
    for(LONG ii = 0; (ii < 200) && (exitCode == STILL_ACTIVE); ii++) {
        if(0 == GetExitCodeThread(m_hRealTimeOutputThread, &exitCode)) {
            break;
        }
        Sleep(100);

        //
        // set the event again just in case
        //
        SetEvent(m_hRealTimeTerminationEvent);
    }

    //
    // We waited 20 seconds and the thread didn't die, so kill it
    //
    if(exitCode == STILL_ACTIVE) {
        TerminateThread(m_hRealTimeOutputThread, 0);
    }

    m_hRealTimeOutputThread = INVALID_HANDLE_VALUE;

    // 
    // Pull this DisplayDlg out of the global hash table
    //
    g_displayIDToDisplayDlgHash.RemoveKey((WORD)m_displayID);

    //
    // The dialog bar should be deleted after this object,
    // but this pointer better be NULL when we are deleted
    //
    ASSERT(NULL == m_pDockDialogBar);

    //
    // Close any open handles
    //
    if(m_hRealTimeProcessingDoneEvent != NULL) {
        CloseHandle(m_hRealTimeProcessingDoneEvent);
    }

    if(m_hRealTimeProcessingStartEvent != NULL) {
        CloseHandle(m_hRealTimeProcessingStartEvent);
    }

    if(m_hRealTimeTerminationEvent != NULL) {
        CloseHandle(m_hRealTimeTerminationEvent);
    }

    if(m_hTraceEventMutex != NULL) {
        CloseHandle(m_hTraceEventMutex);
    }

    if(m_hSessionArrayMutex != NULL) {
        CloseHandle(m_hSessionArrayMutex);
    }
}

void CDisplayDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CDisplayDlg, CDialog)
    //{{AFX_MSG_MAP(CDisplayDlg)
    ON_MESSAGE(WM_USER_TRACE_DONE, OnTraceDone)
    ON_MESSAGE(WM_USER_AUTOSIZECOLUMNS, AutoSizeColumns)
    ON_WM_NCCALCSIZE()
    ON_WM_SIZE()
    ON_WM_TIMER()
    ON_WM_INITMENUPOPUP()
    ON_NOTIFY(LVN_GETDISPINFO, IDC_DISPLAY_LIST, OnGetDispInfo)
    ON_NOTIFY(NM_CLICK, IDC_DISPLAY_LIST, OnNMClickDisplayList)
    ON_NOTIFY(NM_RCLICK, IDC_DISPLAY_LIST, OnNMRClickDisplayList)
    ON_NOTIFY(LVN_BEGINSCROLL, IDC_DISPLAY_LIST, OnLvnBeginScrollDisplayList)
    ON_NOTIFY(HDN_ITEMCLICK, 0, OnDoSort)
    ON_COMMAND(ID__AUTOSIZECOLUMNS, AutoSizeColumns)
    ON_COMMAND(ID__CLEARDISPLAY, OnClearDisplay)
    ON_COMMAND(ID__NAME, OnNameDisplayColumnCheck)
    ON_COMMAND(ID__MESSAGE, OnMessageDisplayColumnCheck)
    ON_COMMAND(ID__FILENAME, OnFileNameDisplayColumnCheck)
    ON_COMMAND(ID__LINENUMBER, OnLineNumberDisplayColumnCheck)
    ON_COMMAND(ID__FUNCTIONNAME, OnFunctionNameDisplayColumnCheck)
    ON_COMMAND(ID__PROCESSID, OnProcessIDDisplayColumnCheck)
    ON_COMMAND(ID__THREADID, OnThreadIDDisplayColumnCheck)
    ON_COMMAND(ID__CPUNUMBER, OnCpuNumberDisplayColumnCheck)
    ON_COMMAND(ID__SEQUENCENUMBER, OnSeqNumberDisplayColumnCheck)
    ON_COMMAND(ID__SYSTEMTIME, OnSystemTimeDisplayColumnCheck)
    ON_COMMAND(ID__KERNELTIME, OnKernelTimeDisplayColumnCheck)
    ON_COMMAND(ID__USERTIME, OnUserTimeDisplayColumnCheck)
    ON_COMMAND(ID__INDENT, OnIndentDisplayColumnCheck)
    ON_COMMAND(ID__FLAGSNAME, OnFlagsNameDisplayColumnCheck)
    ON_COMMAND(ID__LEVELNAME, OnLevelNameDisplayColumnCheck)
    ON_COMMAND(ID__COMPONENTNAME, OnComponentNameDisplayColumnCheck)
    ON_COMMAND(ID__SUBCOMPONENTNAME, OnSubComponentNameDisplayColumnCheck)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////////
// CDisplayDlg message handlers

BOOL CDisplayDlg::OnInitDialog()
{
    RECT    rc;
    RECT    parentRC;
    BOOL    retVal;
    CString str;

    retVal = CDialog::OnInitDialog();

    //
    // Setup the protection for our trace event array
    //
    m_hTraceEventMutex = CreateMutex(NULL,TRUE,NULL);

    if(m_hTraceEventMutex == NULL) {

        DWORD error = GetLastError();

        str.Format(_T("CreateMutex Error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    ReleaseMutex(m_hTraceEventMutex);


    //
    // Setup the protection for our log session array
    //
    m_hSessionArrayMutex = CreateMutex(NULL,TRUE,NULL);

    if(m_hSessionArrayMutex == NULL) {

        DWORD error = GetLastError();

        str.Format(_T("CreateMutex Error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    ReleaseMutex(m_hSessionArrayMutex);

    //
    // Create the events for the real time thread operation
    //
    m_hRealTimeTerminationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(NULL == m_hRealTimeTerminationEvent) {

        DWORD error = GetLastError();

        str.Format(_T("CreateEvent Error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    m_hRealTimeProcessingStartEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(NULL == m_hRealTimeProcessingStartEvent) {

        DWORD error = GetLastError();

        str.Format(_T("CreateEvent Error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    m_hRealTimeProcessingDoneEvent  = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(NULL == m_hRealTimeProcessingDoneEvent) {

        DWORD error = GetLastError();

        str.Format(_T("CreateEvent Error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    //
    // spawn a thread to handle real time events
    //
    m_pRealTimeOutputThread = AfxBeginThread((AFX_THREADPROC)RealTimeEventThread,
                                             this,
                                             THREAD_PRIORITY_LOWEST,
                                             0,
                                             CREATE_SUSPENDED);

    //
    // save the thread handle
    //
    DuplicateHandle(GetCurrentProcess(),
                    m_pRealTimeOutputThread->m_hThread,
                    GetCurrentProcess(),
                    &m_hRealTimeOutputThread,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS);

    //
    // start the thread
    //
    ResumeThread(m_pRealTimeOutputThread->m_hThread);

    //
    // get the parent dimensions
    //
    GetParent()->GetParent()->GetClientRect(&parentRC);

    //
    // get the dialog dimensions
    //
    GetWindowRect(&rc);

    //
    // adjust the list control dimensions
    //
    rc.right = parentRC.right - parentRC.left - 24;
    rc.bottom = rc.bottom - rc.top;
    rc.left = 0;
    rc.top = 0;

    //
    // Create the list control
    //
    if(!m_displayCtrl.Create(WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT|LVS_OWNERDATA,
                             rc, 
                             this, 
                             IDC_DISPLAY_LIST)) 
    {
        TRACE(_T("Failed to create logger list control\n"));
        return FALSE;
    }

    return retVal;
}

void CDisplayDlg::OnNcPaint() 
{
    CRect pRect;

    GetClientRect(&pRect);
    InvalidateRect(&pRect, TRUE);
}

VOID CDisplayDlg::SetDisplayFlags(LONG DisplayFlags)
{
    LONG    addDisplayFlags = ~m_displayFlags & DisplayFlags;
    LONG    removeDisplayFlags = m_displayFlags & ~DisplayFlags;
    LONG    updateDisplayFlags = m_displayFlags & DisplayFlags;
    BOOL    bChanged = FALSE;
    LONG    ii;
    LONG    jj;
    LONG    kk;
    LONG    ll;
    CString str;

    //
    // Insert any new columns and remove any uneeded
    //
    for(ii = 0; ii < MaxTraceSessionOptions; ii++) {
        //
        // add the columns
        //
        if(addDisplayFlags & (1 << ii)) {
            //
            // add the column
            //
            m_displayCtrl.InsertColumn(m_insertionArray[ii], 
                                       m_columnName[ii],
                                       LVCFMT_LEFT,
                                       m_columnWidth[ii]);

            //
            // update the column positions
            //
            for(kk = 0, ll = 0; kk < MaxTraceSessionOptions; kk++) {
                m_insertionArray[kk] = ll;
                if(DisplayFlags & (1 << kk)) {
                    m_retrievalArray[ll] = kk;
                    ll++;
                }
            }
        }

        //
        // remove the columns
        //
        if(removeDisplayFlags & (1 << ii)) {
            //
            // delete the column
            //
            m_displayCtrl.DeleteColumn(m_insertionArray[ii]);

            //
            // update the column positions
            //
            for(kk = 0, ll = 0; kk < MaxTraceSessionOptions; kk++) {
                m_insertionArray[kk] = ll;
                if(DisplayFlags & (1 << kk)) {
                    m_retrievalArray[ll] = kk;
                    ll++;
                }
            }
        }
    }

    //
    // Save the new display flags
    //
    m_displayFlags = DisplayFlags;

    //
    // Save the new column order array
    //
    memset(m_columnArray, 0, sizeof(int) * MaxTraceSessionOptions);
    m_displayCtrl.GetColumnOrderArray(m_columnArray);
}

VOID CDisplayDlg::AddSession(CLogSession *pLogSession)
{
    ULONG flags;

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    //
    // Add the log session to the list
    //
    m_sessionArray.Add(pLogSession);

    //
    // Is this the first session?
    //
    if(m_sessionArray.GetSize() == 1) {
        //
        // Force the columns to get updated for first time
        //
        flags = GetDisplayFlags();
        m_displayFlags = 0;
        SetDisplayFlags(flags);

        //
        // Fix the widths of the columns
        //
        AutoSizeColumns();
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);
}

VOID CDisplayDlg::RemoveSession(CLogSession *pLogSession)
{
    LONG        traceDisplayFlags;
    PVOID       pHashEntry;
    CString     hashEntryKey;
    POSITION    pos;

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    for(LONG ii = (LONG)m_sessionArray.GetSize() - 1; ii >= 0; ii--) {
        if(pLogSession == (CLogSession *)m_sessionArray[ii]) {
            m_sessionArray.RemoveAt(ii);

            break;
        }
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    //
    // Remove TMF info from our global hash, if any.
    //
    for(pos = g_formatInfoHash.GetStartPosition(); pos != NULL; )
    {
        g_formatInfoHash.GetNextAssoc(pos, hashEntryKey, pHashEntry);

        if(pHashEntry == (PVOID)pLogSession) {
            g_formatInfoHash.RemoveKey(hashEntryKey);
        }
    }

    //
    // Force an update of the displayed columns
    //
    traceDisplayFlags = GetDisplayFlags();

    //
    // Update the display flags and thus the display
    //
    SetDisplayFlags(traceDisplayFlags);
}

void CDisplayDlg::OnSize(UINT nType, int cx,int cy) 
{
    CRect rc;

    if(!IsWindow(m_displayCtrl.GetSafeHwnd())) 
    {
        return;
    }

    GetParent()->GetClientRect(&rc);

    //
    // reset the size of the dialog to follow the frame
    //
    SetWindowPos(NULL, 
                 0,
                 0,
                 rc.right - rc.left,
                 rc.bottom - rc.top,
                 SWP_NOMOVE|SWP_SHOWWINDOW|SWP_NOZORDER);

    GetClientRect(&rc);

    //
    // Reset the size and position of the list control in the dialog
    //
    m_displayCtrl.MoveWindow(rc);
}


BOOL CDisplayDlg::PreTranslateMessage(MSG* pMsg)
{
    if(pMsg->message == WM_KEYDOWN) 
    { 
        //
        // Ignore the escape key, otherwise 
        // the client area grays out on escape
        //
        if(pMsg->wParam == VK_ESCAPE) { 
            // ignore the key 
            return TRUE; 
        } 

        //
        // For the return key, we set the list control 
        // to always scroll to the last item
        //
        if(pMsg->wParam == VK_RETURN) {

            //
            // Start showing the latest entries in the list
            //
            m_bShowLatest = TRUE;

            return TRUE;
        }

        //
        // Fix for key accelerators, otherwise they are never
        // processed
        //
        if (AfxGetMainWnd()->PreTranslateMessage(pMsg)) {
            return TRUE;
        }
    } 

    return CDialog::PreTranslateMessage(pMsg);
}

void CDisplayDlg::OnNMClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
    //
    // Stop automatic scrolling to latest list control entry
    // Hit enter to start auto scrolling again
    //
    m_bShowLatest = FALSE;

    *pResult = 0;
}

void CDisplayDlg::OnNMRClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
    CString         str;
    DWORD           position;
    int             listIndex;
    LVHITTESTINFO   lvhti;

    //
    // Get the position of the mouse when this 
    // message posted
    //
    position = ::GetMessagePos();

    //
    // Get the position in an easy to use format
    //
    CPoint  point((int) LOWORD (position), (int)HIWORD(position));

    //
    // Convert to screen coordinates
    //
    CPoint  screenPoint(point);

    //
    // If there are entries in the event array, then pop-up
    // the menu to allow autosize columns and clear display
    //
    CMenu menu;
    menu.LoadMenu(IDR_TRACE_SESSION_POPUP_MENU);
    CMenu* pPopup = menu.GetSubMenu(0);
    ASSERT(pPopup != NULL);

    pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, screenPoint.x, screenPoint.y, this);

    *pResult = 0;
}

void CDisplayDlg::OnLvnBeginScrollDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
    //
    // This feature requires Internet Explorer 5.5 or greater.
    // The symbol _WIN32_IE must be >= 0x0560.
    //
    LPNMLVSCROLL pStateChanged = reinterpret_cast<LPNMLVSCROLL>(pNMHDR);

    //
    // If someone grabs the scroll handle,
    // stop the list control from scrolling
    // 
    m_bShowLatest = FALSE;

    *pResult = 0;
}

void CDisplayDlg::OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)
{
    CString         str;
    LV_DISPINFO    *pDispInfo = (LV_DISPINFO*)pNMHDR;
    LV_ITEM        *pItem;
    int             index;
    int             item = 0;
    int             subItem = 0;
    LPWSTR          outStr;
    CString         tempString;
    CString         tempString2;
    CTraceMessage  *pTraceMessage;

    if(pDispInfo == NULL) {
        return;
    }

    //
    // list control cell information
    //
    pItem = &pDispInfo->item;

    //
    // Get the cell item and subitem locators
    //
    item = pItem->iItem;
    subItem = pItem->iSubItem;

    //
    // Get the string pointer we need to fill in
    //
    outStr = pItem->pszText;

    //
    // Check that this is a text buffer request
    //
    if(!(pItem->mask & LVIF_TEXT)) {
        return;
    }

    //
    // Make sure the text requested is text we have
    //
    if((m_traceArray.GetSize() == 0) || 
            (item >= m_traceArray.GetSize()) ||
            (item < 0)) {
        _tcscpy(outStr,_T(""));
        return;
    }

    //
    // Get our trace event array protection
    //
    WaitForSingleObject(m_hTraceEventMutex,INFINITE);

    //
    // Get the message from the array
    //
    pTraceMessage = m_traceArray[item];

    //
    // Release our trace event array protection
    //
    ReleaseMutex(m_hTraceEventMutex);

    if(NULL == pTraceMessage) {
        _tcscpy(outStr,_T(""));
        return;
    }

    CTime kernelTime(pTraceMessage->m_KernelTime);
    CTime userTime(pTraceMessage->m_UserTime);

//    if( (pTraceMessage->m_UserTime.dwLowDateTime != 0) && (pTraceMessage->m_UserTime.dwHighDateTime != 0) )  {
//            CTime userTime1(pTraceMessage->m_UserTime);
//            userTime = userTime1;
//    }

    //
    // Copy the proper portion of the message to the out string
    //

    switch(m_retrievalArray[subItem]) {
        case ProviderName:
            _tcscpy(outStr, pTraceMessage->m_GuidName);
            break;
    
        case Message:  {

            _tcsncpy(outStr, pTraceMessage->m_Message, pItem->cchTextMax-4);

            outStr[pItem->cchTextMax-4] = 0x00;

            if( (pItem->cchTextMax-4) <= 
                 (int)_tcslen(pTraceMessage->m_Message) )  {
                 _tcscat(outStr, _T("..."));
            }

            break;
        }


        case FileName:
            //
            // Filename and line number are combined in a single string
            // so we have to parse them out.  The format is generally 
            // something like this:
            //
            //      myfile_c389
            //
            // Where myfile.c is where the event occurred and on line 389.
            // This field can also signify a type of message, as in the
            // Kernel Logger case, for example, so if there is no underscore
            // we assume this is the case and we just print out the whole
            // field.
            //
            if(pTraceMessage->m_GuidTypeName.Find('_') > 0) {
                tempString = (LPCTSTR)pTraceMessage->m_GuidTypeName.Left(pTraceMessage->m_GuidTypeName.Find('_'));
                if(tempString.IsEmpty()) {
                    //
                    // Copy the string back to the list control
                    //
                    _tcscpy(outStr, tempString);
                    return;
                }

                // 
                // Get the extension
                //
                tempString += ".";

                tempString2 = (LPCTSTR)pTraceMessage->m_GuidTypeName.Right(pTraceMessage->m_GuidTypeName.GetLength() - pTraceMessage->m_GuidTypeName.Find('_') - 1);

                tempString += (LPCTSTR)tempString2.Left(tempString2.FindOneOf(_T("0123456789")));
            } else {
                tempString = (LPCTSTR)pTraceMessage->m_GuidTypeName;
            }

            _tcscpy(outStr, tempString);
            break;

        case LineNumber:
            //
            // Filename and line number are combined in a single string
            // so we have to parse them out.  The format is generally 
            // something like this:
            //
            //      myfile_c389
            //
            // Where myfile.c is where the event occurred and on line 389.
            // This field can also signify a type of message, as in the
            // Kernel Logger case, for example, so if there is no underscore
            // we assume this is the case and we print nothing for the line
            // number.
            //
            if(pTraceMessage->m_GuidTypeName.Find('_') > 0) {
                tempString2 = 
                    pTraceMessage->m_GuidTypeName.Right(pTraceMessage->m_GuidTypeName.GetLength() - 
                        pTraceMessage->m_GuidTypeName.Find('_') - 1);

                tempString2 = 
                    tempString2.Right(tempString2.GetLength() - 
                        tempString2.FindOneOf(_T("0123456789")));
            } else {
                tempString2.Empty();
            }

            _tcscpy(outStr, tempString2);
            break;

        case FunctionName:
            _tcscpy(outStr, pTraceMessage->m_FunctionName);
            break;

        case ProcessId:
            if((LONG)pTraceMessage->m_ProcessId >= 0) {
                tempString.Format(_T("%d"), pTraceMessage->m_ProcessId);
            } else {
                tempString.Empty();
            }
            _tcscpy(outStr, tempString);
            break;

        case ThreadId:
            if((LONG)pTraceMessage->m_ThreadId >= 0) {
                tempString.Format(_T("%d"), pTraceMessage->m_ThreadId);
            } else {
                tempString.Empty();
            }
            _tcscpy(outStr, tempString);
            break;

        case CpuNumber:
            if((LONG)pTraceMessage->m_CpuNumber >= 0) {
                tempString.Format(_T("%d"), pTraceMessage->m_CpuNumber);
            } else {
                tempString.Empty();
            }
            _tcscpy(outStr, tempString);
            break;

        case SeqNumber:
            if((LONG)pTraceMessage->m_SequenceNum >= 0) {
                tempString.Format(_T("%d"), pTraceMessage->m_SequenceNum);
            } else {
                tempString.Empty();
            }
            
            _tcscpy(outStr, tempString);
            break;

        case SystemTime:

            tempString.Format(_T("%02d\\%02d\\%4d-%02d:%02d:%02d:%02d"),
                                  pTraceMessage->m_SystemTime.wMonth,
                                  pTraceMessage->m_SystemTime.wDay,
                                  pTraceMessage->m_SystemTime.wYear,
                                  pTraceMessage->m_SystemTime.wHour,
                                  pTraceMessage->m_SystemTime.wMinute,
                                  pTraceMessage->m_SystemTime.wSecond,
                                  pTraceMessage->m_SystemTime.wMilliseconds);

            _tcscpy(outStr, tempString);
            break;

        case KernelTime:
            //
            // We have to do an ugly conversion here.  If the year is 1969, 
            // then the time was blank.
            //
            if( (kernelTime == -1) || (kernelTime.GetYear() == 1969)) {
                tempString.Format(_T(""));
            } else {
                tempString.Format(_T("%s-%02d:%02d:%02d"),                     
                                    kernelTime.Format("%m\\%d\\%Y"),
                                    kernelTime.GetHour() + 5,
                                    kernelTime.GetMinute(),
                                    kernelTime.GetSecond());
            }
            _tcscpy(outStr, tempString);
            break;

        case UserTime:
            //
            // We have to do an ugly conversion here.  If the year is 1969 or
            // 1970 then the time was blank.
            //
            if( (userTime == -1) || (userTime.GetYear() == 1969) || (userTime.GetYear() == 1970) ) {
                tempString.Format(_T(""));
            } else {
                tempString.Format(_T("%s-%02d:%02d:%02d"),                     
                                    userTime.Format("%m\\%d\\%Y"),
                                    userTime.GetHour() + 5,
                                    userTime.GetMinute(),
                                    userTime.GetSecond());
            }
            _tcscpy(outStr, tempString);
            break;

        case Indent:
            tempString.Format(_T("%d"), pTraceMessage->m_Indent);
            _tcscpy(outStr, tempString);
            break;

        case FlagsName:
            _tcscpy(outStr, pTraceMessage->m_FlagsName);
            break;

        case LevelName:
            _tcscpy(outStr, pTraceMessage->m_LevelName);
            break;

        case ComponentName:
            _tcscpy(outStr, pTraceMessage->m_ComponentName);
            break;

        case SubComponentName:
            _tcscpy(outStr, pTraceMessage->m_SubComponentName);
            break;

        default:
            //
            // Default to empty string
            //
            _tcscpy(outStr,_T(""));
            break;
    }
}

void CDisplayDlg::OnClearDisplay()
{
    CTraceMessage  *pTraceMessage;
    CTraceViewApp  *pMainWnd;

    //
    // Clear the trace log
    //

    //
    // Get a pointer to the main frame
    //
    pMainWnd = (CTraceViewApp *)AfxGetApp();

    //
    // Get our trace event array protection
    //
    WaitForSingleObject(m_hTraceEventMutex,INFINITE);

    int elCount;
    
    elCount = (int)m_traceArray.GetSize();

    while (elCount > 0 ) {

        delete m_traceArray.GetAt( --elCount );
    }

    //
    // Remove the elements from the array
    //
    m_traceArray.RemoveAll();

    //
    // Release our trace event array protection
    //
    ReleaseMutex(m_hTraceEventMutex);

    //
    // Clear the list control
    //
    m_displayCtrl.DeleteAllItems();

    //
    // Reset the output to always show latest
    //
    m_bShowLatest = TRUE;
}

void CDisplayDlg::AutoSizeColumns() 
{
    LONG            colWidth1;
    LONG            colWidth2;
    LONG            columnCount;
    CHeaderCtrl    *pHeaderCtrl;

    //
    // Get the list control header
    //
    pHeaderCtrl = m_displayCtrl.GetHeaderCtrl();

    if (pHeaderCtrl != NULL)
    {
        //
        // Get number of columns
        //
        columnCount = pHeaderCtrl->GetItemCount();

        for(LONG ii = 0; ii < (columnCount - 1); ii++) {
            //
            // Get the max width of the column entries
            //
            m_displayCtrl.SetColumnWidth(ii, LVSCW_AUTOSIZE);
            colWidth1 = m_displayCtrl.GetColumnWidth(ii);

            //
            // Get the width of the column header
            //
            m_displayCtrl.SetColumnWidth(ii, LVSCW_AUTOSIZE_USEHEADER);
            colWidth2 = m_displayCtrl.GetColumnWidth(ii);

            //
            // Set the column width to the max of the two
            // Special case the first column??  Seems to be off
            // a couple of pixels
            //
            if(0 == ii) {
                m_displayCtrl.SetColumnWidth(ii, max(colWidth1,colWidth2) + 2);
            } else {
                m_displayCtrl.SetColumnWidth(ii, max(colWidth1,colWidth2));
            }

            //
            // Save the column width
            //
            m_columnWidth[m_retrievalArray[ii]] = m_displayCtrl.GetColumnWidth(ii);
        }

        //
        // Special case the message column.  The last column is usually
        // limited to only be as wide as needed.  But, if the message
        // column is the last column, then use up all available space.
        //
        if(m_retrievalArray[columnCount - 1] != Message) {
            //
            // Get the column width of the last column
            //
            colWidth2 = m_displayCtrl.GetColumnWidth(columnCount - 1);

            //
            // Get the max width of the column entries for the last column
            //
            m_displayCtrl.SetColumnWidth(columnCount - 1, LVSCW_AUTOSIZE);

            colWidth1 = m_displayCtrl.GetColumnWidth(columnCount - 1);

            //
            // Set the last column width to the max of the two
            //
            m_displayCtrl.SetColumnWidth(columnCount - 1, max(colWidth1,colWidth2));

            //
            // Save the column width
            //
            m_columnWidth[m_retrievalArray[columnCount - 1]] = m_displayCtrl.GetColumnWidth(columnCount - 1);
        } else {
            //
            // Set the width of the column to use the remaining space
            //
            m_displayCtrl.SetColumnWidth(columnCount - 1, 
                                         LVSCW_AUTOSIZE_USEHEADER);

            //
            // Save the column width
            //
            m_columnWidth[m_retrievalArray[columnCount - 1]] = 
                        m_displayCtrl.GetColumnWidth(columnCount - 1);
        }
    }
}

void CDisplayDlg::OnNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the Name flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_PROVIDERNAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_PROVIDERNAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_PROVIDERNAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnMessageDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the Message flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_MESSAGE) {
        flags &= ~TRACEOUTPUT_DISPLAY_MESSAGE;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_MESSAGE;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnFileNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the FileName flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_FILENAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_FILENAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_FILENAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnLineNumberDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the LineNumber flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_LINENUMBER) {
        flags &= ~TRACEOUTPUT_DISPLAY_LINENUMBER;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_LINENUMBER;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnFunctionNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the FunctionName flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_FUNCTIONNAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_FUNCTIONNAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_FUNCTIONNAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnProcessIDDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the ProcessID flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_PROCESSID) {
        flags &= ~TRACEOUTPUT_DISPLAY_PROCESSID;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_PROCESSID;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnThreadIDDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the Thread ID flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_THREADID) {
        flags &= ~TRACEOUTPUT_DISPLAY_THREADID;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_THREADID;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnCpuNumberDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the CPU Number flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_CPUNUMBER) {
        flags &= ~TRACEOUTPUT_DISPLAY_CPUNUMBER;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_CPUNUMBER;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnSeqNumberDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the Sequence Number flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_SEQNUMBER) {
        flags &= ~TRACEOUTPUT_DISPLAY_SEQNUMBER;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_SEQNUMBER;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnSystemTimeDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the SystemTime flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_SYSTEMTIME) {
        flags &= ~TRACEOUTPUT_DISPLAY_SYSTEMTIME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_SYSTEMTIME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnKernelTimeDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the KernelTime flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_KERNELTIME) {
        flags &= ~TRACEOUTPUT_DISPLAY_KERNELTIME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_KERNELTIME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnUserTimeDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the UserTime flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_USERTIME) {
        flags &= ~TRACEOUTPUT_DISPLAY_USERTIME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_USERTIME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnIndentDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the Indent flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_INDENT) {
        flags &= ~TRACEOUTPUT_DISPLAY_INDENT;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_INDENT;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnFlagsNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the FlagsName flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_FLAGSNAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_FLAGSNAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_FLAGSNAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnLevelNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the LevelName flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_LEVELNAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_LEVELNAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_LEVELNAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnComponentNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the ComponentName flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_COMPNAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_COMPNAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_COMPNAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

void CDisplayDlg::OnSubComponentNameDisplayColumnCheck()
{
    LONG flags;

    //
    // Get the current flag values
    //
    flags = GetDisplayFlags();

    //
    // Toggle the SubComponentName flag value
    //
    if(flags & TRACEOUTPUT_DISPLAY_SUBCOMPNAME) {
        flags &= ~TRACEOUTPUT_DISPLAY_SUBCOMPNAME;
    } else {
        flags |= TRACEOUTPUT_DISPLAY_SUBCOMPNAME;
    }

    //
    // Update the flag values and thus the display
    //
    SetDisplayFlags(flags);
}

BOOL CDisplayDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
    HD_NOTIFY   *pHDN = (HD_NOTIFY*)lParam;
    LPNMHDR     pNH = (LPNMHDR) lParam; 

    //
    // wParam is zero for Header ctrl
    //
    if(wParam == 0 && pNH->code == NM_RCLICK) {
        //
        // Right button was clicked on header
        //

        //
        // Determine where the right click occurred and pop-up
        // a menu there
        //
        CPoint pt(GetMessagePos());

        CHeaderCtrl *pHeader = m_displayCtrl.GetHeaderCtrl();

        pHeader->ScreenToClient(&pt);
        
        CPoint screenPoint(GetMessagePos());

        CMenu menu;
        menu.LoadMenu(IDR_TRACE_DISPLAY_OPTION_POPUP_MENU);
        CMenu* pPopup = menu.GetSubMenu(0);
        ASSERT(pPopup != NULL);
        
        pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                               screenPoint.x, 
                               screenPoint.y, 
                               this);

        return TRUE;
    } else if(wParam == 0 && pNH->code == NM_RELEASEDCAPTURE) {
        //
        // Column header was pressed and now released
        //

        POINT           Point;
        CHeaderCtrl    *pHeader = m_displayCtrl.GetHeaderCtrl();
        int             columnArray[MaxTraceSessionOptions];

        GetCursorPos (&Point);
        ScreenToClient(&Point);
        
        HDHITTESTINFO HitTest;
       
        //
        //Offset of right scrolling  
        //
        HitTest.pt.x = Point.x + GetScrollPos(SB_HORZ);
        HitTest.pt.y = Point.y;
        
        //
        //Send the hit test message
        //
        pHeader->SendMessage(HDM_HITTEST,0,(LPARAM)&HitTest);

        //
        // We check here if the column order changed.  If so, then
        // we don't want to cause a sort of the column items, the user
        // had to press the column header to drag the column around.
        //
        memset(columnArray, 0, sizeof(int) * MaxTraceSessionOptions);

        m_displayCtrl.GetColumnOrderArray(columnArray);

        if(memcmp(m_columnArray, columnArray, sizeof(int) * MaxTraceSessionOptions)) {
            //
            // Column order changed, save the new order
            //
            memcpy(m_columnArray, columnArray, sizeof(int) * MaxTraceSessionOptions);

            //
            // Now call the default handler and return
            //
            return CDialog::OnNotify(wParam, lParam, pResult);
        } 

        if(HitTest.iItem >= 0) {
            //
            // Now check for column resize
            //
            if(m_displayCtrl.GetColumnWidth(HitTest.iItem) != m_columnWidth[m_retrievalArray[HitTest.iItem]]) {
                //
                // Save off the new column width and don't sort the column
                //
                m_columnWidth[m_retrievalArray[HitTest.iItem]] = m_displayCtrl.GetColumnWidth(HitTest.iItem);

                //
                // Now call the default handler and return
                //
                return CDialog::OnNotify(wParam, lParam, pResult);
            }

//            //
//            // Sort the table by this column's data
//            //
//            SortTable(HitTest.iItem);
//
//            //
//            // Force a redraw of the data
//            //
//            m_displayCtrl.RedrawItems(m_displayCtrl.GetTopIndex(), 
//                                      m_displayCtrl.GetTopIndex() + m_displayCtrl.GetCountPerPage());
//
//            m_displayCtrl.UpdateWindow();
        }
    }

    //
    // Now call the default handler and return
    //
    return CDialog::OnNotify(wParam, lParam, pResult);
}

void CDisplayDlg::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
    //
    // Call the default handler
    //
    CDialog::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);

    //
    // As CDisplayDlg corresponds to a non-CFrameWnd window, OF COURSE 
    // you have to overload this handler and explicitly set the check 
    // state of each item in the popup menu.  It is utterly, 
    // absolutely, and intuitively obvious as to why this is 
    // necessary, thus it won't be explained here
    //


    //
    // Trace session pop-up menu
    //

    //
    // Disable the clear display option, if there are no
    // traces displayed
    //
    if(m_traceArray.GetSize() == 0) {
        pPopupMenu->EnableMenuItem(ID__CLEARDISPLAY, MF_GRAYED);
    }


    //
    // Trace display option pop-up menu
    //

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_PROVIDERNAME) {
        pPopupMenu->CheckMenuItem(ID__NAME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_MESSAGE) {
        pPopupMenu->CheckMenuItem(ID__MESSAGE, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_FILENAME) {
        pPopupMenu->CheckMenuItem(ID__FILENAME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_LINENUMBER) {
        pPopupMenu->CheckMenuItem(ID__LINENUMBER, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_FUNCTIONNAME) {
        pPopupMenu->CheckMenuItem(ID__FUNCTIONNAME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_PROCESSID) {
        pPopupMenu->CheckMenuItem(ID__PROCESSID, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_THREADID) {
        pPopupMenu->CheckMenuItem(ID__THREADID, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_CPUNUMBER) {
        pPopupMenu->CheckMenuItem(ID__CPUNUMBER, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_SEQNUMBER) {
        pPopupMenu->CheckMenuItem(ID__SEQUENCENUMBER, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_SYSTEMTIME) {
        pPopupMenu->CheckMenuItem(ID__SYSTEMTIME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_KERNELTIME) {
        pPopupMenu->CheckMenuItem(ID__KERNELTIME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_USERTIME) {
        pPopupMenu->CheckMenuItem(ID__USERTIME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_INDENT) {
        pPopupMenu->CheckMenuItem(ID__INDENT, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_FLAGSNAME) {
        pPopupMenu->CheckMenuItem(ID__FLAGSNAME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_LEVELNAME) {
        pPopupMenu->CheckMenuItem(ID__LEVELNAME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_COMPNAME) {
        pPopupMenu->CheckMenuItem(ID__COMPONENTNAME, MF_CHECKED);
    }

    if(GetDisplayFlags() & TRACEOUTPUT_DISPLAY_SUBCOMPNAME) {
        pPopupMenu->CheckMenuItem(ID__SUBCOMPONENTNAME, MF_CHECKED);
    }
}

void CDisplayDlg::SortTable(int Column)
{
    CString str;

    //
    // Use qsort with the proper compare routine.  We use qsort
    // versus the list control's own sort functionality as its
    // actually more flexible for this case.  We don't have to 
    // parse the item data during the sorts this way.  The native
    // sort wouldn't buy us anything.
    //

    //
    // Get our trace event array protection
    //
    WaitForSingleObject(m_hTraceEventMutex,INFINITE);

    //
    // Check the column to see if its in range, if not just sort
    // by the last selected column
    //
    if(Column < MaxLogSessionOptions) {

        if(m_lastSorted != m_retrievalArray[Column]) {

            //
            // If this column has not been used to sort the trace event
            // data before, then sort ascending
            //
            m_bOrder = TRUE;

        } else {
            //
            // If this column has been used before, then reverse the order
            // of the sort (column header was selected again)
            //
            m_bOrder = (m_bOrder == TRUE ? FALSE : TRUE);
        }

        //
        // Save the column
        //
        m_lastSorted = m_retrievalArray[Column];

    } else if(m_lastSorted >= MaxLogSessionOptions) {

        //
        // Release our trace event array protection
        //
        ReleaseMutex(m_hTraceEventMutex);

        str.Format(_T("m_lastSorted = %d"), m_lastSorted);
        return;

    }

    //
    // Determine whether to sort ascending or descending and call
    // qsort with the proper callback
    //
    if(m_bOrder) {
        qsort((PVOID)&m_traceArray[0], m_traceArray.GetSize(), sizeof(CTraceMessage *), m_traceSortRoutine[m_lastSorted]);
    } else {
        qsort((PVOID)&m_traceArray[0], m_traceArray.GetSize(), sizeof(CTraceMessage *), m_traceReverseSortRoutine[m_lastSorted]);
    }

    //
    // Release our trace event array protection
    //
    ReleaseMutex(m_hTraceEventMutex);
}

int CDisplayDlg::CompareOnName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_GuidName.Compare(pTraceMessage2->m_GuidName));
}

int CDisplayDlg::CompareOnMessage(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_Message.Compare(pTraceMessage2->m_Message));
}

int CDisplayDlg::CompareOnFileName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_GuidTypeName.Compare(pTraceMessage2->m_GuidTypeName));
}

int CDisplayDlg::CompareOnLineNumber(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage  *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage  *pTraceMessage2 = *(CTraceMessage **)pMessage2;
    CString         string1;
    CString         string2;
    DWORD           val1, val2;

    //
    // Get Line number string for the first element
    //
    string1 = 
        pTraceMessage1->m_GuidTypeName.Right(pTraceMessage1->m_GuidTypeName.GetLength() - 
            pTraceMessage1->m_GuidTypeName.Find('_') - 1);

    string1 = 
        string1.Right(string1.GetLength() - 
            string1.FindOneOf(_T("0123456789")));

    string2 = 
        pTraceMessage2->m_GuidTypeName.Right(pTraceMessage2->m_GuidTypeName.GetLength() - 
            pTraceMessage2->m_GuidTypeName.Find('_') - 1);

    //
    // Get the line number string for the second element
    //
    string2 = 
        string2.Right(string2.GetLength() - 
            string2.FindOneOf(_T("0123456789")));

    TCHAR * end;

    val1 = _tcstoul(string1, &end, 10);
    val2 = _tcstoul(string2, &end,10);

    if(val1 == val2)  {
        return(0);
    }

    if(val1 < val2)  {
        return(-1);
    }

    return(1);
}

int CDisplayDlg::CompareOnFunctionName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_FunctionName.Compare(pTraceMessage2->m_FunctionName));
}

int CDisplayDlg::CompareOnProcessId(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage1->m_ProcessId - (LONG)pTraceMessage2->m_ProcessId);
}

int CDisplayDlg::CompareOnThreadId(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage1->m_ThreadId - (LONG)pTraceMessage2->m_ThreadId);
}

int CDisplayDlg::CompareOnCpuNumber(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage1->m_CpuNumber - (LONG)pTraceMessage2->m_CpuNumber);
}

int CDisplayDlg::CompareOnSeqNumber(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage1->m_SequenceNum - (LONG)pTraceMessage2->m_SequenceNum);
}

int CDisplayDlg::CompareOnSystemTime(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage  *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage  *pTraceMessage2 = *(CTraceMessage **)pMessage2;
    FILETIME timea, timeb;
    BOOL res;

    res = SystemTimeToFileTime(&pTraceMessage1->m_SystemTime, &timea);
    res = SystemTimeToFileTime(&pTraceMessage2->m_SystemTime, &timeb);

    return(CompareFileTime(&timea, &timeb));
}

int CDisplayDlg::CompareOnKernelTime(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_KernelTime - pTraceMessage2->m_KernelTime);
//    return (pTraceMessage1->m_KernelTime.dwHighDateTime - pTraceMessage2->m_KernelTime.dwHighDateTime) ?
//        (pTraceMessage1->m_KernelTime.dwHighDateTime - pTraceMessage2->m_KernelTime.dwHighDateTime) :
//        (pTraceMessage1->m_KernelTime.dwLowDateTime - pTraceMessage2->m_KernelTime.dwLowDateTime);
}

int CDisplayDlg::CompareOnUserTime(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_UserTime - pTraceMessage2->m_UserTime);

//    return (pTraceMessage1->m_UserTime.dwHighDateTime - pTraceMessage2->m_UserTime.dwHighDateTime) ?
//        (pTraceMessage1->m_UserTime.dwHighDateTime - pTraceMessage2->m_UserTime.dwHighDateTime) :
//        (pTraceMessage1->m_UserTime.dwLowDateTime - pTraceMessage2->m_UserTime.dwLowDateTime);
}

int CDisplayDlg::CompareOnIndent(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage1->m_Indent - (LONG)pTraceMessage2->m_Indent);
}

int CDisplayDlg::CompareOnFlagsName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_FlagsName.Compare(pTraceMessage2->m_FlagsName));
}

int CDisplayDlg::CompareOnLevelName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_LevelName.Compare(pTraceMessage2->m_LevelName));
}

int CDisplayDlg::CompareOnComponentName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_ComponentName.Compare(pTraceMessage2->m_ComponentName));
}

int CDisplayDlg::CompareOnSubComponentName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage1->m_SubComponentName.Compare(pTraceMessage2->m_SubComponentName));
}

int CDisplayDlg::ReverseCompareOnName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_GuidName.Compare(pTraceMessage1->m_GuidName));
}

int CDisplayDlg::ReverseCompareOnMessage(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_Message.Compare(pTraceMessage1->m_Message));
}

int CDisplayDlg::ReverseCompareOnFileName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_GuidTypeName.Compare(pTraceMessage1->m_GuidTypeName));
}

int CDisplayDlg::ReverseCompareOnLineNumber(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage  *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage  *pTraceMessage2 = *(CTraceMessage **)pMessage2;
    CString         string1;
    CString         string2;
    DWORD           val1, val2;

    //
    // Get Line number string for the first element
    //
    string1 = 
        pTraceMessage1->m_GuidTypeName.Right(pTraceMessage1->m_GuidTypeName.GetLength() - 
            pTraceMessage1->m_GuidTypeName.Find('_') - 1);

    string1 = 
        string1.Right(string1.GetLength() - 
            string1.FindOneOf(_T("0123456789")));

    string2 = 
        pTraceMessage2->m_GuidTypeName.Right(pTraceMessage2->m_GuidTypeName.GetLength() - 
            pTraceMessage2->m_GuidTypeName.Find('_') - 1);

    //
    // Get the line number string for the second element
    //
    string2 = 
        string2.Right(string2.GetLength() - 
            string2.FindOneOf(_T("0123456789")));

    TCHAR * end;

    val1 = _tcstoul(string1, &end, 10);
    val2 = _tcstoul(string2, &end,10);

    if(val1 == val2)  {
        return(0);
    }

    if(val1 > val2)  {
        return(-1);
    }

    return(1);
}

int CDisplayDlg::ReverseCompareOnFunctionName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_FunctionName.Compare(pTraceMessage1->m_FunctionName));
}

int CDisplayDlg::ReverseCompareOnProcessId(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage2->m_ProcessId - (LONG)pTraceMessage1->m_ProcessId);
}

int CDisplayDlg::ReverseCompareOnThreadId(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage2->m_ThreadId - (LONG)pTraceMessage1->m_ThreadId);
}

int CDisplayDlg::ReverseCompareOnCpuNumber(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage2->m_CpuNumber - (LONG)pTraceMessage1->m_CpuNumber);
}

int CDisplayDlg::ReverseCompareOnSeqNumber(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage2->m_SequenceNum - (LONG)pTraceMessage1->m_SequenceNum);
}

int CDisplayDlg::ReverseCompareOnSystemTime(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;
    FILETIME timea, timeb;
    BOOL res;

    res = SystemTimeToFileTime(&pTraceMessage1->m_SystemTime, &timea);
    res = SystemTimeToFileTime(&pTraceMessage2->m_SystemTime, &timeb);

    return(CompareFileTime(&timeb, &timea));
}

int CDisplayDlg::ReverseCompareOnKernelTime(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_KernelTime - pTraceMessage1->m_KernelTime);

//    return (pTraceMessage2->m_KernelTime.dwHighDateTime - pTraceMessage1->m_KernelTime.dwHighDateTime) ?
//        (pTraceMessage2->m_KernelTime.dwHighDateTime - pTraceMessage1->m_KernelTime.dwHighDateTime) :
//        (pTraceMessage2->m_KernelTime.dwLowDateTime - pTraceMessage1->m_KernelTime.dwLowDateTime);
}

int CDisplayDlg::ReverseCompareOnUserTime(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_UserTime - pTraceMessage1->m_UserTime);
//    return (pTraceMessage2->m_UserTime.dwHighDateTime - pTraceMessage1->m_UserTime.dwHighDateTime) ?
//        (pTraceMessage2->m_UserTime.dwHighDateTime - pTraceMessage1->m_UserTime.dwHighDateTime) :
//        (pTraceMessage2->m_UserTime.dwLowDateTime - pTraceMessage1->m_UserTime.dwLowDateTime);
}

int CDisplayDlg::ReverseCompareOnIndent(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return((LONG)pTraceMessage2->m_Indent - (LONG)pTraceMessage1->m_Indent);
}

int CDisplayDlg::ReverseCompareOnFlagsName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_FlagsName.Compare(pTraceMessage1->m_FlagsName));
}

int CDisplayDlg::ReverseCompareOnLevelName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_LevelName.Compare(pTraceMessage1->m_LevelName));
}

int CDisplayDlg::ReverseCompareOnComponentName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_ComponentName.Compare(pTraceMessage1->m_ComponentName));
}

int CDisplayDlg::ReverseCompareOnSubComponentName(const void *pMessage1, const void *pMessage2) 
{
    CTraceMessage *pTraceMessage1 = *(CTraceMessage **)pMessage1;
    CTraceMessage *pTraceMessage2 = *(CTraceMessage **)pMessage2;

    return(pTraceMessage2->m_SubComponentName.Compare(pTraceMessage1->m_SubComponentName));
}

BOOL CDisplayDlg::BeginTrace(BOOL   bUseExisting)
{
    CTraceSession  *pTraceSession;
    CLogSession    *pLogSession;
    LONG            ii;
    LONG            jj;
    CString         str;
    BOOL            bGroupActive = FALSE;

    //
    // If the group is already started or being started, just return
    // false
    //
    if(TRUE == SetGroupActive(TRUE)) {
        return FALSE;
    }

    //
    // The list head should always be NULL here
    //
    ASSERT(m_pEventListHead == NULL);

    //
    // Setup the event timer
    //
    m_eventTimer = SetTimer(1, EVENT_TIME_LIMIT, 0);

    //
    // zero our counts
    //
    m_totalBuffersRead = 0;
    m_totalEventsLost = 0;
    m_totalEventCount = 0;

    //
    // We set to use the StructuredFormat method in traceprt.dll
    // and we use no prefix on the message.  We have to specify no
    // prefix as we cannot otherwise predictably setup the data we
    // get in our event callback.
    //
    SetTraceFormatParameter(ParameterStructuredFormat,UlongToPtr(1));
    SetTraceFormatParameter(ParameterUsePrefix,UlongToPtr(0));

    //
    // open the output file if writing output
    //
    if(m_bWriteListingFile) {
        m_bListingFileOpen = FALSE;
        if(!m_listingFile.Open(
                            m_listingFileName, 
                            CFile::modeCreate | CFile::modeReadWrite)) {
            AfxMessageBox(_T("Unable To Create Listing File"));
        } else {
            m_bListingFileOpen = TRUE;
        }
    }

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    //
    // Setup the log sessions
    //
    for(ii = 0; ii < m_sessionArray.GetSize(); ii++) {

        //
        // Get the next CLogSession pointer
        //
        pLogSession = (CLogSession *)m_sessionArray[ii];

        if(NULL == pLogSession) {
            continue;
        }
    
        if(!pLogSession->BeginTrace(bUseExisting)) {
            if(pLogSession->m_bTraceActive) {
//BUGBUG -- should we be doing this??
                pLogSession->EndTrace();
            }

            continue;
        }
        bGroupActive = TRUE;
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    //
    // Show the sessions running
    //
    ::PostMessage(m_hMainWnd, WM_USER_UPDATE_LOGSESSION_LIST, 0, 0);

    //
    // If none of the log sessions started successfully,
    // then return FALSE
    //
//BUGBUG -- maybe we want to fail if ANY of the sessions didn't start?
//          Also, might need a pop-up here?
    if(!bGroupActive) {
        SetGroupActive(FALSE);

        SetState(Stopped);
        return FALSE;
    }

    //
    // Prepare the format GUIDs and such
    //
    if(!SetupTraceSessions()) {
        AfxMessageBox(_T("Failed To Open Handles For Any Log Sessions In Group"));
        SetGroupActive(FALSE);

        SetState(Stopped);
        return FALSE;
    }

    return TRUE;
}

UINT CDisplayDlg::RealTimeEventThread(LPVOID  pParam)
{
    CString                 str;
    CDisplayDlg            *pDisplayDlg = (CDisplayDlg *)pParam;
    CLogSession            *pLogSession;
    LONG                    status;
    CTraceSession          *pTraceSession;
    DWORD                   handleIndex;
    HANDLE                  handleArray[2];

    //
    // Setup the handle array, the termination event
    // must always be element zero, so that it's index
    // will be the index returned in case multiple 
    // events are set
    //
    handleArray[0] = pDisplayDlg->m_hRealTimeTerminationEvent;
    handleArray[1] = pDisplayDlg->m_hRealTimeProcessingStartEvent;

    //
    // Our master control loop, loop until we get a termination event
    // signal.  The start event signals the loop to call ProcessTrace,
    // the done event is signalled and the WM_USER_TRACE_DONE message 
    // posted to signal that CloseTrace was called
    //
    while(1) {
        //
        // Wait on start or termination event
        //
        handleIndex = WaitForMultipleObjects(2, 
                                             handleArray, 
                                             FALSE, 
                                             INFINITE) - WAIT_OBJECT_0;
        //
        // Did we get killed?
        //
        if(0 == handleIndex) {
            //
            // Signal that we are done.
            //
            ::PostMessage(pDisplayDlg->GetSafeHwnd(), WM_USER_TRACE_DONE, 0, 0);

            //
            // Free our string buffer (threads seem to leak if this isn't done??)
            //
            str.Empty();

            return 0;
        }

        //
        // Reset done event for UpdateSession
        //
        ResetEvent(pDisplayDlg->m_hRealTimeProcessingDoneEvent);

        //
        // Process the trace events
        //
        status = ProcessTrace(pDisplayDlg->m_traceHandleArray, 
                              pDisplayDlg->m_traceHandleCount, 
                              NULL, 
                              NULL);
        if(ERROR_SUCCESS != status){
            str.Format(_T("ProcessTrace returned error %d, GetLastError() = %d\n"), status, GetLastError());
            AfxMessageBox(str);
        }

        //
        // We are done, close the trace sessions
        //
        for(LONG ii = 0; ii < pDisplayDlg->m_traceHandleCount; ii++) {
            status = CloseTrace(pDisplayDlg->m_traceHandleArray[ii]);
            if(ERROR_SUCCESS != status){
                str.Format(_T("CloseTrace returned error %d\n"), status);
                AfxMessageBox(str);
            }
        }

        //
        // Set done event for UpdateSession
        //
        SetEvent(pDisplayDlg->m_hRealTimeProcessingDoneEvent);

        //
        // Indicate that we are done.
        //
        ::PostMessage(pDisplayDlg->GetSafeHwnd(), WM_USER_TRACE_DONE, 0, 0);
    }

    return 0;
}

BOOL CDisplayDlg::EndTrace(HANDLE DoneEvent) 
{
    CString                 str;
    CLogSession            *pLogSession;
    LONG                    ii;
    BOOL                    bWasActive = FALSE;
    BOOL                    bWasRealTime = FALSE;

    //
    // If the group is already stopped, or is stopping, just 
    // return FALSE.
    //
    if(TRUE == SetGroupInActive(TRUE)) {
        return FALSE;
    }

    //
    // Save the caller's event to be set when stopped
    //
    m_hEndTraceEvent = DoneEvent;

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    for(ii = 0; ii < m_sessionArray.GetSize(); ii++) {
        pLogSession = (CLogSession *)m_sessionArray[ii];

        if(NULL == pLogSession) {
            continue;
        }

        //
        // If the session is active, stop it
        //
        if(pLogSession->m_bTraceActive) {
            pLogSession->EndTrace();
            
            bWasActive = TRUE;

            if(pLogSession->m_bRealTime) {
                bWasRealTime = TRUE;
            }

        }
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    if(bWasActive) {
        //
        // Update the log session state
        //
        ::PostMessage(m_hMainWnd, WM_USER_UPDATE_LOGSESSION_LIST, 0, 0);

        if(!bWasRealTime) {
            //
            // We need to explicitly call OnTraceDone here
            //
            OnTraceDone(NULL, NULL);
        }

        return TRUE;
    }

    return FALSE;
}

void CDisplayDlg::OnTraceDone(WPARAM wParam, LPARAM lParam)
{
    CString         str;
    CLogSession    *pLogSession = NULL;

    //
    // Set the group state
    //
    SetState(Stopping);

    //
    // Write the summary file if requested
    //
    if(m_bWriteSummaryFile) {
        WriteSummaryFile();
    }

    //
    // close the output file if opened
    //
    if(m_bWriteListingFile && m_bListingFileOpen) {

        m_listingFile.Close();

        m_bListingFileOpen = FALSE;
    }

    //
    // Cleanup the event list
    //
    WaitForSingleObject(g_hGetTraceEvent, INFINITE);

    //
    // The event list head
    //
    CleanupTraceEventList(m_pEventListHead);

    SetEvent(g_hGetTraceEvent);

    m_pEventListHead = NULL;

    //
    // Remove the keys from the hash table
    //
    for(LONG ii = 0; ii < m_sessionArray.GetSize(); ii++) {
        pLogSession = (CLogSession *)m_sessionArray[ii];

        if(NULL == pLogSession) {
            continue;
        }

        g_loggerNameToDisplayDlgHash.RemoveKey(pLogSession->GetDisplayName());
    }

    //
    // Kill the event timer
    //
    KillTimer(m_eventTimer);

    //
    // Force one last update of the event display
    //
    OnTimer(1);

    //
    // Set the group as not active
    //
    SetGroupActive(FALSE);
    SetGroupInActive(FALSE);

    //
    // Set the group state
    //
    SetState(Stopped);

    if(m_hEndTraceEvent != NULL) {
        SetEvent(m_hEndTraceEvent);

        m_hEndTraceEvent = NULL;
    }

    return;
}

//
// Updates an active tracing session.  Real-Time mode, log file name,
// flush-time, flags, and maximum buffers can be updated for active
// sessions.
//
BOOL CDisplayDlg::UpdateSession(CLogSession *pLogSession)
{
    CLogSession            *pLog;
    PEVENT_TRACE_PROPERTIES pQueryProperties;
    ULONG                   sizeNeeded;
    LPTSTR                  pLoggerName;
    LPTSTR                  pCurrentLogFileName;
    LPTSTR                  pLogFileName;
    ULONG                   flags;
    ULONG                   level;
    ULONG                   status;
    CString                 logFileName;
    CString                 str;

    //
    // setup our buffer size for the properties struct for our query
    //
    sizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + (2 * 1024 * sizeof(TCHAR));

    //
    // allocate our memory
    //
    pQueryProperties = (PEVENT_TRACE_PROPERTIES) new char[sizeNeeded];
    if(NULL == pQueryProperties) {
        return FALSE;
    }

    //
    // zero our structures
    //
    memset(pQueryProperties, 0, sizeNeeded);

    //
    // Set the size
    //
    pQueryProperties->Wnode.BufferSize = sizeNeeded;

    // 
    // Set the GUID
    //
    pQueryProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

    // 
    // Set the logger name offset
    //
    pQueryProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

    //
    // Set the logger name for the query
    //
    pLoggerName = (LPTSTR)((char*)pQueryProperties + pQueryProperties->LoggerNameOffset);
    _tcscpy(pLoggerName, pLogSession->GetDisplayName());

    // 
    // Set the log file name offset
    //
    pQueryProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (500 * sizeof(TCHAR));

    //
    // Get the log file name pointers
    //
    pCurrentLogFileName = (LPTSTR)((char*)pQueryProperties + pQueryProperties->LogFileNameOffset);
    
    //
    // Query the log session
    //
    status = ControlTrace(0,
                          pLogSession->GetDisplayName(),
                          pQueryProperties,
                          EVENT_TRACE_CONTROL_QUERY);

    if(ERROR_SUCCESS != status) {
        str.Format(_T("Query Failed For Log Session, %d\nSession Not Updated"), status);
        AfxMessageBox(str);
    }

    //
    // Call the log session's UpdateSession function
    //
    if(!pLogSession->UpdateSession(pQueryProperties)) {
        delete [] pQueryProperties;

        return FALSE;
    }

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    for(LONG ii = 0; ii < m_sessionArray.GetSize(); ii++) {
        pLog = (CLogSession *)m_sessionArray[ii];

        if(pLog == pLogSession) {
            continue;
        }

        //
        // In our real-time thread we call ProcessTrace.  If all sessions
        // related to that call update to be non-real-time sessions, then
        // ProcessTrace will exit and CloseTrace will get called.  We have
        // to track this and restart the real-time processing if a log session
        // subsequently updates to be real-time again.  So, we check here if
        // any other attached sessions are real-time, and if so, we don't 
        // have to bother with waiting on or setting the events below.
        //
        if(pLog->m_bRealTime) {
            delete [] pQueryProperties;

            return TRUE;
        }
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    //
    // If real-time is specified and the session was not real-time before, 
    // then we need to set the start event.
    //
    if(pLogSession->m_bRealTime && 
            !(pQueryProperties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        //
        // We have updated a session to be real-time and it is the only session in
        // its group to be real-time.  We need to restart the trace in this case
        //

        //
        // Start the real-time thread processing again
        //
        BeginTrace(TRUE);
    }

    //
    // If real-time is not set and it was before, then we need to wait on
    // the real-time thread to catch the fact that the session is no longer
    // tracing real time.  This will cause the ProcessTrace call to 
    // return in the real-time thread.
    //
    if(!pLogSession->m_bRealTime && 
            (pQueryProperties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        //
        // Make sure our thread catches the stop
        //
        WaitForSingleObject(m_hRealTimeProcessingDoneEvent, INFINITE);
    }

    delete [] pQueryProperties;

    return TRUE;
}

BOOL CDisplayDlg::SetupTraceSessions()
{
    CTraceSession  *pTraceSession;
    CLogSession    *pLogSession;
    LONG            jj;
    CString         str;
    LPTSTR          tmfFile;
    PVOID           pHashEntry;

    //
    // Initialize our handle count
    //
    m_traceHandleCount = 0;

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    //
    // Setup the log sessions
    //
    for(LONG ii = 0; ii < m_sessionArray.GetSize(); ii++) {

        //
        // Get the next CLogSession pointer
        //
        pLogSession = (CLogSession *)m_sessionArray[ii];

        if(NULL == pLogSession) {
            continue;
        }


        //
        // If the log session is not real-time and we are not dumping an existing
        // logfile, then no need to call OpenTrace
        //
        if((!pLogSession->m_bRealTime) && (!pLogSession->m_bDisplayExistingLogFileOnly)) {
            continue;
        }

        //
        // zero the EVENT_TRACE_LOGFILE buffer
        //
        memset(&pLogSession->m_evmFile, 0, sizeof(EVENT_TRACE_LOGFILE));

        //
        // setup the trace parameters
        //

        //
        // For real-time we set the logger name only, for existing logfiles we
        // also set the logfile name.
        //
        if(pLogSession->m_bDisplayExistingLogFileOnly) {
            pLogSession->m_evmFile.LogFileName = (LPTSTR)(LPCTSTR)pLogSession->m_logFileName;
            pLogSession->m_evmFile.LoggerName = (LPTSTR)(LPCTSTR)pLogSession->GetDisplayName();
        } else {
            pLogSession->m_evmFile.LoggerName = (LPTSTR)(LPCTSTR)pLogSession->GetDisplayName();
        }
        pLogSession->m_evmFile.Context = NULL;
        pLogSession->m_evmFile.BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACK)BufferCallback;
        pLogSession->m_evmFile.BuffersRead = 0;
        pLogSession->m_evmFile.CurrentTime = 0;
        pLogSession->m_evmFile.EventCallback = m_pEventCallback;
        if(pLogSession->m_bDisplayExistingLogFileOnly) {
            pLogSession->m_evmFile.LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
        } else {
            pLogSession->m_evmFile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
        }

        //
        // We call GetTraceGuids for each TMF file specified, or once if
        // a TMF path is used.
        //
        for(jj = 0; jj < pLogSession->m_traceSessionArray.GetSize(); jj++) {
            pTraceSession = (CTraceSession *)pLogSession->m_traceSessionArray[jj];

            if((NULL != pTraceSession) && (0 != pTraceSession->m_tmfFile.GetSize())) {
                //
                // TMFs were selected get the format info from each one.
                //
                for(LONG kk = 0; kk < pTraceSession->m_tmfFile.GetSize(); kk++) {

                    //
                    // Make sure the format info isn't already in use
                    // This actually isn't foolproof, as it counts on 
                    // no one changing the TMF filename and thus two TMFs
                    // with different names having the same format GUID.
                    //
                    if(g_formatInfoHash.Lookup(pTraceSession->m_tmfFile[kk].Right(40), pHashEntry)) {
                        // 
                        // Need to clean out any unique entries from the hash that
                        // were added by this session
                        //
                        for(; kk > 0; kk--) {
                            g_formatInfoHash.RemoveKey(pTraceSession->m_tmfFile[kk - 1].Right(40));
                        }

                        return FALSE;
                    }

                    //
                    // Not there, so add it to the hash
                    //
                    g_formatInfoHash.SetAt(pTraceSession->m_tmfFile[kk].Right(40), pLogSession);

                    //
                    // get the protection
                    //
                    WaitForSingleObject(g_hGetTraceEvent, INFINITE);

                    //
                    // Get the format GUIDs from the TMF file(s)
                    //
                    if(0 == GetTraceGuids((LPTSTR)(LPCTSTR)pTraceSession->m_tmfFile[kk], 
                        (PLIST_ENTRY *)&m_pEventListHead)) {
                        str.Format(_T("Failed To Get Format Information For Logger %ls"), pLogSession->m_evmFile.LoggerName);
                        AfxMessageBox(str);
                    }

                    //
                    // Release the protection
                    //
                    SetEvent(g_hGetTraceEvent);
                }
            } else {

                CString defaultPath;

                if((GetModuleFileName(NULL, defaultPath.GetBuffer(500), 500)) == 0) {
                    defaultPath.Empty();
                } else {
                    defaultPath = (LPCTSTR)defaultPath.Left(defaultPath.ReverseFind('\\') + 1);
                }
                defaultPath +=_T("default.tmf");

                //
                // If path is empty, the TMF path environment variable will
                // be used as-is by default.
                //
                if(!pTraceSession->m_tmfPath.IsEmpty()){
                    //
                    // If the path is set we set the TMF path 
                    // environment variable
                    //
                    SetTraceFormatParameter(ParameterTraceFormatSearchPath, (PVOID)(LPCTSTR)pTraceSession->m_tmfPath);
                }

                //
                // Still have to call GetTraceGuids
                //
                WaitForSingleObject(g_hGetTraceEvent, INFINITE);

                //
                // Get the format info
                //
                GetTraceGuids((LPTSTR)(LPCTSTR)defaultPath, 
                            (PLIST_ENTRY *)&m_pEventListHead);

                //
                // Release the protection
                //
                SetEvent(g_hGetTraceEvent);
            }
        }

        //
        // Open and get a handle to the trace session
        //
        pLogSession->m_traceHandle = OpenTrace(&pLogSession->m_evmFile);

        if(INVALID_HANDLE_VALUE == (HANDLE)pLogSession->m_traceHandle) {
            str.Format(_T("OpenTrace failed for logger %ls\nError returned: %d"), 
                       pLogSession->GetDisplayName(), 
                       GetLastError());
            AfxMessageBox(str);

            continue;
        }

        //
        // Save the handle in our array for OpenTrace
        //
        m_traceHandleArray[m_traceHandleCount++] = pLogSession->m_traceHandle;

        //
        // Add this displayDlg to the global hash table keyed
        // by log session name
        //
        g_loggerNameToDisplayDlgHash.SetAt(pLogSession->GetDisplayName(), this);
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    //
    // If we have at least one valid handle start
    // our real-time thread processing events
    //
    if(m_traceHandleCount != 0) {
        //
        // Set the real-time processing start event and thus kick
        // the real-time thread into processing events
        //
        SetEvent(m_hRealTimeProcessingStartEvent);
    }

    return TRUE;
}

//
// This function handles writing the summary file.  Heavily borrowed code
// from TraceFmt here.
//
VOID CDisplayDlg::WriteSummaryFile() 
{
    CLogSession    *pLogSession;
    CString         str;
    CStdioFile      summaryFile;
    TCHAR          *pSummaryBlock;
    __int64         elapsedTime;
    LONG            ii;

    //
    // Attempt to open the summary file
    //
    if(!summaryFile.Open(m_summaryFileName, CFile::modeCreate |   
            CFile::modeReadWrite)) {
        AfxMessageBox(_T("Unable To Create Summary File"));
        return;
    }

    //
    // allocate some memory
    //
    pSummaryBlock = new TCHAR[SIZESUMMARYBLOCK];
    if(NULL == pSummaryBlock) {
        AfxMessageBox(_T("Unable To Create Summary File"));
        return;
    }

    //
    // Write the header
    //
    str.Format(_T("Files Processed:\n"));
    summaryFile.WriteString(str);

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    for(ii = 0; ii < m_sessionArray.GetSize(); ii++) {
        pLogSession = (CLogSession *)m_sessionArray[ii];

        if(NULL == pLogSession) {
            continue;
        }

        str.Format(_T("\t%s\n"),pLogSession->m_logFileName);
        summaryFile.WriteString(str);
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    //
    // Get the duration of the session
    //
    GetTraceElapseTime(&elapsedTime);

    //
    // Write out the counts
    //
    str.Format(
           _T("Total Buffers Processed %d\n")
           _T("Total Events  Processed %d\n")
           _T("Total Events  Lost      %d\n")
           _T("Elapsed Time            %I64d sec\n"), 
            m_totalBuffersRead,
            m_totalEventCount,
            m_totalEventsLost,
            (elapsedTime / 10000000) );
    summaryFile.WriteString(str);

    str.Format(
   _T("+--------------------------------------------------------------------------------------+\n")
   _T("|%10s    %-20s %-10s     %-36s|\n")
   _T("+--------------------------------------------------------------------------------------+\n"),
   _T("EventCount"),
   _T("EventName"),
   _T("EventType"),
   _T("Guid"));
    summaryFile.WriteString(str);

    //
    // Write out the summary block
    //
    SummaryTraceEventList(pSummaryBlock, SIZESUMMARYBLOCK, m_pEventListHead);
    str.Format(_T("%s+--------------------------------------------------------------------------------------+\n"),
            pSummaryBlock);
    summaryFile.WriteString(str);

    //
    // Close the file
    //
    summaryFile.Close();

    //
    // Free our memory
    //
    delete [] pSummaryBlock;
}

ULONG WINAPI BufferCallback(PEVENT_TRACE_LOGFILE pLog)
{
    CDisplayDlg    *pDisplayDlg;
    CString         str;

    //
    // Get the logger name from the passed in struct
    //
    str.Format(_T("%s"), pLog->LoggerName);

    //
    // Get our logsession from the global hash table using the logger name
    //
    g_loggerNameToDisplayDlgHash.Lookup(str, (void*&)pDisplayDlg);

    //
    // If we got our displayDlg, update the counts
    //
    if(NULL != pDisplayDlg) {
        pDisplayDlg->m_totalBuffersRead++;
        pDisplayDlg->m_totalEventsLost += pLog->EventsLost;

        ::PostMessage(pDisplayDlg->m_hMainWnd, WM_USER_UPDATE_LOGSESSION_LIST, 0, 0);
    }

    return TRUE;
}

//
// Sort handler
VOID CDisplayDlg::OnDoSort(NMHDR * pNmhdr, LRESULT * pResult)
{
    NMLISTVIEW *pLV = (NMLISTVIEW *)pNmhdr;

    //
    // Sort the table by the selected column's data
    //
    SortTable(pLV->iItem);

    //
    // Force a redraw of the data
    //
    m_displayCtrl.RedrawItems(m_displayCtrl.GetTopIndex(), 
                              m_displayCtrl.GetTopIndex() + m_displayCtrl.GetCountPerPage());

    m_displayCtrl.UpdateWindow();
}


//
// EventHandler() is only a wrapper, it calls FormatTraceEvent() in TracePrt.
//
VOID CDisplayDlg::EventHandler(PEVENT_TRACE pEvent)
{
    CString             str;
    CString             tempString;
    GUID                guidValue;
    CString             guidString;
    PSTRUCTUREDMESSAGE  pStructuredMessage;
    CTraceMessage      *pTraceMessage;
    DWORD               itemCount;
    DWORD               time;
    CTraceViewApp      *pMainWnd;
    
    //
    // Make sure we got an event
    //
    if (NULL == pEvent) {
        return;
    }

    //
    // Get traceprt protection
    //
    WaitForSingleObject(g_hGetTraceEvent, INFINITE);

    //
    // FormatTraceEvent fills in our event buffer and updates some
    // info in the event list for the summary file
    //
    if(FormatTraceEvent(m_pEventListHead,
                        pEvent,
                        m_pEventBuf,
                        EVENT_BUFFER_SIZE,
                        NULL) <= 0) {

        //
        // Release traceprt protection
        //
        SetEvent(g_hGetTraceEvent);

        return;
    }

    //
    // Release traceprt protection
    //
    SetEvent(g_hGetTraceEvent);

    //
    // Get the structured message struct from the event buffer
    //
    pStructuredMessage = (PSTRUCTUREDMESSAGE)&m_pEventBuf[0];

    //
    // Get a pointer to the main wnd
    //
    pMainWnd = (CTraceViewApp *)AfxGetApp();

    if(NULL == pMainWnd) {
        return;
    }

    //
    // Allocate a message struct from the main frame
    //
    pTraceMessage = pMainWnd->AllocateTraceEventBlock();

    if(NULL == pTraceMessage) {
        return;
    }

    //
    // Get the message from the event buffer
    //
    memcpy(&pTraceMessage->m_TraceGuid, 
            &pStructuredMessage->TraceGuid, 
            sizeof(GUID));

    //
    // Copy the message struct to our own struct
    //
    pTraceMessage->m_GuidName =
        (pStructuredMessage->GuidName ? &m_pEventBuf[pStructuredMessage->GuidName/sizeof(TCHAR)] :_T(""));

    pTraceMessage->m_GuidTypeName.Format(_T("%s"),
        (pStructuredMessage->GuidTypeName ? &m_pEventBuf[pStructuredMessage->GuidTypeName/sizeof(TCHAR)] :_T("")));

    pTraceMessage->m_ThreadId = pStructuredMessage->ThreadId;

    memcpy(&pTraceMessage->m_SystemTime, 
           &pStructuredMessage->SystemTime,
           sizeof(SYSTEMTIME));

    memcpy(&pTraceMessage->m_UserTime, 
            &pStructuredMessage->UserTime,
            sizeof(ULONG));

    memcpy(&pTraceMessage->m_KernelTime, 
            &pStructuredMessage->KernelTime,
            sizeof(ULONG));

    pTraceMessage->m_SequenceNum = pStructuredMessage->SequenceNum;

    pTraceMessage->m_ProcessId = pStructuredMessage->ProcessId;

    pTraceMessage->m_CpuNumber = pStructuredMessage->CpuNumber;

    pTraceMessage->m_Indent = pStructuredMessage->Indent;

    pTraceMessage->m_FlagsName.Format(_T("%s"),
        (pStructuredMessage->FlagsName ? &m_pEventBuf[pStructuredMessage->FlagsName/sizeof(TCHAR)] :_T("")));

    pTraceMessage->m_LevelName.Format(_T("%s"),
        (pStructuredMessage->LevelName ? &m_pEventBuf[pStructuredMessage->LevelName/sizeof(TCHAR)] :_T("")));

    pTraceMessage->m_FunctionName.Format(_T("%s"),
        (pStructuredMessage->FunctionName ? &m_pEventBuf[pStructuredMessage->FunctionName/sizeof(TCHAR)] :_T("")));

    pTraceMessage->m_ComponentName.Format(_T("%s"),
        (pStructuredMessage->ComponentName ? &m_pEventBuf[pStructuredMessage->ComponentName/sizeof(TCHAR)] :_T("")));

    pTraceMessage->m_SubComponentName.Format(_T("%s"),
        (pStructuredMessage->SubComponentName ? &m_pEventBuf[pStructuredMessage->SubComponentName/sizeof(TCHAR)] :_T("")));

    pTraceMessage->m_Message.Format(_T("%s"),
        (pStructuredMessage->FormattedString ? &m_pEventBuf[pStructuredMessage->FormattedString/sizeof(TCHAR)] :_T("")));

    //
    // Get our trace event array protection
    //
    WaitForSingleObject(m_hTraceEventMutex,INFINITE);

    //
    // If we're in a low memory situation, drop one entry for every one we add
    //
    if(  m_traceArray.GetSize() > MaxTraceEntries)  {

        delete m_traceArray.GetAt(0);

        //
        // Slide 'em all down...
        //
        m_traceArray.RemoveAt(0);
    }

    //
    // Add the event to the array
    //
    m_traceArray.Add(pTraceMessage);

    //
    // Update the item count for the list control so that
    // the display gets updated
    //
    itemCount = (LONG)m_traceArray.GetSize();

    //
    // Release our trace event array protection
    //
    ReleaseMutex(m_hTraceEventMutex);

    //
    // dump the event to the output file if any
    //
    if(m_bWriteListingFile && 
            m_bListingFileOpen) {
        //
        // Glorious hack to get FILETIME back into string format
        // Not sure this works for different time zones or daylight savings
        //
        CTime kernelTime(pStructuredMessage->KernelTime);
        CTime userTime(pStructuredMessage->UserTime);

        CString system;
        CString kernel;
        CString user;

        system.Format(_T("%02d\\%02d\\%4d-%02d:%02d:%02d"),                     
                            pStructuredMessage->SystemTime.wMonth,
                            pStructuredMessage->SystemTime.wDay,
                            pStructuredMessage->SystemTime.wYear,
                            pStructuredMessage->SystemTime.wHour,
                            pStructuredMessage->SystemTime.wMinute,
                            pStructuredMessage->SystemTime.wSecond,
                            pStructuredMessage->SystemTime.wMilliseconds);

        if(kernelTime.GetYear() == 1969) {
            kernel.Format(_T(" "));
        } else {
            kernel.Format(_T("%s-%02d:%02d:%02d"),                     
                        kernelTime.Format("%m\\%d\\%Y"),
                        kernelTime.GetHour() + 5,
                        kernelTime.GetMinute(),
                        kernelTime.GetSecond());
        }

        if(userTime.GetYear() == 1969) {
            user.Format(_T(" "));
        } else {
            user.Format(_T("%s-%02d:%02d:%02d"),                     
                        userTime.Format("%m\\%d\\%Y"),
                        userTime.GetHour() + 5,
                        userTime.GetMinute(),
                        userTime.GetSecond());
        }

        //
        // Need to reformat with good timestamps for the output file.
        // Output Order --> Name FileName_Line# FunctionName ProcessID ThreadID 
        //                  CPU# Seq# SystemTime KernelTime UserTime Indent
        //                  FlagsName LevelName ComponentName SubComponentName
        //                  Message at end
        //
        str.Format(_T("%s %s %s %X %X %d %u %s %s %s %s %s %s %s %s %s"),
                (pStructuredMessage->GuidName ? &m_pEventBuf[pStructuredMessage->GuidName/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->GuidTypeName ? &m_pEventBuf[pStructuredMessage->GuidTypeName/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->FunctionName ? &m_pEventBuf[pStructuredMessage->FunctionName/sizeof(TCHAR)] :_T("")),
                pStructuredMessage->ProcessId,
                pStructuredMessage->ThreadId,
                pStructuredMessage->CpuNumber,
                pStructuredMessage->SequenceNum,
                system,
                kernel,
                user,
                (pStructuredMessage->Indent ? &m_pEventBuf[pStructuredMessage->Indent/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->FlagsName ? &m_pEventBuf[pStructuredMessage->FlagsName/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->LevelName ? &m_pEventBuf[pStructuredMessage->LevelName/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->ComponentName ? &m_pEventBuf[pStructuredMessage->ComponentName/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->SubComponentName ? &m_pEventBuf[pStructuredMessage->SubComponentName/sizeof(TCHAR)] :_T("")),
                (pStructuredMessage->FormattedString ? &m_pEventBuf[pStructuredMessage->FormattedString/sizeof(TCHAR)] :_T("")));

                str +=_T("\n");
                m_listingFile.WriteString(str);
    }

    //
    // Update the event count for the summary file
    //
    m_totalEventCount++;

    //
    // Empty the string buffer (not strictly necessary)
    //
    str.Empty();
}

VOID CDisplayDlg::OnTimer(UINT nIDEvent)
{
    int itemCount;
    static int previousCount = 0;
    static BOOL bAutoSizeOnce = TRUE;
    static CTraceMessage * msgLastSeen=0;

    //
    // This is a really bad hack.
    // Couldn't figure out anyway to get notified when
    // the DisplayDlg window has actually been displayed.
    // Until it is displayed, then AutoSizeColumns won't 
    // work correctly for the last column.  Calling it here
    // seems to fix the problem.  There has to be a better way.
    //
    if(bAutoSizeOnce) {
        AutoSizeColumns();
        bAutoSizeOnce = FALSE;
    }

    //
    // Get our trace event array protection
    //
    WaitForSingleObject(m_hTraceEventMutex,INFINITE);

    //
    // Update the item count for the list control so that
    // the display gets updated
    //
    itemCount = (LONG)m_traceArray.GetSize();

    //
    // Release our trace event array protection
    //
    ReleaseMutex(m_hTraceEventMutex);

    if(itemCount == 0)  {
        msgLastSeen = NULL;
        return;
    }

    if(  itemCount <= MaxTraceEntries)  {

        if( itemCount == previousCount )  {
            return;
        } 
            
    } else  {

        if(m_traceArray.GetAt(0) == msgLastSeen)  {
            return;
        }

        msgLastSeen = m_traceArray.GetAt(0);
    }

    previousCount = itemCount;

    //
    // Sort the table of event messages
    //
    SortTable();

    //
    // Adjust the trace display item count
    //
    m_displayCtrl.SetItemCountEx(itemCount, 
                                 LVSICF_NOINVALIDATEALL|LVSICF_NOSCROLL);

    m_displayCtrl.RedrawItems(m_displayCtrl.GetTopIndex(), 
                              m_displayCtrl.GetTopIndex() + m_displayCtrl.GetCountPerPage());

    m_displayCtrl.UpdateWindow();

    //
    // Ensure that the last item is visible if requested.
    //
    if(m_bShowLatest) {
        m_displayCtrl.EnsureVisible(itemCount - 1,
                                    FALSE);
    }

    //
    // Force an update of the event count in the display
    //
    ::PostMessage(m_hMainWnd, WM_USER_UPDATE_LOGSESSION_LIST, 0, 0);
}



VOID CDisplayDlg::SetState(LOG_SESSION_STATE StateValue)
{
    CLogSession    *pLogSession = NULL;

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hSessionArrayMutex, INFINITE);

    for(LONG ii = 0; ii < m_sessionArray.GetSize(); ii++) {
        pLogSession = (CLogSession *)m_sessionArray[ii];

        if(NULL == pLogSession) {
            continue;
        }

        //
        // Set the log session's state
        //
        pLogSession->SetState(StateValue);
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hSessionArrayMutex);

    ::PostMessage(m_hMainWnd, WM_USER_UPDATE_LOGSESSION_LIST, 0, 0);
}

//
// Macro to create our event callback functions.  This is only
// necessary as there is no context we can pass into our event
// callback function.  So, we setup a unique event callback for
// each log session.  We have 64 here, but the number will have
// to increase to match the total number of possible loggers
//
#define MAKE_EVENT_CALLBACK(n) \
    VOID WINAPI DumpEvent##n(PEVENT_TRACE pEvent)   \
    {                                               \
        CDisplayDlg *pDisplayDlg;                   \
        g_displayIDToDisplayDlgHash.Lookup(n, (void *&)pDisplayDlg);\
        if(NULL != pDisplayDlg) {                   \
            pDisplayDlg->EventHandler(pEvent);      \
        }                                           \
    }

//
// Make 64 of them initially
//
MAKE_EVENT_CALLBACK(0);
MAKE_EVENT_CALLBACK(1);
MAKE_EVENT_CALLBACK(2);
MAKE_EVENT_CALLBACK(3);
MAKE_EVENT_CALLBACK(4);
MAKE_EVENT_CALLBACK(5);
MAKE_EVENT_CALLBACK(6);
MAKE_EVENT_CALLBACK(7);
MAKE_EVENT_CALLBACK(8);
MAKE_EVENT_CALLBACK(9);
MAKE_EVENT_CALLBACK(10);
MAKE_EVENT_CALLBACK(11);
MAKE_EVENT_CALLBACK(12);
MAKE_EVENT_CALLBACK(13);
MAKE_EVENT_CALLBACK(14);
MAKE_EVENT_CALLBACK(15);
MAKE_EVENT_CALLBACK(16);
MAKE_EVENT_CALLBACK(17);
MAKE_EVENT_CALLBACK(18);
MAKE_EVENT_CALLBACK(19);
MAKE_EVENT_CALLBACK(20);
MAKE_EVENT_CALLBACK(21);
MAKE_EVENT_CALLBACK(22);
MAKE_EVENT_CALLBACK(23);
MAKE_EVENT_CALLBACK(24);
MAKE_EVENT_CALLBACK(25);
MAKE_EVENT_CALLBACK(26);
MAKE_EVENT_CALLBACK(27);
MAKE_EVENT_CALLBACK(28);
MAKE_EVENT_CALLBACK(29);
MAKE_EVENT_CALLBACK(30);
MAKE_EVENT_CALLBACK(31);
MAKE_EVENT_CALLBACK(32);
MAKE_EVENT_CALLBACK(33);
MAKE_EVENT_CALLBACK(34);
MAKE_EVENT_CALLBACK(35);
MAKE_EVENT_CALLBACK(36);
MAKE_EVENT_CALLBACK(37);
MAKE_EVENT_CALLBACK(38);
MAKE_EVENT_CALLBACK(39);
MAKE_EVENT_CALLBACK(40);
MAKE_EVENT_CALLBACK(41);
MAKE_EVENT_CALLBACK(42);
MAKE_EVENT_CALLBACK(43);
MAKE_EVENT_CALLBACK(44);
MAKE_EVENT_CALLBACK(45);
MAKE_EVENT_CALLBACK(46);
MAKE_EVENT_CALLBACK(47);
MAKE_EVENT_CALLBACK(48);
MAKE_EVENT_CALLBACK(49);
MAKE_EVENT_CALLBACK(50);
MAKE_EVENT_CALLBACK(51);
MAKE_EVENT_CALLBACK(52);
MAKE_EVENT_CALLBACK(53);
MAKE_EVENT_CALLBACK(54);
MAKE_EVENT_CALLBACK(55);
MAKE_EVENT_CALLBACK(56);
MAKE_EVENT_CALLBACK(57);
MAKE_EVENT_CALLBACK(58);
MAKE_EVENT_CALLBACK(59);
MAKE_EVENT_CALLBACK(60);
MAKE_EVENT_CALLBACK(61);
MAKE_EVENT_CALLBACK(62);
MAKE_EVENT_CALLBACK(63);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\dockdialogbar.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// DockDialogBar.h : header file for CDockDialogBar class
//////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DOCKDIALOGBAR_H__85D92394_C61A_4310_ABA1_F4A61E034A7D__INCLUDED_)
#define AFX_DOCKDIALOGBAR_H__85D92394_C61A_4310_ABA1_F4A61E034A7D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "afxpriv.h"
#include "afxtempl.h"

/////////////////////////////////////////////////////////////////////////////
// CDockDialogBar window

class CDockDialogBar : public CControlBar
{
    DECLARE_DYNAMIC(CDockDialogBar);

	const COLORREF	m_clrBtnHilight;
	const COLORREF	m_clrBtnShadow;

	// Construction / destruction
public:
    CDockDialogBar();

// Attributes
public:
    BOOL IsHorz() const;

// Operations
public:

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDockDialogBar)
    public:
    virtual BOOL Create(CWnd* pParentWnd, CDialog *pDialog, CString &pTitle, UINT nID, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_LEFT, BOOL bShowTitleInGripper = FALSE);
    virtual CSize CalcFixedLayout( BOOL bStretch, BOOL bHorz );
    virtual CSize CalcDynamicLayout( int nLength, DWORD dwMode );
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDockDialogBar();
    void StartTracking();
    void StopTracking(BOOL bAccept);
    void OnInvertTracker(const CRect& rect);
    
    // implementation helpers
    CPoint& ClientToWnd(CPoint& point);

    CString     m_pTitle;

protected:
	void		DrawGripper(CDC &dc);

    CSize       m_sizeMin;
    CSize       m_sizeHorz;
    CSize       m_sizeVert;
    CSize       m_sizeFloat;
    CRect       m_rectBorder;
    CRect       m_rectTracker;
    UINT        m_nDockBarID;
    CPoint      m_ptOld;
    BOOL        m_bTracking;
    BOOL        m_bInRecalcNC;
    int         m_cxEdge;
	CRect		m_rectUndock;
	CRect		m_rectClose;
	CRect		m_rectGripper;
	int			m_cxGripper;
	int			m_cxBorder;
	CDialog*	m_pDialog;
    CBrush		m_brushBkgd;
    BOOL        m_bKeepSize;
	int         m_cyBorder;
	int         m_cMinWidth;
	int         m_cMinHeight;
	int         m_cCaptionSize;
    BOOL        m_bShowTitleInGripper;

// Generated message map functions
protected:
   //{{AFX_MSG(CDockDialogBar)
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
    afx_msg void OnNcPaint();
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg UINT OnNcHitTest(CPoint point);
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnCaptureChanged(CWnd *pWnd);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
    afx_msg void OnWindowPosChanging(WINDOWPOS FAR* LpWndPos);
	//}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOCKDIALOGBAR_H__85D92394_C61A_4310_ABA1_F4A61E034A7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\listctrlex.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ListCtrlEx.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "ListCtrlEx.h"
#include "LogSessionDlg.h"

// CListCtrlEx 

IMPLEMENT_DYNAMIC(CListCtrlEx, CListCtrl)
CListCtrlEx::CListCtrlEx()
    : CListCtrl()
{
    //
    // Initialize flag for suspending list control updates
    // See SuspendUpdates() function
    //
    m_bSuspendUpdates = FALSE;
}

CListCtrlEx::~CListCtrlEx()
{
}

void CListCtrlEx::DoDataExchange(CDataExchange* pDX)
{
    CListCtrl::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CListCtrlEx, CListCtrl)
    //{{AFX_MSG_MAP(CLogSessionDlg)
    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CListCtrlEx::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult)
{
    CLogSession    *pLogSession = NULL;
    CLogSessionDlg *pDialog = NULL;
    CDisplayDlg    *pDisplayDlg = NULL;
    LVITEM          item;

    //
    // the structure is actually a NMLVCUSTOMDRAW that 
    // specifies what the custom draw action is attempting
    //  to do. We need to cast the generic pNMHDR pointer.
    //
    LPNMLVCUSTOMDRAW    lplvcd = (LPNMLVCUSTOMDRAW)pNMHDR;
    int                 iCol = lplvcd->iSubItem;
    int                 iRow = (int)lplvcd->nmcd.dwItemSpec;

    switch(lplvcd->nmcd.dwDrawStage) {
        case CDDS_PREPAINT:
            //
            // ask for subitem notifications.
            //
            *pResult = CDRF_NOTIFYSUBITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
            //
            // ask for subitem notifications.
            //
            *pResult = CDRF_NOTIFYSUBITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT|CDDS_SUBITEM: 
            //
            // recd when CDRF_NOTIFYSUBITEMDRAW is returned in
            // response to CDDS_ITEMPREPAINT.
            //
            *pResult = CDRF_NEWFONT;

            //
            // Default text is black on white background
            //
            lplvcd->clrTextBk = RGB(255, 255, 255);
            lplvcd->clrText = RGB(0, 0, 0);

            if((iCol == 0) && (iRow < GetItemCount())) {
                item.iItem = iRow;
                item.state = LVIF_PARAM;
                item.mask = LVIF_PARAM;

                CListCtrl::GetItem(&item);

                pLogSession = (CLogSession *)item.lParam;

                //
                // Go with the default if no session found
                //
                if(NULL == pLogSession) {
                    return;
                }

                //
                // Set the text color
                //
                lplvcd->clrText = pLogSession->m_titleTextColor;
                lplvcd->clrTextBk = pLogSession->m_titleBackgroundColor;
                return;
            } else if(iRow < GetItemCount()) {
                item.iItem = iRow;
                item.state = LVIF_PARAM;
                item.mask = LVIF_PARAM;

                CListCtrl::GetItem(&item);

                pLogSession = (CLogSession *)item.lParam;

                //
                // Go with the default if no session found
                //
                if(NULL == pLogSession) {
                    return;
                }

                //
                // These fields are always grayed out as they cannot be 
                // altered directly by the user
                //
                pDialog = (CLogSessionDlg *)GetParent();

                if(pDialog == NULL) {
                    return;
                }
                    
                if(State == pDialog->m_retrievalArray[iCol]) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);

                    //
                    // Update the state text whenever we get here
                    //
                    if(pLogSession->m_logSessionValues[pDialog->m_retrievalArray[iCol]].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[pDialog->m_retrievalArray[iCol]]);
                    }

                    return;
                }

                if(EventCount == pDialog->m_retrievalArray[iCol]) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);

                    pDisplayDlg = pLogSession->GetDisplayWnd();
                    if(NULL == pDisplayDlg) {
                        return;
                    }

                    //
                    // Update the event count text whenever we get here
                    //
                    pLogSession->m_logSessionValues[EventCount].Format(_T("%d"), pDisplayDlg->m_totalEventCount);
                    if(pLogSession->m_logSessionValues[EventCount].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[EventCount]);
                    }

                    return;
                }

                if(LostEvents == pDialog->m_retrievalArray[iCol]) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);

                    pDisplayDlg = pLogSession->GetDisplayWnd();
                    if(NULL == pDisplayDlg) {
                        return;
                    }

                    //
                    // Update the event count text whenever we get here
                    //
                    pLogSession->m_logSessionValues[LostEvents].Format(_T("%d"), pDisplayDlg->m_totalEventsLost);
                    if(pLogSession->m_logSessionValues[LostEvents].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[LostEvents]);
                    }

                    return;
                }

                if(BuffersRead == pDialog->m_retrievalArray[iCol]) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);

                    pDisplayDlg = pLogSession->GetDisplayWnd();
                    if(NULL == pDisplayDlg) {
                        return;
                    }

                    //
                    // Update the event count text whenever we get here
                    //
                    pLogSession->m_logSessionValues[BuffersRead].Format(_T("%d"), pDisplayDlg->m_totalBuffersRead);
                    if(pLogSession->m_logSessionValues[BuffersRead].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[BuffersRead]);
                    }

                    return;
                }

                //
                // Update all log session parameters if necessary
                //

                //
                // Flags
                //
                if(Flags == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[Flags].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[Flags]);
                    }
                }

                //
                // FlushTime
                //
                if(FlushTime == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[FlushTime].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[FlushTime]);
                    }
                }

                //
                // MaximumBuffers
                //
                if(MaximumBuffers == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[MaximumBuffers].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[MaximumBuffers]);
                    }
                }

                //
                // MinimumBuffers
                //
                if(MinimumBuffers == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[MinimumBuffers].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[MinimumBuffers]);
                    }
                }

                //
                // BufferSize
                //
                if(BufferSize == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[BufferSize].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[BufferSize]);
                    }
                }

                //
                // DecayTime
                //
                if(DecayTime == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[DecayTime].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[DecayTime]);
                    }
                }

                //
                // Circular
                //
                if(Circular == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[Circular].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[Circular]);
                    }
                }

                //
                // Sequential
                //
                if(Sequential == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[Sequential].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[Sequential]);
                    }
                }

                //
                // NewFile
                //
                if(NewFile == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[NewFile].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[NewFile]);
                    }
                }

                //
                // GlobalSequence
                //
                if(GlobalSequence == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[GlobalSequence].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[GlobalSequence]);
                    }
                }

                //
                // LocalSequence
                //
                if(LocalSequence == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[LocalSequence].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[LocalSequence]);
                    }
                }

                //
                // Level
                //
                if(Level == pDialog->m_retrievalArray[iCol]) {
                    if(pLogSession->m_logSessionValues[Level].Compare(CListCtrl::GetItemText(iRow, iCol))) {
                        CListCtrl::SetItemText(iRow, iCol, pLogSession->m_logSessionValues[Level]);
                    }
                }

                //
                // If this is a kernel logger session, then gray out
                // the flags field
                //
                if((Flags == pDialog->m_retrievalArray[iCol]) &&
                    (!_tcscmp(pLogSession->GetDisplayName(), _T("NT Kernel Logger")))) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);
                    return;
                }

                //
                // If the trace session is not active all fields are 
                // shown with default
                //
                if(!pLogSession->m_bTraceActive) {
                    return;
                }

                //
                // For existing logfile trace sessions we opt 
                // for default
                //
                if(pLogSession->m_bDisplayExistingLogFileOnly) {
                    return;
                }


                //
                // If the trace session is active, we gray out
                // any fields that cannot be updated while active.
                //
                if((Flags != pDialog->m_retrievalArray[iCol]) &&
                    (MaximumBuffers != pDialog->m_retrievalArray[iCol]) &&
                        (FlushTime != pDialog->m_retrievalArray[iCol])) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);
                    return;
                }
            }

            //
            // Default text is black on white background
            //
            lplvcd->clrTextBk = RGB(255, 255, 255);
            lplvcd->clrText = RGB(0, 0, 0);
            break;

        default:
            *pResult = CDRF_DODEFAULT;
    }
}

int CListCtrlEx::InsertItem(int nItem, LPCTSTR lpszItem, CLogSession *pLogSession)
{
    //
    // We don't allow NULL item data
    //
    if(pLogSession == NULL) {
        return 0;
    }
    
    //
    // Insert the item into the list with 
    // the log session as item data
    //
    return CListCtrl::InsertItem(LVIF_TEXT | LVIF_PARAM, 
                                 nItem, 
                                 lpszItem, 
                                 LVIF_TEXT | LVIF_PARAM, 
                                 0, 
                                 0, 
                                 (LPARAM)pLogSession);
}

BOOL CListCtrlEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LPNMHDR pNH = (LPNMHDR) lParam; 

    //
	// wParam is zero for Header ctrl
    //
	if(wParam == 0 && pNH->code == NM_RCLICK)	{
        NMLISTVIEW NMListView;
        NMListView.hdr.code = HDN_ITEMRCLICK;
        NMListView.hdr.hwndFrom = m_hWnd;
        NMListView.hdr.idFrom = GetDlgCtrlID();

        CWnd* pWnd = GetParent();

        pWnd->SendMessage(WM_NOTIFY, 
                          GetDlgCtrlID(),
                          (LPARAM)&NMListView);

        return TRUE;
    }

    return CListCtrl::OnNotify(wParam, lParam, pResult);
}

BOOL CListCtrlEx::RedrawItems(int nFirst, int nLast)
{
    if(!m_bSuspendUpdates) {
        return CListCtrl::RedrawItems(nFirst, nLast);
    }

    return FALSE;
}

void CListCtrlEx::UpdateWindow()
{
    if(!m_bSuspendUpdates) {
        CListCtrl::UpdateWindow();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\listctrlex.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ListCtrlEx.h : CListCtrl derived class
//////////////////////////////////////////////////////////////////////////////

#include <afxtempl.h>


class CListCtrlEx : public CListCtrl
{
    DECLARE_DYNAMIC(CListCtrlEx)

public:
    CListCtrlEx();   // standard constructor
    virtual ~CListCtrlEx();

    int InsertItem(int nItem, LPCTSTR lpszItem, CLogSession *pLogSession);

    BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    BOOL RedrawItems(int nFirst, int nLast);
    void UpdateWindow();

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    //
    // Suspend updating list control items.  This is used
    // to stop updates while CSubItemEdit/Combo instances are active
    // in the list control.  Otherwise, the updates disrupt the
    // edit and combo controls.
    //
    INLINE VOID SuspendUpdates(BOOL bSuspendUpdates) 
    {
        InterlockedExchange((PLONG)&m_bSuspendUpdates, (LONG)bSuspendUpdates);
    }

public:
    //{{AFX_MSG(CLogSessionDlg)
    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    CMapWordToPtr   m_colorMap;
    COLORREF        m_foreGround[MAX_LOG_SESSIONS];
    COLORREF        m_backGround[MAX_LOG_SESSIONS];
    BOOL            m_bSuspendUpdates;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logdisplayoptiondlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogDisplayOptionDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "Utils.h"
#include "LogDisplayOptionDlg.h"


CString itemName[MaxLogSessionOptions] = {"State",
                                          "Event Count",
                                          "Events Lost",
                                          "Buffers Read",
                                          "Flags",
	                                      "Flush Time (S)",
	                                      "Maximum Buffers",
	                                      "Minimum Buffers",
	                                      "Buffer Size",
	                                      "Decay Time (Minutes)",
	                                      "Circular Buffer Size (MB)",
	                                      "Sequential Buffer Size (MB)",
	                                      "Start New File After Buffer Size (MB)",
                                          "Use Global Sequence Numbers",
                                          "Use Local Sequence Numbers",
										  "Level"};


// CListCtrlDisplay - CListCtrl class only used for CLogDisplayOptionDlg

IMPLEMENT_DYNAMIC(CListCtrlDisplay, CListCtrl)
CListCtrlDisplay::CListCtrlDisplay(CLogSessionPropSht *pPropSheet)
    : CListCtrl()
{
    m_pPropSheet = pPropSheet;
}

CListCtrlDisplay::~CListCtrlDisplay()
{
}

void CListCtrlDisplay::DoDataExchange(CDataExchange* pDX)
{
    CListCtrl::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CListCtrlDisplay, CListCtrl)
    //{{AFX_MSG_MAP(CLogSessionDlg)
    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CListCtrlDisplay::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult)
{
    LVITEM          item;

    //
    // the structure is actually a NMLVCUSTOMDRAW that 
    // specifies what the custom draw action is attempting
    //  to do. We need to cast the generic pNMHDR pointer.
    //
    LPNMLVCUSTOMDRAW    lplvcd = (LPNMLVCUSTOMDRAW)pNMHDR;
    int                 iRow = (int)lplvcd->nmcd.dwItemSpec;

    switch(lplvcd->nmcd.dwDrawStage) {
        case CDDS_PREPAINT:
            //
            // ask for subitem notifications.
            //
            *pResult = CDRF_NOTIFYSUBITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
            //
            // ask for subitem notifications.
            //
            *pResult = CDRF_NOTIFYSUBITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT|CDDS_SUBITEM: 
            //
            // recd when CDRF_NOTIFYSUBITEMDRAW is returned in
            // response to CDDS_ITEMPREPAINT.
            //
            *pResult = CDRF_NEWFONT;

            //
            // Default text is black on white background
            //
            lplvcd->clrTextBk = RGB(255, 255, 255);
            lplvcd->clrText = RGB(0, 0, 0);

            if(iRow < MaxLogSessionOptions) {
                item.iItem = iRow;
                item.state = LVIF_PARAM;
                item.mask = LVIF_PARAM;

                //
                // These fields are always grayed out as they cannot be 
                // altered directly by the user
                //
                if((State == iRow) ||
                    (EventCount == iRow) ||
                    (LostEvents == iRow) ||
                    (BuffersRead == iRow)) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);

                    return;
                }

                //
                // The Flags field should be grayed out for 
                // NT Kernel Logger sessions
                //
                if((Flags == iRow) && 
                    (!_tcscmp(m_pPropSheet->m_displayName, _T("NT Kernel Logger")))) {
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                    lplvcd->clrText = RGB(145, 145, 145);

                    return;
                }
            }
            break;

        default:
            *pResult = CDRF_DODEFAULT;
    }
}


// CLogDisplayOptionDlg dialog

IMPLEMENT_DYNAMIC(CLogDisplayOptionDlg, CPropertyPage)
CLogDisplayOptionDlg::CLogDisplayOptionDlg(CLogSessionPropSht *pPropSheet)
	: CPropertyPage(CLogDisplayOptionDlg::IDD),
    m_displayOptionList(pPropSheet)
{
    m_pPropSheet = pPropSheet;
    m_bTraceActive = m_pPropSheet->m_pLogSession->m_bTraceActive;
}

CLogDisplayOptionDlg::~CLogDisplayOptionDlg()
{
}

BOOL CLogDisplayOptionDlg::OnSetActive() 
{
    m_pPropSheet->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
   
    m_displayOptionList.SetFocus();

    //
    // Gray out unsettable items
    //
    if(m_bTraceActive) {
        for(LONG ii = 0; ii < MaxLogSessionOptions; ii++) {
            if((ii != FlushTime) && 
               (ii != MaximumBuffers) && 
               (ii != Flags)) {
                m_displayOptionList.SetItemState(ii, LVIS_CUT, LVIS_CUT);
            }
        }
    } else {
        for(LONG ii = 0; ii < MaxLogSessionOptions; ii++) {
            if((ii == State) || 
               (ii == EventCount) || 
               (ii == LostEvents) ||
               (ii == BuffersRead)) {
                m_displayOptionList.SetItemState(ii, LVIS_CUT, LVIS_CUT);
            }
        }
    }

    //
    // Disable Flags value editing for NT Kernel Logger
    //
    if(!_tcscmp(m_pPropSheet->m_displayName, _T("NT Kernel Logger"))) {
        m_displayOptionList.SetItemState(Flags, LVIS_CUT, LVIS_CUT);
    }

    m_displayOptionList.RedrawItems(0, MaxLogSessionOptions);
    m_displayOptionList.UpdateWindow();


    return CPropertyPage::OnSetActive();
}

BOOL CLogDisplayOptionDlg::OnInitDialog()
{
	RECT    rc; 
    CString str;
    BOOL    retVal;

	retVal = CDialog::OnInitDialog();

    //
    // get the dialog dimensions
    //
    GetParent()->GetClientRect(&rc);

    if(!m_displayOptionList.Create(WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT,
								   rc, 
                                   this, 
                                   IDC_LOG_DISPLAY_OPTION_LIST)) 
    {
        TRACE(_T("Failed to create log session option list control\n"));
        return FALSE;
    }

	m_displayOptionList.CenterWindow();

	m_displayOptionList.SetExtendedStyle(LVS_EX_GRIDLINES|LVS_EX_FULLROWSELECT);

    //
    // Insert the columns for the list control
    //
	m_displayOptionList.InsertColumn(0, 
                                    _T("Option"), 
                                     LVCFMT_LEFT, 
                                     300);
    m_displayOptionList.InsertColumn(1, 
                                    _T("Value"), 
                                     LVCFMT_LEFT, 
                                     rc.right - rc.left - m_displayOptionList.GetColumnWidth(0) - 22);

    //
	// set the values in the display
    //
    for(LONG ii = 0; ii < MaxLogSessionOptions; ii++) {
	    m_displayOptionList.InsertItem(ii, itemName[ii]);
        m_displayOptionList.SetItemText(ii, 1, m_pPropSheet->m_logSessionValues[ii]);
    }
	return retVal;
}

void CLogDisplayOptionDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CLogDisplayOptionDlg, CPropertyPage)
    ON_NOTIFY(NM_CLICK, IDC_LOG_DISPLAY_OPTION_LIST, OnNMClickDisplayList)
    ON_MESSAGE(WM_PARAMETER_CHANGED, OnParameterChanged)
END_MESSAGE_MAP()


// CLogDisplayOptionDlg message handlers

void CLogDisplayOptionDlg::OnNMClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
    CString         str;
    DWORD           position;
    int		        listIndex;
    LVHITTESTINFO   lvhti;
	CRect			itemRect;
	CRect			parentRect;

    //
    // Get the position of the mouse when this 
    // message posted
    //
    position = ::GetMessagePos();

    //
    // Get the position in an easy to use format
    //
    CPoint	point((int) LOWORD (position), (int)HIWORD(position));

    //
    // Convert to client coordinates
    //
    ScreenToClient(&point);

    lvhti.pt = point;

    listIndex = m_displayOptionList.SubItemHitTest(&lvhti);

    if(0 == lvhti.iSubItem) {
        if(-1 == lvhti.iItem) {
            //str.Format(_T("NM Click: Item = %d, Flags = 0x%X\n"), lvhti.iItem, lvhti.flags);
            //TRACE(str);
        } else {
            //str.Format(_T("NM Click: Item = %d\n"), lvhti.iItem);
            //TRACE(str);
        }
    } else if(-1 == lvhti.iItem) {
        //str.Format(_T("NM Click: Item = %d, Flags = 0x%X\n"), lvhti.iItem, lvhti.flags);
        //TRACE(str);
    } else {
        //str.Format(_T("NM Click: Item = %d, "), lvhti.iItem);
        //TRACE(str);
        //str.Format(_T("SubItem = %d\n"), lvhti.iSubItem);
		//TRACE(str);

		GetClientRect(&parentRect);

		m_displayOptionList.GetSubItemRect(lvhti.iItem, lvhti.iSubItem, LVIR_BOUNDS, itemRect);

		itemRect.right = m_displayOptionList.GetColumnWidth(0) + parentRect.left + (itemRect.right - itemRect.left);
		itemRect.left = m_displayOptionList.GetColumnWidth(0) + parentRect.left;

        *pResult = 0;

        if(lvhti.iItem == State) {
            return;
        }

        //
        // Determine if the user selected a modifiable field.  If
        // so, pop up the proper edit or combo box to allow the user
        // to modify the log session properties.
        //
        if(((lvhti.iItem == GlobalSequence) ||
            (lvhti.iItem == LocalSequence)) &&
                (LVIS_CUT != m_displayOptionList.GetItemState(lvhti.iItem, LVIS_CUT))) {

		    CComboBox *pCombo = new CSubItemCombo(lvhti.iItem, 
										          lvhti.iSubItem,
										          &m_displayOptionList);

		    pCombo->Create(WS_BORDER|WS_CHILD|WS_VISIBLE|CBS_DROPDOWNLIST, 
					       itemRect, 
					       &m_displayOptionList, 
					       1);
            return;
        }

        if((lvhti.iItem == Circular) &&
            (LVIS_CUT != m_displayOptionList.GetItemState(lvhti.iItem, LVIS_CUT))){

		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayOptionList);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					    itemRect, 
					    this, 
					    1);

            return;
        }

        if((lvhti.iItem == Sequential) &&
            (LVIS_CUT != m_displayOptionList.GetItemState(lvhti.iItem, LVIS_CUT))){
		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayOptionList);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      1);

            return;
        }

        if((lvhti.iItem == NewFile) &&
            (LVIS_CUT != m_displayOptionList.GetItemState(lvhti.iItem, LVIS_CUT))){
		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayOptionList);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      1);

            
            return;
        }

        if(LVIS_CUT != m_displayOptionList.GetItemState(lvhti.iItem, LVIS_CUT)){
		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayOptionList);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      1);
        }
    }
}

LRESULT CLogDisplayOptionDlg::OnParameterChanged(WPARAM wParam, LPARAM lParam)
{
    CString str;

    //
    // Get the changed text
    //
    str = m_displayOptionList.GetItemText((int)wParam, (int)lParam);

    if(((int)wParam == Circular) && 
        !str.IsEmpty()) {
        m_displayOptionList.SetItemText(Sequential, (int)lParam, _T(""));
        m_displayOptionList.SetItemText(NewFile, (int)lParam, _T(""));
    }

    if(((int)wParam == Sequential) && 
        !str.IsEmpty()) {
        m_displayOptionList.SetItemText(Circular, (int)lParam, _T(""));
        m_displayOptionList.SetItemText(NewFile, (int)lParam, _T(""));
    }

    if(((int)wParam == NewFile) && 
        !str.IsEmpty()) {
        m_displayOptionList.SetItemText(Circular, (int)lParam, _T(""));
        m_displayOptionList.SetItemText(Sequential, (int)lParam, _T(""));
    }

    if(((int)wParam == GlobalSequence) && 
       !str.Compare(_T("TRUE"))) {
        m_displayOptionList.SetItemText(LocalSequence, (int)lParam, _T("FALSE"));
    }

    if(((int)wParam == LocalSequence) && 
       !str.Compare(_T("TRUE"))) {
        m_displayOptionList.SetItemText(GlobalSequence, (int)lParam, _T("FALSE"));
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logfiledlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogFileDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "LogFileDlg.h"


// CLogFileDlg dialog

IMPLEMENT_DYNAMIC(CLogFileDlg, CDialog)
CLogFileDlg::CLogFileDlg(CWnd* pParent, CLogSession *pLogSession)
	: CDialog(CLogFileDlg::IDD, pParent)
{
    ASSERT(pLogSession != NULL);

    m_pLogSession = pLogSession;

    m_pLogSession->m_bDisplayExistingLogFileOnly = TRUE;

    //
    // Initialize summary and listing file flags
    //
    m_bWriteListingFile = FALSE;
    m_bWriteSummaryFile = FALSE;
}

CLogFileDlg::~CLogFileDlg()
{
}

BOOL CLogFileDlg::OnInitDialog()
{
    CString         str;
    BOOL            retVal;
    CDisplayDlg    *pDisplayDlg = NULL;

    retVal = CDialog::OnInitDialog();

    pDisplayDlg = m_pLogSession->GetDisplayWnd();

    //
    // setup the listing and summary file edit and check boxes
    //
    if(NULL == pDisplayDlg) {
        m_listingFileName = (LPCTSTR)m_pLogSession->GetDisplayName();
        m_listingFileName +=_T(".out");
        ((CEdit *)GetDlgItem(IDC_LISTING_EDIT))->SetWindowText(m_listingFileName);

        m_summaryFileName = (LPCTSTR)m_pLogSession->GetDisplayName();
        m_summaryFileName +=_T(".sum");
        ((CEdit *)GetDlgItem(IDC_SUMMARY_EDIT))->SetWindowText(m_summaryFileName);

        //
        // Disable the edit boxes
        //
        ((CEdit *)GetDlgItem(IDC_LISTING_EDIT))->EnableWindow(m_bWriteListingFile);
        ((CEdit *)GetDlgItem(IDC_SUMMARY_EDIT))->EnableWindow(m_bWriteSummaryFile);
    } else {
        ((CEdit *)GetDlgItem(IDC_LISTING_EDIT))->SetWindowText(pDisplayDlg->m_listingFileName);
        ((CEdit *)GetDlgItem(IDC_SUMMARY_EDIT))->SetWindowText(pDisplayDlg->m_summaryFileName);

        ((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->SetCheck(pDisplayDlg->m_bWriteListingFile);
        ((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->SetCheck(pDisplayDlg->m_bWriteSummaryFile);

        //
        // Enable or disable the edit boxes as appropriate
        //
        ((CEdit *)GetDlgItem(IDC_LISTING_EDIT))->EnableWindow(pDisplayDlg->m_bWriteListingFile && !m_pLogSession->m_bTraceActive);
        ((CEdit *)GetDlgItem(IDC_SUMMARY_EDIT))->EnableWindow(pDisplayDlg->m_bWriteSummaryFile && !m_pLogSession->m_bTraceActive);

        //
        // Set the summary and listing check boxes as appropriate
        //
        ((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->SetCheck(pDisplayDlg->m_bWriteListingFile);
        ((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->SetCheck(pDisplayDlg->m_bWriteSummaryFile);

        //
        // Enable the summary and listing check boxes as appropriate
        //
        ((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->EnableWindow(!m_pLogSession->m_bTraceActive);
        ((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->EnableWindow(!m_pLogSession->m_bTraceActive);
    }

    //
    // setup the logfile edit box
    //
    ((CEdit *)GetDlgItem(IDC_LOGFILE_EDIT))->SetWindowText(m_pLogSession->m_logFileName);

    return retVal;
}

void CLogFileDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_LOGFILE_EDIT, m_logFileName);
    DDX_Control(pDX, IDC_LISTING_EDIT, m_listingFile);
    DDX_Control(pDX, IDC_SUMMARY_EDIT, m_summaryFile);
}


BEGIN_MESSAGE_MAP(CLogFileDlg, CDialog)
    ON_BN_CLICKED(IDC_LOGFILE_BROWSE_BUTTON, OnBnClickedLogfileBrowseButton)
    ON_BN_CLICKED(IDC_LISTING_FILE_CHECK, OnBnClickedListingFileCheck)
    ON_BN_CLICKED(IDC_SUMMARY_FILE_CHECK, OnBnClickedSummaryFileCheck)
    ON_BN_CLICKED(IDOK, OnBnClickedOk)
END_MESSAGE_MAP()


// CLogFileDlg message handlers

void CLogFileDlg::OnBnClickedLogfileBrowseButton()
{
	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE,_T("etl"),_T("*.etl"),
				        OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | 
                            OFN_READONLY | OFN_HIDEREADONLY |
                            OFN_EXPLORER | OFN_NOCHANGEDIR, 
				       _T("Log Session Files (*.etl)|*.etl|All Files (*.*)|*.*||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name
	//
    m_pLogSession->m_logFileName = fileDlg.GetPathName();
    m_logFileName.SetWindowText(m_pLogSession->m_logFileName);
    m_logFileName.SetFocus();
}

void CLogFileDlg::OnBnClickedListingFileCheck()
{
    BOOL isChecked;

    isChecked = (BOOL)((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->GetCheck();

    //
    // enable the edit box as appropriate
    //
    ((CEdit *)GetDlgItem(IDC_LISTING_EDIT))->EnableWindow(isChecked);
}

void CLogFileDlg::OnBnClickedSummaryFileCheck()
{
    BOOL isChecked;

    isChecked = (BOOL)((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->GetCheck();

    //
    // enable the edit box as appropriate
    //
    ((CEdit *)GetDlgItem(IDC_SUMMARY_EDIT))->EnableWindow(isChecked);
}

void CLogFileDlg::OnBnClickedOk()
{
    CString         str;
    CDisplayDlg    *pDisplayDlg = NULL;

    pDisplayDlg = m_pLogSession->GetDisplayWnd();

    if(pDisplayDlg != NULL) {
        //
        // If the listing file check box is checked get the file name
        // and set the log session to generate the file
        //
        if(((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->GetCheck()) {
            pDisplayDlg->m_bWriteListingFile = TRUE;
            m_listingFile.GetWindowText(pDisplayDlg->m_listingFileName);
        } else {
            pDisplayDlg->m_bWriteListingFile = FALSE;
        }

        //
        // If the summary file check box is checked get the file name
        // and set the log session to generate the file
        //
        if(((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->GetCheck()) {
            pDisplayDlg->m_bWriteSummaryFile = TRUE;
            m_summaryFile.GetWindowText(pDisplayDlg->m_summaryFileName);
        } else {
            pDisplayDlg->m_bWriteSummaryFile = FALSE;
        }
    } else {
        //
        // If the listing file check box is checked get the file name
        //
        if(((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->GetCheck()) {
            m_bWriteListingFile = TRUE;
            m_listingFile.GetWindowText(m_listingFileName);
        } else {
            m_bWriteListingFile = FALSE;
        }

        //
        // If the summary file check box is checked get the file name
        //
        if(((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->GetCheck()) {
            m_bWriteSummaryFile = TRUE;
            m_summaryFile.GetWindowText(m_summaryFileName);
        } else {
            m_bWriteSummaryFile = FALSE;
        }
    }

    //
    // Get the logfile name, don't exit dialog if it isn't valid
    //
    m_logFileName.GetWindowText(m_pLogSession->m_logFileName);

    if(m_pLogSession->m_logFileName.IsEmpty()) {
        AfxMessageBox(_T("A Valid Log File Must Be Provided"));
        return;
    }

    OnOK();

    EndDialog(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logdisplayoptiondlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogDisplayOptionDlg.h : interface for the CLogDisplayOptionDlg class
//////////////////////////////////////////////////////////////////////////////

#pragma once

// forward reference
class CLogSessionPropSht;


// CListCtrlDisplay class

class CListCtrlDisplay : public CListCtrl
{
    DECLARE_DYNAMIC(CListCtrlDisplay)

public:
    CListCtrlDisplay(CLogSessionPropSht *pPropSheet);
    virtual ~CListCtrlDisplay();

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

public:
    //{{AFX_MSG(CLogSessionDlg)
    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    CLogSessionPropSht *m_pPropSheet;
};



// CLogDisplayOptionDlg dialog

class CLogDisplayOptionDlg : public CPropertyPage
{
	DECLARE_DYNAMIC(CLogDisplayOptionDlg)

public:
	CLogDisplayOptionDlg(CLogSessionPropSht *pPropSheet);
	virtual ~CLogDisplayOptionDlg();

	BOOL OnInitDialog();
    BOOL OnSetActive();

    LRESULT OnParameterChanged(WPARAM wParam, LPARAM lParam);


// Dialog Data
	enum { IDD = IDD_LOG_DISPLAY_OPTIONS_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

public:
	CListCtrlDisplay    m_displayOptionList;
	CEdit				m_levelValue;
	CEdit			    m_maxBufValue;
    CEdit			    m_minBufValue;
    CEdit			    m_bufferSizeValue;
    CEdit			    m_flushTimeValue;
    CEdit			    m_decayTimeValue;
    CEdit			    m_newFileValue;
    CEdit			    m_cirValue;
    CEdit			    m_flagsValue;
    CEdit			    m_seqValue;
    CLogSession        *m_pLogSession;
    CLogSessionPropSht *m_pPropSheet;
    BOOL                m_bTraceActive;

	DECLARE_MESSAGE_MAP()
    afx_msg void OnNMClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logfiledlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogFileDlg.h : interface of the CLogFileDlg class
//////////////////////////////////////////////////////////////////////////////


#pragma once
#include "afxwin.h"


// CLogFileDlg dialog

class CLogFileDlg : public CDialog
{
	DECLARE_DYNAMIC(CLogFileDlg)

public:
	CLogFileDlg(CWnd* pParent, CLogSession *pLogSession);
	virtual ~CLogFileDlg();

    BOOL OnInitDialog();

// Dialog Data
	enum { IDD = IDD_LOG_FILE_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
    afx_msg void OnBnClickedLogfileBrowseButton();
    afx_msg void OnBnClickedListingFileCheck();
    afx_msg void OnBnClickedSummaryFileCheck();
    afx_msg void OnBnClickedOk();

    CEdit           m_logFileName;
    CLogSession    *m_pLogSession;
    CEdit           m_listingFile;
    CEdit           m_summaryFile;
    CString         m_listingFileName;
    CString         m_summaryFileName;
    BOOL            m_bWriteListingFile;
    BOOL            m_bWriteSummaryFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsession.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSession.h : interface of the CLogSession class
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CDisplayDlg;

class CTraceSession
{
public:
    // constructor
    CTraceSession(ULONG TraceSessionID);

    // destructor
    ~CTraceSession();

    BOOL ProcessPdb();

    ULONG               m_traceSessionID;
    CString             m_tempDirectory;
    CString             m_pdbFile;
    CStringArray        m_tmfFile;
    CString             m_tmfPath;
    CStringArray        m_tmcFile;
    CString             m_ctlFile;
    CStringArray        m_controlGuid;
    CStringArray        m_controlGuidFriendlyName;
    CStringArray        m_formatGuid;
    BOOL                m_bKernelLogger;
};

// forward reference
class CLogSessionDlg;

class CLogSession
{
public:
    // constructor
    CLogSession(ULONG LogSessionID, CLogSessionDlg *pLogSessionDlg);

    // destructor
    ~CLogSession();

    BOOL BeginTrace(BOOL   bUseExisting = FALSE);
    BOOL UpdateSession(PEVENT_TRACE_PROPERTIES pQueryProperties);
    LONG EndTrace();
    VOID SetState(LOG_SESSION_STATE StateValue);

    INLINE VOID SetDisplayName(CString &DisplayName)
    {
        m_displayName = DisplayName;
    }

    INLINE CString & GetDisplayName()
    {
        return m_displayName;
    }

    INLINE CDisplayDlg* GetDisplayWnd()
    {
        return m_pDisplayDialog;
    }

    INLINE VOID SetDisplayWnd(CDisplayDlg *pDisplayDlg)
    {
        m_pDisplayDialog = pDisplayDlg;
    }

    INLINE LONG GetGroupID()
    {
        return m_groupID;
    }

    INLINE VOID SetGroupID(LONG GroupID)
    {
        m_groupID = GroupID;
    }

    INLINE LONG GetLogSessionID()
    {
        return m_logSessionID;
    }

    INLINE VOID SetLogSessionID(LONG LogSessionID)
    {
        m_logSessionID = LogSessionID;
    }

    INLINE TRACEHANDLE GetSessionHandle()
    {
        return m_sessionHandle;
    }

    INLINE VOID SetSessionHandle(TRACEHANDLE SessionHandle)
    {
        m_sessionHandle = SessionHandle;
    }

    // log session information
    BOOL                m_bAppend;
    BOOL                m_bRealTime;
    BOOL                m_bWriteLogFile;
    CString             m_logFileName;
    CString             m_displayName;              // Log session display name
    LONG                m_logSessionID;             // Log session identification number
    LONG                m_groupID;                  // Group identification number
    EVENT_TRACE_LOGFILE m_evmFile;                  // struct used for trace processing in real-time thread
    CDisplayDlg        *m_pDisplayDialog;           // Dialog for trace output
    CStringArray        m_logSessionValues;
    BOOL                m_bTraceActive;
    BOOL                m_bSessionActive;
    BOOL                m_bGroupingTrace;           // used for grouping and ungrouping
    BOOL                m_bStoppingTrace;
    TRACEHANDLE         m_sessionHandle;            // Log session handle
    TRACEHANDLE         m_traceHandle;              // Trace event session handle
    CPtrArray           m_traceSessionArray;
    BOOLEAN             m_bDisplayExistingLogFileOnly;
    CLogSessionDlg     *m_pLogSessionDlg;
    CString             m_stateText;
    COLORREF            m_titleTextColor;
    COLORREF            m_titleBackgroundColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionadvpropsht.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionAdvPropSht.cpp : implementation of the CLogSession class
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "traceview.h"
#include "logsession.h"
#include "DisplayDlg.h"
#include "logDisplayOptionDlg.h"
#include "LogSessionOutputOptionDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "LogSessionAdvPropSht.h"

IMPLEMENT_DYNAMIC(CLogSessionAdvPropSht, CPropertySheet)

BEGIN_MESSAGE_MAP(CLogSessionAdvPropSht, CPropertySheet)
	//{{AFX_MSG_MAP(CLogSessionAdvPropSht)
	ON_BN_CLICKED(IDOK, OnBnClickedOk)
	ON_BN_CLICKED(IDCANCEL, OnBnClickedCancel)
	ON_BN_CLICKED(ID_WIZFINISH, OnBnClickedOk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CLogSessionAdvPropSht::CLogSessionAdvPropSht(CWnd* pWndParent, CLogSessionPropSht *pLogSessionPropSht)
	: CPropertySheet(IDS_LOG_SESSION_OPTIONS_TITLE, pWndParent),
    m_displayOptionPage(pLogSessionPropSht)
{
    AddPage(&m_logSessionOutputOptionDlg);

	m_pLogSessionPropSht = pLogSessionPropSht;

    if(m_pLogSessionPropSht->IsWizard()) {
	    AddPage(&m_displayOptionPage);
    }

    m_pLogSession = pLogSessionPropSht->m_pLogSession;
}

BOOL CLogSessionAdvPropSht::OnInitDialog()
{
	CString str;

	BOOL bResult = CPropertySheet::OnInitDialog();

    //
	// add the window to the property sheet.
    //
	CRect rectWnd;
	GetWindowRect(rectWnd);
	SetWindowPos(NULL, 0, 0,
		rectWnd.Width(),
		rectWnd.Height(),
		SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	CenterWindow();

    //
    // Make sure both pages get displayed at
    // least once, so values are updated.  Otherwise,
    // improper data will get copied back to the 
    // CLogSessionPropSht instance.
    //
    if(m_pLogSessionPropSht->IsWizard()) {
        SetActivePage(&m_displayOptionPage);
    }

    SetActivePage(&m_logSessionOutputOptionDlg);

	return bResult;
}

void CLogSessionAdvPropSht::OnBnClickedOk()
{
    CString     str;
    CListCtrl  *pList;

    //
    // Propagate settings back to the CLogSessionPropSht instance.  We
    // wait until here to do this to ensure that any changes made do
    // not effect the data that ends up in the log session settings if
    // a cancel is hit along the way.
    //

    //
    // update the file select checks
    //
    m_pLogSessionPropSht->m_bWriteListingFile = ((CButton *)m_logSessionOutputOptionDlg.GetDlgItem(IDC_LISTING_FILE_CHECK))->GetCheck();
    m_pLogSessionPropSht->m_bWriteSummaryFile = ((CButton *)m_logSessionOutputOptionDlg.GetDlgItem(IDC_SUMMARY_FILE_CHECK))->GetCheck();

    //
    // update the file names
    //
    m_logSessionOutputOptionDlg.m_listingFileName.GetWindowText(m_pLogSessionPropSht->m_listingFileName);
    m_logSessionOutputOptionDlg.m_summaryFileName.GetWindowText(m_pLogSessionPropSht->m_summaryFileName);

    if(m_pLogSessionPropSht->IsWizard()) {
        //
        // update the log session parameter values skipping state
        //
        for(LONG ii = 1; ii < MaxLogSessionOptions; ii++) {
            m_pLogSessionPropSht->m_logSessionValues[ii] =
                m_displayOptionPage.m_displayOptionList.GetItemText(ii, 1);
        }
    }

	EndDialog(1);
}

void CLogSessionAdvPropSht::OnBnClickedCancel()
{
	EndDialog(2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsession.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSession.cpp : implementation of the CLogSession class
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxtempl.h>
#include "DockDialogBar.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
extern "C" {
#include <evntrace.h>
#include "wppfmtstub.h"
}
#include <traceprt.h>
#include "TraceView.h"
#include "utils.h"

#include "LogSession.h"
#include "ListCtrlEx.h"
#include "LogSessionDlg.h"
#include "DisplayDlg.h"


CTraceSession::CTraceSession(ULONG TraceSessionID)
{
    m_traceSessionID = TraceSessionID;

    //
    // Initialize the temp directory
    //
    m_tempDirectory.Empty();

    //
    // Not using kernel logger unless selected by user
    //
    m_bKernelLogger = FALSE;
}

CTraceSession::~CTraceSession()
{
    //
    // remove our working directory
    //
    ClearDirectory(m_tempDirectory);

    //
    // Now remove it
    //
    RemoveDirectory(m_tempDirectory);
}

BOOL CTraceSession::ProcessPdb()
{
    CString         traceDirectory;
    CString         tempPath;
    CString         tmfPath;
    CString         tmcPath;
    CString         providerName;
    CString         temp;
    GUID            directoryGuid;
    CFileFind       fileFind;

    if(m_pdbFile.IsEmpty()) {
        return FALSE;
    }

    if(m_tempDirectory.IsEmpty()) {
        //
        // setup a special directory in which to create our files
        //
        traceDirectory = (LPCTSTR)((CTraceViewApp *)AfxGetApp())->m_traceDirectory;

        //
        // create our own unique directory under the temp directory
        //
        if(S_OK != CoCreateGuid(&directoryGuid)) {
            AfxMessageBox(_T("Failed To Create Temp Directory\nApplication Will Exit"));
            return FALSE;
        }

        GuidToString(directoryGuid, temp);

        traceDirectory += (LPCTSTR)temp;

        traceDirectory += (LPCTSTR)_T("\\");

        if(!CreateDirectory(traceDirectory, NULL)) {
            AfxMessageBox(_T("Failed To Create Temporary Directory For Trace Session"));
            return FALSE;
        }

        //
        // save the directory
        //
        m_tempDirectory = traceDirectory;
    }

    //
    // Clear the directory in case it already existed
    //
    ClearDirectory(m_tempDirectory);

    //
    // Now create the TMF and TMC files
    //
    if(!ParsePdb(m_pdbFile, m_tempDirectory)) {
        AfxMessageBox(_T("Failed To Parse PDB File"));
        return FALSE;
    }

    //
    // Get the control GUID for this provider
    //
    tmfPath = (LPCTSTR)m_tempDirectory;

    tmcPath = (LPCTSTR)m_tempDirectory;

    tmcPath +=_T("\\*.tmc");

    if(!fileFind.FindFile(tmcPath)) {
        AfxMessageBox(_T("Failed To Get Control GUID From PDB"));
        return FALSE;
    } else {
        while(fileFind.FindNextFile()) {
            tmcPath = fileFind.GetFileName();
            m_tmcFile.Add(tmcPath);
        }

        tmcPath = fileFind.GetFileName();
        m_tmcFile.Add(tmcPath);
    }

    if(m_tmcFile.GetSize() == 0) {
        AfxMessageBox(_T("No Control GUIDs Obtained From PDB"));
        return FALSE;
    }

    //
    // Pull the control GUID(s) from the name(s) of the TMC file(s),
    // this is a very backwards way of getting a GUID from a PDB
    // but its what we got
    //
    for(LONG ii = 0; ii < m_tmcFile.GetSize(); ii++) {
        m_controlGuid.Add(
            (LPCTSTR)m_tmcFile[ii].Left(m_tmcFile[ii].Find('.')));
        m_controlGuidFriendlyName.Add(m_pdbFile);
    }

    //
    // Now get the full path and name of the TMF file
    //
    tmfPath +=_T("\\*.tmf");

    if(!fileFind.FindFile(tmfPath)) {
        AfxMessageBox(_T("Failed To Get Format Information From PDB\nEvent Data Will Not Be Formatted"));
    } else {

        while(fileFind.FindNextFile()) {
            //
            // Get the trace event identifier GUID
            //
            tmfPath = (LPCTSTR)fileFind.GetFileName();
            if(!tmfPath.IsEmpty()) {
                //
                // Add format GUID
                //
                m_formatGuid.Add((LPCTSTR)tmfPath.Left(tmfPath.Find('.')));
                //
                // Add the TMF filename to the TMF path
                //
                tmfPath = (LPCTSTR)m_tempDirectory;
                tmfPath +=_T("\\");
                tmfPath += (LPCTSTR)fileFind.GetFileName();
                //
                // Store the TMF path
                //
                m_tmfFile.Add(tmfPath);
            }
        }

        //
        // Get the trace event identifier GUID
        //
        tmfPath = (LPCTSTR)fileFind.GetFileName();
        if(!tmfPath.IsEmpty()) {
            //
            // Add format GUID
            //
            m_formatGuid.Add((LPCTSTR)tmfPath.Left(tmfPath.Find('.')));
            //
            // Add the TMF filename to the TMF path
            //
            tmfPath = (LPCTSTR)m_tempDirectory;
            tmfPath +=_T("\\");
            tmfPath += (LPCTSTR)fileFind.GetFileName();
            //
            // Store the TMF path
            //
            m_tmfFile.Add(tmfPath);
        }
    }

    if(m_tmfFile.GetSize() == 0) {
        AfxMessageBox(_T("Failed To Get Format Information From PDB\nEvent Data Will Not Be Formatted"));
    }

    return TRUE;
}


CLogSession::CLogSession(ULONG LogSessionID, CLogSessionDlg *pLogSessionDlg)
{
    //
    // Save the log session ID
    //
	m_logSessionID = LogSessionID;

    //
    // save the log session dialog pointer
    //
    m_pLogSessionDlg = pLogSessionDlg;

    CString str;

    str.Format(_T("m_pLogSession = %p"), this);

    //
    // initialize class members
    //
    m_pDisplayDialog = NULL;
    m_groupID = -1;
    m_bAppend = FALSE;
    m_bRealTime = TRUE;
    m_logFileName.Format(_T("LogSession%d.etl"), m_logSessionID);
    m_displayName.Format(_T("LogSession%d"), m_logSessionID);
    m_sessionHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    m_bTraceActive = FALSE;
    m_bSessionActive = FALSE;
    m_bStoppingTrace = FALSE;
    m_bDisplayExistingLogFileOnly = FALSE;

    //
    // Initialize default log session parameter values
    //
    m_logSessionValues.Add("STOPPED");  // State
    m_logSessionValues.Add("0");        // Event Count
    m_logSessionValues.Add("0");        // Lost Event Count
    m_logSessionValues.Add("0");        // Event Buffers Read Count
    m_logSessionValues.Add("0xFFFF");      // Flags
	m_logSessionValues.Add("1");        // Flush time in seconds
    m_logSessionValues.Add("21");       // Maximum buffers
    m_logSessionValues.Add("4");        // Minimum buffers
    m_logSessionValues.Add("200");      // Buffer size in KB
    m_logSessionValues.Add("20");       // Decay value in minutes
    m_logSessionValues.Add("");         // Circular file size in MB
    m_logSessionValues.Add("200");      // Sequential file size in MB
    m_logSessionValues.Add("");         // New file after size in MB
    m_logSessionValues.Add("FALSE");    // Use global sequence numbers
    m_logSessionValues.Add("TRUE");     // Use local sequence numbers
    m_logSessionValues.Add("0");        // Level

    //
    // Set the default log session name color
    //
    m_titleTextColor = RGB(0,0,0);
    m_titleBackgroundColor = RGB(255,255,255);

    //
    // Default to writing no log file
    //
    m_bWriteLogFile = FALSE;
}

CLogSession::~CLogSession()
{
    CTraceSession  *pTraceSession;

    //
    // free the trace sessions
    //
    while(m_traceSessionArray.GetSize() > 0) {
        pTraceSession = (CTraceSession *)m_traceSessionArray[0];
        m_traceSessionArray.RemoveAt(0);
        if(NULL != pTraceSession) {
            delete pTraceSession;
        }
    }
}

VOID CLogSession::SetState(LOG_SESSION_STATE StateValue)
{
    LONG    index;
    CString stateText;

    switch(StateValue) {
        case Grouping:
            //
            // set the display text
            //
            stateText =_T("GROUPING");

            m_bGroupingTrace = TRUE;

            break;

        case UnGrouping:
            //
            // set the display text
            //
            stateText =_T("UNGROUPING");

            m_bGroupingTrace = TRUE;

            break;

        case Existing:
            //
            // set the display text
            //
            stateText =_T("EXISTING");

            //
            // Set our state to show a session is in progress
            //
            m_bTraceActive = TRUE;

            m_bGroupingTrace = FALSE;

            break;

        case Running:
            //
            // set the display text
            //
            stateText =_T("RUNNING");

            //
            // Set our state to show a session is in progress
            //
            m_bTraceActive = TRUE;

            m_bGroupingTrace = FALSE;

            break;

        case Stopping:
            if(m_logSessionValues[State].Compare(_T("GROUPING"))) {
                if(m_logSessionValues[State].Compare(_T("UNGROUPING"))) {
                    if(!m_bDisplayExistingLogFileOnly) {
                        //
                        // set the display text
                        //
                        stateText =_T("STOPPING");
                    }
                }
            }

            //
            // Indicate we are done stopping the trace
            //
            m_bStoppingTrace = TRUE;

            break;

        case Stopped:
        default:

            if(m_logSessionValues[State].Compare(_T("GROUPING"))) {
                if(m_logSessionValues[State].Compare(_T("UNGROUPING"))) {
                    if(!m_bDisplayExistingLogFileOnly) {
                        //
                        // set the display text
                        //
                        stateText =_T("STOPPED");
                    }
                }
            }

            //
            // Indicate we are done stopping the trace
            //
            m_bStoppingTrace = FALSE;

            //
            // Set our state to show a session is not in progress
            //
            m_bTraceActive = FALSE;

            break;
    }

    //
    // Save the state value
    //
    if(!stateText.IsEmpty()) {
        m_logSessionValues[State] = stateText;
    }
}

BOOL CLogSession::BeginTrace(BOOL bUseExisting) 
{
    ULONG                   ret;
    PEVENT_TRACE_PROPERTIES pProperties;
    PEVENT_TRACE_PROPERTIES pQueryProperties;
    TRACEHANDLE             hSessionHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    CString                 str;
    ULONG                   sizeNeeded;
    LPTSTR                  pLoggerName;
    LPTSTR                  pLogFileName;
    ULONG                   flags = 0;
	ULONG					level;
	GUID                    controlGuid;
    LONG                    status;
    CTraceSession          *pTraceSession;

    //
    // If we are just displaying an existing log file, then just set 
    // the state and return
    //
    if(m_bDisplayExistingLogFileOnly) {
        SetState(Existing);
        return TRUE;
    }

    //
    // setup our buffer size for the properties struct
    //
    sizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + (2 * 500 * sizeof(TCHAR));

    pProperties = (PEVENT_TRACE_PROPERTIES) new char[sizeNeeded];
    if(NULL == pProperties) {
        AfxMessageBox(_T("Failed To Start Trace, Out Of Resources"));
        return FALSE;
    }

    //
    // zero our structure
    //
    memset(pProperties, 0, sizeNeeded);

    pProperties->Wnode.BufferSize = sizeNeeded;
    pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerName = (LPTSTR)((char*)pProperties + pProperties->LoggerNameOffset);
    _tcscpy(pLoggerName, GetDisplayName());

    //
    // If using a log file, then set the parameters for it
    //
    if(m_bWriteLogFile) {
        pProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (500 * sizeof(TCHAR));
        pLogFileName = (LPTSTR)((char*)pProperties + pProperties->LogFileNameOffset);
        _tcscpy(pLogFileName, (LPCTSTR)m_logFileName);

//BUGBUG
        //
        // Can't have circular and sequential, so we favor circular
        // this probably needs to change in that we should limit the 
        // user to only be able to pick one or the other.
        //
        if(!m_logSessionValues[Circular].IsEmpty()) {
            //
            // Deliver events to a circular log file.
            //
            pProperties->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;

            //
            // Circular log files should have a maximum size.
            //
            pProperties->MaximumFileSize = ConvertStringToNum(m_logSessionValues[Circular]);
        } else {
            //
            // Deliver events to a sequential log file.
            //
            pProperties->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;

            //
            // Sequential log files can have a maximum size.
            //
            pProperties->MaximumFileSize = ConvertStringToNum(m_logSessionValues[Sequential]);
        }

        //
        // Append to a current logfile.
        //
        if(m_bAppend) {
            pProperties->LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
        }

        if(!m_logSessionValues[NewFile].IsEmpty()) {
            //
            // Use a new log file when the requested size of data is 
            // received.
            //
            pProperties->LogFileMode |= EVENT_TRACE_FILE_MODE_NEWFILE;

            //
            // Data size.
            //
            pProperties->MaximumFileSize = ConvertStringToNum(m_logSessionValues[NewFile]);
        }
    }    

    //
    // Set the session to generate real-time events
    //
	if(m_bRealTime) {
        pProperties->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
    }

//BUGBUG
    //
    // Again we should limit the user to select one or the other.
    // a session can only use global or local sequence numbers so
    // we favor global for now.
    //
    if(m_logSessionValues[GlobalSequence] == "TRUE") {
        //
        // Use global sequence numbers.
        //
        pProperties->LogFileMode |= EVENT_TRACE_USE_GLOBAL_SEQUENCE;
    } else if(m_logSessionValues[LocalSequence] == "TRUE") {
        //
        // Use local sequence numbers.
        //
        pProperties->LogFileMode |= EVENT_TRACE_USE_LOCAL_SEQUENCE;
    }

    //
    // Set the buffer settings.
    //
    pProperties->BufferSize = ConvertStringToNum(m_logSessionValues[BufferSize]);
    pProperties->MinimumBuffers = ConvertStringToNum(m_logSessionValues[MinimumBuffers]);
    pProperties->MaximumBuffers = ConvertStringToNum(m_logSessionValues[MaximumBuffers]);
    pProperties->FlushTimer = ConvertStringToNum(m_logSessionValues[FlushTime]);
    level = ConvertStringToNum(m_logSessionValues[Level]);
    pProperties->AgeLimit = ConvertStringToNum(m_logSessionValues[DecayTime]);

    //
    // get the trace enable flags
    //
    flags = ConvertStringToNum(m_logSessionValues[Flags]);
	pProperties->EnableFlags = flags;

    //
    // Start the session.
    //
    while(ERROR_SUCCESS != (ret = StartTrace(&hSessionHandle, 
                                             GetDisplayName(), 
                                             pProperties))) {
        if(ret != ERROR_ALREADY_EXISTS)
        {
            str.Format(_T("StartTrace failed: %d\n"), ret);

            AfxMessageBox(str);

            delete [] pProperties;

            //
            // Reset the session handle
            //
            SetSessionHandle((TRACEHANDLE)INVALID_HANDLE_VALUE);

            return FALSE;
        }

        if(bUseExisting) {
            SetState(Running);

            delete [] pProperties;

            return TRUE;
        }

        //
        // If the session is already active give the user a chance to kill
        // it and restart. (this will happen if the app dies while a log
        // session is active)
        //
        str.Format(_T("Warning:  LogSession Already In Progress\n\nSelect Action:\n\n\tYes - Stop And Restart The Log Session\n\n\tNo  - Join The Log Session Without Stopping\n\t         (Session Will Be Unremovable/Unstoppable Without Restarting TraceView)\n\n\tCancel - Abort Start Operation"));

        ret = AfxMessageBox(str, MB_YESNOCANCEL);

        //
        // If joining an in progress session, we need to query and 
        // get the correct values for the session
        //
        if(IDNO == ret) {
            //
            // setup our buffer size for the properties struct for our query
            //
            sizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + (2 * 1024 * sizeof(TCHAR));

            //
            // allocate our memory
            //
            pQueryProperties = (PEVENT_TRACE_PROPERTIES) new char[sizeNeeded];
            if(NULL == pQueryProperties) {
                return FALSE;
            }

            //
            // zero our structures
            //
            memset(pQueryProperties, 0, sizeNeeded);

            //
            // Set the size
            //
            pQueryProperties->Wnode.BufferSize = sizeNeeded;

            // 
            // Set the GUID
            //
            pQueryProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

            // 
            // Set the logger name offset
            //
            pQueryProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            //
            // Set the logger name for the query
            //
            pLoggerName = (LPTSTR)((char*)pQueryProperties + pQueryProperties->LoggerNameOffset);
            _tcscpy(pLoggerName, GetDisplayName());

            // 
            // Set the log file name offset
            //
            pQueryProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (500 * sizeof(TCHAR));

            //
            // Query the log session
            //
            status = ControlTrace(0,
                                  GetDisplayName(),
                                  pQueryProperties,
                                  EVENT_TRACE_CONTROL_QUERY);

            if(ERROR_SUCCESS == status) {
                if(pQueryProperties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
                    m_logSessionValues[Circular].Format(_T("%d"), pQueryProperties->MaximumFileSize);
                    m_logSessionValues[Sequential].Empty();
                    m_logSessionValues[NewFile].Empty();
                }

                if(pQueryProperties->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
                    m_logSessionValues[Sequential].Format(_T("%d"), pQueryProperties->MaximumFileSize);
                    m_logSessionValues[Circular].Empty();
                    m_logSessionValues[NewFile].Empty();
                }

                if(pQueryProperties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
                    m_logSessionValues[NewFile].Format(_T("%d"), pQueryProperties->MaximumFileSize);
                    m_logSessionValues[Circular].Empty();
                    m_logSessionValues[Sequential].Empty();
                }

                if(pQueryProperties->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
                    m_logSessionValues[GlobalSequence].Format(_T("TRUE"));
                    m_logSessionValues[LocalSequence].Format(_T("FALSE"));
                }

                if(pQueryProperties->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
                    m_logSessionValues[GlobalSequence].Format(_T("FALSE"));
                    m_logSessionValues[LocalSequence].Format(_T("TRUE"));
                }

                m_logSessionValues[BufferSize].Format(_T("%d"), pQueryProperties->BufferSize);
                m_logSessionValues[MinimumBuffers].Format(_T("%d"), pQueryProperties->MinimumBuffers);
                m_logSessionValues[MaximumBuffers].Format(_T("%d"), pQueryProperties->MaximumBuffers);
                m_logSessionValues[FlushTime].Format(_T("%d"), pQueryProperties->FlushTimer);
                m_logSessionValues[Level].Format(_T("%d"), pQueryProperties->Wnode.HistoricalContext);
                m_logSessionValues[DecayTime].Format(_T("%d"), pQueryProperties->AgeLimit);
                m_logSessionValues[Flags].Format(_T("0x%X"), pQueryProperties->EnableFlags);

                //
                // Now write the values out
                //
                //::PostMessage(AfxGetMainWnd()->GetSafeHwnd(), WM_USER_UPDATE_LOGSESSION_DATA, (WPARAM)this, NULL);
            }

            hSessionHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;

            break;
        }

        if(IDCANCEL == ret) {
            this->SetSessionHandle((TRACEHANDLE)INVALID_HANDLE_VALUE);

            return FALSE;
        }

        //
        // Stop the session, so it can be restarted.
        //
        ret = ControlTrace(hSessionHandle, 
                           GetDisplayName(), 
                           pProperties,
                           EVENT_TRACE_CONTROL_STOP);
    }

    delete [] pProperties;

    //
    // Set the session state flag
    //
    m_bSessionActive = TRUE;

    //
    // Save the new session handle
    //
    SetSessionHandle(hSessionHandle);

    //
    // If the session handle is invalid, we are hooking up to
    // an already running session
    //
    if((TRACEHANDLE)INVALID_HANDLE_VALUE == (TRACEHANDLE)hSessionHandle) {
        SetState(Running);

	    return TRUE;
    }

    //
    // Enable the trace(s)
    //
    for(LONG ii = 0; ii < m_traceSessionArray.GetSize(); ii++) {
        pTraceSession = (CTraceSession *)m_traceSessionArray[ii];
        if(pTraceSession == NULL) {
            continue;
        }

        //
        // Enable all trace providers for this log session
        //
        for(LONG jj = 0; jj < pTraceSession->m_controlGuid.GetSize(); jj++) {
            //
            // We don't have to enable the kernel logger, so check for it
            //
            if(!pTraceSession->m_bKernelLogger) {
                StringToGuid((LPTSTR)(LPCTSTR)pTraceSession->m_controlGuid[jj], &controlGuid);
                ret = EnableTrace(TRUE,
                                  flags,
                                  level,
                                  &controlGuid,
                                  hSessionHandle);
                if (ret != ERROR_SUCCESS) 
                {
                    if(ret == ERROR_INVALID_FUNCTION) {
                        str.Format(_T("Failed To Enable Trace For Control GUID:\n%ls\n\nEnableTrace Returned %d\n\nThis Error Is Commonly Caused By Multiple Log Sessions\nAttempting To Solicit Events From A Single Provider"), pTraceSession->m_controlGuid[jj], ret);                    
                    } else {
                        str.Format(_T("Failed To Enable Trace For Control GUID:\n%ls\n\nEnableTrace Returned %d\n"), pTraceSession->m_controlGuid[jj], ret);
                    }
                    AfxMessageBox(str);
                }
            }
        }
    }

    SetState(Running);

	return TRUE;
}

//
// Updates an active tracing session.  Real-Time mode, log file name,
// flush-time, flags, and maximum buffers can be updated.
//
BOOL CLogSession::UpdateSession(PEVENT_TRACE_PROPERTIES pQueryProperties)
{
    PEVENT_TRACE_PROPERTIES pProperties;
    ULONG                   sizeNeeded;
    LPTSTR                  pLoggerName;
    LPTSTR                  pCurrentLogFileName;
    LPTSTR                  pLogFileName;
    ULONG                   flags;
	ULONG					level;
    ULONG                   status;
    CString                 logFileName;
    CString                 str;

    //
    // setup our buffer size for the properties struct
    //
    sizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + (2 * 1024 * sizeof(TCHAR));

    //
    // allocate our memory
    //
    pProperties = (PEVENT_TRACE_PROPERTIES) new char[sizeNeeded];
    if(NULL == pProperties) {
        return FALSE;
    }

    //
    // zero our structures
    //
    memset(pProperties, 0, sizeNeeded);

    //
    // Set the size
    //
    pProperties->Wnode.BufferSize = sizeNeeded;

    // 
    // Set the GUID
    //
    pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

    // 
    // Set the logger name offset
    //
    pProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

    // 
    // Set the log file name offset
    //
    pProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (500 * sizeof(TCHAR));

    //
    // Get the log file name pointers
    //
    pLogFileName = (LPTSTR)((char*)pProperties + pProperties->LogFileNameOffset);

    //
    // Set the log file name
    //
    if(m_bWriteLogFile) {
        //
        // See if the logfile name is already specified and hasn't changed
        // ControlTrace will fail if you specify the same logfile name as it 
        // is already using
        //
        if((NULL == pQueryProperties) ||
                (NULL == _tcsstr((LPTSTR)((char*)pQueryProperties + pQueryProperties->LogFileNameOffset), m_logFileName)) ||
                (NULL == (LPTSTR)((char*)pQueryProperties + pQueryProperties->LogFileNameOffset))) {

            _tcscpy(pLogFileName, (LPCTSTR)m_logFileName);
        }    
    }

    //
    // Set the real-time setting.
    //
	if(m_bRealTime) {
        pProperties->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
    }

    //
    // Set the max buffers setting.
    //
    pProperties->MaximumBuffers = ConvertStringToNum(m_logSessionValues[MaximumBuffers]);

    //
    // Set the enable flags setting.
    //
    flags = ConvertStringToNum(m_logSessionValues[Flags]);

	pProperties->EnableFlags = flags;

    //
    // Set the flush time setting.
    //
    pProperties->FlushTimer = ConvertStringToNum(m_logSessionValues[FlushTime]);

    //
    // Attempt to update the session
    //
    status = ControlTrace(0,
                          GetDisplayName(),
                          pProperties,
                          EVENT_TRACE_CONTROL_UPDATE);

    if(ERROR_BAD_PATHNAME == status) {
        _tcscpy(pLogFileName,_T(""));

        //
        // If we get an ERROR_BAD_PATHNAME it means we specified the same
        // logfile name as the one we were already using.  It seems the 
        // tool should handle this, but it doesn't, so we just try again
        // with a blank logfilename.  There is no way to clear a logfile
        // name from a session, so this seems to work.
        //
        status = ControlTrace(0,
                              GetDisplayName(),
                              pProperties,
                              EVENT_TRACE_CONTROL_UPDATE);
    }

    if(ERROR_SUCCESS != status) {
        CString str;
        str.Format(_T("Failed To Update Session\nControlTrace failed with status %d"), status);
        AfxMessageBox(str);

        delete [] pProperties;

        return FALSE;
    }

    delete [] pProperties;

    return TRUE;
}

LONG CLogSession::EndTrace()
{
    ULONG                   ret;
    PEVENT_TRACE_PROPERTIES pProperties;
    CString                 str;
    ULONG                   sizeNeeded;
    LPTSTR                  pLoggerName;
    LPTSTR                  pLogFileName;
    ULONG                   exitCode = STILL_ACTIVE;
    LONG                    startTime;
    TRACEHANDLE             hSessionHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    LONG                    status;
    CTraceSession          *pTraceSession;
	GUID                    controlGuid;

    //
    // If an attempt to stop this session has already been made, just return
    //
    if(m_bStoppingTrace || !m_bTraceActive) {
        return TRUE;
    }

    SetState(Stopping);

    //
    // If dealing with an existing log file we terminate the tracing later
    //
    if(m_bDisplayExistingLogFileOnly) {
        return TRUE;
    }

    //
    // Get our session handle
    //
    hSessionHandle = GetSessionHandle();

    //
    // If the session handle is invalid, we hooked up to
    // an already running session, so we can't stop the traces
    //
    if((TRACEHANDLE)INVALID_HANDLE_VALUE != hSessionHandle) {

        //
        // Disable the trace(s)
        //
        for(LONG ii = 0; ii < m_traceSessionArray.GetSize(); ii++) {
            pTraceSession = (CTraceSession *)m_traceSessionArray[ii];
            if(pTraceSession == NULL) {
                continue;
            }

            //
            // Disable all trace providers for this log session
            //
            for(LONG jj = 0; jj < pTraceSession->m_controlGuid.GetSize(); jj++) {
                StringToGuid((LPTSTR)(LPCTSTR)pTraceSession->m_controlGuid[jj], &controlGuid);

                ret = EnableTrace(FALSE,
                                0,
                                0,
                                &controlGuid,
                                hSessionHandle);
                if (ret != ERROR_SUCCESS) 
                {
                    if(ret == ERROR_INVALID_FUNCTION) {
                        str.Format(_T("Failed To Disable Trace For Control GUID:\n%ls\n\nEnableTrace Returned %d"), pTraceSession->m_controlGuid[jj], ret);                    
                    } else {
                        str.Format(_T("Failed To Disable Trace For Control GUID:\n%ls\n\nEnableTrace Returned %d\n"), pTraceSession->m_controlGuid[jj], ret);
                    }
                    AfxMessageBox(str);
                }
            }
        }

        //
        // Calculate the size needed to store the properties,
        // a LogFileName string, and LoggerName string.
        //
        sizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + (2 * 500 * sizeof(TCHAR));

        pProperties = (PEVENT_TRACE_PROPERTIES) new char[sizeNeeded];
        if(NULL == pProperties) {
            AfxMessageBox(_T("Failed To Stop Trace, Out Of Resources"));
            return ERROR_OUTOFMEMORY;
        }

        //
        // zero our structure
        //
        memset(pProperties, 0, sizeNeeded);

        //
        // setup the struct
        //
        pProperties->Wnode.BufferSize = sizeNeeded;
        pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
        pProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        pLoggerName = (LPTSTR)((char*)pProperties + pProperties->LoggerNameOffset);
        _tcscpy(pLoggerName, GetDisplayName());
        if(m_bWriteLogFile) {
            pProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (500 * sizeof(TCHAR));
            pLogFileName = (LPTSTR)((char*)pProperties + pProperties->LogFileNameOffset);
            _tcscpy(pLogFileName, (LPCTSTR)m_logFileName);
        }

        //
        // The WNODE_HEADER is being used.
        //
        pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        //
        // end the trace session
        //
        ret = ControlTrace(hSessionHandle, 
                        (LPCTSTR)GetDisplayName(), 
                        pProperties, 
                        EVENT_TRACE_CONTROL_STOP);
        if(ERROR_SUCCESS != ret) {
            str.Format(_T("Failed To Stop Trace: %d, Session Handle = 0x%X"), ret, hSessionHandle);
            AfxMessageBox(str);
        }

        delete [] pProperties;
    }

    //
    // Set the session state flag
    //
    m_bSessionActive = FALSE;

    //
    // reset the session handle
    //
    SetSessionHandle((TRACEHANDLE)INVALID_HANDLE_VALUE);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessiondlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionDialog.h : header for logger list dialog
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CLogSessionDlg dialog

class CLogSessionDlg : public CDialog
{
    DECLARE_DYNAMIC(CLogSessionDlg)

public:
    CLogSessionDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CLogSessionDlg();

    //int CLogSessionDlg::Create(UINT nIDTemplate, CWnd *pParentWnd = NULL);

    BOOL OnInitDialog();
    void OnNcPaint();
    void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
    //void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
    void OnSize(UINT nType, int cx,int cy);
    void SetDisplayFlags(LONG DisplayFlags);
    BOOL SetItemText(int nItem, int nSubItem, LPCTSTR lpszText);
    BOOL AssignDisplayWnd(CLogSession *pLogSession);
    VOID ReleaseDisplayWnd(CLogSession *pLogSession);
    VOID UpdateSession(CLogSession *pLogSession); 
    BOOL AddSession(CLogSession *pLogSession);
    VOID RemoveSession(CLogSession *pLogSession);
    VOID RemoveSelectedLogSessions();
    VOID GroupSessions(CPtrArray *pLogSessionArray);
    VOID UnGroupSessions(CPtrArray *pLogSessionArray);
    void AutoSizeColumns();
    LONG GetDisplayWndID();
    VOID ReleaseDisplayWndID(CDisplayDlg *pDisplayDlg);
    LONG GetLogSessionID();
    VOID ReleaseLogSessionID(CLogSession *pLogSession);

    static void EndTraceComplete(PVOID pContext);

    LRESULT OnParameterChanged(WPARAM wParam, LPARAM lParam);

    INLINE LONG GetDisplayFlags()
    {
        return m_displayFlags;
    }

    // Dialog Data
    enum { IDD = IDD_DISPLAY_DIALOG };

    CListCtrlEx     m_displayCtrl;
    CPtrArray       m_logSessionArray;
    LONG            m_displayFlags;
    CStringArray    m_columnName;
    LONG            m_columnWidth[MaxLogSessionOptions];
    int             m_insertionArray[MaxLogSessionOptions + 1];
    int             m_retrievalArray[MaxLogSessionOptions + 1];
    CPtrArray       m_traceDisplayWndArray;
    LONG            m_logSessionDisplayFlags;
    HANDLE          m_hParameterChangeEvent;
    BOOL            m_displayWndIDList[MAX_LOG_SESSIONS];
    BOOL            m_logSessionIDList[MAX_LOG_SESSIONS];
    HWND            m_hMainFrame;
    HANDLE          m_traceDisplayWndMutex;
    HANDLE          m_logSessionArrayMutex;

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

public:
    //{{AFX_MSG(CLogSessionDlg)
    afx_msg void OnNMClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnNMRclickDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnHDNRclickDisplayList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    virtual BOOL PreTranslateMessage(MSG* pMsg);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessiondlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionDialog.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "DockDialogBar.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "ListCtrlEx.h"
#include "Utils.h"
#include "LogSessionDlg.h"

// CLogSessionDlg dialog

IMPLEMENT_DYNAMIC(CLogSessionDlg, CDialog)
CLogSessionDlg::CLogSessionDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CLogSessionDlg::IDD, pParent)
{
    //
    // Set the column titles
    //
    m_columnName.Add("State              ");
    m_columnName.Add("Event Count");
    m_columnName.Add("Lost Events");
    m_columnName.Add("Buffers Read");
    m_columnName.Add("Flags");
    m_columnName.Add("Flush Time");
    m_columnName.Add("Max Buf");
    m_columnName.Add("Min Buf");
    m_columnName.Add("Buf Size");
    m_columnName.Add("Age");
    m_columnName.Add("Circular");
    m_columnName.Add("Sequential");
    m_columnName.Add("New File");
    m_columnName.Add("Global Seq");
    m_columnName.Add("Local Seq");
    m_columnName.Add("Level");

    //
    // Set the initial column widths
    //
    for(LONG ii = 0; ii < MaxLogSessionOptions; ii++) {
        m_columnWidth[ii] = 100;
    }

    //
    // Initialize the ID arrays
    //
    memset(m_logSessionIDList, 0, sizeof(BOOL) * MAX_LOG_SESSIONS);
    memset(m_displayWndIDList, 0, sizeof(BOOL) * MAX_LOG_SESSIONS);

    m_displayFlags = 0;
	m_logSessionDisplayFlags = 0x00000000;

    //
    // Create the parameter change signalling event
    //
    m_hParameterChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CLogSessionDlg::~CLogSessionDlg()
{
    CLogSession    *pLogSession;

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    //
    // cleanup our display bar list
    //
    while(m_logSessionArray.GetSize() > 0) {
        pLogSession = (CLogSession *)m_logSessionArray.GetAt(0);
        m_logSessionArray.RemoveAt(0);
        if(pLogSession != NULL) {
            if((pLogSession->m_bTraceActive) && (!pLogSession->m_bStoppingTrace)) {
                pLogSession->EndTrace();
            }

            //
            // Disengage the display window from this log session
            //
            ReleaseDisplayWnd(pLogSession);

            ReleaseLogSessionID(pLogSession);

            delete pLogSession;
        }
    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    ASSERT(m_traceDisplayWndArray.GetSize() == 0);

    //
    // close our event handle
    //
    CloseHandle(m_hParameterChangeEvent);

    //
    // Close the mutex handles
    //
    CloseHandle(m_traceDisplayWndMutex);
    CloseHandle(m_logSessionArrayMutex);
}

BOOL CLogSessionDlg::OnInitDialog()
{
    RECT    rc;
    RECT    parentRC;
    CString str;

    CDialog::OnInitDialog();

    //
    // Create the trace window pointer array protection mutex
    //
    m_traceDisplayWndMutex = CreateMutex(NULL,TRUE,NULL);

    if(m_traceDisplayWndMutex == NULL) {

        DWORD error = GetLastError();

        str.Format(_T("CreateMutex Error error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    ReleaseMutex(m_traceDisplayWndMutex);

    //
    // Create the log session array protection mutex
    //
    m_logSessionArrayMutex = CreateMutex(NULL, TRUE, NULL);

    if(m_logSessionArrayMutex == NULL) {

        DWORD error = GetLastError();

        str.Format(_T("CreateMutex Error error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    ReleaseMutex(m_logSessionArrayMutex);

    //
    // get the parent dimensions
    //
    GetParent()->GetParent()->GetClientRect(&parentRC);

    //
    // get the dialog dimensions
    //
    GetWindowRect(&rc);

    //
    // adjust the list control dimensions
    //
    rc.right = parentRC.right - parentRC.left - 24;
    rc.bottom = rc.bottom - rc.top;
    rc.left = 0;
    rc.top = 0;

    if(!m_displayCtrl.Create(WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT,
                             rc, 
                             this, 
                             IDC_DISPLAY_LIST)) 
    {
        TRACE(_T("Failed to create logger list control\n"));
        return FALSE;
    }

    for(LONG ii = 0; ii < MaxLogSessionOptions; ii++) {
        //
        // This lookup table allows a retrieval of the current 
        // position of a given column like m_retrievalArray[State]
        // will return the correct column value for the State
        // column
        //
        m_retrievalArray[ii] = ii;

        //
        // This lookup table allows correct placement of 
        // a column being added.  So, if the State column
        // needed to be inserted, then m_insertionArray[State]
        // would give the correct insertion column value.
        // It is also used in SetItemText to update the correct
        // column.
        //
        m_insertionArray[ii] = ii;
    }

    //
    // We have to return zero here to get the focus set correctly
    // for the app.
    //
    return 0;
}

void CLogSessionDlg::OnNcPaint() 
{
    CRect pRect;

    GetClientRect(&pRect);
    InvalidateRect(&pRect, TRUE);
}

void CLogSessionDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
}

VOID CLogSessionDlg::SetDisplayFlags(LONG DisplayFlags)
{
    LONG            addDisplayFlags = ~m_displayFlags & DisplayFlags;
    LONG            removeDisplayFlags = m_displayFlags & ~DisplayFlags;
    LONG            updateDisplayFlags = m_displayFlags & DisplayFlags;
    LONG            ii;
    LONG            jj;
    LONG            kk;
    LONG            ll;
    CString         str;
    CLogSession    *pLog;
    LONG            limit;

    //
    // Now insert any new columns and remove any uneeded
    //
    for(ii = 0, jj = 1; ii < MaxLogSessionOptions; ii++, jj <<= 1) {
        //
        // add the columns
        //
        if(addDisplayFlags & jj) {

            //
            // insert the column
            //
            m_displayCtrl.InsertColumn(m_insertionArray[ii + 1], 
                                       m_columnName[ii],
                                       LVCFMT_LEFT,
                                       m_columnWidth[ii]);

            //
            // update the column positions
            //
            for(kk = 0, ll = 1; kk < MaxLogSessionOptions; kk++) {
                m_insertionArray[kk + 1] = ll;
                if(DisplayFlags & (1 << kk)) {
                    m_retrievalArray[ll] = kk;
                    ll++;
                }
            }
        }

        //
        // remove the columns
        //
        if(removeDisplayFlags & jj) {
            //
            // Get the width of the column to be removed
            //
            m_columnWidth[ii] = 
                m_displayCtrl.GetColumnWidth(m_insertionArray[ii + 1]);

            //
            // remove the column
            //
            m_displayCtrl.DeleteColumn(m_insertionArray[ii + 1]);

            //
            // update the column positions
            //
            for(kk = 0, ll = 1; kk < MaxLogSessionOptions; kk++) {
                m_insertionArray[kk + 1] = ll;
                if(DisplayFlags & (1 << kk)) {
                    m_retrievalArray[ll] = kk;
                    ll++;
                }
            }
        }
    }

    //
    // Save our new flags
    //
    m_displayFlags = DisplayFlags;

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    //
    // Now display the log session properties that
    // have been selected
    //
    for(ii = 0; ii < m_logSessionArray.GetSize(); ii++) {
        pLog = (CLogSession *)m_logSessionArray[ii];

        if(NULL == pLog) {
            continue;
        }

        limit = MaxLogSessionOptions;

        if(pLog->m_bDisplayExistingLogFileOnly) {
            limit = 1;
        }
        for(jj = 0; jj < limit; jj++) {
            SetItemText(ii, 
                        jj + 1,
                        pLog->m_logSessionValues[jj]);
        }
    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);
}

BOOL CLogSessionDlg::SetItemText(int nItem, int nSubItem, LPCTSTR lpszText) 
{
    //
    // Adjust the subitem value for the correct column and insert
    //
    if(m_displayFlags & (1 << (nSubItem - 1))) {
        return m_displayCtrl.SetItemText(nItem, 
                                         m_insertionArray[nSubItem],
                                         lpszText);
    }

    return FALSE;
}

BOOL CLogSessionDlg::AddSession(CLogSession *pLogSession) 
{
    CLogSession    *pLog;
    CString         text;
    LONG            numberOfEntries;

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    //
    // add the element to the array
    //
    m_logSessionArray.Add(pLogSession);

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    //
    // Get a trace display window for the session
    //
    if(!AssignDisplayWnd(pLogSession)) {
        return FALSE;
    }

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);
        
    numberOfEntries = (LONG)m_logSessionArray.GetSize();

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    for(LONG ii = 0; ii < numberOfEntries; ii++) {

        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

        pLog = (CLogSession *)m_logSessionArray[ii];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionArrayMutex);

        if(pLog == pLogSession) {
            text.Format(_T("%d   "), pLogSession->GetGroupID());

            text += pLogSession->GetDisplayName();

            //
            // Display the name
            //
	        m_displayCtrl.InsertItem(ii, 
                                     text,
                                     pLogSession);

            UpdateSession(pLogSession);

            if(numberOfEntries <= 1) {
                AutoSizeColumns();
            }

            return TRUE;
        }
    }

    return FALSE;
}

VOID CLogSessionDlg::UpdateSession(CLogSession *pLogSession) 
{
    LONG            logSessionDisplayFlags;
    CLogSession    *pLog;
    BOOL            bActiveSession = FALSE;
    LONG            traceDisplayFlags;
    LONG            numberOfEntries;

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    numberOfEntries = (LONG)m_logSessionArray.GetSize();
    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    //
    // recalculate the display flags
    //
	for(LONG ii = 0; ii < numberOfEntries; ii++) {
        
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

        pLog = (CLogSession *)m_logSessionArray[ii];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionArrayMutex);

        if((NULL != pLog) && !pLog->m_bDisplayExistingLogFileOnly) {
            bActiveSession = TRUE;
        }
	}

    //
	// Figure out if we need to stop displaying columns
    //
    logSessionDisplayFlags = GetDisplayFlags();

    SetDisplayFlags(logSessionDisplayFlags ? logSessionDisplayFlags : 0xFFFFFFFF);

    //
    // Force an update of the display window as well
    //
    traceDisplayFlags = pLogSession->GetDisplayWnd()->GetDisplayFlags();

    pLogSession->GetDisplayWnd()->SetDisplayFlags(traceDisplayFlags);
}

VOID CLogSessionDlg::RemoveSession(CLogSession *pLogSession)
{
    CDisplayDlg    *pDisplayDlg;
    CDockDialogBar *pDialogBar;
    CLogSession    *pLog;

    if(pLogSession == NULL) {
        return;
    }

    //
    // Disengage the display window from this log session
    //
    ReleaseDisplayWnd(pLogSession);

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    //
    // remove the session from display
    //
    for(LONG ii = (LONG)m_logSessionArray.GetSize() - 1; ii >= 0; ii--) {
        pLog = (CLogSession *)m_logSessionArray[ii];

        if(pLog == pLogSession) {
            m_displayCtrl.DeleteItem(ii);

            //
            // delete the log session from the array
            //
            m_logSessionArray.RemoveAt(ii);
            break;
        }
    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    //
    // Return the log session ID
    //
    ReleaseLogSessionID(pLogSession);

    if(m_logSessionArray.GetSize() == 0) {
        SetDisplayFlags(0);
    }
}

VOID CLogSessionDlg::RemoveSelectedLogSessions()
{
    POSITION        pos;
    LONG            index;
    CLogSession    *pLogSession;
    CDisplayDlg    *pDisplayDlg;

    pos = m_displayCtrl.GetFirstSelectedItemPosition();

    while(pos != NULL) {
        //
        // Find any selected sessions
        //
        index = m_displayCtrl.GetNextSelectedItem(pos);

        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

        pLogSession = (CLogSession *)m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionArrayMutex);

        pDisplayDlg = pLogSession->GetDisplayWnd();

        if(pDisplayDlg->m_sessionArray.GetSize() > 1) {
            //
            // Don't allow grouped sessions to get removed
            //
            continue;
        }
        
        RemoveSession(pLogSession);

        //
        // delete the log session
        //
        delete pLogSession;
    }
}

VOID CLogSessionDlg::GroupSessions(CPtrArray *pLogSessionArray)
{
    CLogSession    *pLogSession = NULL;
    LONG            groupID = -1;
    CString         str;

    //
    // Disconnect sessions from group display windows
    //
    for(LONG ii = 0; ii < pLogSessionArray->GetSize(); ii++) {
        pLogSession = (CLogSession *)pLogSessionArray->GetAt(ii);

        if(NULL == pLogSession) {
            continue;
        }

        //
        // Disconnect the display window and possibly remove it
        //
        ReleaseDisplayWnd(pLogSession);
    }

    //
    // Attach the first log session to a group window
    // then use this for all subsequent log sessions
    //
    for(LONG ii = 0; ii < pLogSessionArray->GetSize(); ii++) {
        pLogSession = (CLogSession *)pLogSessionArray->GetAt(ii);

        if(NULL == pLogSession) {
            continue;
        }

        //
        // Set the group ID
        //
        pLogSession->SetGroupID(groupID);

        //
        // Hook up the group window
        //
        AssignDisplayWnd(pLogSession);

        //
        // Update the session group ID in the display
        //
        str.Format(_T("%d    %ls"), pLogSession->GetGroupID(), pLogSession->GetDisplayName());

        for(LONG jj = 0; jj < m_displayCtrl.GetItemCount(); jj++) {
            if(pLogSession == (CLogSession *)m_displayCtrl.GetItemData(jj)) {
                m_displayCtrl.SetItemText(jj, 0, str); 
                break;
            }
        }

        //
        // Get the new group ID
        //
        groupID = pLogSession->GetGroupID();
    }

    //
    // Now start the new group
    //
    pLogSession->GetDisplayWnd()->BeginTrace();
}

VOID CLogSessionDlg::UnGroupSessions(CPtrArray *pLogSessionArray)
{
    CLogSession    *pLogSession = NULL;
    LONG            groupID = -1;
    CString         str;
    LONG            ii;

    //
    // Disconnect all sessions from their groups
    //
    for(ii = 0; ii < pLogSessionArray->GetSize(); ii++) {
        pLogSession = (CLogSession *)pLogSessionArray->GetAt(ii);

        if(NULL == pLogSession) {
            continue;
        }

        //
        // Disconnect the display window and possibly remove it
        //
        ReleaseDisplayWnd(pLogSession);
    }

    //
    // Create a unique group for each
    //
    for(ii = 0; ii < pLogSessionArray->GetSize(); ii++) {
        pLogSession = (CLogSession *)pLogSessionArray->GetAt(ii);

        if(NULL == pLogSession) {
            continue;
        }

        //
        // Hook up the group window
        //
        AssignDisplayWnd(pLogSession);

        //
        // Update the session group ID in the display
        //
        str.Format(_T("%d    %ls"), pLogSession->GetGroupID(), pLogSession->GetDisplayName());

        for(LONG jj = 0; jj < m_displayCtrl.GetItemCount(); jj++) {
            if(pLogSession == (CLogSession *)m_displayCtrl.GetItemData(jj)) {
                m_displayCtrl.SetItemText(jj, 0, str); 
                break;
            }
        }

        //
        // Now start the new group
        //
        pLogSession->GetDisplayWnd()->BeginTrace();
    }
}

BOOL CLogSessionDlg::AssignDisplayWnd(CLogSession *pLogSession)
{
    CDisplayDlg    *pDisplayDlg;
    CString         str;
    DWORD           extendedStyles;
    LONG            numberOfEntries;

    //
    // If we have a valid group number see if there is an
    // existing group window
    //
    if(pLogSession->GetGroupID() != -1) {

        //
        // Get the trace display window array protection
        //
        WaitForSingleObject(m_traceDisplayWndMutex, INFINITE);

        numberOfEntries = (LONG)m_traceDisplayWndArray.GetSize();

        //
        // Release the trace display window array protection
        //
        ReleaseMutex(m_traceDisplayWndMutex);

        //
        // Use the group window if there is one
        //
        for(LONG ii = 0; ii < numberOfEntries; ii++) {
            //
            // Get the trace display window array protection
            //
            WaitForSingleObject(m_traceDisplayWndMutex, INFINITE);

            pDisplayDlg = (CDisplayDlg *)m_traceDisplayWndArray[ii];
            if(pDisplayDlg == NULL) {
                continue;
            }

            //
            // Release the trace display window array protection
            //
            ReleaseMutex(m_traceDisplayWndMutex);

            if(pDisplayDlg->GetDisplayID() == pLogSession->GetGroupID()) {
                pLogSession->SetDisplayWnd(pDisplayDlg);

                //
                // add the element to the display wnd
                //
                pDisplayDlg->AddSession(pLogSession);

                return TRUE;
            }
        }
    }

    //
    // Otherwise create a new group display window
    //
    CDockDialogBar *pDialogBar = new CDockDialogBar();
    if(NULL == pDialogBar) {
	    AfxMessageBox(_T("Failed To Create Display Window\nMemory Allocation Failure"));

        return FALSE;
    }

    pDisplayDlg = new CDisplayDlg(GetParentFrame(), 
                                  GetDisplayWndID());
    if(NULL == pDisplayDlg) {
	    AfxMessageBox(_T("Failed To Create Display Window\nMemory Allocation Failure"));

        delete pDialogBar;
        return FALSE;
    }

    str.Format(_T("Group %d"), pDisplayDlg->GetDisplayID());

    //
    // create our dockable dialog bar with list control
    //
    if(!pDialogBar->Create(GetParentFrame(), 
                           pDisplayDlg, 
                           str, 
                           IDD_DISPLAY_DIALOG,
                           WS_CHILD|WS_VISIBLE|CBRS_BOTTOM|CBRS_TOOLTIPS|CBRS_SIZE_DYNAMIC, 
                           TRUE))
    {
	    AfxMessageBox(_T("Failed To Create Display Window"));

	    delete pDisplayDlg;
	    delete pDialogBar;

	    return FALSE;
    }

    //
    // Store the dock dialog pointer in the display dialog instance
    //
    pDisplayDlg->SetDockDialogBar((PVOID)pDialogBar);

    //
    // set our preferred extended styles
    //
    extendedStyles = LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT;

    //
    // Set the extended styles for the list control
    //
    pDisplayDlg->m_displayCtrl.SetExtendedStyle(extendedStyles);

    //
    // make the dialog dockable and dock it to the top
    //
    pDialogBar->EnableDocking(CBRS_ALIGN_TOP);

    //
    // dock the bar to the top
    //
    GetParentFrame()->DockControlBar(pDialogBar, AFX_IDW_DOCKBAR_TOP);

    //
    // Get the trace display window array protection
    //
    WaitForSingleObject(m_traceDisplayWndMutex, INFINITE);

    //
    // Add the bar to our array
    //
    m_traceDisplayWndArray.Add(pDisplayDlg);

    //
    // Release the trace display window array protection
    //
    ReleaseMutex(m_traceDisplayWndMutex);

    //
    // Set the log session group ID
    //
    pLogSession->SetGroupID(pDisplayDlg->GetDisplayID());

    //
    // Set the log session display pointer
    //
    pLogSession->SetDisplayWnd(pDisplayDlg);

    //
    // add the element to the display wnd
    //
    pDisplayDlg->AddSession(pLogSession);

    return TRUE;
}

VOID CLogSessionDlg::ReleaseDisplayWnd(CLogSession *pLogSession)
{
    CString         str;
    CDisplayDlg    *pDisplayDlg;
    CDockDialogBar *pDialogBar = NULL;
    CLogSession    *pLog;

    if(pLogSession == NULL) {
        return;
    }

    //
    // get the session's display window
    //
    pDisplayDlg = pLogSession->GetDisplayWnd();

    //
    // Clear the display window pointer from the log session
    //
    pLogSession->SetDisplayWnd(NULL);

    //
    // Set the group ID to an invalid ID
    //
    pLogSession->SetGroupID(-1);

    if(NULL == pDisplayDlg) {
        return;
    }

    //
    // Pull the log session from the displayDlg's array
    //
    pDisplayDlg->RemoveSession(pLogSession);

    //
    // Get the array protection
    //
    WaitForSingleObject(pDisplayDlg->m_hSessionArrayMutex, INFINITE);

    //
    // If there are still log sessions attached to this window
    // just return
    //
    if(pDisplayDlg->m_sessionArray.GetSize() > 0) {
        //
        // Release the array protection
        //
        ReleaseMutex(pDisplayDlg->m_hSessionArrayMutex);

        return;
    }

    //
    // Release the array protection
    //
    ReleaseMutex(pDisplayDlg->m_hSessionArrayMutex);

    //
    // Get the trace display window array protection
    //
    WaitForSingleObject(m_traceDisplayWndMutex, INFINITE);

    //
    // Remove this window from the list of display windows
    //
    for (LONG ii = (LONG)m_traceDisplayWndArray.GetSize() - 1; ii >=0 ; ii--) {
        if(m_traceDisplayWndArray[ii] == pDisplayDlg) {
            m_traceDisplayWndArray.RemoveAt(ii);
            break;
        }
    }

    //
    // Release the trace display window array protection
    //
    ReleaseMutex(m_traceDisplayWndMutex);

    //
    // Get the dock dialog bar so it can be deleted
    //
    pDialogBar = (CDockDialogBar *)pDisplayDlg->GetDockDialogBar();

    //
    // Clear the pointer in the class
    //
    pDisplayDlg->SetDockDialogBar(NULL);

    //
    // Release the window ID
    //
    ReleaseDisplayWndID(pDisplayDlg);

    //
    // delete the display window
    //
    delete pDisplayDlg;

    //
    // Delete the dock dialog bar
    //
    if(NULL != pDialogBar) {
        delete pDialogBar;
    }
}

BEGIN_MESSAGE_MAP(CLogSessionDlg, CDialog)
    //{{AFX_MSG_MAP(CLogSessionDlg)
    ON_WM_WINDOWPOSCHANGED()
    ON_WM_NCCALCSIZE()
    ON_WM_SIZE()
    ON_MESSAGE(WM_PARAMETER_CHANGED, OnParameterChanged)
    ON_NOTIFY(NM_CLICK, IDC_DISPLAY_LIST, OnNMClickDisplayList)
    ON_NOTIFY(NM_RCLICK, IDC_DISPLAY_LIST, OnNMRclickDisplayList)
    ON_NOTIFY(HDN_ITEMRCLICK, IDC_DISPLAY_LIST, OnHDNRclickDisplayList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// CLogSessionDlg message handlers

void CLogSessionDlg::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
    CDialog::OnWindowPosChanged(lpwndpos);
}

void CLogSessionDlg::OnSize(UINT nType, int cx,int cy) 
{
    CRect rc;

    if(!IsWindow(m_displayCtrl.GetSafeHwnd())) 
    {
        return;
    }

    GetParent()->GetClientRect(&rc);

    //
    // reset the size of the dialog
    //
    SetWindowPos(NULL, 
                 0,
                 0,
                 rc.right - rc.left,
                 rc.bottom - rc.top,
                 SWP_NOMOVE|SWP_SHOWWINDOW|SWP_NOZORDER);

    GetClientRect(&rc);

    m_displayCtrl.MoveWindow(rc);
}


BOOL CLogSessionDlg::PreTranslateMessage(MSG* pMsg)
{
    if(pMsg->message == WM_KEYDOWN) 
    { 
        if((pMsg->wParam == VK_ESCAPE) || (pMsg->wParam == VK_RETURN))
        { 
            //
            // Ignore the escape and return keys, otherwise 
            // the client area grays out on escape
            //
            return TRUE; 
        } 

        //
        // Fix for key accelerators, otherwise they are never
        // processed
        //
        if (AfxGetMainWnd()->PreTranslateMessage(pMsg))
            return TRUE;
        return CDialog::PreTranslateMessage(pMsg);
    } 

    return CDialog::PreTranslateMessage(pMsg);
}

LRESULT CLogSessionDlg::OnParameterChanged(WPARAM wParam, LPARAM lParam)
{
    CLogSession *pLogSession;
    CString str;

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    pLogSession = (CLogSession *)m_logSessionArray[wParam];

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    if(NULL == pLogSession) {
        return 0;
    }

    pLogSession->m_logSessionValues[m_retrievalArray[(int)lParam]] = 
                                m_displayCtrl.GetItemText((int)wParam, (int)lParam);

    if((m_retrievalArray[lParam] == Circular) && 
            !pLogSession->m_logSessionValues[m_retrievalArray[lParam]].IsEmpty()) {
        pLogSession->m_logSessionValues[Sequential].Empty();
        pLogSession->m_logSessionValues[NewFile].Empty();
    }

    if((m_retrievalArray[lParam] == Sequential) && 
            !pLogSession->m_logSessionValues[m_retrievalArray[lParam]].IsEmpty()) {
        pLogSession->m_logSessionValues[Circular].Empty();
        pLogSession->m_logSessionValues[NewFile].Empty();
    }

    if((m_retrievalArray[lParam] == NewFile) && 
            !pLogSession->m_logSessionValues[m_retrievalArray[lParam]].IsEmpty()) {
        pLogSession->m_logSessionValues[Circular].Empty();
        pLogSession->m_logSessionValues[Sequential].Empty();
    }

    if((m_retrievalArray[lParam] == GlobalSequence) && 
       !pLogSession->m_logSessionValues[m_retrievalArray[lParam]].Compare(_T("TRUE"))) {
        pLogSession->m_logSessionValues[LocalSequence] = _T("FALSE");
    }

    if((m_retrievalArray[lParam] == LocalSequence) && 
       !pLogSession->m_logSessionValues[m_retrievalArray[lParam]].Compare(_T("TRUE"))) {
        pLogSession->m_logSessionValues[GlobalSequence] = _T("FALSE");
    }

    if(pLogSession->m_bTraceActive) {
        pLogSession->GetDisplayWnd()->UpdateSession(pLogSession);
    }

    //
    // Restart updating the log session list control
    //
    m_displayCtrl.SuspendUpdates(FALSE);

    UpdateSession(pLogSession);

    return 0;
}

void CLogSessionDlg::OnNMClickDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
    CString         str;
    DWORD           position;
    int		        listIndex;
    LVHITTESTINFO   lvhti;
	CRect			itemRect;
	CRect			parentRect;
    CLogSession    *pLogSession;

// BUGBUG -- clean out uneeded str formats

    *pResult = 0;

    //
    // Get the position of the mouse when this 
    // message posted
    //
    position = ::GetMessagePos();

    //
    // Get the position in an easy to use format
    //
    CPoint	point((int) LOWORD (position), (int)HIWORD(position));

    //
    // Convert to client coordinates
    //
    ScreenToClient(&point);

    lvhti.pt = point;

    listIndex = m_displayCtrl.SubItemHitTest(&lvhti);

    if(0 == lvhti.iSubItem) {
        if(-1 == lvhti.iItem) {
            //str.Format(_T("NM Click: Item = %d, Flags = 0x%X\n"), lvhti.iItem, lvhti.flags);
            //TRACE(str);
        } else {
            //str.Format(_T("NM Click: Item = %d\n"), lvhti.iItem);
            //TRACE(str);
        }
    } else if(-1 == lvhti.iItem) {
        //str.Format(_T("NM Click: Item = %d, Flags = 0x%X\n"), lvhti.iItem, lvhti.flags);
        //TRACE(str);
    } else {
        //str.Format(_T("NM Click: Item = %d, "), lvhti.iItem);
        //TRACE(str);
        //str.Format(_T("SubItem = %d\n"), lvhti.iSubItem);
		//TRACE(str);

		GetClientRect(&parentRect);

		m_displayCtrl.GetSubItemRect(lvhti.iItem, lvhti.iSubItem, LVIR_BOUNDS, itemRect);

        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

        //
        // Get the log session for this row
        //
        pLogSession = (CLogSession *)m_logSessionArray[lvhti.iItem];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionArrayMutex);

        if(pLogSession == NULL) {
            return;
        }

        //
        // State, EventCount, LostEvents, BuffersRead
        //
        if((m_retrievalArray[lvhti.iSubItem] == State) ||
           (m_retrievalArray[lvhti.iSubItem] == EventCount) ||
           (m_retrievalArray[lvhti.iSubItem] == LostEvents) ||
           (m_retrievalArray[lvhti.iSubItem] == BuffersRead)) {
            return;
        }

        //
        // Flags - special handling for Kernel Logger
        //
        if((m_retrievalArray[lvhti.iSubItem] == Flags) &&
            !_tcscmp(pLogSession->GetDisplayName(), _T("NT Kernel Logger"))) {
            return;
        }

        //
        // MaxBuffers
        //
        if((m_retrievalArray[lvhti.iSubItem] == MaximumBuffers) &&
                !pLogSession->m_bDisplayExistingLogFileOnly){

            //
            // Stop updating the log session list control until
            // this control goes away.  Otherwise, this control
            // is disrupted.  Updating is turned back on in the
            // OnParameterChanged callback.
            //
            m_displayCtrl.SuspendUpdates(TRUE);

		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayCtrl);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      IDC_CUSTOM_EDIT);

            
            return;
        }

        //
        // FlushTime
        //
        if((m_retrievalArray[lvhti.iSubItem] == FlushTime) &&
                !pLogSession->m_bDisplayExistingLogFileOnly){

            //
            // Stop updating the log session list control until
            // this control goes away.  Otherwise, this control
            // is disrupted.  Updating is turned back on in the
            // OnParameterChanged callback.
            //
            m_displayCtrl.SuspendUpdates(TRUE);

		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayCtrl);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      IDC_CUSTOM_EDIT);

            return;
        }

        //
        // Flags
        //
        if((m_retrievalArray[lvhti.iSubItem] == Flags) &&
                !pLogSession->m_bDisplayExistingLogFileOnly){

            //
            // Stop updating the log session list control until
            // this control goes away.  Otherwise, this control
            // is disrupted.  Updating is turned back on in the
            // OnParameterChanged callback.
            //
            m_displayCtrl.SuspendUpdates(TRUE);

		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayCtrl);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      IDC_CUSTOM_EDIT);

            return;
        }

        //
        // Global Sequence
        //
        if((m_retrievalArray[lvhti.iSubItem] == GlobalSequence) &&
            !pLogSession->m_bTraceActive &&
                !pLogSession->m_bDisplayExistingLogFileOnly) {
		    CComboBox *pCombo = new CSubItemCombo(lvhti.iItem, 
										          lvhti.iSubItem,
										          &m_displayCtrl);

            //
            // Stop updating the log session list control until
            // this control goes away.  Otherwise, this control
            // is disrupted.  Updating is turned back on in the
            // OnParameterChanged callback.
            //
            m_displayCtrl.SuspendUpdates(TRUE);

		    pCombo->Create(WS_BORDER|WS_CHILD|WS_VISIBLE|CBS_DROPDOWNLIST, 
					       itemRect, 
					       &m_displayCtrl, 
					       IDC_CUSTOM_COMBO);

            return;
        }

        //
        // Local Sequence
        //
        if((m_retrievalArray[lvhti.iSubItem] == LocalSequence) &&
            !pLogSession->m_bTraceActive &&
                !pLogSession->m_bDisplayExistingLogFileOnly) {
		    CComboBox *pCombo = new CSubItemCombo(lvhti.iItem, 
										          lvhti.iSubItem,
										          &m_displayCtrl);

            //
            // Stop updating the log session list control until
            // this control goes away.  Otherwise, this control
            // is disrupted.  Updating is turned back on in the
            // OnParameterChanged callback.
            //
            m_displayCtrl.SuspendUpdates(TRUE);

		    pCombo->Create(WS_BORDER|WS_CHILD|WS_VISIBLE|CBS_DROPDOWNLIST, 
					       itemRect, 
					       &m_displayCtrl, 
					       IDC_CUSTOM_COMBO);

            return;
        }

        //
        // The Rest
        //
        if(!pLogSession->m_bTraceActive &&
                !pLogSession->m_bDisplayExistingLogFileOnly) {

            //
            // Stop updating the log session list control until
            // this control goes away.  Otherwise, this control
            // is disrupted.  Updating is turned back on in the
            // OnParameterChanged callback.
            //
            m_displayCtrl.SuspendUpdates(TRUE);

		    CEdit *pEdit = new CSubItemEdit(lvhti.iItem, 
										    lvhti.iSubItem,
										    &m_displayCtrl);

		    pEdit->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
					      itemRect, 
					      this, 
					      IDC_CUSTOM_EDIT);

            return;
        }
    }
}

void CLogSessionDlg::OnNMRclickDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
    CString         str;
    DWORD           position;
    int             listIndex;
    LVHITTESTINFO   lvhti;

    *pResult = 0;

    //
    // Get the position of the mouse when this 
    // message posted
    //
    position = ::GetMessagePos();

    //
    // Get the position in an easy to use format
    //
    CPoint  point((int) LOWORD (position), (int)HIWORD(position));

    CPoint  screenPoint(point);

    //
    // Convert to client coordinates
    //
    ScreenToClient(&point);

    lvhti.pt = point;

    listIndex = m_displayCtrl.SubItemHitTest(&lvhti);

    //
    // Pop-up menu for log session creation
    //
    if(-1 == lvhti.iItem) {
        CMenu menu;
        menu.LoadMenu(IDR_LOG_SESSION_POPUP_MENU);
        CMenu* pPopup = menu.GetSubMenu(0);
        ASSERT(pPopup != NULL);

        pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, screenPoint.x, screenPoint.y, AfxGetMainWnd());

        return;
    } 

    //
    // Pop-up menu for existing log session options
    //
	CMenu menu;
	menu.LoadMenu(IDR_LOG_OPTIONS_POPUP_MENU);

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);

	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, screenPoint.x, screenPoint.y, AfxGetMainWnd());
    return;
}

void CLogSessionDlg::OnHDNRclickDisplayList(NMHDR *pNMHDR, LRESULT *pResult)
{
	int             index;
	CRect           rcCol;
    BOOL            bActiveSession = FALSE;
    CLogSession    *pLogSession;
    LONG            numberOfEntries;

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionArrayMutex, INFINITE);

    if(m_logSessionArray.GetSize() == 0) {
        *pResult = 0;
    }

    for(LONG ii = 0; ii < m_logSessionArray.GetSize(); ii++) {
        pLogSession = (CLogSession *)m_logSessionArray[ii];

        if(NULL != pLogSession) {
            bActiveSession = TRUE;
            break;
        }

    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionArrayMutex);

    if(!bActiveSession) {
        *pResult = 0;
        return;
    }

    //
	// Right button was clicked on header
    //
	CPoint pt(GetMessagePos());
    CPoint screenPt(GetMessagePos());

	CHeaderCtrl *pHeader = m_displayCtrl.GetHeaderCtrl();

	pHeader->ScreenToClient(&pt);
	
    //
	// Determine the column index
    //
	for(int i=0; Header_GetItemRect(pHeader->m_hWnd, i, &rcCol); i++) {
		if(rcCol.PtInRect(pt)) {
            //
            // Column index if its ever needed
            //
			index = i;
			break;
		}
	}

 	CMenu menu;
	
    menu.LoadMenu(IDR_LOG_DISPLAY_OPTIONS_POPUP_MENU);

	CMenu *pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);

	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, screenPt.x, screenPt.y, AfxGetMainWnd());

    *pResult = 0;
}

void CLogSessionDlg::AutoSizeColumns() 
{
    LONG            colWidth1;
    LONG            colWidth2;
    LONG            columnCount;
    CHeaderCtrl    *pHeaderCtrl;

    //
    // Call this after the list control is filled
    //
    pHeaderCtrl = m_displayCtrl.GetHeaderCtrl();

    if (pHeaderCtrl != NULL)
    {
        columnCount = pHeaderCtrl->GetItemCount();

        //
        // Add a bogus column to the end, or the end column will
        // get resized to fit the remaining screen width
        //
        m_displayCtrl.InsertColumn(columnCount,_T(""));

        for(LONG ii = 0; ii < columnCount; ii++) {
            //
            // Get the max width of the column entries
            //
            m_displayCtrl.SetColumnWidth(ii, LVSCW_AUTOSIZE);
            colWidth1 = m_displayCtrl.GetColumnWidth(ii);

            //
            // Get the width of the column header
            //
            m_displayCtrl.SetColumnWidth(ii, LVSCW_AUTOSIZE_USEHEADER);
            colWidth2 = m_displayCtrl.GetColumnWidth(ii);

            //
            // Set the column width to the max of the two
            //
            m_displayCtrl.SetColumnWidth(ii, max(colWidth1,colWidth2));
        }

        //
        // Remove the bogus column
        //
        m_displayCtrl.DeleteColumn(columnCount);
    }
}

LONG CLogSessionDlg::GetDisplayWndID()
{
    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        if(FALSE == m_displayWndIDList[ii]) {
            m_displayWndIDList[ii] = TRUE;
            return ii;
        }
    }

    return -1;
}

VOID CLogSessionDlg::ReleaseDisplayWndID(CDisplayDlg *pDisplayDlg)
{
    LONG   displayID;

    displayID = pDisplayDlg->GetDisplayID();

    ASSERT(displayID < MAX_LOG_SESSIONS);

    //
    // Free the ID to be reused
    //
    m_displayWndIDList[displayID] = FALSE;
}

LONG CLogSessionDlg::GetLogSessionID()
{
    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        if(FALSE == m_logSessionIDList[ii]) {
            m_logSessionIDList[ii] = TRUE;
            return ii;
        }
    }

    return -1;
}

VOID CLogSessionDlg::ReleaseLogSessionID(CLogSession *pLogSession)
{
    LONG    sessionID;

    sessionID = pLogSession->GetLogSessionID();

    ASSERT(sessionID < MAX_LOG_SESSIONS);

    //
    // Free the ID to be reused
    //
    m_logSessionIDList[sessionID] = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionadvpropsht.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionAdvPropSht.h : interface of the CLogSessionAdvPropSht class
//////////////////////////////////////////////////////////////////////////////


#pragma once

class CLogSessionAdvPropSht : public CPropertySheet
{
public:
	DECLARE_DYNAMIC(CLogSessionAdvPropSht)
	CLogSessionAdvPropSht(CWnd* pWndParent, CLogSessionPropSht *pLogSessionPropSht);

// Attributes
	CLogSessionOutputOptionDlg	m_logSessionOutputOptionDlg;
	CLogDisplayOptionDlg		m_displayOptionPage;
    CLogSessionPropSht         *m_pLogSessionPropSht;
    CLogSession                *m_pLogSession;
    CStringArray                m_originalValues;
    BOOL                        m_bAppend;
    BOOL                        m_bRealTime;
    BOOL                        m_bWriteLogFile;
    BOOL                        m_bWriteListingFile;
    BOOL                        m_bWriteSummaryFile;
    CString                     m_logFileName;
    CString                     m_displayName;              // Log session display name
    CString                     m_summaryFileName;          // File name for summary output
    CString                     m_listingFileName;          // File name for event output

// Overrides
	virtual BOOL OnInitDialog();


// Message Handlers
protected:
	//{{AFX_MSG(CLogSessionAdvPropSht)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	afx_msg void OnBnClickedOk();
	afx_msg void OnBnClickedCancel();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessioninformationdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionInformationDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "ListCtrlEx.h"
#include "LogSessionDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogDisplayOptionDlg.h"
#include "LogSessionPropSht.h"
#include "LogSessionOutputOptionDlg.h"
#include "LogSessionAdvPropSht.h"


// CLogSessionInformationDlg dialog

IMPLEMENT_DYNAMIC(CLogSessionInformationDlg, CPropertyPage)
CLogSessionInformationDlg::CLogSessionInformationDlg()
	: CPropertyPage(CLogSessionInformationDlg::IDD)
{
    m_pLogSession = NULL;
}

CLogSessionInformationDlg::~CLogSessionInformationDlg()
{
}

BOOL CLogSessionInformationDlg::OnInitDialog()
{
    BOOL                    retVal;
    CLogSessionPropSht     *pSheet = (CLogSessionPropSht *)GetParent();   

    retVal = CPropertyPage::OnInitDialog();
   
    pSheet = (CLogSessionPropSht*) GetParent();

    //
    // Initialize settings from the parent property sheet
    //
    m_pLogSession = pSheet->m_pLogSession;
    m_bAppend = pSheet->m_bAppend;
    m_bRealTime = pSheet->m_bRealTime;
    m_bWriteLogFile = pSheet->m_bWriteLogFile;
    m_logFileNameString = pSheet->m_logFileName;
    m_displayNameString = pSheet->m_displayName;

    return retVal;
}

//
// Enable the correct wizard buttons 
//
BOOL CLogSessionInformationDlg::OnSetActive() 
{
    CString             str;
    CDisplayDlg        *pDisplayDlg;
    CLogSessionPropSht *pSheet = (CLogSessionPropSht*) GetParent();
    LONG                numberOfEntries;
    BOOL                retVal;

    retVal = CPropertyPage::OnSetActive();

    //
    // Fix the title if in Wizard mode
    //
    if(pSheet->IsWizard()) {
        CTabCtrl* pTab = pSheet->GetTabControl();

        //
        //If its not the active page, just set the tab item
        //
	    TC_ITEM ti;
	    ti.mask = TCIF_TEXT;
	    ti.pszText =_T("Create New Log Session");
	    VERIFY(pTab->SetItem(1, &ti));
    }

    //
    // Enable the back and finish buttons
    //
    pSheet->SetWizardButtons(PSWIZB_BACK|PSWIZB_FINISH);

    //
    // Update the display name
    //
    m_displayNameString = pSheet->m_displayName;

    //
    // set the log session name
    //
    m_logSessionName.SetWindowText(m_displayNameString);

    //
    // Disable the session name edit if using kernel logger or if the trace is active
    //
    if(m_displayNameString.Compare(KERNEL_LOGGER_NAME)) {
        m_logSessionName.EnableWindow(!m_pLogSession->m_bTraceActive);
    } else {
        m_logSessionName.EnableWindow(FALSE);
    }

    //
    // set the logfile name 
    //
    m_logFileName.SetWindowText(m_logFileNameString);

    //
    // set the logfile write check
    //
    ((CButton *)GetDlgItem(IDC_WRITE_LOGFILE_CHECK))->SetCheck(m_bWriteLogFile);

    //
    // Enable log file stuff as appropriate
    //
    ((CButton *)GetDlgItem(IDC_APPEND_CHECK))->EnableWindow(!m_pLogSession->m_bTraceActive && m_bWriteLogFile);
    ((CEdit *)GetDlgItem(IDC_LOGFILE_EDIT))->EnableWindow(m_bWriteLogFile);
    ((CButton *)GetDlgItem(IDC_LOGFILE_BROWSE_BUTTON))->EnableWindow(m_bWriteLogFile);

    //
    // update the append check
    //
    ((CButton *)GetDlgItem(IDC_APPEND_CHECK))->SetCheck(m_bAppend);

    //
    // update the real time check
    //
    ((CButton *)GetDlgItem(IDC_REALTIME_CHECK))->SetCheck(m_bRealTime);

    return retVal;
}

BOOL CLogSessionInformationDlg::OnKillActive()
{
    CLogSessionPropSht *pSheet = (CLogSessionPropSht *)GetParent();   
    BOOL                retVal= TRUE;

    retVal = CPropertyPage::OnKillActive();
   
    pSheet = (CLogSessionPropSht*) GetParent();

    //
    // Store all settings here so that they are correct if the user
    // hits the back button and comes back to us.  These settings are
    // not propagated back to the parent property sheet yet though.
    //
    // Note: OnKillActive is not called if the user selects the finish
    // button.
    //

    //
    // store the log session name
    //
    m_logSessionName.GetWindowText(m_displayNameString);


    //
    // store the logfile name 
    //
    m_logFileName.GetWindowText(m_logFileNameString);

    //
    // store the logfile write check
    //
    m_bWriteLogFile = ((CButton *)GetDlgItem(IDC_WRITE_LOGFILE_CHECK))->GetCheck();

    //
    // store the append check
    //
    m_bAppend = ((CButton *)GetDlgItem(IDC_APPEND_CHECK))->GetCheck();

    //
    // store the real time value
    //
    m_bRealTime = ((CButton *)GetDlgItem(IDC_REALTIME_CHECK))->GetCheck();

	return retVal;
}

void CLogSessionInformationDlg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_LOG_NAME_EDIT, m_logSessionName);
    DDX_Control(pDX, IDC_LOGFILE_EDIT, m_logFileName);
    DDX_Control(pDX, IDC_APPEND_CHECK, m_appendLogFile);
    DDX_Control(pDX, IDC_REALTIME_CHECK, m_realTime);
}


BEGIN_MESSAGE_MAP(CLogSessionInformationDlg, CPropertyPage)
	ON_BN_CLICKED(IDC_LOGFILE_BROWSE_BUTTON, OnBnClickedLogfileBrowseButton)
    ON_BN_CLICKED(IDC_WRITE_LOGFILE_CHECK, OnBnClickedWriteLogfileCheck)
    ON_BN_CLICKED(IDC_ADVANCED_BUTTON, OnBnClickedAdvancedButton)
END_MESSAGE_MAP()


// CLogSessionInformationDlg message handlers

void CLogSessionInformationDlg::OnBnClickedLogfileBrowseButton()
{
    DWORD   flags;

    //
    // If appending the file must exist; Else prompt user to
    // create if the file doesn't exist
    //
    flags = (m_appendLogFile.GetCheck() ? OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | 
                                            OFN_HIDEREADONLY | OFN_EXPLORER | 
                                            OFN_NOCHANGEDIR :
                                          OFN_CREATEPROMPT | OFN_HIDEREADONLY | 
                                            OFN_EXPLORER | OFN_NOCHANGEDIR);

	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE, 
                       _T("etl"),_T("*.etl"),
				        flags, 
				       _T("Log Session Files (*.etl)|*.etl|All Files (*.*)|*.*||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name
	//
    if(!fileDlg.GetPathName().IsEmpty()) {
        //
        // Store the file name
        //
        ((CLogSessionPropSht *)GetParent())->m_pLogSession->m_logFileName = 
                                                        fileDlg.GetPathName();
        // 
        // Display the file name and give it focus
        //
        m_logFileName.SetWindowText(fileDlg.GetPathName());
        m_logFileName.SetFocus();
    }
}

void CLogSessionInformationDlg::OnBnClickedWriteLogfileCheck()
{
    //
    // Enable or disable the log file name edit box, the append
    // check box, and the browse button as appropriate.
    //
    if(((CButton *)GetDlgItem(IDC_WRITE_LOGFILE_CHECK))->GetCheck()) {
        m_logFileName.EnableWindow(TRUE);
        m_appendLogFile.EnableWindow(TRUE);
        ((CButton *)GetDlgItem(IDC_LOGFILE_BROWSE_BUTTON))->EnableWindow(TRUE);
    } else {
        m_logFileName.EnableWindow(FALSE);
        m_appendLogFile.EnableWindow(FALSE);
        ((CButton *)GetDlgItem(IDC_LOGFILE_BROWSE_BUTTON))->EnableWindow(FALSE);
    }
}

void CLogSessionInformationDlg::OnBnClickedAdvancedButton()
{
    INT_PTR             retVal;
    CLogSessionPropSht *pSheet = (CLogSessionPropSht *)GetParent();   

    //
	// pop-up our wizard/tab dialog to show/get properties
    //
    CLogSessionAdvPropSht *pLogSessionAdvPropertySheet = 
            new CLogSessionAdvPropSht(this, pSheet);

    if(NULL == pLogSessionAdvPropertySheet) {
        return;
    }

    retVal = pLogSessionAdvPropertySheet->DoModal();

	if(IDOK != retVal) {
//BUGBUG -- make sure options are correct here
    }

    delete pLogSessionAdvPropertySheet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessioninformationdlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionInformationDlg.h : CLogSessionInformationDlg header
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "afxwin.h"


// CLogSessionInformationDlg dialog

class CLogSessionInformationDlg : public CPropertyPage
{
	DECLARE_DYNAMIC(CLogSessionInformationDlg)

public:
	CLogSessionInformationDlg();
	virtual ~CLogSessionInformationDlg();

	BOOL OnInitDialog();

    BOOL OnSetActive();
    BOOL OnKillActive();

// Dialog Data
	enum { IDD = IDD_LOG_SESSION_INFORMATION_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedLogfileBrowseButton();
    afx_msg void OnBnClickedWriteLogfileCheck();
    afx_msg void OnBnClickedAdvancedButton();

	CEdit           m_logSessionName;
	CEdit           m_logFileName;
	CButton         m_appendLogFile;
    CButton         m_realTime;
    CLogSession    *m_pLogSession;
    BOOL            m_bAppend;
    BOOL            m_bRealTime;
    BOOL            m_bWriteLogFile;
    CString         m_logFileNameString;
    CString         m_displayNameString;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionoptionsdlg.h ===
#pragma once
#include "afxwin.h"


// CLogSessionOptionsDlg dialog

class CLogSessionOptionsDlg : public CDialog
{
	DECLARE_DYNAMIC(CLogSessionOptionsDlg)

public:
	CLogSessionOptionsDlg(CWnd* pParent, CLogSession *pLogSession);
	virtual ~CLogSessionOptionsDlg();

    int OnInitDialog();

// Dialog Data
	enum { IDD = IDD_LOG_SESSION_OPTIONS_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    CLogSession    *m_pLogSession;
    LONG            m_DisplayEnableFlags;       // Enable flags for the log session output


	DECLARE_MESSAGE_MAP()
public:
    afx_msg void OnBnClickedOk();
    afx_msg void OnBnClickedLogfileBrowseButton();
    afx_msg void OnTcnSelchangeTab1(NMHDR *pNMHDR, LRESULT *pResult);

    CButton m_DisplayMaxBuf;
    CButton m_DisplayMinBuf;
    CButton m_DisplayBufferSize;
    CButton m_DisplayFlushTime;
    CButton m_DisplayTraceLevel;
    CButton m_DisplayDecayTime;
    CButton m_DisplayNewFile;
    CButton m_DisplayCir;
    CButton m_DisplaySeq;
    CButton m_DisplayFlags;
    CEdit   m_LogSessionName;
    CEdit m_MaxBufValue;
    CEdit m_MinBufValue;
    CEdit m_BufferSizeValue;
    CEdit m_FlushTimeValue;
    CEdit m_TraceLevelValue;
    CEdit m_DecayTimeValue;
    CEdit m_NewFileValue;
    CEdit m_CirValue;
    CEdit m_FlagsValue;
    CEdit m_LogFileName;
    CButton m_AppendToLogFile;
    CEdit m_SeqValue;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionoptionsdlg.cpp ===
// LogSessionOptionsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "TraceView.h"
#include "DisplayDlg.h"
#include "LogSession.h"
#include "LogSessionOptionsDlg.h"


// CLogSessionOptionsDlg dialog

IMPLEMENT_DYNAMIC(CLogSessionOptionsDlg, CDialog)
CLogSessionOptionsDlg::CLogSessionOptionsDlg(CWnd* pParent, CLogSession *pLogSession)
	: CDialog(CLogSessionOptionsDlg::IDD, pParent)
{
    m_pLogSession = pLogSession;
}

CLogSessionOptionsDlg::~CLogSessionOptionsDlg()
{
}

int CLogSessionOptionsDlg::OnInitDialog()
{
    LONG    displayEnableFlags;
    CString str;
    
    int retVal = CDialog::OnInitDialog();

    // Hide all of the non-Tab1 items
    m_DisplayMaxBuf.ShowWindow(SW_HIDE);
    m_DisplayMinBuf.ShowWindow(SW_HIDE);
    m_DisplayBufferSize.ShowWindow(SW_HIDE);
    m_DisplayFlushTime.ShowWindow(SW_HIDE);
    m_DisplayTraceLevel.ShowWindow(SW_HIDE);
    m_DisplayDecayTime.ShowWindow(SW_HIDE);
    m_DisplayNewFile.ShowWindow(SW_HIDE);
    m_DisplayCir.ShowWindow(SW_HIDE);
    m_DisplaySeq.ShowWindow(SW_HIDE);
    m_DisplayFlags.ShowWindow(SW_HIDE);
    m_MaxBufValue.ShowWindow(SW_HIDE);
    m_MinBufValue.ShowWindow(SW_HIDE);
    m_BufferSizeValue.ShowWindow(SW_HIDE);
    m_FlushTimeValue.ShowWindow(SW_HIDE);
    m_TraceLevelValue.ShowWindow(SW_HIDE);
    m_DecayTimeValue.ShowWindow(SW_HIDE);
    m_NewFileValue.ShowWindow(SW_HIDE);
    m_CirValue.ShowWindow(SW_HIDE);
    m_SeqValue.ShowWindow(SW_HIDE);
    m_FlagsValue.ShowWindow(SW_HIDE);

    GetDlgItem(IDC_MAXBUF_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_MINBUF_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_BUFFERSIZE_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_FLUSHTIME_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_TRACELEVEL_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_DECAYTIME_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_NEWFILE_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_CIR_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_SEQ_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_FLAGS_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_DISPLAY1_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_OPTION1_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_VALUE1_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_DISPLAY2_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_OPTION2_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_VALUE2_STATIC)->ShowWindow(SW_HIDE);

    // Setup the tab control
    ((CTabCtrl *)GetDlgItem(IDC_TAB1))->InsertItem(0, "Session Information");
    ((CTabCtrl *)GetDlgItem(IDC_TAB1))->InsertItem(1, "Display Options");


    // Handle the session name
    if(m_pLogSession->GetDisplayName() == "") {
        str.Format("Trace%d", m_pLogSession->GetLogSessionID());
    
        m_pLogSession->SetDisplayName(str);
    } else {
        m_LogSessionName.EnableWindow(FALSE);
        m_LogFileName.EnableWindow(FALSE);
        m_AppendToLogFile.EnableWindow(FALSE);
        GetDlgItem(IDC_LOGFILE_BROWSE_BUTTON)->EnableWindow(FALSE);
    }


    // Set the defaults
    displayEnableFlags = m_pLogSession->GetDisplayEnableFlags();

    m_DisplayMaxBuf.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_MAXBUF);
    
    m_DisplayMinBuf.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_MINBUF);
    
    m_DisplayBufferSize.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_BUFFERSIZE);
    
    m_DisplayTraceLevel.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_TRACELEVEL);
    
    m_DisplayFlushTime.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_FLUSHTIME);
    
    m_DisplayDecayTime.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_DECAYTIME);
    
    m_DisplayNewFile.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_NEWFILE);
    
    m_DisplayCir.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_CIR);
    
    m_DisplaySeq.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_SEQ);
    
    m_DisplayFlags.SetCheck(displayEnableFlags & LOGSESSION_DISPLAY_FLAGS);
    
    m_LogSessionName.SetWindowText(m_pLogSession->GetDisplayName());

    m_LogFileName.SetWindowText(m_pLogSession->m_OutputFileName);

    return retVal;
}

void CLogSessionOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_DISPLAY_MAXBUF_CHECK, m_DisplayMaxBuf);
    DDX_Control(pDX, IDC_DISPLAY_MINBUF_CHECK, m_DisplayMinBuf);
    DDX_Control(pDX, IDC_DISPLAY_BUFSIZ_CHECK, m_DisplayBufferSize);
    DDX_Control(pDX, IDC_DISPLAY_FLUSHTIME_CHECK, m_DisplayFlushTime);
    DDX_Control(pDX, IDC_DISPLAY_TRCLVL_CHECK, m_DisplayTraceLevel);
    DDX_Control(pDX, IDC_DISPLAY_DECAYTIME_CHECK, m_DisplayDecayTime);
    DDX_Control(pDX, IDC_DISPLAY_NEWFILE_CHECK, m_DisplayNewFile);
    DDX_Control(pDX, IDC_DISPLAY_CIR_CHECK, m_DisplayCir);
    DDX_Control(pDX, IDC_DISPLAY_SEQ_CHECK, m_DisplaySeq);
    DDX_Control(pDX, IDC_DISPLAY_FLAGS_CHECK, m_DisplayFlags);
    DDX_Control(pDX, IDC_LOG_NAME_EDIT, m_LogSessionName);
    DDX_Control(pDX, IDC_MAXBUF_VAL_EDIT, m_MaxBufValue);
    DDX_Control(pDX, IDC_MINBUF_VAL_EDIT, m_MinBufValue);
    DDX_Control(pDX, IDC_BUFSIZ_VAL_EDIT, m_BufferSizeValue);
    DDX_Control(pDX, IDC_FLUSHTIME_VAL_EDIT, m_FlushTimeValue);
    DDX_Control(pDX, IDC_TRCLVL_VAL_EDIT, m_TraceLevelValue);
    DDX_Control(pDX, IDC_DECAYTIME_VAL_EDIT, m_DecayTimeValue);
    DDX_Control(pDX, IDC_NEWFILE_VAL_EDIT, m_NewFileValue);
    DDX_Control(pDX, IDC_CIR_VAL_EDIT, m_CirValue);
    DDX_Control(pDX, IDC_FLAGS_VAL_EDIT, m_FlagsValue);
    DDX_Control(pDX, IDC_LOGFILE_EDIT, m_LogFileName);
    DDX_Control(pDX, IDC_APPEND_CHECK, m_AppendToLogFile);
    DDX_Control(pDX, IDC_SEQ_VAL_EDIT3, m_SeqValue);
}

BEGIN_MESSAGE_MAP(CLogSessionOptionsDlg, CDialog)
    ON_BN_CLICKED(IDOK, OnBnClickedOk)
    ON_BN_CLICKED(IDC_LOGFILE_BROWSE_BUTTON, OnBnClickedLogfileBrowseButton)
    ON_NOTIFY(TCN_SELCHANGE, IDC_TAB1, OnTcnSelchangeTab1)
END_MESSAGE_MAP()

void CLogSessionOptionsDlg::OnBnClickedOk()
{
    CString str;
    CString strBogus;
    LONG    length;
    TCHAR   logSessionName[500];

    m_LogFileName.GetWindowText(m_pLogSession->m_OutputFileName);

    // Warn the user that no logfile was specified
    if((m_LogFileName.IsWindowEnabled()) && (m_pLogSession->m_OutputFileName.IsEmpty())) {
        if(IDCANCEL == AfxMessageBox("No Log File Specified\n\nTrace Data Will Not Be Saved  \n", MB_OKCANCEL)) {
            return;
        }
    }

    m_DisplayEnableFlags = 0;

    if(m_DisplayMaxBuf.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_MAXBUF;
    };

    if(m_DisplayMinBuf.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_MINBUF;
    };

    if(m_DisplayBufferSize.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_BUFFERSIZE;
    };

    if(m_DisplayTraceLevel.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_TRACELEVEL;
    };

    if(m_DisplayFlushTime.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_FLUSHTIME;
    };

    if(m_DisplayDecayTime.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_DECAYTIME;
    };

    if(m_DisplayNewFile.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_NEWFILE;
    };

    if(m_DisplayCir.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_CIR;
    };

    if(m_DisplaySeq.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_SEQ;
    };

    if(m_DisplayFlags.GetCheck()) {
        m_DisplayEnableFlags |= LOGSESSION_DISPLAY_FLAGS;
    };

    m_pLogSession->SetDisplayEnableFlags(m_DisplayEnableFlags);

    // Update the log session name if changed
    length = m_LogSessionName.LineLength(0);

    memset((void *)logSessionName, 0, length + 2);

    m_LogSessionName.GetLine(0, logSessionName, length);

    str = logSessionName;

    m_pLogSession->SetDisplayName(str);

    OnOK();
}

void CLogSessionOptionsDlg::OnBnClickedLogfileBrowseButton()
{
    char fileName[260] = "";     // buffer for file name

    OPENFILENAME openFile;

    ZeroMemory(&openFile, sizeof(OPENFILENAME));

    openFile.lStructSize = sizeof(OPENFILENAME);
    //openFile.hwndOwner = GetSafeHwnd();
    openFile.lpstrCustomFilter = NULL;
    openFile.nMaxCustFilter = 0;
    openFile.nFilterIndex = 1;
    openFile.lpstrFile = fileName;
    openFile.nMaxFile = 500;
    openFile.lpstrFileTitle = NULL;
    openFile.nMaxFileTitle = 0;
    openFile.lpstrInitialDir = NULL;
    openFile.lpstrTitle = "Open Log File";
    if(m_AppendToLogFile.GetCheck()) {
        openFile.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
    } else {
        openFile.Flags = OFN_CREATEPROMPT;
    }
    openFile.lpstrDefExt = "log";
    openFile.lpstrFilter = "log files (*.log)\0*.log\0all files (*.*)\0*.*\0";
    openFile.lCustData = NULL;
    openFile.lpfnHook = NULL;
    openFile.lpTemplateName = NULL;


    if(!GetOpenFileName(&openFile)) {
        AfxMessageBox("Failed To Open Logfile");
    } else {
        m_pLogSession->m_OutputFileName = fileName;
        m_LogFileName.SetWindowText(fileName);
    }
}
CTabCtrl
void CLogSessionOptionsDlg::OnTcnSelchangeTab1(NMHDR *pNMHDR, LRESULT *pResult)
{
        // Hide all of the non-Tab1 items
    m_DisplayMaxBuf.ShowWindow(SW_HIDE);
    m_DisplayMinBuf.ShowWindow(SW_HIDE);
    m_DisplayBufferSize.ShowWindow(SW_HIDE);
    m_DisplayFlushTime.ShowWindow(SW_HIDE);
    m_DisplayTraceLevel.ShowWindow(SW_HIDE);
    m_DisplayDecayTime.ShowWindow(SW_HIDE);
    m_DisplayNewFile.ShowWindow(SW_HIDE);
    m_DisplayCir.ShowWindow(SW_HIDE);
    m_DisplaySeq.ShowWindow(SW_HIDE);
    m_DisplayFlags.ShowWindow(SW_HIDE);
    m_MaxBufValue.ShowWindow(SW_HIDE);
    m_MinBufValue.ShowWindow(SW_HIDE);
    m_BufferSizeValue.ShowWindow(SW_HIDE);
    m_FlushTimeValue.ShowWindow(SW_HIDE);
    m_TraceLevelValue.ShowWindow(SW_HIDE);
    m_DecayTimeValue.ShowWindow(SW_HIDE);
    m_NewFileValue.ShowWindow(SW_HIDE);
    m_CirValue.ShowWindow(SW_HIDE);
    m_SeqValue.ShowWindow(SW_HIDE);
    m_FlagsValue.ShowWindow(SW_HIDE);

    GetDlgItem(IDC_MAXBUF_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_MINBUF_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_BUFFERSIZE_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_FLUSHTIME_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_TRACELEVEL_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_DECAYTIME_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_NEWFILE_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_CIR_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_SEQ_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_FLAGS_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_DISPLAY1_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_OPTION1_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_VALUE1_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_DISPLAY2_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_OPTION2_STATIC)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_VALUE2_STATIC)->ShowWindow(SW_HIDE);

    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionoutputoptiondlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionOutputOptionDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "resource.h"
#include "logsession.h"
#include "DisplayDlg.h"
#include "logDisplayOptionDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "LogSessionOutputOptionDlg.h"
#include "LogSessionAdvPropSht.h"



// CLogSessionOutputOptionDlg dialog

IMPLEMENT_DYNAMIC(CLogSessionOutputOptionDlg, CPropertyPage)
CLogSessionOutputOptionDlg::CLogSessionOutputOptionDlg()
	: CPropertyPage(CLogSessionOutputOptionDlg::IDD)
{
}

CLogSessionOutputOptionDlg::~CLogSessionOutputOptionDlg()
{
}

BOOL CLogSessionOutputOptionDlg::OnInitDialog() 
{
    BOOL                    retVal;
    CLogSessionAdvPropSht  *pSheet = (CLogSessionAdvPropSht  *)GetParent();

    //
    // Determine if the log session is actively tracing
    //
    m_bTraceActive = pSheet->m_pLogSession->m_bTraceActive;

    //
    // Determine enable state of controls
    //
    m_bWriteListingFile = pSheet->m_pLogSessionPropSht->m_bWriteListingFile;
    m_bWriteSummaryFile = pSheet->m_pLogSessionPropSht->m_bWriteSummaryFile;

    retVal = CPropertyPage::OnInitDialog();

    m_listingFileName.SetWindowText(pSheet->m_pLogSessionPropSht->m_listingFileName);
    m_summaryFileName.SetWindowText(pSheet->m_pLogSessionPropSht->m_summaryFileName);

    //
    // setup listing file controls
    //

    //
    // set the check
    //
    ((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->SetCheck(m_bWriteListingFile);

    //
    // enable the check
    //
    ((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->EnableWindow(!m_bTraceActive);

    //
    // enable the edit and browse controls
    //
    ((CEdit *)GetDlgItem(IDC_LISTING_FILE_EDIT))->EnableWindow(
                            m_bWriteListingFile && !m_bTraceActive);
    ((CButton *)GetDlgItem(IDC_LISTING_BROWSE_BUTTON))->EnableWindow(
                            m_bWriteListingFile && !m_bTraceActive);

    //
    // setup summary file controls
    //

    //
    // set the check
    //
    ((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->SetCheck(m_bWriteSummaryFile);

    //
    // enable the check
    //
    ((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->EnableWindow(!m_bTraceActive);

    //
    // enable the edit and browse controls
    //
    ((CEdit *)GetDlgItem(IDC_SUMMARY_FILE_EDIT))->EnableWindow(
                            m_bWriteSummaryFile && !m_bTraceActive);

    ((CButton *)GetDlgItem(IDC_SUMMARY_BROWSE_BUTTON))->EnableWindow(
                            m_bWriteSummaryFile && !m_bTraceActive);

    return retVal;
}

BOOL CLogSessionOutputOptionDlg::OnSetActive() 
{
    //
    // Enable the correct wizard buttons 
    //

    //
    // check boxes
    //
    ((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->EnableWindow(!m_bTraceActive);
    ((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->EnableWindow(!m_bTraceActive);

    //
    // edit controls
    //
    ((CEdit *)GetDlgItem(IDC_LISTING_FILE_EDIT))->EnableWindow(!m_bTraceActive && m_bWriteListingFile);
    ((CEdit *)GetDlgItem(IDC_SUMMARY_FILE_EDIT))->EnableWindow(!m_bTraceActive && m_bWriteSummaryFile);

    //
    // browse buttons
    //
    ((CButton *)GetDlgItem(IDC_LISTING_BROWSE_BUTTON))->EnableWindow(!m_bTraceActive && m_bWriteListingFile);
    ((CButton *)GetDlgItem(IDC_SUMMARY_BROWSE_BUTTON))->EnableWindow(!m_bTraceActive && m_bWriteSummaryFile);

    return CPropertyPage::OnSetActive();
}

void CLogSessionOutputOptionDlg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_LISTING_FILE_EDIT, m_listingFileName);
    DDX_Control(pDX, IDC_SUMMARY_FILE_EDIT, m_summaryFileName);
}


BEGIN_MESSAGE_MAP(CLogSessionOutputOptionDlg, CPropertyPage)
    ON_BN_CLICKED(IDC_LISTING_FILE_CHECK, OnBnClickedListingFileCheck)
    ON_BN_CLICKED(IDC_SUMMARY_FILE_CHECK, OnBnClickedSummaryFileCheck)
    ON_BN_CLICKED(IDC_LISTING_BROWSE_BUTTON, OnBnClickedListingBrowseButton)
    ON_BN_CLICKED(IDC_SUMMARY_BROWSE_BUTTON, OnBnClickedSummaryBrowseButton)
END_MESSAGE_MAP()


// CLogSessionOutputOptionDlg message handlers

void CLogSessionOutputOptionDlg::OnBnClickedListingFileCheck()
{
    if(((CButton *)GetDlgItem(IDC_LISTING_FILE_CHECK))->GetCheck()) {
        GetDlgItem(IDC_LISTING_FILE_EDIT)->EnableWindow(TRUE);
        GetDlgItem(IDC_LISTING_BROWSE_BUTTON)->EnableWindow(TRUE);
        m_bWriteListingFile = TRUE;
    } else {
        GetDlgItem(IDC_LISTING_FILE_EDIT)->EnableWindow(FALSE);
        GetDlgItem(IDC_LISTING_BROWSE_BUTTON)->EnableWindow(FALSE);
        m_bWriteListingFile = FALSE;
    }
}

void CLogSessionOutputOptionDlg::OnBnClickedSummaryFileCheck()
{
    if(((CButton *)GetDlgItem(IDC_SUMMARY_FILE_CHECK))->GetCheck()) {
        GetDlgItem(IDC_SUMMARY_FILE_EDIT)->EnableWindow(TRUE);
        GetDlgItem(IDC_SUMMARY_BROWSE_BUTTON)->EnableWindow(TRUE);
        m_bWriteSummaryFile = TRUE;
    } else {
        GetDlgItem(IDC_SUMMARY_FILE_EDIT)->EnableWindow(FALSE);
        GetDlgItem(IDC_SUMMARY_BROWSE_BUTTON)->EnableWindow(FALSE);
        m_bWriteSummaryFile = FALSE;
    }
}

void CLogSessionOutputOptionDlg::OnBnClickedListingBrowseButton()
{
	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE, 
                       _T("out"),_T("*.out"),
				        OFN_CREATEPROMPT | OFN_HIDEREADONLY | 
                            OFN_EXPLORER | OFN_NOCHANGEDIR, 
				       _T("Output Files (*.out)|*.out|Text Files (*.txt)|*.txt|All Files (*.*)|*.*||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name and display it
	//
    if(!fileDlg.GetPathName().IsEmpty()) {
		m_listingFileName.SetWindowText(fileDlg.GetPathName());
        m_listingFileName.SetFocus();
    }
}

void CLogSessionOutputOptionDlg::OnBnClickedSummaryBrowseButton()
{
	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE, 
                       _T("sum"),_T("*.sum"),
				        OFN_CREATEPROMPT | OFN_HIDEREADONLY | 
                            OFN_EXPLORER | OFN_NOCHANGEDIR, 
				       _T("Summary Files (*.sum)|*.sum|Text Files (*.txt)|*.txt|All Files (*.*)|*.*||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name and display it
	//
    if(!fileDlg.GetPathName().IsEmpty()) {
		m_summaryFileName.SetWindowText(fileDlg.GetPathName());
        m_summaryFileName.SetFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionoutputoptiondlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionOutputOptionDlg.h : CLogSessionOutputOptionDlg header
//////////////////////////////////////////////////////////////////////////////


#pragma once
#include "afxwin.h"


// CLogSessionOutputOptionDlg dialog

class CLogSessionOutputOptionDlg : public CPropertyPage
{
	DECLARE_DYNAMIC(CLogSessionOutputOptionDlg)

public:
	CLogSessionOutputOptionDlg();
	virtual ~CLogSessionOutputOptionDlg();

    BOOL OnInitDialog();
    BOOL OnSetActive();

// Dialog Data
	enum { IDD = IDD_LOG_OUTPUT_DIALOG };

    BOOL    m_bTraceActive;
    BOOL    m_bWriteListingFile;
    BOOL    m_bWriteSummaryFile;
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
    CEdit m_listingFileName;
    CEdit m_summaryFileName;
    
    afx_msg void OnBnClickedListingFileCheck();
    afx_msg void OnBnClickedSummaryFileCheck();
    afx_msg void OnBnClickedListingBrowseButton();
    afx_msg void OnBnClickedSummaryBrowseButton();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionpropsht.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionPropSht.h : CLogSessionPropSht header
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CLogSessionPropSht : public CPropertySheet
{
public:
	DECLARE_DYNAMIC(CLogSessionPropSht)
	CLogSessionPropSht(CWnd* pWndParent, CLogSession *pLogSession);

// Attributes
	CLogSessionInformationDlg	m_logSessionInformationDlg;
    CProviderSetupDlg           m_providerSetupPage;
	CLogSession				   *m_pLogSession;
    CStringArray                m_originalValues;
    BOOL                        m_bAppend;
    BOOL                        m_bRealTime;
    BOOL                        m_bWriteLogFile;
    CString                     m_logFileName;
    CString                     m_displayName;              // Log session display name
    BOOL                        m_bWriteListingFile;
    BOOL                        m_bWriteSummaryFile;
    CString                     m_listingFileName;          // File name for event output
    CString                     m_summaryFileName;          // File name for summary output
    CStringArray                m_logSessionValues;
    LONG                        m_groupID;

// Overrides
	virtual BOOL OnInitDialog();


// Message Handlers
protected:
	//{{AFX_MSG(CLogSessionPropSht)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	afx_msg void OnBnClickedOk();
	afx_msg void OnBnClickedFinish();
	afx_msg void OnBnClickedCancel();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\logsessionpropsht.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// LogSessionPropSht.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "traceview.h"
#include "resource.h"
#include "logsession.h"
#include "DisplayDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "utils.h"

IMPLEMENT_DYNAMIC(CLogSessionPropSht, CPropertySheet)

BEGIN_MESSAGE_MAP(CLogSessionPropSht, CPropertySheet)
	//{{AFX_MSG_MAP(CLogSessionPropSht)
	ON_BN_CLICKED(IDOK, OnBnClickedOk)
	ON_BN_CLICKED(IDCANCEL, OnBnClickedCancel)
	ON_BN_CLICKED(ID_WIZFINISH, OnBnClickedFinish)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CLogSessionPropSht::CLogSessionPropSht(CWnd* pWndParent, CLogSession *pLogSession)
	: CPropertySheet(IDS_LOG_SESSION_OPTIONS_TITLE, pWndParent)
{
    CString str;

    ASSERT(pLogSession != NULL);


    AddPage(&m_providerSetupPage);
	AddPage(&m_logSessionInformationDlg);

    //
    // Initialize the log session settings from the log session
    // this way we display the correct settings for the log session.
    // A new session is setup with defaults, so this will work no matter.
    //
	m_pLogSession = pLogSession;
    m_bAppend = pLogSession->m_bAppend;
    m_bRealTime = pLogSession->m_bRealTime;
    m_bWriteLogFile = pLogSession->m_bWriteLogFile;
    m_logFileName = pLogSession->m_logFileName;
    m_displayName = pLogSession->m_displayName;

    //
    // If this session is already in a group, then display the output
    // file option settings.  Otherwise go with defaults.
    //
    if(NULL != pLogSession->GetDisplayWnd()) {
        m_bWriteListingFile = pLogSession->GetDisplayWnd()->m_bWriteListingFile;
        m_listingFileName = pLogSession->GetDisplayWnd()->m_listingFileName;
        m_bWriteSummaryFile = pLogSession->GetDisplayWnd()->m_bWriteSummaryFile;
        m_summaryFileName = pLogSession->GetDisplayWnd()->m_summaryFileName;
    } else {
        m_bWriteListingFile = FALSE;
        m_listingFileName = (LPCTSTR)pLogSession->GetDisplayName();
        m_listingFileName +=_T(".out");
        m_bWriteSummaryFile = FALSE;
        m_summaryFileName = (LPCTSTR)pLogSession->GetDisplayName();
        m_summaryFileName +=_T(".sum");
    }

    m_logSessionValues.Copy(pLogSession->m_logSessionValues);
}

BOOL CLogSessionPropSht::OnInitDialog()
{
	CString str;

	BOOL bResult = CPropertySheet::OnInitDialog();

    //
	// add the window to the property sheet.
    //
	CRect rectWnd;
	GetWindowRect(rectWnd);
	SetWindowPos(NULL, 0, 0,
		rectWnd.Width(),
		rectWnd.Height(),
		SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	CenterWindow();

    //
    // We set both pages active here, so that the data for
    // those property pages gets updated at the start.  Otherwise
    // if a page is not updated and the user clicks finish then
    // improper data could get copied back to the log session.
    //
    if(IsWizard()) {
        SetActivePage(&m_logSessionInformationDlg);
        SetActivePage(&m_providerSetupPage);
    } else {
        SetActivePage(&m_providerSetupPage);
        SetActivePage(&m_logSessionInformationDlg);
    }

	return bResult;
}

void CLogSessionPropSht::OnBnClickedOk()
{
    CString str;

	m_logSessionInformationDlg.UpdateData(TRUE);

    //
    // If the state changed while the dialog was active, ignore the entries
    //
    if(m_pLogSession->m_logSessionValues[State].Compare(m_logSessionValues[State])) {
        EndDialog(2);
        return;
    }

    //
    // Get the log session name
    //
    m_logSessionInformationDlg.m_logSessionName.GetWindowText(m_displayName);

    if(m_displayName.IsEmpty()) {
        AfxMessageBox(_T("Missing Log Session Name"));
        SetActivePage(&m_logSessionInformationDlg);
        SetWizardButtons(PSWIZB_FINISH);
        return;
    }

    //
    // get the logfile name 
    //
    m_logSessionInformationDlg.m_logFileName.GetWindowText(m_logFileName);


    //
	// set the logfile write check
    //
    m_bWriteLogFile = ((CButton *)m_logSessionInformationDlg.GetDlgItem(IDC_WRITE_LOGFILE_CHECK))->GetCheck();

    //
    // The user must specify a valid log file name if selecting
    // to write a log file
    //
    if((m_bWriteLogFile) && (m_logFileName.IsEmpty())) {
        AfxMessageBox(_T("Missing Log File Name"));
        SetActivePage(&m_logSessionInformationDlg);
        SetWizardButtons(PSWIZB_FINISH);
        return;
    }

    //
    // update the append boolean
    //
    m_bAppend = ((CButton *)m_logSessionInformationDlg.GetDlgItem(IDC_APPEND_CHECK))->GetCheck();

    //
    // update the real time boolean
    //
    m_bRealTime = ((CButton *)m_logSessionInformationDlg.GetDlgItem(IDC_REALTIME_CHECK))->GetCheck();

    //
    // Move the data from the prop pages back to the log session.
    // Storing this data local and waiting until here to copy it
    // back to the log session instance allows for a complete and 
    // smooth cancel anywhere in the process of these property sheets.
    //
	m_pLogSession->m_bAppend = m_bAppend;
    m_pLogSession->m_bRealTime = m_bRealTime;
    m_pLogSession->m_bWriteLogFile = m_bWriteLogFile;
    m_pLogSession->m_logFileName = m_logFileName;
    m_pLogSession->m_displayName = m_displayName;

    if(NULL != m_pLogSession->GetDisplayWnd()) {
        m_pLogSession->GetDisplayWnd()->m_bWriteListingFile = m_bWriteListingFile;
        m_pLogSession->GetDisplayWnd()->m_bWriteSummaryFile = m_bWriteSummaryFile;
        m_pLogSession->GetDisplayWnd()->m_listingFileName = m_listingFileName;
        m_pLogSession->GetDisplayWnd()->m_summaryFileName = m_summaryFileName;
    }

    //
    // Copy the log session values back over if the state of the
    // session hasn't changed while the dialogs were active
    //
    for(ULONG ii = 1; ii < MaxLogSessionOptions; ii++) {
        m_pLogSession->m_logSessionValues[ii] = (LPCTSTR)m_logSessionValues[ii];
    }

    //
    // Make sure a provider was entered if real time
    //
    if(m_pLogSession->m_bRealTime) {
        if(m_pLogSession->m_traceSessionArray.GetSize() == 0) {
            SetActivePage(&m_providerSetupPage);
            SetWizardButtons(PSWIZB_FINISH);
            AfxMessageBox(_T("At Least One Provider Must Be Specified For Each Log Session"));
            return;
        }
    }

    //
    // Make sure a provider was entered if the log file doesn't exist
    //
    CFileStatus status;

    if(!CFile::GetStatus(m_logFileName, status )) {
        if(m_pLogSession->m_traceSessionArray.GetSize() == 0) {
            SetActivePage(&m_providerSetupPage);
            SetWizardButtons(PSWIZB_FINISH);
            AfxMessageBox(_T("Log File Does Not Exist\nAt Least One Provider Must Be Specified For Active Tracing"));
            return;
        }
    }

    //
    // Update active session
    //
    if(m_pLogSession->m_bSessionActive) {
        m_pLogSession->GetDisplayWnd()->UpdateSession(m_pLogSession);
    }

	EndDialog(1);
}

void CLogSessionPropSht::OnBnClickedFinish()
{
	OnBnClickedOk();
}

void CLogSessionPropSht::OnBnClickedCancel()
{
	EndDialog(2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\mainfrm.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// MainFrm.cpp : implementation of the CMainFrame class
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "ProviderFormatInfo.h"
#include "ProviderFormatSelectionDlg.h"
#include "ListCtrlEx.h"
#include "LogSessionDlg.h"
#include "LogDisplayOptionDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "LogSessionOutputOptionDlg.h"
#include "DockDialogBar.h"
#include "LogFileDlg.h"
#include "Utils.h"
#include "MainFrm.h"
#include "ProviderControlGUIDDlg.h"
#include "MaxTraceDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

extern LONG MaxTraceEntries;

typedef struct _GROUP_SESSION_PARAMS {
    CPtrArray  *pGroupArray;
    CPtrArray  *pSessionArray;
    HANDLE      SessionDoneEventArray[MAX_LOG_SESSIONS];
} GROUP_SESSION_PARAMS, *PGROUP_SESSION_PARAMS;

// CGroupSession

IMPLEMENT_DYNCREATE(CGroupSession, CWinThread) 

BEGIN_MESSAGE_MAP(CGroupSession, CWinThread)
    ON_MESSAGE(WM_USER_START_GROUP, OnGroupSession)
    ON_MESSAGE(WM_USER_START_UNGROUP, OnUnGroupSession)
END_MESSAGE_MAP()

BOOL CGroupSession::InitInstance()
{
    //
    // Create the event handles
    //
    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        m_hEventArray[ii] = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    return TRUE;
}

int CGroupSession::ExitInstance()
{
    //
    // Release the handles
    //
    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        CloseHandle(m_hEventArray[ii]);
    }

    return 0;
}

void CGroupSession::OnGroupSession(WPARAM wParam, LPARAM lParam)
{
    PGROUP_SESSION_PARAMS pSessionParams = (PGROUP_SESSION_PARAMS)wParam;
    CDisplayDlg    *pDisplayDlg = NULL;
    CString         str;
    LONG            numberOfEvents = (LONG)pSessionParams->pGroupArray->GetSize();

    //
    // Wait on all sessions to end
    //
    DWORD status = WaitForMultipleObjects(numberOfEvents, 
                                          pSessionParams->SessionDoneEventArray, 
                                          TRUE, 
                                          INFINITE);

    for(LONG ii = (LONG)pSessionParams->pGroupArray->GetSize() - 1; ii >= 0 ; ii--) {
        pDisplayDlg = (CDisplayDlg *)pSessionParams->pGroupArray->GetAt(ii);

        if(pDisplayDlg == NULL) {
            continue;
        }

        //
        // If the group has only one member, we don't need to save it, it
        // won't get restarted
        //
        if(pDisplayDlg->m_sessionArray.GetSize() <= 1) {
            pSessionParams->pGroupArray->RemoveAt(ii);
        }

    }

    ::PostMessage(m_hMainWnd, WM_USER_COMPLETE_GROUP, (WPARAM)pSessionParams, 0);
}

void CGroupSession::OnUnGroupSession(WPARAM wParam, LPARAM lParam)
{
    PGROUP_SESSION_PARAMS pSessionParams = (PGROUP_SESSION_PARAMS)wParam;
    CLogSession    *pLogSession;
    BOOL            bWasActive = FALSE;
    CString         str;
    CDisplayDlg    *pDisplayDlg;
    LONG            numberOfEvents = (LONG)pSessionParams->pGroupArray->GetSize();

    //
    // Wait on all sessions to end
    //
    DWORD status = WaitForMultipleObjects(numberOfEvents, 
                                          pSessionParams->SessionDoneEventArray, 
                                          TRUE, 
                                          INFINITE);

    ::PostMessage(m_hMainWnd, WM_USER_COMPLETE_UNGROUP, (WPARAM)pSessionParams, 0);
}

// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    ON_MESSAGE(WM_USER_UPDATE_LOGSESSION_LIST, OnUpdateLogSessionList)
    ON_MESSAGE(WM_USER_COMPLETE_GROUP, OnCompleteGroup)
    ON_MESSAGE(WM_USER_COMPLETE_UNGROUP, OnCompleteUnGroup)
    ON_WM_CREATE()
    ON_WM_SETFOCUS()
    ON_COMMAND(ID_FILE_NEWLOGSESSION, OnFileNewLogSession)
    ON_COMMAND(ID_CREATENEWLOGSESSION, OnCreateNewLogSession)
    ON_COMMAND(ID_SET_TMAX, OnSetTmax)
    ON_COMMAND(ID_PROPERTIES, OnProperties)
    ON_UPDATE_COMMAND_UI(ID_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_START_TRACE_BUTTON, OnStartTrace)
    ON_COMMAND(ID__STARTTRACE, OnStartTrace)
    ON_COMMAND(ID_STOP_TRACE_BUTTON, OnStopTrace)
    ON_COMMAND(ID__STOPTRACE, OnStopTrace)
#if 0
    ON_UPDATE_COMMAND_UI(ID_START_TRACE_BUTTON, OnUpdateStartTraceButton)
    ON_UPDATE_COMMAND_UI(ID_STOP_TRACE_BUTTON, OnUpdateStopTraceButton)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TRACETOOLBAR, OnUpdateViewTraceToolBar)
    ON_COMMAND(ID_VIEW_TRACETOOLBAR, OnViewTraceToolBar)
#endif

    ON_COMMAND(ID_GROUPSESSIONS, OnGroupSessions)
    ON_COMMAND(ID_UNGROUPSESSIONS, OnUngroupSessions)
    ON_COMMAND(ID_REMOVETRACE, OnRemoveLogSession)
    ON_UPDATE_COMMAND_UI(ID_GROUPSESSIONS, OnUpdateUIGroupSessions)
    ON_UPDATE_COMMAND_UI(ID_UNGROUPSESSIONS, OnUpdateUngroupSessions)
    ON_UPDATE_COMMAND_UI(ID__STARTTRACE, OnUpdateUIStartTrace)
    ON_UPDATE_COMMAND_UI(ID__STOPTRACE, OnUpdateUIStopTrace)
    ON_UPDATE_COMMAND_UI(147, OnUpdateUIOpenExisting)
    ON_COMMAND(ID__OPENEXISTINGLOGFILE, OnOpenExisting)
    ON_COMMAND(ID_FILE_OPENEXISTINGLOGFILE, OnOpenExisting)
    ON_COMMAND(ID__FLAGS, OnFlagsColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__FLAGS, OnUpdateFlagsColumnDisplay)
    ON_COMMAND(ID__FLUSHTIME, OnFlushTimeColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__FLUSHTIME, OnUpdateFlushTimeColumnDisplayCheck)
    ON_COMMAND(ID__MAXBUFFERS, OnMaxBuffersColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__MAXBUFFERS, OnUpdateMaxBuffersColumnDisplayCheck)
    ON_COMMAND(ID__MINBUFFERS, OnMinBuffersColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__MINBUFFERS, OnUpdateMinBuffersColumnDisplayCheck)
    ON_COMMAND(ID__BUFFERSIZE, OnBufferSizeColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__BUFFERSIZE, OnUpdateBufferSizeColumnDisplayCheck)
    ON_COMMAND(ID__AGE, OnDecayTimeColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__AGE, OnUpdateDecayTimeColumnDisplayCheck)
    ON_COMMAND(ID__CIRCULAR, OnCircularColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__CIRCULAR, OnUpdateCircularColumnDisplayCheck)
    ON_COMMAND(ID__SEQUENTIAL, OnSequentialColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__SEQUENTIAL, OnUpdateSequentialColumnDisplayCheck)
    ON_COMMAND(ID__NEWFILE, OnNewFileColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__NEWFILE, OnUpdateNewFileColumnDisplayCheck)
    ON_COMMAND(ID__GLOBALSEQUENCE, OnGlobalSeqColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__GLOBALSEQUENCE, OnUpdateGlobalSeqColumnDisplayCheck)
    ON_COMMAND(ID__LOCALSEQUENCE, OnLocalSeqColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__LOCALSEQUENCE, OnUpdateLocalSeqColumnDisplayCheck)
    ON_COMMAND(ID__LEVEL, OnLevelColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__LEVEL, OnUpdateLevelColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID_REMOVETRACE, OnUpdateRemoveTrace)
    ON_COMMAND(ID__STATE, OnStateColumnDisplayCheck)
    ON_COMMAND(ID__EVENTCOUNT, OnEventCountColumnDisplayCheck)
    ON_COMMAND(ID__LOSTEVENTS, OnLostEventsColumnDisplayCheck)
    ON_COMMAND(ID__BUFFERSREAD, OnBuffersReadColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__STATE, OnUpdateStateColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__EVENTCOUNT, OnUpdateEventCountColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__LOSTEVENTS, OnUpdateLostEventsColumnDisplayCheck)
    ON_UPDATE_COMMAND_UI(ID__BUFFERSREAD, OnUpdateBuffersReadColumnDisplayCheck)
    ON_COMMAND(ID__LOGSESSIONDISPLAYOPTIONS, OnLogSessionDisplayOptions)
    ON_COMMAND(ID__CHANGETEXTCOLOR, OnChangeTextColor)
    ON_COMMAND(ID__CHANGEBACKGROUNDCOLOR, OnChangeBackgroundColor)
    ON_UPDATE_COMMAND_UI(ID__CHANGETEXTCOLOR, OnUpdateChangeTextColor)
    ON_UPDATE_COMMAND_UI(ID__CHANGEBACKGROUNDCOLOR, OnUpdateChangeBackgroundColor)
    ON_UPDATE_COMMAND_UI(ID_SET_TMAX, OnUpdateSetTmax)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_hEndTraceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CMainFrame::~CMainFrame()
{
    delete []m_pGroupSessionsThread;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DWORD   extendedStyles;
    CString str;
    RECT    rc;
    int     height;
    HMODULE hTestHandle;


    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    //
    // Make sure that the msvcr70.dll is available, and if not error out
    //
    hTestHandle = LoadLibraryEx(_T("msvcr70.dll"), NULL, 0);

    if(hTestHandle == NULL) {
        AfxMessageBox(_T("MISSING NECESSARY DLL: MSVCR70.DLL"));
        return -1;
    }

    FreeLibrary(hTestHandle);

    //
    // Make sure that the msvcr70.dll is available, and if not error out
    //
    hTestHandle = LoadLibraryEx(_T("mspdb70.dll"), NULL, 0);

    if(hTestHandle == NULL) {
        AfxMessageBox(_T("MISSING NECESSARY DLL: MSPDB70.DLL"));
        return -1;
    }

    FreeLibrary(hTestHandle);

    //
    // Spawn a thread to handle grouping and ungrouping sessions
    //
    m_pGroupSessionsThread = (CGroupSession *)AfxBeginThread(RUNTIME_CLASS(CGroupSession));

    m_pGroupSessionsThread->m_hMainWnd = GetSafeHwnd();

    //
    // create a view to occupy the client area of the frame
    //

    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
    {
        TRACE(_T("Failed to create view window\n"));
        return -1;
    }

#if 0
    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE(_T("Failed to create toolbar\n"));
        //
        // fail to create
        //
        return -1;
    }

    if (!m_wndTraceToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndTraceToolBar.LoadToolBar(IDR_TRACE_TOOLBAR))
    {
        TRACE(_T("Failed to create toolbar\n"));
        //
        // fail to create
        //
        return -1;
    }
#endif

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE(_T("Failed to create status bar\n"));
        //
        // fail to create
        //
        return -1;
    }

#if 0
    //
    // toolbars are dockable
    //
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    m_wndTraceToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBarLeftOf(&m_wndTraceToolBar, &m_wndToolBar);
#endif

    EnableDocking(CBRS_ALIGN_ANY);

    str.Format(_T("Log Session List"));

    //
    // create our dockable dialog bar with list control
    // We always create one, which is our log session list display
    //
    if (!m_wndLogSessionListBar.Create(this, &m_logSessionDlg, str, IDD_DISPLAY_DIALOG,
            WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_SIZE_DYNAMIC))
    {
        TRACE(_T("Failed to create log session list DockDialogBar\n"));
        return -1;
    }

    //
    // make the dialog dockable and dock it to the bottom originally.
    //
    m_wndLogSessionListBar.EnableDocking(CBRS_ALIGN_TOP);

    //
    //EnableDocking(CBRS_ALIGN_ANY);
    //
    DockControlBar(&m_wndLogSessionListBar, AFX_IDW_DOCKBAR_TOP);

    //
    // Go ahead and create the first column header
    //
    str.Format(_T("Group ID / Session Name"));

    m_logSessionDlg.m_displayCtrl.InsertColumn(0, 
                                               str,
                                               LVCFMT_LEFT,
                                               180);

    //
    // set our preferred extended styles
    //
    extendedStyles = LVS_EX_GRIDLINES | 
                     LVS_EX_HEADERDRAGDROP | 
                     LVS_EX_FULLROWSELECT;
    
    //
    // Set the extended styles for the list control
    //
    m_logSessionDlg.m_displayCtrl.SetExtendedStyle(extendedStyles);

    //
    // resize our main window
    //
    GetWindowRect(&rc);

    height = rc.bottom - rc.top;

    GetClientRect(&rc);

    height -= rc.bottom - rc.top;

#if 0
    m_wndToolBar.GetWindowRect(&rc);

    height += rc.bottom - rc.top;
#endif

    m_logSessionDlg.m_displayCtrl.GetWindowRect(&rc);

    height += rc.bottom - rc.top + 432;

    GetWindowRect(&rc);

    SetWindowPos(&wndBottom, 0, 0, rc.right - rc.left + 76, height, SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_SHOWWINDOW);  

    return 0;
}

void CMainFrame::DockControlBarLeftOf(CToolBar* Bar, CToolBar* LeftOf)
{
    CRect rect;
    DWORD dw;
    UINT n;
    
    //
    // get MFC to adjust the dimensions of all docked ToolBars
    // so that GetWindowRect will be accurate
    //
    RecalcLayout(TRUE);
    
    LeftOf->GetWindowRect(&rect);
    rect.OffsetRect(1,0);
    dw=LeftOf->GetBarStyle();
    n = 0;
    n = (dw&CBRS_ALIGN_TOP) ? AFX_IDW_DOCKBAR_TOP : n;
    n = (dw&CBRS_ALIGN_BOTTOM && n==0) ? AFX_IDW_DOCKBAR_BOTTOM : n;
    n = (dw&CBRS_ALIGN_LEFT && n==0) ? AFX_IDW_DOCKBAR_LEFT : n;
    n = (dw&CBRS_ALIGN_RIGHT && n==0) ? AFX_IDW_DOCKBAR_RIGHT : n;
    
    //
    // When we take the default parameters on rect, DockControlBar will dock
    // each Toolbar on a seperate line. By calculating a rectangle, we
    // are simulating a Toolbar being dragged to that location and docked.
    //
    DockControlBar(Bar,n,&rect);

    RecalcLayout(TRUE);
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;

    cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG


// CMainFrame message handlers

void CMainFrame::OnSetFocus(CWnd* /*pOldWnd*/)
{
    // forward focus to the view window
    //m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
    // 
    // 
    //
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CMainFrame::OnFileNewLogSession()
{
    AddModifyLogSession();   
}

void CMainFrame::OnCreateNewLogSession()
{
    AddModifyLogSession();
}

void CMainFrame::AddModifyLogSession(CLogSession *pLogSession)
{
    BOOL            bAddingSession = FALSE;
    CString         str;
    DWORD           extendedStyles;
    INT_PTR         retVal;
    CLogSession    *pLog;
    BOOL            bNoID = FALSE;
    LONG            logSessionID = 0;
    CDisplayDlg    *pDisplayDlg;

    //
    // if this is a new session, create the instance
    //
    if(NULL == pLogSession) {
        //
        // Get a unique log session ID
        //
        logSessionID = m_logSessionDlg.GetLogSessionID();

        pLogSession = new CLogSession(logSessionID, &m_logSessionDlg);
        if(NULL == pLogSession) {
            AfxMessageBox(_T("Unable To Create Log Session"));
            return;
        }

        bAddingSession = TRUE;
    }

    //
    // pop-up our wizard/tab dialog to show/get properties
    //
    CLogSessionPropSht *pLogSessionPropertySheet = 
            new CLogSessionPropSht(this, pLogSession);

    if(NULL == pLogSessionPropertySheet) {
        if(bAddingSession) {
            AfxMessageBox(_T("Failed To Create Log Session, Resource Error"));
            
            m_logSessionDlg.ReleaseLogSessionID(pLogSession);
            delete pLogSession;
        }
        return;
    }

    if(bAddingSession) {
        pLogSessionPropertySheet->SetWizardMode();
    }

    retVal = pLogSessionPropertySheet->DoModal();

    if(IDOK != retVal) {
        if(bAddingSession) {
            if(IDCANCEL != retVal) {
                AfxMessageBox(_T("Failed To Get Log Session Properties"));
            }
            m_logSessionDlg.ReleaseLogSessionID(pLogSession);
            delete pLogSession;
        }
        delete pLogSessionPropertySheet;

        return;
    }

    if(!pLogSession->m_bTraceActive) {

        if(bAddingSession) {
            //
            // Check that we have at least one provider
            //
            if(0 == pLogSession->m_traceSessionArray.GetSize()) {
                AfxMessageBox(_T("No Providers Registered\nLog Session Initialization Failed"));
                m_logSessionDlg.ReleaseLogSessionID(pLogSession);
                delete pLogSession;
                delete pLogSessionPropertySheet;
                return;
            }

            //
            // Add the session to the list of log sessions
            //
            m_logSessionDlg.AddSession(pLogSession);

            //
            // Get the display window for the log session
            //
            pDisplayDlg = pLogSession->GetDisplayWnd();

            ASSERT(pDisplayDlg != NULL);

            //
            // Set the output file info for the display dialog
            //
            pDisplayDlg->m_bWriteListingFile = 
                pLogSessionPropertySheet->m_bWriteListingFile;

            if(pDisplayDlg->m_bWriteListingFile) {
                pDisplayDlg->m_listingFileName = 
                    pLogSessionPropertySheet->m_listingFileName;
            }

            pDisplayDlg->m_bWriteSummaryFile = 
                pLogSessionPropertySheet->m_bWriteSummaryFile;

            if(pDisplayDlg->m_bWriteSummaryFile) {
                pDisplayDlg->m_summaryFileName = 
                    pLogSessionPropertySheet->m_summaryFileName;
            }

            //
            // Start the log session tracing
            //
            pDisplayDlg->BeginTrace();

            //
            // Force a redraw of the list control
            //
            m_logSessionDlg.m_displayCtrl.RedrawItems(
                                        m_logSessionDlg.m_displayCtrl.GetTopIndex(), 
                                        m_logSessionDlg.m_displayCtrl.GetTopIndex() + 
                                            m_logSessionDlg.m_displayCtrl.GetCountPerPage());

            m_logSessionDlg.m_displayCtrl.UpdateWindow();

        } else {
            m_logSessionDlg.UpdateSession(pLogSession);
        }
    } else {
        m_logSessionDlg.UpdateSession(pLogSession);
    }

    delete pLogSessionPropertySheet;
}

void CMainFrame::OnProperties()
{
    POSITION        pos;
    LONG            index;    
    CLogSession    *pLogSession;
    INT_PTR         retVal;
    
    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

    index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

    if((index < 0) || (index >= m_logSessionDlg.m_logSessionArray.GetSize())) {
        AfxMessageBox(_T("Error Log Session Not Found!"));

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        return;
    }
    
    pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

    if(NULL == pLogSession) {
        return;
    }

    if(pLogSession->m_bDisplayExistingLogFileOnly) {
        //
        // pop-up our wizard/tab dialog to show/get properties
        //
        CLogFileDlg *pDialog = new CLogFileDlg(this, pLogSession);
        if(NULL == pDialog) {
            return;
        }
        
        retVal = pDialog->DoModal();

        delete pDialog;

        if(IDOK != retVal) {
            if(IDCANCEL != retVal) {
                AfxMessageBox(_T("Failed To Get Log File Properties"));
            }
            return;
        }

        //
        // Now update the session
        //
        m_logSessionDlg.UpdateSession(pLogSession);
        return;
    }

    AddModifyLogSession(pLogSession);
}

void CMainFrame::OnUpdateProperties(CCmdUI *pCmdUI)
{
    POSITION        pos;
    int             index;
    CLogSession    *pLogSession;


    //
    // Taking this out altogether for now, but leaving it in
    // the code in case it needs to be put back
    //
    pCmdUI->Enable(FALSE);
    
    return;

    //
    // disable the properties option if there is more
    // than one selected log session
    //
    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 1) {
        pCmdUI->Enable(FALSE);
    }

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

    index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

    pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

    //
    // If the session is in process of stopping, don't allow the
    // properties dialog to be viewed
    //
    if((NULL == pLogSession) || 
            (pLogSession->m_bStoppingTrace)) {
        pCmdUI->Enable(FALSE);
    }
}

void CMainFrame::OnStartTrace()
{
    POSITION        pos;
    LONG            index;
    CLogSession    *pLogSession;
    CDisplayDlg    *pDisplayDlg;

    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if(NULL == pLogSession) {
            continue;
        }

        pDisplayDlg = pLogSession->GetDisplayWnd();
        
        ASSERT(pDisplayDlg != NULL);
         
        pDisplayDlg->BeginTrace();
    }

    //
    // Force a redraw of the list control
    //
    m_logSessionDlg.m_displayCtrl.RedrawItems(
                                m_logSessionDlg.m_displayCtrl.GetTopIndex(), 
                                m_logSessionDlg.m_displayCtrl.GetTopIndex() + 
                                    m_logSessionDlg.m_displayCtrl.GetCountPerPage());

    m_logSessionDlg.m_displayCtrl.UpdateWindow();
}

#if 0
void CMainFrame::OnUpdateStartTraceButton(CCmdUI *pCmdUI)
{
    POSITION    pos;
    int         index;
    CLogSession *pLogSession;
    BOOL        bFound = FALSE;

    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() == 0) {
        pCmdUI->Enable(FALSE);
        return;
    }

    pCmdUI->Enable(TRUE);

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
    while(pos != NULL) {
        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);
        if(index >= m_logSessionDlg.m_logSessionArray.GetSize()) {
            break;
        }
        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];
        if(pLogSession != NULL) {
            bFound = TRUE;
            if(pLogSession->m_bTraceActive) {
                pCmdUI->Enable(FALSE);
                break;
            }
        }
    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

    if(!bFound) {
        pCmdUI->Enable(FALSE);
    }
}

void CMainFrame::OnUpdateStopTraceButton(CCmdUI *pCmdUI)
{
    POSITION    pos;
    int         index;
    CLogSession *pLogSession;

    pCmdUI->Enable(FALSE);

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 0) {
        pCmdUI->Enable(TRUE);
        pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
        while(pos != NULL) {
            index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);
            if(index >= m_logSessionDlg.m_logSessionArray.GetSize()) {
                pCmdUI->Enable(FALSE);
                break;
            }
            pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];
            if((pLogSession == NULL) || 
                (!pLogSession->m_bTraceActive) ||
                    (pLogSession->m_bStoppingTrace)) {
                pCmdUI->Enable(FALSE);
                break;
            }
        }
    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

}

void CMainFrame::OnUpdateViewTraceToolBar(CCmdUI *pCmdUI)
{
    pCmdUI->SetCheck((m_wndTraceToolBar.IsWindowVisible()) != 0);
}

void CMainFrame::OnViewTraceToolBar()
{
    //
    // toggle visible state
    //
    m_wndTraceToolBar.ShowWindow((m_wndTraceToolBar.IsWindowVisible()) == 0);
    RecalcLayout();
}
#endif

void CMainFrame::OnStopTrace()
{
    POSITION    pos;
    LONG        index;
    CLogSession *pLogSession;

    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if((pLogSession != NULL) &&
                (pLogSession->m_bTraceActive)) {
            //
            // Stop tracing
            //
            pLogSession->GetDisplayWnd()->EndTrace();
        }
    }
}

void CMainFrame::OnGroupSessions()
{
    POSITION        pos;
    int             index;
    CLogSession    *pLogSession;
    BOOL            bFound = FALSE;
    CLogSession    *pLog = NULL;
    BOOL            bWasActive = FALSE;
    COLORREF        textColor;
    COLORREF        backgroundColor;
    CString         str;
    CDisplayDlg    *pDisplayDlg;
    CPtrArray      *pLogSessionArray;
    CPtrArray      *pGroupArray;
    PGROUP_SESSION_PARAMS   pSessionParams;

    //
    // Can't group one session
    //
    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() == 1) {
        return;
    }

    //
    // Allocate arrays
    //
    pLogSessionArray  = new CPtrArray();

    //
    // Make sure allocation succeeded
    //
    if(NULL == pLogSessionArray) {
        AfxMessageBox(_T("Unable To Group Sessions, Memory Allocation Failure"));
        return;
    }

    pGroupArray = new CPtrArray();

    //
    // Make sure allocation succeeded
    //
    if(NULL == pGroupArray) {
        AfxMessageBox(_T("Unable To Group Sessions, Memory Allocation Failure"));

        delete pLogSessionArray;
        return;
    }

    //
    // Allocate our structure
    //
    pSessionParams = (PGROUP_SESSION_PARAMS)new CHAR[sizeof(GROUP_SESSION_PARAMS)];

    //
    // Make sure allocation succeeded
    //
    if(NULL == pSessionParams) {
        AfxMessageBox(_T("Unable To Group Sessions, Memory Allocation Failure"));

        delete pLogSessionArray;
        delete pGroupArray;
        return;
    }

    //
    // Setup the params struct
    //
    pSessionParams->pGroupArray = pGroupArray;
    pSessionParams->pSessionArray = pLogSessionArray;

    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        pSessionParams->SessionDoneEventArray[ii] = 
                CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Now walk through the selected sessions and put them in an array
    //
    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        //
        // Get the index of the next selected item
        //
        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        //
        // Get the next log session
        //
        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if(pLogSession == NULL) {
            continue;
        }

        //
        // Add the session to the array
        //
        pLogSessionArray->Add(pLogSession);

        //
        // Get the group display dialog for the session
        //
        pDisplayDlg = pLogSession->GetDisplayWnd();

        //
        // Set the state of the groups
        //
        pDisplayDlg->SetState(Grouping);

        //
        // Attempt to Stop the group
        //
        if(pDisplayDlg->EndTrace(pSessionParams->SessionDoneEventArray[pGroupArray->GetSize()])) {
            //
            // If stopped save the pointer to possibly start later
            //
            pGroupArray->Add(pDisplayDlg);
        }
    }

    if(pLogSessionArray->GetSize() > 1) {
        m_pGroupSessionsThread->PostThreadMessage(WM_USER_START_GROUP, (WPARAM)pSessionParams, 0);

        return;
    }

    //
    // Cleanup our allocations
    //
    delete pLogSessionArray;
    delete pGroupArray;

    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        CloseHandle(pSessionParams->SessionDoneEventArray[ii]);
    }

    delete [] pSessionParams;
}

void CMainFrame::OnCompleteGroup(WPARAM wParam, LPARAM lParam)
{
    PGROUP_SESSION_PARAMS   pSessionParams = (PGROUP_SESSION_PARAMS)wParam;
    CPtrArray      *pGroupArray = pSessionParams->pGroupArray;
    CPtrArray      *pLogSessionArray = pSessionParams->pSessionArray;
    CDisplayDlg    *pDisplayDlg = NULL;

    //
    // Group the log sessions in a new group
    //
    m_logSessionDlg.GroupSessions(pLogSessionArray);

    //
    // Now restart any of the groups that we stopped previously
    // that are still around
    //
    while(pGroupArray->GetSize()) {
        //
        // Get the first entry in the array
        //
        pDisplayDlg = (CDisplayDlg *)pGroupArray->GetAt(0);
        pGroupArray->RemoveAt(0);

        //
        // Get the trace display window array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_traceDisplayWndMutex, INFINITE);

        //
        // See if the group still exists and start it back up if so
        //
        for(LONG ii = 0; ii < m_logSessionDlg.m_traceDisplayWndArray.GetSize(); ii++) {
            if(pDisplayDlg == m_logSessionDlg.m_traceDisplayWndArray[ii]) {
                pDisplayDlg->BeginTrace();
            }
        }

        //
        // Release the trace display window array protection
        //
        ReleaseMutex(m_logSessionDlg.m_traceDisplayWndMutex);
    }

    //
    // Cleanup our allocations
    //
    delete pLogSessionArray;
    delete pGroupArray;

    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        CloseHandle(pSessionParams->SessionDoneEventArray[ii]);
    }

    delete [] pSessionParams;
}

void CMainFrame::OnUngroupSessions()
{
    POSITION        pos;
    int             index;
    CLogSession    *pLogSession;
    CString         str;
    CDisplayDlg    *pDisplayDlg;
    BOOL            bWasActive = FALSE;
    CPtrArray      *pLogSessionArray;
    CPtrArray      *pGroupArray;
    PGROUP_SESSION_PARAMS   pSessionParams;

    //
    // Allocate arrays
    //
    pLogSessionArray  = new CPtrArray();

    //
    // Make sure allocation succeeded
    //
    if(NULL == pLogSessionArray) {
        AfxMessageBox(_T("Unable To Group Sessions, Memory Allocation Failure"));
        return;
    }

    pGroupArray = new CPtrArray();

    //
    // Make sure allocation succeeded
    //
    if(NULL == pGroupArray) {
        AfxMessageBox(_T("Unable To Group Sessions, Memory Allocation Failure"));

        delete pLogSessionArray;
        return;
    }

    //
    // Allocate our structure
    //
    pSessionParams = (PGROUP_SESSION_PARAMS)new CHAR[sizeof(GROUP_SESSION_PARAMS)];

    //
    // Make sure allocation succeeded
    //
    if(NULL == pSessionParams) {
        AfxMessageBox(_T("Unable To Group Sessions, Memory Allocation Failure"));

        delete pLogSessionArray;
        delete pGroupArray;
        return;
    }

    //
    // Setup the params struct
    //
    pSessionParams->pGroupArray = pGroupArray;
    pSessionParams->pSessionArray = pLogSessionArray;

    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        pSessionParams->SessionDoneEventArray[ii] = 
                CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Walk selected sessions and check if they are grouped
    //
    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if(pLogSession == NULL) {
            continue;
        }

        //
        // Get the display wnd for the session
        //
        pDisplayDlg = pLogSession->GetDisplayWnd();

        if(NULL == pDisplayDlg) {
            continue;
        }

        //
        // Set the state of the groups
        //
        pDisplayDlg->SetState(UnGrouping);

        //
        // Store each log session in the array
        //
        pLogSessionArray->Add(pLogSession);
       
        //
        // Stop the group, and if stopped store it to possibly be
        // started again later
        //
        if(pDisplayDlg->EndTrace(pSessionParams->SessionDoneEventArray[pGroupArray->GetSize()])) {
            pGroupArray->Add(pDisplayDlg);
        }
    }

    m_pGroupSessionsThread->PostThreadMessage(WM_USER_START_UNGROUP, (WPARAM)pSessionParams, 0);

    return;
}

void CMainFrame::OnCompleteUnGroup(WPARAM wParam, LPARAM lParam)
{
    PGROUP_SESSION_PARAMS   pSessionParams = (PGROUP_SESSION_PARAMS)wParam;
    CPtrArray      *pGroupArray = pSessionParams->pGroupArray;
    CPtrArray      *pLogSessionArray = pSessionParams->pSessionArray;
    CDisplayDlg    *pDisplayDlg = NULL;


    //
    // Group the log sessions in a new group
    //
    m_logSessionDlg.UnGroupSessions(pLogSessionArray);

    //
    // Now restart any of the groups that we stopped previously
    // that are still around
    //
    while(pGroupArray->GetSize()) {
        //
        // Get the first entry in the array
        //
        pDisplayDlg = (CDisplayDlg *)pGroupArray->GetAt(0);
        pGroupArray->RemoveAt(0);

        //
        // Get the trace display window array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_traceDisplayWndMutex, INFINITE);

        //
        // See if the group still exists and start it back up if so
        //
        for(LONG ii = 0; ii < m_logSessionDlg.m_traceDisplayWndArray.GetSize(); ii++) {
            if(pDisplayDlg == m_logSessionDlg.m_traceDisplayWndArray[ii]) {
                pDisplayDlg->BeginTrace();
            }
        }

        //
        // Release the trace display window array protection
        //
        ReleaseMutex(m_logSessionDlg.m_traceDisplayWndMutex);
    }

    //
    // Cleanup our allocations
    //
    delete pLogSessionArray;
    delete pGroupArray;

    for(LONG ii = 0; ii < MAX_LOG_SESSIONS; ii++) {
        CloseHandle(pSessionParams->SessionDoneEventArray[ii]);
    }

    delete [] pSessionParams;
}

void CMainFrame::OnRemoveLogSession()
{
    m_logSessionDlg.RemoveSelectedLogSessions();
}

void CMainFrame::OnUpdateUIGroupSessions(CCmdUI *pCmdUI)
{
    POSITION        pos;
    int             index;
    CLogSession    *pLogSession;
    CString         str;
    OSVERSIONINFO   osVersion;
    BOOL            bOpenExisting = FALSE;
    BOOL            bActiveTracing = FALSE;
    BOOL            bDifferentGroups = FALSE;
    LONG            groupNumber = -1;

    //
    // Default to enabled
    //
    pCmdUI->Enable(TRUE);

    //
    // disable the group option if there are not multiple groups
    //
    if(m_logSessionDlg.m_traceDisplayWndArray.GetSize() == 1) {
        pCmdUI->Enable(FALSE);
        return;
    }

    //
    // disable the group option if multiple sessions are not
    // selected
    //
    if(0 == m_logSessionDlg.m_displayCtrl.GetSelectedCount()) {
        pCmdUI->Enable(FALSE);
        return;
    }

    //
    // Make sure all selected sessions are of the same
    // type, that is active tracing or open exisiting logfile.
    //
    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if(pLogSession != NULL) {
            //
            // If any session is not grouped, in the process of stopping,
            // or in the process of grouping or ungrouping already,
            // don't allow ungrouping
            //
            if((pLogSession->m_bStoppingTrace) ||
                    (pLogSession->m_bGroupingTrace)) {
                pCmdUI->Enable(FALSE);
                return;
            }

            //
            // Check the group numbers
            //
            if(groupNumber == -1) {
                groupNumber = pLogSession->GetGroupID();
            }

            if(groupNumber != pLogSession->GetGroupID()) {
                bDifferentGroups = TRUE;
            }

            if(pLogSession->m_bDisplayExistingLogFileOnly) {
                //
                // Opened an existing log file
                //
                bOpenExisting = TRUE;
            } else {
                //
                // Active tracing sessions can only be 
                // grouped on .Net and later, so we need to check
                // the OS version.  .Net: Major = 5 Minor = 2.
                //

                //
                // call GetVersionEx using the OSVERSIONINFO structure,
                //
                ZeroMemory(&osVersion, sizeof(OSVERSIONINFO));
                osVersion.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

                if(GetVersionEx((OSVERSIONINFO *)&osVersion)) {
                    //
                    // Make sure we are on .NET or later to group
                    // real-time sessions
                    //
                    if(osVersion.dwMajorVersion < 5) {
                        pCmdUI->Enable(FALSE);
                        return;
                    }
                    if(osVersion.dwMinorVersion < 2) {
                        pCmdUI->Enable(FALSE);
                        return;
                    }
                }

                bActiveTracing = TRUE;
            }
        }
    }

    //
    // Make sure there are multiple groups represented
    //
    if(!bDifferentGroups) {
        pCmdUI->Enable(FALSE);
        return;
    }

    //
    // Make sure that the log session types aren't mixed
    //
    if(bActiveTracing && bOpenExisting) {
        pCmdUI->Enable(FALSE);
        return;
    }
}


void CMainFrame::OnUpdateUngroupSessions(CCmdUI *pCmdUI)
{
    POSITION        pos;
    int             index;
    CLogSession    *pLogSession;
    CString         str;

    //
    // Default to enabled
    //
    pCmdUI->Enable(TRUE);

    //
    // Walk selected sessions and check if they are grouped
    //
    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if(pLogSession == NULL) {
            continue;
        }

        //
        // If any session is not grouped, in the process of stopping,
        // or in the process of grouping or ungrouping already,
        // don't allow ungrouping
        //
        if((pLogSession->GetDisplayWnd()->m_sessionArray.GetSize() == 1) ||
                (pLogSession->m_bStoppingTrace) ||
                (pLogSession->m_bGroupingTrace)) {
            pCmdUI->Enable(FALSE);
            return;
        }
    }
}

void CMainFrame::OnUpdateUIStartTrace(CCmdUI *pCmdUI)
{
    POSITION    pos;
    int         index;
    CLogSession *pLogSession;
    BOOL        bFound = FALSE;

    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() != 1) {
            pCmdUI->Enable(FALSE);
            return;
    }

    pCmdUI->Enable(TRUE);

    pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
    while(pos != NULL) {
        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        if(pLogSession != NULL) {
            bFound = TRUE;
            if((pLogSession->m_bTraceActive) || (pLogSession->m_bDisplayExistingLogFileOnly)) {
                pCmdUI->Enable(FALSE);
                break;
            }
        }
    }
    if(!bFound) {
        pCmdUI->Enable(FALSE);
    }
}

void CMainFrame::OnUpdateUIStopTrace(CCmdUI *pCmdUI)
{
    POSITION    pos;
    int         index;
    CLogSession *pLogSession;

    pCmdUI->Enable(FALSE);

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

    //
    // Don't allow stop if more than one session is selected
    //
    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 1) {
        pCmdUI->Enable(FALSE);

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        return;
    }

    
    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 0) {

        //
        // Default to enabling the stop option
        //
        pCmdUI->Enable(TRUE);

        pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

        index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

        if(index >= m_logSessionDlg.m_logSessionArray.GetSize()) {
            //
            // Release the log session array protection
            //
            ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

            pCmdUI->Enable(FALSE);

            return;
        }

        pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);

        //
        // If no session is found, disable the stop option
        //
        // If the session is not active, is already being stopped,
        // or is for an existing logfile then disable the 
        // stop option.
        //
        // Don't allow stop if the session was started outside of
        // traceview.  We determine this by whether a valid handle
        // was obtained for the session.
        //
        if((pLogSession == NULL) || 
            (!pLogSession->m_bTraceActive) ||
            (pLogSession->m_bStoppingTrace) ||
            (pLogSession->m_bDisplayExistingLogFileOnly) ||
            (pLogSession->GetSessionHandle() == (TRACEHANDLE)INVALID_HANDLE_VALUE)) {
            pCmdUI->Enable(FALSE);
        }
    }
}

void CMainFrame::OnUpdateUIOpenExisting(CCmdUI *pCmdUI)
{
    //
    // placeholder
    //
}

void CMainFrame::OnOpenExisting()
{
    CLogSession    *pLogSession = NULL;
    CString         str;
    LONG            newDisplayFlags = 0;
    LONG            newColumnDisplayFlags;
    LONG            logSessionDisplayFlags;
    CDisplayDlg    *pDisplayDlg;
    DWORD           extendedStyles;
    INT_PTR         retVal;
    CLogSession    *pLog;
    BOOL            bNoID;
    LONG            logSessionID = 0;
    CString         extension;
    CString         traceDirectory;
    LONG            traceSessionID = 0;



    //
    // Get a unique ID for the session
    //
    logSessionID = m_logSessionDlg.GetLogSessionID();

    //
    // Create an instance of the logsession class
    //
    pLogSession = new CLogSession(logSessionID, &m_logSessionDlg);
    if(NULL == pLogSession) {
        AfxMessageBox(_T("Unable To Create Log Session"));
        return;
    }

    //
    // Indicate the log session is not tracing real time
    //
    pLogSession->m_bRealTime = FALSE;

    //
    // Indicate the log session is only displaying an existing log session
    //
    pLogSession->m_bDisplayExistingLogFileOnly = TRUE;

    //
    // Clear the log file name so the user has to select
    //
    pLogSession->m_logFileName.Empty();

    //
    // pop-up our wizard/tab dialog to show/get properties
    //
    CLogFileDlg *pDialog = new CLogFileDlg(this, pLogSession);
    if(NULL == pDialog) {
        AfxMessageBox(_T("Failed To Create Log File Session, Resource Error"));
        
        m_logSessionDlg.RemoveSession(pLogSession);

        delete pLogSession;

        return;
    }
    
    retVal = pDialog->DoModal();

    if(IDOK != retVal) {
        if(IDCANCEL != retVal) {
            AfxMessageBox(_T("Failed To Get Log File Properties"));
        }
        m_logSessionDlg.RemoveSession(pLogSession);

        delete pDialog;

        delete pLogSession;

        return;
    }
    
    CTraceSession *pTraceSession = new CTraceSession(0);
    if(NULL == pTraceSession) {
        AfxMessageBox(_T("Failed To Process Log File"));
        m_logSessionDlg.RemoveSession(pLogSession);

        delete pDialog;

        delete pLogSession;

        return;
    }

    //
    // put the default trace session in the list
    //
    pLogSession->m_traceSessionArray.Add(pTraceSession);

    //
    // Now get the format info, prompt user for PDB or TMF
    //
    CProviderFormatSelectionDlg *pFormatDialog = new CProviderFormatSelectionDlg(this, pTraceSession);

    if(NULL == pFormatDialog) {
        AfxMessageBox(_T("Failed To Process Log File"));
        m_logSessionDlg.RemoveSession(pLogSession);

        delete pDialog;

        delete pLogSession;

        return;
    }
    
    if(IDOK != pFormatDialog->DoModal()) {
        delete pFormatDialog;
        m_logSessionDlg.RemoveSession(pLogSession);

        delete pDialog;

        delete pLogSession;

        return;
    }

    delete pFormatDialog;

    //
    // Now add the log session to the log session list
    //
    m_logSessionDlg.AddSession(pLogSession);

    //
    // Get the display dialog
    //
    pDisplayDlg = pLogSession->GetDisplayWnd();

    //
    // Get the listing file name if selected from dialog
    //
    if(pDisplayDlg->m_bWriteListingFile = pDialog->m_bWriteListingFile) {
        pDisplayDlg->m_listingFileName = pDialog->m_listingFileName;
    }

    //
    // Get the summary file name if selected from dialog
    //
    if(pDisplayDlg->m_bWriteSummaryFile = pDialog->m_bWriteSummaryFile) {
        pDisplayDlg->m_summaryFileName = pDialog->m_summaryFileName;
    }

    delete pDialog;


    //
    // Now trace the contents of the logfile
    //
    pDisplayDlg->BeginTrace();

    //
    // Force a redraw of the list control
    //
    m_logSessionDlg.m_displayCtrl.RedrawItems(
                                m_logSessionDlg.m_displayCtrl.GetTopIndex(), 
                                m_logSessionDlg.m_displayCtrl.GetTopIndex() + 
                                    m_logSessionDlg.m_displayCtrl.GetCountPerPage());

    m_logSessionDlg.m_displayCtrl.UpdateWindow();
}

void CMainFrame::OnStateColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_STATE) {
        flags &= ~LOGSESSION_DISPLAY_STATE;
    } else {
        flags |= LOGSESSION_DISPLAY_STATE;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnEventCountColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_EVENTCOUNT) {
        flags &= ~LOGSESSION_DISPLAY_EVENTCOUNT;
    } else {
        flags |= LOGSESSION_DISPLAY_EVENTCOUNT;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnLostEventsColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_LOSTEVENTS) {
        flags &= ~LOGSESSION_DISPLAY_LOSTEVENTS;
    } else {
        flags |= LOGSESSION_DISPLAY_LOSTEVENTS;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnBuffersReadColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_BUFFERSREAD) {
        flags &= ~LOGSESSION_DISPLAY_BUFFERSREAD;
    } else {
        flags |= LOGSESSION_DISPLAY_BUFFERSREAD;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateStateColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_STATE) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnUpdateEventCountColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_EVENTCOUNT) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnUpdateLostEventsColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_LOSTEVENTS) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnUpdateBuffersReadColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_BUFFERSREAD) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnFlagsColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_FLAGS) {
        flags &= ~LOGSESSION_DISPLAY_FLAGS;
    } else {
        flags |= LOGSESSION_DISPLAY_FLAGS;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateFlagsColumnDisplay(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_FLAGS) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnFlushTimeColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_FLUSHTIME) {
        flags &= ~LOGSESSION_DISPLAY_FLUSHTIME;
    } else {
        flags |= LOGSESSION_DISPLAY_FLUSHTIME;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateFlushTimeColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_FLUSHTIME) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnMaxBuffersColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_MAXBUF) {
        flags &= ~LOGSESSION_DISPLAY_MAXBUF;
    } else {
        flags |= LOGSESSION_DISPLAY_MAXBUF;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateMaxBuffersColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_MAXBUF) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnMinBuffersColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_MINBUF) {
        flags &= ~LOGSESSION_DISPLAY_MINBUF;
    } else {
        flags |= LOGSESSION_DISPLAY_MINBUF;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateMinBuffersColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_MINBUF) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnBufferSizeColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_BUFFERSIZE) {
        flags &= ~LOGSESSION_DISPLAY_BUFFERSIZE;
    } else {
        flags |= LOGSESSION_DISPLAY_BUFFERSIZE;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateBufferSizeColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_BUFFERSIZE) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnDecayTimeColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_DECAYTIME) {
        flags &= ~LOGSESSION_DISPLAY_DECAYTIME;
    } else {
        flags |= LOGSESSION_DISPLAY_DECAYTIME;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateDecayTimeColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_DECAYTIME) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnCircularColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_CIR) {
        flags &= ~LOGSESSION_DISPLAY_CIR;
    } else {
        flags |= LOGSESSION_DISPLAY_CIR;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateCircularColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_CIR) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnSequentialColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_SEQ) {
        flags &= ~LOGSESSION_DISPLAY_SEQ;
    } else {
        flags |= LOGSESSION_DISPLAY_SEQ;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateSequentialColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_SEQ) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnNewFileColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_NEWFILE) {
        flags &= ~LOGSESSION_DISPLAY_NEWFILE;
    } else {
        flags |= LOGSESSION_DISPLAY_NEWFILE;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateNewFileColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_NEWFILE) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnGlobalSeqColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_GLOBALSEQ) {
        flags &= ~LOGSESSION_DISPLAY_GLOBALSEQ;
    } else {
        flags |= LOGSESSION_DISPLAY_GLOBALSEQ;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateGlobalSeqColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_GLOBALSEQ) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnLocalSeqColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_LOCALSEQ) {
        flags &= ~LOGSESSION_DISPLAY_LOCALSEQ;
    } else {
        flags |= LOGSESSION_DISPLAY_LOCALSEQ;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateLocalSeqColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_LOCALSEQ) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnLevelColumnDisplayCheck()
{
    LONG flags;

    flags = m_logSessionDlg.GetDisplayFlags();

    if(flags & LOGSESSION_DISPLAY_LEVEL) {
        flags &= ~LOGSESSION_DISPLAY_LEVEL;
    } else {
        flags |= LOGSESSION_DISPLAY_LEVEL;
    }

    m_logSessionDlg.SetDisplayFlags(flags);
}

void CMainFrame::OnUpdateLevelColumnDisplayCheck(CCmdUI *pCmdUI)
{
    if(m_logSessionDlg.GetDisplayFlags() & LOGSESSION_DISPLAY_LEVEL) {
        pCmdUI->SetCheck(TRUE);
    } else {
        pCmdUI->SetCheck(FALSE);
    }
}

void CMainFrame::OnUpdateRemoveTrace(CCmdUI *pCmdUI)
{
    POSITION        pos;
    int             index;
    CLogSession    *pLogSession;

    pCmdUI->Enable(FALSE);

    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 1) {
        return;
    }

    //
    // Get the log session array protection
    //
    WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 0) {
        pCmdUI->Enable(TRUE);
        pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();
        while(pos != NULL) {
            index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);
            if(index >= m_logSessionDlg.m_logSessionArray.GetSize()) {
                pCmdUI->Enable(FALSE);
                break;
            }

            pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];
            if((pLogSession == NULL) || 
                    pLogSession->m_bTraceActive ||
                    pLogSession->m_bStoppingTrace ||
                    pLogSession->m_bGroupingTrace || 
                    (pLogSession->GetDisplayWnd()->m_sessionArray.GetSize() > 1)) {
                pCmdUI->Enable(FALSE);
                break;
            }
        }
    }

    //
    // Release the log session array protection
    //
    ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);
}

void CMainFrame::OnLogSessionDisplayOptions()
{
    //
    // Just here to enable the menu item, nothing to do
    //
}

void CMainFrame::OnChangeTextColor()
{
    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 0) {

        CColorDialog    colorDlg(0, 0, this);
        COLORREF        color;
        POSITION        pos;
        int             index;
        CLogSession    *pLogSession;

        if(IDOK == colorDlg.DoModal()) {
            color = colorDlg.GetColor();              
        }

        pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        while(pos != NULL) {

            index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

            if(index >= m_logSessionDlg.m_logSessionArray.GetSize()) {
                break;
            }

            pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];
            if(pLogSession != NULL) {
                pLogSession->m_titleTextColor = color;

                m_logSessionDlg.m_displayCtrl.RedrawItems(
                                            m_logSessionDlg.m_displayCtrl.GetTopIndex(), 
                                            m_logSessionDlg.m_displayCtrl.GetTopIndex() + 
                                                m_logSessionDlg.m_displayCtrl.GetCountPerPage());

                m_logSessionDlg.m_displayCtrl.UpdateWindow();
            }
        }
        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);
    }
}

void CMainFrame::OnChangeBackgroundColor()
{
    if(m_logSessionDlg.m_displayCtrl.GetSelectedCount() > 0) {

        CColorDialog    colorDlg(0, 0, this);
        COLORREF        color;
        POSITION        pos;
        int             index;
        CLogSession    *pLogSession;

        if(IDOK == colorDlg.DoModal()) {
            color = colorDlg.GetColor();              
        }

        pos = m_logSessionDlg.m_displayCtrl.GetFirstSelectedItemPosition();

        //
        // Get the log session array protection
        //
        WaitForSingleObject(m_logSessionDlg.m_logSessionArrayMutex, INFINITE);

        while(pos != NULL) {

            index = m_logSessionDlg.m_displayCtrl.GetNextSelectedItem(pos);

            if(index >= m_logSessionDlg.m_logSessionArray.GetSize()) {
                break;
            }

            pLogSession = (CLogSession *)m_logSessionDlg.m_logSessionArray[index];
            if(pLogSession != NULL) {
                pLogSession->m_titleBackgroundColor = color;

                m_logSessionDlg.m_displayCtrl.RedrawItems(
                                            m_logSessionDlg.m_displayCtrl.GetTopIndex(), 
                                            m_logSessionDlg.m_displayCtrl.GetTopIndex() + 
                                                m_logSessionDlg.m_displayCtrl.GetCountPerPage());

                m_logSessionDlg.m_displayCtrl.UpdateWindow();
            }
        }

        //
        // Release the log session array protection
        //
        ReleaseMutex(m_logSessionDlg.m_logSessionArrayMutex);
    }
}

void CMainFrame::OnUpdateChangeTextColor(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(FALSE);
}

void CMainFrame::OnUpdateChangeBackgroundColor(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(FALSE);
}

void CMainFrame::OnUpdateLogSessionList(WPARAM wParam, LPARAM lParam)
{
    m_logSessionDlg.m_displayCtrl.RedrawItems(
                                m_logSessionDlg.m_displayCtrl.GetTopIndex(), 
                                m_logSessionDlg.m_displayCtrl.GetTopIndex() + 
                                    m_logSessionDlg.m_displayCtrl.GetCountPerPage());

    m_logSessionDlg.m_displayCtrl.UpdateWindow();
}

void CMainFrame::OnSetTmax()
{
    // TODO: Add your command handler code here
    CMaxTraceDlg dlg;

    dlg.DoModal();

    MaxTraceEntries = dlg.m_MaxTraceEntries;
}

void CMainFrame::OnUpdateSetTmax(CCmdUI *pCmdUI)
{
    // TODO: Add your command update UI handler code here
    pCmdUI->Enable();

    if( m_logSessionDlg.m_logSessionArray.GetSize() ) {
        pCmdUI->Enable(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\mainfrm.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// MainFrm.h : interface of the CMainFrame class
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "ChildView.h"

//
// Our CWinThread derived class used for the 
// user interface thread to offload some of the
// grouping and ungrouping work from the main
// user interface thread
//
class CGroupSession : public CWinThread
{
public:
    DECLARE_DYNCREATE(CGroupSession)

    virtual int ExitInstance();
    virtual BOOL InitInstance();

    void OnGroupSession(WPARAM wParam, LPARAM lParam);
    void OnUnGroupSession(WPARAM wParam, LPARAM lParam);

    HWND    m_hMainWnd;
    HANDLE  m_hEventArray[MAX_LOG_SESSIONS];

    DECLARE_MESSAGE_MAP()
};

class CMainFrame : public CFrameWnd
{
	friend CGroupSession;

public:
	CMainFrame();
protected: 
	DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	virtual ~CMainFrame();

    void AddModifyLogSession(CLogSession *pLogSession = NULL);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar          m_wndStatusBar;
	CToolBar            m_wndToolBar;
    CToolBar            m_wndTraceToolBar;
    CLogSessionDlg      m_logSessionDlg;
    CDockDialogBar      m_wndLogSessionListBar;
    CChildView          m_wndView;
	CPropertyPage		m_logSessionSetup;
    CGroupSession      *m_pGroupSessionsThread;


// Generated message map functions
protected:
    void DockControlBarLeftOf(CToolBar* Bar, CToolBar* LeftOf);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	DECLARE_MESSAGE_MAP()
public:
    static UINT GroupSessionsThread(LPVOID  pParam);

    afx_msg void OnFileNewLogSession();
    afx_msg void OnCreateNewLogSession();
    afx_msg void OnProperties();
    afx_msg void OnUpdateProperties(CCmdUI *pCmdUI);
    afx_msg void OnStartTrace();
    afx_msg void OnUpdateStartTraceButton(CCmdUI *pCmdUI);
    afx_msg void OnStopTrace();
    afx_msg void OnUpdateStopTraceButton(CCmdUI *pCmdUI);
    afx_msg void OnOpenExisting();
    afx_msg void OnUpdateViewTraceToolBar(CCmdUI *pCmdUI);
    afx_msg void OnViewTraceToolBar();
    afx_msg void OnGroupSessions();
    afx_msg void OnUngroupSessions();
    afx_msg void OnRemoveLogSession();
    afx_msg void OnUpdateUIGroupSessions(CCmdUI *pCmdUI);
    afx_msg void OnUpdateUngroupSessions(CCmdUI *pCmdUI);
    afx_msg void OnUpdateUIStartTrace(CCmdUI *pCmdUI);
    afx_msg void OnUpdateUIStopTrace(CCmdUI *pCmdUI);
    afx_msg void OnUpdateUIOpenExisting(CCmdUI *pCmdUI);
    afx_msg void OnFlagsColumnDisplayCheck();
    afx_msg void OnUpdateFlagsColumnDisplay(CCmdUI *pCmdUI);
    afx_msg void OnFlushTimeColumnDisplayCheck();
    afx_msg void OnUpdateFlushTimeColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnMaxBuffersColumnDisplayCheck();
    afx_msg void OnUpdateMaxBuffersColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnMinBuffersColumnDisplayCheck();
    afx_msg void OnUpdateMinBuffersColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnBufferSizeColumnDisplayCheck();
    afx_msg void OnUpdateBufferSizeColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnDecayTimeColumnDisplayCheck();
    afx_msg void OnUpdateDecayTimeColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnCircularColumnDisplayCheck();
    afx_msg void OnUpdateCircularColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnSequentialColumnDisplayCheck();
    afx_msg void OnUpdateSequentialColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnNewFileColumnDisplayCheck();
    afx_msg void OnUpdateNewFileColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnGlobalSeqColumnDisplayCheck();
    afx_msg void OnUpdateGlobalSeqColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnLocalSeqColumnDisplayCheck();
    afx_msg void OnUpdateLocalSeqColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnLevelColumnDisplayCheck();
    afx_msg void OnUpdateLevelColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnUpdateRemoveTrace(CCmdUI *pCmdUI);
    afx_msg void OnStateColumnDisplayCheck();
    afx_msg void OnEventCountColumnDisplayCheck();
    afx_msg void OnLostEventsColumnDisplayCheck();
    afx_msg void OnBuffersReadColumnDisplayCheck();
    afx_msg void OnUpdateStateColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnUpdateEventCountColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnUpdateLostEventsColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnUpdateBuffersReadColumnDisplayCheck(CCmdUI *pCmdUI);
    afx_msg void OnLogSessionDisplayOptions();
    afx_msg void OnChangeTextColor();
    afx_msg void OnChangeBackgroundColor();
    afx_msg void OnUpdateChangeTextColor(CCmdUI *pCmdUI);
    afx_msg void OnUpdateChangeBackgroundColor(CCmdUI *pCmdUI);
    afx_msg void OnUpdateLogSessionList(WPARAM wParam, LPARAM lParam);
    afx_msg void OnCompleteGroup(WPARAM wParam, LPARAM lParam);
    afx_msg void OnCompleteUnGroup(WPARAM wParam, LPARAM lParam);
    afx_msg void OnTraceDone(WPARAM wParam, LPARAM lParam);

    HANDLE m_hEndTraceEvent;
	afx_msg void OnSetTmax();
	afx_msg void OnUpdateSetTmax(CCmdUI *pCmdUI);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\maxtracedlg.h ===
#pragma once


// CMaxTraceDlg dialog

class CMaxTraceDlg : public CDialog
{
	DECLARE_DYNAMIC(CMaxTraceDlg)

public:
	CMaxTraceDlg(CWnd* pParent = NULL);   // standard constructor
	virtual ~CMaxTraceDlg();

// Dialog Data
	enum { IDD = IDD_MAX_TRACE };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
	LONG m_MaxTraceEntries;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\maxtracedlg.cpp ===
// MaxTraceDlg.cpp : implementation file
//

#include "stdafx.h"

#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "ProviderFormatInfo.h"
#include "ProviderFormatSelectionDlg.h"
#include "ListCtrlEx.h"
#include "LogSessionDlg.h"
#include "LogDisplayOptionDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "LogSessionOutputOptionDlg.h"
#include "DockDialogBar.h"
#include "LogFileDlg.h"
#include "Utils.h"
#include "MainFrm.h"
#include "ProviderControlGUIDDlg.h"


#include "MaxTraceDlg.h"

extern LONG MaxTraceEntries;

// CMaxTraceDlg dialog

IMPLEMENT_DYNAMIC(CMaxTraceDlg, CDialog)
CMaxTraceDlg::CMaxTraceDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMaxTraceDlg::IDD, pParent)
	, m_MaxTraceEntries(0)
{
	m_MaxTraceEntries = MaxTraceEntries;
}

CMaxTraceDlg::~CMaxTraceDlg()
{
}

void CMaxTraceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_MAX_TRACE, m_MaxTraceEntries);
	DDV_MinMaxUInt(pDX, m_MaxTraceEntries, 100, 500000);
}


BEGIN_MESSAGE_MAP(CMaxTraceDlg, CDialog)
END_MESSAGE_MAP()


// CMaxTraceDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\pathdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// PathDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <direct.h>
#include <dlgs.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "PathDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPathDlg

IMPLEMENT_DYNAMIC(CPathDlg, CFileDialog)

CPathDlg::CPathDlg(BOOL     bOpenFileDialog, 
                   LPCTSTR  lpszDefExt, 
                   LPCTSTR  lpszFileName,
		           DWORD    dwFlags, 
                   LPCTSTR  lpszFilter, 
                   CWnd    *pParentWnd) :
		CFileDialog(bOpenFileDialog, 
                    lpszDefExt, 
                    lpszFileName, 
			        dwFlags |= OFN_ENABLETEMPLATE, 
                    lpszFilter, 
                    pParentWnd)
{
	m_ofn.hInstance = AfxGetResourceHandle();
	m_ofn.lpTemplateName = MAKEINTRESOURCE(CPathDlg::IDD);

	m_ofn.Flags &= ~OFN_EXPLORER;

	//{{AFX_DATA_INIT(CPathDlg)
	//}}AFX_DATA_INIT
}

void CPathDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPathDlg)
	DDX_Control(pDX, IDC_PATH_NAME_EDIT, m_PathName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPathDlg, CFileDialog)
	//{{AFX_MSG_MAP(CPathDlg)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CPathDlg::OnInitDialog() 
{
	CString str;

	CenterWindow();

	GetDlgItem(stc2)->ShowWindow(SW_HIDE);
	GetDlgItem(stc3)->ShowWindow(SW_HIDE);
	GetDlgItem(edt1)->ShowWindow(SW_HIDE);
	GetDlgItem(lst1)->ShowWindow(SW_HIDE);
	GetDlgItem(cmb1)->ShowWindow(SW_HIDE);
	GetDlgItem(stc1)->ShowWindow(SW_HIDE);
	GetDlgItem(chx1)->ShowWindow(SW_HIDE);
	GetDlgItem(psh15)->EnableWindow(FALSE);

	SetDlgItemText(edt1,_T("Junk"));

    //
	// Need to fill in edit control(IDC_PATH_NAME_EDIT)
    //
	
	CListBox* pList = (CListBox*)GetDlgItem(lst2);
	int iIndex = pList->GetCurSel();

	m_pathName.Empty();
	
	if(iIndex != LB_ERR) {
		pList->GetText(iIndex, str);

		for(int i = 0; i <= iIndex; i++) {
			pList->GetText(i, str);

			if(i > 1) {
				m_pathName += "\\";
				m_pathName += str;
            } else {
				m_pathName += str;
            }
		}

		m_pathName.MakeUpper();
		
        ((CEdit *)GetDlgItem(IDC_PATH_NAME_EDIT))->SetWindowText(m_pathName);
	}

	GetDlgItem(lst2)->SetFocus();

	m_bFirstTime = TRUE;

	CFileDialog::OnInitDialog();
	
    //
    // return FALSE to set the focus to a control
    //
	return FALSE;  
}

void CPathDlg::OnPaint() 
{
    //
    // device context for painting
    //
	CPaintDC dc(this); 
	
	if (m_bFirstTime) {
		m_bFirstTime = FALSE;
		SendDlgItemMessage(lst2, LB_SETCURSEL, 0, 0L);
	}
	
    //
	// Do not call CFileDialog::OnPaint() for painting messages
    //
}

void CPathDlg::OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode)
{
	CString str;
	int i;

	CListBox* pList = (CListBox*)GetDlgItem(lst2);

	int iIndex = pList->GetCurSel();

	m_pathName.Empty();
	
	if (iIndex != LB_ERR) {
		pList->GetText(iIndex, str);

		for (i = 0; i <= iIndex; i++) {
			pList->GetText(i, str);

			if (i > 1) {
				m_pathName += "\\";
				m_pathName += str;
            } else {
                m_pathName += str;
            }
		}
		
		((CEdit*)GetDlgItem(IDC_PATH_NAME_EDIT))->SetWindowText(m_pathName);
	}

}

BOOL CPathDlg::OnFileNameOK(void)
{
	CString drive;
	CString str;
	int		retVal;

	m_PathName.GetWindowText(m_pathName);

	drive = m_pathName.Left(3);

	retVal = m_pathName.FindOneOf(_T("*?|/<>\""));

	if (retVal >= 0) {
		str.Format(_T("%s is not a valid pathname."), m_pathName);
		AfxMessageBox(str);
		return TRUE;
	}
	
	if (_tchdir(m_pathName)) {
		str.Format(_T("Directory %s does not exist."), m_pathName);
        AfxMessageBox(str);
		return TRUE;
    }

	TCHAR buffer[MAX_PATH];
	
	str = m_pathName + "\\" + m_ofn.lpstrFileTitle;

	_tcscpy(buffer, str);

	_tcscpy(m_ofn.lpstrFile, buffer);

	m_pofnTemp->nFileOffset = m_pathName.GetLength() + 1;
	m_pofnTemp->nFileExtension = (WORD)str.GetLength();
		
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providercontrolguiddlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderControlGuidDlg.h : interface of the CProviderControlGuidDlg class
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "afxwin.h"


// CProviderControlGuidDlg dialog

class CProviderControlGuidDlg : public CDialog
{
	DECLARE_DYNAMIC(CProviderControlGuidDlg)

public:
	CProviderControlGuidDlg(CWnd* pParent, CTraceSession *pTraceSession);
	virtual ~CProviderControlGuidDlg();
	int OnInitDialog();

// Dialog Data
	enum { IDD = IDD_PROVIDER_CONTROL_GUID_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedCtlBrowseButton();
    afx_msg void OnBnClickedPdbSelectRadio();
    afx_msg void OnBnClickedCtlSelectRadio();
    afx_msg void OnBnClickedManualSelectRadio();
    afx_msg void OnBnClickedOk();
	afx_msg void OnBnClickedPdbBrowseButton();
    afx_msg void OnBnClickedKernelLoggerSelectRadio();

	CEdit           m_pdbFileName;
	CEdit           m_ctlFileName;
	CEdit           m_controlGuidName;
    CTraceSession  *m_pTraceSession;
    BOOL            m_bProcess;
    BOOL            m_bThread;
    BOOL            m_bDisk;
    BOOL            m_bNet;
    BOOL            m_bFileIO;
    BOOL            m_bPageFault;
    BOOL            m_bHardFault;
    BOOL            m_bImageLoad;
    BOOL            m_bRegistry;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providercontrolguiddlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderControlGUIDDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "utils.h"
#include "ProviderControlGUIDDlg.h"


// CProviderControlGuidDlg dialog

IMPLEMENT_DYNAMIC(CProviderControlGuidDlg, CDialog)
CProviderControlGuidDlg::CProviderControlGuidDlg(CWnd* pParent, CTraceSession *pTraceSession)
    : CDialog(CProviderControlGuidDlg::IDD, pParent)
{
    m_pTraceSession = pTraceSession;
}

CProviderControlGuidDlg::~CProviderControlGuidDlg()
{
}

int CProviderControlGuidDlg::OnInitDialog()
{
    int ret;

    ret = CDialog::OnInitDialog();

    //
    // Default to the PDB radio button being selected
    //
    CheckRadioButton(IDC_PDB_SELECT_RADIO,
                     IDC_MANUAL_SELECT_RADIO,
                     IDC_PDB_SELECT_RADIO);

    //
    // Enable PDB edit box and browse button
    //
    m_pdbFileName.EnableWindow(TRUE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(TRUE);

    //
    // Disable all controls associated with other radio buttons
    //
	m_ctlFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_CTL_BROWSE_BUTTON)->EnableWindow(FALSE);
	m_controlGuidName.EnableWindow(FALSE);
    GetDlgItem(IDC_PROCESS_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_THREAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_NET_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_DISK_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_PAGEFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_HARDFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_IMAGELOAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_REGISTRY_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_FILEIO_CHECK)->EnableWindow(FALSE);

    return ret;
}

void CProviderControlGuidDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_PDB_FILE_EDIT, m_pdbFileName);
    DDX_Control(pDX, IDC_CTL_FILE_EDIT, m_ctlFileName);
    DDX_Control(pDX, IDC_MANUAL_GUID_EDIT, m_controlGuidName);
}


BEGIN_MESSAGE_MAP(CProviderControlGuidDlg, CDialog)
    ON_BN_CLICKED(IDC_PDB_BROWSE_BUTTON, OnBnClickedPdbBrowseButton)
    ON_BN_CLICKED(IDC_CTL_BROWSE_BUTTON, OnBnClickedCtlBrowseButton)
    ON_BN_CLICKED(IDC_PDB_SELECT_RADIO, OnBnClickedPdbSelectRadio)
    ON_BN_CLICKED(IDC_CTL_SELECT_RADIO, OnBnClickedCtlSelectRadio)
    ON_BN_CLICKED(IDC_MANUAL_SELECT_RADIO, OnBnClickedManualSelectRadio)
    ON_BN_CLICKED(IDOK, OnBnClickedOk)
    ON_BN_CLICKED(IDC_KERNEL_LOGGER_SELECT_RADIO, OnBnClickedKernelLoggerSelectRadio)
END_MESSAGE_MAP()


// CProviderControlGuidDlg message handlers

void CProviderControlGuidDlg::OnBnClickedPdbBrowseButton()
{
	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE, 
                       _T("pdb"),_T("*.pdb"),
				        OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_READONLY |
                            OFN_HIDEREADONLY | OFN_EXPLORER | OFN_NOCHANGEDIR,
				       _T("Program Database Files (*.pdb)|*.pdb||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name and display it
	//
    if(!fileDlg.GetPathName().IsEmpty()) {
        m_pdbFileName.SetWindowText(fileDlg.GetPathName());
        m_pdbFileName.SetFocus();
    }
}

void CProviderControlGuidDlg::OnBnClickedCtlBrowseButton()
{
	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE, 
                       _T("ctl"),_T("*.ctl"),
				        OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_READONLY |
                            OFN_HIDEREADONLY | OFN_EXPLORER | OFN_NOCHANGEDIR, 
				       _T("Control GUID Files (*.ctl)|*.ctl|All Files (*.*)|*.*||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name and display it
	//
    if(!fileDlg.GetPathName().IsEmpty()) {
        m_ctlFileName.SetWindowText(fileDlg.GetPathName());
        m_ctlFileName.SetFocus();
    }
}

void CProviderControlGuidDlg::OnBnClickedPdbSelectRadio()
{
    //
    // Set the PDB radio button and unset the rest
    //
    CheckRadioButton(IDC_PDB_SELECT_RADIO,
                     IDC_KERNEL_LOGGER_SELECT_RADIO,
                     IDC_PDB_SELECT_RADIO);

    //
    // Enable the PDB filename edit box and browse button
    //
    m_pdbFileName.EnableWindow(TRUE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(TRUE);

    //
    // Disable all controls associated with other radio buttons
    //
	m_ctlFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_CTL_BROWSE_BUTTON)->EnableWindow(FALSE);
	m_controlGuidName.EnableWindow(FALSE);
    GetDlgItem(IDC_PROCESS_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_THREAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_NET_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_DISK_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_PAGEFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_HARDFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_IMAGELOAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_REGISTRY_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_FILEIO_CHECK)->EnableWindow(FALSE);
}

void CProviderControlGuidDlg::OnBnClickedCtlSelectRadio()
{
    //
    // Set the CTL radio button and unset the rest
    //
    CheckRadioButton(IDC_PDB_SELECT_RADIO,
                     IDC_KERNEL_LOGGER_SELECT_RADIO,
                     IDC_CTL_SELECT_RADIO);

    //
    // Enable the CTL name edit box and browse button
    //
	m_ctlFileName.EnableWindow(TRUE);
    GetDlgItem(IDC_CTL_BROWSE_BUTTON)->EnableWindow(TRUE);

    //
    // Disable all controls associated with other radio buttons
    //
    m_pdbFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(FALSE);
	m_controlGuidName.EnableWindow(FALSE);
    GetDlgItem(IDC_PROCESS_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_THREAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_NET_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_DISK_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_PAGEFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_HARDFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_IMAGELOAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_REGISTRY_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_FILEIO_CHECK)->EnableWindow(FALSE);
}

void CProviderControlGuidDlg::OnBnClickedManualSelectRadio()
{
    //
    // Set the Manual radio button and unset the rest
    //
    CheckRadioButton(IDC_PDB_SELECT_RADIO,
                     IDC_KERNEL_LOGGER_SELECT_RADIO,
                     IDC_MANUAL_SELECT_RADIO);

    //
    // Enable the GUID name edit box
    //
	m_controlGuidName.EnableWindow(TRUE);

    //
    // Disable all controls associated with other radio buttons
    //
    m_pdbFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(FALSE);
	m_ctlFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_CTL_BROWSE_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_PROCESS_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_THREAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_NET_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_DISK_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_PAGEFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_HARDFAULT_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_IMAGELOAD_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_REGISTRY_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_FILEIO_CHECK)->EnableWindow(FALSE);
}

void CProviderControlGuidDlg::OnBnClickedKernelLoggerSelectRadio()
{
    //
    // Set the Kernel Logger radio button and unset the rest
    //
    CheckRadioButton(IDC_PDB_SELECT_RADIO,
                     IDC_KERNEL_LOGGER_SELECT_RADIO,
                     IDC_KERNEL_LOGGER_SELECT_RADIO);


    //
    // Enable the kernel logger check boxes
    //
    GetDlgItem(IDC_PROCESS_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_THREAD_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_NET_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_DISK_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_PAGEFAULT_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_HARDFAULT_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_IMAGELOAD_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_REGISTRY_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_FILEIO_CHECK)->EnableWindow(TRUE);

    //
    // Disable all controls associated with other radio buttons
    //
    m_pdbFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(FALSE);
	m_ctlFileName.EnableWindow(FALSE);
    GetDlgItem(IDC_CTL_BROWSE_BUTTON)->EnableWindow(FALSE);
	m_controlGuidName.EnableWindow(FALSE);
}

void CProviderControlGuidDlg::OnBnClickedOk()
{
    CString str;

    if(BST_CHECKED == IsDlgButtonChecked(IDC_PDB_SELECT_RADIO)) {
        m_pdbFileName.GetWindowText(m_pTraceSession->m_pdbFile);

        EndDialog(1);
        return;
    } 
    
    if(BST_CHECKED == IsDlgButtonChecked(IDC_CTL_SELECT_RADIO)) {
        m_ctlFileName.GetWindowText(m_pTraceSession->m_ctlFile);

        EndDialog(1);
        return;
    }
    
    if(BST_CHECKED == IsDlgButtonChecked(IDC_MANUAL_SELECT_RADIO)) {
        m_controlGuidName.GetWindowText(str);
        m_pTraceSession->m_controlGuid.Add(str);

        EndDialog(1);
        return;
    }

    if(BST_CHECKED == IsDlgButtonChecked(IDC_KERNEL_LOGGER_SELECT_RADIO)) {
        //
        // Convert the system kernel logger control GUID to a string
        //
        GuidToString(SystemTraceControlGuid, str);

        m_pTraceSession->m_controlGuid.Add(str);

        m_pTraceSession->m_bKernelLogger = TRUE;

        //
        // Get the kernel logger options
        //
        m_bProcess = ((CButton *)GetDlgItem(IDC_PROCESS_CHECK))->GetCheck();
        m_bThread = ((CButton *)GetDlgItem(IDC_THREAD_CHECK))->GetCheck();
        m_bDisk = ((CButton *)GetDlgItem(IDC_DISK_CHECK))->GetCheck();
        m_bNet = ((CButton *)GetDlgItem(IDC_NET_CHECK))->GetCheck();
        m_bFileIO = ((CButton *)GetDlgItem(IDC_FILEIO_CHECK))->GetCheck();
        m_bPageFault = ((CButton *)GetDlgItem(IDC_PAGEFAULT_CHECK))->GetCheck();
        m_bHardFault = ((CButton *)GetDlgItem(IDC_HARDFAULT_CHECK))->GetCheck();
        m_bImageLoad = ((CButton *)GetDlgItem(IDC_IMAGELOAD_CHECK))->GetCheck();
        m_bRegistry = ((CButton *)GetDlgItem(IDC_REGISTRY_CHECK))->GetCheck();

        EndDialog(1);
        return;
    }

    EndDialog(2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\pathdlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// PathDlg.h : interface of the CPathDlg class
//////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CPathDlg dialog

class CPathDlg : public CFileDialog
{
	DECLARE_DYNAMIC(CPathDlg)

public:
	virtual BOOL OnFileNameOK(void);
	virtual void OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode);

	CPathDlg(BOOL       bOpenFileDialog,
		     LPCTSTR    lpszDefExt = NULL,
		     LPCTSTR    lpszFileName = NULL,
		     DWORD      dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLETEMPLATE,
		     LPCTSTR    lpszFilter = NULL,
		     CWnd      *pParentWnd = NULL);

  	CString m_pathName;
    BOOL    m_bFirstTime;

// Dialog Data
	//{{AFX_DATA(CPathDlg)
	enum {IDD = IDD_DIRECTORY_SELECT_DIALOG};
	CEdit	m_PathName;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPathDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CPathDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providerformatinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderFormatInfo.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "utils.h"
#include "PathDlg.h"
#include "ProviderFormatInfo.h"


// CProviderFormatInfo dialog

IMPLEMENT_DYNAMIC(CProviderFormatInfo, CDialog)
CProviderFormatInfo::CProviderFormatInfo(CWnd* pParent, CTraceSession *pTraceSession)
	: CDialog(CProviderFormatInfo::IDD, pParent)
{
    m_pTraceSession = pTraceSession;
}

CProviderFormatInfo::~CProviderFormatInfo()
{
}

void CProviderFormatInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CProviderFormatInfo, CDialog)
    ON_BN_CLICKED(IDC_TMF_BROWSE_BUTTON, OnBnClickedTmfBrowseButton)
    ON_BN_CLICKED(IDOK, OnBnClickedOk)
END_MESSAGE_MAP()


// CProviderFormatInfo message handlers

void CProviderFormatInfo::OnBnClickedTmfBrowseButton()
{
	CString         str;
	CListBox       *pListBox;
	LONG            index;
	CString			fileName;
	POSITION		pos;
	CString			pathAndFile;
    int             length = 32768;
   
	//
	// Use the common controls file open dialog;  Allow multiple files
	// to be selected
	//
	CFileDialog fileDlg(TRUE,_T("tmf"),_T("*.tmf"),
				        OFN_NOCHANGEDIR | OFN_HIDEREADONLY | 
                            OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | 
                            OFN_ALLOWMULTISELECT | OFN_READONLY | OFN_EXPLORER,
				       _T("Trace Format Files (*.tmf)|*.tmf|All Files (*.*)|*.*||"),
				        this);

	fileDlg.m_ofn.lpstrFile = fileName.GetBuffer(length);
	fileDlg.m_ofn.nMaxFile = length;

	//
	// Pop the dialog...Any error just return
	//
    if(IDOK != fileDlg.DoModal()) {
        return;
    }

	//
	// Iterate over multiple selections
	//
	pos = fileDlg.GetStartPosition();

    while(pos) {

		//
		// Get the file path specification of a file
		//
		pathAndFile = fileDlg.GetNextPathName(pos);

		//
		// Add it to the trace session
		//
		m_pTraceSession->m_tmfFile.Add(pathAndFile);

		//
		// Clip off the path, and add just the file and extension
		// to the list of format files opened
		//
		str = (LPCTSTR)pathAndFile;
        index = str.ReverseFind('\\');        
		str = str.Mid(index+1);

		pListBox = (CListBox *)GetDlgItem(IDC_TMF_FILE_LIST);
        pListBox->InsertString(pListBox->GetCount(), str);

		//
		// Now remove the path and add the GUID to the trace
		// session GUID list
		//
		index = str.ReverseFind('.');
		str = str.Left(index);

        m_pTraceSession->m_formatGuid.Add(str);
    }
}

void CProviderFormatInfo::OnBnClickedOk()
{
    if(0 == m_pTraceSession->m_tmfFile.GetSize()) {
        EndDialog(2);
        return;
    }

    EndDialog(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providerformatinfo.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderFormatInfo.h : interface of the CProviderFormatInfo class
//////////////////////////////////////////////////////////////////////////////

#pragma once


// CProviderFormatInfo dialog

class CProviderFormatInfo : public CDialog
{
	DECLARE_DYNAMIC(CProviderFormatInfo)

public:
	CProviderFormatInfo(CWnd* pParent, CTraceSession *pTraceSession);   // standard constructor
	virtual ~CProviderFormatInfo();

// Dialog Data
	enum { IDD = IDD_PROVIDER_FORMAT_INFORMATION_DIALOG };

    CTraceSession  *m_pTraceSession;
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
    afx_msg void OnBnClickedTmfBrowseButton();
    afx_msg void OnBnClickedOk();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providerformatselectiondlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderFormatSelectionDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "ProviderFormatInfo.h"
#include "FormatSourceSelectDlg.h"
#include "ProviderFormatSelectionDlg.h"


// CProviderFormatSelectionDlg dialog

IMPLEMENT_DYNAMIC(CProviderFormatSelectionDlg, CDialog)
CProviderFormatSelectionDlg::CProviderFormatSelectionDlg(CWnd* pParent, CTraceSession *pTraceSession)
	: CDialog(CProviderFormatSelectionDlg::IDD, pParent)
{
    m_pTraceSession = pTraceSession;
}

CProviderFormatSelectionDlg::~CProviderFormatSelectionDlg()
{
}

BOOL CProviderFormatSelectionDlg::OnInitDialog()
{
    BOOL    retVal;

    retVal = CDialog::OnInitDialog();

    ((CButton *)GetDlgItem(IDC_PDB_SELECT_RADIO))->SetCheck(BST_CHECKED);
    GetDlgItem(IDC_PDB_FILE_EDIT)->EnableWindow(TRUE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(TRUE);

    ((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->SetCheck(BST_UNCHECKED);

    return retVal;
}

void CProviderFormatSelectionDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_PDB_FILE_EDIT, m_pdbFileName);
}


BEGIN_MESSAGE_MAP(CProviderFormatSelectionDlg, CDialog)
    ON_BN_CLICKED(IDOK, OnBnClickedOk)
    ON_BN_CLICKED(IDC_PDB_SELECT_RADIO, OnBnClickedPdbSelectRadio)
    ON_BN_CLICKED(IDC_TMF_SELECT_RADIO, OnBnClickedTmfSelectRadio)
    ON_BN_CLICKED(IDC_PDB_BROWSE_BUTTON, OnBnClickedPdbBrowseButton)
END_MESSAGE_MAP()


// CProviderFormatSelectionDlg message handlers

void CProviderFormatSelectionDlg::OnBnClickedOk()
{
    if(BST_CHECKED == IsDlgButtonChecked(IDC_PDB_SELECT_RADIO)) {
        m_pdbFileName.GetWindowText(m_pTraceSession->m_pdbFile);

        //
        // Have the trace session process the PDB
        //
        if(!m_pTraceSession->ProcessPdb()) {
            EndDialog(2);
            return;
        }

        OnOK();
        return;
    }

    if(((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->GetCheck()) {
        //
        // Now get the TMF file(s) or path as necessary
        //
        CFormatSourceSelectDlg *pDialog = new CFormatSourceSelectDlg(this, m_pTraceSession);
        if(NULL == pDialog) {
            EndDialog(2);
            return;
        }

        if(IDOK != pDialog->DoModal()) {
            delete pDialog;
            EndDialog(2);
            return;
        }

	    delete pDialog;
        EndDialog(1);
        return;
    }
}

void CProviderFormatSelectionDlg::OnBnClickedPdbSelectRadio()
{
    ((CButton *)GetDlgItem(IDC_PDB_SELECT_RADIO))->SetCheck(BST_CHECKED);
    GetDlgItem(IDC_PDB_FILE_EDIT)->EnableWindow(TRUE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(TRUE);

    ((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->SetCheck(BST_UNCHECKED);
}

void CProviderFormatSelectionDlg::OnBnClickedTmfSelectRadio()
{
    ((CButton *)GetDlgItem(IDC_PDB_SELECT_RADIO))->SetCheck(BST_UNCHECKED);
    GetDlgItem(IDC_PDB_FILE_EDIT)->EnableWindow(FALSE);
    GetDlgItem(IDC_PDB_BROWSE_BUTTON)->EnableWindow(FALSE);

    ((CButton *)GetDlgItem(IDC_TMF_SELECT_RADIO))->SetCheck(BST_CHECKED);
}

void CProviderFormatSelectionDlg::OnBnClickedPdbBrowseButton()
{
	//
	// Use the common controls file open dialog
	//
	CFileDialog fileDlg(TRUE, 
                       _T("pdb"),_T("*.pdb"),
				        OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_READONLY |
                            OFN_HIDEREADONLY | OFN_EXPLORER | OFN_NOCHANGEDIR, 
				       _T("Program Database Files (*.pdb)|*.pdb||"),
				        this);

	//
	// Pop the dialog... Any error, just return
	//
	if( fileDlg.DoModal()!=IDOK ) { 				
		return;
	}
	
	//
	// Get the file name and display it
	//
    if(!fileDlg.GetPathName().IsEmpty()) {
        m_pdbFileName.SetWindowText(fileDlg.GetPathName());
        m_pdbFileName.SetFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providerformatselectiondlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// CProviderFormatSelectionDlg.h : CProviderFormatSelectionDlg class interface
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "afxwin.h"


// CProviderFormatSelectionDlg dialog

class CProviderFormatSelectionDlg : public CDialog
{
	DECLARE_DYNAMIC(CProviderFormatSelectionDlg)

public:
	CProviderFormatSelectionDlg(CWnd* pParent, CTraceSession *pTraceSession);
	virtual ~CProviderFormatSelectionDlg();

    BOOL OnInitDialog();

// Dialog Data
	enum { IDD = IDD_PROVIDER_FORMAT_SELECTION_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
    afx_msg void OnBnClickedOk();
    afx_msg void OnBnClickedPdbSelectRadio();
    afx_msg void OnBnClickedTmfSelectRadio();

    CEdit           m_pdbFileName;
    CTraceSession  *m_pTraceSession;
    afx_msg void OnBnClickedPdbBrowseButton();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providersetupdlg.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderSetupDlg.h : interface of the CProviderSetupDlg class
//////////////////////////////////////////////////////////////////////////////


#pragma once
#include "afxcmn.h"
#include "afxwin.h"


// CProviderSetupDlg dialog

class CProviderSetupDlg : public CPropertyPage
{
	DECLARE_DYNAMIC(CProviderSetupDlg)

public:
	CProviderSetupDlg();
	virtual ~CProviderSetupDlg();

    int OnInitDialog();

    BOOL OnSetActive();
    BOOL GetTmfInfo(CTraceSession *pTraceSession);


// Dialog Data
	enum { IDD = IDD_PROVIDER_SETUP_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    CLogSession    *m_pLogSession;

	DECLARE_MESSAGE_MAP()
public:
    afx_msg void OnBnClickedAddProviderButton();
    afx_msg void OnBnClickedRemoveProviderButton();

    CListCtrl   m_providerListCtrl;
    CEdit       m_pdbPath;
    CEdit       m_tmfPath;
    afx_msg void OnNMClickCurrentProviderList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnNMRclickCurrentProviderList(NMHDR *pNMHDR, LRESULT *pResult);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\providersetupdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// ProviderSetupDlg.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include "TraceView.h"
#include "LogSession.h"
#include "FormatSourceSelectDlg.h"
#include "DisplayDlg.h"
#include "ProviderControlGuidDlg.h"
#include "LogDisplayOptionDlg.h"
#include "LogSessionInformationDlg.h"
#include "ProviderSetupDlg.h"
#include "LogSessionPropSht.h"
#include "ProviderFormatInfo.h"
#include "Utils.h"

// CProviderSetupDlg dialog

IMPLEMENT_DYNAMIC(CProviderSetupDlg, CPropertyPage)
CProviderSetupDlg::CProviderSetupDlg()
	: CPropertyPage(CProviderSetupDlg::IDD)
{
}

CProviderSetupDlg::~CProviderSetupDlg()
{
}

int CProviderSetupDlg::OnInitDialog()
{
    BOOL                retVal;
    CLogSessionPropSht *pSheet;
    CTraceSession      *pTraceSession;
    CString             str;
        
    retVal = CPropertyPage::OnInitDialog();

    //
    // Disable the remove button
    //
    GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(FALSE);

    m_providerListCtrl.InsertColumn(0,_T("Name"), LVCFMT_LEFT, 348); //80);

    pSheet = (CLogSessionPropSht *) GetParent();   

    m_pLogSession = pSheet->m_pLogSession;

    if(m_pLogSession != NULL) {
        for(LONG ii = 0; ii < m_pLogSession->m_traceSessionArray.GetSize(); ii++) {
            pTraceSession = (CTraceSession *)m_pLogSession->m_traceSessionArray[ii];
            if(pTraceSession != NULL) {
                //
                // Put the provider on the display
                //
                m_providerListCtrl.InsertItem(ii, 
                                              pTraceSession->m_controlGuidFriendlyName[0]);

                m_providerListCtrl.SetItemData(ii, (DWORD_PTR)pTraceSession);

                m_providerListCtrl.SetItemText(pTraceSession->m_traceSessionID, 
                                               1,
                                               pTraceSession->m_controlGuid[0]);
            }
        }
    }

    return retVal;
}

void CProviderSetupDlg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_CURRENT_PROVIDER_LIST, m_providerListCtrl);
}


BEGIN_MESSAGE_MAP(CProviderSetupDlg, CPropertyPage)
    ON_BN_CLICKED(IDC_ADD_PROVIDER_BUTTON, OnBnClickedAddProviderButton)
    ON_BN_CLICKED(IDC_REMOVE_PROVIDER_BUTTON, OnBnClickedRemoveProviderButton)
    ON_NOTIFY(NM_CLICK, IDC_CURRENT_PROVIDER_LIST, OnNMClickCurrentProviderList)
    ON_NOTIFY(NM_RCLICK, IDC_CURRENT_PROVIDER_LIST, OnNMRclickCurrentProviderList)
END_MESSAGE_MAP()

BOOL CProviderSetupDlg::OnSetActive() 
{
    CLogSessionPropSht *pSheet = (CLogSessionPropSht*) GetParent();   
    CString             dialogTxt;
    CString             tempString;
    BOOL                retVal;    

    retVal = CPropertyPage::OnSetActive();

    //
    // Fix the title if in Wizard mode
    //
    if(pSheet->IsWizard()) {
        CTabCtrl* pTab = pSheet->GetTabControl();

        //
        //If its not the active page, just set the tab item
        //
	    TC_ITEM ti;
	    ti.mask = TCIF_TEXT;
	    ti.pszText =_T("Create New Log Session");
	    VERIFY(pTab->SetItem(0, &ti));
    }

    //
    // disable/enable buttons as appropriate
    //
    if(m_pLogSession->m_bTraceActive) {
        GetDlgItem(IDC_ADD_PROVIDER_BUTTON)->EnableWindow(FALSE);
        GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(FALSE);
    } else {
        GetDlgItem(IDC_ADD_PROVIDER_BUTTON)->EnableWindow(TRUE);
    }

    //
    // display the proper text for the group box
    //
    if(::IsWindow(pSheet->m_logSessionInformationDlg.m_hWnd))  {
        
        dialogTxt.Format(_T("Provider List For "));
        pSheet->m_logSessionInformationDlg.m_logSessionName.GetWindowText(tempString);
        dialogTxt += (LPCTSTR)tempString;
        GetDlgItem(IDC_PROVIDER_SETUP_STATIC)->SetWindowText(dialogTxt);
    }

    if(0 == m_pLogSession->m_traceSessionArray.GetSize()) {
        pSheet->SetWizardButtons(0);
    } else {
        pSheet->SetWizardButtons(PSWIZB_NEXT);
    }

    return retVal;
}


void CProviderSetupDlg::OnBnClickedAddProviderButton()
{
    CString         str;
    CTraceSession  *pTraceSession = NULL;
    CFileFind       fileFind;
    CString         extension;
    CString         traceDirectory;
    CString         tmcPath;
    CString         tmfPath;
    CString         ctlPath;
    CString         tempPath;
    CString         providerName;
    CString         tempDirectory;
    CTraceSession  *pTrace;
    BOOL            bNoID;
    LONG            traceSessionID = 0;
    CLogSessionPropSht *pSheet;
    ULONG           flags = 0;
    BOOL            bProcess;
    BOOL            bThread;
    BOOL            bDisk;
    BOOL            bNet;
    BOOL            bFileIO;
    BOOL            bPageFault;
    BOOL            bHardFault;
    BOOL            bImageLoad;
    BOOL            bRegistry;

    //
    // Get the parent property sheet
    //
    pSheet = (CLogSessionPropSht *) GetParent();   

    //
    // Get the trace session ID
    //
    do {
        bNoID = FALSE;
        for(LONG ii = 0; ii < m_pLogSession->m_traceSessionArray.GetSize(); ii++) {
            pTrace = (CTraceSession *)m_pLogSession->m_traceSessionArray[ii];

            if(pTrace == NULL) {
                continue;
            }

            if(traceSessionID == pTrace->m_traceSessionID) {
                bNoID = TRUE;
                traceSessionID++;
            }
        }
    } while(bNoID);

    //
    // Create the new trace session
    //
    pTraceSession = new CTraceSession(traceSessionID);

    if(NULL == pTraceSession) {
        AfxMessageBox(_T("Failed To Initialize Provider, Resource Allocation Failure"));
        return;
    }

    //
    // Promt the user for trace providers
    //
    CProviderControlGuidDlg	*pDialog = new CProviderControlGuidDlg(this, pTraceSession);
    
    if(IDOK != pDialog->DoModal()) {
        delete pTraceSession;
        delete pDialog;
        return;
    }

    bProcess = pDialog->m_bProcess;
    bThread = pDialog->m_bThread;
    bDisk = pDialog->m_bDisk;
    bNet = pDialog->m_bNet;
    bFileIO = pDialog->m_bFileIO;
    bPageFault = pDialog->m_bPageFault;
    bHardFault = pDialog->m_bHardFault;
    bImageLoad = pDialog->m_bImageLoad;
    bRegistry = pDialog->m_bRegistry;

	delete pDialog;

    //
    // Handle PDB input
    //
    if(!pTraceSession->m_pdbFile.IsEmpty()) {

        if(!pTraceSession->ProcessPdb()) {
            delete pTraceSession;
            return;
        }

        //
        // We have a control GUID whether we can display info or
        // not we are good to start a trace, so add the session 
        // to the list
        //
        m_pLogSession->m_traceSessionArray.Add(pTraceSession);

        if(pTraceSession->m_tmfFile.GetSize() == 0) {
            AfxMessageBox(_T("Failed To Get Format Information From PDB\nEvent Data Will Not Be Formatted"));
        }
    } else if(!pTraceSession->m_ctlFile.IsEmpty()) {
        //
        // Handle CTL file input here
        //

        FILE   *ctlFile;
        TCHAR   line[MAX_STR_LENGTH];
        LONG    count;
        BOOL    bFoundCtlFile = FALSE;

        ctlFile = _tfopen((LPTSTR)(LPCTSTR)pTraceSession->m_ctlFile, 
                         _T("r"));
        if (ctlFile == NULL) {
            str.Format(_T("Unable To Open Control GUID File %s"), 
                       pTraceSession->m_ctlFile);
            AfxMessageBox(str);

            delete pTraceSession;
            return;
        }

        while( _fgetts(line, MAX_STR_LENGTH, ctlFile) != NULL ) {
            if (_tcslen(line) < 36)
                continue;
            if(line[0] == ';'  || 
               line[0] == '\0' || 
               line[0] == '#' || 
               line[0] == '/') {
                continue;
            }
            
            bFoundCtlFile = TRUE;
            str = line;
            pTraceSession->m_controlGuid.Add(str);

            //
            // add a control GUID friendly name
            //
            pTraceSession->m_controlGuidFriendlyName.Add(pTraceSession->m_ctlFile);
        }

        fclose(ctlFile);

        if(!bFoundCtlFile) {
            AfxMessageBox(_T("Unable To Obtain Control GUID"));
            delete pTraceSession;
            return;
        }

        //
        // We have a control GUID whether we can display info or
        // not we are good to start a trace, so add the session 
        // to the list
        //
        m_pLogSession->m_traceSessionArray.Add(pTraceSession);

        //
        // Now get the TMF File(s)
        //
        GetTmfInfo(pTraceSession);
    } else if(pTraceSession->m_bKernelLogger) {
        //
        // The kernel logger was selected, 
        // so we specify the logger name here
        // Set the session name in the property sheet
        //
        pSheet->m_displayName = KERNEL_LOGGER_NAME;

        if(bProcess) {
            flags |= EVENT_TRACE_FLAG_PROCESS;
        }

        if(bThread) {
            flags |= EVENT_TRACE_FLAG_THREAD;
        }

        if(bDisk) {
            flags |= EVENT_TRACE_FLAG_DISK_IO;
        }

        if(bNet) {
            flags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
        }

        if(bFileIO) {
            flags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
        }

        if(bPageFault) {
            flags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
        }

        if(bHardFault) {
            flags |= EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
        }

        if(bImageLoad) {
            flags |= EVENT_TRACE_FLAG_IMAGE_LOAD;
        }

        if(bRegistry) {
            flags |= EVENT_TRACE_FLAG_REGISTRY;
        }

        //
        // Update the flags data
        //
        pSheet->m_logSessionValues[Flags].Format(_T("%d"), flags);

        //
        // We have a control GUID whether we can display info or
        // not we are good to start a trace, so add the session 
        // to the list
        //
        m_pLogSession->m_traceSessionArray.Add(pTraceSession);

        //
        // Now get the system TMF File
        //

	    //
	    // Use the common controls file open dialog
	    //
	    CFileDialog fileDlg(TRUE, 
                            _T(".tmf"),
                            _T("system.tmf"),
				            OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | 
                                OFN_HIDEREADONLY | OFN_EXPLORER | 
                                OFN_NOCHANGEDIR, 
				            _T("System TMF File (system.tmf)|system.tmf||"),
				            this);

	    //
	    // Pop the dialog... Any error, just return
	    //
	    if( fileDlg.DoModal()!=IDOK ) { 				
		    return;
	    }
    	
	    //
	    // Get the file name
	    //
        if(!fileDlg.GetPathName().IsEmpty()) {
            //
            // Store the file name
            //
            //
		    // Add it to the trace session
		    //
		    pTraceSession->m_tmfFile.Add(fileDlg.GetPathName());
        }

        //
        // add a control GUID friendly name
        //
        pTraceSession->m_controlGuidFriendlyName.Add(KERNEL_LOGGER_NAME);
    } else {
        //
        // Handle manually entered control GUID here
        //

        if((0 == pTraceSession->m_controlGuid.GetSize()) ||
           (pTraceSession->m_controlGuid[0].IsEmpty())) {
            AfxMessageBox(_T("Unable To Obtain Control GUID"));
            delete pTraceSession;
            return;
        }

        //
        // Add a control GUID to the provider list
        //
        pTraceSession->m_controlGuidFriendlyName.Add(pTraceSession->m_controlGuid[0]);

        //
        // We have a control GUID whether we can display info or
        // not we are good to start a trace, so add the session 
        // to the list
        //
        m_pLogSession->m_traceSessionArray.Add(pTraceSession);

        //
        // Now get the TMF File(s)
        //
        GetTmfInfo(pTraceSession);
    } 

    //
    // Put the provider on the display
    //
    m_providerListCtrl.InsertItem(pTraceSession->m_traceSessionID, 
                                  pTraceSession->m_controlGuidFriendlyName[0]);

    m_providerListCtrl.SetItemData(pTraceSession->m_traceSessionID, (DWORD_PTR)pTraceSession);

    pSheet->SetWizardButtons(PSWIZB_NEXT);

	return;
}

BOOL CProviderSetupDlg::GetTmfInfo(CTraceSession *pTraceSession)
{
    //
    // Now get the TMF file(s) or path as necessary
    //
    CFormatSourceSelectDlg *pDialog = new CFormatSourceSelectDlg(this, pTraceSession);
    if(NULL == pDialog) {
        return FALSE;
    }

    if(IDOK != pDialog->DoModal()) {
        delete pDialog;
        return FALSE;
    }

	delete pDialog;
    return TRUE;
}

void CProviderSetupDlg::OnBnClickedRemoveProviderButton()
{
    CTraceSession      *pTraceSession;
    POSITION            pos;
    BOOL                bFound = FALSE;
    CLogSessionPropSht *pSheet;
    int                 index;

    //
    // Get the parent property sheet
    //
    pSheet = (CLogSessionPropSht *) GetParent();   
    
    pos = m_providerListCtrl.GetFirstSelectedItemPosition();
    if (pos == NULL) {
        return;
    }

    while (pos)
    {
        index = m_providerListCtrl.GetNextSelectedItem(pos);


        pTraceSession = (CTraceSession *)m_providerListCtrl.GetItemData(index);

        //
        // Pull the provider from the display
        //
        m_providerListCtrl.DeleteItem(index);

        if(pTraceSession != NULL) {
            for(LONG ii = 0; ii < m_pLogSession->m_traceSessionArray.GetSize(); ii++) {
                if(m_pLogSession->m_traceSessionArray[ii] == pTraceSession) {
                    m_pLogSession->m_traceSessionArray.RemoveAt(ii);

                    //
                    // If the kernel logger is being removed, change the
                    // log session name stored by the property sheet back
                    // to what is stored in the CLogSession object
                    //
                    if(pTraceSession->m_bKernelLogger) {
                        //
                        // Set the session name in the property sheet
                        //
                        pSheet->m_displayName = pSheet->m_pLogSession->GetDisplayName();

                        //
                        // Set the flags back to the default as well
                        //
                        pSheet->m_logSessionValues[Flags] = (LPCTSTR)m_pLogSession->m_logSessionValues[Flags];
                    }

                    delete pTraceSession;
                    break;
                }
            }
        }
    }

    //
    // Check for at least one provider
    //
    if(0 == m_pLogSession->m_traceSessionArray.GetSize()) {
        //
        // disable the remove button
        //
        GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(FALSE);

        //
        // Disable the next button if there are no providers
        //
        pSheet->SetWizardButtons(0);
    }
}

void CProviderSetupDlg::OnNMClickCurrentProviderList(NMHDR *pNMHDR, LRESULT *pResult)
{
    POSITION        pos;

    *pResult = 0;

    if(m_pLogSession->m_bTraceActive) {
        //
        // don't enable anything
        //
        return;
    }

    pos = m_providerListCtrl.GetFirstSelectedItemPosition();
        
    if(pos == NULL) {
        //
        // Disable the remove button
        //
        GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(FALSE);
    } else {
        //
        // Enable the remove button
        //
        GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(TRUE);
    }
}

void CProviderSetupDlg::OnNMRclickCurrentProviderList(NMHDR *pNMHDR, LRESULT *pResult)
{
    POSITION        pos;
    
    pos = m_providerListCtrl.GetFirstSelectedItemPosition();
    if (pos == NULL) {
        //
        // Disable the remove button
        //
        GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(FALSE);
    } else {
        //
        // Enable the remove button
        //
        GetDlgItem(IDC_REMOVE_PROVIDER_BUTTON)->EnableWindow(TRUE);
    }

    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// TraceView.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TraceView.rc
//
#define IDR_MANIFEST                    1
#define IDC_DISPLAY_LIST                5
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDR_MAINFRAME                   128
#define IDR_TraceViewTYPE               129
#define IDS_LOG_SESSION_OPTIONS_TITLE   129
#define IDS_LOG_SESSION_SETUP_TITLE     129
#define IDD_DISPLAY_DIALOG              130
#define ID_FILE_NEWLOGSESSION           131
#define IDD_PROVIDER_SETUP_DIALOG       133
#define IDD_PROVIDER_OPTIONS_DIALOG     134
#define IDR_LOG_SESSION_POPUP_MENU      135
#define ID_CREATENEWLOGSESSION          137
#define IDR_LOG_OPTIONS_POPUP_MENU      139
#define ID__STARTTRACE                  140
#define ID__STOPTRACE                   141
#define ID_REMOVETRACE                  142
#define ID__ADDNEW                      143
#define ID_PROPERTIES                   144
#define IDD_LOG_DISPLAY_OPTIONS_DIALOG  145
#define ID_FILE_OPENEXISTINGLOGFILEFORDISPLAY 146
#define ID__OPENEXISTINGLOGFILEFORDISPLAY 147
#define IDR_TRACE_TOOLBAR               148
#define IDR_TRACE_SESSION_POPUP_MENU    148
#define ID_VIEW_TRACETOOLBAR            150
#define ID_GROUPSESSIONS                151
#define ID_UNGROUPSESSIONS              152
#define IDD_TRACE_FORMAT_INFORMATION_DIALOG 153
#define IDD_PROVIDER_CONTROL_GUID_DIALOG 153
#define IDD_PROVIDER_FORMAT_INFORMATION_DIALOG 155
#define ID__CLEARDISPLAY                157
#define IDD_LOG_FILE_DIALOG             158
#define IDD_LOG_OUTPUT_DIALOG           159
#define ID__AUTOSIZECOLUMNS             160
#define ID__OPENEXISTINGLOGFILE         161
#define ID_FILE_OPENEXISTINGLOGFILE     162
#define ID__DUMPLOGFILE                 163
#define IDR_LOG_DISPLAY_OPTIONS_POPUP_MENU 164
#define ID__FLAGS                       165
#define ID__FLUSHTIME                   166
#define ID__MAXBUFFERS                  167
#define ID__MINBUFFERS                  168
#define ID__BUFFERSIZE                  169
#define ID__AGE                         170
#define ID__CIRCULAR                    171
#define ID__SEQUENTIAL                  172
#define ID__NEWFILE                     173
#define ID__GLOBALSEQUENCE              174
#define ID__LOCALSEQUENCE               175
#define ID__LEVEL                       176
#define ID__NAME                        178
#define ID__MESSAGE                     179
#define ID__FILENAME                    180
#define ID__LINENUMBER                  181
#define ID__FUNCTIONNAME                182
#define ID__PROCESSID                   183
#define ID__THREADID                    184
#define ID__CPUNUMBER                   185
#define ID__SEQUENCENUMBER              186
#define ID__SYSTEMTIME                  187
#define ID__KERNELTIME                  188
#define ID__USERTIME                    189
#define ID_Menu                         190
#define IDR_TRACE_DISPLAY_OPTION_POPUP_MENU 202
#define IDD_PROVIDER_FORMAT_SELECTION_DIALOG 215
#define ID__STATE                       216
#define ID__TRACEDISPLAYOPTIONS         217
#define ID__LOGSESSIONDISPLAYOPTIONS    218
#define ID__SELECTCOLUMNTOVIEW          219
#define ID__SELECTCOLUMNTOVIEW220       220
#define IDD_DIRECTORY_SELECT_DIALOG     221
#define IDD_FORMAT_INFO_SELECT          223
#define ID__INDENT                      224
#define ID__FLAGSNAME                   225
#define ID__LEVELNAME                   226
#define ID__COMPONENTNAME               227
#define ID__SUBCOMPONENTNAME            228
#define ID__CHANGECOLOR                 229
#define ID__CHANGETEXTCOLOR             230
#define ID__CHANGEBACKGROUNDCOLOR       231
#define ID__EVENTCOUNT                  233
#define ID__LOSTEVENTS                  234
#define ID__BUFFERSREAD                 235
#define ID_CREATEKERNELLOGGERSESSION    236
#define ID_HELP_HELPTOPICS              237
#define ID_SET_TMAX                     238
#define IDD_MAX_TRACE                   239
#define IDC_CUSTOM_EDIT                 812
#define IDC_CUSTOM_COMBO                813
#define IDD_LOG_SESSION_OPTIONS         1000
#define IDC_LOG_SESSION_OPTIONS         1000
#define IDD_LOG_SESSION_OPTIONS_DIALOG  1000
#define IDD_LOG_SESSION_INFORMATION_DIALOG 1000
#define IDC_MAXBUF_VAL_EDIT             1002
#define IDC_DISPLAY_THREADID_CHECK      1002
#define IDC_DISPLAY_CPUNUMBER_CHECK     1003
#define IDC_DISPLAY_MINBUF_CHECK        1004
#define IDC_DISPLAY_PROVIDERNAME_CHECK  1004
#define IDC_MINBUF_VAL_EDIT             1005
#define IDC_DISPLAY_FILENAME_CHECK      1005
#define IDC_CHECK6                      1006
#define IDC_DISPLAY_FUNCTIONNAME_CHECK  1006
#define IDC_FILEIO_CHECK                1006
#define IDC_LOGFILE_EDIT                1007
#define IDC_DISPLAY_LINENUMBER_CHECK    1007
#define IDC_LOGFILE_BROWSE_BUTTON       1008
#define IDC_DISPLAY_MESSAGE_CHECK       1008
#define IDC_TMF_FILE_EDIT1              1009
#define IDC_DISPLAY_SEQNUMBER_CHECK     1009
#define IDC_TMF_FILE_EDIT               1009
#define IDC_TMF_BROWSE_BUTTON1          1010
#define IDC_DISPLAY_BUFSIZ_CHECK        1010
#define IDC_DISPLAY_GLOBALSEQNUMBER_CHECK 1010
#define IDC_TMF_BROWSE_BUTTON           1010
#define IDC_CTL_FILE_EDIT               1011
#define IDC_BUFSIZ_VAL_EDIT             1011
#define IDC_CONTROL_GUID_FRIENDLY_NAME_EDIT 1011
#define IDC_CTL_BROWSE_BUTTON           1012
#define IDC_DISPLAY_FLUSHTIME_CHECK     1012
#define IDC_TMF_FILE_EDIT2              1013
#define IDC_FLUSHTIME_VAL_EDIT          1013
#define IDC_TMF_BROWSE_BUTTON2          1014
#define IDC_DISPLAY_TRCLVL_CHECK        1014
#define IDC_MANUAL_GUID_EDIT            1015
#define IDC_TRCLVL_VAL_EDIT             1015
#define IDC_ADD_PROVIDER_BUTTON         1016
#define IDC_PDB_SELECT_RADIO            1017
#define IDC_CTL_SELECT_RADIO            1018
#define IDC_MANUAL_SELECT_RADIO         1019
#define IDC_PDB_SELECT_RADIO2           1019
#define IDC_TMF_SELECT_RADIO            1019
#define IDC_REMOVE_PROVIDER_BUTTON      1020
#define IDC_DONE_PROVIDER_SETUP_BUTTON  1021
#define IDC_KERNEL_LOGGER_SELECT_RADIO  1021
#define IDC_MODIFY_PROVIDER_BUTTON      1022
#define IDC_CURRENT_PROVIDER_LIST       1023
#define IDC_PDB_FILE_EDIT               1024
#define IDC_CANCEL_PROVIDER_BUTTON      1024
#define IDC_PDB_BROWSE_BUTTON           1025
#define IDC_DISPLAY_MAXBUF_CHECK        1026
#define IDC_DISPLAY_PROCESSID_CHECK     1027
#define IDC_APPEND_CHECK                1033
#define IDC_WRITE_LOGFILE_CHECK         1034
#define IDC_REALTIME_CHECK              1036
#define IDC_DISPLAY_DECAYTIME_CHECK     1053
#define IDC_LOG_DISPLAY_OPTION_LIST     1053
#define IDC_DECAYTIME_VAL_EDIT          1054
#define IDC_BUTTON1                     1054
#define IDC_OK                          1054
#define IDC_ADVANCED_BUTTON             1054
#define IDC_LISTING_BROWSE_BUTTON       1054
#define IDC_DISPLAY_NEWFILE_CHECK       1055
#define IDC_BUTTON2                     1055
#define IDC_CANCEL                      1055
#define IDC_SUMMARY_BROWSE_BUTTON       1055
#define IDC_NEWFILE_VAL_EDIT            1056
#define IDC_DISPLAY_CIR_CHECK           1057
#define IDC_WRITE_LOGFILE_STATIC        1058
#define IDC_DISPLAY_SEQ_CHECK           1059
#define IDC_REALTIME_STATIC             1059
#define IDC_APPEND_STATIC               1060
#define IDC_DISPLAY_FLAGS_CHECK         1061
#define IDC_PROVIDER_SETUP_STATIC       1061
#define IDC_FLAGS_VAL_EDIT              1062
#define IDC_CIR_CHECK                   1063
#define IDC_SEQ_CHECK                   1064
#define IDC_TRACE_OPTION_LIST           1064
#define IDC_LOG_NAME_EDIT               1065
#define IDC_LISTING_FILE_CHECK          1065
#define IDC_SUMMARY_FILE_CHECK          1066
#define IDC_LISTING_FILE_EDIT           1067
#define IDC_SUMMARY_FILE_EDIT           1068
#define IDC_LISTING_EDIT                1069
#define IDC_SUMMARY_EDIT                1070
#define IDC_TMF_FILE_LIST               1071
#define IDC_SPIN1                       1077
#define IDC_FAST_FLAGS                  1078
#define IDC_FAST_LEVEL                  1079
#define IDC_TMF_STATIC                  1079
#define IDC_PDB_STATIC                  1080
#define IDC_PATH_NAME_EDIT              1081
#define IDC_DIRECTORY_LIST              1082
#define IDC_COMBO1                      1083
#define IDC_GROUP_NUMBER_COMBO          1083
#define IDC_RADIO2                      1092
#define IDC_TMF_SEARCH_RADIO            1092
#define IDC_COMBO2                      1096
#define IDC_PROCESS_CHECK               1098
#define IDC_CPU_CHECK                   1099
#define IDC_NET_CHECK                   1100
#define IDC_THREAD_CHECK                1101
#define IDC_DISK_CHECK                  1102
#define IDC_PAGEFAULT_CHECK             1103
#define IDC_HARDFAULT_CHECK             1104
#define IDC_IMAGELOAD_CHECK             1105
#define IDC_REGISTRY_CHECK              1106
#define IDC_SCROLLBAR1                  1108
#define IDC_EDIT1                       1109
#define IDC_MAX_TRACE                   1109
#define ID_START_TRACE_BUTTON           32773
#define ID_STOP_TRACE_BUTTON            32774
#define ID_DUMP_TRACE_BUTTON            32777

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        240
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif						

//#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
//#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
//#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxdlgs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\wppfmtstub.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// WppFmtStub.h : BinPlaceWppFmt stub to allow mixed linking
//////////////////////////////////////////////////////////////////////////////

#ifndef __WPPFMTSTUB_H__
#define __WPPFMTSTUB_H__

#pragma once

// The main Formatting routine, normally used by Binplace and TracePDB
// Takes a PDB and creates guid.tmf files from it, all in TraceFormatFilePath
//
DWORD BinplaceWppFmtStub(LPSTR  PdbFileName,
                         LPSTR  TraceFormatFilePath,
                         LPSTR  szRSDSDllToLoad,
                         BOOL   TraceVerbose);

#endif // __WPPFMTSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\wppfmtstub.c ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// WppFmtStub.cpp : implementation file
//////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>
#include <traceprt.h>
#include "wppfmtstub.h"
#include "wppfmt.h"

DWORD BinplaceWppFmtStub(LPSTR PdbFileName,
                         LPSTR TraceFormatFilePath,
                         LPSTR szRSDSDllToLoad,
                         BOOL  TraceVerbose)
{
    return BinplaceWppFmt(PdbFileName, 
                          TraceFormatFilePath,
                          szRSDSDllToLoad,
                          TraceVerbose);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\traceview.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// TraceView.h : main header file for the TraceView application
//////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#if !defined(INLINE)
#define INLINE __inline
#endif

#include "afxtempl.h"


//
// Command line tool stuff
//
#if !defined(EVENT_TRACE_USE_KBYTES_FOR_SIZE)
#define EVENT_TRACE_USE_KBYTES_FOR_SIZE     0x00002000  // Use KBytes as file size unit
#endif

#if !defined(EVENT_TRACE_KD_FILTER_MODE)
#define EVENT_TRACE_KD_FILTER_MODE          0x00080000  // KD_FILTER
#endif

#define DEFAULT_LOG_BUFFER_SIZE	1024
#define SIZEEVENTBUF 32768
#define TRACE_FORMAT_SEARCH_PATH L"TRACE_FORMAT_SEARCH_PATH"

typedef struct _TRACE_ENABLE_FLAG_EXTENSION {
    USHORT      Offset;     // Offset to the flag array in structure
    UCHAR       Length;     // Length of flag array in ULONGs
    UCHAR       Flag;       // Must be set to EVENT_TRACE_FLAG_EXTENSION
} TRACE_ENABLE_FLAG_EXTENSION, *PTRACE_ENABLE_FLAG_EXTENSION;

typedef struct _WMI_CLIENT_CONTEXT {
    UCHAR                   ProcessorNumber;
    UCHAR                   Alignment;
    USHORT                  LoggerId;
} WMI_CLIENT_CONTEXT, *PWMI_CLIENT_CONTEXT;

typedef struct _WMI_BUFFER_STATE {
   ULONG               Free:1;
   ULONG               InUse:1;
   ULONG               Flush:1;
   ULONG               Unused:29;
} WMI_BUFFER_STATE, *PWMI_BUFFER_STATE;

typedef struct _WMI_BUFFER_HEADER {
    union {
            WNODE_HEADER        Wnode;
        struct {
            ULONG64         Reserved1;
            ULONG64         Reserved2;
            LARGE_INTEGER   Reserved3;
            union{
                struct {
                    PVOID Alignment;          
                    SINGLE_LIST_ENTRY SlistEntry;
                };
                LIST_ENTRY      Entry;
            };
        };
        struct {
            LONG            ReferenceCount;     // Buffer reference count
            ULONG           SavedOffset;        // Temp saved offset
            ULONG           CurrentOffset;      // Current offset
            ULONG           UsePerfClock;       // UsePerfClock flag
            LARGE_INTEGER   TimeStamp;
            GUID            Guid;
            WMI_CLIENT_CONTEXT ClientContext;
            union {
                WMI_BUFFER_STATE State;
                ULONG Flags;
            };
        };
    };
    ULONG                   Offset;
    USHORT                  BufferFlag;
    USHORT                  BufferType;
    union {
        GUID                InstanceGuid;
        struct {
            PVOID               LoggerContext;
            SINGLE_LIST_ENTRY GlobalEntry;
        };
    };
} WMI_BUFFER_HEADER, *PWMI_BUFFER_HEADER;

typedef struct _WMI_TRACE_PACKET {   // must be ULONG!!
    USHORT  Size;
    union{
        USHORT  HookId;
        struct {
            UCHAR   Type;
            UCHAR   Group;
        };
    };
} WMI_TRACE_PACKET, *PWMI_TRACE_PACKET;

//
// 64-bit Trace header for kernel events
//
typedef struct _SYSTEM_TRACE_HEADER {
    union {
        ULONG       Marker;
        struct {
            USHORT  Version;
            UCHAR   HeaderType;
            UCHAR   Flags;
        };
    };
    union {
        ULONG            Header;    // both sizes must be the same!
        WMI_TRACE_PACKET Packet;
    };
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   SystemTime;
    ULONG           KernelTime;
    ULONG           UserTime;
} SYSTEM_TRACE_HEADER, *PSYSTEM_TRACE_HEADER;


// Constants
const LONG SIZESUMMARYBLOCK = 16384;

//
// GUI stuff
//

// Log session display flags
#define LOGSESSION_DISPLAY_STATE            0x00000001
#define LOGSESSION_DISPLAY_EVENTCOUNT       0x00000002
#define LOGSESSION_DISPLAY_LOSTEVENTS       0x00000004
#define LOGSESSION_DISPLAY_BUFFERSREAD      0x00000008
#define LOGSESSION_DISPLAY_FLAGS            0x00000010
#define LOGSESSION_DISPLAY_FLUSHTIME        0x00000020
#define LOGSESSION_DISPLAY_MAXBUF           0x00000040
#define LOGSESSION_DISPLAY_MINBUF           0x00000080
#define LOGSESSION_DISPLAY_BUFFERSIZE       0x00000100
#define LOGSESSION_DISPLAY_DECAYTIME        0x00000200
#define LOGSESSION_DISPLAY_CIR              0x00000400
#define LOGSESSION_DISPLAY_SEQ              0x00000800
#define LOGSESSION_DISPLAY_NEWFILE          0x00001000
#define LOGSESSION_DISPLAY_GLOBALSEQ        0x00002000
#define LOGSESSION_DISPLAY_LOCALSEQ         0x00004000
#define LOGSESSION_DISPLAY_LEVEL            0x00008000

//
// Log session column numbers
//
typedef enum _LOG_SESSION_OPTIONS {
State=0,
EventCount,
LostEvents,
BuffersRead,
Flags,
FlushTime,
MaximumBuffers,
MinimumBuffers,
BufferSize,
DecayTime,
Circular,
Sequential,
NewFile,
GlobalSequence,
LocalSequence,
Level,
MaxLogSessionOptions
} LOG_SESSION_OPTIONS,*PLOG_SESSION_OPTIONS;

// Trace output display flags
// if we ever go over 32 items, we will just create 
// another set of 32 'extended' flags
#define TRACEOUTPUT_DISPLAY_PROVIDERNAME    0x00000001
#define TRACEOUTPUT_DISPLAY_FILENAME        0x00000002
#define TRACEOUTPUT_DISPLAY_LINENUMBER      0x00000004
#define TRACEOUTPUT_DISPLAY_FUNCTIONNAME    0x00000008
#define TRACEOUTPUT_DISPLAY_PROCESSID       0x00000010
#define TRACEOUTPUT_DISPLAY_THREADID        0x00000020
#define TRACEOUTPUT_DISPLAY_CPUNUMBER       0x00000040
#define TRACEOUTPUT_DISPLAY_SEQNUMBER       0x00000080
#define TRACEOUTPUT_DISPLAY_SYSTEMTIME      0x00000100
#define TRACEOUTPUT_DISPLAY_KERNELTIME      0x00000200
#define TRACEOUTPUT_DISPLAY_USERTIME        0x00000400
#define TRACEOUTPUT_DISPLAY_INDENT          0x00000800
#define TRACEOUTPUT_DISPLAY_FLAGSNAME       0x00001000
#define TRACEOUTPUT_DISPLAY_LEVELNAME       0x00002000
#define TRACEOUTPUT_DISPLAY_COMPNAME        0x00004000
#define TRACEOUTPUT_DISPLAY_SUBCOMPNAME     0x00008000
#define TRACEOUTPUT_DISPLAY_MESSAGE         0x00010000

// Trace output column numbers
typedef enum _TRACE_OUTPUT_COLUMNS {
ProviderName = 0,
FileName,
LineNumber,
FunctionName,
ProcessId,
ThreadId,
CpuNumber,
SeqNumber,
SystemTime,
KernelTime,
UserTime,
Indent,
FlagsName,
LevelName,
ComponentName,
SubComponentName,
Message,
MaxTraceSessionOptions
} TRACE_SESSION_OPTIONS,*PTRACE_SESSION_OPTIONS;

//
// Log session state values
//
typedef enum _LOG_SESSION_STATE {
Stopped=0,
Stopping,
Running, 
Existing,
Grouping,
UnGrouping
} LOG_SESSION_STATE,*PLOG_SESSION_STATE;

typedef struct _MOF_INFO
{
    LIST_ENTRY   Entry;
    LPTSTR       strDescription;
    ULONG        EventCount;            
    GUID         Guid;
    PLIST_ENTRY  ItemHeader;            
    LPTSTR       strType;
    LONG         TypeIndex;
    ULONG        TypeOfType;
    LPTSTR       TypeFormat;
    INT          Indent;
}  MOF_INFO, *PMOF_INFO;

typedef void (*PEND_TRACE_COMPLETE_CALLBACK)(PVOID pContext);

const ULONG CHAR_PIXELS_WIDTH   = 11;

const ULONG MAX_LOG_SESSIONS    = 64;

const ULONG EVENT_BUFFER_SIZE   = 32768;

const MAX_STR_LENGTH            = 1024;

const MAX_ENABLE_FLAGS          = 10;

const HDN_ITEMRCLICK            = (HDN_LAST - 1);

//
// Custom messages
//
CONST LONG WM_PARAMETER_CHANGED           = (WM_USER + 0x1000);
CONST LONG WM_USER_START_GROUP            = (WM_USER + 0x1001);
CONST LONG WM_USER_COMPLETE_GROUP         = (WM_USER + 0x1002);
CONST LONG WM_USER_START_UNGROUP          = (WM_USER + 0x1003);
CONST LONG WM_USER_COMPLETE_UNGROUP       = (WM_USER + 0x1004);
CONST LONG WM_USER_UPDATE_LOGSESSION_LIST = (WM_USER + 0x1005);
CONST LONG WM_USER_UPDATE_LOGSESSION_DATA = (WM_USER + 0x1006);
CONST LONG WM_USER_TRACE_DONE             = (WM_USER + 0x1007);
CONST LONG WM_USER_AUTOSIZECOLUMNS        = (WM_USER + 0x1008);


//
// Our trace event message formatting class
//
class CTraceMessage
{
public:
    CTraceMessage() {};
    ~CTraceMessage() {};

    GUID        m_TraceGuid;            // Message Guid
    CString     m_GuidName;             // %1   Guid Friendly Name  String
    CString     m_GuidTypeName;         // %2   Guid Type Name String
    ULONG       m_ThreadId;             // %3   Thread ID  Value
    SYSTEMTIME  m_SystemTime;           // %4   System Time Value
    ULONG       m_UserTime;             // %5   Kernel Time Value
    ULONG       m_KernelTime;           // %6   User Time Value
    ULONG       m_SequenceNum;          // %7   Sequence Number Value
    ULONG       m_ProcessId;            // %8   Process ID Value
    ULONG       m_CpuNumber;            // %9   CPU Number Value
    ULONG       m_Indent;               //  Indentation level Value
    CString     m_FlagsName;            //  Trace Flag settings Name String
    CString     m_LevelName;            //  Trace Level Name String
    CString     m_FunctionName;         //  Function Name String
    CString     m_ComponentName;        //  Component Name String
    CString     m_SubComponentName;     //  SubComponent Name String
    CString     m_Message;              //  Message String
};


// CTraceViewApp:
// See TraceView.cpp for the implementation of this class
//

class CTraceViewApp : public CWinApp
{
public:
	CTraceViewApp();

    ~CTraceViewApp();

    BOOL InitializeConsole();
    LONG CommandLine();
    LONG StartSession();
    LONG StopSession();
    LONG ListActiveSessions(BOOL bKill);
    LONG QueryActiveSession();
    LONG FlushActiveBuffers();
    LONG UpdateActiveSession();
    LONG EnumerateRegisteredGuids();
    LONG EnableProvider(BOOL bEnable);
    LONG ConsumeTraceEvents();
    LONG ExtractPdbInfo();
    void DisplayHelp();
    void PrintLoggerStatus(ULONG Status);
    LPCTSTR DecodeStatus(ULONG Status);
    LONG GetGuids(LPCTSTR GuidFile);
    void sync_with_stdio();
    void DisplayVersionInfo();
    BOOL CheckFile(LPTSTR fileName);

    static ULONG BufferCallback(PEVENT_TRACE_LOGFILE pLog);
    static void DumpEvent(PEVENT_TRACE pEvent);

    CTraceMessage *AllocateTraceEventBlock();
    void FreeTraceEventBlocks(CArray<CTraceMessage*, CTraceMessage*> &TraceArray);


// Overrides
public:
	virtual BOOL InitInstance();
    virtual int ExitInstance();
    virtual BOOL OnIdle(LONG lCount);

// Implementation

public:
	afx_msg void OnAppAbout();

    CString     m_traceDirectory;
    CArray<CTraceMessage*, CTraceMessage*> m_traceBlockArray;
    HANDLE      m_hTraceBlockMutex;

    //
    // member variables used for control command line interface
    //
    PEVENT_TRACE_PROPERTIES m_pLoggerInfo;
    CString         m_errorMsg;
    ULONG           m_globalLoggerStartValue;
    CStringArray    m_guidArray;
    BOOL            m_bCreatedConsole;

    //
    // member variables used for consumption command line interface
    //
    FILE       *m_pDumpFile;
    FILE       *m_pSummaryFile;
    BOOL        m_bDebugDisplay;
    BOOL        m_bDisplayOnly;
    BOOL        m_bSummaryOnly;
    BOOL        m_bNoSummary;
    BOOL        m_bVerbose;
    BOOL        m_bFixUp;
    BOOL        m_bODSOutput;
    BOOL        m_bTMFSpecified;
    BOOL        m_bCSVMode;
    BOOL        m_bNoCSVHeader;
    BOOL        m_bCSVHeader;
    TCHAR       m_summaryBlock[SIZESUMMARYBLOCK];
    PEVENT_TRACE_LOGFILE m_evmFile[MAXLOGFILES];
    ULONG       m_logFileCount;
    ULONG       m_userMode;
    TCHAR      *m_traceMask;
    TCHAR       m_eventBuf[SIZEEVENTBUF];
    BYTE        m_eventBufCSV[SIZEEVENTBUF * sizeof(TCHAR)];
    CHAR        m_eventBufA[SIZEEVENTBUF*sizeof(WCHAR)];
    FILETIME    m_lastTime;
    ULONG       m_totalBuffersRead;
    ULONG       m_totalEventsLost;
    ULONG       m_totalEventCount;
    ULONG       m_timerResolution;
    ULONG       m_bufferWrap;
    __int64     m_elapseTime;
    PLIST_ENTRY m_eventListHead;

	DECLARE_MESSAGE_MAP()
    afx_msg void OnHelpHelpTopics();
};

extern CTraceViewApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\traceview.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// TraceView.cpp : Defines the class behaviors for the application.
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <objbase.h>
#include <io.h>
#include <new.h>
#include <fcntl.h>
extern "C" {
#include <evntrace.h>
}
#include <traceprt.h>
#include <guiddef.h>
#include <wmiguid.h>
#include <iostream.h>
#include <ios>
#include <conio.h>
#include "TraceView.h"
#include "DockDialogBar.h"
#include "LogSession.h"
#include "DisplayDlg.h"
#include "ListCtrlEx.h"
#include "LogSessionDlg.h"
#include "MainFrm.h"
#include "htmlhelp.h"
#include "utils.h"
extern "C" {

#ifdef UNICODE
typedef 
ULONG
(*PFLUSH_TRACE_FUNC)(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

#else

typedef 
ULONG
(*PFLUSH_TRACE_FUNC)(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );
#endif

typedef 
ULONG
(*PENUMERATE_TRACE_GUIDS_FUNC)(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    );

PENUMERATE_TRACE_GUIDS_FUNC EnumerateTraceGuidsFunction = NULL;

PFLUSH_TRACE_FUNC FlushTraceFunction = NULL;
}

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//
// Global to this module
//
HINSTANCE advapidll=NULL;


// CTraceViewApp

BEGIN_MESSAGE_MAP(CTraceViewApp, CWinApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpHelpTopics)
    ON_COMMAND(ID_HELP, OnHelpHelpTopics)
END_MESSAGE_MAP()


// CTraceViewApp construction

CTraceViewApp::CTraceViewApp()
{
    m_globalLoggerStartValue = 0;
}

CTraceViewApp::~CTraceViewApp()
{
}

// The one and only CTraceViewApp object

CTraceViewApp theApp;


// CTraceViewApp initialization
BOOL CTraceViewApp::InitInstance()
{
    ULONG       length;
    CString     temp;
    GUID        directoryGuid;
    CString     str;
    STARTUPINFO startupInfo;

    //
    // Get the temp directory and save it
    //
    length = GetTempPath(0, NULL);

    m_traceDirectory.GetBuffer(MAX_PATH);

    if(length < GetTempPath(length, (LPTSTR)(LPCTSTR)m_traceDirectory)) {
        AfxMessageBox(_T("Failed To Create Temp Directory\nApplication Will Exit"));
        return FALSE;
    }

    //
    // make sure the directory exists
    //
    CreateDirectory(m_traceDirectory, NULL);

    //
    // I have to do this cast here
    // to get the string to allocate a new buffer
    // or the += operation below overwrites the 
    // existing buffer??
    //
    m_traceDirectory = (LPCTSTR)m_traceDirectory;

    //
    // create our own unique directory under the temp directory
    //
    if(S_OK != CoCreateGuid(&directoryGuid)) {
        AfxMessageBox(_T("Failed To Create Temp Directory\nApplication Will Exit"));
        return FALSE;
    }

    GuidToString(directoryGuid, temp);

    m_traceDirectory += (LPCTSTR)temp;

    m_traceDirectory += (LPCTSTR)_T("\\");

    if(!CreateDirectory(m_traceDirectory, NULL) && (GetLastError() != ERROR_ALREADY_EXISTS)) {
        AfxMessageBox(_T("Failed To Create Temp Directory\nApplication Will Exit"));
        return FALSE;
    }

    //
    // Initialize the trace block ready array mutex
    //
    m_hTraceBlockMutex = CreateMutex(NULL,TRUE,NULL);

    if(m_hTraceBlockMutex == NULL) {

        DWORD error = GetLastError();

        str.Format(_T("CreateMutex Error %d %x"),error,error);

        AfxMessageBox(str);

        return FALSE;
    }

    ReleaseMutex(m_hTraceBlockMutex);

    advapidll = LoadLibrary(_T("advapi32.dll"));

    if (advapidll != NULL) {
#ifdef UNICODE
            FlushTraceFunction = (PFLUSH_TRACE_FUNC)GetProcAddress(advapidll, "FlushTraceW");
#else
            FlushTraceFunction = GetProcAddress(advapidll, "FlushTraceA");
#endif
            EnumerateTraceGuidsFunction = (PENUMERATE_TRACE_GUIDS_FUNC)GetProcAddress(advapidll, "EnumerateTraceGuids");
    }

    //
    // Determine if this is a command line instance or a GUI instance
    //
    if(__argc > 1) {

        //
        // Hook up stdout, stdin, and stderr
        //
        InitializeConsole();

        CommandLine();

        return FALSE;
    }

    //
    // InitCommonControls() is required on Windows XP if an application
    // manifest specifies use of ComCtl32.dll version 6 or later to enable
    // visual styles.  Otherwise, any window creation will fail.
    //
    InitCommonControls();

    CWinApp::InitInstance();

    //
    // Initialize OLE libraries
    //
    if (!AfxOleInit())
    {
        AfxMessageBox(IDP_OLE_INIT_FAILED);
        return FALSE;
    }
    AfxEnableControlContainer();

    //
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    // of your final executable, you should remove from the following
    // the specific initialization routines you do not need
    // Change the registry key under which our settings are stored
    // TODO: You should modify this string to be something appropriate
    // such as the name of your company or organization
    //
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    //
    // To create the main window, this code creates a new frame window
    // object and then sets it as the application's main window object
    //
    CMainFrame* pFrame = new CMainFrame;
    m_pMainWnd = pFrame;

    //
    // create and load the frame with its resources
    //
    if (!pFrame->LoadFrame(IDR_MAINFRAME)) {
        return FALSE;
    }

    //
    // The one and only window has been initialized, so show and update it
    //
    pFrame->ShowWindow(SW_SHOW);
    pFrame->UpdateWindow();

    //
    // Set the icon
    //
    AfxGetMainWnd()->SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME), TRUE); 

    //
    // call DragAcceptFiles only if there's a suffix
    //  In an SDI app, this should occur after ProcessShellCommand
    //

    return TRUE;
}

int CTraceViewApp::ExitInstance() 
{
    CTraceMessage  *pTraceMessage = NULL;
    LONG            itemCount;

    //
    // Free the library we loaded earlier
    //
    FreeLibrary(advapidll);

    //
    // Free the trace block array
    //

    //
    // Get the free array protection
    //
    WaitForSingleObject(m_hTraceBlockMutex, INFINITE);

    itemCount = m_traceBlockArray.GetSize();

    ASSERT(itemCount == 0);

    for(LONG ii = 0; ii < itemCount; ii++) {
        //
        // delete the next entry in the list
        //
        delete m_traceBlockArray.GetAt(ii);
    }

    m_traceBlockArray.RemoveAll();

    //
    // Release the free array protection
    //
    ReleaseMutex(m_hTraceBlockMutex);

    //
    // Remove our temporary directory
    //
    if(!m_traceDirectory.IsEmpty()) {
        RemoveDirectory(m_traceDirectory);
    }

   return CWinApp::ExitInstance();
}

BOOL CTraceViewApp::InitializeConsole()
{
    BOOL    connected = FALSE;
    TCHAR   outputPipeName[256];
    TCHAR   inputPipeName[256];
    TCHAR   errorPipeName[256];

    //
    // Initialize our console creation flag
    //
    m_bCreatedConsole = FALSE;

    //
    // construct named pipe names
    //
    _stprintf(outputPipeName, 
              _T("\\\\.\\pipe\\%dcout"),
                GetCurrentProcessId());

    _stprintf(inputPipeName, 
              _T("\\\\.\\pipe\\%dcin"),
                GetCurrentProcessId() );

    _stprintf(errorPipeName, 
              _T("\\\\.\\pipe\\%dcerr"),
                GetCurrentProcessId() );

    //
    // attach named pipes to stdin/stdout/stderr
    //
    connected = (_tfreopen( outputPipeName, _T("a"), stdout ) != NULL) &&
                (_tfreopen( inputPipeName, _T("r"), stdin ) != NULL) &&
                (_tfreopen( errorPipeName, _T("a"), stderr ) != NULL);

    //
    // if unsuccessful, i.e. no console was available
    // we need to create a new console
    //
    if (!connected) {

        connected = AllocConsole();
        
        if (connected) {
            connected = (_tfreopen( _T("CONOUT$"), _T("a"), stdout ) != NULL) &&
                        (_tfreopen( _T("CONIN$"), _T("r"), stdin ) != NULL) &&
                        (_tfreopen( _T("CONERR$"), _T("a"), stderr ) != NULL); 

            //
            // Indicate that we created a new console
            //
            m_bCreatedConsole = TRUE;
        }
    }

    //
    // synchronize iostreams with standard io
    //
    if(connected) {
        std::ios_base::sync_with_stdio();
    }

    return connected;
}

LONG CTraceViewApp::CommandLine()
{
    CString str;
    LONG    argc = __argc;
    LPTSTR  loggerName;
    LONG    sizeNeeded;
    LONG    status = ERROR_INVALID_PARAMETER;


    //
    // dump all arguments
    //
    //for(LONG ii = 0; ii < argc; ii++) {
    //    str.Format(_T("%ls"), __wargv[ii]);
    //    AfxMessageBox(str);
    //}

    //AfxMessageBox(m_lpCmdLine);

    //
    // Initialize structure first
    //
    sizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAX_STR_LENGTH * sizeof(TCHAR);

    sizeNeeded += MAX_ENABLE_FLAGS * sizeof(ULONG); // for extension enable flags

    m_pLoggerInfo = (PEVENT_TRACE_PROPERTIES) new char[sizeNeeded];
    if (m_pLoggerInfo == NULL) {
        return (ERROR_OUTOFMEMORY);
    }

    RtlZeroMemory(m_pLoggerInfo, sizeNeeded);

    m_pLoggerInfo->Wnode.BufferSize = sizeNeeded;
    m_pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    m_pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    m_pLoggerInfo->LogFileNameOffset = m_pLoggerInfo->LoggerNameOffset + (MAX_STR_LENGTH * sizeof(TCHAR));

    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);
    _tcscpy(loggerName, KERNEL_LOGGER_NAME);

    if(!_tcscmp(__wargv[1], _T("-start") )) {
        status = StartSession();
    }

    if(!_tcscmp(__wargv[1], _T("-stop") )) {
        status = StopSession();
    }

    if(!_tcscmp(__wargv[1], _T("-update") )) {
        status = UpdateActiveSession();
    }

    if(!_tcscmp(__wargv[1], _T("-enable") )) {
        status = EnableProvider(TRUE);
    }

    if(!_tcscmp(__wargv[1], _T("-disable") )) {
        status = EnableProvider(FALSE);
    }

    if(!_tcscmp(__wargv[1], _T("-flush") )) {
        status = FlushActiveBuffers();
    }

    if(!_tcscmp(__wargv[1], _T("-enumguid") )) {
        status = EnumerateRegisteredGuids();
    }

    if(!_tcscmp(__wargv[1], _T("-q") )) {
        status = QueryActiveSession();
    }

    if(!_tcscmp(__wargv[1], _T("-l") )) {
        status = ListActiveSessions(FALSE);
    }

    if(!_tcscmp(__wargv[1], _T("-x") )) {
        status = ListActiveSessions(TRUE);
    }

    if(!_tcscmp(__wargv[1], _T("-process") )) {
        status = ConsumeTraceEvents();
    }

    if(!_tcscmp(__wargv[1], _T("-parsepdb") )) {
        status = ExtractPdbInfo();
    }

    if(status == ERROR_INVALID_PARAMETER) {
        DisplayHelp();
    }

    if(m_bCreatedConsole) {
        //
        // Prompt user for input so that the console doesn't
        // disappear before the user sees what it displays
        //
        _tprintf(_T("\n\nPress any key to exit\n"));

        _getch();
    }

    return status;
}

LONG CTraceViewApp::StartSession()
{
    CString     str;
    LPTSTR      loggerName = NULL;
    LPTSTR      logFileName;
    LONG        start = 2;
    LONG        status;
    TRACEHANDLE loggerHandle = 0;
    CString     guidFile;
    CString     pdbFile;
    CString     tmcPath;
    GUID        guid;
    LONG        guidCount = 0;
    ULONG       enableFlags = 0;
    ULONG       traceLevel = 0;
    ULONG       specialLogger = 0;
    USHORT      numberOfFlags = 0;
    USHORT      offset;
    PTRACE_ENABLE_FLAG_EXTENSION flagExt;
    PULONG      pFlags = NULL;
    LONG        i;
    CFileFind   fileFind;
    TCHAR       drive[10];
    TCHAR       path[MAXSTR];
    TCHAR       file[MAXSTR];
    TCHAR       ext[MAXSTR];



    pFlags = &m_pLoggerInfo->EnableFlags;

    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);
    logFileName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LogFileNameOffset);

    if((__argc > 2) && ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {
        _tcscpy(loggerName, __wargv[2]);

        start = 3;
    }

    for(LONG ii = start; ii < __argc; ii++) {
        //
        // Set the buffer size
        //
        if(!_tcscmp(__wargv[ii], _T("-b"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->BufferSize = _ttoi(__wargv[ii + 1]);
/*BUGBUG
                    if (kdOn && m_pLoggerInfo->BufferSize > 3) {
                        _tprintf(_T("Kernel Debugging has been enabled: Buffer size has been set to 3kBytes\n"));
                        m_pLoggerInfo->BufferSize = 3;
                    }
*/
                    ii++;
                }
            }
        }

        //
        // Set the minimum number of buffers
        //
        if(!_tcscmp(__wargv[ii], _T("-min"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->MinimumBuffers = _ttoi(__wargv[ii + 1]);
                    ii++;
                }
            }
        }

        //
        // Set the maximum number of buffers
        //
        if(!_tcscmp(__wargv[ii], _T("-max"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->MaximumBuffers = _ttoi(__wargv[ii + 1]);
                    ii++;
                }
            }
        }

        //
        // Set the log file name
        //
        if(!_tcscmp(__wargv[ii], _T("-f"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(logFileName, __wargv[ii + 1], MAX_STR_LENGTH);

                    ii++;
                }
            }
        }

        //
        // Set the log file append setting
        //
        if(!_tcscmp(__wargv[ii], _T("-append"))) {
            m_pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
        }

        //
        // Set the preallocate setting
        //
        if(!_tcscmp(__wargv[ii], _T("-prealloc"))) {
            m_pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_PREALLOCATE;
        }

        //
        // Set the sequential log file setting
        //
        if(!_tcscmp(__wargv[ii], _T("-seq"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
                    m_pLoggerInfo->MaximumFileSize = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the sequential log file setting
        //
        if(!_tcscmp(__wargv[ii], _T("-cir"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
                    m_pLoggerInfo->MaximumFileSize = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the new log file size setting
        //
        if(!_tcscmp(__wargv[ii], _T("-newfile"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_NEWFILE;
                    m_pLoggerInfo->MaximumFileSize = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the flush time setting
        //
        if(!_tcscmp(__wargv[ii], _T("-ft"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->FlushTimer = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the paged setting
        //
        if(!_tcscmp(__wargv[ii], _T("-paged"))) {
            m_pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY;
        }

        //
        // Get the control guid(s)
        //
        if(!_tcscmp(__wargv[ii], _T("-guid"))) {
            if((ii + 1) < __argc) {
                if(__wargv[ii + 1][0] == _T('#')) {
                    m_guidArray.Add(__wargv[ii + 1][1]);
                    guidCount++;
                } else if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(guidFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);
                    // _tprintf(_T("Getting guids from %s\n"), (LPCTSTR)guidFile);
                    guidCount += GetGuids(guidFile);
                    if (guidCount < 0) {
                        _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                    } else if (guidCount == 0){
                        _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }
                }
                ii++;
            }
        }

        //
        // Get the control guid(s) from a PDB file
        //
        if(!_tcscmp(__wargv[ii], _T("-pdb"))) {
            if(((ii + 1) < __argc) && 
               ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);

                pdbFile = (LPCTSTR)pdbFile;

                ParsePdb(pdbFile, m_traceDirectory, TRUE);

                _tprintf(_T("\n\n"));

                tmcPath = (LPCTSTR)m_traceDirectory;

                tmcPath +=_T("\\*.tmc");

                if(!fileFind.FindFile(tmcPath)) {
                    _tprintf(_T("Failed To Get Control GUID From PDB"));
                    return ERROR_INVALID_PARAMETER;
                } 

                while(fileFind.FindNextFile()) {
                    
                    tmcPath = fileFind.GetFileName();

                    _tsplitpath(tmcPath, drive, path, file, ext );

                    m_guidArray.Add(file);
                    guidCount++;
                }

                tmcPath = fileFind.GetFileName();

                _tsplitpath(tmcPath, drive, path, file, ext );

                m_guidArray.Add(file);

                guidCount++;

                if (guidCount < 0) {
                    _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                } else if (guidCount == 0){
                    _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                    status = ERROR_INVALID_PARAMETER;
                    return status;
                }
                ii++;
            }
        }

        //
        // Check for real-time setting
        //
        if(!_tcscmp(__wargv[ii], _T("-rt"))) {
            m_pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;

            //
            // Did the user specify buffering only?
            //
            if ((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    if (__wargv[ii + 1][0] == 'b')
                        m_pLoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
                        ii++;
                }
            }
        }

        //
        // Set the debug output setting
        //
        if(!_tcscmp(__wargv[ii], _T("-kd"))) {
            m_pLoggerInfo->LogFileMode |= EVENT_TRACE_KD_FILTER_MODE;
            m_pLoggerInfo->BufferSize = 3;
        }

        //
        // Set the age (decay time) setting
        //
        if(!_tcscmp(__wargv[ii], _T("-age"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->AgeLimit = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the level
        //
        if(!_tcscmp(__wargv[ii], _T("-level"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    traceLevel = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the flags
        //
        if((!_tcscmp(__wargv[ii], _T("-flag"))) || (!_tcscmp(__wargv[ii], _T("-flags")))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    //
                    // Get the flags specified, convert from hex if necessary
                    //
                    if(__wargv[ii + 1][1] == _T('x') || __wargv[ii + 1][1] == _T('X')) {
                        m_pLoggerInfo->EnableFlags |= ahextoi(__wargv[ii + 1]);
                    } else {
                        m_pLoggerInfo->EnableFlags |= _ttoi(__wargv[ii + 1]);
                    }

                    //
                    // Copy flags for EnableTrace
                    //
                    enableFlags =  m_pLoggerInfo->EnableFlags;

                    //
                    // Do not accept flags with MSB = 1.
                    //
                    if (0x80000000 & m_pLoggerInfo->EnableFlags) {
                        _tprintf(_T("Invalid Flags: 0x%0X(%d.)\n"),
                            m_pLoggerInfo->EnableFlags, m_pLoggerInfo->EnableFlags);
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }

                    ii++;
                }
            }
        }

        //
        // Set the eflags
        //
        if(!_tcscmp(__wargv[ii], _T("-eflag"))) {
            if((ii + 2) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    
                    numberOfFlags = (USHORT)_ttoi(__wargv[ii + 1]);

                    ii++;

                    if((numberOfFlags > MAX_ENABLE_FLAGS) || (numberOfFlags < 1)) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       status = ERROR_INVALID_PARAMETER;
                       return status;
                    }

                    offset = (USHORT) sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAX_STR_LENGTH * sizeof(TCHAR);

                    m_pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;

                    flagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &m_pLoggerInfo->EnableFlags;

                    flagExt->Offset = offset;

                    flagExt->Length = (UCHAR)numberOfFlags;

                    pFlags = (PULONG)(offset + (PCHAR) m_pLoggerInfo);

                    for (i = 0; ((i < numberOfFlags) && ((ii + 1) < __argc)); i++) {
                        if ((__wargv[ii + 1][0] == '-') || (__wargv[ii + 1][0] == '/')) {
                            //
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            //
                            break;
                        }

                        pFlags[i] = ahextoi(__wargv[ii + 1]);
                        ii++;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    numberOfFlags = (USHORT)i;
                    for ( ; i < MAX_ENABLE_FLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (flagExt->Length != (UCHAR)numberOfFlags) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        flagExt->Length = (UCHAR)numberOfFlags;
                    }
                }
            }
        }
    }


/*
    if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        if (GuidCount != 1) {
            _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
            return ERROR_INVALID_PARAMETER;
        }
        m_pLoggerInfo->Wnode.Guid = *GuidArray[0];
    }

    if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE  &&
        m_pLoggerInfo->MaximumFileSize == 0) {
        _tprintf(_T("Need file size for preallocated log file\n"));
        return ERROR_INVALID_PARAMETER;
    }
// end_sdk
    if (specialLogger == 3) {  // Global Logger
        status = SetGlobalLoggerSettings(1L, m_pLoggerInfo, m_pLoggerInfo->Wnode.ClientContext);
        if (status != ERROR_SUCCESS)
            break;
        status = GetGlobalLoggerSettings(m_pLoggerInfo, &m_pLoggerInfo->Wnode.ClientContext, &m_globalLoggerStartValue);
        break;
    }
// begin_sdk
    if(m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION){
        if(IsEqualGUID(&CritSecGuid,GuidArray[0]) ||
            IsEqualGUID(&HeapGuid,GuidArray[0])){
            m_pLoggerInfo->Wnode.HistoricalContext = traceLevel;
        }
    }
*/
    if (!_tcscmp(loggerName, _T("NT Kernel Logger"))) {
        if (pFlags == &m_pLoggerInfo->EnableFlags) {
                *pFlags |= EVENT_TRACE_FLAG_PROCESS;
                *pFlags |= EVENT_TRACE_FLAG_THREAD;
                *pFlags |= EVENT_TRACE_FLAG_DISK_IO;
                *pFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
        }

        m_pLoggerInfo->Wnode.Guid = SystemTraceControlGuid; // defaults to OS
    }

    //
    // Set the default log file name if necessary
    //
    if(!(m_pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        _tcscpy(logFileName, _T("C:\\LogFile.Etl"));
    }

    status = StartTrace(&loggerHandle, loggerName, m_pLoggerInfo);

    if (status != ERROR_SUCCESS) {
        _tprintf(_T("Could not start logger: %s\n") 
                    _T("Operation Status:       %uL\n"),
                    loggerName,
                    status);
    } else {
        _tprintf(_T("Logger Started...\n"));
    }

    PrintLoggerStatus(status);

    if((guidCount > 0) && (specialLogger == 0)) {
        _tprintf(_T("Enabling trace to logger %d\n"), loggerHandle);
        for(ULONG ii = 0; ii < (ULONG)guidCount; ii++) {
            //
            // Convert the guid string to a guid
            //
            StringToGuid(m_guidArray[ii].GetBuffer(0), &guid);

            //
            // Enable the provider
            //
            status = EnableTrace (
                            TRUE,
                            enableFlags,
                            traceLevel,
                            &guid,
                            loggerHandle);

            //
            // If the Guid can not be enabled, it is a benign 
            // failure. Print Warning message and continue. 
            //
            if (status == 4317) {
                _tprintf(_T("WARNING: Could not enable some guids.\n")); 
                _tprintf(_T("Check your Guids file\n")); 
                status = ERROR_SUCCESS;
            }

            if (status != ERROR_SUCCESS) {
                _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), ii);
                _tprintf(_T("Operation Status:       %uL\n"), status);
                _tprintf(_T("%s\n"),DecodeStatus(status));
                break;
            }
        }
    } else if (guidCount > 0) {
        _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
        status = ERROR_INVALID_PARAMETER;
    }

    return status;
}

LONG CTraceViewApp::StopSession()
{
    TRACEHANDLE loggerHandle = 0;
    LPTSTR      loggerName = NULL;
    LONG        start = 2;
    LONG        guidCount = 0;
    CString     guidFile;
    GUID        guid;
    LONG        status;
    CString     pdbFile;
    CString     tmcPath;
    CFileFind   fileFind;
    TCHAR       drive[10];
    TCHAR       path[MAXSTR];
    TCHAR       file[MAXSTR];
    TCHAR       ext[MAXSTR];

    //
    // Get the logger name string
    //
    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);

    if((__argc > 2) && ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {
        loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);

        _tcscpy(loggerName, __wargv[2]);

        start = 3;
    }

    for(LONG ii = start; ii < __argc; ii++) {
        //
        // Get the control guid(s)
        //
        if(!_tcscmp(__wargv[ii], _T("-guid"))) {
            if((ii + 1) < __argc) {
                if(__wargv[ii + 1][0] == _T('#')) {
                    m_guidArray.Add(__wargv[ii + 1][1]);
                    guidCount++;
                } else if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(guidFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);
                    // _tprintf(_T("Getting guids from %s\n"), (LPCTSTR)guidFile);
                    guidCount += GetGuids(guidFile);
                    if (guidCount < 0) {
                        _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                    } else if (guidCount == 0){
                        _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }
                }
                ii++;
            }
        }

        //
        // Get the control guid(s) from a PDB file
        //
        if(!_tcscmp(__wargv[ii], _T("-pdb"))) {
            if(((ii + 1) < __argc) && 
               ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);

                pdbFile = (LPCTSTR)pdbFile;

                ParsePdb(pdbFile, m_traceDirectory, TRUE);

                _tprintf(_T("\n\n"));

                tmcPath = (LPCTSTR)m_traceDirectory;

                tmcPath +=_T("\\*.tmc");

                if(!fileFind.FindFile(tmcPath)) {
                    _tprintf(_T("Failed To Get Control GUID From PDB"));
                    return ERROR_INVALID_PARAMETER;
                } 

                while(fileFind.FindNextFile()) {
                    
                    tmcPath = fileFind.GetFileName();

                    _tsplitpath(tmcPath, drive, path, file, ext );

                    m_guidArray.Add(file);
                    guidCount++;
                }

                tmcPath = fileFind.GetFileName();

                _tsplitpath(tmcPath, drive, path, file, ext );

                m_guidArray.Add(file);

                guidCount++;

                if (guidCount < 0) {
                    _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                } else if (guidCount == 0){
                    _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                    status = ERROR_INVALID_PARAMETER;
                    return status;
                }
                ii++;
            }
        }
    }
/*
    if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        if (guidCount != 1) {
            _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
        pLoggerInfo->Wnode.Guid = *m_guidArray[0];
    }

    if (specialLogger == 3)
        Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
*/

    if(guidCount > 0) {
/*
        if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
            Status = ControlTrace(loggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
            if (Status != ERROR_SUCCESS)
                break;
            loggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            Status = EnableTrace( FALSE,
                                    EVENT_TRACE_PRIVATE_LOGGER_MODE,
                                    0,
                                    m_guidArray[0],
                                    loggerHandle );
        }
        else {
*/
        status = ControlTrace(loggerHandle, 
                              loggerName, 
                              m_pLoggerInfo, 
                              EVENT_TRACE_CONTROL_QUERY);

        if(status == ERROR_WMI_INSTANCE_NOT_FOUND) {
            return status;
        }

        loggerHandle = m_pLoggerInfo->Wnode.HistoricalContext;

        for(ULONG i = 0; i < (ULONG)guidCount; i++) {

            //
            // Convert the string to a GUID
            //
            StringToGuid(m_guidArray[i].GetBuffer(0), &guid);

            EnableTrace(FALSE,
                        0,
                        0,
                        &guid,
                        loggerHandle);
        }

//        }
    }

    status = ControlTrace(loggerHandle, 
                          loggerName, 
                          m_pLoggerInfo, 
                          EVENT_TRACE_CONTROL_STOP);

    PrintLoggerStatus(status);

    return status;
}

LONG CTraceViewApp::ListActiveSessions(BOOL bKill)
{
    ULONG       returnCount ;
    ULONG       listSizeNeeded;
    PEVENT_TRACE_PROPERTIES pListLoggerInfo[MAX_LOG_SESSIONS];
    PEVENT_TRACE_PROPERTIES pStorage;
    PVOID       storage;
    LONG        status;
    TRACEHANDLE loggerHandle = 0;

    listSizeNeeded = MAX_LOG_SESSIONS * (sizeof(EVENT_TRACE_PROPERTIES)
                                + 2 * MAX_STR_LENGTH * sizeof(TCHAR));

    storage =  malloc(listSizeNeeded);
    if (storage == NULL) {
        status = ERROR_OUTOFMEMORY;
        return status;
    }
    RtlZeroMemory(storage, listSizeNeeded);

    pStorage = (PEVENT_TRACE_PROPERTIES)storage;
    for (ULONG i = 0; i < MAX_LOG_SESSIONS; i++) {
        pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)
                                    + 2 * MAX_STR_LENGTH * sizeof(TCHAR);
        pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                + MAX_STR_LENGTH * sizeof(TCHAR);
        pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        pListLoggerInfo[i] = pStorage;
        pStorage = (PEVENT_TRACE_PROPERTIES) (
                            (char*)pStorage + 
                            pStorage->Wnode.BufferSize);
    }
    
//    if (XP) {
        status = QueryAllTraces(pListLoggerInfo,
                                MAX_LOG_SESSIONS,
                                &returnCount);
/*
    }
    else {
        status = QueryAllTraces(pListLoggerInfo,
                                32,
                                &returnCount);
    }
*/

    if (status == ERROR_SUCCESS)
    {
        for (ULONG j = 0; j < returnCount; j++)
        {
            LPTSTR ListLoggerName;
            TCHAR asked = _T('?') ;
            BOOL StatusPrint = FALSE ;
            if (bKill)
            {

                ListLoggerName = (LPTSTR) ((char*)pListLoggerInfo[j] + 
                                pListLoggerInfo[j]->LoggerNameOffset);
/*
                if (!bForceKill) {
                    while (!(asked == _T('y')) && !(asked == _T('n'))) {
                        ULONG ReadChars = 0;
                        _tprintf(_T("Do you want to kill Logger \"%s\" (Y or N)?"), ListLoggerName);
                        ReadChars = _tscanf(_T(" %c"), &asked);
                        if (ReadChars == 0 || ReadChars == EOF) {
                            continue;
                        }
                        if (asked == _T('Y')) {
                            asked = _T('y') ;
                        } else if (asked == _T('N')) {
                            asked = _T('n') ;
                        }
                    }
                } else {
*/
                    asked = _T('y');
//                }
                if (asked == _T('y')) {
                    if (!IsEqualGUID(pListLoggerInfo[j]->Wnode.Guid,
                                     SystemTraceControlGuid))
                    {
                        loggerHandle = pListLoggerInfo[j]->Wnode.HistoricalContext;
                        status = EnableTrace(
                                    FALSE,
                                    (pListLoggerInfo[j]->LogFileMode &
                                            EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                        ? (EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                        : (0),
                                    0,
                                    & pListLoggerInfo[j]->Wnode.Guid,
                                    loggerHandle);
                    }
                    status = ControlTrace((TRACEHANDLE) 0,
                                    ListLoggerName,
                                    pListLoggerInfo[j],
                                    EVENT_TRACE_CONTROL_STOP);
                    _tprintf(_T("Logger \"%s\" has been killed\n"), ListLoggerName);
                    StatusPrint = TRUE ;
                } else {
                    _tprintf(_T("Logger \"%s\" has not been killed, current Status is\n"), ListLoggerName);
                    StatusPrint = FALSE ;
                }
            }

            m_pLoggerInfo = pListLoggerInfo[j];

            PrintLoggerStatus(status);

            _tprintf(_T("\n"));
        }
    }

    free(storage);

    return status;
}

LONG CTraceViewApp::QueryActiveSession()
{
    TRACEHANDLE loggerHandle = 0;
    LPTSTR      loggerName = NULL;
    LONG        start = 2;
    LONG        guidCount = 0;
    CString     guidFile;
    GUID        guid;
    LONG        status;
    CString     pdbFile;
    CString     tmcPath;
    CFileFind   fileFind;
    TCHAR       drive[10];
    TCHAR       path[MAXSTR];
    TCHAR       file[MAXSTR];
    TCHAR       ext[MAXSTR];

    //
    // Get the logger name string
    //
    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);

     if((__argc > 2) && ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {

        _tcscpy(loggerName, __wargv[2]);

        start = 3;
    }

    for(LONG ii = start; ii < __argc; ii++) {
        //
        // Get the control guid(s)
        //
        if(!_tcscmp(__wargv[ii], _T("-guid"))) {
            if((ii + 1) < __argc) {
                if(__wargv[ii + 1][0] == _T('#')) {
                    m_guidArray.Add(__wargv[ii + 1][1]);
                    guidCount++;
                } else if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(guidFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);
                    // _tprintf(_T("Getting guids from %s\n"), (LPCTSTR)guidFile);
                    guidCount += GetGuids(guidFile);
                    if (guidCount < 0) {
                        _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                    } else if (guidCount == 0){
                        _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }
                }
                ii++;
            }
        }

        //
        // Get the control guid(s) from a PDB file
        //
        if(!_tcscmp(__wargv[ii], _T("-pdb"))) {
            if(((ii + 1) < __argc) && 
               ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);

                pdbFile = (LPCTSTR)pdbFile;

                ParsePdb(pdbFile, m_traceDirectory, TRUE);

                _tprintf(_T("\n\n"));

                tmcPath = (LPCTSTR)m_traceDirectory;

                tmcPath +=_T("\\*.tmc");

                if(!fileFind.FindFile(tmcPath)) {
                    _tprintf(_T("Failed To Get Control GUID From PDB"));
                    return ERROR_INVALID_PARAMETER;
                } 

                while(fileFind.FindNextFile()) {
                    
                    tmcPath = fileFind.GetFileName();

                    _tsplitpath(tmcPath, drive, path, file, ext );

                    m_guidArray.Add(file);
                    guidCount++;
                }

                tmcPath = fileFind.GetFileName();

                _tsplitpath(tmcPath, drive, path, file, ext );

                m_guidArray.Add(file);

                guidCount++;

                if (guidCount < 0) {
                    _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                } else if (guidCount == 0){
                    _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                    status = ERROR_INVALID_PARAMETER;
                    return status;
                }
                ii++;
            }
        }
    }

    if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        if (guidCount != 1) {
            _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
            status = ERROR_INVALID_PARAMETER;
            return status;
        }

        StringToGuid(m_guidArray[0].GetBuffer(0), &guid);

        m_pLoggerInfo->Wnode.Guid = guid;
    }
/*
    if (specialLogger == 3) {
        status = GetGlobalLoggerSettings(m_pLoggerInfo, &m_pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
    }
*/
    status = ControlTrace(loggerHandle, loggerName, m_pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);

    PrintLoggerStatus(status);

    return status;
}

LONG CTraceViewApp::FlushActiveBuffers()
{
    TRACEHANDLE loggerHandle = 0;
    LPTSTR      loggerName = NULL;
    LONG        start = 2;
    LONG        guidCount = 0;
    CString     guidFile;
    GUID        guid;
    LONG        status;
    CString     pdbFile;
    CString     tmcPath;
    CFileFind   fileFind;
    TCHAR       drive[10];
    TCHAR       path[MAXSTR];
    TCHAR       file[MAXSTR];
    TCHAR       ext[MAXSTR];

    //
    // Get the logger name string
    //
    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);

     if((__argc > 2) && ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {

        _tcscpy(loggerName, __wargv[2]);

        start = 3;
    }

    for(LONG ii = start; ii < __argc; ii++) {
        //
        // Get the control guid(s)
        //
        if(!_tcscmp(__wargv[ii], _T("-guid"))) {
            if((ii + 1) < __argc) {
                if(__wargv[ii + 1][0] == _T('#')) {
                    m_guidArray.Add(__wargv[ii + 1][1]);
                    guidCount++;
                } else if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(guidFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);
                    // _tprintf(_T("Getting guids from %s\n"), (LPCTSTR)guidFile);
                    guidCount += GetGuids(guidFile);
                    if (guidCount < 0) {
                        _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                    } else if (guidCount == 0){
                        _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }
                }
                ii++;
            }
        }

        //
        // Get the control guid(s) from a PDB file
        //
        if(!_tcscmp(__wargv[ii], _T("-pdb"))) {
            if(((ii + 1) < __argc) && 
               ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);

                pdbFile = (LPCTSTR)pdbFile;

                ParsePdb(pdbFile, m_traceDirectory, TRUE);

                _tprintf(_T("\n\n"));

                tmcPath = (LPCTSTR)m_traceDirectory;

                tmcPath +=_T("\\*.tmc");

                if(!fileFind.FindFile(tmcPath)) {
                    _tprintf(_T("Failed To Get Control GUID From PDB"));
                    return ERROR_INVALID_PARAMETER;
                } 

                while(fileFind.FindNextFile()) {
                    
                    tmcPath = fileFind.GetFileName();

                    _tsplitpath(tmcPath, drive, path, file, ext );

                    m_guidArray.Add(file);
                    guidCount++;
                }

                tmcPath = fileFind.GetFileName();

                _tsplitpath(tmcPath, drive, path, file, ext );

                m_guidArray.Add(file);

                guidCount++;

                if (guidCount < 0) {
                    _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                } else if (guidCount == 0){
                    _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                    status = ERROR_INVALID_PARAMETER;
                    return status;
                }
                ii++;
            }
        }
    }

    if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        if(guidCount != 1) {
            _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
            status = ERROR_INVALID_PARAMETER;
            return status;
        }

        StringToGuid(m_guidArray[0].GetBuffer(0), &guid);

        m_pLoggerInfo->Wnode.Guid = guid;
    }

//    status = (ULONG)FlushTrace(loggerHandle, loggerName, m_pLoggerInfo);
    status = 1;

    if(FlushTraceFunction)  {
        
        status = (ULONG)(FlushTraceFunction)(loggerHandle, loggerName, m_pLoggerInfo);

        PrintLoggerStatus(status);
    }
    return status;
}

LONG CTraceViewApp::UpdateActiveSession()
{
    TRACEHANDLE loggerHandle = 0;
    LPTSTR      loggerName = NULL;
    LPTSTR      logFileName = NULL;
    LONG        start = 2;
    LONG        guidCount = 0;
    CString     guidFile;
    GUID        guid;
    LONG        status;
    ULONG       enableFlags = 0;
    ULONG       specialLogger = 0;
    USHORT      numberOfFlags = 0;
    USHORT      offset;
    PTRACE_ENABLE_FLAG_EXTENSION flagExt;
    PULONG      pFlags = NULL;
    LONG        i;
    CString     pdbFile;
    CString     tmcPath;
    CFileFind   fileFind;
    TCHAR       drive[10];
    TCHAR       path[MAXSTR];
    TCHAR       file[MAXSTR];
    TCHAR       ext[MAXSTR];

    //
    // Get the logger name string
    //
    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);
    logFileName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LogFileNameOffset);

    //
    // Get the logger name
    //
     if((__argc > 2) && ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {

        _tcscpy(loggerName, __wargv[2]);

        start = 3;
    }

    for(LONG ii = start; ii < __argc; ii++) {
        //
        // Set the maximum number of buffers
        //
        if(!_tcscmp(__wargv[ii], _T("-max"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->MaximumBuffers = _ttoi(__wargv[ii + 1]);
                    ii++;
                }
            }
        }

        //
        // Set the log file name
        //
        if(!_tcscmp(__wargv[ii], _T("-f"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(logFileName, __wargv[ii + 1], MAX_STR_LENGTH);

                    ii++;
                }
            }
        }

        //
        // Set the flush time setting
        //
        if(!_tcscmp(__wargv[ii], _T("-ft"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    m_pLoggerInfo->FlushTimer = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Get the control guid(s)
        //
        if(!_tcscmp(__wargv[ii], _T("-guid"))) {
            if((ii + 1) < __argc) {
                if(__wargv[ii + 1][0] == _T('#')) {
                    m_guidArray.Add(__wargv[ii + 1][1]);
                    guidCount++;
                } else if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(guidFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);
                    // _tprintf(_T("Getting guids from %s\n"), (LPCTSTR)guidFile);
                    guidCount += GetGuids(guidFile);
                    if (guidCount < 0) {
                        _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                    } else if (guidCount == 0){
                        _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }
                }
                ii++;
            }
        }

        //
        // Get the control guid(s) from a PDB file
        //
        if(!_tcscmp(__wargv[ii], _T("-pdb"))) {
            if(((ii + 1) < __argc) && 
               ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);

                pdbFile = (LPCTSTR)pdbFile;

                ParsePdb(pdbFile, m_traceDirectory, TRUE);

                _tprintf(_T("\n\n"));

                tmcPath = (LPCTSTR)m_traceDirectory;

                tmcPath +=_T("\\*.tmc");

                if(!fileFind.FindFile(tmcPath)) {
                    _tprintf(_T("Failed To Get Control GUID From PDB"));
                    return ERROR_INVALID_PARAMETER;
                } 

                while(fileFind.FindNextFile()) {
                    
                    tmcPath = fileFind.GetFileName();

                    _tsplitpath(tmcPath, drive, path, file, ext );

                    m_guidArray.Add(file);
                    guidCount++;
                }

                tmcPath = fileFind.GetFileName();

                _tsplitpath(tmcPath, drive, path, file, ext );

                m_guidArray.Add(file);

                guidCount++;

                if (guidCount < 0) {
                    _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                } else if (guidCount == 0){
                    _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                    status = ERROR_INVALID_PARAMETER;
                    return status;
                }
                ii++;
            }
        }

        //
        // Check for real-time setting
        //
        if(!_tcscmp(__wargv[ii], _T("-rt"))) {
            m_pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;

            //
            // Did the user specify buffering only?
            //
            if ((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    if (__wargv[ii + 1][0] == 'b')
                        m_pLoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
                        ii++;
                }
            }
        }

        //
        // Set the flags
        //
        if((!_tcscmp(__wargv[ii], _T("-flag"))) || (!_tcscmp(__wargv[ii], _T("-flags")))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    //
                    // Get the flags specified, convert from hex if necessary
                    //
                    if(__wargv[ii + 1][1] == _T('x') || __wargv[ii + 1][1] == _T('X')) {
                        m_pLoggerInfo->EnableFlags |= ahextoi(__wargv[ii + 1]);
                    } else {
                        m_pLoggerInfo->EnableFlags |= _ttoi(__wargv[ii + 1]);
                    }

                    //
                    // Copy flags for EnableTrace
                    //
                    enableFlags =  m_pLoggerInfo->EnableFlags;

                    //
                    // Do not accept flags with MSB = 1.
                    //
                    if (0x80000000 & m_pLoggerInfo->EnableFlags) {
                        _tprintf(_T("Invalid Flags: 0x%0X(%d.)\n"),
                            m_pLoggerInfo->EnableFlags, m_pLoggerInfo->EnableFlags);
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }

                    ii++;
                }
            }
        }

        //
        // Set the eflags
        //
        if(!_tcscmp(__wargv[ii], _T("-eflag"))) {
            if((ii + 2) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    
                    numberOfFlags = (USHORT)_ttoi(__wargv[ii + 1]);

                    ii++;

                    if((numberOfFlags > MAX_ENABLE_FLAGS) || (numberOfFlags < 1)) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       status = ERROR_INVALID_PARAMETER;
                       return status;
                    }

                    offset = (USHORT) sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAX_STR_LENGTH * sizeof(TCHAR);

                    m_pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;

                    flagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &m_pLoggerInfo->EnableFlags;

                    flagExt->Offset = offset;

                    flagExt->Length = (UCHAR)numberOfFlags;

                    pFlags = (PULONG)(offset + (PCHAR) m_pLoggerInfo);

                    for (i = 0; ((i < numberOfFlags) && ((ii + 1) < __argc)); i++) {
                        if ((__wargv[ii + 1][0] == '-') || (__wargv[ii + 1][0] == '/')) {
                            //
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            //
                            break;
                        }

                        pFlags[i] = ahextoi(__wargv[ii + 1]);
                        ii++;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    numberOfFlags = (USHORT)i;
                    for ( ; i < MAX_ENABLE_FLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (flagExt->Length != (UCHAR)numberOfFlags) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        flagExt->Length = (UCHAR)numberOfFlags;
                    }
                }
            }
        }
    }

    if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        if (guidCount != 1) {
            _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
            status = ERROR_INVALID_PARAMETER;
            return status;
        }

        StringToGuid(m_guidArray[0].GetBuffer(0), &guid);

        m_pLoggerInfo->Wnode.Guid = guid;
    }

/*
    if (specialLogger == 3) {
        status = GetGlobalLoggerSettings(m_pLoggerInfo, &m_pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
    }
*/

    status = ControlTrace(loggerHandle, loggerName, m_pLoggerInfo, EVENT_TRACE_CONTROL_UPDATE);

    PrintLoggerStatus(status);

    return status;
}

LONG CTraceViewApp::EnumerateRegisteredGuids()
{
    ULONG   propertyArrayCount = 10;
    PTRACE_GUID_PROPERTIES  *guidPropertiesArray;
    ULONG   enumGuidCount;
    ULONG   sizeStorage;
    PVOID   storageNeeded;
    PTRACE_GUID_PROPERTIES cleanStorage;
    CString str;
    LONG    status;
    ULONG   i;


Retry:
    sizeStorage = propertyArrayCount * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));
    storageNeeded =  malloc(sizeStorage);
    if(storageNeeded == NULL) {
        status = ERROR_OUTOFMEMORY;

        return status;
    }
    
    RtlZeroMemory(storageNeeded, sizeStorage);
    guidPropertiesArray = (PTRACE_GUID_PROPERTIES *)storageNeeded;
    cleanStorage = (PTRACE_GUID_PROPERTIES)((char*)storageNeeded + propertyArrayCount * sizeof(PTRACE_GUID_PROPERTIES));
    for(i = 0; i < propertyArrayCount; i++) {
        guidPropertiesArray[i] = cleanStorage;
        cleanStorage = (PTRACE_GUID_PROPERTIES) (
                            (char*)cleanStorage + sizeof(TRACE_GUID_PROPERTIES)
                            );
    }

//
// V1.0 Note: We are deliberately "breaking" things here, so that
// TraceView will NOT be able to load in Windows 2000.  This is because
// very last minute testing indicated that TraceView did not work
// properly on Win2K.  This will take some investigating, so the
// work to support Win2K is deferred to a later release.
// (see companion "V1.0 NOTE" in the code below)
//
    status = EnumerateTraceGuids(guidPropertiesArray,
                                 propertyArrayCount,
                                 &enumGuidCount);
//
// See V1.0 NOTE, above
//
//    if(EnumerateTraceGuidsFunction)  {
//
//        status = (EnumerateTraceGuidsFunction)(guidPropertiesArray,
//                                     propertyArrayCount,
//                                     &enumGuidCount);
        if(status == ERROR_MORE_DATA)
        {
            propertyArrayCount = enumGuidCount;
            free(storageNeeded);
            goto Retry;

        }
//
// (see V1.0 NOTE above)
//
//    } else  {
//        
//        _tprintf(_T("not supported on Win2K\n"));
//        status = 1;
//
//        return status;
//    }

    //
    // print the GUID_PROPERTIES and Free Strorage
    //
    _tprintf(_T("    Guid                     Enabled  LoggerId Level Flags\n"));
    _tprintf(_T("----------------------------------------------------------\n"));
    for (i=0; i < enumGuidCount; i++) {

        GuidToString(guidPropertiesArray[i]->Guid, str);

        _tprintf(_T("%s     %5s  %d    %d    %d\n"),
                                    (LPCTSTR)str, 
                                    (guidPropertiesArray[i]->IsEnable) ? _T("TRUE") : _T("FALSE"),
                                    guidPropertiesArray[i]->LoggerId,
                                    guidPropertiesArray[i]->EnableLevel,
                                    guidPropertiesArray[i]->EnableFlags);
    }
    free(storageNeeded);

    return status;
}

LONG CTraceViewApp::EnableProvider(BOOL bEnable)
{
    TRACEHANDLE loggerHandle = 0;
    LPTSTR      loggerName = NULL;
    LPTSTR      logFileName = NULL;
    LONG        start = 2;
    LONG        guidCount = 0;
    CString     guidFile;
    GUID        guid;
    LONG        status;
    ULONG       enableFlags = 0;
    ULONG       traceLevel = 0;
    ULONG       specialLogger = 0;
    USHORT      numberOfFlags = 0;
    USHORT      offset;
    PTRACE_ENABLE_FLAG_EXTENSION flagExt;
    PULONG      pFlags = NULL;
    LONG        i;
    CString     pdbFile;
    CString     tmcPath;
    CFileFind   fileFind;
    TCHAR       drive[10];
    TCHAR       path[MAXSTR];
    TCHAR       file[MAXSTR];
    TCHAR       ext[MAXSTR];

    //
    // Get the logger name string
    //
    loggerName = (LPTSTR)((char*)m_pLoggerInfo + m_pLoggerInfo->LoggerNameOffset);

    //
    // Get the logger name
    //
     if((__argc > 2) && ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {

        _tcscpy(loggerName, __wargv[2]);

        start = 3;
    }

    for(LONG ii = start; ii < __argc; ii++) {
        //
        // Get the control guid(s)
        //
        if(!_tcscmp(__wargv[ii], _T("-guid"))) {
            if((ii + 1) < __argc) {
                if(__wargv[ii + 1][0] == _T('#')) {
                    m_guidArray.Add(__wargv[ii + 1][1]);
                    guidCount++;
                } else if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    _tfullpath(guidFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);
                    // _tprintf(_T("Getting guids from %s\n"), (LPCTSTR)guidFile);
                    guidCount += GetGuids(guidFile);
                    if (guidCount < 0) {
                        _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                    } else if (guidCount == 0){
                        _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }
                }
                ii++;
            }
        }

        //
        // Get the control guid(s) from a PDB file
        //
        if(!_tcscmp(__wargv[ii], _T("-pdb"))) {
            if(((ii + 1) < __argc) && 
               ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), __wargv[ii + 1], MAX_STR_LENGTH);

                pdbFile = (LPCTSTR)pdbFile;

                ParsePdb(pdbFile, m_traceDirectory, TRUE);

                _tprintf(_T("\n\n"));

                tmcPath = (LPCTSTR)m_traceDirectory;

                tmcPath +=_T("\\*.tmc");

                if(!fileFind.FindFile(tmcPath)) {
                    _tprintf(_T("Failed To Get Control GUID From PDB"));
                    return ERROR_INVALID_PARAMETER;
                } 

                while(fileFind.FindNextFile()) {
                    
                    tmcPath = fileFind.GetFileName();

                    _tsplitpath(tmcPath, drive, path, file, ext );

                    m_guidArray.Add(file);
                    guidCount++;
                }

                tmcPath = fileFind.GetFileName();

                _tsplitpath(tmcPath, drive, path, file, ext );

                m_guidArray.Add(file);

                guidCount++;

                if (guidCount < 0) {
                    _tprintf( _T("Error: %ls does not exist\n"), (LPCTSTR)guidFile );
                } else if (guidCount == 0){
                    _tprintf( _T("Error: %ls is invalid\n"), (LPCTSTR)guidFile );
                    status = ERROR_INVALID_PARAMETER;
                    return status;
                }
                ii++;
            }
        }

        //
        // Set the level
        //
        if(!_tcscmp(__wargv[ii], _T("-level"))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    traceLevel = _ttoi(__wargv[ii + 1]);

                    ii++;
                }
            }
        }

        //
        // Set the flags
        //
        if((!_tcscmp(__wargv[ii], _T("-flag"))) || (!_tcscmp(__wargv[ii], _T("-flags")))) {
            if((ii + 1) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    //
                    // Get the flags specified, convert from hex if necessary
                    //
                    if(__wargv[ii + 1][1] == _T('x') || __wargv[ii + 1][1] == _T('X')) {
                        m_pLoggerInfo->EnableFlags |= ahextoi(__wargv[ii + 1]);
                    } else {
                        m_pLoggerInfo->EnableFlags |= _ttoi(__wargv[ii + 1]);
                    }

                    //
                    // Copy flags for EnableTrace
                    //
                    enableFlags =  m_pLoggerInfo->EnableFlags;

                    //
                    // Do not accept flags with MSB = 1.
                    //
                    if (0x80000000 & m_pLoggerInfo->EnableFlags) {
                        _tprintf(_T("Invalid Flags: 0x%0X(%d.)\n"),
                            m_pLoggerInfo->EnableFlags, m_pLoggerInfo->EnableFlags);
                        status = ERROR_INVALID_PARAMETER;
                        return status;
                    }

                    ii++;
                }
            }
        }

        //
        // Set the eflags
        //
        if(!_tcscmp(__wargv[ii], _T("-eflag"))) {
            if((ii + 2) < __argc) {
                if((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/')) {
                    
                    numberOfFlags = (USHORT)_ttoi(__wargv[ii + 1]);

                    ii++;

                    if((numberOfFlags > MAX_ENABLE_FLAGS) || (numberOfFlags < 1)) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       status = ERROR_INVALID_PARAMETER;
                       return status;
                    }

                    offset = (USHORT) sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAX_STR_LENGTH * sizeof(TCHAR);

                    m_pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;

                    flagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &m_pLoggerInfo->EnableFlags;

                    flagExt->Offset = offset;

                    flagExt->Length = (UCHAR)numberOfFlags;

                    pFlags = (PULONG)(offset + (PCHAR) m_pLoggerInfo);

                    for (i = 0; ((i < numberOfFlags) && ((ii + 1) < __argc)); i++) {
                        if ((__wargv[ii + 1][0] == '-') || (__wargv[ii + 1][0] == '/')) {
                            //
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            //
                            break;
                        }

                        pFlags[i] = ahextoi(__wargv[ii + 1]);
                        ii++;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    numberOfFlags = (USHORT)i;
                    for ( ; i < MAX_ENABLE_FLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (flagExt->Length != (UCHAR)numberOfFlags) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        flagExt->Length = (UCHAR)numberOfFlags;
                    }
                }
            }
        }
    }

    if(m_pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        if(guidCount != 1) {
            _tprintf(_T("Need one GUID for PRIVATE loggers\n"));
            status = ERROR_INVALID_PARAMETER;
            return status;
        }

        StringToGuid(m_guidArray[0].GetBuffer(0), &guid);

        m_pLoggerInfo->Wnode.Guid = guid;
    }

    status = ControlTrace((TRACEHANDLE) 0, loggerName, m_pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
    if(status != ERROR_SUCCESS) {
/*
        if( IsEqualGUID(&HeapGuid,&m_pLoggerInfo->Wnode.Guid) 
        || IsEqualGUID(&CritSecGuid,&m_pLoggerInfo->Wnode.Guid) 
        ){
            //do nothing 
        } else {
*/
            _tprintf( _T("ERROR: Logger not started\n")
                        _T("Operation Status:    %uL\n")
                        _T("%s\n"),
                        status,
                        DecodeStatus(status));
            return status;
//        }
    }

    loggerHandle = m_pLoggerInfo->Wnode.HistoricalContext;

    if((guidCount > 0) && (specialLogger == 0)) {
        _tprintf(_T("Enabling trace to logger %d\n"), loggerHandle);
        for(i = 0; i < (ULONG)guidCount; i++) {

            StringToGuid(m_guidArray[i].GetBuffer(0), &guid);

            status = EnableTrace (
                            bEnable,
                            enableFlags,
                            traceLevel,
                            &guid,
                            loggerHandle);

            //
            // If the Guid can not be enabled, it is a benign 
            // failure. Print Warning message and continue. 
            //
            if(status == 4317) {
                _tprintf(_T("WARNING: Could not enable some guids.\n")); 
                _tprintf(_T("Check your Guids file\n")); 
                status = ERROR_SUCCESS;
            }

            if(status != ERROR_SUCCESS) {
                _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), i);
                _tprintf(_T("Operation Status:       %uL\n"), status);
                _tprintf(_T("%s\n"),DecodeStatus(status));
                return status;
            }
        }
    } else if(guidCount > 0) {
        _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
        status = ERROR_INVALID_PARAMETER;
    }

    PrintLoggerStatus(status);

    return status;
}

LONG CTraceViewApp::ConsumeTraceEvents()
{
    TCHAR   guidFileName[MAXSTR];
    TCHAR   dumpFileName[MAXSTR];
    TCHAR   summaryFileName[MAXSTR];
    LPTSTR *commandLine;
    LPTSTR *targv;
    LPTSTR *cmdargv;
    LONG    argc;
    PEVENT_TRACE_LOGFILE pLogFile;
    ULONG   status;
    ULONG   guidCount = 0;
    ULONG   i;
    ULONG   j;
    TRACEHANDLE handleArray[MAXLOGFILES];
    CString pdbFile;
    CString formatOptions;

    //
    // initialize member variables
    //
    m_pDumpFile = NULL;
    m_pSummaryFile = NULL;
    m_bDebugDisplay = FALSE ;
    m_bDisplayOnly  = FALSE ;
    m_bSummaryOnly  = FALSE ;
    m_bNoSummary    = FALSE ;
    m_bVerbose      = FALSE ;
    m_bFixUp        = FALSE ;
    m_bODSOutput    = FALSE ;
    m_bTMFSpecified = FALSE ;
    m_bCSVMode      = FALSE ;
    m_bNoCSVHeader  = TRUE ;
    m_bCSVHeader    = FALSE ;
    m_totalBuffersRead = 0;
    m_totalEventsLost = 0;
    m_totalEventCount = 0;
    m_timerResolution = 10;
    m_bufferWrap = 0 ;
    m_eventListHead = NULL;
    m_logFileCount = 0;
    m_userMode = FALSE; // TODO: Pick this up from the stream itself.
    m_traceMask = NULL;

    targv = __wargv;
    argc = __argc;

    _tcscpy(dumpFileName, _T("FmtFile.txt"));
    _tcscpy(summaryFileName, _T("FmtSum.txt"));

    // By default look for Define.guid in the image location

    if ((status = GetModuleFileName(NULL, guidFileName, MAXSTR)) == MAXSTR) {
        guidFileName[MAXSTR-1] = _T('\0');
    }

    if( status != 0 ){
        TCHAR drive[10];
        TCHAR path[MAXSTR];
        TCHAR file[MAXSTR];
        TCHAR ext[MAXSTR];

        _tsplitpath( guidFileName, drive, path, file, ext );
        _tcscpy(ext, GUID_EXT );
        _tcscpy(file, GUID_FILE );
        _tmakepath( guidFileName, drive, path, file, ext );
    }else{
        _tcscpy( guidFileName, GUID_FILE );
        _tcscat( guidFileName, _T(".") );
        _tcscat( guidFileName, GUID_EXT );
    }

    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if( **targv == '/' ){
                **targv = '-';
            }
           else if (!_tcsicmp(targv[0], _T("-debug"))) {
               m_bDebugDisplay = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-display"))) {
               m_bDebugDisplay = TRUE ;
           }
           else if (!_tcsicmp(targv[0], _T("-displayonly"))) {
               m_bDisplayOnly = TRUE ;
           }
           else if (!_tcsicmp(targv[0], _T("-fixup"))) {
               m_bFixUp = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-summary"))) {
               m_bSummaryOnly = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-seq"))) {
               SetTraceFormatParameter(ParameterSEQUENCE, ULongToPtr(1));
           }
           else if (!_tcsicmp(targv[0], _T("-gmt"))) {
               SetTraceFormatParameter(ParameterGMT, ULongToPtr(1));
           }
           else if (!_tcsicmp(targv[0], _T("-utc"))) {
               SetTraceFormatParameter(ParameterGMT, ULongToPtr(1));
           } else if (!_tcsicmp(targv[0], _T("-nosummary"))) {
               m_bNoSummary = TRUE;
           } else if (!_tcsicmp(targv[0], _T("-csv"))) {
               m_bCSVMode = TRUE ;
               m_bCSVHeader = TRUE ;
               SetTraceFormatParameter(ParameterStructuredFormat,UlongToPtr(1));
           } else if (!_tcsicmp(targv[0], _T("-nocsvheader"))) {
               m_bNoCSVHeader = FALSE ;
           }
           else if (!_tcsicmp(targv[0], _T("-noprefix"))) {
               SetTraceFormatParameter(ParameterUsePrefix,UlongToPtr(0));
           }
           else if (!_tcsicmp(targv[0], _T("-rt"))) {
               TCHAR LoggerName[MAXSTR];
               _tcscpy(LoggerName, KERNEL_LOGGER_NAME);
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; 
                        --argc;
                        _tcscpy(LoggerName, targv[0]);
                   }
               }
               
               pLogFile = (PEVENT_TRACE_LOGFILE)malloc(sizeof(EVENT_TRACE_LOGFILE));
               if (pLogFile == NULL){
                   _tprintf(_T("Allocation Failure\n"));
                   
                   goto cleanup;
               }
               RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
               m_evmFile[m_logFileCount] = pLogFile;
               
               m_evmFile[m_logFileCount]->LogFileName = NULL;
               m_evmFile[m_logFileCount]->LoggerName =
                   (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
               
               if ( m_evmFile[m_logFileCount]->LoggerName == NULL ) {
                   _tprintf(_T("Allocation Failure\n"));
                   goto cleanup;
               }
               _tcscpy(m_evmFile[m_logFileCount]->LoggerName, LoggerName);
               
               _tprintf(_T("Setting RealTime mode for  %s\n"),
                        m_evmFile[m_logFileCount]->LoggerName);
               
               m_evmFile[m_logFileCount]->Context = NULL;
               m_evmFile[m_logFileCount]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)BufferCallback;
               m_evmFile[m_logFileCount]->BuffersRead = 0;
               m_evmFile[m_logFileCount]->CurrentTime = 0;
               m_evmFile[m_logFileCount]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
               m_evmFile[m_logFileCount]->LogFileMode =
                   EVENT_TRACE_REAL_TIME_MODE;
               m_logFileCount++;
            }
            else if ( !_tcsicmp(targv[0], _T("-guid")) ) {    // maintain for compatabillity
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tcscpy(guidFileName, targv[1]);
                        ++targv; --argc;
                        m_bTMFSpecified = TRUE ;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-tmf")) ) { 
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tcscpy(guidFileName, targv[1]);
                        ++targv; --argc;
                        m_bTMFSpecified = TRUE ;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-pdb")) ) { 
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tfullpath(pdbFile.GetBuffer(MAX_STR_LENGTH), targv[1], MAX_STR_LENGTH);

                        pdbFile = (LPCTSTR)pdbFile;

                        if(ParsePdb(pdbFile, m_traceDirectory, TRUE)) {
                            SetTraceFormatParameter(ParameterTraceFormatSearchPath, 
                                                    m_traceDirectory.GetBuffer(0));
                        }

                        ++targv; 
                        --argc;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-p")) ){
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        SetTraceFormatParameter(ParameterTraceFormatSearchPath, targv[1]);
                        ++targv; --argc;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-format")) ) { 
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {

                        for(LONG ii = 0; ii < _tcslen(targv[1]); ii++) {
                            switch(targv[1][ii]) {
                                case 'n':
                                    formatOptions += _T("%1!s! ");
                                    break;
                                case 'w':
                                    formatOptions += _T("%2!s! ");
                                    break;
                                case 't':
                                    formatOptions += _T("%3!04X! ");
                                    break;
                                case 's':
                                    formatOptions += _T("%4!s! ");
                                    break;
                                case 'k':
                                    formatOptions += _T("%5!s! ");
                                    break;
                                case 'u':
                                    formatOptions += _T("%6!s! ");
                                    break;
                                case 'q':
                                    formatOptions += _T("%7!d! ");
                                    break;
                                case 'p':
                                    formatOptions += _T("%8!04X! ");
                                    break;
                                case 'c':
                                    formatOptions += _T("%9!d! ");
                                    break;
                                case 'f':
                                    formatOptions += _T("%!FUNC! ");
                                    break;
                                default:
                                    break;
                            }
                        }

                        SetEnvironmentVariable(_T("TRACE_FORMAT_PREFIX"), 
                                               formatOptions);

                        ++targv; --argc;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-v")) ) {
                    m_bVerbose = TRUE ;
            }
            else if ( !_tcsicmp(targv[0], _T("-ods")) ) {
                    m_bODSOutput = TRUE ;
            }
            else if ( !_tcsicmp(targv[0], _T("-onlyshow")) ) {
                if (argc > 1) {
                    m_traceMask = (TCHAR *)malloc((_tcslen(targv[1])+1) * sizeof(TCHAR));
                    _tcscpy(m_traceMask, targv[1]);
                    ++targv; --argc;
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-o")) ) {
                if (argc > 1) {

                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR drive[10];
                        TCHAR path[MAXSTR];
                        TCHAR file[MAXSTR];
                        TCHAR ext[MAXSTR];
                        ++targv; --argc;

                        _tfullpath(dumpFileName, targv[0], MAXSTR);
                        _tsplitpath( dumpFileName, drive, path, file, ext );
                        _tcscat(ext,_T(".sum"));  
                        _tmakepath( summaryFileName, drive, path, file, ext );

                    }
                }
            }
        }
        else {
            pLogFile = (PEVENT_TRACE_LOGFILE)malloc(sizeof(EVENT_TRACE_LOGFILE));
            if (pLogFile == NULL){ 
                _tprintf(_T("Allocation Failure(EVENT_TRACE_LOGFILE)\n")); // Need to cleanup better. 
                goto cleanup;
            }
            RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
            m_evmFile[m_logFileCount] = pLogFile;

            m_evmFile[m_logFileCount]->LoggerName = NULL;
            m_evmFile[m_logFileCount]->LogFileName = 
                (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
            if (m_evmFile[m_logFileCount]->LogFileName == NULL) {
                _tprintf(_T("Allocation Failure (LogFileName)\n"));
                goto cleanup;
            }
            
            _tfullpath(m_evmFile[m_logFileCount]->LogFileName, targv[0], MAXSTR);
            _tprintf(_T("Setting log file to: %s\n"),
                     m_evmFile[m_logFileCount]->LogFileName);
                        
            if (!CheckFile(m_evmFile[m_logFileCount]->LogFileName)) {
                _tprintf(_T("Cannot open logfile for reading\n"));
                goto cleanup;
            }
            m_evmFile[m_logFileCount]->Context = NULL;
            m_evmFile[m_logFileCount]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)BufferCallback;
            m_evmFile[m_logFileCount]->BuffersRead = 0;
            m_evmFile[m_logFileCount]->CurrentTime = 0;
            m_evmFile[m_logFileCount]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
            m_logFileCount++;
        }
    }

    if( _tcslen( guidFileName ) ){
        TCHAR str[MAXSTR];
        _tfullpath( str, guidFileName, MAXSTR);
        _tcscpy( guidFileName, str );
        _tprintf(_T("Getting guids from %s\n"), guidFileName);
        guidCount = GetTraceGuids(guidFileName, (PLIST_ENTRY *) &m_eventListHead);
        if ((guidCount <= 0) && m_bTMFSpecified)
        {
            _tprintf(_T("GetTraceGuids returned %d, GetLastError=%d, for %s\n"),
                        guidCount,
                        GetLastError(),
                        guidFileName);
        }
    }

    if (m_logFileCount <= 0) {
        pLogFile = (PEVENT_TRACE_LOGFILE)malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (pLogFile == NULL){ 
            _tprintf(_T("Allocation Failure\n")); // Need to cleanup better. 
            goto cleanup;
        }
        RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
        m_evmFile[0] = pLogFile;
        m_evmFile[0]->LoggerName = NULL;
        m_logFileCount = 1;
        m_evmFile[0]->LogFileName = (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
        if (m_evmFile[0]->LogFileName == NULL) {
            _tprintf(_T("Allocation Failure\n"));
            goto cleanup;
        }
        _tcscpy(m_evmFile[0]->LogFileName, _T("C:\\Logfile.Etl"));
        m_evmFile[0]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
    }

    for (i = 0; i < m_logFileCount; i++) {
        TRACEHANDLE x;
        x = OpenTrace(m_evmFile[i]);
        handleArray[i] = x;
        if (handleArray[i] == 0) {
            _tprintf(_T("Error Opening Trace %d with status=%d\n"), 
                                                           i, GetLastError());

            for (j = 0; j < i; j++)
                CloseTrace(handleArray[j]);
            goto cleanup;
        }
    }
    if (!m_bDisplayOnly) {
        m_pDumpFile = _tfopen(dumpFileName, _T("w"));
        if (m_pDumpFile == NULL) {
            _tprintf(_T("Format File \"%s\" Could not be opened for writing 0X%X\n"),
                        dumpFileName,GetLastError());
            goto cleanup;
        }
        m_pSummaryFile = NULL ;
        if (!m_bNoSummary) {
            m_pSummaryFile = _tfopen(summaryFileName, _T("w"));
            if (m_pSummaryFile == NULL) {
                _tprintf(_T("Summary File \"%s\" could not be opened for writing 0X%X\n"),
                            summaryFileName,GetLastError());
                goto cleanup;
            }
        }
    } else {
        m_pDumpFile = stdout;
        m_pSummaryFile = stdout;
    }

    status = ProcessTrace(handleArray,
                 m_logFileCount,
                 NULL, NULL);
    if (status != ERROR_SUCCESS) {
        _tprintf(_T("Error processing trace entry with status=0x%x (GetLastError=0x%x)\n"),
                status, GetLastError());
    }

    for (j = 0; j < m_logFileCount; j++){
        status = CloseTrace(handleArray[j]);
        if (status != ERROR_SUCCESS) {
            _tprintf(_T("Error Closing Trace %d with status=%d\n"), j, status);
        }
    }


    if (!m_bNoSummary) {
        _ftprintf(m_pSummaryFile,_T("Files Processed:\n"));
        for (i=0; i<m_logFileCount; i++) {
            _ftprintf(m_pSummaryFile,_T("\t%s\n"),m_evmFile[i]->LogFileName);
        }
    
        GetTraceElapseTime(&m_elapseTime);
    
        _ftprintf(m_pSummaryFile,
                  _T("Total Buffers Processed %d\n")
                  _T("Total Events  Processed %d\n")
                  _T("Total Events  Lost      %d\n")
                  _T("Elapsed Time            %I64d sec\n"), 
                  m_totalBuffersRead,
                  m_totalEventCount,
                  m_totalEventsLost,
                  (m_elapseTime / 10000000) );
    
        _ftprintf(m_pSummaryFile,
           _T("+-----------------------------------------------------------------------------------+\n")
           _T("|%10s    %-20s %-10s  %-36s|\n")
           _T("+-----------------------------------------------------------------------------------+\n"),
           _T("EventCount"),
           _T("EventName"),
           _T("EventType"),
           _T("Guid")
            );
    
        SummaryTraceEventList(m_summaryBlock, SIZESUMMARYBLOCK, m_eventListHead);
        _ftprintf(m_pSummaryFile,
               _T("%s+-----------------------------------------------------------------------------------+\n"),
               m_summaryBlock);
    }

cleanup:
    
    CleanupTraceEventList(m_eventListHead);
    if (m_bVerbose) {
        _tprintf(_T("\n"));  // need a newline after the block updates
    }
    if (m_pDumpFile != NULL)  {
        _tprintf(_T("Event traces dumped to %s\n"), dumpFileName);
        fclose(m_pDumpFile);
    }

    if(m_pSummaryFile != NULL){
        _tprintf(_T("Event Summary dumped to %s\n"), summaryFileName);
        fclose(m_pSummaryFile);
    }

    for (i = 0; i < m_logFileCount; i ++)
    {
        if (m_evmFile[i]->LoggerName != NULL)
        {
            free(m_evmFile[i]->LoggerName);
            m_evmFile[i]->LoggerName = NULL;
        }
        if (m_evmFile[i]->LogFileName != NULL)
        {
            free(m_evmFile[i]->LogFileName);
            m_evmFile[i]->LogFileName = NULL;
        }
        free(m_evmFile[i]);
    }

    status = GetLastError();
    if(status != ERROR_SUCCESS ){
        _tprintf(_T("Exit Status: %d\n"), status );
    }
    return 0;
}

LONG CTraceViewApp::ExtractPdbInfo()
{
    DWORD   status;
    CString path;
    CString pdbName;
    CHAR    pdbNameStr[500];
    CHAR    pathStr[500];
    INT     len; 
    INT     targv = 0;
    BOOL    bPDBName = FALSE ;
    LPTSTR  dllToLoad = NULL;

/*
    TCHAR helptext[] = "Usage: TracePDB  -f <pdbname> [-p <path>]  [-v]\n"
                       "       Options:\n"
//                     "         -r recurse into subdirectories\n"
                       "         -f specifies the PDBName from which to extract tmf's\n"
                       "         -p specifies the path to create the tmf's,\n"
                       "                by default the current directory.\n"
                       "         -v verbose, displays actions taken \n"  ;
*/


    if (GetCurrentDirectory(MAX_PATH, path.GetBuffer(MAX_PATH)) == 0 ) {
       _fputts(_T("TracePDB: no current directory\n"), stdout);
       return ERROR_PATH_NOT_FOUND;
    }

    path = (LPCTSTR)path;

    //
    // Get the PDB file name
    //
    if((__argc > 2) &&
       ((__wargv[2][0] != '-') && (__wargv[2][0] != '/'))) {

        if((_tcslen(__wargv[2]) + 1) > MAX_PATH) {
            _fputts(_T("TracePDB: PDBname too large\n"), stdout);
            return ERROR_INVALID_PARAMETER;
        }

        pdbName.GetBuffer(_tcslen(__wargv[2]) + 1);

        pdbName = __wargv[2]; 

        bPDBName = TRUE ;
    }

    for(LONG ii = 3; ii < __argc; ii++) {
        if((__argc > 3) && ((__wargv[ii][0] == '-') || (__wargv[ii][0] == '/'))) {

            if(__wargv[ii][1] == 'p') {
                if(((ii + 1) < __argc) &&
                   ((__wargv[ii + 1][0] != '-') && (__wargv[ii + 1][0] != '/'))) {
                    if((_tcslen(__wargv[ii + 1]) + 1) > MAX_PATH) {
                        fputs("TracePDB: Path larger than MAX_PATH\n", stdout);
                        return ERROR_INVALID_PARAMETER;
                    }
                    
                    _tcsncpy(path.GetBuffer(_tcslen(__wargv[ii + 1]) + 1),
                             __wargv[ii + 1],
                             _tcslen(__wargv[ii + 1]) + 1);

                    ii++;
                }
            } else {
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    if (!bPDBName) {
        _tprintf(_T("TracePDB: No PDB specified?\n\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if((dllToLoad = (LPTSTR) malloc(MAX_PATH + 1)) == NULL) {
        _fputts(_T("TracePDB: malloc failed\n"), stdout);
        return ERROR_OUTOFMEMORY;
    }

    _tcscpy(dllToLoad, _T("mspdb70.dll"));

    if(!ParsePdb(pdbName, path, TRUE)) {
        status = ERROR_INVALID_PARAMETER;

        _tprintf(_T("TracePDB: failed with error %d\n"), status);
    }

    return status;
}

void CTraceViewApp::DisplayHelp()
{
    _fputts(
        _T("\n")
        _T("\n")
        _T("\n")
        _T("Control:\n")
        _T("Usage: traceview [action] [options] | [-h | -help | -?]\n")
        _T("\n")
        _T("Control Actions:\n")
        _T("\t-start   [LoggerName] Starts up the [LoggerName] trace session\n")
        _T("\t-stop    [LoggerName] Stops the [LoggerName] trace session\n")
        _T("\t-update  [LoggerName] Updates the [LoggerName] trace session\n")
        _T("\t-enable  [LoggerName] Enables providers for the [LoggerName] session\n")
        _T("\t-disable [LoggerName] Disables providers for the [LoggerName] session\n")
        _T("\t-flush   [LoggerName] Flushes the [LoggerName] active buffers\n")
        _T("\t-enumguid             Enumerate Registered Trace Guids\n")
        _T("\t-q       [LoggerName] Query status of [LoggerName] trace session\n")
        _T("\t-l                    List all trace sessions\n")
        _T("\t-x                    Stops all active trace sessions\n")
        _T("\n")
        _T("Control Options:\n")
        _T("\t-b   <n>              Sets buffer size to <n> Kbytes\n")
        _T("\t-min <n>              Sets minimum buffers\n")
        _T("\t-max <n>              Sets maximum buffers\n")
        _T("\t-f <name>             Log to file <name>\n")
        _T("\t-append               Append to file\n")
        _T("\t-prealloc             Pre-allocate\n")
        _T("\t-seq <n>              Sequential logfile of up to n Mbytes\n")
        _T("\t-cir <n>              Circular logfile of n Mbytes\n")
        _T("\t-newfile <n>          Log to a new file after every n Mbytes\n")
        _T("\t-ft <n>               Set flush timer to n seconds\n")
        _T("\t-paged                Use pageable memory for buffers\n")
        _T("\t-guid <file>          Start tracing for providers in file\n")
        _T("\t-pdb <file>           Start tracing for provider related to PDB file\n")
        _T("\t-rt                   Enable tracing in real time mode\n")
        _T("\t-kd                   Enable tracing in kernel debugger\n")
        _T("\t-age <n>              Modify aging decay time to n minutes\n")
        _T("\t-level <n>            Enable Level passed to the providers\n")
        _T("\t-flag <n>             Enable Flags passed to the providers\n")
        _T("\t-eflag <n> <flag...>  Enable flags (several) to providers\n")
        _T("\n")
        _T("\n")
        _T("Consumption:\n")
        _T("Usage: traceview [action] [options] <evmfile> | [-h | -help | -?]\n")
        _T("\n")
        _T("Consumption Actions:\n")
        _T("\t-process              Setup trace event processing for consumer\n")
        _T("\n")
        _T("Consumption Options:\n")
        _T("\t-o <file>             Output file\n")
        _T("\t-csv                  Format the output as a comma seperated file\n")
        _T("\t-tmf <file>           Format definition file\n")
        _T("\t-pdb <file>           Retrieve format information from PDB file\n")
        _T("\t-p <path>             TMF file search path\n")
        _T("\t-rt [loggername] Realtime formatting\n")
        _T("\t-h           Display this information\n")
        _T("\t-display              Display output\n")
        _T("\t-displayonly          Display output. Don't write to the file\n")
        _T("\t-nosummary            Don't create the summary file\n")
        _T("\t-noprefix             Suppress any defined TRACE_FORMAT_PREFIX")
        _T("\t-ods                  do Display output using OutputDebugString\n")
        _T("\t-summaryonly          Don't create the listing file.\n")
        _T("\t-v                    Verbose Display\n")
        _T("\n")
        _T("\tDefault evmfile is    ") _T("C:\\Logfile.Etl") _T("\n")
        _T("\tDefault outputfile is ") _T("FmtFile.txt") _T("\n")
        _T("\tDefault TMF file is   ") GUID_FILE _T(".") GUID_EXT _T("\n")
        _T("\n")
        _T("\n")
        _T("Parsing:\n")
        _T("Usage: traceview [action] <pdbname> [-p <path>] | [-h | -help | -?]\n")
        _T("\n")
        _T("Parsing Actions:\n")
        _T("\t-parsepdb <pdbname>   Extract TMF(s) from <pdbname>\n")
        _T("\n")
        _T("Parsing Options:\n")
        _T("\t-p specifies the path to create the tmf's,\n")
        _T("\t       by default the current directory.\n")
        _T("\n")
        _T("\n")
        _T("\n")
        _T("Examples:\n")
        _T("\n")
        _T("Start a log session named foo with the following properties:\n")
        _T("  - real-time\n")
        _T("  - flags set to 0x7\n")
        _T("  - flush time equal to 1\n")
        _T("  - control GUID information stored in foo.pdb\n")
        _T("\n")
        _T("traceview -start foo -rt - flag 0x7 -ft 1 -pdb foo.pdb\n")
        _T("\n")
        _T("\n")
        _T("Consume trace events from a logger named bar with the\n")
        _T(" following options:\n")
        _T("  - process events in real-time from real-time logger bar\n")
        _T("  - display to screen only, no listing file generated\n")
        _T("  - display process ID, CPU number, and function name\n")
        _T("    ahead of event message \n")
        _T("  - extract event format information from bar.pdb\n")
        _T("\n")
        _T("traceview -process -pdb bar.pdb -displayonly  -rt bar -format pcf\n")
        _T("\n")
        _T("\n")
        _T("Extract the TMF files from a PDB file and place them in \n")
        _T("  a directory named c:\\foobar\n")
        _T("\n")
        _T("traceview -parsepdb bar.pdb -p c:\\foobar\n"),
        stdout
        );
}

// CTraceViewApp message handlers



// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    enum { IDD = IDD_ABOUTBOX };

protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
    DECLARE_MESSAGE_MAP()
public:
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
END_MESSAGE_MAP()

// App command to run the dialog
void CTraceViewApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}


// CTraceViewApp message handlers

CTraceMessage * CTraceViewApp::AllocateTraceEventBlock()
{
    CTraceMessage *pTraceMessage = NULL;

    //
    // Get the array protection
    //
    WaitForSingleObject(m_hTraceBlockMutex, INFINITE);

    if(m_traceBlockArray.GetSize()) {

        ASSERT(FALSE);

        pTraceMessage = m_traceBlockArray.GetAt(0);

        m_traceBlockArray.RemoveAt(0);
    } else {
        pTraceMessage = new CTraceMessage();
    }

    //
    // Release the array protection
    //
    ReleaseMutex(m_hTraceBlockMutex);

    return pTraceMessage;
}

void CTraceViewApp::FreeTraceEventBlocks(CArray<CTraceMessage*, CTraceMessage*> &TraceArray)
{
    //
    // Get the free array protection
    //
    WaitForSingleObject(m_hTraceBlockMutex, INFINITE);

    m_traceBlockArray.Append(TraceArray);

    TraceArray.RemoveAll();

    //
    // Release the free array protection
    //
    ReleaseMutex(m_hTraceBlockMutex);

}

BOOL CTraceViewApp::OnIdle(LONG lCount)
{
    CTraceMessage *pTraceMessage = NULL;

    //
    // Get the free array protection
    //
    WaitForSingleObject(m_hTraceBlockMutex, INFINITE);

    for(LONG ii = 0; ii < 1000; ii++) {
        
        if(m_traceBlockArray.GetSize() < 100) {
            break;
        }

        //
        // Get the next entry from the list
        //
        pTraceMessage = m_traceBlockArray.GetAt(0);

        m_traceBlockArray.RemoveAt(0);

        delete pTraceMessage;
    }

    //
    // Release the free array protection
    //
    ReleaseMutex(m_hTraceBlockMutex);

    return CWinApp::OnIdle(lCount);
}

void CTraceViewApp::PrintLoggerStatus(ULONG Status)
{
    LPTSTR  loggerName;
    LPTSTR  LogFileName;
    CString errorMsg;
    
    if ((m_pLoggerInfo->LoggerNameOffset > 0) &&
        (m_pLoggerInfo->LoggerNameOffset  < m_pLoggerInfo->Wnode.BufferSize)) {
        loggerName = (LPTSTR) ((char*)m_pLoggerInfo +
                                m_pLoggerInfo->LoggerNameOffset);
    }
    else loggerName = NULL;

    if ((m_pLoggerInfo->LogFileNameOffset > 0) &&
        (m_pLoggerInfo->LogFileNameOffset  < m_pLoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((char*)m_pLoggerInfo +
                                m_pLoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;

    _tprintf(_T("Operation Status:       %uL\t"), Status);
    _tprintf(_T("%s\n"), DecodeStatus(Status));
    
    _tprintf(_T("Logger Name:            %s\n"),
            (loggerName == NULL) ?
            _T(" ") : loggerName);
// end_sdk
    if (loggerName == NULL || !_tcscmp(loggerName, _T("GlobalLogger"))) {
        // Logger ID
        _tprintf(_T("Status:                 %s\n"), 
                 m_globalLoggerStartValue ?
                _T("Registry set to start") : _T("Registry set to stop"));
        _tprintf(_T("Logger Id:              %I64x\n"), m_pLoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %p\n"), m_pLoggerInfo->LoggerThreadId);
        if (m_pLoggerInfo->BufferSize == 0)
            _tprintf(_T("Buffer Size:            default value\n"));
        else
            _tprintf(_T("Buffer Size:            %d Kb\n"), m_pLoggerInfo->BufferSize);

        if (m_pLoggerInfo->MaximumBuffers == 0)
            _tprintf(_T("Maximum Buffers:        default value\n"));
        else
            _tprintf(_T("Maximum Buffers:        %d\n"), m_pLoggerInfo->MaximumBuffers);
        if (m_pLoggerInfo->MinimumBuffers == 0)
            _tprintf(_T("Minimum Buffers:        default value\n"));
        else
            _tprintf(_T("Minimum Buffers:        %d\n"), m_pLoggerInfo->MinimumBuffers);
        
        _tprintf(_T("Number of Buffers:      %d\n"), m_pLoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), m_pLoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), m_pLoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), m_pLoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), m_pLoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), m_pLoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), m_pLoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (m_pLoggerInfo->MaximumFileSize > 0) {
            if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE)
                _tprintf(_T("Maximum File Size:      %d Kb\n"), m_pLoggerInfo->MaximumFileSize);
            else
                _tprintf(_T("Maximum File Size:      %d Mb\n"), m_pLoggerInfo->MaximumFileSize);
        }
        if (m_pLoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), m_pLoggerInfo->FlushTimer);
        if (m_pLoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));
            if ((loggerName != NULL) && (!_tcscmp(loggerName, KERNEL_LOGGER_NAME))) {

                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }
            else {
                _tprintf(_T("0x%08x"), m_pLoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName == NULL || _tcslen(LogFileName) == 0) {
            _tprintf(_T("Log Filename:           default location\n"));
            _tprintf(_T("                        %%SystemRoot%%\\System32\\LogFiles\\WMI\\trace.log\n"));
        }
        else
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);

        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
            _tprintf(_T("Local Sequence numbers in use\n"));
        }
        else if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
            _tprintf(_T("Global Sequence numbers in use\n"));
        }
    }
    else {
// begin_sdk
        _tprintf(_T("Logger Id:              %I64x\n"), m_pLoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %p\n"), m_pLoggerInfo->LoggerThreadId);
        if (Status != 0)
            return;

        _tprintf(_T("Buffer Size:            %d Kb"), m_pLoggerInfo->BufferSize);
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
            _tprintf(_T(" using paged memory\n"));
        }
        else {
            _tprintf(_T("\n"));
        }
        _tprintf(_T("Maximum Buffers:        %d\n"), m_pLoggerInfo->MaximumBuffers);
        _tprintf(_T("Minimum Buffers:        %d\n"), m_pLoggerInfo->MinimumBuffers);
        _tprintf(_T("Number of Buffers:      %d\n"), m_pLoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), m_pLoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), m_pLoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), m_pLoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), m_pLoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), m_pLoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), m_pLoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            _tprintf(_T("Real Time mode enabled"));
// end_sdk
            if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_BUFFERING_MODE) {
                _tprintf(_T(": buffering only"));
            }
// begin_sdk
            _tprintf(_T("\n"));
        }

        if (m_pLoggerInfo->MaximumFileSize > 0) {
            if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE)
                _tprintf(_T("Maximum File Size:      %d Kb\n"), m_pLoggerInfo->MaximumFileSize);
            else
                _tprintf(_T("Maximum File Size:      %d Mb\n"), m_pLoggerInfo->MaximumFileSize);
        }

        if (m_pLoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), m_pLoggerInfo->FlushTimer);

        if (m_pLoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));

            if ((loggerName != NULL) && (!_tcscmp(loggerName, KERNEL_LOGGER_NAME))) {

                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (m_pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }else{
                _tprintf(_T("0x%08x"), m_pLoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName != NULL) {
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);
        }
// end_sdk
        if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
            _tprintf(_T("Local Sequence numbers in use\n"));
        }
        else if (m_pLoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
            _tprintf(_T("Global Sequence numbers in use\n"));
        }
    }
// begin_sdk

}

LPCTSTR CTraceViewApp::DecodeStatus(ULONG Status)
{
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        m_errorMsg.GetBuffer(MAX_STR_LENGTH),
        MAX_STR_LENGTH,
        NULL );

    return m_errorMsg;
}

LONG CTraceViewApp::GetGuids(LPCTSTR GuidFile)
{
    FILE   *f;
    TCHAR   line[MAX_STR_LENGTH];
    TCHAR   arg[MAX_STR_LENGTH];
    LPGUID  guid;
    int     i;
    int     n;

    f = _tfopen(GuidFile, _T("r"));

    if(f == NULL) {
        return -1;
    }

    n = 0;
    while(_fgetts(line, MAX_STR_LENGTH, f) != NULL) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        n ++;
        m_guidArray.Add(line);
    }

    fclose(f);
    return (ULONG)n;
}

void CTraceViewApp::DisplayVersionInfo()
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    if ((dw = GetModuleFileName(NULL, strProgram, MAXSTR)) == MAXSTR) {
        strProgram[MAXSTR-1] = _T('\0');
    }

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _tprintf( _T("\nMicrosoft (R) %s (%s)\n%s\n\n"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }
}

BOOL CTraceViewApp::CheckFile(LPTSTR fileName)
{
    HANDLE hFile;
    BYTE   LogHeaderBuffer[DEFAULT_LOG_BUFFER_SIZE];
    ULONG  nBytesRead ;
    ULONG  hResult ;
    PEVENT_TRACE pEvent;
    PTRACE_LOGFILE_HEADER logfileHeader ;
    LARGE_INTEGER lFileSize ;
    LARGE_INTEGER lFileSizeMB ;
    DWORD dwDesiredAccess , dwShareMode ;
    FILETIME      stdTime, localTime, endlocalTime, endTime;
    SYSTEMTIME    sysTime, endsysTime;
    PEVENT_TRACE_LOGFILE    pLogBuffer ;

    if (m_bFixUp) {
        dwShareMode = 0 ;
        dwDesiredAccess = GENERIC_READ | GENERIC_WRITE ;
    } else {
        dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;
        dwDesiredAccess = GENERIC_READ ;
    }
    hFile = CreateFile(
                fileName,
                dwDesiredAccess,
                dwShareMode,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if (hFile == INVALID_HANDLE_VALUE) {
        if (m_bFixUp) {
            _tprintf(_T("ERROR: Fixup could not open file, Error = 0x%X\n"),GetLastError());
            exit(GetLastError());
        }
        return(FALSE);
    }

    // While we are here we will look to see if the file is ok and fix up
    // Circular buffer anomolies
    if (((hResult = ReadFile(hFile,
                      (LPVOID)LogHeaderBuffer,
                        DEFAULT_LOG_BUFFER_SIZE,
                        &nBytesRead,
                        NULL)) == 0) || nBytesRead < DEFAULT_LOG_BUFFER_SIZE) {
        _tprintf(_T("ERROR: Fixup could not read file, Error = 0x%X, bytes read = %d(of %d)\n"),
                 GetLastError(),nBytesRead,DEFAULT_LOG_BUFFER_SIZE);
        exit(ERROR_BAD_ARGUMENTS);
    }
    pEvent = (PEVENT_TRACE)LogHeaderBuffer ;
    logfileHeader = (PTRACE_LOGFILE_HEADER)&LogHeaderBuffer[sizeof(WMI_BUFFER_HEADER) + 
                                                            sizeof(SYSTEM_TRACE_HEADER)];
    if (m_bVerbose) {

        _tprintf(_T("Dumping Logfile Header\n"));
        RtlCopyMemory(&stdTime , &(logfileHeader->StartTime), sizeof(FILETIME));
        FileTimeToLocalFileTime(&stdTime, &localTime);
        FileTimeToSystemTime(&localTime, &sysTime);

        RtlCopyMemory(&endTime , &(logfileHeader->EndTime), sizeof(FILETIME));
        FileTimeToLocalFileTime(&endTime, &endlocalTime);
        FileTimeToSystemTime(&endlocalTime, &endsysTime);

        _tprintf(_T("\tStart Time   %02d/%02d/%04d-%02d:%02d:%02d.%03d\n"),
                    sysTime.wMonth,
                    sysTime.wDay,
                    sysTime.wYear,
                    sysTime.wHour,
                    sysTime.wMinute,
                    sysTime.wSecond,
                    sysTime.wMilliseconds);
        _tprintf(_T("\tBufferSize           %d\n"), 
                        logfileHeader->BufferSize);
        _tprintf(_T("\tVersion              %d\n"), 
                        logfileHeader->Version);
        _tprintf(_T("\tProviderVersion      %d\n"), 
                        logfileHeader->ProviderVersion);
        _tprintf(_T("\tEnd Time %02d/%02d/%04d-%02d:%02d:%02d.%03d\n"),
                    endsysTime.wMonth,
                    endsysTime.wDay,
                    endsysTime.wYear,
                    endsysTime.wHour,
                    endsysTime.wMinute,
                    endsysTime.wSecond,
                    endsysTime.wMilliseconds);
        _tprintf(_T("\tTimer Resolution     %d\n"), 
                        logfileHeader->TimerResolution);
        _tprintf(_T("\tMaximum File Size    %d\n"), 
                        logfileHeader->MaximumFileSize);
        _tprintf(_T("\tBuffers  Written     %d\n"), 
                        logfileHeader->BuffersWritten);

/*
        _tprintf(_T("\tLogger Name          %ls\n"), 
                        logfileHeader->LoggerName);
        _tprintf(_T("\tLogfile Name         %ls\n"), 
                        logfileHeader->LogFileName);
*/
        _tprintf(_T("\tTimezone is %s (Bias is %dmins)\n"),
                logfileHeader->TimeZone.StandardName,logfileHeader->TimeZone.Bias);
        _tprintf(_T("\tLogfile Mode         %X "), 
                        logfileHeader->LogFileMode);
        if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_NONE) {
            _tprintf(_T("Logfile is off(?)\n"));
        } else if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Logfile is sequential\n"));
        } else if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Logfile is circular\n"));
        }
        _tprintf(_T("\tProcessorCount        %d\n"), 
                        logfileHeader->NumberOfProcessors);
    }

    if (GetFileSizeEx(hFile, &lFileSize) == 0) {
        _tprintf(_T("WARNING: Could not get file size, continuing\n"));
    } else {
        lFileSizeMB.QuadPart = lFileSize.QuadPart / (1024*1024) ;
        if (lFileSizeMB.QuadPart > logfileHeader->MaximumFileSize) {
            _tprintf(_T("WARNING: File size given as %dMB, should be %dMB\n"),
                logfileHeader->MaximumFileSize,lFileSizeMB.QuadPart);
            if (lFileSize.HighPart != 0) {
                _tprintf(_T("WARNING: Log file is TOO big"));
            }
            if (m_bFixUp) {
                logfileHeader->MaximumFileSize = lFileSizeMB.LowPart + 1 ;
            }
        }
    }

    if ((logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) &&
        (logfileHeader->BuffersWritten== 0 )) {
        _tprintf(_T("WARNING: Circular Trace File did not have 'wrap' address\n"));
        if (m_bFixUp) {
            // Figure out the wrap address
            INT LowBuff = 1, HighBuff, CurrentBuff, MaxBuff ;
            FILETIME LowTime, HighTime, CurrentTime, MaxTime ;
            if (lFileSize.HighPart != 0) {
                _tprintf(_T("ERROR: File TOO big\n"));
                exit(-1);
            }
            MaxBuff = (LONG)(lFileSize.QuadPart / logfileHeader->BufferSize) - 1 ;
            _tprintf(_T("MaxBuff=%d\n"),MaxBuff);
            pLogBuffer = (PEVENT_TRACE_LOGFILE)malloc(logfileHeader->BufferSize);
            if (SetFilePointer(hFile,0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
                _tprintf(_T("ERROR: Could not reset file to beginning for FixUp, Error = 0x%X"),
                        GetLastError());
                exit(GetLastError());
            }
            for (CurrentBuff = 1 ; CurrentBuff <= MaxBuff; CurrentBuff++) {
                if (SetFilePointer(hFile,logfileHeader->BufferSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
                    _tprintf(_T("ERROR: Could not set file to next buffer for FixUp, Error = 0x%X"),
                            GetLastError());
                    exit(GetLastError());
                }
                hResult = ReadFile(hFile,
                                   (LPVOID)pLogBuffer,
                                    logfileHeader->BufferSize,
                                    &nBytesRead,
                                    NULL);
                BufferCallback((PEVENT_TRACE_LOGFILE)pLogBuffer);
            }
        }
    }
    if (m_bFixUp) {
        if (SetFilePointer(hFile,0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
            _tprintf(_T("ERROR: Could not reset file to beginning for FixUp, Error = 0x%X"),
                    GetLastError());
            exit(GetLastError());
        }

        logfileHeader->BuffersWritten = m_bufferWrap;

        if (!WriteFile(hFile,(LPVOID)LogHeaderBuffer,DEFAULT_LOG_BUFFER_SIZE,&nBytesRead, NULL)) {
            _tprintf(_T("ERROR: Could not Write file for FixUp, Error = 0x%X"),
                    GetLastError());
            exit(GetLastError());
        }
        _tprintf(_T("INFO: Buffer Wrap reset to %d\n"), m_bufferWrap);
    }
    

    CloseHandle(hFile);

    return (TRUE);
}

ULONG CTraceViewApp::BufferCallback(PEVENT_TRACE_LOGFILE pLog)
{
    ULONG i;
    ULONG Status;
    EVENT_TRACE_PROPERTIES LoggerProp;
    CTraceViewApp *pApp = (CTraceViewApp *)AfxGetApp();
    
    pApp->m_totalBuffersRead++;
    pApp->m_totalEventsLost += pLog->EventsLost;

    if (pApp->m_bVerbose) {

       FILETIME      stdTime, localTime;
       SYSTEMTIME    sysTime;

       RtlCopyMemory(&stdTime , &pLog->CurrentTime, sizeof(FILETIME));

       FileTimeToSystemTime(&stdTime, &sysTime);

       _tprintf(_T("%02d/%02d/%04d-%02d:%02d:%02d.%03d :: %8d: Filled=%8d, Lost=%3d"),
                    sysTime.wMonth,
                    sysTime.wDay,
                    sysTime.wYear,
                    sysTime.wHour,
                    sysTime.wMinute,
                    sysTime.wSecond,
                    sysTime.wMilliseconds,
                    pApp->m_totalBuffersRead,
                    pLog->Filled,
                    pLog->EventsLost);
       _tprintf(_T(" TotalLost= %d\r"), pApp->m_totalEventsLost);

       if (CompareFileTime(&pApp->m_lastTime,&stdTime) == 1) {
           _tprintf(_T("\nWARNING: time appears to have wrapped here (Block = %d)!\n"), pApp->m_totalBuffersRead);
           pApp->m_bufferWrap = pApp->m_totalBuffersRead;
       }
       pApp->m_lastTime = stdTime ;
    }

    return (TRUE);
}

void CTraceViewApp::DumpEvent(PEVENT_TRACE pEvent)
{
    CTraceViewApp *pApp = (CTraceViewApp *)AfxGetApp();
    
    pApp->m_totalEventCount++;

    if (pEvent == NULL) {
        _tprintf(_T("pEvent is NULL\n"));
        return;
    }
    // DumpEvent() is only a wrapper, it calls FormatTraceEvent() in TracePrt.
    //
    if (FormatTraceEvent(pApp->m_eventListHead, pEvent, pApp->m_eventBuf, SIZEEVENTBUF, NULL) > 0)
    {
        TCHAR * eventBufWork = &pApp->m_eventBuf[0] ;
#ifdef UNICODE
        //sprintf(_T("Name,\"SubName(File+line#)\",ThreadID,ProcessId,SequenceNumber,CPUNumber,Indent,Function,Component,TraceLevel,TraceFlags,Text\n"));
        if (pApp->m_bCSVMode) {
            PSTRUCTUREDMESSAGE pStructuredMessage = (PSTRUCTUREDMESSAGE)&pApp->m_eventBuf[0];
          /*  if (fCSVHeader && fNoCSVHeader) {
                fCSVHeader = FALSE ;
                _stprintf((TCHAR *)pApp->m_eventBufCSV,_T("GUIDname,TypeName,ThreadId,ProcessId,SequenceNum,CpuNumber,Indent,CompnentName,SubComponentName,FunctionName,LevelName,FlagsName, String"));
            }  */
            _stprintf((TCHAR *)pApp->m_eventBufCSV,_T("%s,%s,%08X,%08X,%d,%d,%d,%s,%s,%s,%s,%s,\"%s\""),
                                (pStructuredMessage->GuidName?&pApp->m_eventBuf[pStructuredMessage->GuidName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->GuidTypeName?&pApp->m_eventBuf[pStructuredMessage->GuidTypeName/sizeof(TCHAR)]:_T("")),
                                pStructuredMessage->ThreadId,
                                pStructuredMessage->ProcessId,
                                pStructuredMessage->SequenceNum,
                                pStructuredMessage->CpuNumber,
                                pStructuredMessage->Indent,
                                (pStructuredMessage->ComponentName?&pApp->m_eventBuf[pStructuredMessage->ComponentName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->SubComponentName?&pApp->m_eventBuf[pStructuredMessage->SubComponentName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->FunctionName?&pApp->m_eventBuf[pStructuredMessage->FunctionName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->LevelName?&pApp->m_eventBuf[pStructuredMessage->LevelName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->FlagsName?&pApp->m_eventBuf[pStructuredMessage->FlagsName/sizeof(TCHAR)]:_T("")),
                                (pStructuredMessage->FormattedString?&pApp->m_eventBuf[pStructuredMessage->FormattedString/sizeof(TCHAR)]:_T("")));
            eventBufWork = (TCHAR *)&pApp->m_eventBufCSV[0] ;

        }
        //
        // Convert Unicode to MultiByte
        //
        if (WideCharToMultiByte(GetConsoleOutputCP(),
                                0,
                                eventBufWork,
                                -1,
                                pApp->m_eventBufA,
                                SIZEEVENTBUF * sizeof(WCHAR),
                                NULL,
                                NULL ) == 0 )
    {
            //
            // do nothing, let the _ftprintf handle it.
            //
    }
        else
        {
            if (!pApp->m_bSummaryOnly && !pApp->m_bDisplayOnly) {
                fprintf(pApp->m_pDumpFile, "%s\n", pApp->m_eventBufA);
            }
            if (pApp->m_bDebugDisplay || pApp->m_bDisplayOnly) {
                if (pApp->m_bODSOutput) {
                   OutputDebugStringA(pApp->m_eventBufA);
                   OutputDebugStringA("\n");
                } else {
                   printf("%s\n", pApp->m_eventBufA);
                }
            }
            return ;
        }
#endif  
        if (!pApp->m_bSummaryOnly && !pApp->m_bDisplayOnly) {
            _ftprintf(pApp->m_pDumpFile, _T("%s\n"),pApp->m_eventBuf);
        }
        if (pApp->m_bDebugDisplay || pApp->m_bDisplayOnly) {
            if (pApp->m_bODSOutput) {
                OutputDebugString(pApp->m_eventBuf);
                OutputDebugString(_T("\n"));
            } else {
               _tprintf(_T("%s\n"),pApp->m_eventBuf);
            }
        }
    }
}

void CTraceViewApp::OnHelpHelpTopics()
{
    ::HtmlHelp(
        0,
        _T("traceview.chm"),
        HH_DISPLAY_TOC,
        NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\utils.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// Utils.cpp : miscellaneous useful functions
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
extern "C" {
#include <evntrace.h>
#include "wppfmtstub.h"
}
#include <traceprt.h>
#include "TraceView.h"
#include "Utils.h"

BOOLEAN ParsePdb(CString &PDBFileName, CString &TMFPath, BOOL bCommandLine) 
{
    CString     str;
    CString     currentDir =_T("");
    ULONG       guidCount = 0;
    DWORD       status;
    CHAR        pdbName[500];
    CHAR        path[500];
  
    if(PDBFileName.IsEmpty()) {
        if(bCommandLine) {
            _tprintf(_T("No PDB File To Parse\n"));
        } else {
            AfxMessageBox(_T("No PDB File To Parse"));
        }
        return FALSE;
    }

    if(TMFPath.IsEmpty()) { 
        GetCurrentDirectory(500, (LPTSTR)(LPCTSTR)TMFPath);
    }

#if defined(UNICODE)
    memset(pdbName, 0, 500);
    WideCharToMultiByte(CP_ACP, 
                        0, 
                        (LPCTSTR)PDBFileName,
                        PDBFileName.GetAllocLength(),
                        (LPSTR)pdbName, 
                        500, 
                        NULL, 
                        NULL);

    memset(path, 0, 500);
    WideCharToMultiByte(CP_ACP, 
                        0, 
                        (LPCTSTR)TMFPath,
                        TMFPath.GetLength(),
                        (LPSTR)path, 
                        500, 
                        NULL, 
                        NULL);

    status = BinplaceWppFmtStub(pdbName,
                                path,
                                "mspdb70.dll",
                                TRUE);
#else // UNICODE
    status = BinplaceWppFmtStub((LPSTR)(LPCTSTR)PDBFileName,
                                (LPSTR)(LPCTSTR)TMFPath,
                                "mspdb70.dll",
                                TRUE);
#endif // UNICODE
    if (status != ERROR_SUCCESS) {
        if(bCommandLine) {
            _tprintf(_T("BinplaceWppFmt Failed with status %d\n"), status);
        } else {
            AfxMessageBox(_T("BinplaceWppFmt Failed"));
        }
    }
    return TRUE;
}

void 
StringToGuid(
    IN TCHAR *str, 
    IN OUT LPGUID guid
)
/*++

Routine Description:

    Converts a string into a GUID.

Arguments:

    str - A string in TCHAR.
    guid - The pointer to a GUID that will have the converted GUID.

Return Value:

    None.


--*/
{
    TCHAR temp[10];
    int i;

    _tcsncpy(temp, str, 8);
    temp[8] = 0;
    guid->Data1 = ahextoi(temp);
    _tcsncpy(temp, &str[9], 4);
    temp[4] = 0;
    guid->Data2 = (USHORT) ahextoi(temp);
    _tcsncpy(temp, &str[14], 4);
    temp[4] = 0;
    guid->Data3 = (USHORT) ahextoi(temp);

    for (i=0; i<2; i++) {
        _tcsncpy(temp, &str[19 + (i*2)], 2);
        temp[2] = 0;
        guid->Data4[i] = (UCHAR) ahextoi(temp);
    }
    for (i=2; i<8; i++) {
        _tcsncpy(temp, &str[20 + (i*2)], 2);
        temp[2] = 0;
        guid->Data4[i] = (UCHAR) ahextoi(temp);
    }
}

ULONG 
ahextoi(
    IN TCHAR *s
    )
/*++

Routine Description:

    Converts a hex string into a number.

Arguments:

    s - A hex string in TCHAR. 

Return Value:

    ULONG - The number in the string.


--*/
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

#if 0
LONG
GetGuids(
    IN LPTSTR GuidFile, 
    IN OUT LPGUID *GuidArray
)
/*++

Routine Description:

    Reads GUIDs from a file and stores them in an GUID array.

Arguments:

    GuidFile - The file containing GUIDs. 
    GuidArray - The GUID array that will have GUIDs read from the file.

Return Value:

    ULONG - The number of GUIDs processed.


--*/
{
    FILE *f;
    TCHAR line[MAXSTR], arg[MAXSTR];
    LPGUID Guid;
    int i, n;

    f = _tfopen((TCHAR*)GuidFile, _T("r"));

    if (f == NULL)
        return -1;

    n = 0;
    while ( _fgetts(line, MAXSTR, f) != NULL ) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        Guid = (LPGUID) GuidArray[n];
        n ++;
        StringToGuid(line, Guid);
    }
    fclose(f);
    return (ULONG)n;
}

//
// GlobalLogger functions
// 
ULONG
SetGlobalLoggerSettings(
    IN DWORD StartValue,
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN DWORD ClockType
)
/*++

Since it is a standalone utility, there is no need for extensive comments. 

Routine Description:

    Depending on the value given in "StartValue", it sets or resets event
    trace registry. If the StartValue is 0 (Global logger off), it deletes
    all the keys (that the user may have set previsouly).
    
    Users are allowed to set or reset individual keys using this function,
    but only when "-start GlobalLogger" is used.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    StartValue - The "Start" value to be set in the registry.
                    0: Global logger off
                    1: Global logger on
    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are used to set registry keys.

    ClockType - The type of the clock to be set.

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    DWORD  dwValue;
    NTSTATUS status;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey, UnicodeString;
    ULONG Disposition, TitleIndex;

    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );

    // instead of opening, create a new key because it may not exist.
    // if one exists already, that handle will be passed.
    // if none exists, it will create one.
    status = NtCreateKey(&KeyHandle,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &ObjectAttributes,
                         0L,    // not used within this call anyway.
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &Disposition);

    if(!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    TitleIndex = 0L;


    if (StartValue == 1) { // ACTION_START: set filename only when it is given by a user.
        // setting BufferSize
        if (LoggerInfo->BufferSize > 0) {
            dwValue = LoggerInfo->BufferSize;
            RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MaximumBuffers
        if (LoggerInfo->MaximumBuffers > 0) {
            dwValue = LoggerInfo->MaximumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MinimumBuffers 
        if (LoggerInfo->MinimumBuffers > 0) {
            dwValue = LoggerInfo->MinimumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting FlushTimer
        if (LoggerInfo->FlushTimer > 0) {
            dwValue = LoggerInfo->FlushTimer;
            RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting EnableFlags
        if (LoggerInfo->EnableFlags > 0) {
            dwValue = LoggerInfo->EnableFlags;
            RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }

        dwValue = 0;
        if (LoggerInfo->LogFileNameOffset > 0) {
            UNICODE_STRING UnicodeFileName;
#ifndef UNICODE
            WCHAR TempString[MAXSTR];
            MultiByteToWideChar(CP_ACP,
                                0,
                                (PCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo),
                                strlen((PCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo)),
                                TempString,
                                MAXSTR
                                );
            RtlInitUnicodeString((&UnicodeFileName), TempString);
#else
            RtlInitUnicodeString((&UnicodeFileName), (PWCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo));
#endif
            RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_SZ,
                        UnicodeFileName.Buffer,
                        UnicodeFileName.Length + sizeof(UNICODE_NULL)
                        );
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
    }
    else { // if ACTION_STOP then delete the keys that users might have set previously.
        // delete buffer size
        RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete maximum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete minimum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete flush timer
        RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete enable falg
        RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete filename
        RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
    }

    // setting ClockType
    if (ClockType > 0) {
        dwValue = ClockType;
        RtlInitUnicodeString((&UnicodeString),(cszClockTypeValue));
        status = NtSetValueKey(
                    KeyHandle,
                    &UnicodeString,
                    TitleIndex,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue)
                    );
        if (!NT_SUCCESS(status)) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        TitleIndex++;
    }

     // Setting StartValue
    dwValue = StartValue;
    RtlInitUnicodeString((&UnicodeString),(cszStartValue));
    status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                TitleIndex,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue)
                );
    if (!NT_SUCCESS(status)) {
        NtClose(KeyHandle);
        return RtlNtStatusToDosError(status);
    }
    TitleIndex++;

    NtClose(KeyHandle);
    return 0;
}

ULONG
GetGlobalLoggerSettings(
    IN OUT PEVENT_TRACE_PROPERTIES LoggerInfo,
    OUT PULONG ClockType,
    OUT PDWORD pdwStart
)
/*++

Routine Description:

    It reads registry for golbal logger and updates LoggerInfo. It uses 
    NtEnumerateValueKey() to retrieve the values of the required subkeys.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are updated as the result.

    ClockType - The type of the clock to be updated.
    pdwStart - The "Start" value of currently retained in the registry.

Return Value:

    WINERROR - Error Code defined in winerror.h. If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    ULONG i, j;
    NTSTATUS status;
    HANDLE KeyHandle;
    WCHAR SubKeyName[MAXSTR];
    PVOID Buffer;
    ULONG BufferLength, RequiredLength, KeyNameLength, KeyDataOffset, KeyDataLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey;

    *pdwStart = 0;

    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );
    status = NtOpenKey(
                &KeyHandle,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(status)) 
        return RtlNtStatusToDosError(status);

    // KEY_VALUE_FULL_INFORMATION + name (1 WSTR) + data.
    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + 2 * MAXSTR * sizeof(TCHAR);
    Buffer = (PVOID) malloc(BufferLength);
    if (Buffer == NULL) {
        NtClose(KeyHandle);
        return (ERROR_OUTOFMEMORY);
    }

    i = 0;
    do {
        // Using Key Enumeration
        status = NtEnumerateValueKey(
                    KeyHandle,
                    i++,
                    KeyValueFullInformation,
                    Buffer,
                    BufferLength,
                    &RequiredLength
                    );


        if (!NT_SUCCESS(status)) {
            if (status == STATUS_NO_MORE_ENTRIES)
                break;
            else if (status == STATUS_BUFFER_OVERFLOW) {
                free(Buffer);
                Buffer = malloc(RequiredLength);
                if (Buffer == NULL) {
                    NtClose(KeyHandle);
                    return (ERROR_OUTOFMEMORY);
                }

                status = NtEnumerateValueKey(
                            KeyHandle,
                            i++,
                            KeyValueFullInformation,
                            Buffer,
                            BufferLength,
                            &RequiredLength
                            );
                if (!NT_SUCCESS(status)) {
                    NtClose(KeyHandle);
                    free(Buffer);
                    return RtlNtStatusToDosError(status);
                }
            }
            else {
                NtClose(KeyHandle);
                free(Buffer);
                return RtlNtStatusToDosError(status);
            }
        }
        KeyNameLength = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->NameLength;
        RtlCopyMemory(SubKeyName, 
            (PUCHAR)(((PKEY_VALUE_FULL_INFORMATION)Buffer)->Name), 
            KeyNameLength
            );
        KeyNameLength /= sizeof(WCHAR);
        SubKeyName[KeyNameLength] = L'\0';
        KeyDataOffset = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->DataOffset;
        KeyDataLength = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->DataLength;
        // Find out what the key is
        if (!_wcsicmp(SubKeyName, cszStartValue)) { //StartValue
            RtlCopyMemory(pdwStart, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszBufferSizeValue)) { // BufferSizeValue
            RtlCopyMemory(&(LoggerInfo->BufferSize), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszMaximumBufferValue)) { // MaximumBufferValue
            RtlCopyMemory(&(LoggerInfo->MaximumBuffers), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszMinimumBufferValue)) { // MinimumBuffers
            RtlCopyMemory(&(LoggerInfo->MinimumBuffers), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszFlushTimerValue)) { // FlushTimer
            RtlCopyMemory(&(LoggerInfo->FlushTimer), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszEnableKernelValue)) { // EnableKernelValue
            RtlCopyMemory(&(LoggerInfo->EnableFlags), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszClockTypeValue)) { // ClockTypeValue
            RtlCopyMemory(ClockType, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszFileNameValue)) { // FileName
#ifndef UNICODE
            WCHAR TempString[MAXSTR];
            RtlCopyMemory(TempString, (PUCHAR)Buffer + KeyDataOffset, KeyDataLength);
            WideCharToMultiByte(CP_ACP, 
                                0, 
                                TempString, 
                                wcslen(TempString), 
                                (PUCHAR)LoggerInfo + LoggerInfo->LogFileNameOffset,
                                KeyDataLength, 
                                NULL, 
                                NULL);
#else
            RtlCopyMemory((PUCHAR)LoggerInfo + LoggerInfo->LogFileNameOffset, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
#endif
        }
        else { // Some other keys are in there
            _tprintf(_T("Warning: Unidentified Key in the trace registry: %s\n"), SubKeyName);
        }
        
    }
    while (1);

    NtClose(KeyHandle);
    free(Buffer);
    return 0; 

}
#endif // 0

LONG ConvertStringToNum(CString Str)
{
    CString str;

    LONG retVal;
        
    if( (Str.GetLength() > 1) &&
        (Str[0] == '0' && Str[1] == 'x') ) {

        retVal = _tcstoul(Str, '\0', 16);

    } else {

        retVal = _tcstoul(Str, '\0', 10);

    }

    str.Format(_T("retVal = 0x%X"), retVal);

    return retVal;
}

BOOL ClearDirectory(LPCTSTR Directory)
{
    CString     tempDirectory;
    CString     tempPath;
    CFileFind   fileFind;
    BOOL        result = TRUE;

    tempDirectory = (LPCTSTR)Directory;
    tempPath = (LPCTSTR)Directory;

    tempDirectory +=_T("\\*.*");

    //
    // Clear the directory first
    //
    if(fileFind.FindFile(tempDirectory)) {
        tempDirectory = (LPCTSTR)tempPath;
        while(fileFind.FindNextFile()) {
            tempPath = (LPCTSTR)tempDirectory;
            tempPath +=_T("\\");
            tempPath += fileFind.GetFileName();
            if(!DeleteFile(tempPath)) {
                result = FALSE;
            }
        }
            tempPath = (LPCTSTR)tempDirectory;
            tempPath +=_T("\\");
            tempPath += fileFind.GetFileName();
            if(!DeleteFile(tempPath)) {
                result = FALSE;
            }
    }

    fileFind.Close();

    return result;
}

// Our CEdit class

CSubItemEdit::CSubItemEdit(int iItem, int iSubItem, CListCtrl *pListControl)
{
	m_iItem = iItem;
	m_iSubItem = iSubItem;
	m_bESC = FALSE;
	m_pListControl = pListControl;
}

BEGIN_MESSAGE_MAP(CSubItemEdit, CEdit)
	//{{AFX_MSG_MAP(CSubItemEdit)
	ON_WM_KILLFOCUS()
	ON_WM_NCDESTROY()
	ON_WM_CHAR()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSubItemEdit message handlers

BOOL CSubItemEdit::PreTranslateMessage(MSG* pMsg)
{
	if( pMsg->message == WM_KEYDOWN )
	{
		if(pMsg->wParam == VK_RETURN
				|| pMsg->wParam == VK_DELETE
				|| pMsg->wParam == VK_ESCAPE
				|| GetKeyState( VK_CONTROL)
				)
		{
			::TranslateMessage(pMsg);
			::DispatchMessage(pMsg);
			return TRUE;
		}
	}

	return CEdit::PreTranslateMessage(pMsg);
}


void CSubItemEdit::OnKillFocus(CWnd* pNewWnd)
{
	CString str;
    CString newValue = "0x";
    BOOL    bIsHex = FALSE;

    //
    // if escape was hit don't do anything
    //
	if(m_bESC) {
	    CEdit::OnKillFocus(pNewWnd);

	    DestroyWindow();
        return;
	}

    GetWindowText(str);

    //
    // Skip any hex notation
    // 
    if((str[0] == '0') && (str[1] == 'x')) {
        str = str.Right(str.GetLength() - 2);
        bIsHex = TRUE;
    }

    //
    // Validate the value
    //
    for(int ii = 0; ii < str.GetLength(); ii++) {
        if(str[ii] < '0' || str[ii] > '9') {
            if((str[ii] < 'a' || str[ii] > 'f') &&
                (str[ii] < 'A' || str[ii] > 'F')) {
	            CEdit::OnKillFocus(pNewWnd);

	            DestroyWindow();

                return;
            }
            bIsHex = TRUE;
        }
    }

    if(bIsHex) {
        newValue += (LPCTSTR)str;
        str = (LPCTSTR)newValue;
    }

    //
	// Send Notification to parent of ListView ctrl
    //
	LV_DISPINFO dispinfo;
	dispinfo.hdr.hwndFrom = GetParent()->m_hWnd;
	dispinfo.hdr.idFrom = GetDlgCtrlID();
	dispinfo.hdr.code = LVN_ENDLABELEDIT;

	dispinfo.item.mask = LVIF_TEXT;
	dispinfo.item.iItem = m_iItem;
	dispinfo.item.iSubItem = m_iSubItem;
	dispinfo.item.pszText = m_bESC ? NULL : LPTSTR((LPCTSTR)str);
	dispinfo.item.cchTextMax = str.GetLength();


	m_pListControl->SetItemText(m_iItem, m_iSubItem, str);

	GetParent()->SendMessage(WM_PARAMETER_CHANGED, 
                             m_iItem, 
					         m_iSubItem);

	CEdit::OnKillFocus(pNewWnd);

	DestroyWindow();
}

void CSubItemEdit::OnNcDestroy()
{
	CEdit::OnNcDestroy();

	delete this;
}


void CSubItemEdit::OnChar(UINT Char, UINT nRepCnt, UINT nFlags)
{
	if(Char == VK_ESCAPE || Char == VK_RETURN)
	{
		if(Char == VK_ESCAPE) {
			m_bESC = TRUE;
		}
		GetParent()->SetFocus();
		return;
	}

	CEdit::OnChar(Char, nRepCnt, nFlags);
}

int CSubItemEdit::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    CString str;

	if (CEdit::OnCreate(lpCreateStruct) == -1)
		return -1;

    //
	// Set the proper font
    //
	CFont* font = GetParent()->GetFont();
	SetFont(font);

	str = m_pListControl->GetItemText(m_iItem, m_iSubItem);

	SetWindowText(str);
	SetFocus();
	SetSel( 0, -1 );
	return 0;
}

// Our CComboBox class

CSubItemCombo::CSubItemCombo(int iItem, int iSubItem, CListCtrl *pListControl)
{
	m_iItem = iItem;
	m_iSubItem = iSubItem;
	m_bESC = FALSE;
	m_pListControl = pListControl;
}

BEGIN_MESSAGE_MAP(CSubItemCombo, CComboBox)
	//{{AFX_MSG_MAP(CSubItemCombo)
	ON_WM_KILLFOCUS()
	ON_WM_NCDESTROY()
    ON_WM_CHAR()
	ON_WM_CREATE()
    ON_CONTROL_REFLECT(CBN_CLOSEUP, OnCloseup)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSubItemCombo message handlers

BOOL CSubItemCombo::PreTranslateMessage(MSG* pMsg)
{
	if( pMsg->message == WM_KEYDOWN ) {
		if(pMsg->wParam == VK_RETURN 
				|| pMsg->wParam == VK_ESCAPE) {
			::TranslateMessage(pMsg);
			::DispatchMessage(pMsg);
			return TRUE;
		}
	}
	
	return CComboBox::PreTranslateMessage(pMsg);
}

void CSubItemCombo::OnKillFocus(CWnd* pNewWnd)
{
	CString str;
	GetWindowText(str);

	CComboBox::OnKillFocus(pNewWnd);

    //
	// Send Notification to parent of ListView ctrl
    //
	LV_DISPINFO dispinfo;
	dispinfo.hdr.hwndFrom = GetParent()->m_hWnd;
	dispinfo.hdr.idFrom = GetDlgCtrlID();
	dispinfo.hdr.code = LVN_ENDLABELEDIT;

	dispinfo.item.mask = LVIF_TEXT;
	dispinfo.item.iItem = m_iItem;
	dispinfo.item.iSubItem = m_iSubItem;
	dispinfo.item.pszText = m_bESC ? NULL : LPTSTR((LPCTSTR)str);
	dispinfo.item.cchTextMax = str.GetLength();

	if(!m_bESC) {
		m_pListControl->SetItemText(m_iItem, m_iSubItem, str);
	}

	GetParent()->GetParent()->SendMessage(WM_PARAMETER_CHANGED, 
                                          m_iItem, 
					                      m_iSubItem);

	DestroyWindow();
}

void CSubItemCombo::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if( nChar == VK_ESCAPE || nChar == VK_RETURN)
	{
		if( nChar == VK_ESCAPE )
			m_bESC = TRUE;
		GetParent()->SetFocus();
		return;
	}
	
	CComboBox::OnChar(nChar, nRepCnt, nFlags);
}

void CSubItemCombo::OnNcDestroy()
{
	CComboBox::OnNcDestroy();

	delete this;
}

int CSubItemCombo::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    CString str;
    int     index;

    if (CComboBox::OnCreate(lpCreateStruct) == -1) {
		return -1;
    }

    //
    // Set the proper font
    //
	CFont* font = GetParent()->GetFont();
	SetFont(font);

    AddString(_T("TRUE"));
    AddString(_T("FALSE"));

	str = m_pListControl->GetItemText(m_iItem, m_iSubItem);

    index = FindStringExact(0, str);

    SetCurSel(index);

	SetFocus();

	return 0;
}

void CSubItemCombo::OnCloseup() 
{
	GetParent()->SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\consolecom\consolecom.cpp ===
//
// ConsoleCom.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "ConsoleCom.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//
// The one and only application object
//

CWinApp theApp;

HANDLE coutPipe, cinPipe, cerrPipe;
#define CONNECTIMEOUT 1000

//
// Create named pipes for stdin, stdout and stderr
// Parameter: process id
//
BOOL CreateNamedPipes(DWORD pid)
{
    TCHAR name[256];

    _stprintf(name, _T("\\\\.\\pipe\\%dcout"), pid);
    if (INVALID_HANDLE_VALUE == (coutPipe = CreateNamedPipe(name, 
                                                            PIPE_ACCESS_INBOUND, 
                                                            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                                                            1,
                                                            1024,
                                                            1024,
                                                            CONNECTIMEOUT,
                                                            NULL)))
        return 0;
    _stprintf(name, _T("\\\\.\\pipe\\%dcin"), pid);
    if (INVALID_HANDLE_VALUE == (cinPipe = CreateNamedPipe(name, 
                                                           PIPE_ACCESS_OUTBOUND, 
                                                           PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                                                           1,
                                                           1024,
                                                           1024,
                                                           CONNECTIMEOUT,
                                                           NULL)))
        return 0;
    _stprintf(name, _T("\\\\.\\pipe\\%dcerr"), pid);
    if (INVALID_HANDLE_VALUE == (cerrPipe = CreateNamedPipe(name, 
                                                            PIPE_ACCESS_INBOUND, 
                                                            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                                                            1,
                                                            1024,
                                                            1024,
                                                            CONNECTIMEOUT,
                                                            NULL)))
        return 0;

    return 1;
}

//
// Close all named pipes
//
void CloseNamedPipes()
{
    CloseHandle(coutPipe);
    CloseHandle(cerrPipe);
    CloseHandle(cinPipe);
}

//
// Thread function that handles incoming bytesreams to be outputed
// on stdout
//
void __cdecl OutPipeTh(void*)
{
    TCHAR buffer[1024];
    DWORD count = 0;

    ConnectNamedPipe(coutPipe, NULL);

    while(ReadFile(coutPipe, buffer, 1024, &count, NULL))
    {
        buffer[count] = 0;
        cout << buffer << flush;
    }
}

//
// Thread function that handles incoming bytesreams to be outputed
// on stderr
//
void __cdecl ErrPipeTh(void*)
{
    TCHAR buffer[1024];
    DWORD count = 0;

    ConnectNamedPipe(cerrPipe, NULL);

    while(ReadFile(cerrPipe, buffer, 1024, &count, NULL))
    {
        buffer[count] = 0;
        cerr << buffer << flush;
    }
}

//
// Thread function that handles incoming bytesreams from stdin
//
void __cdecl InPipeTh(void*)
{
    TCHAR buffer[1024];
    DWORD countr = 0;
    DWORD countw = 0;

    ConnectNamedPipe(cinPipe, NULL);

    for(;;)
    {
        if (!ReadFile(GetStdHandle(STD_INPUT_HANDLE),
                      buffer,
                      1024,
                      &countr,
                      NULL))
                break;


        if (!WriteFile(cinPipe, 
                       buffer, 
                       countr, 
                       &countw, 
                       NULL))
            break;
    }
}

//
// Start handler pipe handler threads
//
void RunPipeThreads()
{
    _beginthread(InPipeTh, 0, NULL);
    _beginthread(OutPipeTh, 0, NULL);
    _beginthread(ErrPipeTh, 0, NULL);
}

int __cdecl _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
    ULONG nRetCode = 0;

    //
    // initialize MFC and print and error on failure
    //
    if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
    {
        _tprintf(_T("Fatal Error: MFC initialization failed\n"));
        nRetCode = 1;
    } else {
        //
        // create command line string based on program name
        //
        TCHAR drive[_MAX_DRIVE];
        TCHAR dir[_MAX_DIR];
        TCHAR fname[_MAX_FNAME];
        TCHAR ext[_MAX_EXT];

        _tsplitpath(argv[0], drive, dir, fname, ext);
        TCHAR cParams[1024];
        _tcscpy(cParams, GetCommandLine() + _tcslen(argv[0]) + 1); 
        TCHAR cLine[2028];
        _stprintf(cLine, _T("%s%s%s.exe %s"), drive, dir, fname, cParams);


        //
        // create process in suspended mode
        //
        PROCESS_INFORMATION pInfo;
        STARTUPINFO sInfo;
        memset(&sInfo, 0, sizeof(STARTUPINFO));
        sInfo.cb = sizeof(STARTUPINFO);
        //cout << "Calling " << cLine << endl;
        if (!CreateProcess(NULL,
                           cLine, 
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_SUSPENDED,
                           NULL,
                           NULL,
                           &sInfo,
                           &pInfo))
        {
            cerr << _T("ERROR: Could not create process.") << endl;
            return 1;
        }

        if (!CreateNamedPipes(pInfo.dwProcessId))
        {
            cerr << _T("ERROR: Could not create named pipes.") << endl;
            return 1;
        }

        RunPipeThreads();

        //
        // resume process
        //
        ResumeThread(pInfo.hThread);

        WaitForSingleObject(pInfo.hProcess, INFINITE);

        CloseNamedPipes();

        GetExitCodeProcess(pInfo.hProcess, (ULONG*)&nRetCode);
    }

    return (int)nRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\wppfmt.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// WppFmt.h : BinPlaceWppFmt and associated paraphenalia
//////////////////////////////////////////////////////////////////////////////

#ifndef __WPPFMT_H__
#define __WPPFMT_H__

#pragma once

// The main Formatting routine, normally used by Binplace and TracePDB
// Takes a PDB and creates guid.tmf files from it, all in TraceFormatFilePath
//

DWORD __stdcall
BinplaceWppFmt(
              LPSTR PdbFileName,
              LPSTR TraceFormatFilePath,
              LPSTR szRSDSDllToLoad,
              BOOL  TraceVerbose
              );

BOOL __cdecl PDBOpen(char *a,
                     char *b,
                     ULONG c,
                     ULONG *pError,
                     char *e,
                     VOID **f)
{
    // set the error code
    *pError = ERROR_NOT_SUPPORTED;

    return FALSE;
}

BOOL __cdecl PDBClose(VOID* ppdb)
{
    return FALSE;
}

BOOL __cdecl PDBOpenDBI(VOID*       ppdb, 
                        const char* szMode, 
                        const char* szTarget, 
                        VOID**      ppdbi)
{
    return FALSE;
}

BOOL __cdecl DBIClose(VOID* pdbi) 
{
    return FALSE;
}

BOOL __cdecl ModQuerySymbols(VOID* pmod, 
                             BYTE* pbSym, 
                             long* pcb)
{
    return FALSE;
}

BOOL __cdecl DBIQueryNextMod(VOID*  pdbi, 
                             VOID*  pmod, 
                             VOID** ppmodNext)
{
    return FALSE;
}

VOID __cdecl __security_cookie()
{
}

BOOL __fastcall __security_check_cookie(VOID *p)
{
    return FALSE;
}

#endif // __WPPFMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\utils.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
// Copyright (c) 2002 OSR Open Systems Resources, Inc.
//
// Utils.h : header for miscelaneous functions
//////////////////////////////////////////////////////////////////////////////

BOOLEAN ParsePdb(CString &PDBFileName, CString &TMFPath, BOOL bCommandLine = FALSE);

void StringToGuid(TCHAR *str, LPGUID guid);

ULONG ahextoi(TCHAR *s);

LONG GetGuids(IN LPTSTR GuidFile, IN OUT LPGUID *GuidArray);

ULONG SetGlobalLoggerSettings(IN DWORD                      StartValue,
                              IN PEVENT_TRACE_PROPERTIES    LoggerInfo,
                              IN DWORD                      ClockType);

ULONG GetGlobalLoggerSettings(IN OUT PEVENT_TRACE_PROPERTIES    LoggerInfo,
                                 OUT PULONG                     ClockType,
                                 OUT PDWORD                     pdwStart);

LONG ConvertStringToNum(CString Str);

BOOL ClearDirectory(LPCTSTR Directory);

inline VOID GuidToString(GUID Guid, CString &GuidString)
{
    GuidString.Format(_T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"), 
                      Guid.Data1,
                      Guid.Data2,
                      Guid.Data3,
                      Guid.Data4[0], Guid.Data4[1],
                      Guid.Data4[2], Guid.Data4[3], 
                      Guid.Data4[4], Guid.Data4[5],
                      Guid.Data4[6], Guid.Data4[7]);
}

class CSubItemEdit : public CEdit
{
// Construction
public:
	CSubItemEdit(int iItem, int iSubItem, CListCtrl *pListControl);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSubItemEdit)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSubItemEdit() {};

	// Generated message map functions
protected:
	//{{AFX_MSG(CSubItemEdit)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnNcDestroy();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
private:
	int			m_iItem;
	int			m_iSubItem;
	CListCtrl  *m_pListControl;
	BOOL        m_bESC;
};


class CSubItemCombo : public CComboBox
{
// Construction
public:
	CSubItemCombo(int iItem, int iSubItem, CListCtrl *pListControl);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSubItemCombo)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSubItemCombo() {};

	// Generated message map functions
protected:
	//{{AFX_MSG(CSubItemCombo)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnNcDestroy();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnCloseup();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
private:
	int			m_iItem;
	int			m_iSubItem;
	CListCtrl  *m_pListControl;
	BOOL        m_bESC;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\consolecom\consolecom.h ===
#pragma once

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\consolecom\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// ConsoleCom.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\consolecom\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ConsoleCom.rc
//

#define IDS_APP_TITLE			103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE	101
#define _APS_NEXT_COMMAND_VALUE		40001
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\traceview\consolecom\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <tchar.h>
#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <stdio.h>
#include <windows.h>
#include <TCHAR.h>
#include <iostream.h>
#include <process.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\crc32.h ===
#ifdef __cplusplus
extern "C" {
#endif

ULONG32
FstubCrc32(
    ULONG32 dwCrc,
    PVOID pvBuffer,
    SIZE_T cbBuffer
    );

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\ezparse.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    EzParse.cpp

Abstract:

    Poor man C/C++/any file parser.
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work

    GorN: 29-Sep-2000 - fix enumeration bug
    GorN: 29-Sep-2000 - add support for KdPrintEx like function
    GorN: 09-Oct-2000 - fixed "//" in the string bug 
    GorN: 23-Oct-2000 - IGNORE_CPP_COMMENT, IGNORE_POUND_COMMENT options added 
    GorN: 16-Apr-2001 - Properly handle \" within a string
    
ToDo:

    Clean it up
    

--*/

#define STRICT

#include <stdio.h>
#include <windows.h>

#pragma warning(disable: 4100)
#include <algorithm>
#include <xstring>
#include "ezparse.h"

DWORD ErrorCount = 0;

PEZPARSE_CONTEXT EzParseCurrentContext = NULL;

// To force build tool to recognize our errors

#define BUILD_PREFIX_FNAME "cl %s\n"
#define BUILD_PREFIX "cl wpp\n"

void ExParsePrintErrorPrefix(FILE* f, char * func)
{
    ++ErrorCount;
    if (EzParseCurrentContext) {
        fprintf(f,BUILD_PREFIX_FNAME "%s(%d) : error : (%s)", 
               EzParseCurrentContext->filename, 
               EzParseCurrentContext->filename, 
               EzGetLineNo(EzParseCurrentContext->currentStart, EzParseCurrentContext),
               func);
    } else {
        fprintf(f,BUILD_PREFIX "wpp : error : (%s)", func);
    }
}

LPCSTR skip_stuff_in_quotes(LPCSTR  q, LPCSTR  begin)
{
    char ch = *q;
    if (q > begin) {
        if (q[-1] == '\\') {
            return q - 1;
        }
    }
    for(;;) {
        if (q == begin) {
            return 0;
        }
        --q;
        if (*q == ch && ( (q == begin) || (q[-1] != '\\') ) ) {
            return q;
        }
    }
}


void
adjust_pair( STR_PAIR& str )
/*++
  Shrink the pair to remote leading and trailing whitespace
 */
{
    while (str.beg < str.end && isspace(*str.beg)) { ++str.beg; }
    while (str.beg < str.end && isspace(str.end[-1])) { --str.end; }
}

void
remove_cpp_comment(STR_PAIR& str)
{
    LPCSTR p = str.beg;

//    printf("rcb: %s\n", std::string(str.beg, str.end).c_str());

    // let's cut the comment in the beginning of the string

    for(;;) {
        // skip the whitespace
        for(;;) {
            if (p == str.end) return;
            if (!isspace(*p)) break;
            ++p;
        }
        str.beg = p;
        if (p + 1 == str.end) return;
        if (p[0] == '/' && p[1] == '/') {

            // we have a comment. Need to get to the end of the comment
            p += 2;
//    printf("rcd: %s %s\n", std::string(str.beg, p).c_str(), std::string(p,str.end).c_str());
            for(;;) {
                if (p == str.end) return;
                if (*p == '\r' || *p == '\n') {                    
                    str.beg = p;
                    break;
                }
                ++p;
            }
        
        } else {
            // no leading comment
            break;
        }
    }    

//    printf("rcc: %s %s\n", std::string(str.beg, p).c_str(), std::string(p,str.end).c_str());    

    for(;;) {
        if (p == str.end) return;
        if (*p == '"') {
            // don't look for comments within a string
            for(;;) {
                if (++p == str.end) return;
                if (*p == '"' && p[-1] != '\\') break;
            }
            ++p;
            continue;
        }
        
        if (p + 1 == str.end) return;
        if (p[0] == '/')
            if (p[1] == '/') break;
            else p += 2;
        else
            p += 1;
    }
    str.end = p;

//    printf("rce: %s\n", std::string(str.beg, str.end).c_str());
}

DWORD
ScanForFunctionCallsEx(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext,
    IN DWORD Options
    )
/*++

Routine Description:

    Scan the buffer for expressions that looks like function calls,
    i.e name(sd,sdf,sdf,sdf,sdf); . It will treat variable declaration
    with constructor call as a function call as well.
    
Inputs:

    begin, end -- pointers to the beginning and the end of the buffer
    Callback   -- to be called for every function
    Context    -- opaque context to be passed to callback
    ParseContext -- holds current parse state information    

--*/
{
    LPCSTR p = begin;
    LPCSTR q, funcNameEnd;
    DWORD Status = ERROR_SUCCESS;
    bool double_par = FALSE;

no_match:

    if (Options & NO_SEMICOLON) {
        q = end;
        Options &= ~NO_SEMICOLON;
    } else {   
        do {
            ++p;
            if (p == end) {
                return Status;
            }
        } while ( *p != ';' );
        // Ok. Now p points to ';' //

        q = p;
    }    
    
    do {
        if (--q <= begin) {
            goto no_match;
        }
    } while ( isspace(*q) );
    
    // Now q points on the first non white space character        //
    // If it is not a ')' then we need to search for the next ';' //

    if (*q != ')') {
        goto no_match;
    }

    ParseContext->macroEnd = q;

    // Ok. This is a function call (definition).
    // Now, let's go and collect all the arguments of the first level and
    // get to the name of the function

    // HACKHACK
    // We need a special case for functions that looks like
    //   KdPrintEx((Level, Indent, Msg, ...));
    //   Essentially, we need to treat them as
    //   KdPrintEx(Level, Indent, Msg, ...);

    const char *r = q;

    // check if we have ));

    do {
        if (--r <= begin) break; // no "));"
    } while ( isspace(*r) );

    double_par = r > begin && *r == ')';
    if (double_par) {
        q = r;
        // we assume that this is KdPrint((a,b,c,d,...)); at the moment
        // if our assumtion is wrong, we will retry the loop below
    }

retry: 
    {
        int level = 0;

        LPCSTR   ends[128], *current = ends;
        STR_PAIR strs[128];

//        LPCSTR   closing_parenthisis = q;

        *current = q;
        
        for(;;) {
            --q;
            if (q <= begin) {
                goto no_match;
            }
            switch (*q) {
            case ',':  if (!level) {
            	                 if (current - ends == 127) goto no_match; 
            	                 *++current = q; 
            	            }
                          break;
            case '(':  if (level) --level; else goto maybe_match; break;
            case ')':  ++level; break;
            case '\'': 
            case '"':  
                q = skip_stuff_in_quotes(q, begin); if(!q) goto no_match;
            }
        }
maybe_match:
        if (current - ends == 127) goto no_match; 
        *++current = q;
        funcNameEnd = q;

        // now q point to '(' we need to find name of the function //
        do {
            --q;
            if (q <= begin) {
                goto no_match;
            }

        } while(isspace(*q));

        // now q points to first not white character

        if (double_par) {
            // if we see )); and found a matching
            // parenthesis for the inner one, we can have
            // one of two cases
            //   1) KdPrint((a,b,c,d,...));
            //      or
            //   2) DebugPrint(a,b,(c,d));
            // If it is the latter, we just need to
            // retry the scanning, now using leftmost bracket as a starting point

            if (*q != '(') {
                // restore q to the rightmost parenthesis
                q = ParseContext->macroEnd;
                double_par = FALSE;
                goto retry;
            }
            funcNameEnd = q;
            // now q point to '(' we need to find name of the function //
            do {
                --q;
                if (q <= begin) {
                    goto no_match;
                }

            } while(isspace(*q));
        }
        
        // now q points to first non white character
        // BUGBUG '{' and '}' are allowed only in config files

        if (*q == '}') {
            for(;;) {
                if (--q < begin) goto no_match;
                if (*q == '{') break;
            }
            if (--q < begin) goto no_match;
        }

        if (!(isalpha(*q) || isdigit(*q) || *q == '_')) {
            goto no_match;
        }
        do {
            --q;
            if (q <= begin) {
                goto found;
            }
        } while ( isalpha(*q) || isdigit(*q) || *q == '_');
        ++q;

        if (isdigit(*q)) {
            goto no_match;
        }

found:
        if (Options & IGNORE_COMMENT)
        // Verify that it is not a comment
        //   # sign in the beginning of the line

        {
            LPCSTR line = q;
            //
            // Find the beginning of the line or file
            //

            for(;;) {
                if (line == begin) {
                    // Beginning of the file. Good enough
                    break;
                }
                if (Options & IGNORE_CPP_COMMENT && line[0] == '/' && line[1] == '/') {
                    // C++ comment. Ignore
                    goto no_match;
                }
                if (*line == 13 || *line == 10) {
                    ++line;
                    break;
                }
                --line;
            }

            //
            // If the first non-white character is #, ignore it
            //
            while (line <= q) {
                if ( *line != ' ' && *line != '\t' ) {
                    break;
                }
                ++line;
            }

            if (Options & IGNORE_POUND_COMMENT && *line == '#') {
                goto no_match;
            }
        }


        {
            int i = 0;

            strs[0].beg  = q;
            strs[0].end = funcNameEnd;
            adjust_pair(strs[0]);

            while (current != ends) {
                // putchar('<');printrange(current[0]+1, current[-1]); putchar('>');
                ++i;
                strs[i].beg = current[0]+1;
                --current;
                strs[i].end = current[0];
                adjust_pair(strs[i]);
                remove_cpp_comment(strs[i]);
            }

            ParseContext->currentStart = strs[0].beg;
            ParseContext->currentEnd = strs[0].end;
            ParseContext->doubleParent = double_par;

            Status = Callback(strs, i+1, Context, ParseContext);
            if (Status != ERROR_SUCCESS) {
                return Status;
            }
                
        }
        goto no_match;
    }
    // return ERROR_SUCCESS; // unreachable code
}

DWORD
ScanForFunctionCalls(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext    
    )
{
    return ScanForFunctionCallsEx(
        begin, end, Callback, Context,
        ParseContext, IGNORE_COMMENT);
}

DWORD 
EzGetLineNo(
    IN LPCSTR Ptr,
    IN OUT PEZPARSE_CONTEXT ParseContext
    )
/*++
    Computes a line number based on 
    an pointer within a buffer.

    Last known lineno/pointer is cached in ParseContext
    for performance
*/
{
    int count = ParseContext->scannedLineCount;
    LPCSTR downto = ParseContext->lastScanned;
        LPCSTR p = Ptr;

    if (downto > p) {
        count = 1;
        downto = ParseContext->start;
    }

    while (p > downto) {
        if (*p == '\n') {
            ++count;
        }
        --p;
    }

    ParseContext->scannedLineCount = count;
    ParseContext->lastScanned = Ptr;

    return count;
}

const char begin_wpp[] = "begin_wpp"; 
const char end_wpp[]   = "end_wpp";  
const char define_[]   = "#define";
const char enum_[]     = "enum ";
enum { 
    begin_wpp_size = (sizeof(begin_wpp)-1),
    end_wpp_size   = (sizeof(end_wpp)-1),
    define_size    = (sizeof(define_)-1),
    enum_size      = (sizeof(enum_)-1),
};

typedef struct _SmartContext {
    EZPARSE_CALLBACK Callback;
    PVOID Context;
    OUT PEZPARSE_CONTEXT ParseContext;
    std::string buf;
} SMART_CONTEXT, *PSMART_CONTEXT;

void DoEnumItems(PSTR_PAIR name, LPCSTR begin, LPCSTR end, PSMART_CONTEXT ctx)
{
    LPCSTR p,q;
    ULONG  value = 0;
    STR_PAIR Item;
    BOOL First = TRUE;
    ctx->buf.assign("CUSTOM_TYPE(");
    ctx->buf.append(name->beg, name->end);
    ctx->buf.append(", ItemListLong");
    p = begin;

    while(begin < end && isspace(*--end)); // skip spaces
    if (begin < end && *end != ',') ++end;

    for(;p < end;) {
        Item.beg = p;
        q = p;
        for(;;) {
            if (q == end) {
                goto enum_end;
            }
            if (*q == ',' || *q == '}') {
                // valueless item. Use current
                Item.end = q;
                break;
            } else if (*q == '=') {
                // need to calc the value. Skip for now //
                Item.end = q;
                while (q < end && *q != ',') ++q;
                break;
            }
            ++q;
        }
        adjust_pair(Item);
        if (Item.beg == Item.end) {
            break;
        }
        if (First) {ctx->buf.append("("); First = FALSE;} else ctx->buf.append(",");
        ctx->buf.append(Item.beg, Item.end);
        if (q == end) break;
        p = q+1;
        ++value;
    }
  enum_end:;  
    ctx->buf.append(") )");
    ScanForFunctionCallsEx(
        &ctx->buf[0], &ctx->buf[0] + ctx->buf.size(), ctx->Callback, ctx->Context,
        ctx->ParseContext, NO_SEMICOLON);
    Flood("enum %s\n", ctx->buf.c_str());
}

void DoEnum(LPCSTR begin, LPCSTR end, PSMART_CONTEXT Ctx)
{
    LPCSTR p, q, current = begin;

    for(;;) {
        p = std::search(current, end, enum_, enum_ + enum_size);
        if (p == end) break;
        q = std::find(p, end, '{');
        if (q == end) break;

        // let's figure out enum name //
        STR_PAIR name;
        name.beg = p + enum_size;
        name.end = q;

        adjust_pair(name);
        if ( *name.beg == '_' ) ++name.beg;

        p = q+1; // past "{";
        q = std::find(p, end, '}');
        if (q == end) break;

        if (name.end > name.beg) {
            DoEnumItems(&name, p, q, Ctx); 
        } else {
            ReportError("Cannot handle tagless enums yet");
        }

        current = q;
    }
}


DWORD
SmartScan(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext
    )
{
    LPCSTR block_start, block_end, current = begin;
    SMART_CONTEXT Ctx;
    Ctx.Callback = Callback;
    Ctx.Context  = Context;
    Ctx.ParseContext = ParseContext;
    
    for(;;) {
        block_start = std::search(current, end, begin_wpp, begin_wpp + begin_wpp_size);
        if (block_start == end) break;
        
        current = block_start;
        
        block_end = std::search(block_start, end, end_wpp, end_wpp + end_wpp_size);
        if (block_end == end) break;

        Flood("Block Found\n");
        // determine block type //
        
        //  begin_wpp enum
        //  begin_wpp config
        //  begin_wpp func
        //  begin_wpp define
        
        LPCSTR block_type = block_start + begin_wpp_size + 1;
        Flood("block_type = %c%c%c%c\n", block_type[0],block_type[1],block_type[2],block_type[3]); 
        
        if        (memcmp(block_type, "enum",   4) == 0) {
            // do enum block //
            DoEnum( block_type + 4, block_end, &Ctx );
            
        } else if (memcmp(block_type, "config", 6) == 0) {
            // do config block //
            ScanForFunctionCallsEx(block_type + 6, block_end, Callback, Context, ParseContext, IGNORE_POUND_COMMENT);

        } else if (memcmp(block_type, "func", 4) == 0) {
            LPCSTR func_start, func_end;
            current = block_type + 6;
            for(;;) {
                func_start = std::search(current, block_end, define_, define_ + define_size);
                if (func_start == block_end) break;
                func_start += define_size;
                while (isspace(*func_start)) {
                    if(++func_start == block_end) goto no_func;
                }
                func_end = func_start;
                while (!isspace(*func_end)) {
                    if(*func_end == '(') break;
                    if(++func_end == block_end) goto no_func;
                }
                if(*func_end != '(') {
                    Ctx.buf.assign(func_start, func_end);
                    Ctx.buf.append("(MSGARGS)");
                } else {
                    func_end = std::find(func_start, block_end, ')');
                    if (func_end == block_end) break;

                    ++func_end; // include ")"
                    Ctx.buf.assign(func_start, func_end); 
                }
                Flood("Func %s\n", Ctx.buf.c_str());
                ScanForFunctionCallsEx(
                    Ctx.buf.begin(), Ctx.buf.end(), Callback, Context,
                    ParseContext, NO_SEMICOLON);
                current = func_end;
            }            
            no_func:;
        } else if (memcmp(block_type, "define", 6) == 0) {
            // do define block
        } else {
            ReportError("Unknown block");
        }

        current = block_end + end_wpp_size;
    }
    if (current == begin) {
        // file without marking, let's do default processing
        Unusual("Reverting back to plain scan\n");
        ScanForFunctionCalls(begin, end, Callback, Context, ParseContext);
    }

    return ERROR_SUCCESS;
}

DWORD
EzParse(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context)
{
    
//    return EzParseEx(filename, SmartScan, Callback, Context);
    return EzParseEx(filename, ScanForFunctionCalls, Callback, Context, IGNORE_POUND_COMMENT);
}

DWORD
EzParseWithOptions(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options)
{
    
    return EzParseEx(filename, ScanForFunctionCalls, Callback, Context, Options);
}

DWORD
EzParseEx(
    IN LPCSTR filename, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options
    )
{    
    DWORD  Status = ERROR_SUCCESS;
    HANDLE mapping;
    HANDLE file = CreateFileA(filename, 
                              GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, 0);
    if (file == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        ReportError("Cannot open file %s, error %u\n", filename, Status );
        return Status;
    }
    DWORD size = GetFileSize(file, 0);
    mapping = CreateFileMapping(file,0,PAGE_READONLY,0,0, 0);
    if (!mapping) {
        Status = GetLastError();
        ReportError("Cannot create mapping, error %u\n", Status );
        CloseHandle(file);
        return Status;
    }
    PCHAR buf = (PCHAR)MapViewOfFileEx(mapping, FILE_MAP_READ,0,0,0,0);
    if (buf) {

        EZPARSE_CONTEXT ParseContext;
        ZeroMemory(&ParseContext, sizeof(ParseContext) );
    
        ParseContext.start = buf;
        ParseContext.filename = filename;
        ParseContext.scannedLineCount = 1;
        ParseContext.lastScanned = buf;
        ParseContext.previousContext = EzParseCurrentContext;
        ParseContext.Options = Options;
        EzParseCurrentContext = &ParseContext;
    
        Status = (*ProcessData)(buf, buf + size, Callback, Context, &ParseContext);

        EzParseCurrentContext = ParseContext.previousContext;
        UnmapViewOfFile( buf );

    } else {
        Status = GetLastError();
        ReportError("MapViewOfFileEx failed, error %u\n", Status );
    }
    CloseHandle(mapping);
    CloseHandle(file);
    return Status;
}

DWORD
EzParseResourceEx(
    IN LPCSTR ResName, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context)
{    
    DWORD  Status = ERROR_SUCCESS;
    HRSRC hRsrc;

    hRsrc = FindResource(
        NULL, //this Module
        ResName, 
        RT_RCDATA);
        
    if (hRsrc == NULL) {
        Status = GetLastError();
        ReportError("Cannot open resource %s, error %u\n", ResName, Status );
        return Status;
    }

    HGLOBAL hGlobal = LoadResource(NULL, hRsrc);
    if (!hGlobal) {
        Status = GetLastError();
        ReportError("LockResource failed, error %u\n", Status );
        return Status;
    }

    DWORD size = SizeofResource(NULL, hRsrc);
    
    PCHAR buf = (PCHAR)LockResource(hGlobal);
    if (buf) {

        EZPARSE_CONTEXT ParseContext;
        ZeroMemory(&ParseContext, sizeof(ParseContext) );
    
        ParseContext.start = buf;
        ParseContext.filename = ResName;
        ParseContext.scannedLineCount = 1;
        ParseContext.lastScanned = buf;
        ParseContext.previousContext = EzParseCurrentContext;
        EzParseCurrentContext = &ParseContext;
    
        Status = (*ProcessData)(buf, buf + size, Callback, Context, &ParseContext);
        EzParseCurrentContext = ParseContext.previousContext;
    } else {
        Status = GetLastError();
        ReportError("LockResource failed, error %u\n", Status );
    }
    // According to MSDN. There is no need to call Unlock/Free Resource
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/

#include <windows.h>

//
// This code comes from Dr. Dobbs Journal, May 1992
//

ULONG32
FstubCrc32(
    ULONG32 dwCrc,
    PVOID pvBuffer,
    SIZE_T cbBuffer
    );


ULONG32 FstubCrcTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };

ULONG32
FstubCrc32(
    IN ULONG32 dwCrc,
    IN PVOID pvBuffer,
    IN SIZE_T cbBuffer
    )
{
    PUCHAR pbBuffer = (PUCHAR) pvBuffer;

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ FstubCrcTable[(UCHAR) dwCrc ^ *pbBuffer++];
    }

    return dwCrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\ezparse.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    EzParse.h

Abstract:

    Poor man C/C++/any file parser declaration.
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work

ToDo:

    Clean it up

--*/

typedef struct STR_PAIR
{
    LPCSTR beg;
    LPCSTR end;
    bool empty() const { return beg == end; }
    STR_PAIR():beg(0),end(0){}
    STR_PAIR(LPCSTR inBeg, LPCSTR inEnd):beg(inBeg),end(inEnd) {}
} STR_PAIR, *PSTR_PAIR;

typedef struct _EZPARSE_CONTEXT {
    LPCSTR start;
    LPCSTR currentStart;
    LPCSTR currentEnd;
    LPCSTR filename;
    LPCSTR lastScanned;
    UINT   scannedLineCount;
    LPCSTR macroEnd;
    BOOL   doubleParent;
    struct _EZPARSE_CONTEXT * previousContext;
    DWORD  Options;
} EZPARSE_CONTEXT, *PEZPARSE_CONTEXT;

void ExParsePrintErrorPrefix(FILE* f, char* funcname);
extern DWORD ErrorCount;

#define ReportError ExParsePrintErrorPrefix(stdout, __FUNCTION__);printf

typedef
DWORD (*EZPARSE_CALLBACK) (PSTR_PAIR, INT, PVOID, PEZPARSE_CONTEXT);

typedef
DWORD (*PROCESSFILE_CALLBACK) (
    LPCSTR, LPCSTR, EZPARSE_CALLBACK,PVOID,PEZPARSE_CONTEXT);

DWORD 
EzGetLineNo(
    IN LPCSTR Ptr,
    IN PEZPARSE_CONTEXT
    );

DWORD
EzParse(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context);

DWORD
EzParseWithOptions(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options
    );

DWORD
EzParseEx(
    IN LPCSTR filename, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options);

DWORD
EzParseResourceEx(
    IN LPCSTR ResName, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context);

DWORD
SmartScan(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext
    );

DWORD
ScanForFunctionCalls(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext    
    );

enum {
    NO_SEMICOLON         = 0x01,
    IGNORE_CPP_COMMENT   = 0x02, 
    IGNORE_POUND_COMMENT = 0x04, 
    IGNORE_COMMENT = IGNORE_CPP_COMMENT | IGNORE_POUND_COMMENT,
};
    
DWORD
ScanForFunctionCallsEx(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext,
    IN DWORD Options
    );

__declspec(selectany) int DbgLevel = 0;

enum DBG_LEVELS {
    DBG_UNUSUAL = 1,
    DBG_NOISE   = 2,
    DBG_FLOOD   = 3,
};    

#define Always printf
#define Flood (DbgLevel < DBG_FLOOD)?0:printf
#define Noise (DbgLevel < DBG_NOISE)?0:printf
#define Unusual (DbgLevel < DBG_UNUSUAL)?0:printf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\fieldtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    FieldTable.h

Abstract:

    Field Table declarations for tracewpp.exe

    field table allows tpl interpreter to
    work with data collected by during scanning of the source files.
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work

ToDo:

    Clean it up

--*/

extern LPCSTR FieldNames[];

struct FieldHolder;

struct Enumerator {
    virtual void Reset(std::string Filter) = 0;
    virtual void Next(std::string Filter) = 0;
    virtual bool Valid() const = 0;
    virtual const FieldHolder* GetData() const = 0;
    virtual ~Enumerator(){}
};

struct FieldHolder {
    virtual DWORD PrintField(int fieldId, FILE* f, const Enumerator **) const = 0;
    virtual BOOL Hidden(std::string filter="") const { return FALSE; }
};

struct VectorPtrTag {};
struct VectorTag {};
struct MapTag{};
struct MapPtrTag{};

template <class T> const FieldHolder* GetFieldHolder(const T& Data, VectorPtrTag) { return Data;}
template <class T> const FieldHolder* GetFieldHolder(const T& Data, VectorTag)    { return &Data;}
template <class T> const FieldHolder* GetFieldHolder(const T& Data, MapPtrTag)    { return Data.second;}
template <class T> const FieldHolder* GetFieldHolder(const T& Data, MapTag)       { return &Data.second;}

template <class Container, class Tag>
class EnumeratorFromContainer : public Enumerator 
{
    typedef typename Container::const_iterator const_iterator;
    const_iterator _current, _begin, _end;
public:

    EnumeratorFromContainer(const Container& v):
        _begin(v.begin()),_end(v.end()),_current(v.begin()) {}
    
    void Reset(std::string Filter) { _current = _begin; while(Valid() && GetData()->Hidden(Filter)) ++_current;}
    void Next(std::string Filter) { ++_current; while(Valid() && GetData()->Hidden(Filter)) ++_current; }
    bool Valid() const { return _current != _end; }
    
    const FieldHolder* GetData() const { return GetFieldHolder(*_current, Tag()); }
};

template <class Container, class Tag> 
Enumerator* GetEnumFromContainer(const Container& v, Tag) {
    return new EnumeratorFromContainer< Container, Tag >( v );
}

#define DEFAULT_FID 0

#define TEXT_FIELD(FieldId) break; case fid_ ## FieldId: \
    if (__f__ == 0) { \
        printf("%s.%s can not be enumerated\n",__Object__, #FieldId); \
        exit(1); \
    }
    
#define ENUM_FIELD(FieldId,FieldName,Tag) break; case fid_ ## FieldId: \
    if (__pEnum__ == 0) { \
       printf("%s.%s is an enumeration\n",__Object__, #FieldId); \
       exit(1); \
    } \
    *__pEnum__ = GetEnumFromContainer(FieldName, Tag() );

#define DEFAULT_TEXT_FIELD break; case DEFAULT_FID: \
    if (__f__ == 0) {printf("%s can not be enumerated\n",__Object__); exit(1);}
    
#define DEFAULT_ENUM_FIELD(EnumName,Tag) break; case DEFAULT_FID: \
    if (__pEnum__ == 0) {printf("%s is an enumeration\n",__Object__); exit(1);} \
    *__pEnum__ = GetEnumFromContainer(EnumName, Tag() );

#define BEGIN_FIELD_TABLE(__ObjectName__, __Output__) \
    DWORD PrintField(int __FieldId__, FILE* __Output__, const Enumerator** __pEnum__) const \
    { \
        DWORD __status__ = ERROR_SUCCESS; \
        static char* __Object__ = #__ObjectName__; \
        FILE* __f__ = __Output__; \
        UNREFERENCED_PARAMETER(__pEnum__); \
        switch(__FieldId__) { case -1:;

#define BEGIN_FIELD_TABLE_NONAME(__Output__) \
    DWORD PrintField(int __FieldId__, FILE* __Output__, const Enumerator** __pEnum__) const \
    { \
        DWORD __status__ = ERROR_SUCCESS; \
        FILE* __f__ = __Output__; \
        UNREFERENCED_PARAMETER(__pEnum__); \
        switch(__FieldId__) { case -1:;

#define END_FIELD_TABLE \
            break;\
            default: __status__ = ERROR_NOT_FOUND; \
            ReportError("\"%s\" (%d) is not a member of \"%s\"\n",FieldNames[__FieldId__], __FieldId__,__Object__); \
            exit(1); \
        } \
        return __status__; \
    }

template <class Container, class Tag>
class ContainerAdapter : public FieldHolder {
    LPCSTR __Object__; // END_FIELD_TABLE uses __Object__ as an object name //
    Container& _container;
public:
    ContainerAdapter(LPCSTR name, Container& container):
        _container(container), __Object__(name) {}

    BEGIN_FIELD_TABLE_NONAME(out)
        TEXT_FIELD(Count) fprintf(out, "%d", _container.size());
        DEFAULT_ENUM_FIELD(_container, Tag)
    END_FIELD_TABLE    
};

class StringAdapter : public FieldHolder {
    LPCSTR __Object__; // END_FIELD_TABLE uses __Object__ as an object name //
    const std::string& _string;
public:
    StringAdapter(LPCSTR name, const std::string& string):
        __Object__(name), _string(string) {}
    
    BEGIN_FIELD_TABLE_NONAME(out)
        DEFAULT_TEXT_FIELD { fprintf(out, "%s", _string.c_str()); }
    END_FIELD_TABLE    
};

template<class Iterator>
struct IteratorAdapter : FieldHolder {
    Iterator* theRealThing;

    explicit IteratorAdapter(Iterator* aRealThing):theRealThing(aRealThing) {}

    DWORD PrintField(int fieldId, FILE* f, const Enumerator** pEnum) const {
        return (*theRealThing)->PrintField(fieldId, f, pEnum);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\tpl.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tpl.cpp

Abstract:

    template file interpreter for tracewpp.exe
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work
    GorN: 29-Sep-2000 - fix WHERE clause handling

ToDo:

    Clean it up

--*/

#define UNICODE

#include <stdio.h>
#include <windows.h>

#pragma warning(disable: 4786)
#pragma warning(disable: 4503) // decorated length 

#pragma warning(disable: 4512) // cannot generate assignment
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#pragma warning(disable: 4018) // signed/unsigned mismatch
#pragma warning(disable: 4267) // 'return' : conversion from 'size_t' to 'int' 
#include <xmemory>
#include <xstring>
#include <set>
#include <map>
#pragma warning(disable: 4663 4018)
#include <vector>
//#pragma warning(default: 4018 4663) // signed/unsigned mismatch
#pragma warning(default: 4100)

#include "ezparse.h"
#include "fieldtable.h"
#include "tpl.h"

LPCSTR FieldNames[] = {
    #define FIELD_NAME(f) #f,
        INSERT_FIELD_NAMES
    #undef FIELD_NAME
};

OBJECT_MAP ObjectMap;

typedef std::map<std::string, FieldId, strless> FIELD_MAP;

FIELD_MAP FieldMap;

void PopulateFieldMap() {
    #define FIELD_NAME(_name_) FieldMap[#_name_] = fid_ ## _name_;
      INSERT_FIELD_NAMES
    #undef FIELD_NAME

    FIELD_MAP::iterator i;
}

////////////////////////////////////////////////////////////////////////////////////////////

struct LoopVar : FieldHolder {
    Enumerator * Enum;
    std::string Name;

    LoopVar() {}

    DWORD PrintField(int fieldId, FILE* f, const Enumerator** pEnum) const {
        return Enum->GetData()->PrintField(fieldId, f, pEnum);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////

char Delimiter = '`';

std::string COMMENT("*");

std::string FORALL("FORALL");
std::string ENDFOR("ENDFOR");

std::string IF("IF");
std::string ENDIF("ENDIF");

std::string DELIMITER("DELIMITER");
std::string INCLUDE("INCLUDE");
std::string ENV("ENV");

typedef enum Action {
    actText,
    actVar,
    actLoop,
    actIf,
    actInclude,
    actLiteralString,
} Action;

#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
struct Chunk {
    struct {
        Action  action : 8;
        UCHAR   level  : 8;
        SHORT   loopEnd:16;
    };
    union {
        struct {
            LPCSTR textBeg;
            LPCSTR textEnd;
        };
        struct {
            FieldHolder * p;
            FieldId FieldNo;
            std::string Filter;
        };
    };

    Enumerator* getEnum() { 
        const Enumerator* Enum; p->PrintField(FieldNo, 0, &Enum); return (Enumerator*)Enum; }
    void printField(FILE* out) const {
        p->PrintField(FieldNo, out, 0); }  

    Chunk(){} // to make vector happy
    Chunk (Action Act, FieldHolder* fh, FieldId fid, int lvl, const std::string& filter):
        action(Act),FieldNo(fid),p(fh),level((UCHAR)lvl),Filter(filter) {} 
    Chunk (FieldHolder* fh, FieldId fid):action(actVar),FieldNo(fid),p(fh) {} 
    Chunk (LPCSTR b, LPCSTR e):action(actText),textBeg(b),textEnd(e) {}
    Chunk (Action act, LPCSTR b, LPCSTR e):action(act),textBeg(b),textEnd(e) {}
    explicit Chunk(std::string const& Text):action(actLiteralString),Filter(Text) {}
};

#define MAX_LOOP_LEVEL 127

struct TemplateProcessor {
    LoopVar Loop[MAX_LOOP_LEVEL];
    std::vector<Chunk> Chunks;

    void RunIt(int beg, int end, FILE* out) {
        for(int i = beg; i < end; ) {
            switch(Chunks[i].action) {
            	case actLiteralString:
            	{
            		fwrite(Chunks[i].Filter.c_str(), Chunks[i].Filter.length(), 1, out );
            		++i;
            		break;
            	}
                case actText:
                {
                    for(LPCSTR p = Chunks[i].textBeg; p < Chunks[i].textEnd; ++p) {
                        if (*p != '\r') putc(*p, out);
                    }
                    ++i;
                    break;
                }
                case actVar:
                {
                    Chunks[i].printField(out);
                    ++i;
                    break;
                }
                case actIf:
                {
                    if (!Chunks[i].p->Hidden(Chunks[i].Filter)) {
                        RunIt(i+1, Chunks[i].loopEnd, out);
                    }
                    i = Chunks[i].loopEnd;
                    break;
                }
                case actLoop:
                {
                    Enumerator * Enum = Chunks[i].getEnum();
                    Loop[Chunks[i].level].Enum = Enum;
                    for(Enum->Reset(Chunks[i].Filter); Enum->Valid(); Enum->Next(Chunks[i].Filter) ) {
                        RunIt(i+1, Chunks[i].loopEnd, out);
                    }
                    delete Enum;
                    i = Chunks[i].loopEnd;
                    break;
                }
                case actInclude:
                {
                    ProcessTemplate(Chunks[i].textBeg, Chunks[i].textEnd, out);
                    ++i;
                    break;
                }
            }
        }
    }

    void DoId(LPCSTR q, LPCSTR p, FieldId& fid, FieldHolder*& fh)
    {
        LPCSTR dot = q;

        while (q < p && isspace(*q)) ++q;
        while (q < p && isspace(p[-1])) --p;

        while (dot < p && *dot != '.') ++dot;

        std::string ObjectName(q, dot);
        OBJECT_MAP::iterator it = ObjectMap.find( ObjectName );

        if (it == ObjectMap.end()) {
            ReportError("Var not found: %s\n", ObjectName.c_str() );
            exit(1);
    	} else {
    		std::string FieldName;
    		
    		if (dot == p) {
    			fid = (FieldId)fid___default__;
    			FieldName.assign("__default__");
    		} else {
    			++dot;
    			while (p < dot && isspace(*dot)) ++dot;

    			FieldName.assign(dot,p);
    			
    			FIELD_MAP::iterator fit = FieldMap.find( FieldName.c_str() );
    			if (fit == FieldMap.end()) {
    				ReportError("FieldNotFound: %s.%s\n", ObjectName.c_str(), FieldName.c_str() );
                    exit(1);
    			} else {
    				fid = fit->second;
    			}
    		}
    	}
    	fh = it->second;
    }

    void DoVar(LPCSTR q, LPCSTR p) {
        FieldHolder* fh;
        FieldId      fid;

        DoId(q,p, fid, fh);
        
        Chunks.push_back( Chunk(fh, fid) );
    }

    void DoLoop(int loopLevel, LPCSTR beg, LPCSTR end) {
        FieldHolder* fh;
        FieldId      fid;

        std::string LoopVar;
        std::string LoopSet;
        std::string Filter;

        LPCSTR p,q;

        p = beg+6; while (p < end && isspace(*p)) ++p;
        q = p;     while(p < end && !isspace(*p)) ++p;

        LoopVar.assign(q,p);
        Loop[loopLevel].Name = LoopVar;

        p += 4; while (p < end && isspace(*p)) ++p;
        q = p;  while(p < end && !isspace(*p)) ++p;
        
        DoId(q,p, fid, fh);
        LoopSet.assign(q, p);

        p += 7; while (p < end && isspace(*p)) ++p;
        q = p;  
        if (q < end) {
            p = end; while(p > q && isspace(*--p));
            if (p < end && !isspace(*p)) ++p;
        }

        Filter.assign(q,p);

        Flood("FORALL %s IN %s WHERE %s\n", LoopVar.c_str(), LoopSet.c_str(),
            Filter.c_str());
        
        ObjectMap[LoopVar] = &Loop[loopLevel]; 

        Chunks.push_back( Chunk(actLoop, fh, fid, loopLevel, Filter) );
    }

    void DoIf(int loopLevel, LPCSTR beg, LPCSTR end) {
        FieldHolder* fh;
        FieldId      fid;

        std::string Object;
        std::string Filter;

        LPCSTR p,q;

        p = beg+3; while (p < end && isspace(*p)) ++p;
        q = p;     while(p < end && !isspace(*p)) ++p;

        DoId(q,p, fid, fh); // Split id //
        Object.assign(q, p);

        while (p < end && isspace(*p)) ++p;
        while (p < end && isspace(end[-1]) ) --end;

        Filter.assign(p,end);

        Flood("IF %s %s\n", Object.c_str(), Filter.c_str() );
        
        Chunks.push_back( Chunk(actIf, fh, fid, loopLevel, Filter) );
    }


    DWORD
    CompileAndRun(
        IN LPCSTR begin, 
        IN LPCSTR   end,
        IN FILE* out
        )
    {
        LPCSTR p = begin, PlainText = begin;
        int loop = -1;
        int loopLevel = -1;
        bool comment;

        Chunks.erase(Chunks.begin(), Chunks.end());
        Chunks.reserve(128);    

        for(;;) {
    		LPCSTR q;
    		for(;;) {
    			if (p == end) {
    				Chunks.push_back( Chunk(PlainText, p) );
    				goto done;
    			}				
    			if (*p == Delimiter)
    				break;
    			++p;
    		}
    		q = ++p;
    		comment = (p < end && *p == '*');
    		for(;;) {
    			if (p == end) {
    				ReportError("Unmatched delimiters\n");
    				exit(1);
    			}
    			if (*p == Delimiter) {
    			    if (comment) {
    			        if (p[-1] == '*') break;
    			    } else {
    			        break;
    			    }
    		    }
    			++p;
    		}
    		if (q-1 > PlainText) {
    			Chunks.push_back( Chunk(PlainText, q-1) );
    		}
    		if (p == q) {
    			// PERFPERF If the previous chunk was a text, we can extend it 
    			Chunks.push_back( Chunk(q-1, p) );
    		} else {
    			std::string x(q,p);
    			if (x.compare(0, IF.size(), IF) == 0) {
    				int previous = loop;
    				// KLUDGE merge with FORALL

                    if (loopLevel == MAX_LOOP_LEVEL) {
                        ReportError("Too many nested blocks!\n");
                        exit(1);
                    }
                    ++loopLevel;

    				loop = static_cast<int>( Chunks.size() );

    				DoIf(loopLevel, q,p);

                    if (previous >= 32765) {
                        ReportError("Too many chunks. Make loopEnd a UINT, %d\n", previous);
                        exit(1);
                    }
    				Chunks.back().loopEnd   = (SHORT)previous;

    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    				
    			} else if (x.compare(0, FORALL.size(), FORALL) == 0) {
    				int previous = loop;

                    if (loopLevel == MAX_LOOP_LEVEL) {
                        ReportError("Too many nested loops!\n");
                        exit(1);
                    }
                    ++loopLevel;

    				loop = static_cast<int>( Chunks.size() );

    				DoLoop(loopLevel, q,p);

                    if (previous >= 32765) {
                        ReportError("Too many chunks. Make loopEnd a UINT, %d\n", previous);
                        exit(1);
                    }
    				Chunks.back().loopEnd   = (SHORT)previous;

    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    				
    			} else if (x.compare(0, DELIMITER.size(), DELIMITER) == 0 && x.size() > 10) {
    			    Delimiter = x[10];
    			} else if (x.compare(0, ENV.size(), ENV) == 0) {
    			    // we need to replace this field with 
    			    // the value of the specified env variable
    			    LPCSTR val = getenv( std::string(q+4,p).c_str() );
    			    if (val != NULL) {
                        Chunks.push_back( Chunk(std::string(val)) );
    			    }
    			} else if (x.compare(0, COMMENT.size(), COMMENT) == 0) {
    			    // eat away the whitespace
    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    			} else if (x.compare(0, INCLUDE.size(), INCLUDE) == 0) { // Doesn't work
        			Chunks.push_back( 
        			    Chunk(actInclude, q + INCLUDE.size() + 1, p) );
    			} else if ((x.compare(0, ENDIF.size(), ENDIF) == 0) 
    			       || (x.compare(0, ENDFOR.size(), ENDFOR) == 0)) {

    			    // KLUDGE make them separate or rename both to simply END   

    				// End will be set in ENDFOR //
    				if (loop == -1) {
    					ReportError("ENDFOR without FORALL\n");
    					exit(1);
    				}

                    ObjectMap.erase( Loop[loopLevel].Name );

    				int previous = Chunks[loop].loopEnd;

                    // BUGBUG have a check that confirms that we didn't run out of space
    				Chunks[loop].loopEnd = (SHORT)Chunks.size();

    				loop = previous;
    				--loopLevel;

    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    			} else {
    				DoVar(q, p);
    			}
    		}
    		PlainText = ++p;
    	}
    done:;	
    	if (loop != -1) {
    		ReportError("No ENDFOR for loop, %d\n", loop);
    		exit(1);
    	}

    	RunIt(0, static_cast<int>( Chunks.size() ), out);

        return 0;
    }
};

    
DWORD
processTemplate(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK, 
    IN PVOID Context,
    IN PEZPARSE_CONTEXT
    )
{
    FILE *out = (FILE*)Context;
    TemplateProcessor tpl;
    return tpl.CompileAndRun(begin,end,out);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\tpl.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tpl.h

Abstract:

    template file interpreter declarations
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    gorn 03-Apr-1999 -- hacked it all together to prove that this can work

To Do:

    Clean it up

--*/

#define INSERT_FIELD_NAMES \
  FIELD_NAME(__default__) \
  FIELD_NAME(Version) \
  FIELD_NAME(Time) \
  FIELD_NAME(Date) \
  FIELD_NAME(Count) \
  FIELD_NAME(Struct) \
  FIELD_NAME(Indent) \
  FIELD_NAME(Comment) \
  FIELD_NAME(Checksum) \
  FIELD_NAME(Messages) \
  FIELD_NAME(Text) \
  FIELD_NAME(RawText) \
  FIELD_NAME(MsgNames) \
  FIELD_NAME(MacroArgs) \
  FIELD_NAME(MacroExprs) \
  FIELD_NAME(FixedArgs) \
  FIELD_NAME(ReorderSig) \
  FIELD_NAME(Value) \
  FIELD_NAME(GooActualValues) \
  FIELD_NAME(GooArgs) \
  FIELD_NAME(GooVals) \
  FIELD_NAME(GooId) \
  FIELD_NAME(GooPairs) \
  FIELD_NAME(MsgNo) \
  FIELD_NAME(GuidNo) \
  FIELD_NAME(Guid) \
  FIELD_NAME(BitNo) \
  FIELD_NAME(Arguments) \
  FIELD_NAME(Permutation) \
  FIELD_NAME(LogArgs) \
  FIELD_NAME(Name) \
  FIELD_NAME(RawName) \
  FIELD_NAME(Alias) \
  FIELD_NAME(CtlMsg) \
  FIELD_NAME(Enabled) \
  FIELD_NAME(ID) \
  FIELD_NAME(GRP) \
  FIELD_NAME(ARG) \
  FIELD_NAME(MSG) \
  FIELD_NAME(MofType) \
  FIELD_NAME(DeclVars) \
  FIELD_NAME(References) \
  FIELD_NAME(No) \
  FIELD_NAME(Line) \
  FIELD_NAME(CanonicalName) \
  FIELD_NAME(UppercaseName) \
  FIELD_NAME(Timestamp) \
  FIELD_NAME(EquivType) \
  FIELD_NAME(MacroStart) \
  FIELD_NAME(MacroEnd) \
  FIELD_NAME(MacroName) \
  FIELD_NAME(Path) \
  FIELD_NAME(Extension) \
  FIELD_NAME(TypeSig) \
  FIELD_NAME(MsgVal) \
  FIELD_NAME(Func) \
  FIELD_NAME(FormatSpec) 

    
extern LPCSTR FieldNames[];

enum FieldId {
  #define FIELD_NAME(_name_) fid_ ## _name_,
     INSERT_FIELD_NAMES
  #undef FIELD_NAME
};

DWORD
processTemplate(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN PEZPARSE_CONTEXT ParseContext
    );

void PopulateFieldMap();

void ProcessTemplate(LPCSTR b, LPCSTR e, void* Context);

struct strless {
    bool operator() (const std::string& a, const std::string&b) const { return a.compare(b) < 0; }
};

typedef std::map<std::string, FieldHolder*, strless> OBJECT_MAP;

extern OBJECT_MAP ObjectMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\tracewpp\tracewpp.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tracewpp.c

Abstract:

    Parameter processing and main entry point for tracewpp.exe
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    gorn 03-Apr-1999 -- hacked together to prove that this can work

    GorN: 29-Sep-2000 - do not scan files that didn't change
    GorN: 29-Sep-2000 - support -notimechk -nohashchk -dll switches
    GorN: 29-Sep-2000 - add support for KdPrintEx((level,comp,msg,...)) like functions
    GorN: 09-Oct-2000 - fix hashing; added NULL arg
    GorN: 07-Mar-2001 - add arglimit option
    GorN: 05-Sep-2001 - add preserveext option (do not strip specified extensions)
    GorN: 05-Sep-2001 - add Func field in message (to be used from templates)
    GorN: 05-Sep-2001 - hash full path, in addition to all the messages
    BassamT: 01-Oct-2001 - Added NoMsg option + filter for functions that do not have MSG,...
    GorN: 15-May-2002 - handle assumed MSG properly
    
ToDo:

    NullArg          Remove limitation of having only one NULL arg in a func
    all              Clean it up
    parseConfigCheck for premature termination Ex: CUSTOM_TYPE(x, ItemListLong(dfdf))
    cool             Automatic fill of the arguments if ...
    nice             better error chk 
    types to mof     it stinks to generate long enums multiple times
    later            guidless
    bug              check for types with dup names
    bug              tpl: check for unterminated keyword
    later            detect WPP_CLEANUP -- complain
    print in macros  what to do about prints in macro?
    cmdline          get the flags from the env variable
    !!!              Don't assume that whatever is not recognized is func
    bug              updated CRC computations to properly work with consts
    bug              enum doesn't work
    bug              %10!..! doesnt' work
    bug              %% is not handled
    mess             rename hidden => visible
    mess             remove ugly MSGTYPBASE. Make FmtStr 0 based
    mess             let message share some of the func field handlers
    traceprt         think how to make the level indenting
    ezparse          report unmatched end_wpp    
    now              get cmdline options from a file or env.var
    later            handle "str" STRMACRO "another string" as a MSG arg
    
    strange output

..\logsup.c(4180) : error : Unterminated Format SpecifierHere is the signature: (0)
..\logsup.c(4180) : error : Extra argument. Only 0 are specified in the string

    why we didn't catch the error

                CsDbgPrint(LOG_NOISE,
                ("[FM] FmpSetGroupEnumOwner: Group %1!ws! not found\n"));

        CsDbgPrint(LOG_UNUSUAL, (
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "no slots are available in the node table.\n"
            ));

    printf("Port no in network order %1!port!, regular order %1!u!, 0x0102);

NetDeviceTrace( NETDEV_DBG_EXIT | NETDEV_DBG_INFO,
                "ClientMdlSetup Client[%10!d!], RCB[%11!d!]: "
                "Exit w/ Func 0x%12!04X!, Send 0x%14!04X!, Recv 0x%15!04X!",
                deviceExtension->Ordinal, // LOGULONG
                RequestCB->RequestIdx, // LOGUSHORT
                ios->MajorFunction, // LOGUCHAR
                ios->MajorFunction, // LOGUCHAR
                sendBytes, // LOGULONG
                recvBytes); // LOGULONG => AV's

    DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE

    later            handle KdPrintEx
    later            add "if" to templates (at least if not empty)
    requirement      md5
    later            detect WPP_INIT_TRACING
    main             Time ourselves and print how fast we are
    useful           ignore anything but .c .cxx .cpp .c++
    useful           -gen{a,b,c}h.tpl
    -ext:.c.cxx.cpp.c++
    -v verbose
    -q extra quiet
    footprint        merge multiple formats together
    difficult?       Think how to unify DoTraceMacro0 TraceLazy, etc
    figureout        DbgPrint
    -odir:path
    trivial          add "\" to -odir if needed
    nice             scan
    -gen:{a.tpl}auto.c
    -gen:{a.tpl}*.c
    outstanding      take plain DebugPrint format as well
    difficult?       Add generation of by value types
    
--*/

#define STRICT

#include <stdio.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>

#pragma warning(disable: 4702) // unreachable code

#pragma warning(disable: 4786)
#pragma warning(disable: 4503) // decorated length 

#pragma warning(disable: 4512) // cannot generate assignment
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#pragma warning(disable: 4267) // 'return' : conversion from 'size_t' to 'int' 
#include <xmemory>
#include <xstring>
#include <set>
#include <map>
#pragma warning(disable: 4663)
#pragma warning(disable: 4018) // signed/unsigned mismatch
#include <vector>
//#pragma warning(default: 4018 4663) // signed/unsigned mismatch
#pragma warning(default: 4100)
#include <algorithm>

#include "ezparse.h"
#include "crc32.h"
#include "md5.h"
#include "fieldtable.h"
#include "tpl.h"

#define override

//typedef ULONG CRC32;

using namespace std;

BOOL    md5 = TRUE;
BOOL    reorder = FALSE;
BOOL    userMode = TRUE;
BOOL    noshrieks = FALSE;
UINT    SeparateTraceGuidPerFile = 1;
INT     MSGTYPBASE = 10;
UINT    MessageCount = 0;    
UINT    ArgBase = 1;
BOOL    CheckTimestamp = TRUE;
BOOL    CheckHash = TRUE;
BOOL    IgnoreDupTypes = FALSE;
int     arglimit = 32;

//string         OutputInc ("_tracewpp.h");
//string         OutputMof ("_tracewpp.mof");
string  OutputMac;
string  OutputDir (".\\");
//string         ArrayPrefix("WPP_");

string  MacroPrefix("LOG");
string  AllowedExtensions(".c.cxx.cpp.c++.C.CPP");
string  PreserveExtensions("");
string  CurrentDir;


#define DEFAULT_UM_GEN_OPTION "{um-default.tpl}*.tmh"
#define DEFAULT_KM_GEN_OPTION "{km-default.tpl}*.tmh"

#define DEFAULT_GEN_OPTION (userMode?DEFAULT_UM_GEN_OPTION:DEFAULT_KM_GEN_OPTION)

#define DEFAULT_CONFIG_NAME "defaultwpp.ini"
string LOCAL_CONFIG_NAME("localwpp.ini");

string         WppDefault(DEFAULT_CONFIG_NAME);
vector<string> SearchDirs;
//string         Revision;
string         LocalConfig;
string         ComponentName;

BOOL CheckExtension(const string& str, string::size_type pos, const string& Extensions)
{
	string::size_type q, n;
	n = str.size() - pos; // extension length
	q = Extensions.find(&str[pos], 0, n);
	if ( (q == string::npos)
        || (q + n < Extensions.size() && Extensions[q + n] != '.') ) 
	{
		return FALSE;
	}
	return TRUE;
}

// Checks whether string passed has an allowed extension
// Lame: uses global variable AllowedExtensions
BOOL AllowedExtension(const string str)
{
    string::size_type p = str.rfind('.');
    if (p == string::npos) {
        Unusual("File %s has no extension\n", str.c_str() );
        return FALSE;
    }
    if ( !CheckExtension(str, p, AllowedExtensions) )
    {
        Unusual("File %s has unrecognized extension\n", str.c_str() );
        return FALSE;
    }
    return TRUE;
}

inline size_t fprint_str(FILE* f, const string& str, LPCSTR replace, LPCSTR replace_with) {
    int skipped = 0;
    for (int i = 0; i < str.length(); ++i) {
    	  char ch = str[i];
    	  char* pos = strchr(replace, ch);
    	  if (pos) {
    	  	ch = replace_with[ pos - replace ];
    	  	if (ch == '@') {
    	  		++skipped;
    	  		continue;
		}
    	  }
	  fputc(ch, f);
    }
    return str.length() - skipped;
}

inline size_t fprint_str(FILE* f, const string& str) {
    return fwrite(str.c_str(), str.length(), 1, f );
}

inline size_t fprint_str(FILE* f, LPCSTR beg, LPCSTR end) {
    return fwrite(beg, end - beg, 1, f );
}

inline size_t fprint_str(FILE* f, const STR_PAIR& Pair) {
    return fwrite(Pair.beg, Pair.end - Pair.beg, 1, f );
}

inline int stoi(const STR_PAIR& str, LPCSTR name)
{
    LPCSTR p = str.beg;
    int sum = 0;
    int sgn = 1;

    if (p < str.end && *p == '-') {
        ++p; sgn = -1;
    }

    while (p < str.end) {
        if (!isdigit(*p)) {
            ReportError("%s should be a number (%s supplied)\n",
                        name, string(str.beg, str.end).c_str() );
            break;            
        }
        sum = 10 * sum + (*p - '0');
        ++p;
    }
    return sgn * sum; 
}

inline unsigned char HexVal(int ch) { 
	return (unsigned char)(isdigit(ch) ? ch - '0' : ch - 'a' + 10); }

UINT Hex(LPCSTR s, int n) 
{
    UINT res = 0;
    while(n--) {
        res = res * 16 + HexVal(*s++);
    }
    return res;
}

CHAR HexDigit(int val) { 
    if (val < 10) return (CHAR)(val + '0'); 
             else return (CHAR)(val + 'a' - 10);
}

ULONGLONG GetFileModificationTime(const string& str)
{
    WIN32_FIND_DATA FindData;
    ULONGLONG Time;
    
    HANDLE FindHandle = FindFirstFile(str.c_str(), &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        return 0;
    }
    FindClose(FindHandle);

    CopyMemory(&Time, &FindData.ftLastWriteTime, sizeof(Time));
    return Time;
}

// Prototypes //

void DealWithCmdLineOptions(LPCSTR s);

void DealWithCmdLineOptions(LPCSTR beg, LPCSTR end)
{
    DealWithCmdLineOptions(string(beg,end).c_str() );
}


struct Hasher {
    virtual void Init() = 0;
    virtual void Finalize() = 0;
    virtual void Hash(const void* buf, int nBytes) = 0;
    virtual int Size() const = 0;
    virtual const unsigned char * Buf() const = 0;

    void Hash(const std::string& str) {
        Hash(str.begin(), (int)str.size());
    }
    void HashStr(const std::string& str) { Hash(str); }

    void fromString(LPCSTR beg, LPCSTR end) 
    {
        int n = min((ULONG)(end - beg)/2, Size());
        unsigned char * buf = BufRW();
        ZeroMemory(buf, Size());
        for(int i = 0; i < n; ++i) {
            buf[i] = HexVal(beg[2*i]) * 16 + HexVal(beg[2*i + 1]);
        }
    }
    void print(FILE* out) const {
        int n = Size();
        const UCHAR* buf = Buf();
        for(int i = 0; i < n; ++i) {
            fprintf(out, "%x%x", buf[i] >> 4, buf[i] & 0xF); 
        }
    }

    bool operator ==(const Hasher& b) const {
        return Size() == b.Size() && memcmp(Buf(), b.Buf(), Size()) == 0;
    }
    
private:
    unsigned char* BufRW() { return (unsigned char*)Buf(); }
};

class Crc32Hasher : public Hasher 
{
    ULONG Crc;
public:
    override void Init() { Crc = (ULONG)~0; }
    override void Finalize() {}
    override void Hash(const void* buf, int nBytes) {
        Crc = FstubCrc32(Crc, (PVOID)buf, nBytes);
    }
    override int Size() const { return sizeof(Crc); }
    override const unsigned char * Buf() const { return (UCHAR*)&Crc; }
};

class Md5Hasher : public Hasher
{
    MD5_CTX Ctx;
public:
    override void Init() 
    {
        MD5Init(&Ctx);
    }
    override void Finalize() 
    {
        MD5Final(&Ctx);
    }
    override void Hash(const void* buf, int nBytes) 
    {
        MD5Update(&Ctx, (const unsigned char*)buf, nBytes); 
    }
    virtual int Size() const
    {
//        assert(MD5DIGESTLEN == sizeof(GUID));
        return MD5DIGESTLEN; // == 16
    }
    virtual const unsigned char * Buf() const
    {
        return Ctx.digest;
    }
};

//typedef Crc32Hasher DefaultHasher;
typedef Md5Hasher DefaultHasher;

void ReplaceCrOrLfWith(string& s, char ch)
{
    for(int i = 0; i < s.size(); ++i) {
        if (s[i] == '\n' || s[i] == '\r') s[i] = ch;
        if (s[i] == '"') s[i] = '\'';
    }
}

string currentFileName();

bool
Files_AddFile(const string& Name, string Path, const WIN32_FIND_DATA& FindData) ;

enum {
    WT_MACRONAME = 0x00000001, // TypeName is actually a MacroName. Don't have to be prepended with Log Macro Prefix
};

struct WppType : FieldHolder {
    string TypeName;
    string EquivType;  // c-type
    string MacroStart; // WPP_LOGVALARG(%s, if not specified
    string MofType;    // yeah
    string Extension; // something to be merged with MofType
    string FormatSpec; // sprintf style    
    string Sig;
    int priority;
    int ArgConsumed;
    mutable BOOL   Used;
    DWORD  Flags;

    void hash(Hasher& hash) const {hash.Hash(TypeName);} // BUGBUG ?? Maybe we need to hash it

    string sig() const { return Sig; }
    bool isConstant() const { return EquivType.size() == 0; }

    WppType() {} // To make STL happy

    WppType(const string& a, const string&b, const string& c, 
            const string& d, const string& e, const string& f, 
            const string& g, int prio, int argConsumed):
        TypeName(a), EquivType(b), MacroStart(c), MofType(d),  
        Extension(e), FormatSpec(f), Sig(g), 
        priority(prio),Used(0),ArgConsumed(argConsumed) {}

//    WppType(LPCSTR beg, LPCSTR end):TypeName(beg, end),Used(0){}
//    explicit WppType(char name):TypeName(&name, &name+1),Used(0){}
    bool operator < (const WppType& b) const {
        int diff = b.priority - priority; // higher prio first
        if (diff < 0) return TRUE;
        if (diff > 0) return FALSE;
        return TypeName.compare(b.TypeName) < 0;
    }

    virtual BOOL Hidden(std::string) const { return !Used; }

    BEGIN_FIELD_TABLE(WppType, f)
        TEXT_FIELD(Name)       fprint_str(f, TypeName);
        TEXT_FIELD(EquivType)  fprint_str(f, EquivType);
        TEXT_FIELD(MacroName)  
            { 
                if (!(Flags & WT_MACRONAME)) fprint_str(f, MacroPrefix);
                fprint_str(f, TypeName);
            }
        TEXT_FIELD(MacroStart) fprintf(f, MacroStart.c_str(), EquivType.c_str());
        TEXT_FIELD(MacroEnd)   fprintf(f, ")");
        TEXT_FIELD(MofType)    fprint_str(f, MofType);
        TEXT_FIELD(Extension)  fprint_str(f, Extension);
        TEXT_FIELD(FormatSpec) fprint_str(f, FormatSpec);
    END_FIELD_TABLE
};
typedef map<string,WppType,strless> TYPE_SET;

string SimpleValueMacroStart("WPP_LOGTYPEVAL(%s,");
string SimplePtrMacroStart("WPP_LOGTYPEPTR(");

TYPE_SET TypeSet;

struct Argument : FieldHolder {
    const WppType* Type;
    string Name;
    string OverrideName;
    int    No;

    bool operator < (const Argument& b) const { return *Type < *b.Type; }

    Argument(){} // To make STL happy //
    Argument(string name, const WppType* type):Type(type),Name(name)
        { ReplaceCrOrLfWith(Name, ' '); }

    void hash(Hasher& hash) const {
        hash.Hash(Name);
        if(Type) Type->hash(hash);
    }

    BEGIN_FIELD_TABLE(Argument, f)
        TEXT_FIELD(No)      {fprintf(f, "%d",   No);}
        TEXT_FIELD(Name)    {fprint_str(f, Name, ",\"\n", ".' ");}
        TEXT_FIELD(RawName) {fprint_str(f, Name);}
        TEXT_FIELD(MofType) {fprint_str(f, Type->MofType); fprint_str(f,Type->Extension);}
    END_FIELD_TABLE
};

struct Reorder : FieldHolder {
    string Name;
    vector<int> Args;

    Reorder(){} // to make stl happy
    explicit Reorder(string name, const vector<Argument>& args): Name(name) 
    {   Args.resize( args.size() );
        for(int i = 0; i < args.size(); ++i) {
            Args[i] = args[i].No - MSGTYPBASE;
        }
    }

    bool operator < (const Reorder& b) const 
        { return Name.compare(b.Name) < 0; }

    BEGIN_FIELD_TABLE(Reorder, f)
        TEXT_FIELD(Name) fprint_str(f, Name);
        TEXT_FIELD(Permutation) 
            {
                for(int i = 0; i < Args.size(); ++i) {
                    fprintf(f, ", a%d", Args[i]);
                }
            }
        TEXT_FIELD(Arguments) 
            {
                fprintf(f,"MSG");
                for(int i = 0; i < Args.size(); ++i) {
                    fprintf(f, ", a%d", i);
                }
            }
    END_FIELD_TABLE    
};

set<Reorder> ReorderSet; 

string GetReorderSig(const vector<Argument>& args)
{
    string sig;

    if (args.size() > 256) {
        ReportError("Only upto 256 arguments are supported\n");
        return sig;
    }
    if (args.size() <= 16) {
        sig.resize(args.size());
        for(int i = 0; i < args.size(); ++i) {
            sig[i] = HexDigit(args[i].No - MSGTYPBASE);
        }
    } else {
        sig.resize(2 * args.size());
        for(int i = 0; i < args.size(); ++i) {
            int val = args[i].No;
            sig[2 * i] = HexDigit(val >> 16);
            sig[2 * i + 1] = HexDigit(val & 15);
        }
    }

    ReorderSet.insert( Reorder(sig, args) );
    return sig;
}



#include "parsed-string.hxx"

struct TypeSig : FieldHolder {
    string Name;
    vector<const WppType*> Types;
    BOOL Unsafe;

    TypeSig() {} // To make STL happy

    TypeSig(const vector<Argument>& args, const string& sig, BOOL unsafe):
        Unsafe(unsafe)
    {
        Name.assign(sig);
        for(int i = 0; i < args.size(); ++i) {
            Types.push_back(args[i].Type);
        }
    }

    bool operator < (const TypeSig& b) const {
        return Name.compare(b.Name) < 0;
    }
    
    virtual BOOL Hidden(std::string str) const {
        if (str.size() == 0) { return FALSE; }
        else if (str.compare("UnsafeArgs") == 0) { return !Unsafe; }
        else if (str.compare("!UnsafeArgs") == 0) { return Unsafe; }
        else { ReportError("Unknown filter '%s'\n", str.c_str()); exit(1); }
        return NULL; 
    }
    
    BEGIN_FIELD_TABLE(TypeSig, f)
        TEXT_FIELD(Name)       fprint_str(f, Name);
        TEXT_FIELD(Count)      fprintf(f, "%d", Name.size());
        TEXT_FIELD(Arguments)  
            {
                for(int i = 0; i < Types.size(); ++i) {
                    fprintf(f,", ");
                    fprint_str(f, Types[i]->EquivType);
                    fprintf(f, " _a%d", i+1);
                }
            }
        TEXT_FIELD(LogArgs) 
            {
                for(int i = 0; i < Types.size(); ++i) {
                    fprintf(f, Types[i]->MacroStart.c_str(), 
                               Types[i]->EquivType.c_str());
                    fprintf(f, "_a%d) ", i+1);
                }
            }
        TEXT_FIELD(DeclVars) 
            {
                for(int i = 0; i < Types.size(); ++i) {
                    fprintf(f, "%s _a%d = va_arg(ap, %s); ", 
                    Types[i]->EquivType.c_str(), i+1,
                    Types[i]->EquivType.c_str());
                }
            }
    END_FIELD_TABLE
};
typedef map<string,TypeSig,strless> TYPESIG_MAP;
TYPESIG_MAP TypeSigMap;

TypeSig* GetTypeSig(const vector<Argument>& args, BOOL unsafe)
{
    string sig;
    if (unsafe) {
        sig.assign("v");
    }
    for(int i = 0; i < args.size(); ++i) {
        sig.append(args[i].Type->sig() );
    }
    TYPESIG_MAP::iterator it = TypeSigMap.find( sig );
    if ( it == TypeSigMap.end() ) {
        // we need to add one //
        return &(TypeSigMap[ sig ] = TypeSig(args, sig, unsafe));
    }
    return &it->second;
}

void Fill(
    string pattern)
{
    WIN32_FIND_DATA findData;
    HANDLE handle;

    handle = FindFirstFile(pattern.c_str(), &findData);
    if (handle == INVALID_HANDLE_VALUE) {
        DWORD status = GetLastError();
        if (status != ERROR_FILE_NOT_FOUND) {
            Noise("FindFirstFile(%s): error %d\n", pattern.c_str(), GetLastError() );
        }
        return;
    }

    string::size_type p = pattern.find_last_of(":\\");
    if (p != string::npos) {
        pattern.resize(p+1); // to include the symbol
    } else {
        pattern.resize(0);
    }

    do {
        Files_AddFile(findData.cFileName, pattern, findData);
    } while( FindNextFile(handle, &findData) );

    FindClose(handle);
}

struct Group : FieldHolder {
    UINT GrpId;
    vector<string> MsgIds;
    string _Name;

    Group(){}
    Group(UINT id, string Name, string Msg):GrpId(id),_Name(Name) { MsgIds.push_back(Msg); }

    BEGIN_FIELD_TABLE(Group, f) 
        TEXT_FIELD(GuidNo) fprintf(f, "%d", GrpId / 32);
        TEXT_FIELD(BitNo)  fprintf(f, "%d", GrpId & 31);
        TEXT_FIELD(Name)   fprint_str(f, _Name);
        TEXT_FIELD(References) 
            {
                vector<string>::const_iterator i;
                for(i = MsgIds.begin(); i != MsgIds.end(); ++i) {
                    putc(' ', f); fprint_str(f, *i); 
                }
            }
    END_FIELD_TABLE
};

//void RegenerateMacroMap();

struct Prefix{
    string FuncName;
//    string MsgPrefix;
//    vector<Argument> Args;
    ParsedFormatString FmtStr;

    Prefix(){}
    Prefix(PSTR_PAIR str, UINT count);
};

int inline sign(UCHAR val) { return val?1:0; }

enum FuncOptions {
    FO_VAR_ARGS = 0x01,
    FO_UNSAFE   = 0x02,
    FO_DOUBLEP  = 0x04,
    FO_LINE_BEG = 0x08,
    FO_NOMACRO  = 0x10,
    FO_NOMSG    = 0x20,
};

struct Func : FieldHolder {
    const Prefix *prefix, *suffix;
    string _name;
    vector<string> Args;  // all supplied args - var args
    vector<string> Goo;   // values for GooId, usually = GooId
    vector<string> GooId; // all unrecognized args + LEV

    STR_PAIR assumedMsg;
    
    UCHAR Grp, MsgArg, Msg, Arg;
    UCHAR Num, Indent, MsgVal, NullArg; // BUGBUG -- what if multiple NULL args?

    ULONG Options;
    size_t nAssumedArgs;

    void SetPS(const Prefix* val, const Prefix*& var, LPCSTR msg)
    {
        if (val && val->FmtStr.ArgCount > 0 && MsgArg) {
            ReportError("Function %s has (something,(MSG,...)) type\n"
                        "It cannot have non-const %s\n",
                        _name.c_str(), msg );
        }
        var = val;
    }

    void set(ULONG flag) { Options |= flag; }
    ULONG is(ULONG flag) const { return Options & flag; }
    void SetLineBeg() { Options |= FO_LINE_BEG; }
    void SetVarArgs() { Options |= FO_VAR_ARGS | FO_LINE_BEG; }
    void SetUnsafe()  { Options |= FO_UNSAFE; }
    void SetDoubleP() { Options |= FO_DOUBLEP; }
    void SetNoMsg() { Options |= FO_NOMSG; }

    BOOL LineBeg() const { return Options & FO_LINE_BEG; }
    BOOL VarArgs() const { return Options & FO_VAR_ARGS; }
    BOOL Unsafe() const  { return Options & FO_UNSAFE; }
    BOOL DoubleP() const { return Options & FO_DOUBLEP; }
    BOOL NoMsg() const { return Options & FO_NOMSG; }

    void SetPrefix(const Prefix* pr) { SetPS(pr,prefix,"prefix"); }
    void SetSuffix(const Prefix* sf) { SetPS(sf,suffix,"suffix"); }

    virtual BOOL Hidden(std::string str) const {
        if (str.size() == 0) { return FALSE; }
        if (is(FO_NOMACRO)) return str.compare("NoMacro") != 0;
        else if (str.compare("MsgArgs") == 0) { return !MsgArg; }
        else if (str.compare("!MsgArgs") == 0) { return MsgArg; }
        else if (str.compare("!DoubleP && !MsgArgs") == 0) { return !(!DoubleP() && !MsgArg); }
        else if (str.compare("DoubleP && !MsgArgs") == 0) { return !(DoubleP() && !MsgArg); }
        else if (str.compare("NoMsg") == 0) { return !NoMsg(); }
        else if (str.compare("!NoMsg") == 0) { return NoMsg(); }
        else if (str.compare("!NoMsg && !MsgArgs") == 0) { return !(!NoMsg() && !MsgArg); }
        else if (str.compare("NoMsg && !MsgArgs") == 0) { return !(NoMsg() && !MsgArg); }
        else if (str.compare("!DoubleP && !MsgArgs && !NoMsg") == 0) { return !(!DoubleP() && !MsgArg && !NoMsg()); }
        else if (str.compare("DoubleP && !MsgArgs && !NoMsg") == 0) { return !(DoubleP() && !MsgArg && !NoMsg()); }
        else { ReportError("Unknown filter '%s'\n", str.c_str()); exit(1); }
        return NULL; 
    }

#if 0
    // returns recognized argument count
    int count() const {
        return sign(Grp) + sign(Id) + sign(Msg) + sign(Arg);
    }
#endif
    void printArgs(FILE* f) const {
        for(int i = 1; i <= Num; ++i) {
            if (i > 1) fprintf(f, ", ");
            else fprintf(f, "(");
            fprint_str(f, Args[i]);
/*
            if (i == Grp) fprintf(f,"GRP");
            else if (i == Id) fprintf(f,"ID");
            else if (i == Msg) fprintf(f,"MSG");
            else if (i == Arg) fprintf(f,"ARG");
            else fprintf(f,"_unknown%d", i);
*/            
        }
        fprintf(f, ")");
    }

    BEGIN_FIELD_TABLE(Func, out)
        TEXT_FIELD(Name) fprintf(out, "%s", _name.c_str() );
        TEXT_FIELD(Arguments) {printArgs(out);}
        TEXT_FIELD(MSG) {fputs(Msg?"MSG":"\"\"",out);}
        TEXT_FIELD(ARG) {fputs(Arg?"ARG":"",out);}
        TEXT_FIELD(GRP) {fputs(Grp?"GRP":"WPP_DEFAULT_GROUP_ID",out);}
//        TEXT_FIELD(ID)  {fprintf(out,  Id?"ID":"WPP_AUTO_ID");}
        TEXT_FIELD(FixedArgs) 
            {
                for(int i = 0; i < Args.size(); ++i) {
                    fprint_str(out, Args[i]);
                    fprintf(out,", ");
                }
            } 
        TEXT_FIELD(GooArgs)
            {
                for(int i = 0; i < GooId.size(); ++i) {
                    if (i > 0) fprintf(out,",");
                    fprint_str(out, GooId[i]);
                }
            }
        TEXT_FIELD(GooVals) 
            {
                for(int i = 0; i < Goo.size(); ++i) {
                    if (i > 0) fprintf(out,", ");
                    fprint_str(out, Goo[i]);
                }
            }
        TEXT_FIELD(GooId)
            {
                for(int i = 0; i < GooId.size(); ++i) {
                    fprintf(out,"_");
                    fprint_str(out, GooId[i]);
                }
            }
    END_FIELD_TABLE

    Func(){}
    Func(std::string Name):_name(Name),prefix(0),suffix(0),
        Grp(0), MsgArg(0), Msg(0), Arg(0),
        Num(0), Indent(0), NullArg(0), MsgVal(0), Options(0),nAssumedArgs(0) {}
};

#define GRP(x) ((x).Grp)
#define MSG(x) ((x).Msg)
#define ARG(x) ((x).Arg)
#define NUM(x) ((x).Num)

//BOOL
//UpgradeFormatSpecifiers(string& str, int startCount, string* TypeSig = 0);

void printTraceGuid(FILE* f, int guidno);

struct Message : FieldHolder {
//    string Msg;
    string IdName;
    string msgval;
    string Indent;
    string reorderSig;
    int    LineNo;
    ParsedFormatString FormatStr;
    TypeSig* typeSig;
    const Func*    func;

	vector<Argument> Args;
	vector<string> GooActualValues;

    UINT id;
	string TypeListHost;

    virtual BOOL Hidden(std::string str) const { return func->Hidden(str); }

	void hash(Hasher& hash) const;
	int ArgConsumed() const ;
	
//  void ChkArgs() const;
    
    BEGIN_FIELD_TABLE(Message, f)
        TEXT_FIELD(Text)    { FormatStr.printMofTxt(f,LineNo); }
        TEXT_FIELD(RawText)    { FormatStr.print(f); }
        TEXT_FIELD(Indent)  
            { 
                if(Indent.size()) {
                    fprintf(f, "INDENT="); 
                    fprint_str(f, Indent);
                }
            }
        TEXT_FIELD(MsgNo)   { fprintf(f, "%d", id & 0xFFFF); }
        TEXT_FIELD(GuidNo)  { fprintf(f, "%d", id >> 16); }
        TEXT_FIELD(Guid)    { printTraceGuid(f, id >> 16); }
        TEXT_FIELD(Name)    { fprint_str(f, IdName ); }
        TEXT_FIELD(Line)    { fprintf(f, "%d", LineNo ); }
        TEXT_FIELD(MsgVal)  { fprint_str(f, msgval ); }
        TEXT_FIELD(ReorderSig)  { fprint_str(f, reorderSig ); }
        TEXT_FIELD(TypeSig) { fprint_str(f, typeSig->Name); }
        TEXT_FIELD(Func) { fprint_str(f, func->_name); }
        TEXT_FIELD(Count)   { fprintf(f, "%d", FormatStr.ArgCount); }
//        TEXT_FIELD(CtlMsg)  { ??? }
//        TEXT_FIELD(Enabled)
        ENUM_FIELD(Arguments, Args, VectorTag)
        TEXT_FIELD(GooActualValues)
        {
            size_t k = func->nAssumedArgs;
            size_t n = min(func->GooId.size()-k, GooActualValues.size());
            for(size_t i = 0; i < n; ++i) {
                fprintf(f, "_");
                fprint_str(f, GooActualValues[i], "\"\n\r", "'@@");
            }
        }
        TEXT_FIELD(GooPairs)
            {
                size_t k = func->nAssumedArgs;
                // print assumed arguments
                for(size_t i = 0; i < k; ++i) {
                    fprintf(f, " ");
                    fprint_str(f, func->GooId[i]);
                    fprintf(f, "=");
                    fprint_str(f, func->Goo[i], "\"\n", "' ");
                }
                // print the goo we pulled out of the trace statement itself
                size_t n = min(func->GooId.size()-k, GooActualValues.size());
                for(size_t i = 0; i < n; ++i) {
                    fprintf(f, " ");
                    fprint_str(f, func->GooId[i+k]);
                    fprintf(f, "=");
                    fprint_str(f, GooActualValues[i], "\"\n\r", "'@@");
                }
            }
        TEXT_FIELD(FixedArgs) 
            {
                for(int i = 0; i < func->Args.size(); ++i) {
                    fprint_str(f, func->Args[i]);
                    if ((unsigned)i == func->Args.size()-1 && func->NoMsg()) 
                        {;} // no comma needed
                    else 
                        fprintf(f, ", ");
                }
            }
        TEXT_FIELD(GooVals) 
            {
                for(int i = 0; i < func->Goo.size(); ++i) {
                    if (i > 0) fprintf(f,", ");
                    fprint_str(f, func->Goo[i]);
                }
            }
        TEXT_FIELD(GooArgs)
            {
                for(int i = 0; i < func->GooId.size(); ++i) {
                    if (i > 0) fprintf(f,",");
                    fprint_str(f, func->GooId[i]);
                }
            }
        TEXT_FIELD(GooId)
            {
                for(int i = 0; i < func->GooId.size(); ++i) {
                    fprintf(f,"_");
                    fprint_str(f, func->GooId[i]);
                }
            }
        TEXT_FIELD(MacroExprs) 
            {
                for(int i = 0; i < Args.size(); ++i) {
                    if (Args[i].OverrideName.size() > 0) {
                        fprintf(f,",");
                        fprint_str(f, Args[i].OverrideName);
                    } else {
                        fprintf(f, ",a%d", Args[i].No);
                    }
                }
            }
        TEXT_FIELD(MacroArgs) 
            {
                if (!func->NoMsg()) {
                    fprintf(f,"MSG");
                }
                    for(int i = 0; i < Args.size(); ++i) {
                        if (Args[i].OverrideName.size() > 0) {
    //                        fprint_str(f, Args[i].OverrideName);
                        } else {
                            if (i != 0 || !func->NoMsg()) fprintf(f,",");
                            fprintf(f, "a%d", i + MSGTYPBASE);
                        }
                    }
                
            }
    END_FIELD_TABLE

    Message(){}
    Message(
        const string& idTxt,
        const string&,     
        const vector<Argument>&,
        UINT msgid,
        int lineno,
        const ParsedFormatString& fmtStr,
        const Func& aFunc
        )
    :IdName(idTxt), id(msgid), LineNo(lineno), 
     FormatStr(fmtStr),func(&aFunc)
    {
 
        
        Args.resize(FormatStr.ArgCount, Argument("",0) );

        for(int i = 0; i < FormatStr.Items.size(); ++i) {
            int no = FormatStr.Items[i].no;
            if (no > 0) {
                Args[no-1] = Argument
                    (FormatStr.Items[i].expr, FormatStr.Items[i].type);
                Args[no-1].OverrideName = FormatStr.Items[i].argName;
                Args[no-1].No = no-1 + MSGTYPBASE;
            }
        }

        if (reorder) {
            sort(Args.begin(), Args.end());
        }
        for (int j = 0; j < FormatStr.Items.size(); ++j) {
            int& no = FormatStr.Items[j].no;
            if (no > 0) {
                // find new msg no for that
                for(int k = 0; k < Args.size(); ++k) {
                    if (Args[k].No == no-1 + MSGTYPBASE) {
                        no = MSGTYPBASE + k;
                        break;
                    }
                }
//                Args[no-1].OverrideName = FormatStr.Items[i].argName;
            }
        }
        typeSig = GetTypeSig(Args, func->Unsafe());

        if (func->MsgArg) {
            reorderSig = GetReorderSig(Args);
        }
        
//        UpgradeFormatSpecifiers(Msg, 10, (typeSig.size())?0:&TypeSig); 
//        ChkArgs();
    }
};

struct File : FieldHolder {
    string _CanonicalName; // lower case, bad chars => _
    string _Path;
    string _UppercaseName; // uppercase canonical
    string _Name;
    string _BaseName;      // no extension
    ULONGLONG ModificationTime;

    //
    // Since the file is a member of the set type
    // fields that don't affect set membership should be mutables
    //
    mutable vector<Message*> Msgs;
    mutable set<string, strless> IdsFound;

    BEGIN_FIELD_TABLE(File, out)
        TEXT_FIELD(Name)          fprint_str(out, _Name );
        TEXT_FIELD(Path)          fprint_str(out, _Path );
        TEXT_FIELD(CanonicalName) fprint_str(out, _CanonicalName );
        TEXT_FIELD(UppercaseName) fprint_str(out, _UppercaseName );
        ENUM_FIELD(Messages, Msgs, VectorPtrTag)
    END_FIELD_TABLE

    File(){} // to make STL and compiler happy

    string FullFileName() const {
    	string Tmp(_Path);
    	Tmp.append(_Name);
    	return Tmp;
    }

    File(const string& FileName, const string& Path, const WIN32_FIND_DATA& FindData)
    	:_Name(FileName), _Path(Path)
   	{    
        CopyMemory(&ModificationTime, &FindData.ftLastWriteTime, sizeof(ModificationTime));
   
        // Canonicalize FileName
        // i.e. make it suitable to be a DEFINE name
        //
        // Cut the path out. Replace all non-alphanumeric symbols
        // with an underscore.

        string::size_type pos = _Name.rfind('\\');
        if (pos == string::npos) {
            // No back slash
            _CanonicalName.assign(_Name);
        } else {
            // Get only the name part
            _CanonicalName.assign(_Name.begin() + pos, _Name.end());
        }

        // strip extension for a base name 
        string::size_type ext = _CanonicalName.rfind('.');
        if (ext != string::npos && !CheckExtension(_CanonicalName, ext, PreserveExtensions)) {
            // there was a "."
            _BaseName.assign(_CanonicalName.begin(),
                             _CanonicalName.begin() + ext);
        } else {
            _BaseName.assign(_CanonicalName);
        }

        // Can't have a digit in the first position
        // Let's prepend it with an underscore

        {
            char ch = _CanonicalName[0];
            if ( ch >= '0' && ch <= '9' ) {
                _CanonicalName.insert(0, '_');
            }
        }

        _UppercaseName.assign( _CanonicalName );
        
        for(UINT i = 0; i < _CanonicalName.size(); ++i) {
            char ch = _CanonicalName[i];
            if ( (ch == '_') 
              || ((ch >= 'A') && (ch <= 'Z'))
              || ((ch >= '0') && (ch <= '9')) )
            {
                // Good Character. Do nothing
            } else if ( (ch >= 'a') && (ch <= 'z') ) {
                _UppercaseName[i] = static_cast<char>(ch - 'a' + 'A');
            } else {
                _CanonicalName[i] = '_';
                _UppercaseName[i] = '_';
            }
        }
    }

    bool operator < (const File& b) const {
        return _CanonicalName.compare(b._CanonicalName) < 0;
    }
};

int Message::ArgConsumed() const 
{
    vector<Argument>::const_iterator i = Args.begin();
    int sum = 0;
    for(;i != Args.end(); ++i) {
        sum += i->Type->ArgConsumed;
    }
    return sum;
}

void Message::hash(Hasher& hash) const 
{
    vector<Argument>::const_iterator i = Args.begin();
    for(;i != Args.end(); ++i) {
        i->hash(hash);
    }
    hash.Hash(&id, sizeof(id));
    hash.Hash(IdName);
    hash.Hash(FormatStr.HostString);
}

typedef map<string, string, strless > TYPE_MAP;
typedef map<string, Message, strless > MSG_MAP;
typedef map<string, Func, strless > FUNC_MAP;
typedef map<string, Group, strless> GROUP_MAP;
typedef vector< Prefix > PREFIX_VECTOR;
typedef set<File> FILES;

FILES::iterator CurrentFile;
string CurrentTpl;

string currentFileName()
    { return CurrentFile->_Name; }

void MsgMapHash(
	const MSG_MAP& msgmap,
	Hasher& hash
	)
{
	MSG_MAP::iterator i = msgmap.begin();
	for(;i != msgmap.end(); ++i) {
	    i->second.hash(hash);
	}
}

void expand(IN OUT string& str, const string& id);

BOOL
parseMsg(
    IN LPCSTR beg,
    IN LPCSTR end,
    IN OUT string& str,
    OUT LPCSTR* strend = 0
    )
{
    LPCSTR p = beg;

    for(;;) {

        if (*p == '_' || isalpha(*p)) {
            const char * id = p;
            for(;;) {
               if (++p == end) { expand(str, string(id,p)); goto done; }
               if (*p == '_' || isalpha(*p) || isdigit(*p)) continue;
               break;
            }
            expand(str, string(id,p));
        }
        if (*p == ',')  goto done;
        if (*p == '"') {
            const char * run = ++p;
            for(;;) {
                if (p == end) goto unterminated;
                if (*p == '"' && p[-1] != '\\') break;
                ++p;
            }
            str.append(run,p);
        }
        if (++p == end) break;
    }
done:
    if (str.size() == 0) {
        ReportError("parsing %s. Cannot find format string\n",
           string(beg,end).c_str() );
        return FALSE;
    }

    // eat whitespace at the end
    while (str.size() > 0 && isspace( str.end()[-1]) ) 
        { str.resize(str.size()-1); }
    // get rid of pesky trailing \n    
    if (str.size() >= 2 && str.end()[-1] == 'n' && str.end()[-2] == '\\') {
        str.resize(str.size()-2);
    }

    Flood("msg: \"%s\".\n", str.c_str() );
    if (strend) {
        *strend = p;
    }
    return TRUE;
    
unterminated:
    ReportError("Unterminated string constant\n");
     return FALSE;
}        

BOOL
parseArgs(
    IN LPCSTR beg, 
    IN LPCSTR end,
    IN OUT vector<Argument>& args
    );

#define isvar(x) ( isalnum(x) || (x == '_') )

Prefix::Prefix(
    IN PSTR_PAIR str, 
    IN UINT count):FuncName(str[1].beg, str[1].end)
{
    vector<string> ArgNames;

    if (count > 2) {
        string msg;
        if (str[2].beg < str[2].end && 
            str[2].beg[0] == '"') parseMsg(str[2].beg, str[2].end, msg);
        else msg.assign(str[2].beg, str[2].end);
        FmtStr.init( msg );
    }
    if (count > 3) {
        count -= 3; str += 2;
        while (count-- > 0) {
            ++str; ArgNames.push_back( string(str->beg,str->end) );
        }
    }

    // check that sizes match //
    if (ArgNames.size() > FmtStr.ArgCount ) {
        ReportError("Prefix: Extra argument. Only %d are specified in the string\n", FmtStr.ArgCount);
        exit(1);
    }
    if (ArgNames.size() < FmtStr.ArgCount ) {
        ReportError("Prefix: Not enough args. %d are specified in the string\n", FmtStr.ArgCount);
        exit(1);
    }

    for(int i = 0; i < FmtStr.Items.size(); ++i) {
        int no = FmtStr.Items[i].no;
        if (no > 0) {
            FmtStr.Items[i].argName = ArgNames[no-1];
            FmtStr.Items[i].expr = ArgNames[no-1];
        }
    }
}

struct GuidEntry : FieldHolder {
    GUID guid;
    string comment;
    int count;

    vector<Message*> Msgs;

    void printTxt(FILE* f) const {
        fprintf(f,"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                guid.Data1,guid.Data2,guid.Data3,
                guid.Data4[0],guid.Data4[1],guid.Data4[2],guid.Data4[3],
                guid.Data4[4],guid.Data4[5],guid.Data4[6],guid.Data4[7] );
    }
    void printDat(FILE* f) const {
        fprintf(f,"{0x%08x,0x%04x,0x%04x,{0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x}}",
                guid.Data1,guid.Data2,guid.Data3,
                guid.Data4[0],guid.Data4[1],guid.Data4[2],guid.Data4[3],
                guid.Data4[4],guid.Data4[5],guid.Data4[6],guid.Data4[7] );
    }

    BEGIN_FIELD_TABLE(GuidEntry, f) 
        TEXT_FIELD(Text) { printTxt(f); }
        TEXT_FIELD(Struct) { printDat(f);}
        TEXT_FIELD(Comment) fprintf(f, "%s", comment.c_str() );
        ENUM_FIELD(Messages, Msgs, VectorPtrTag);
    END_FIELD_TABLE

    GuidEntry(){}
    GuidEntry(int cnt, const string& cmnt):count(cnt),comment(cmnt) {
        RPC_STATUS status = UuidCreate( &guid );
        if ( status != RPC_S_OK ) {
            ReportError("UuidCreate failed with error 0x%0X\n", status);
            exit(1);
        }
    }
    GuidEntry(PSTR_PAIR p, int cnt, const string& cmnt):count(cnt),comment(cmnt)
    {
        guid.Data1 =         Hex(p->beg +  0, 8);
        guid.Data2 = (USHORT)Hex(p->beg +  9, 4);
        guid.Data3 = (USHORT)Hex(p->beg + 14, 4);
        guid.Data4[0] = (UCHAR) Hex(p->beg + 19, 2);
        guid.Data4[1] = (UCHAR) Hex(p->beg + 21, 2);
        guid.Data4[2] = (UCHAR) Hex(p->beg + 24, 2);
        guid.Data4[3] = (UCHAR) Hex(p->beg + 26, 2);
        guid.Data4[4] = (UCHAR) Hex(p->beg + 28, 2);
        guid.Data4[5] = (UCHAR) Hex(p->beg + 30, 2);
        guid.Data4[6] = (UCHAR) Hex(p->beg + 32, 2);
        guid.Data4[7] = (UCHAR) Hex(p->beg + 34, 2);
    }
};

struct Guids : FieldHolder {
    UINT min_val;
    UINT max_val;

    vector<GuidEntry> guids;
    int current;
    string currentFileName;

    Guids(int lo, int hi) : min_val(lo),max_val(hi),current(0) {}
    void erase() {current = 0; guids.erase(guids.begin(), guids.end());}

    BEGIN_FIELD_TABLE(Guids, f)
        TEXT_FIELD(Count) fprintf(f, "%d", min(current+1, (signed)guids.size()) );
        DEFAULT_ENUM_FIELD(guids, VectorTag)
    END_FIELD_TABLE

    ULONG getid() {
        for(;;) {
            if ( current == (signed)guids.size() ) {
            	
	            guids.push_back(GuidEntry(max_val - min_val + 1, currentFileName) );
            }
            if ( guids[current].count ) {
                ULONG ret = (max_val + 1 - guids[current].count--) | ( current << 16 );
                return ret;
            }
            ++current;
        }
    }
    void add_guids(PSTR_PAIR p, int count) {
        --count; ++p; // skip func name //
        string comment(p->beg,p->end);
        while (--count) {
            guids.push_back(GuidEntry(++p, max_val - min_val + 1, comment));
        }
    }
    void new_file(const char* fname) {
        currentFileName.assign(fname);

    	// this will force a new guid to be allocated
    	// when a new id is required

        current = static_cast<int>(guids.size()); 
    }
};

struct GenPair {
    string tpl;
    string out;

    GenPair(){} // STL pleaser
    GenPair(const string& a, const string& b)
        :tpl(a),out(b) {}
};    

//TYPE_MAP       AutoGen;
TYPE_MAP       TypeMap;
MSG_MAP        MsgMap;
//MACRO_MAP      MacroMap;
FUNC_MAP       Funcs;
GROUP_MAP      Groups;
PREFIX_VECTOR  Prefixes;
PREFIX_VECTOR  Suffixes;
//Guids          CtrlGuids(0,31);
Guids          TraceGuids(10,65535);
FILES          Files;
vector<string> ScanForMacros;
vector<string> Touch;
vector<GenPair>GenMulti;
vector<GenPair>GenSingle;
set<string, strless>    LookFor;

void printTraceGuid(FILE* f, int guidno)
{
    TraceGuids.guids[guidno].printTxt(f);
}

struct Keyword {
    int              nParams; // if < 0 then at least -nParams, otherwise = nParams //
    EZPARSE_CALLBACK handler;
    int              id;
    PVOID            context;
    Keyword(){}
    Keyword(EZPARSE_CALLBACK func,
            int n, UINT i, PVOID ctx) : nParams(n), handler(func), id(i), context(ctx) {}
};

typedef map<string, Keyword, strless> KEYWORD_MAP;

KEYWORD_MAP Keywords;

#if DEPRECATED
//BOOL   GenerateTypeTable;
string TypeTableBegin;
string TypeTableEntry;
string TypeTableEnd;
string TypeTablePrefix;
string GuidStore; 
#endif

const string CtlStr("LEVEL"); // the same as GRP
const string MakeStr("MAKESTR");
const string MsgArgStrUnsafe("(MSG,..unsafe..)");
const string MsgArgStr("(MSG,...)");
const string MsgValStr("MsgVal");
const string MsgStr("MSG");
const string ArgStr("...");
const string ArgStrUnsafe("..unsafe..");
const string IndentStr("INDENT");
const string NullStr("NULL");

bool
Files_AddFile(const string& Name, string Path, const WIN32_FIND_DATA& FindData) 
{
    if (!AllowedExtension(Name)) {
        return FALSE;
    }
    pair<FILES::iterator, bool> result = Files.insert(File(Name,Path,FindData));
    if (!result.second) {
        if (Name.compare(result.first->_Name) == 0) {
            ReportError("File %s was already in the processing list\n",Name.c_str());
        } else {
            ReportError("Files %s and %s have the same canonical name %s\n",
                   Name.c_str(), 
                   result.first->_Name.c_str(), 
                   result.first->_CanonicalName.c_str());
        }
    }
    return result.second;
}

int
compare(const string& a, const STR_PAIR& b)
{
    return a.compare(0, a.length(), b.beg, b.end - b.beg);
}

BOOL
parseLegacy(    
    IN PSTR_PAIR strs,
    IN INT       count,
    IN INT       hole, // args - msg, usually one
    IN OUT string& Msg,
    IN OUT vector<Argument>&,
    OUT ParsedFormatString& FmtStr
    )
{
    vector<string> ArgNames;
    STR_PAIR buf = *strs;
    LPCSTR p = buf.beg, q;
    int i;

    if ( p < buf.end && buf.end[-1] == ')' ) --buf.end;
    if(!parseMsg(buf.beg, buf.end, Msg, &p)) {
        return FALSE;
    }    

    if( !FmtStr.init(Msg) ) {
        return FALSE;
    }

    ArgNames.reserve(FmtStr.ArgCount);

    if (count == 1) {

        // need to grok args from the string

        // Let's get to the first ','
        if (p == buf.end) goto success;
        while(*p != ',') if (++p ==  buf.end) goto success; 
        q = ++p;
        for(i = 0;;++i) {
            int parlevel = 0;
            // currently we don't deal with the case of commas or parents within '"'
            while (p < buf.end) {
                if (parlevel == 0 && *p == ',') break;
                if (*p == '(') ++parlevel;
                if (*p == ')') {
                    if (--parlevel < 0) 
                        {ReportError("Too many ')'\n"); return FALSE;}
                }
                ++p;
            }
            if (parlevel > 0) {
                ReportError("No closing ')'");
            }

            LPCSTR tmp = p; // remember where we were
            
            while (q < p && isspace(*q)) ++ q;
            while (q < p && isspace(p[-1])) --p;

            ArgNames.push_back( string(q,p) );

            p = tmp;
           
            if (p == buf.end) break;
            q = ++p;
        }
    } else {
        // arguments were supplied in strs
        strs += hole; count -= hole;
        while (count-- > 0) {
            ArgNames.push_back( string(strs->beg,strs->end) ); 
            ++strs; 
        }
    }

success:
    // check that sizes match //
    if ((unsigned)ArgNames.size() != (unsigned)FmtStr.ArgCount ) {
        ReportError("%d argument(s) expected, argument(s) supplied: %d\n", FmtStr.ArgCount, ArgNames.size());
        return FALSE;
    }

    for(i = 0; i < FmtStr.Items.size(); ++i) {
        int no = FmtStr.Items[i].no;
        if (no > 0) {
            FmtStr.Items[i].expr = ArgNames[no-1];
        }
    }
    return TRUE;
}

BOOL
parseArgs(
    IN LPCSTR beg, 
    IN LPCSTR end,
    IN OUT vector<Argument>& args
    )
{
    LPCSTR p = beg;
//    MACRO_MAP::iterator macro;
    TYPE_SET::iterator macro;

    for(;;) {
        while ( isspace(*p) ) {
            if (++p == end) return TRUE;
        }
        LPCSTR q = p; // id start
        while ( isvar(*p) ) {
            if (++p == end) return TRUE;
        }
        macro = TypeSet.find( string(q, p) );
        if ( macro == TypeSet.end() ) {
        	if (p == q) {
        		q = beg;
        		p = end;
        	}
            ReportError("Unknown type: %s\n", string(q, p).c_str() );
            return FALSE;
        }
        macro->second.Used = TRUE;
        while ( *p != '(') {
            if (++p == end) return TRUE;
        }
        q = p; // now q points to '('
        int level = 0;
        for (;;) {
            if (*p == '(') {
                ++level;
            } else if (*p == ')') {
                if (--level == 0) {
                    break;
                }
            }
            if (++p == end) return TRUE;
        }
        args.push_back( Argument(string(q+1,p), &macro->second) );

        if (++p == end) return TRUE;
    }
    // return TRUE; // unreachable code
}


enum {
    ID_TraceRange,
    
    ID_ProcessFiles,
    
    ID_TemplateFile,
    
    ID_TypeMacro,
    ID_TypevMacro,
    ID_Include,
    ID_UsePrefix,
    ID_UseSuffix,
    ID_NoPrefix,

    ID_DefineSimpleTypePtr,
    ID_DefineSimpleType,
    ID_DefineCplxType,
    ID_CustomType,
    ID_DefineFlavor,
    ID_SeparateTraceGuidPerFile,
    ID_Touch,
    ID_ScanForMacros,
    ID_GenerateTypeTable,
    ID_Exceptions,
    ID_WppFlags,
};

void
UpdateIntVar(
    UINT*  var,
    PSTR_PAIR Str
    )
{
    LPCSTR p = Str->beg, q = Str->end;
    UINT x = 0; 

    while (p != q && isdigit(*p) ) {
        x = (x * 10) + (*p - '0');
        ++p;
    }

    *var = x;
}

void parseAssumedArgs(Func& f,LPCSTR beg, LPCSTR end)
{
    // we have a string of A=value1,B=value2,C=value3,...,F=valuen}
    // we need to put A,B,C into f.GooId, 
    // and value1, value2, value3 into f.Goo

    LPCSTR p = beg, q, stop;
    if (p >= end) return;

    Flood("Got %p %p\n", beg, end );

    for(;p < end;) {
        while (isspace(*p)) ++p; // cannot have spaces all the way. there is '}'
        if (p == end) return;
        q = p++;
        while (p < end && *p != '=') ++p;
        if (p == end) { 
            ReportError("Missing '=' in %s\n", string(beg,end).c_str() ); exit(1); }

        stop = p;
        while (--p > q && isspace(*p));
        if (p == q) { 
            ReportError("Id required before '=' in %s\n", string(beg,end).c_str() ); exit(1); }

        int isMsg = memcmp(q,"MSG=",4) == 0;
        if (!isMsg) 
            f.GooId.push_back( string(q,p+1) );

        p = stop + 1;
        while (isspace(*p)) ++p;  // cannot have spaces all the way. there is '}'
        q = p++;
        while (*p != '}' && *p != ',') ++p;
        stop = p;
        while (--p > q && isspace(*p));

        if (isspace(*p)) { // BUGBUG Verify that this condition is correct
            ReportError("value required after '=' in %s\n", string(beg,end).c_str() ); exit(1); }

        if (isMsg)
            f.assumedMsg = STR_PAIR(q, p+1);
        else
            f.Goo.push_back( string(q,p+1) );

        if (*stop == '}') break;
        p = stop + 1;
    }
    f.nAssumedArgs = f.Goo.size();
}

DWORD 
ParseConfigCallback (
    IN PSTR_PAIR Str, 
    IN INT   Count, 
    IN PVOID Context,
    IN PEZPARSE_CONTEXT ParseContext
    )
{
    string Name1(Str[0].beg, Str[0].end);
    KEYWORD_MAP::iterator keyword = Keywords.find(Name1);

    if (Context) {
        // We need to ignore all the keywords besides ID_TypeMacro //
        if (keyword != Keywords.end() && keyword->second.id == ID_TypeMacro) {
            // proceed and do the job //
        } else {
            // Ignore everything else
            return ERROR_SUCCESS;
        }
    }

    if (keyword != Keywords.end() ) {
        if (keyword->second.nParams < 0 && Count - 1 < -keyword->second.nParams ) {
            ReportError("%s requires at least %d parameter(s)\n", 
                   Name1.c_str(), -keyword->second.nParams);
            return ERROR_INVALID_PARAMETER;
        }
        if (keyword->second.nParams > 0 && Count - 1 != keyword->second.nParams ) {
            ReportError("%s requires %d parameter(s) (we have %s)\n", 
                   Name1.c_str(), keyword->second.nParams, std::string(Str[1].beg, Str[Count-1].end).c_str() );
            return ERROR_INVALID_PARAMETER;
        }

        switch (keyword->second.id) {
#ifdef DEPRECATED        
        case ID_UseTraceGuid:
            TraceGuids.add_guids(Str+1, Count-1);
            break;
        case ID_UseCtrlGuid:
            CtrlGuids.add_guids(Str+1, Count-1);
            break;

        case ID_SeparateTraceGuidPerFile:
            UpdateIntVar((UINT*)(keyword->second.context), Str+1); 
            break;
        case ID_GrpidRange:
            UpdateIntVar(&CtrlGuids.min_val, Str+1); UpdateIntVar(&CtrlGuids.max_val, Str+2); 
            break;
#endif

        case ID_TraceRange:
            UpdateIntVar(&TraceGuids.min_val, Str+1); UpdateIntVar(&TraceGuids.max_val, Str+2); 
            break;

        case ID_ProcessFiles:
            while(--Count) { ++Str; Fill( string(Str->beg, Str->end) ); }
            break;

        case ID_WppFlags:
            while(--Count) { ++Str; if(*Str->beg == '-') ++Str->beg; DealWithCmdLineOptions( Str->beg, Str->end ); }
            Unusual("\n");
            break;
            
        case ID_ScanForMacros:
            while(--Count) { ++Str; ScanForMacros.push_back( string(Str->beg, Str->end) ); }
            break;
            
        case ID_Touch:
            while(--Count) { ++Str; Touch.push_back( string(Str->beg, Str->end) ); }
            break;

        case ID_DefineSimpleType:
            {
                string Name(Str[1].beg, Str[1].end);
                if (Str[4].beg < Str[4].end && *Str[4].beg == '"') Str[4].beg++;
                if (Str[4].beg < Str[4].end && Str[4].end[-1] == '"') Str[4].end--;

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                } 
                Flood(" type %s\n", Name.c_str());
                TypeSet[Name] = WppType( Name , // name
                                     string(Str[2].beg, Str[2].end), // c-type
                                     SimpleValueMacroStart,
                                     string(Str[3].beg, Str[3].end), // mof type
                                     "", // MofExtension
                                     string(Str[4].beg, Str[4].end), 
                                     string(Str[5].beg, Str[5].end),
                                     stoi(Str[6], "priority"),
                                     Count > 7?stoi(Str[7], "argused"):1
                                     );
                break;                             
            }
            
        case ID_DefineSimpleTypePtr:
            {
                string Name(Str[1].beg, Str[1].end);
                if (Str[4].beg < Str[4].end && *Str[4].beg == '"') Str[4].beg++;
                if (Str[4].beg < Str[4].end && Str[4].end[-1] == '"') Str[4].end--;

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }
                TypeSet[Name] = WppType( Name , // name
                                     string(Str[2].beg, Str[2].end), // c-type
                                     SimplePtrMacroStart,
                                     string(Str[3].beg, Str[3].end), // mof type
                                     "", // MofExtension
                                     string(Str[4].beg, Str[4].end), 
                                     string(Str[5].beg, Str[5].end),
                                     stoi(Str[6], "priority"),
                                     Count > 7?stoi(Str[7], "argused"):1
                                     );
                break;                             
            }
            
        case ID_DefineCplxType:
            {
                string Name(Str[1].beg, Str[1].end);
                string MacroStart(Str[2].beg, Str[2].end);
                MacroStart.append("(");

                if (Str[5].beg < Str[5].end && *Str[5].beg == '"') Str[5].beg++;
                if (Str[5].beg < Str[5].end && Str[5].end[-1] == '"') Str[5].end--;
            
                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }
                
                TypeSet[Name] = WppType( Name , // name
                                         string(Str[3].beg, Str[3].end), // equiv type
                                         MacroStart, 
                                         string(Str[4].beg, Str[4].end), // mof type
                                         "", // MofExtension
                                         string(Str[5].beg, Str[5].end), 
                                         string(Str[6].beg, Str[6].end),
                                         stoi(Str[7], "priority"),
                                         Count > 8?stoi(Str[8], "argused"):1
                                         );
            }                                     
            break;                             
            

        case ID_DefineFlavor:
            {
                string Name(Str[1].beg, Str[1].end);
                string BaseType(Str[2].beg, Str[2].end);
                TYPE_SET::const_iterator it = TypeSet.find(BaseType);

                if (Str[4].beg < Str[4].end && *Str[4].beg == '"') Str[4].beg++;
                if (Str[4].beg < Str[4].end && Str[4].end[-1] == '"') Str[4].end--;

                if (it == TypeSet.end()) {
                    ReportError("Type Not Found %s\n", BaseType.c_str());
                    break;
                }

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }

                WppType Flavor(it->second);
                Flavor.TypeName = Name;
                if (!Str[3].empty()) 
                    { Flavor.MofType.assign(Str[3].beg, Str[3].end); }
                if (!Str[4].empty()) 
                    { Flavor.FormatSpec.assign(Str[4].beg, Str[4].end); }
                TypeSet[Name] = Flavor;

                break;
            }
            
        case ID_TypeMacro: 
        case ID_CustomType:
            {
                string Name(Str[1].beg, Str[1].end);
                LPCSTR p = Str[2].beg, q = Str[2].end;                
                while (p < Str[2].end && *p != '(') ++p;
                if (p < Str[2].end) {
                    q = p-1;
                    while (q >= Str[2].beg && isspace(*q)) --q;
                    ++q;
                }
                string BaseType(Str[2].beg, q);
                TYPE_SET::const_iterator it = TypeSet.find(BaseType);

                if (it == TypeSet.end()) {
                    ReportError("Type Not Found %s\n", BaseType.c_str());
                    break;
                }

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }

                if (Count == 4) {
                    if (Str[3].beg < Str[3].end && *Str[3].beg == '"') Str[3].beg++;
                    if (Str[3].beg < Str[3].end && Str[3].end[-1] == '"') Str[3].end--;
                }


                {
                    string ExtendedType;
                    LPCSTR end = Str[2].end;
                    if ( p != end ) {
                        ExtendedType.reserve(end - p);
                        do {
                            while(p != end && isspace(*p)) ++p;
                            LPCSTR qq = p;
                            while(qq != end && !isspace(*qq)) ++qq;
                            ExtendedType.append(p, qq);
                            p = qq;
                        } while ( p != end );
                    }
                    WppType Flavor(it->second);
                    Flavor.TypeName = Name;
                    Flavor.Extension = ExtendedType;
                    if (Count == 4) 
                        { Flavor.FormatSpec.assign(Str[3].beg,Str[3].end); }
                    
                    if (keyword->second.id == ID_TypeMacro) {
                        Flavor.Flags = WT_MACRONAME;
                    } else {
                        Flavor.Flags = 0;
                    }
                    TypeSet[Name] = Flavor;
                }
                break;
            }

        case ID_Include:
            return EzParse(std::string(Str[1].beg, Str[1].end).c_str(),ParseConfigCallback,0);        

        case ID_UseSuffix:
            Suffixes.push_back( Prefix(Str, Count) );
            break;
        case ID_UsePrefix:
        case ID_NoPrefix:
            Prefixes.push_back( Prefix(Str, Count) );
            break;
        default:;
            //return Keywords->handler(Str, Count, Context);
        }
        
    } else {

        //
        // a macro can have a list of assumed arguments in
        // curly braces right after the name
        //
        // Ex: TraceNoise{LEVEL=Noise}(MSG,...)
        //

        Flood("Got %s\n", Name1.c_str() );

        LPCSTR assumed_beg = find(Str[0].beg,Str[0].end, '{');
        LPCSTR assumed_end = find(Str[0].beg,Str[0].end, '}');

        if (assumed_beg != Str[0].end) {
            if (assumed_end == Str[0].end) {
                ReportError("No closing brace in '%s'\n",
                    Name1.c_str() );
                exit(1);
            }
            Name1.assign(Str[0].beg, assumed_beg);
            Noise("Real name is %s (%s)\n", Name1.c_str(),
                string(assumed_beg+1, assumed_end).c_str() );
        } else if (assumed_end != Str[0].end) {
                ReportError("No openning brace in '%s'\n",
                    Name1.c_str() );
                exit(1);
        }

        FUNC_MAP::iterator it = Funcs.find(Name1);
        if (it != Funcs.end()) {
            ReportError("Function %s is already defined\n",
                Name1.c_str() );
            exit(1);
        }

        Func f(Name1);

        BOOL SeenMsg = FALSE;

        if (ParseContext->doubleParent) {
            f.SetDoubleP();
        }

        if (assumed_end > assumed_beg) {
            parseAssumedArgs(f, assumed_beg+1, assumed_end+1);
        }

        for (int i = 1; i < Count; ++i) {
            // check for '='
            LPCSTR div = find(Str[i].beg, Str[i].end, '=' );
            if ( div != Str[i].end ) {               
                //f.Args.push_back( string(div+1, Str[i].end) );
                f.Goo.push_back( string(Str[i].beg, div ) );
                f.GooId.push_back( string(Str[i].beg, div ) );
                f.MsgVal = static_cast<UCHAR>(i); // can I have more of those?
                continue;
            }
            if ( compare(CtlStr, Str[i]) == 0 ) {
                f.Grp = static_cast<UCHAR>(i);
                f.Goo.push_back( string(Str[i].beg, Str[i].end) );
                f.GooId.push_back( string(Str[i].beg, Str[i].end) );
            } else if ( compare(MsgArgStr, Str[i]) == 0 ) {
                f.MsgArg = static_cast<UCHAR>(i); // can I have more of those?
                SeenMsg = TRUE;
//                f.SetLineBeg();
                continue;
            } else if ( compare(MsgArgStrUnsafe, Str[i]) == 0 ) {
                f.SetUnsafe();
                f.MsgArg = static_cast<UCHAR>(i); // can I have more of those?
                continue;
            } else if ( compare(MsgValStr, Str[i]) == 0 ) {
                f.MsgVal = static_cast<UCHAR>(i); // can I have more of those?
            } else if ( compare(MakeStr, Str[i]) == 0 ) {
                f.MsgVal = static_cast<UCHAR>(i); // can I have more of those?
                f.set(FO_NOMACRO);
//                f.SetLineBeg();
                // should i continue?
            } else if ( compare(MsgStr, Str[i]) == 0 ) {
                f.Msg = static_cast<UCHAR>(i);
                SeenMsg = TRUE;
                continue;
            } else if ( compare(NullStr, Str[i]) == 0 ) {
                f.NullArg = static_cast<UCHAR>(i);
            } else if ( compare(IndentStr, Str[i]) == 0 ) {
                f.Indent = static_cast<UCHAR>(i);
            } else if ( compare(ArgStrUnsafe, Str[i]) == 0 ) {
                f.Arg = static_cast<UCHAR>(i);
                f.SetUnsafe();
                f.SetVarArgs();
                if (i != Count - 1) {
                    ReportError("func %s: '...' has to be the very last argument\n",
                        Name1.c_str() );
                }
                continue;
            } else if ( compare(ArgStr, Str[i]) == 0 ) {
                f.Arg = static_cast<UCHAR>(i);
                f.SetVarArgs();
                if (i != Count - 1) {
                    ReportError("func %s: '...' has to be the very last argument\n",
                        Name1.c_str() );
                }
                continue;
            } else {
                f.Goo.push_back( string(Str[i].beg, Str[i].end) );
                f.GooId.push_back( string(Str[i].beg, Str[i].end) );
            }
            f.Args.push_back( string(Str[i].beg, Str[i].end) );
        }

        if (!SeenMsg) { f.SetNoMsg(); }

        f.Num = static_cast<UCHAR>(Count - 1);
        Noise(" func %s\n", Name1.c_str() );
        Funcs[ Name1 ] = f;
    }

    return ERROR_SUCCESS;
}
#if 0
DWORD
PrintCallback (
    IN PSTR_PAIR Str, 
    IN UINT Count, 
    IN PVOID
    )
{
    UINT i;
    for (i = 0; i < Count; ++i) {
        putchar('<'); fwrite(Str[i].beg, Str[i].end - Str[i].beg, 1, stdout); putchar('>');
    }
    putchar('\n');
    return ERROR_SUCCESS;
}
#endif

void CleanupString(LPCSTR beg, LPCSTR end, OUT string& msg)
{
    LPCSTR p = beg, q;
    msg.resize(0);

    while (p < end) {
        // skip spaces
        while (p < end && isspace(*p)) ++p;
        q = p;
        if (p < end && *p == '"') {
            ++p;
            while (p < end && (*p != '"' || p[-1] != '\\')) ++p;
        }
        if (p < end) ++p; 
        msg.append(q,p);
    }
}

DWORD
ParseSrcCallback (
    IN PSTR_PAIR Str, 
    IN INT Count, 
    IN PVOID,
    IN PEZPARSE_CONTEXT ParseContext
    )
{
    string FuncName(Str[0].beg, Str[0].end);
    string msg, msgval, id, indent;
    vector<Argument> args;
    ParsedFormatString FmtStr;
    int LineNo;
    
//    UINT argno = 10;

    if (FuncName.compare("WPP_COMPONENT_NAME") == 0) {
        if (Count != 2) {
            ReportError("WPP_COMPONENT_NAME requires 1 argument.\n");
            exit(1);
        }
        ComponentName.assign(Str[1].beg, Str[1].end);
        return ERROR_SUCCESS;
    }

    // Look for special directive

    if ( LookFor.find( FuncName ) != LookFor.end() ) {
        Noise("SpecialString found %s\n", FuncName.c_str());
        CurrentFile->IdsFound.insert(FuncName);
    }

    FUNC_MAP::iterator func = Funcs.find( FuncName );

    if (func == Funcs.end() ) {
        return ERROR_SUCCESS;
    }

    if (func->second.DoubleP() && !ParseContext->doubleParent) {
        ReportError("%s requires ((args))\n", func->first.c_str() );
        exit(1);
    }
    if (!func->second.DoubleP() && ParseContext->doubleParent) {
        ReportError("%s doesn't take ((args))\n", func->first.c_str() );
        exit(1);
    }

    msg.reserve(255);
    msgval.reserve(255);

    if (func->second.VarArgs()) {
        if (Count < func->second.Num ) {
            ReportError("%s requires at least %d arguments. (Found only %d)\n", 
            	func->first.c_str(), func->second.Num, Count-1);
            return ERROR_INVALID_PARAMETER;
        }
    } else {        
        if (Count-1 != func->second.Num ) {
            ReportError("%s requires %d arguments. (Found only %d)\n", 
            	func->first.c_str(), func->second.Num, Count-1);
            return ERROR_INVALID_PARAMETER;
        }
    }
    if (func->second.LineBeg() && !func->second.DoubleP() ) {
        LineNo = EzGetLineNo(Str[0].beg, ParseContext);
    } else {
        LineNo = EzGetLineNo(ParseContext->macroEnd, ParseContext);
    }
    {
        char Num[64];
        sprintf(Num,"%d", LineNo);

        id = CurrentFile->_CanonicalName;
        id += Num;
    }

    if (GRP(func->second)) {
        PSTR_PAIR p = Str + GRP(func->second);
        string group(p->beg, p->end);
        GROUP_MAP::iterator i = Groups.find(group);
        if (i == Groups.end()) {
            Groups[ string(p->beg, p->end) ] = Group(0, string(p->beg, p->end), id);
        } else {
        	i->second.MsgIds.push_back(id);
        }
    }

    if (func->second.MsgArg) {
        PSTR_PAIR p = Str + func->second.MsgArg;
        if (p->beg == p->end || *p->beg != '(') {
            ReportError("MsgArg argument should have form (MSG,...)\n");
            exit(1);
        }
        if (!parseLegacy(p, 1, 1, msg, args, FmtStr)) {
            return ERROR_INVALID_PARAMETER;
        }
    }


    if (!func->second.assumedMsg.empty() || MSG(func->second)) {
        PSTR_PAIR p = Str + MSG(func->second); // MSG(.) == 0 if assumed
        if (!func->second.assumedMsg.empty()) {
            *p = func->second.assumedMsg; // Str[0] now holds the assumed message
        }
        if (func->second.VarArgs()) {
            if (!parseLegacy(p, Count-MSG(func->second), 
                    ARG(func->second) - MSG(func->second),
                    msg, args, FmtStr)) {
                return ERROR_INVALID_PARAMETER;
            }
        } else if ( !parseMsg(p->beg, p->end, msg) ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (func->second.Indent) {
        PSTR_PAIR p = Str + func->second.Indent;
        indent.assign(p->beg, p->end);
    }

    if (func->second.MsgVal) {
        PSTR_PAIR p = Str + func->second.MsgVal;
        CleanupString(p->beg, p->end, msgval);
        //msgval.assign(p->beg, p->end);
        string::size_type div = msgval.find('=');
        if (div != string::npos) {
            FmtStr.HostString += msgval.substr(div+1);
        } else {
            FmtStr.HostString += msgval;
        }
        msgval.append(","); // Why comma?
    }
    
    if (func->second.prefix) {
        FmtStr.insert_prefix(func->second.prefix->FmtStr);
    }
    if (func->second.suffix) {
        FmtStr.append(func->second.suffix->FmtStr);
    }
    {
        MSG_MAP::iterator i = MsgMap.find(id);
        if ( i != MsgMap.end() ) {
            // Id already exists. Can't happen //
            ReportError("Can't handle multiple trace statements on the same line\n");
            exit(1);
        }
        Message* Msg =
        &(MsgMap[id] = 
            Message(id, msg, args, TraceGuids.getid(), LineNo, FmtStr,
                func->second) ) ;
        Msg->msgval = msgval;    
        Msg->Indent = indent;

        for(int ic = 1; ic < Count; ++ic) {
            if (ic == func->second.Indent) 
                continue;
            if (ic == func->second.NullArg) 
                continue;
            if (ic == func->second.MsgVal ||
               ic == func->second.MsgArg ||
               ic == MSG(func->second) )
            {
                break;
            }
            Msg->GooActualValues.push_back(string(Str[ic].beg, Str[ic].end));
        }
        
        CurrentFile->Msgs.push_back( Msg );
        TraceGuids.guids[TraceGuids.current].Msgs.push_back( Msg );
        ++MessageCount;
        if (Msg->ArgConsumed() > arglimit) {
            ReportError("Too many arguments supplied: %d > %d\n", 
                Msg->ArgConsumed(), arglimit);
        }
    }
    return ERROR_SUCCESS;
}

void
InitKeywords()
{                               
    #define HANDLER(A,B,C,D) Keywords[B] = Keyword(0,C,ID_ ## A, D)
    
    HANDLER( WppFlags,     "WPP_FLAGS", -1, NULL);
    HANDLER( TraceRange,   "TRACERANGE", 2, NULL);
    
    HANDLER( ProcessFiles, "PROCESSFILES", -1, NULL);
    HANDLER( Touch,        "TOUCH", -1, NULL);
    HANDLER( ScanForMacros,"SCANFORMACROS", -1, NULL);
    HANDLER( Exceptions,   "EXCEPTIONS", -2, NULL);
     
    HANDLER( TypeMacro,    "TYPEMACRO",  2, NULL);
    HANDLER( TypevMacro,   "TYPEVMACRO", 3, NULL);
    HANDLER( Include,      "INCLUDE", 1, NULL);
    HANDLER( UsePrefix,    "USEPREFIX", -2, NULL);
    HANDLER( UseSuffix,    "USESUFFIX", -2, NULL); // 3
    HANDLER( NoPrefix,     "NOPREFIX", 1, NULL);

    HANDLER( SeparateTraceGuidPerFile, "SEPARATE_TRACE_GUID_PERFILE", 1, &SeparateTraceGuidPerFile);
    
    HANDLER( DefineSimpleTypePtr, "DEFINE_SIMPLE_TYPE_PTR",-6, NULL);
    HANDLER( DefineSimpleType,    "DEFINE_SIMPLE_TYPE",    -6, NULL);
    HANDLER( DefineCplxType,      "DEFINE_CPLX_TYPE",      -7, NULL);
    HANDLER( DefineFlavor,        "DEFINE_FLAVOR",          4, NULL);
    HANDLER( CustomType,          "CUSTOM_TYPE",           -2, NULL);
}

struct iterless {
    typedef MSG_MAP::iterator ty;
    bool operator() (const ty& a, const ty&b) const { return a->second.id < b->second.id; }
};
/*
bool
FileExists(
	LPSTR fileName
	)
{
	HANDLE hFile = CreateFile(fileName, 0, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) {
		return FALSE;
	} else {
		CloseHandle( hFile );
		return TRUE;
	}
}
*/

void
MyGetCurrentDirectory(string& str, int level = 0)
{
    char buf[4096];	
    int n;

    n = GetCurrentDirectory(sizeof(buf), buf);
    if (n == 0 || n > sizeof(buf) ) {
        ReportError("GetCurrentDirectory failed: %d\n", GetLastError());
        exit(1);
    }

    {
        char *p, *q;
        p = buf;
        while (level) {
            q = strrchr(buf, '\\');
            if (q == 0) {
                break;
            }
            *q = '_'; p = q+1;
            --level;
        }
        str.assign(p);
    }
}


ContainerAdapter<MSG_MAP, MapTag>   MsgMap_tpl("Messages", MsgMap);
ContainerAdapter<GROUP_MAP, MapTag> GroupMap_tpl("Groups", Groups);
ContainerAdapter<FUNC_MAP, MapTag>  FuncMap_tpl("Funcs", Funcs);
ContainerAdapter<set<Reorder>, VectorTag>  Reorder_tpl("Reorder", ReorderSet);
ContainerAdapter<FILES, VectorTag>  Files_tpl("Files", Files);
ContainerAdapter<TYPE_SET, MapTag>  TypeSet_tpl("TypeSet", TypeSet);
ContainerAdapter<TYPESIG_MAP, MapTag>  TypeSigSet_tpl("TypeSigSet", TypeSigMap);
StringAdapter                       CurrentDir_tpl("CurrentDir", CurrentDir);
StringAdapter                       MacroPrefix_tpl("MacroPrefix", MacroPrefix);
//StringAdapter                       GuidStore_tpl("GuidStore", GuidStore);
StringAdapter                       TemplateFile_tpl("TemplateFile", CurrentTpl);
IteratorAdapter<FILES::iterator>    CurrentFile_tpl(&CurrentFile);

struct NameAlias : FieldHolder {
    string _Name, _Alias;

    NameAlias(){} // To make STL happy
    NameAlias(const string& Name, const string& Alias): _Name(Name), _Alias(Alias){}

    bool operator < (const NameAlias& b) const { return _Name.compare(b._Name) < 0; }

    BEGIN_FIELD_TABLE(NameAlias, f)
        TEXT_FIELD(Name)  fprint_str(f, _Name);
        TEXT_FIELD(Alias) fprint_str(f, _Alias);
        TEXT_FIELD(MacroName) {
            string::size_type br = _Name.find('(');
            if (br == string::npos) {
                fprint_str(f, _Name);
            } else {
                fprint_str(f, _Name.begin(), _Name.begin() + br);
            }
        }
    END_FIELD_TABLE
};

struct Compiler : FieldHolder {
    const Hasher* Checksum;

    BEGIN_FIELD_TABLE(Compiler, f)
        TEXT_FIELD(Name)      fprintf(f, "WPP");
        TEXT_FIELD(Version)   fprintf(f, "0.01");
        TEXT_FIELD(Checksum)  if (Checksum) Checksum->print(f);
        TEXT_FIELD(Timestamp) fprintf(f, __TIMESTAMP__);
    END_FIELD_TABLE
};

struct SystemObj : FieldHolder {
    BEGIN_FIELD_TABLE(SystemObject, out)
       TEXT_FIELD(Date) { 
           SYSTEMTIME UtcTime; GetSystemTime(&UtcTime);
           fprintf(out, "%02d/%02d/%04d", UtcTime.wMonth, UtcTime.wDay, UtcTime.wYear);
       }
       TEXT_FIELD(Time) { 
           SYSTEMTIME UtcTime; GetSystemTime(&UtcTime);
           fprintf(out, "%02d:%02d:%02d", UtcTime.wHour, UtcTime.wMinute, UtcTime.wSecond);
       }
    END_FIELD_TABLE
};

struct FoundTpl: FieldHolder {
    virtual BOOL Hidden(std::string filter="") const { 
        return CurrentFile->IdsFound.find(filter) == CurrentFile->IdsFound.end();
    }
    
    BEGIN_FIELD_TABLE(FoundTpl, f)
       __f__;
    END_FIELD_TABLE 
};

FoundTpl  Found_tpl;
SystemObj System_tpl;
Compiler Compiler_tpl;

//vector<NameAlias> AutoGenMacros;
//ContainerAdapter< vector<NameAlias>, VectorTag > AutoGenMacros_tpl("AutoGenMacros", AutoGenMacros);

set<NameAlias> MacroDefinitions;
ContainerAdapter< set<NameAlias>, VectorTag > MacroDefintions_tpl("MacroDefinitions", MacroDefinitions);

void AddMacroDefinition(LPCSTR s)
{
    LPCSTR end = s + strlen(s);
    LPCSTR q = strchr(s, '=');
    
    if (q == NULL) {
        MacroDefinitions.insert( NameAlias( s , "" ) );
    } else {
        MacroDefinitions.insert( NameAlias( string(s,q) , string(q+1,end) ) );
    }
} 

void expand(IN OUT string& str, const string& id)
{
    NameAlias dummy(id, "");
    set<NameAlias>::const_iterator it = MacroDefinitions.find(dummy);
    if (it != MacroDefinitions.end()) {
        str.append(it->_Alias);
    }
}

void processGenOption(LPCSTR s) 
{
    LPCSTR end = s + strlen(s), div = strchr(s,'}'), star = strchr(s,'*');
    vector<GenPair>& v = star ? GenMulti : GenSingle;
    
    if (*s != '{') { goto usage; }
    if (div == 0)  { goto usage; }
    if (s+1 == div || div+1 == end)  { goto usage; }
    if (star) {
        if (div+1 != star) { 
            ReportError(" '*' can appear only as a first charachter of output-filename part\n");
            goto usage;
        }
        ++star;
    } else {
        star = div+1;
    }
    if (star == end) goto usage;

    v.push_back( GenPair(string(s+1, div), string(star, end)) );
    return;

usage:    
    ReportError(" use -gen:{template-fpathname}output-fpathname\n"
                " you supplied -gen:%s\n", s);
    ExitProcess(1);
}

void
PrepareSearchPaths(LPCSTR s)
{
    // 
    // split /Isdf;sdf;y into a vector of strings
    //
    while(s) 
    {
        LPCSTR semi = strchr(s, ';');
        if (semi) {
            SearchDirs.push_back(string(s,semi));
            ++semi;
        } else {
            SearchDirs.push_back(string(s));
        }
        s = semi;
        if (SearchDirs.back().size() > 0
         && SearchDirs.back().end()[-1] != '\\')
        {
            SearchDirs.back().append("\\");
        }
    }
}

// 2fb37eda-004b-4b64-a1c4-84c53cb55df5
// 0         1         2         3
// 01234567typeName1234567typeName1234567typeName12345

void processCtlOption(string s)
{
    // first let's check that the guid is OK
    if ( (s.size() == 16 * 2 + 4) 
      && (s[8] == '-') && (s[13] == '-')
      && (s[18] == '-') && s[23] == '-') 
    {
        s[8] = s[13] = s[18] = s[23] = ',';
        MacroDefinitions.insert( NameAlias( 
            string("WPP_DEFAULT_CONTROL_GUID"), s) );
    }
}

void processCfgItem(const string& s)
{
    LPCSTR beg = s.begin(), end = s.end();
    ULONG Status;
    EZPARSE_CONTEXT ParseContext;
    ZeroMemory(&ParseContext, sizeof(ParseContext) );

    ParseContext.start = beg;
    ParseContext.filename = "cmdline";
    ParseContext.scannedLineCount = 1;
    ParseContext.lastScanned = beg;
//    EzParseCurrentContext = &ParseContext;

    Status = ScanForFunctionCallsEx
        (beg, end, ParseConfigCallback, 0, &ParseContext, NO_SEMICOLON);
        
    if (Status != ERROR_SUCCESS) {
        exit(1);
    }
}

vector<string> cmdinit; // config commands specified on the command line.

void ParseConfigFromCmdline()
{
    for(int i = 0; i < cmdinit.size(); ++i) {
        processCfgItem(cmdinit[i]);
    }
}

void DealWithCmdLineOptions(LPCSTR s)
{
    Unusual(" -%s", s);
    if (lstrcmp(s,"km") == 0) {
        AddMacroDefinition("WPP_KERNEL_MODE");
        userMode = FALSE;
    } else if (lstrcmp(s,"um") == 0) {
        AddMacroDefinition("WPP_USER_MODE");
        userMode = TRUE;
    } else if (strcmp(s, "dll")==0) {
        AddMacroDefinition("WPP_DLL");
    } else if (strcmp(s, "ignoreduptypes")==0) {
        IgnoreDupTypes = TRUE;
    } else if (strncmp(s, "gen:", 4)==0) {
        processGenOption(s+4);
    } else if (strncmp(s, "gen{", 4)==0) { // I was always forgetting to put :
        processGenOption(s+3);
    } else if (strncmp(s, "ctl:", 4)==0) {
        processCtlOption(string(s+4));
    } else if (strncmp(s, "scan:", 5)==0) {
        ScanForMacros.push_back(string(s+5));
    } else if (strncmp(s, "defwpp:", 7)==0) {
        WppDefault.assign(s+7);
    } else if (strncmp(s, "v", 1)==0) {
        if ( isdigit(s[1]) ) {
            DbgLevel = s[1] - '0';
        } else {
            DbgLevel = 1;
        }
    } else if (strncmp(s, "ini:", 4)==0) {
        LocalConfig.assign(s+4);
    } else if (strncmp(s, "lookfor:", 8)==0) {
        LookFor.insert(string(s+8));
    } else if (strncmp(s, "ext:", 4)==0) {
        AllowedExtensions.assign(s+4);
    } else if (strncmp(s, "preserveext:", 4)==0) {
        PreserveExtensions.assign(s+4);
    } else if (strncmp(s, "cfgdir:", 7)==0) { // OBSOLETE
        PrepareSearchPaths(s+7);
    } else if (strncmp(s, "arglimit:", 9)==0) { 
        arglimit = atoi(s+9);
    } else if (strncmp(s, "I", 1)==0) {
        PrepareSearchPaths(s+1);
    } else if (strcmp(s, "reorder")==0) {
        reorder = TRUE;
    } else if (strcmp(s, "noreorder")==0) {
        reorder = FALSE;
    } else if (strcmp(s, "donothing")==0) {
        exit(0);
    } else if (strcmp(s, "notimechk")==0) {
        CheckTimestamp = FALSE;
    } else if (strcmp(s, "noshrieks")==0) {
        noshrieks = TRUE;
    } else if (strcmp(s, "nohashchk")==0) {
        CheckHash = FALSE;
    } else if (strncmp(s, "func:",5)==0) {
        cmdinit.push_back( string(s+5) );
    } else if (strcmp(s, "md5")==0) {
        md5 = TRUE;
    } else if (strcmp(s, "nomd5")==0) {
        md5 = FALSE;
    } else if (strncmp(s, "omac:", 5)==0) {
        OutputMac.assign(s+5);
    } else if (strncmp(s, "argbase:", 8)==0) {
        ArgBase = atoi(s+8);
    } else if (strncmp(s, "odir:", 5)==0) {
        OutputDir.assign(s+5);
        if (OutputDir.size() > 0 && OutputDir.end()[-1] != '\\') {
            OutputDir.append("\\");
        }
    } else if (strncmp(s, "D", 1)==0) {
        AddMacroDefinition(s+1);
    } else {
        ReportError("Unknown cmdline option: -%s\n", s);
        exit(1);
    }

}

void parseStringAsCmdLine(
    LPCSTR beg, LPCSTR end
    )
{
    LPCSTR p = beg;
    if( end == NULL ) {
        end = beg + strlen(beg);
    }

    // need to skip spaces. " is processed specially

    for(;;) {
        while (p < end && isspace(*p)) ++p;
        if (p == end) return;
        LPCSTR q = p; // beginning of the the string
        if (*p == '"') {
            ++q; // skip openning quote
            do {
                ++p; while (p < end && *p != '"') ++p;
                if (p == end) {
                    ReportError("Unterminated string in %s\n", string(beg, end).c_str() );
                    exit(1);
                }
            }
            while (*p == '\\');
            // now p points to '"' which is not prefixed by '\'
        } else {
            while (p < end && !isspace(*p)) ++p;
        }
        if (*q != '-') {
            ReportError("Option doesn't start with '-' %s in \"%s\"\n", 
                string(q,p).c_str(), string(beg, end).c_str() );
        }        
        DealWithCmdLineOptions(q+1, p); 
        if (*p == '"') ++p;
    }        
}

enum {
    FAVOR_LOCAL_DIR   = 0x01,
    UPDATE_NAME       = 0x02,
    COMPLAIN_BITTERLY = 0x04,
};

BOOL
FileExists(
    string& fname,
    string path = "",
    ULONG options = 0)
{
    string file(path);
    file.append(fname);

    WIN32_FIND_DATA Dummy;
    HANDLE ffh = FindFirstFile(file.c_str(), &Dummy);

    if (ffh != INVALID_HANDLE_VALUE) {
        FindClose(ffh);
        Noise("found %s in %s\n", fname.c_str(), path.c_str());
        if (options & UPDATE_NAME) {
            fname = file;
        }
        return TRUE;
    }
    return FALSE;
}

void
FindFileOnPath(string& Name, ULONG Options = 0)
{
    if (Options & FAVOR_LOCAL_DIR) {
        if(FileExists(Name)) { goto found; }
    }
    int i;
    for(i = 0; i < SearchDirs.size(); ++i) {
        if(FileExists(Name, SearchDirs[i], Options))
            { goto found; }
    }
    if ( !(Options & FAVOR_LOCAL_DIR) ) {
        if(FileExists(Name)) { goto found; }
    }
    if ( Options & COMPLAIN_BITTERLY ) {
        ReportError("File %s not found\n", Name.c_str());
        exit(1);
    }
found:;
}


void InitGlobals()
{
    InitKeywords();

    MyGetCurrentDirectory(CurrentDir, 1);

//	ArrayPrefix.assign(currentDir);
//	ArrayPrefix.append("_wpp_");

	PopulateFieldMap();

    if (OutputMac.size() > 0) {
        DeleteFile( OutputMac.c_str() );
    }

    ObjectMap["Reorder"] = &Reorder_tpl;
    ObjectMap["TraceGuids"] = &TraceGuids;
//  ObjectMap["CtrlGuids"] = &CtrlGuids;
    ObjectMap["Messages"] = &MsgMap_tpl;
    ObjectMap["Groups"] = &GroupMap_tpl;
    ObjectMap["Funcs"] = &FuncMap_tpl;
//    ObjectMap["AutoMacros"] = &AutoGenMacros_tpl;
    ObjectMap["CurrentDir"] = &CurrentDir_tpl;
    ObjectMap["MacroPrefix"] = &MacroPrefix_tpl;
    ObjectMap["Compiler"] = &Compiler_tpl;
    ObjectMap["Files"] = &Files_tpl;
    ObjectMap["TypeSet"] = &TypeSet_tpl;
    ObjectMap["System"] = &System_tpl;
    ObjectMap["MacroDefinitions"] = &MacroDefintions_tpl;
    ObjectMap["TemplateFile"] = &TemplateFile_tpl;
    ObjectMap["SourceFile"] = &CurrentFile_tpl;
    ObjectMap["TypeSigSet"] = &TypeSigSet_tpl;
    ObjectMap["FOUND"] = &Found_tpl;
}

VOID ReadCommandLineArgs(int argc, char** argv) 
{
    Unusual("  tracewpp");
    for (int i = 1; i < argc; ++i) {
        char* s = argv[i];
        int len = (int)strlen(s);
        if (len > 1 && s[0] == '-') {
            DealWithCmdLineOptions(s+1);
        } else {
            Unusual("  %s", argv[i]);
            Fill( string(argv[i]));
        }
    }
    Unusual("\n");

    {
        LPCSTR p = getenv("WPP_FLAGS");
        if (p) {
            Noise("WPP_FLAGS defined: %s\n", p);
            parseStringAsCmdLine(p, NULL);
        }
    }

/*
    // THINK do we need revision at all?
    if (Revision.size() > 0) {
        if(SearchDirs.size() == 0) {
            ReportError("Revision can be specified only when -cfgdir directive is specified");
            ExitProcess(3);
        } else {
            if (Revision.end()[-1] != '\\') {
                Revision.append("\\");
            }
            int i, n = SearchDirs.size();
            for (i = 0; i < n; ++i) {
                SearchDirs.push_back( SearchDirs[i] );
                SearchDirs.back().append(Revision);
            }
        }
    }
*/
}

void ReadConfig()
{
    DWORD status;
    BOOL WppParsed = FALSE;
    // If default config file was specified,
    // process it
    if (WppDefault.size() > 0) {
        WppParsed = TRUE;
        Noise("parsing config file %s\n", WppDefault.c_str());
        status = EzParse(WppDefault.c_str(), ParseConfigCallback,0);
        if (status != ERROR_SUCCESS) {
            ExitProcess( status );
        }
    }
    if (LocalConfig.size() == 0) {
        if (FileExists(LOCAL_CONFIG_NAME) ) {
            WppParsed = TRUE;
            Noise("parsing config file %s\n", LOCAL_CONFIG_NAME.c_str());
            status = EzParse(LOCAL_CONFIG_NAME.c_str(),ParseConfigCallback,0);
            if (status != ERROR_SUCCESS) {
                ExitProcess( status );
            }
        }
    }
    else 
    {
        WppParsed = TRUE;
        Noise("parsing config file %s\n", LocalConfig.c_str());
        status = EzParse(LocalConfig.c_str(),ParseConfigCallback,0);
        if (status != ERROR_SUCCESS) {
            ExitProcess( status );
        }
    }

    
    if (!WppParsed) {
		ReportError("configuration file not found\n");
        ExitProcess( ERROR_FILE_NOT_FOUND );
	}

    if (Files.begin() == Files.end()) {
        Unusual("Nothing to compile\n");
        ExitProcess( ERROR_FILE_NOT_FOUND );
    }

    {
    	// Scan files for macro //
        vector<string>::iterator i;
        for (i = ScanForMacros.begin(); i != ScanForMacros.end(); ++i) {
            Noise("scanning %s... \n", i->c_str());
            EzParseEx(i->c_str(), SmartScan, ParseConfigCallback,0, 0);
		}
    }
    
    ParseConfigFromCmdline();
    
    //
    // We need to add prefix and suffix information to FuncMap 
    //
    {
        PREFIX_VECTOR::iterator i;
        Prefix * defaultPrefix = 0;
        Prefix * defaultSuffix = 0;
        string star("*");
        
        for (i = Prefixes.begin(); i != Prefixes.end(); ++i) {
            if ( 0 == i->FuncName.compare(star) ) {
                defaultPrefix = i;
            } else {
                Funcs[i->FuncName].SetPrefix(i);
            }
        }
        for (i = Suffixes.begin(); i != Suffixes.end(); ++i) {
            if ( 0 == i->FuncName.compare(star) ) {
                defaultSuffix = i;
            } else {
                Funcs[i->FuncName].SetSuffix(i);
            }
        }

        //
        // Assign the appendicies to the all other functions
        //

        FUNC_MAP::iterator j = Funcs.begin();
        for(; j != Funcs.end(); ++j) {
            if (!j->second.prefix) {
                j->second.SetPrefix( defaultPrefix );
            }
            if (!j->second.suffix) {
                j->second.SetSuffix( defaultSuffix );
            }
        }
    }

    //
    // Generates names of the log macros based on type names
    // Thus users of the tool can have LOGULONG or log_ulong 
    // or w_ulong(). Whatever they like best
    //
//    RegenerateMacroMap();
}

// used by tpl.cpp to do template include [BUGBUG] currently broken
void ProcessTemplate(LPCSTR b, LPCSTR e, void* Context)
{
    string prev(CurrentTpl);
    CurrentTpl.assign(b,e);
    FindFileOnPath(CurrentTpl, COMPLAIN_BITTERLY | UPDATE_NAME | FAVOR_LOCAL_DIR);

    EzParseEx(CurrentTpl.c_str(), processTemplate,0, Context, 0);

    CurrentTpl.assign(prev);
}

void FormOutputFileName(
    IN const string& to, 
    IN const string& suffix, 
    OUT string& OutputFile,
    OUT BOOL &StdOut
    )
{
    string::size_type backSlash = to.find('\\');
    string::size_type colon     = to.find(':');

    if (to.compare("-") == 0) {
        StdOut = TRUE;
        OutputFile.assign("-");
    } else {
        StdOut = FALSE;
        if (backSlash == string::npos && colon == string::npos) {
            // can prepend odir
            OutputFile.assign(OutputDir);
            OutputFile.append(to);
        } else {
            OutputFile.assign(to);
        }
        OutputFile.append(suffix);
    }
}

void GenerateOutput(string tpl, string to, string suffix = "")
{
    string OutputFile;
    FILE * f = 0;
    BOOL useStdOut = FALSE;

    FormOutputFileName(to, suffix, OutputFile, useStdOut);

    DefaultHasher computedHash;
    computedHash.Init();
    MsgMapHash(MsgMap, computedHash);
    computedHash.HashStr( CurrentFile->FullFileName() );
    computedHash.Finalize();
    Compiler_tpl.Checksum = &computedHash;

    if (md5) {
        size_t len = min(sizeof(GUID), computedHash.Size() );
        Flood("Going MD5... %d guid(s) ", TraceGuids.guids.size());
        for (int i = 0; i < TraceGuids.guids.size(); ++i) {
            // The following two lines are just needed in case
            // we ever decide DefaultHasher to be CRC32
            // If it will always be MD5 hasher, we can remove them
            ZeroMemory(&TraceGuids.guids[i].guid, sizeof(TraceGuids.guids[i].guid));
            TraceGuids.guids[i].guid.Data2 = (USHORT)i;
            
            CopyMemory(&TraceGuids.guids[i].guid, computedHash.Buf(), len);
            if (DbgLevel >= DBG_FLOOD) {
                TraceGuids.guids[i].printTxt(stdout); putchar(' ');
            }
        }
        Flood("\n");
    }

    // check whether we need to regenerate the file
    if (ErrorCount == 0 && CheckHash) {
        // Scan the beginning of the 
        FILE *inc = fopen(OutputFile.c_str(), "r");
        if (inc) {
            DefaultHasher readHash;
            char buf[128], *p = buf;
            int n = (int)fread(buf, 1, sizeof(buf)-1, inc);
            fclose(inc);
            buf[n] = 0; 
            
            while (!isalnum(*p) && *p ) ++p;

            readHash.fromString(p, buf + n);
            if (DbgLevel >= DBG_FLOOD) {
                computedHash.print(stdout); putchar(' ');
                readHash.print(stdout); putchar(' ');
            }

            if (computedHash == readHash) {
                Noise("No changes in %s.\n",
                    CurrentFile->_Name.c_str() );
                return;
            }
        }
    }

    if (ErrorCount) {
        DeleteFile(OutputFile.c_str());
        Noise("errors detected. deleting %s...\n", OutputFile.c_str());
        return;
    }

    Noise("generating %s...\n", OutputFile.c_str());

    if (useStdOut) {
        f = stdout;
    } else {
        f = fopen(OutputFile.c_str(), "w");
        if (!f) {
            ReportError("Cannot open '%s' for writing, error %d\n", OutputFile.c_str(), GetLastError() );
            ExitProcess( GetLastError() );
        }
    }
    ProcessTemplate(tpl.begin(), tpl.end(), f);
    
    if (!useStdOut) {
        fclose(f);
    }
}

void
VerifyAndUpdateTemplatesNames(
    vector<GenPair>& Gen
    )
{
    // verify that the template 
    vector<GenPair>::iterator i;
    for(i = Gen.begin();i != Gen.end();++i){
        FindFileOnPath(i->tpl, COMPLAIN_BITTERLY | UPDATE_NAME | FAVOR_LOCAL_DIR);
    }
}

int RealMain(int argc, char** argv) 
{
    InitGlobals();

    ReadCommandLineArgs(argc, argv);

    if (WppDefault.size()) {
        FindFileOnPath(WppDefault, COMPLAIN_BITTERLY | UPDATE_NAME);
    }

    ReadConfig();

    if (GenSingle.size() == 0 && GenMulti.size() == 0)
    {
        // add default template
        processGenOption(DEFAULT_GEN_OPTION);
    }

    BOOL OneAtATime = GenMulti.size() > 0;

    VerifyAndUpdateTemplatesNames(GenMulti);
    VerifyAndUpdateTemplatesNames(GenSingle);

    {
        FILES::iterator file;

        if (CheckTimestamp)
        {
            //
            // Before we do any heavyweight processing
            // let's check timestamps of source
            // and output files
            //
            
            ULONGLONG Now, MaxSrcTime, MinOutTime;
            string OutputFile;

            GetSystemTimeAsFileTime((LPFILETIME)&Now);

            MaxSrcTime = 0;
            MinOutTime = Now;
            
            for (file = Files.begin(); file != Files.end(); ++file) {
                if (file->ModificationTime == 0) {
                    Always("%s file has invalid modification time\n",
                           file->_BaseName.c_str());
                    goto out_of_date;       
                }
                if (file->ModificationTime > Now) {
                    Always("%s file modification time is in the future\n",
                           file->_BaseName.c_str());
                    goto out_of_date;
                }
                if (file->ModificationTime > MaxSrcTime) {
                    MaxSrcTime = file->ModificationTime;
                }
                
                vector<GenPair>::iterator i;
                for(i = GenMulti.begin();i != GenMulti.end();++i){
                    BOOL StdOut;
                    ULONGLONG Time;
                    
                    FormOutputFileName(file->_BaseName, i->out.c_str(),
                        OutputFile, StdOut);
                    if (StdOut) {
                        // StdOut is always out of date //
                        goto out_of_date;
                    }

                    Time = GetFileModificationTime(OutputFile);
                    if (Time == 0) {
                        goto out_of_date;
                    }
                    if (Time > Now) {
                        Always("%s file modification time is in the future\n",
                               OutputFile.c_str());
                        goto out_of_date;
                    }
                    if (Time < MinOutTime) {
                        MinOutTime = Time;
                    }
                }
            }
            vector<GenPair>::iterator i;
            for(i = GenSingle.begin();i != GenSingle.end();++i){
                BOOL StdOut;
                ULONGLONG Time;
                
                FormOutputFileName(file->_BaseName, i->out.c_str(),
                    OutputFile, StdOut);
                if (StdOut) {
                    // StdOut is always out of date //
                    goto out_of_date;
                }

                Time = GetFileModificationTime(OutputFile);
                if (Time == 0) {
                    goto out_of_date;
                }
                if (Time > Now) {
                    Always("%s file modification time is in the future\n",
                           OutputFile.c_str());
                    goto out_of_date;
                }
                if (Time < MinOutTime) {
                    MinOutTime = Time;
                }
            }
            if (MaxSrcTime <= MinOutTime) {
                
                return 0;
            }
        } // if (CheckTimestamp) //

    out_of_date:        
        //
        // Now we are ready to start scanning the source files
        //

        for (file = Files.begin(); file != Files.end(); ++file) {
            Noise("processing %s... \n", file->FullFileName().c_str());
            CurrentFile = file;
            if (SeparateTraceGuidPerFile) {
                TraceGuids.new_file( file->_Name.c_str() );
            }
            EzParseWithOptions(file->FullFileName().c_str(), ParseSrcCallback, 0, IGNORE_CPP_COMMENT);
            
            {
                vector<GenPair>::iterator i;
                for(i = GenMulti.begin();i != GenMulti.end();++i){
                    GenerateOutput(i->tpl, file->_BaseName, i->out.c_str());
                }
            }
            
            if (OneAtATime) {
                // Clear the tables for the next iteration 
                
                MsgMap.erase(MsgMap.begin(), MsgMap.end());
                TypeSigMap.erase(TypeSigMap.begin(), TypeSigMap.end());
                TraceGuids.erase();

                for (TYPE_SET::const_iterator i = TypeSet.begin(); 
                     i != TypeSet.end(); ++i)
                {
                    i->second.Used = FALSE;
                }
            }
        }
        Noise("done. Errors: %d.\n", ErrorCount);   
    }
#if 0
    // update Used field for every type in TypeSigSet
    {
        for (TYPESIG_MAP::const_iterator i = TypeSigMap.begin(); 
             i != TypeSigMap.end(); ++i)
        {
            for(int j = 0; j < i->Types.size(); ++j) {
                i->second.Types[j]->Used = TRUE;
            }
        }
    }
#endif
    // generate global files
    {
        vector<GenPair>::iterator i;
        for(i = GenSingle.begin();i != GenSingle.end();++i){
            GenerateOutput(i->tpl, i->out.c_str());
        }
    }

    return ErrorCount;
}

int __cdecl main(int argc, char** argv) 
{
    int status = 0;
    __int64 a, b;
    GetSystemTimeAsFileTime((LPFILETIME)&a);
    __try 
    {
        status = RealMain(argc, argv);
    } 
     __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        status = 1;
        ReportError("Internal Error : Contact GorN\n");
    }
    {
        SYSTEMTIME st;
        GetSystemTimeAsFileTime((LPFILETIME)&b);
        b -= a;
        FileTimeToSystemTime((LPFILETIME)&b, &st);
        Always("tracewpp: %d file(s) with %d message(s), processed in %d.%03d seconds\n", 
            Files.size(), MessageCount,
            st.wSecond, st.wMilliseconds);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\typeperf\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define    IDS_PARAM_FORMAT          113
#define    IDS_PARAM_INPUT           116
#define    IDS_PARAM_INTERVAL        119
#define    IDS_PARAM_OUTPUT          122
#define    IDS_PARAM_COUNTERS        128
#define    IDS_PARAM_SAMPLES         132
#define    IDS_PARAM_QUERY           135
#define    IDS_PARAM_QUERYX          139
#define    IDS_PARAM_SERVER          145
#define    IDS_PARAM_YES             146

#define    IDS_DEFAULT_OUTPUT        600

#define    IDS_MESSAGE_NOCOUNTERS    700
#define    IDS_MESSAGE_EXIT          701
#define    IDS_MESSAGE_CEXIT         702
#define    IDS_MESSAGE_BADFORMAT     704
#define    IDS_MESSAGE_BADCOUNTER    705
#define    IDS_MESSAGE_SPINNER       706

#define    IDS_EXAMPLE_COUNTERS      800
#define    IDS_EXAMPLE_QUERYALL      801
#define    IDS_EXAMPLE_FORMAT        802
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\typeperf\pdqpdh.cpp ===
/*****************************************************************************\

    PDQ Pdh Query Handler
  
    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include "pdqpdh.h"
#include <strsafe.h>

#include <varg.h>

CPdqPdh::CPdqPdh()
{
    m_nCurrentIndex = 0;
    m_bGoodData = FALSE;
    m_bGoodNames = FALSE;
    m_bFirstQuery = TRUE;
    m_bInitialized = FALSE;
    m_fState = PDQ_STATE_IDLE;
    m_hLog = NULL;
    m_hCollectionThread = NULL;
    m_hLogMutex = NULL;
    m_pbTerminate = NULL;
}

PDH_STATUS
CPdqPdh::Initialize( BOOL* pbTerminate )
{
    PDH_STATUS pdhStatus;
    m_pbTerminate = pbTerminate;

    if(m_bInitialized){
        return ERROR_SUCCESS;
    }

    InitializeCriticalSection( &m_critsec );
    EnterCriticalSection( &m_critsec );
    
    pdhStatus = PdhOpenQuery( 0, 0, &m_hQuery);
    PDQ_ERROR_RETURN( TRUE, pdhStatus );
    
    m_nTotalCollected = 0;
    
    ZeroMemory( &m_pdhCounters, sizeof(PDQ_BUFFER) );
    ZeroMemory( &m_pdhCounterNames, sizeof(PDQ_BUFFER) );
    ZeroMemory( &m_pdhValues, sizeof(PDQ_BUFFER) );
    ZeroMemory( &m_pdhDataNames, sizeof(PDQ_BUFFER) );

    pdhStatus = GrowMemory( &m_pdhValues, (sizeof(PDQ_COUNTER)), PDQ_ALLOCSIZE );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    pdhStatus = GrowMemory( &m_pdhCounters, sizeof(HCOUNTER), 0 );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );
    
    pdhStatus = GrowMemory( &m_pdhCounterNames, sizeof(LPTSTR*), 0 );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    pdhStatus = GrowMemory( &m_pdhDataNames, sizeof(TCHAR), PDQ_ALLOCSIZE );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    m_hLogMutex = CreateMutex( NULL, FALSE, NULL );

    m_bInitialized = TRUE;  
    m_bExpand = FALSE;

    LeaveCriticalSection( &m_critsec );
    return ERROR_SUCCESS;
}

CPdqPdh::~CPdqPdh()
{
    PDH_STATUS pdhStatus;
    BOOL bResult;

    __try {
        LogClose();

        pdhStatus = PdhCloseQuery (m_hQuery);
        assert (pdhStatus == ERROR_SUCCESS);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    EnterCriticalSection( &m_critsec );
    bResult = HeapValidate( GetProcessHeap(), 0, NULL );
    
    if( m_pdhCounters.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhCounters.buffer );
        m_pdhCounters.buffer = NULL;
    }
    for(UINT i=0;i<m_pdhCounterNames.dwNumElements;i++){
        if( NULL != m_pdhCounterNames.szName[i] ){
            HeapFree( GetProcessHeap(), 0, m_pdhCounterNames.szName[i] );
            m_pdhCounterNames.szName[i] = NULL;
        }
    }
    if( m_pdhCounterNames.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhCounterNames.buffer );
        m_pdhCounterNames.buffer = NULL;
    }
    if( m_pdhValues.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhValues.buffer );
        m_pdhValues.buffer  = NULL;
    }
    if( m_pdhDataNames.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhDataNames.buffer );
        m_pdhDataNames.buffer = NULL;
    }

    if( m_hLogMutex != NULL ){
        CloseHandle ( m_hLogMutex );
        m_hLogMutex = NULL;
    }
    LeaveCriticalSection( &m_critsec );
    
    DeleteCriticalSection( &m_critsec );
}

DWORD
CPdqPdh::GrowMemory( PPDQ_BUFFER buffer, size_t tSize, DWORD dwNumElements, BOOL bSave )
{
    void* pNewBlock;
    DWORD dwAlloc;
    
    if( dwNumElements == 0 ){
        dwNumElements = ((int)(buffer->dwNumElements/PDQ_GROWSIZE)+1) * PDQ_GROWSIZE;
        buffer->dwMaxElements += PDQ_GROWSIZE;
    }
    
    dwAlloc = dwNumElements * tSize;
    if( dwAlloc <= 0 ){
        return ERROR_BAD_ARGUMENTS;
    }
    
    pNewBlock = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwAlloc );

    if( NULL == pNewBlock ){
        return ERROR_OUTOFMEMORY;
    }

    if( buffer->buffer != NULL ){
        if( bSave ) CopyMemory( pNewBlock, buffer->buffer, buffer->cbSize );
        HeapFree( GetProcessHeap(), 0, buffer->buffer );
        buffer->buffer = NULL;
    }

    buffer->cbSize = dwAlloc;
    buffer->dwMaxElements = (dwAlloc / tSize);
    buffer->buffer = pNewBlock;
    
    assert( buffer->buffer != NULL);
    
    return ERROR_SUCCESS;
}

DWORD
CPdqPdh::GetCountersFromFile( LPTSTR szFileName, LPTSTR szComputer, void (*fntError)(LPTSTR, PDH_STATUS) )
{
    TCHAR buffer[PDQ_ALLOCSIZE];
    LPTSTR strCounter;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    FILE* f = _tfopen( szFileName, _T("r") );

    if( !f ){
        return GetLastError();
    }
    
    while( NULL != _fgetts( buffer, PDQ_ALLOCSIZE, f ) ){
        
        PDQ_CHECK_TERMINATE( m_pbTerminate );
        
        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }
        
        Chomp(buffer);

        if( _tcsicmp( buffer, _T("NULL") ) == 0 ){
            break;
        }
        
        strCounter = _tcstok( buffer, _T("\"\n") );
        if( strCounter == NULL ){
            continue;
        }

        AddCounter( strCounter, szComputer, fntError );
    }

cleanup:
    fclose( f );

    return ERROR_SUCCESS;
}

DWORD
CPdqPdh::Add( HCOUNTER hCounter, LPTSTR szCounter )
{
    DWORD dwStatus = ERROR_SUCCESS;
    size_t cbSize;
    
    if( m_pdhCounters.dwNumElements == m_pdhCounters.dwMaxElements ){
        dwStatus = GrowMemory( &m_pdhCounters, sizeof(HCOUNTER), 0, true );
        PDQ_ERROR_RETURN( FALSE, dwStatus );
        
        dwStatus = GrowMemory( &m_pdhCounterNames, sizeof(LPTSTR*), 0, true);
        PDQ_ERROR_RETURN( FALSE, dwStatus );
    }
    
    m_pdhCounters.pCounter[m_pdhCounters.dwNumElements++] = hCounter;

    cbSize = (_tcslen( szCounter )+1)*sizeof(TCHAR);

    m_pdhCounterNames.szName[m_pdhCounterNames.dwNumElements] = 
        (LPTSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, cbSize );

    if( NULL == m_pdhCounterNames.szName[m_pdhCounterNames.dwNumElements] ){
        PDQ_ERROR_RETURN( FALSE, ERROR_OUTOFMEMORY );
    }

    StringCbCopy( 
            m_pdhCounterNames.szName[m_pdhCounterNames.dwNumElements++],
            cbSize,
            szCounter
        );

    return dwStatus;
}

PDH_STATUS
CPdqPdh::AddCounter( LPTSTR strCounter, LPTSTR strComputer, void (*fntError)(LPTSTR, PDH_STATUS) )
{
    PDH_STATUS pdhStatus;
    BOOL bResult;
    HCOUNTER pCounter;
    TCHAR buffer[PDQ_ALLOCSIZE];
    LPTSTR szCounterPath;
    TCHAR strComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    LPTSTR strUseComputer = NULL;
    ULONG nChars = 0;
    ULONG nWhacks = 0;

    if( strCounter == NULL ){
        return PDH_INVALID_ARGUMENT;
    }
    nChars = _tcslen( strCounter );
    if( nChars >= PDQ_ALLOCSIZE || nChars < 3 ){
        return PDH_INVALID_ARGUMENT;
    }
    
    EnterCriticalSection( &m_critsec );
    PDQ_CHECK_TERMINATE( m_pbTerminate );
    
    while( strCounter[nWhacks] == _T('\\') ){ nWhacks++; }
   
    if( 2 <= nWhacks ){
        szCounterPath = strCounter;
    }else{
        if( NULL == strComputer ){
            bResult = GetComputerName( strComputerName, &dwSize );
            if( !bResult ){
                LeaveCriticalSection( &m_critsec );
                return GetLastError();
            }
            strUseComputer = strComputerName;
        }else{
            strUseComputer = strComputer;
        }
        while( *strUseComputer == _T('\\') ){
            strUseComputer++;
        }
        nChars += _tcslen( strUseComputer ) + 4;
        if( nChars >= PDQ_ALLOCSIZE ){
            PDQ_ERROR_RETURN( TRUE, PDH_INVALID_ARGUMENT );
        }
        StringCchPrintf( buffer, PDQ_ALLOCSIZE, _T("\\\\%s%s%s"), 
                    strUseComputer, 
                    (nWhacks == 1) ? _T("") : _T("\\"), 
                    strCounter 
                );
        szCounterPath = buffer;
    }

    m_bFirstQuery = TRUE;
    
    PDQ_CHECK_TERMINATE( m_pbTerminate );
    
    if( m_bExpand ){

        pdhStatus = EnumPath( szCounterPath );
        PDQ_CHECK_TERMINATE( m_pbTerminate );
        
        if( ERROR_SUCCESS == pdhStatus ){

            LPTSTR str = m_pdhDataNames.strBuffer;
    
            while (*str){
                pdhStatus = PdhAddCounter(
                        m_hQuery,
                        str,
                        0,
                        &pCounter
                    );
                
                PDQ_CHECK_TERMINATE( m_pbTerminate );
                
                if( ERROR_SUCCESS != pdhStatus ){
                    if( fntError != NULL ){
                        fntError( str, pdhStatus );
                    }
                    break;
                }else{
                    pdhStatus = Add( pCounter, str);
                }
        
                str += (_tcslen(str) + 1);
            }
        }

    }else{

        pdhStatus = PdhAddCounter(
                m_hQuery,
                szCounterPath,
                0,
                &pCounter
            );

        if( ERROR_SUCCESS != pdhStatus ){
            if( fntError != NULL ){
                fntError( szCounterPath, pdhStatus );
            }
        }else{
            pdhStatus = Add( pCounter, szCounterPath );
        }
    }


cleanup:
    LeaveCriticalSection( &m_critsec );
    return ERROR_SUCCESS;
}

PDH_STATUS
CPdqPdh::LogCreate( LPTSTR szLogName, DWORD fType )
{
    PDH_STATUS pdhStatus;

    pdhStatus = PdhOpenLog(
            szLogName, 
            PDH_LOG_WRITE_ACCESS|PDH_LOG_CREATE_ALWAYS, 
            &fType,
            m_hQuery,
            0,
            _T("TYPEPERF"),
            &m_hLog 
        );


    return pdhStatus;
}
    
PDH_STATUS
CPdqPdh::LogData()
{
    PDH_STATUS pdhStatus = PDH_INVALID_HANDLE;
    
    if( m_hLog != NULL ){
        pdhStatus = PdhUpdateLog( m_hLog, NULL );
    }

    return pdhStatus;
}

PDH_STATUS
CPdqPdh::LogClose()
{
    PDH_STATUS pdhStatus = PDH_INVALID_HANDLE;

    LogStop();

    if( m_hLog != NULL ){
        pdhStatus = PdhCloseLog( m_hLog, 0 );
    }

    return pdhStatus;
}

unsigned long __stdcall PdqCollectionThread( void* pdq )
{
    CPdqPdh* pPdqPdh = (CPdqPdh*)pdq;

    if( pPdqPdh == NULL ){
        return 0;
    }
    
    DWORD dwWait;
    BOOL bRun = TRUE;

    while(bRun){

        dwWait = WaitForSingleObject( pPdqPdh->m_hLogMutex, pPdqPdh->m_nCollectionInterval );
        
        if( dwWait == WAIT_TIMEOUT && pPdqPdh->m_fState == PDQ_STATE_LOGGING ){

            pPdqPdh->LogData();
            
            if( pPdqPdh->m_nSamples != PDQ_PERPETUAL ){
                pPdqPdh->m_nSamples--;
            }
            if( pPdqPdh->m_nSamples == 0 ){
                pPdqPdh->m_fState = PDQ_STATE_IDLE;
                break;
            }

        }else{
            if( dwWait == WAIT_OBJECT_0 ){
                ReleaseMutex( pPdqPdh->m_hLogMutex );    
            }
            break;
        }
    }

    return 0;
}

DWORD
CPdqPdh::GetState()
{
    return m_fState;
}

DWORD
CPdqPdh::LogStart( ULONG interval, long samples )
{
    DWORD tid;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwWait;

    EnterCriticalSection( &m_critsec );
    
    if( m_fState == PDQ_STATE_IDLE && m_hLog != NULL ){    

        if( NULL == m_hLogMutex ){
            return GetLastError();
        }

        dwWait = WaitForSingleObject( m_hLogMutex, 0 );

        if( WAIT_OBJECT_0 == dwWait ){
            m_nCollectionInterval = interval;
            m_nSamples = samples;

            if( m_nCollectionInterval < 1000 ){
                m_nCollectionInterval = 1000;
            }

            m_fState |= PDQ_STATE_LOGGING;
            m_hCollectionThread = CreateThread( NULL, 0, PdqCollectionThread, this, 0, &tid );
    
            if( m_hCollectionThread == NULL ){
                ReleaseMutex( m_hLogMutex );
                dwStatus = GetLastError();
            }else{
                dwStatus = ERROR_SUCCESS;
            }
        }
    }else{
        dwStatus = ERROR_TOO_MANY_OPEN_FILES;
    }

    LeaveCriticalSection( &m_critsec );
    return dwStatus;
}

DWORD 
CPdqPdh::LogStop()
{
    BOOL bResult;
    DWORD dwCode = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwWait;

    EnterCriticalSection( &m_critsec );
    
    if( m_hCollectionThread != NULL ){
        
        m_fState = PDQ_STATE_IDLE;
        ReleaseMutex( m_hLogMutex );
    
        dwWait = WaitForSingleObject( m_hLogMutex, m_nCollectionInterval*2 );
        bResult = GetExitCodeThread( m_hCollectionThread, &dwCode );
    
        if( dwCode == STILL_ACTIVE ){
            bResult = TerminateThread( m_hCollectionThread, 0 );
        }

        if( ! bResult ){
            dwStatus = GetLastError();
        }

        CloseHandle( m_hCollectionThread );
        m_hCollectionThread = NULL;
        
        if( dwWait == WAIT_OBJECT_0 ){
            ReleaseMutex( m_hLogMutex );
        }
    }
    
    LeaveCriticalSection( &m_critsec );

    return dwStatus;
}

PDH_STATUS
CPdqPdh::Query()
{
    PDH_STATUS pdhStatus;
    EnterCriticalSection( &m_critsec );

    pdhStatus = PdhCollectQueryData( m_hQuery );
    if(m_bFirstQuery){
        pdhStatus = PdhCollectQueryData( m_hQuery );
        m_bFirstQuery = FALSE;
    }

    m_nTotalCollected++;
    LeaveCriticalSection( &m_critsec );

    return pdhStatus;
}

PDH_STATUS 
CPdqPdh::CollectData( ULONG index )
{
    PDH_STATUS pdhStatus;
    EnterCriticalSection( &m_critsec );

    m_bGoodData = FALSE;
    m_bGoodNames = FALSE;
    DWORD dwItemSize = m_pdhValues.cbSize;
    if( index > m_pdhCounters.dwNumElements ){
        LeaveCriticalSection( &m_critsec );
        return ERROR_INVALID_HANDLE;
    }
    HCOUNTER hCounter = m_pdhCounters.pCounter[index];

    pdhStatus = PdhGetFormattedCounterArray(
            hCounter,
            PDH_FMT_DOUBLE|PDH_FMT_NOCAP100, 
            &dwItemSize,
            &m_pdhValues.dwNumElements,
            m_pdhValues.pValue
        );
    
    if (pdhStatus == PDH_MORE_DATA){
        dwItemSize = 0;
        pdhStatus = PdhGetFormattedCounterArray(
                m_pdhCounters.pCounter[index],
                PDH_FMT_DOUBLE|PDH_FMT_NOCAP100,
                &dwItemSize,
                &m_pdhValues.dwNumElements,
                NULL
            );
                
        pdhStatus = GrowMemory( 
                &m_pdhValues,
                sizeof(PDQ_COUNTER), 
                ++dwItemSize 
            );

        PDQ_ERROR_RETURN(TRUE, pdhStatus );

        dwItemSize = m_pdhValues.cbSize;

        pdhStatus = PdhGetFormattedCounterArray(
                m_pdhCounters.pCounter[index],
                PDH_FMT_DOUBLE|PDH_FMT_NOCAP100,
                &dwItemSize,
                &m_pdhValues.dwNumElements,
                m_pdhValues.pValue
            );
    }

    m_nCurrentIndex = index;

    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    m_bGoodData = TRUE;

    LeaveCriticalSection( &m_critsec );

    return ERROR_SUCCESS;
}

double 
CPdqPdh::GetData( ULONG index )
{
    if( (m_bGoodData == TRUE) && (index < m_pdhValues.dwNumElements) ){
        return m_pdhValues.pValue[index].FmtValue.doubleValue;
    }

    return -1.0;
}

PDH_STATUS
CPdqPdh::EnumPath( LPTSTR szWildCardPath )
{
    PDH_STATUS pdhStatus;
    DWORD dwItemSize = m_pdhDataNames.dwMaxElements;

    m_pdhDataNames.dwNumElements = 0;


    do{

        ZeroMemory( m_pdhDataNames.strBuffer, m_pdhDataNames.cbSize );

        pdhStatus = PdhExpandWildCardPath(
                    NULL,
                    szWildCardPath,
                    m_pdhDataNames.strBuffer,
                    &dwItemSize,
                    0
                );

/*
        pdhStatus = PdhExpandCounterPath(
                szWildCardPath,
                (LPTSTR)m_pdhDataNames.szName,
                &dwItemSize
            );
*/
        if( PDH_MORE_DATA == pdhStatus ){
            HRESULT hr = GrowMemory( &m_pdhDataNames, sizeof(TCHAR), ++dwItemSize );
            PDQ_ERROR_RETURN( FALSE, hr );
            dwItemSize = m_pdhDataNames.dwMaxElements;
        }


    }while( PDH_MORE_DATA == pdhStatus );

    return pdhStatus;
}

LPCTSTR 
CPdqPdh::GetDataName( ULONG index )
{
    PDH_STATUS pdhStatus;
    
    if( PDQ_BASE_NAME == index ){
        return m_pdhCounterNames.szName[m_nCurrentIndex];
    }
    if( m_bGoodNames == FALSE){
            
        pdhStatus = EnumPath( 
                m_pdhCounterNames.szName[m_nCurrentIndex] 
            );

        if( ERROR_SUCCESS != pdhStatus ){
            return m_pdhCounterNames.szName[m_nCurrentIndex];
        }
        
        m_bGoodNames = TRUE;
    }
    
    LPTSTR str = m_pdhDataNames.strBuffer;
    ULONG nCount = 0;
    
    while (*str){
        
        if( nCount++ == index ){
            return str;
        }
        
        str += _tcslen(str);
        str++;
    }
    
    return NULL;
}

double
CPdqPdh::GetCounterValue( LPTSTR strCounter, BOOL bQuery )
{
    for( unsigned int i=0;i<m_pdhCounterNames.dwNumElements;i++){
        if( _tcsstr( m_pdhCounterNames.szName[i], strCounter ) ){
            if( bQuery && (Query() != ERROR_SUCCESS) ){
                return -1;
            }
            CollectData( i );
            return GetData( 0 );
        }
    }

    return -1;
}

double
CPdqPdh::GetCounterValue( ULONG index, BOOL bQuery )
{
    if( index < m_pdhCounters.dwNumElements ){
            if( bQuery && (Query() != ERROR_SUCCESS) ){
                return -1;
            }
            CollectData( index );
            return GetData( 0 );
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\typeperf\pdqpdh.h ===
/*****************************************************************************\

    PDQ Pdh Query Handler
  
    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#ifndef PDHPDQ_H_05271999
#define PDHPDQ_H_05271999

#include <pdh.h>
#include <pdhmsg.h>

#if (WINVER <= 0x400)
#define PDH_FMT_NOCAP100    (0)
#endif

#define PDQ_BASE_NAME       0x0FFFFFFF
#define PDQ_ALLOCSIZE       1024
#define PDQ_GROWSIZE        16
#define PDQ_COUNTER         PPDH_FMT_COUNTERVALUE_ITEM
#define PDQ_PROCESSOR_TIME  _T("\\Processor(_Total)\\% Processor Time")
#define PDQ_DISK_TIME       _T("\\PhysicalDisk(_Total)\\% Disk Time")
#define PDQ_DISK_IDLE       _T("\\PhysicalDisk(_Total)\\% Idle Time")
#define PDQ_PERPETUAL       (-1)
#define PDQ_PDH_CSV_HEADER  _T("\"(PDH-CSV 4.0)\"")

#define PDQ_FLAG_RETURN_ON_ERROR        1

#define PDQ_MORE_DATA(x)    (x == PDH_INSUFFICIENT_BUFFER || x == PDH_MORE_DATA)

#define PDQ_STATE_IDLE      0
#define PDQ_STATE_LOGGING   1

#define PDQ_BAD_VALUE       (-1)

#define PDQ_ERROR_RETURN( c, x )                    \
    if( ERROR_SUCCESS != x ){                       \
        BOOL bUseCritSection = c;                   \
        if( bUseCritSection ){                      \
            LeaveCriticalSection( &m_critsec );     \
        }                                           \
        return x;                                   \
    }                                               \

#define PDQ_CHECK_TERMINATE( x )   \
if( x != NULL ){                   \
    if( *x == TRUE ){              \
        goto cleanup;              \
    }                              \
}                                  \

typedef struct _PDQ_BUFFER{
    union{
        void*           buffer;
        HCOUNTER*       pCounter;
        LPTSTR*         szName;
        PDQ_COUNTER     pValue;
        LPTSTR          strBuffer;
    };
    DWORD   cbSize;
    DWORD   dwMaxElements;
    DWORD   dwNumElements;
    BOOL    bValid;
} PDQ_BUFFER, *PPDQ_BUFFER;

class CPdqPdh
{
public:
    CPdqPdh();
    ~CPdqPdh();
    
    PDH_STATUS Initialize( BOOL* pbTerminate );

    PDH_STATUS AddCounter( 
            LPTSTR strCounter, 
            LPTSTR strComputer,            
            void    (*fntError)(LPTSTR, PDH_STATUS)
    );
    
    PDH_STATUS Query();
    PDH_STATUS CollectData( ULONG index );

    LPCTSTR GetDataName( ULONG index );
    double GetData( ULONG index );
    double GetCounterValue( LPTSTR strCounter, BOOL bQuery = TRUE );
    double GetCounterValue( ULONG index, BOOL bQuery = TRUE );

    
    ULONG GetDataCount() { return m_pdhValues.dwNumElements; };
    ULONG GetCounterCount() { return m_pdhCounters.dwNumElements; };
    
    DWORD GetCountersFromFile( 
            LPTSTR szFileName, 
            LPTSTR szComputer,
            void    (*fntError)(LPTSTR, PDH_STATUS)
        );

    PDH_STATUS LogCreate( LPTSTR szLogName, DWORD fType );
    PDH_STATUS LogData();
    PDH_STATUS LogClose();
    DWORD LogStart( ULONG interval, long samples = PDQ_PERPETUAL );
    DWORD LogStop();
    DWORD GetState();
    void  SetExpand( BOOL bExpand ){ m_bExpand = bExpand; }

public:
    CRITICAL_SECTION    m_critsec;
    DWORD       m_fState;
    ULONG       m_nCollectionInterval;
    ULONG       m_nSamples;
    ULONG       m_nTotalCollected;
    HANDLE      m_hLogMutex;

private:
    HQUERY      m_hQuery;
    PDQ_BUFFER  m_pdhValues;        // PDQ_COUNTER  
    PDQ_BUFFER  m_pdhCounters;      // HCOUNTER*
    PDQ_BUFFER  m_pdhCounterNames;  // LPTSTR*
    PDQ_BUFFER  m_pdhDataNames;     // LPTSTR*
    BOOL        m_bGoodData;
    BOOL        m_bGoodNames;
    ULONG       m_nCurrentIndex;
    BOOL        m_bFirstQuery;
    BOOL        m_bInitialized;
    HLOG        m_hLog;
    TCHAR       m_strMessage[PDQ_ALLOCSIZE];
    BOOL        m_bMessage;
    HANDLE      m_hCollectionThread;
    BOOL*       m_pbTerminate;
    BOOL        m_bExpand;

private:
    DWORD GrowMemory( PPDQ_BUFFER buffer, size_t tSize, DWORD dwSize, BOOL bSave = FALSE );
    PDH_STATUS EnumPath( LPTSTR szWildCardPath );
    DWORD Add( HCOUNTER hCounter, LPTSTR szCounter );
};

#endif //PDHPDQ_H_05271999
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trace\typeperf\typeperf.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <conio.h>
#include <assert.h>
#include <tchar.h>
#include <ntverp.h>

#include "resource.h"
#include "pdqpdh.h"

#include "varg.c"

DWORD GetLogFormat( LPTSTR str, DWORD* pVal );
PDH_STATUS Query( LPTSTR strObjectQuery, BOOL bExpand );
void CounterErrorCallback( LPTSTR strCounter, PDH_STATUS pdhStatus );

#define ACTION_GROUP    1
#define QUERY_GROUP     2
#define COLLECT_GROUP   4

VARG_DECLARE_COMMANDS
    VARG_DEBUG( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP ( VARG_FLAG_OPTIONAL )
    VARG_MSZ  ( IDS_PARAM_COUNTERS, VARG_FLAG_NOFLAG, _T("") )
    VARG_STR  ( IDS_PARAM_FORMAT,   VARG_FLAG_OPTIONAL, _T("CRT") )
    VARG_STR  ( IDS_PARAM_INPUT,    VARG_FLAG_ARG_FILENAME, _T("") )
    VARG_TIME ( IDS_PARAM_INTERVAL, VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_STR  ( IDS_PARAM_OUTPUT,   VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_OUTPUT )
    VARG_STR  ( IDS_PARAM_QUERY,    VARG_FLAG_DEFAULTABLE, NULL )
    VARG_STR  ( IDS_PARAM_QUERYX,   VARG_FLAG_DEFAULTABLE, NULL )
    VARG_INT  ( IDS_PARAM_SAMPLES,  VARG_FLAG_OPTIONAL, 100 )
    VARG_INI  ( IDS_PARAM_SETTINGS, VARG_FLAG_OPTIONAL, NULL )
    VARG_STR  ( IDS_PARAM_SERVER,   VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL ( IDS_PARAM_YES,      VARG_FLAG_OPTIONAL, FALSE )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eCounters,
    eFormat,
    eInput,
    eInterval,
    eOutput,
    eQuery,
    eQueryX,
    eSamples,
    eSettings,
    eComputer,
    eYes,
VARG_DECLARE_FORMAT
    VARG_GROUP( eCounters,  VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eInput,     VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eQuery,     VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eQueryX,    VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eQuery,     VARG_GRPX(QUERY_GROUP, COLLECT_GROUP ) )
    VARG_GROUP( eQueryX,    VARG_GRPX(QUERY_GROUP, COLLECT_GROUP ) )
    VARG_GROUP( eQuery,     VARG_GRPX(QUERY_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eQueryX,    VARG_GRPX(QUERY_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eInput,     VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eFormat,    VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eInterval,  VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eSamples,   VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eCounters,  VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_EXHELP( eCounters, IDS_EXAMPLE_COUNTERS )
    VARG_EXHELP( eQueryX,   IDS_EXAMPLE_QUERYALL )
    VARG_EXHELP( eFormat,   IDS_EXAMPLE_FORMAT   )
VARG_DECLARE_END    

#define LOG_TYPE_CRT    (-1)
#define LOG_TYPE_W2K    (3)
#define WINDOWS_2000    (2195)

#define TERROR_BAD_FORMAT  0xF0000001
#define TERROR_NO_COUNTERS 0xF0000002

CPdqPdh* g_pdh = NULL;
HANDLE   g_hExit = NULL;
LONG     g_bExit = FALSE;

#define CHECK_HR(hr)  if(ERROR_SUCCESS != hr){goto cleanup;}
#define CHECK_EXIT( b ) if( b ){ goto cleanup;}

BOOL __stdcall leave( DWORD /*dwType*/ )
{
    InterlockedExchange( &g_bExit, TRUE );
    if( g_hExit != NULL ){
        SetEvent( g_hExit );
    }

    return TRUE;
}

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    DWORD      dwStatus  = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    BOOL    bResult;
    ULONG   nSeconds = 1;
    DWORD   dwFormat;

    g_hExit = CreateEvent( NULL, FALSE, FALSE, NULL );

    SetConsoleCtrlHandler( leave, TRUE );

    ParseCmd( argc, argv );

    CHECK_EXIT( g_bExit );
    if( Commands[eQuery].bDefined || Commands[eQueryX].bDefined){
        if( Commands[eOutput].bDefined && !Commands[eYes].bValue ){
            dwStatus = CheckFile( Commands[eOutput].strValue, VARG_CF_PROMPT|VARG_CF_OVERWRITE );
            CHECK_HR(dwStatus);
        }

        if( Commands[eQuery].bDefined ){
            pdhStatus = Query( Commands[eQuery].strValue, FALSE );
        }else{
            pdhStatus = Query( Commands[eQueryX].strValue, TRUE );
        }
        goto cleanup;
    }

    OSVERSIONINFO VersionInfo;
    
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionEx( &VersionInfo );

    if( ! bResult ){
        ZeroMemory( &VersionInfo, sizeof( OSVERSIONINFO ) );
    }
    
    if( Commands[eInterval].bDefined ){
        nSeconds = Commands[eInterval].stValue.wSecond;
        nSeconds += (Commands[eInterval].stValue.wMinute * 60);
        nSeconds += (Commands[eInterval].stValue.wHour * 3600);
    }
    __try {

        CHECK_EXIT( g_bExit );
        g_pdh = new CPdqPdh;

        if( g_pdh == NULL ){
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        g_pdh->Initialize( (INT*)&g_bExit );

        CHECK_EXIT( g_bExit );

        if( Commands[eOutput].bDefined && !Commands[eFormat].bDefined ){
            dwFormat = PDH_LOG_TYPE_CSV;
        }else{
            dwStatus = GetLogFormat( Commands[eFormat].strValue, &dwFormat );
            CHECK_HR(dwStatus);
        }

        switch( dwFormat ){
        case PDH_LOG_TYPE_SQL:
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
        case LOG_TYPE_CRT:
            g_pdh->SetExpand(TRUE);
            break;
        default:
            g_pdh->SetExpand(FALSE);
        }

        if( Commands[eCounters].bDefined ){
    
            LPTSTR strCounter;

            strCounter = Commands[eCounters].strValue;
            if( strCounter != NULL ){
                while( *strCounter != _T('\0') ){
                    CHECK_EXIT( g_bExit );
                    pdhStatus = g_pdh->AddCounter( strCounter, Commands[eComputer].strValue, CounterErrorCallback );
                    if( pdhStatus != ERROR_SUCCESS ){
                        PrintMessage( g_debug, IDS_MESSAGE_BADCOUNTER, strCounter, pdhStatus );
                        pdhStatus = ERROR_SUCCESS;
                    }
                    strCounter += (_tcslen( strCounter ) + 1);
                }
            }
        }

        if( Commands[eInput].bDefined ){
            CHECK_EXIT( g_bExit );
            dwStatus = g_pdh->GetCountersFromFile(
                    Commands[eInput].strValue, 
                    Commands[eComputer].strValue,
                    CounterErrorCallback );
            CHECK_EXIT( g_bExit );
        }
        
        varg_printf( g_normal, _T("\n") );

        if( Commands[eDebug].bDefined ){
            g_pdh->Query();
            for( ULONG nCounter = 0; nCounter < g_pdh->GetCounterCount(); nCounter++ ){
                CHECK_EXIT( g_bExit );
                pdhStatus = g_pdh->CollectData( nCounter );
                for( int err = 0; err<10 && pdhStatus != ERROR_SUCCESS; err++ ){
                    _sleep(10);
                    pdhStatus = g_pdh->CollectData( nCounter );
                }
                if( ERROR_SUCCESS != pdhStatus ){
                    varg_printf( g_debug, _T("<%1!4d!> %2!s!\n"), nCounter+1, g_pdh->GetDataName(PDQ_BASE_NAME) );
                    if( Commands[eDebug].nValue > 0 ){
                        PrintErrorEx( pdhStatus, _T("PDH.DLL") );
                    }
                    pdhStatus = ERROR_SUCCESS;
                }else{
                    varg_printf( g_debug, _T("[%1!4d!] %2!s!\n"), nCounter+1, g_pdh->GetDataName(PDQ_BASE_NAME) );
                    if( Commands[eDebug].nValue > 1 && g_pdh->GetDataCount() > 1 ){
                        for( ULONG i=0; i < g_pdh->GetDataCount();i++){
                            CHECK_EXIT( g_bExit );
                            varg_printf( g_debug, _T("  ->   %1!s!\n"), g_pdh->GetDataName(i) );
                        }
                    }
                }
            }
            varg_printf( g_normal, _T("\n") );
        }

        if( g_pdh->GetCounterCount() == 0){
            dwStatus = TERROR_NO_COUNTERS;
            goto cleanup;
        }

        if( dwFormat == LOG_TYPE_CRT ){
            TCHAR buffer[256];
            SYSTEMTIME stSampleTime;
            DWORD dwWait;
            varg_printf( g_normal, _T("%1!s!"), PDQ_PDH_CSV_HEADER );
            g_pdh->Query();
            for( ULONG nCounter = 0; nCounter < g_pdh->GetCounterCount(); nCounter++ ){
                pdhStatus = g_pdh->CollectData( nCounter );
                if( ERROR_SUCCESS == pdhStatus ){
                    for( ULONG i=0; i < g_pdh->GetDataCount();i++){
                        varg_printf( g_normal, _T(",\"%1!s!\""), g_pdh->GetDataName(i) );
                    }
                }
            }
            ULONG nSamples = 0;
            while( !g_bExit ){

                nSamples++;
                dwWait = WaitForSingleObject( g_hExit, nSeconds*1000 );
                if( dwWait != WAIT_TIMEOUT ){
                    break;
                }

                GetLocalTime (&stSampleTime);
                varg_printf( g_normal, _T("\n\"%1!2.2d!/%2!2.2d!/%3!4.4d! %4!2.2d!:%5!2.2d!:%6!2.2d!.%7!3.3d!\""),
                        stSampleTime.wMonth, stSampleTime.wDay, stSampleTime.wYear,
                        stSampleTime.wHour, stSampleTime.wMinute, stSampleTime.wSecond,
                        stSampleTime.wMilliseconds
                    );
        
                g_pdh->Query();
                for( ULONG nCounter = 0; nCounter < g_pdh->GetCounterCount(); nCounter++ ){
                    pdhStatus = g_pdh->CollectData( nCounter );
                    if( ERROR_SUCCESS == pdhStatus ){
                        for( ULONG i=0; i < g_pdh->GetDataCount();i++){
                            StringCchPrintf( buffer, 256, _T("%f"), g_pdh->GetData( i ) );
                            varg_printf( g_normal, _T(",\"%1!s!\""), buffer );
                        }
                    }else{
                        varg_printf( g_normal, _T(",\"%1!d!\""), PDQ_BAD_VALUE );
                    }
                }

                if( Commands[eSamples].bDefined && nSamples >= Commands[eSamples].nValue ){
                    break;
                }
            }
            varg_printf( g_normal, _T("\n") );
    
        }else{
            TCHAR buffer[MAXSTR];
            TCHAR drive[_MAX_DRIVE];
            TCHAR path[MAXSTR];
            TCHAR file[_MAX_FNAME];
            TCHAR ext[_MAX_EXT];

            _tsplitpath( Commands[eOutput].strValue, drive, path, file, ext );
            if( 0 == _tcslen( ext ) ){
                switch( dwFormat ){
                case PDH_LOG_TYPE_TSV: StringCchCopy( ext, _MAX_EXT,_T("tsv") ); break;
                case PDH_LOG_TYPE_CSV: StringCchCopy( ext, _MAX_EXT, _T("csv") ); break;
                case PDH_LOG_TYPE_SQL: break;
                case PDH_LOG_TYPE_BINARY: 
                    StringCchCopy( ext, _MAX_EXT, _T("blg") ); break;
                }
            }
            _tmakepath( buffer, drive, path, file, ext );
         
            if( VersionInfo.dwBuildNumber <= WINDOWS_2000 && dwFormat == PDH_LOG_TYPE_BINARY ){
                dwFormat = LOG_TYPE_W2K;
            }

            if( Commands[eOutput].bDefined && !Commands[eYes].bValue && dwFormat != PDH_LOG_TYPE_SQL ){
                dwStatus = CheckFile( buffer, VARG_CF_PROMPT|VARG_CF_OVERWRITE );
                CHECK_HR(dwStatus);
            }

            pdhStatus = g_pdh->LogCreate( buffer, dwFormat );
            
            if( ERROR_SUCCESS == pdhStatus ){

                TCHAR spin[8] = _T("|/-\\");
                int nSpin;

                nSpin = LoadString( NULL, IDS_MESSAGE_SPINNER, buffer, 8 );
                if( nSpin < 8 && nSpin > 0 ){
                    _tcsncpy( spin, buffer, nSpin );
                }else{
                    nSpin = 4;
                }
        
                if( Commands[eSamples].bDefined ){
                    g_pdh->LogStart( nSeconds * 1000, Commands[eSamples].nValue );
                }else{
                    g_pdh->LogStart( nSeconds * 1000 );
                }

                int loop = 0;
                DWORD dwWait;
                while( !g_bExit ){
                    _tprintf( _T("\r[%c]"), spin[loop++ % nSpin] );
                    dwWait = WaitForSingleObject( g_hExit, 500 );
                    if( dwWait != WAIT_TIMEOUT || g_pdh->GetState() != PDQ_STATE_LOGGING ){
                        break;
                    }
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetLastError();
    }
  

cleanup:    

    _tprintf( _T("\r") );
    PrintMessage( g_normal, IDS_MESSAGE_EXIT );
    _tprintf( _T("\r") );

    if( g_pdh ){
        delete g_pdh;
    }
    
    PrintMessage( g_normal, IDS_MESSAGE_CEXIT );

    switch( dwStatus ){
    case TERROR_NO_COUNTERS:
        PrintMessage( g_debug, IDS_MESSAGE_NOCOUNTERS );
        break;
    case TERROR_BAD_FORMAT:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case ERROR_SUCCESS:
        if( ERROR_SUCCESS == pdhStatus ){
            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        }else{
            PrintErrorEx( pdhStatus, _T("PDH.DLL") );
            dwStatus = pdhStatus;
        }
        break;
    default:
        PrintError( dwStatus );
    }

    FreeCmd();

    return dwStatus;
}

void CounterErrorCallback( LPTSTR strCounter, PDH_STATUS pdhStatus )
{
    PrintMessage( g_debug, IDS_MESSAGE_BADCOUNTER, strCounter, pdhStatus );
}

DWORD
GetLogFormat( LPTSTR str, DWORD* pVal )
{
    if( str != NULL ){
        if( !_tcsicmp( str, _T("TSV")) ){
            *pVal = PDH_LOG_TYPE_TSV;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("CSV")) ){
            *pVal = PDH_LOG_TYPE_CSV;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("SQL")) ){
            *pVal = PDH_LOG_TYPE_SQL;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("CRT")) ){
            *pVal = LOG_TYPE_CRT;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("BIN")) ){
            *pVal = PDH_LOG_TYPE_BINARY;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("BLG")) ){
            *pVal = PDH_LOG_TYPE_BINARY;
            return ERROR_SUCCESS;
        }
    }

    return TERROR_BAD_FORMAT;
}

PDH_STATUS 
Query( LPTSTR strRequest, BOOL bExpand )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    LPTSTR strObjectQuery = NULL;
    LPTSTR strMachine = NULL;

    LPTSTR mszObjects = NULL;
    LPTSTR strObject = NULL;
    DWORD  dwObjects = 0;
    
    if( strRequest != NULL ){
        TCHAR buffer[MAXSTR];

        StringCchCopy( buffer, MAXSTR, strRequest );

        if( buffer[0] == _T('\\') && buffer[1] == _T('\\') ){
            strMachine = _tcstok( buffer, _T("\\\n") );
            strObjectQuery = _tcstok( NULL, _T("\n") );
        }else{
            strMachine = Commands[eComputer].strValue;
            if( strMachine != NULL){
                while( strMachine[0] == _T('\\') ) strMachine++;
            }
            strObjectQuery = _tcstok( buffer, _T("\\\n") );
        }
    }else{
        strMachine = Commands[eComputer].strValue;
    }
    
    FILE* f = NULL;
    if( Commands[eOutput].bDefined ){
        f = _tfopen( Commands[eOutput].strValue, _T("w") );

        if( NULL == f ){
            DWORD dwStatus = GetLastError();
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
            goto cleanup;
        }

    }


    if( strObjectQuery == NULL ){
        pdhStatus = PdhEnumObjects( 
                NULL, 
                strMachine, 
                mszObjects, 
                &dwObjects, 
                PERF_DETAIL_WIZARD, 
                FALSE 
            );
    }

    if( pdhStatus == ERROR_SUCCESS || PDQ_MORE_DATA(pdhStatus) ){

        if( strObjectQuery == NULL ){
            mszObjects = (LPTSTR)VARG_ALLOC( dwObjects * sizeof(TCHAR) );
        
            if( mszObjects == NULL ){
                if( Commands[eOutput].bDefined ){
                    if( NULL != f ){
                        fclose(f);
                    }
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pdhStatus = PdhEnumObjects( 
                        NULL, 
                        strMachine, 
                        mszObjects, 
                        &dwObjects, 
                        PERF_DETAIL_WIZARD, 
                        FALSE 
                    );
            strObject = mszObjects;
        }else{
            strObject = strObjectQuery;
        }

        while( NULL != strObject && strObject[0] != _T('\0') ){

            LPTSTR mszCounters = NULL;
            LPTSTR strCounter = NULL;
            LPTSTR mszInstances = NULL;
            LPTSTR strInstance = NULL;
            DWORD  dwCounters = 0;
            DWORD  dwInstances = 0;

            CHECK_EXIT( g_bExit );

            pdhStatus = PdhEnumObjectItems( 
                        NULL, 
                        strMachine, 
                        strObject, 
                        mszCounters, 
                        &dwCounters, 
                        mszInstances, 
                        &dwInstances, 
                        PERF_DETAIL_WIZARD, 
                        0 
                    );

            if( ERROR_SUCCESS == pdhStatus || PDQ_MORE_DATA(pdhStatus) ){
                mszCounters = (LPTSTR)VARG_ALLOC( dwCounters * sizeof(TCHAR) );
                mszInstances = (LPTSTR)VARG_ALLOC( dwInstances * sizeof(TCHAR) );   

                if( mszCounters == NULL || mszInstances == NULL ){
                    VARG_FREE( mszObjects );
                    VARG_FREE( mszCounters );
                    VARG_FREE( mszInstances );
                    if( Commands[eOutput].bDefined ){
                        if( NULL != f ){
                            fclose(f);
                        }
                    }
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                pdhStatus = PdhEnumObjectItems( 
                            NULL, 
                            strMachine, 
                            strObject, 
                            mszCounters, 
                            &dwCounters, 
                            mszInstances,
                            &dwInstances, 
                            PERF_DETAIL_WIZARD, 
                            0 
                        );

                if( ERROR_SUCCESS == pdhStatus ){
                    strCounter = mszCounters;
                    while( NULL != strCounter && strCounter[0] != _T('\0') ){
                        strInstance = mszInstances;
                        CHECK_EXIT( g_bExit );
                        
                        if( dwInstances > 0 && _tcslen( strInstance ) ){
                            if( bExpand == FALSE ){
                                if( strMachine != NULL ){
                                    if( NULL != f ){
                                        _ftprintf( f, _T("\\\\%s"), strMachine );
                                    }else{
                                        varg_printf( g_normal,  _T("\\\\%2!s!"), strMachine );
                                    }
                                }
                                if( NULL != f ){
                                    _ftprintf( f, _T("\\%s(*)\\%s\n"), strObject, strCounter );
                                }else{
                                    varg_printf( g_normal, _T("\\%1!s!(*)\\%2!s!\n"), strObject, strCounter );
                                }
                            }else{
                                LPTSTR strLastInstance = NULL;
                                ULONG nInstance = 0;
                                while( NULL != strInstance && strInstance[0] != _T('\0') ){
                                    CHECK_EXIT( g_bExit );
                                    if( strMachine != NULL ){
                                        if( NULL != f ){
                                            _ftprintf( f, _T("\\\\%s"), strMachine );
                                        }else{
                                            varg_printf( g_normal, _T("\\\\%1!s!"), strMachine );
                                        }
                                    }
                                    if( strLastInstance == NULL || _tcscmp( strLastInstance, strInstance ) ){
                                        if( NULL != f ){
                                            _ftprintf( f, _T("\\%s(%s)\\%s\n"), strObject, strInstance, strCounter );
                                        }else{
                                            varg_printf( g_normal, _T("\\%1!s!(%2!s!)\\%3!s!\n"), strObject, strInstance, strCounter );
                                        }
                                        nInstance = 0;
                                    }else{
                                        if( NULL != f ){
                                            _ftprintf( f, _T("\\%s(%s#%d)\\%s\n"), strObject, strInstance, ++nInstance, strCounter );
                                        }else{
                                            varg_printf( g_normal, _T("\\%1!s!(%2!s!#%3!d!)\\%4!s!\n"), strObject, strInstance, ++nInstance, strCounter );
                                        }
                                    }
                                    strLastInstance = strInstance;
                                    strInstance += _tcslen( strInstance ) + 1;
                                }
                            }

                        }else{
                            if( strMachine != NULL ){
                                if( NULL != f ){
                                    _ftprintf( f, _T("\\\\%s"), strMachine );
                                }else{
                                    varg_printf( g_normal, _T("\\\\%1!s!"), strMachine );
                                }
                            }
                            if( NULL != f ){
                                _ftprintf( f, _T("\\%s\\%s\n"), strObject, strCounter );
                            }else{
                                varg_printf( g_normal, _T("\\%1!s!\\%2!s!\n"), strObject, strCounter );
                            }
                        }

                        
                        strCounter += _tcslen( strCounter ) + 1;
                    }
                }

                VARG_FREE( mszCounters );
                VARG_FREE( mszInstances );

            }

            if( strObjectQuery == NULL ){
                strObject += _tcslen( strObject ) + 1;
            }else{
                strObject = NULL;
            }
        }

        VARG_FREE( mszObjects );
    }
    
cleanup:

    if( Commands[eOutput].bDefined && NULL != f ){
        fclose(f);
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\trans\trans.c ===
/*  trans.c - transliterate one file into another
 *
 *  Modifications:
 *      30-Apr-1987 mz  Use fmove ()
 *      13-May-1987 mz  Check for buffer overflow
 *                      Use stderr for error output
 *      14-May-1987 bw  Fix stack overflow on fREMatch call
 *                      Make stdin/stdout O_BINARY when used
 *                      Use return message from fmove()
 *                      Send debug output to stderr
 *  01-Mar-1988 mz  Add parameter to RECompile for Z syntax
 *  15-Sep-1988 bw  fREMatch became REMatch
 *
 */
#include <malloc.h>

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
#include <remi.h>

#define BUFFERSIZE  512
#define MAXRESTACK 1024

flagType fCase = FALSE;                 /* TRUE => case is significant */
flagType fTrans = FALSE;                /* TRUE => transform file */
flagType fDebug = FALSE;

// Forward Function Declarations...
void     usage( void );
void     fatal( char * );
flagType fDoTrans( FILE *, FILE *, char * );

extern flagType RETranslate( struct patType *, char *, char * );
extern int RETranslateLength( struct patType *, char * );

struct patType *pbuf;
RE_OPCODE * REStack[MAXRESTACK];

void usage ()
{
    fatal ("Usage: trans [/c] [/t] [files]\n");
}

void fatal( p1 )
char *p1;
{
    fprintf (stderr, p1 );
    exit (1);
}

flagType fDoTrans (fhin, fhout, rbuf)
FILE *fhin, *fhout;
char *rbuf;
{
    flagType fChanged;
    static char buf[BUFFERSIZE], rpl[BUFFERSIZE];
    char * p, * np;
    int line = 0;

    fChanged = FALSE;
    if (fDebug)
        fprintf (stderr, "Replacement '%s'\n", rbuf);
    while (fgetl (buf, BUFFERSIZE, fhin) != 0) {
        line++;
        p = buf;
        if (fDebug)
            fprintf (stderr, "Input: '%s'\n", buf);
        while (!REMatch (pbuf, buf, p, REStack, MAXRESTACK, TRUE)) {
            fChanged = TRUE;
            if (fDebug)
                fprintf (stderr, " Match at %x length %x\n",
                        REStart (pbuf)-buf,
                        RELength (pbuf, 0));

            /*  Make sure translation will fit in temp buffers
             */
            if (RETranslateLength (pbuf, rbuf) >= BUFFERSIZE) {
                fprintf (stderr, "After translation, line %d too long", line);
                exit (1);
                }

            if (!RETranslate (pbuf, rbuf, rpl))
                fatal ("Invalid replacement pattern\n");

            if (fDebug)
                fprintf (stderr, " Replacement: '%s'\n", rpl);

            /*  Make sure body - match + translation still fits in buffer
             */
            if (strlen (buf) - RELength (pbuf, 0) + strlen (rpl) >= BUFFERSIZE) {
                fprintf (stderr, "After translation, line %d too long", line);
                exit (1);
                }

            np = (p = REStart (pbuf)) + strlen (rpl);
            strcat (rpl, p + RELength (pbuf, 0));
            strcpy (p, rpl);
            p = np;
            if (fDebug)
                fprintf (stderr, " Match start %x in '%s'\n", p-buf, buf);
            }
        if (!fTrans || p != buf) {
            if (fDebug)
                fprintf (stderr, " Outputting '%s'\n", buf);
            fputl (buf, strlen(buf), fhout);
            }
        }
    return fChanged;
}

__cdecl
main (
    int c,
    char *v[]
    )
{
    FILE *fhin, *fhout;
    char *p, *p1;
    flagType fChanged;

    ConvertAppToOem( c, v );
    if (c < 3)
        usage ();

    while (fSwitChr (*v[1])) {
        switch (v[1][1]) {
        case 'c':
            fCase = TRUE;
            break;
        case 'd':
            fDebug = TRUE;
            break;
        case 't':
            fTrans = TRUE;
            break;
        default:
            usage ();
            }
        SHIFT(c,v);
        }
    if ((pbuf = RECompile (v[1], fCase, TRUE)) == NULL)
        fatal ("Invalid pattern\n");
    p = v[2];
    if (c == 3) {
        _setmode(0, O_BINARY);
        _setmode(1, O_BINARY);
        fDoTrans (stdin, stdout, p);
    }
    else
        while (c != 3) {
            if ((fhin = fopen (v[3], "rb")) == NULL)
                fprintf (stderr, "trans: Cannot open %s - %s\n", v[3], error ());
            else
            if ((fhout = fopen ("trans$$$.$$$", "wb")) == NULL) {
                fprintf (stderr, "trans: Cannot create temp file - %s\n", error ());
                fclose (fhin);
                }
            else {
                printf ("%s ", v[3]);
                fChanged = fDoTrans (fhin, fhout, p);
                fclose (fhin);
                fclose (fhout);
                if (fChanged) {
                    if (p1 = fmove ("trans$$$.$$$", v[3]))
                        printf ("[%s]\n", p1);
                    else
                        printf ("[OK]\n");
                    }
                else {
                    _unlink ("trans$$$.$$$");
                    printf ("[No change]\n");
                    }
                }
            SHIFT(c,v);
            }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tsen\tsen.h ===
/*
	TSen.h
	(c) 2002 Microsoft Corp
*/
#ifndef _TSEN_H
#define _TSEN_H


#define UNICODE 



#define _UNICODE



TCHAR *ParseArgs();
TCHAR *Constants();
int printTSSession(TCHAR*);

TCHAR Usage[] =
	_T("tsen - displays details of the active TS session on a remote computer\n")
	_T("Usage: \ttsen.exe [/?][computer]\n\n" \)
	_T("\t\tplease run as the ntdev\\ntbuild\n" \)
	_T("\n") ;

TCHAR Codes[] = 
        _T("\t%u A user is logged on to the WinStation.\n")
        _T("\t%u The WinStation is connected to the client.\n" \)
        _T("\t%u The WinStation is in the process of connecting to the client.\n" \)
        _T("\t%u The WinStation is shadowing another WinStation. \n" \)
        _T("\t%u The WinStation is active but the client is disconnected. \n" \)
        _T("\t%u The WinStation is waiting for a client to connect. \n" \)
        _T("\t%u The WinStation is listening for a connection. \n" \)
        _T("\t%u The WinStation is being reset. \n" \)
        _T("\t%u The WinStation is down due to an error. \n"\)
        _T("\t%u The WinStation is initializing. \n\n");


CONST INT SZTSIZE = 1024;
CONST INT KNOWNARG = 1;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tz\tz.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tz.h

Abstract:

    This is the main include file for the Windows TZ (time zone utility)

Author:

    Steve Wood (stevewo) 16-May-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tz\tz.c ===
/*
 * Utility program to query and set the current time zone settings
 * in the registry.
 *
 *      tz [-b Bias] [-s Name Bias Date] [-d Name Bias Date]
 *
 */

#include "tz.h"

void
Usage( void )
{
    fprintf( stderr, "usage: TZ [-b Bias] [-s Name Bias Date] [-d Name Bias Date]\n" );
    fprintf( stderr, "Where...\n" );
    fprintf( stderr, "    Default with no parameters is to display current time zone settings.\n" );
    exit( 1 );
}

char KeyValueBuffer[ 4096 ];

char *Order[] = {
    "first",

    "second",

    "third",

    "fourth",

    "last"
};

char *DayOfWeek[] = {
    "Sunday",

    "Monday",

    "Tuesday",

    "Wednesday",

    "Thursday",

    "Friday",

    "Saturday"
};

char *Months[] = {
    "January",

    "February",

    "March",

    "April",

    "May",

    "June",

    "July",

    "August",

    "September",

    "October",

    "November",

    "December"
};

#define NUMBER_DATE_TIME_FIELDS 6

BOOL
ParseTimeZoneInfo(
    IN LPSTR NameIn,
    OUT PWSTR NameOut,
    IN LPSTR BiasIn,
    OUT PLONG BiasOut,
    IN LPSTR StartIn,
    OUT PTIME_FIELDS StartOut
    )
{
    LPSTR s, s1;
    ULONG FieldIndexes[ NUMBER_DATE_TIME_FIELDS  ] = {1, 2, 0, 3, 4, 7};
    //
    // Month/Day/Year HH:MM DayOfWeek
    //

    ULONG CurrentField = 0;
    PCSHORT Fields;
    LPSTR Field;
    ULONG FieldValue;

    MultiByteToWideChar( CP_ACP,
                         0,
                         NameIn,
                         strlen( NameIn ),
                         NameOut,
                         32
                       );
    *BiasOut = atoi( BiasIn );
    s = StartIn;

    RtlZeroMemory( StartOut, sizeof( *StartOut ) );
    Fields = &StartOut->Year;
    while (*s) {
        if (CurrentField >= 7) {
            return( FALSE );
            }

        while (*s == ' ') {
            s++;
            }

        Field = s;
        while (*s) {
            if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                }
            else
            if (*s < '0' || *s > '9') {
                break;
                }

            s++;
            }

        if (*s) {
            s++;
            }

        if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
            if (strlen( Field ) < 3) {
                printf( "TZ: %s invalid day of week length\n", Field );
                return FALSE;
                }

            if (StartOut->Year != 0) {
                printf( "TZ: Year must be zero to specify day of week\n" );
                return FALSE;
                }

            if (!_strnicmp( Field, "SUN", 3 )) {
                FieldValue = 0;
                }
            else
            if (!_strnicmp( Field, "MON", 3 )) {
                FieldValue = 1;
                }
            else
            if (!_strnicmp( Field, "TUE", 3 )) {
                FieldValue = 2;
                }
            else
            if (!_strnicmp( Field, "WED", 3 )) {
                FieldValue = 3;
                }
            else
            if (!_strnicmp( Field, "THU", 3 )) {
                FieldValue = 4;
                }
            else
            if (!_strnicmp( Field, "FRI", 3 )) {
                FieldValue = 5;
                }
            else
            if (!_strnicmp( Field, "SAT", 3 )) {
                FieldValue = 6;
                }
            else {
                printf( "TZ: %s invalid day of week\n", Field );
                return FALSE;
                }
            }
        else {
            FieldValue = atoi( Field );
            }

        Fields[ FieldIndexes[ CurrentField++ ] ] = (CSHORT)FieldValue;
        }

    if (StartOut->Year == 0) {
        if (StartOut->Day > 5) {
            printf( "TZ: Day must be 0 - 5 if year is zero.\n" );
            return FALSE;
            }
        }
    else
    if (StartOut->Year < 100) {
        StartOut->Year += 1900;
        }

    return TRUE;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i, j;
    LPSTR s, s1, s2, s3, AmPm;
    NTSTATUS Status;
    RTL_TIME_ZONE_INFORMATION tzi;
    BOOLEAN InfoModified = FALSE;

    ConvertAppToOem( argc, argv );
    if (argc < 1) {
        Usage();
        }

    Status = RtlQueryTimeZoneInformation( &tzi );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "TZ: Unable to query current information.\n" );
        }

    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'b':
                        if (argc) {
                            --argc;
                            tzi.Bias = atoi( *++argv );
                            InfoModified = TRUE;
                            }
                        else {
                            Usage();
                            }
                        break;

                    case 's':
                        if (argc >= 3) {
                            argc -= 3;
                            s1 = *++argv;
                            s2 = *++argv;
                            s3 = *++argv;
                            if (ParseTimeZoneInfo( s1, tzi.StandardName,
                                                   s2, &tzi.StandardBias,
                                                   s3, &tzi.StandardStart
                                                 )
                               ) {
                                InfoModified = TRUE;
                                }
                            else {
                                Usage();
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    case 'd':
                        if (argc >= 3) {
                            argc -= 3;
                            s1 = *++argv;
                            s2 = *++argv;
                            s3 = *++argv;
                            if (ParseTimeZoneInfo( s1, tzi.DaylightName,
                                                   s2, &tzi.DaylightBias,
                                                   s3, &tzi.DaylightStart
                                                 )
                               ) {
                                InfoModified = TRUE;
                                }
                            else {
                                Usage();
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    default:    Usage();
                    }
                }
            }
        else {
            Usage();
            }
        }

    if (InfoModified) {
        Status = RtlSetTimeZoneInformation( &tzi );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "TZ: Unable to set new information.\n" );
            }
        }

    printf( "Time Zone Information.\n" );
    printf( "    Bias from UTC: %u:%02u\n", tzi.Bias / 60, tzi.Bias % 60 );
    printf( "    Standard time:\n" );
    printf( "        Name: %ws\n", &tzi.StandardName );
    printf( "        Bias: %d:%02d\n", tzi.StandardBias / 60, abs( tzi.StandardBias % 60 ) );

    if (tzi.StandardStart.Month != 0) {
        if (tzi.StandardStart.Hour > 12) {
            AmPm = "pm";
            tzi.StandardStart.Hour -= 12;
            }
        else {
            AmPm = "am";
            }
        printf( "        Start: %02u:%02u%s", tzi.StandardStart.Hour, tzi.StandardStart.Minute, AmPm );

        if (tzi.StandardStart.Year == 0) {
            printf( " %s %s of %s\n",
                    Order[ tzi.StandardStart.Day - 1 ],
                    DayOfWeek[ tzi.StandardStart.Weekday ],
                    Months[ tzi.StandardStart.Month - 1 ]
                  );
            }
        else {
            printf( "%s %02u, %u\n",
                    Months[ tzi.StandardStart.Month - 1 ],
                    tzi.StandardStart.Month, tzi.StandardStart.Day, tzi.StandardStart.Year
                  );
            }
        }

    printf( "    Daylight time:\n" );
    printf( "        Name: %ws\n", &tzi.DaylightName );
    printf( "        Bias: %d:%02d\n", tzi.DaylightBias / 60, abs( tzi.DaylightBias % 60 ) );

    if (tzi.DaylightStart.Month != 0) {
        if (tzi.DaylightStart.Hour > 12) {
            AmPm = "pm";
            tzi.DaylightStart.Hour -= 12;
            }
        else {
            AmPm = "am";
            }
        printf( "        Start: %02u:%02u%s", tzi.DaylightStart.Hour, tzi.DaylightStart.Minute, AmPm );

        if (tzi.DaylightStart.Year == 0) {
            printf( " %s %s of %s\n",
                    Order[ tzi.DaylightStart.Day - 1 ],
                    DayOfWeek[ tzi.DaylightStart.Weekday ],
                    Months[ tzi.DaylightStart.Month - 1 ]
                  );
            }
        else {
            printf( "%s %02u, %u\n",
                    Months[ tzi.DaylightStart.Month - 1 ],
                    tzi.DaylightStart.Month, tzi.DaylightStart.Day, tzi.DaylightStart.Year
                  );
            }
        }

    return( 0 );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tztool\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tztool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tztool.rc
//
#define IDD_TZDLG                       101
#define IDC_TZTEMP1                     1001
#define IDC_POLLTZ                      1002
#define IDC_FAHR                        1003
#define IDC_TZSELECT                    1004
#define IDC_TZONESEL                    1005
#define IDC_CRTTEMP                     1006
#define IDC_MINTEMP                     1007
#define IDC_TZONEDETAILS                1008
#define IDC_CURTEMP                     1008
#define IDC_TZDETAILS                   1009
#define IDC_TZDETAILS2                  1010
#define IDC_PSVDETAILS                  1011
#define IDC_ACXDETAILS                  1012
#define IDC_THROTTLE                    1013
#define IDC_MINTHROTTLE                 1014
#define IDC_MAXTHROTTLE                 1015
#define IDC_CURTHROTTLE                 1016
#define IDC_MAXIDLE                     1018
#define IDC_CURIDLE                     1019
#define IDC_OPTIONS                     -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tsen\tsen.c ===
/*
	TSen.h
	(c) 2002 Microsoft Corp
*/

#include <stdio.h>
#include <malloc.h>
#include <assert.h>
#include <tchar.h>
#include <windows.h> 
#include <wtsapi32.h> 
#include <Shellapi.h>
#include <process.h>
#include <lm.h>
#include "tsen.h"


void __cdecl main (int argc, TCHAR *argv[])
{
	//Get the server name		
	TCHAR*  pszServerName = ParseArgs(argc,argv);		    	

	//Print the TS session information
	if (printTSSession(pszServerName ))
	{
		exit(1);
	}   
   
   exit(0);
}

/*
	Function: Constants

	Return value: TCHAR Session status values
*/
TCHAR* Constants()
{

	TCHAR*  sztConstants = (TCHAR* ) calloc(SZTSIZE, sizeof(TCHAR));
	if(sztConstants!=NULL)
	{
		ZeroMemory(sztConstants, 1 + _tcslen(sztConstants));

		_stprintf(sztConstants, Codes
			, (DWORD) WTSActive  
			, (DWORD) WTSConnected
			, (DWORD) WTSConnectQuery 
			, (DWORD) WTSShadow 
			, (DWORD) WTSDisconnected 
			, (DWORD) WTSIdle 
			, (DWORD) WTSListen 
			, (DWORD) WTSReset 
			, (DWORD) WTSDown 
			, (DWORD) WTSInit);
	}
	else
	{
		exit(1);
	}

	return sztConstants;
}

/*
	Function: ParseArgs(int argc, TCHAR *argv[])

	Return value: Server name
*/

TCHAR* ParseArgs(int argc, TCHAR *argv[])
{

	TCHAR* sKeyWord   =  NULL;

	if(argc == 1 || _tcscmp(argv[1],"/?")==0)
	{		
		TCHAR* sUsageInfo = Constants();		
		
		_tprintf(_T("%s\n\n%s") , Usage,sUsageInfo);

		free(sUsageInfo);

    }
    else 
	{				
		sKeyWord = argv[1];
    }       
      
	return sKeyWord;

}


/*
	printTSSession(TCHAR* pszServerName)

		Prints the pszSeverNAme TS session information 
*/
int printTSSession(TCHAR* pszServerName)
{  
	DWORD dwTotalCount;
	DWORD SessionId;
	LPTSTR ppBuffer;
	DWORD pBytesReturned;
	DWORD dwCount = 0;
	TCHAR* sztStatus = NULL;
	TCHAR* sztStatLine = NULL;
	CONST DWORD Reserved = 0 ;
	CONST DWORD Version  = 1 ;
	PWTS_SESSION_INFO ppSessionInfo;
	NET_API_STATUS nStatus;	
	HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;

	if (pszServerName == NULL)  
	{
		exit(1);
	}	
    
	hServer =  WTSOpenServer( pszServerName);

	if ( hServer == NULL)
	{

		_tprintf(_T("WTSOpenServer \"%ws\" error: %u\n"), pszServerName, GetLastError( )); 
		exit(1);
	}

	sztStatus = calloc(SZTSIZE, sizeof(TCHAR));   

	if(sztStatus == NULL)
	{
		return 1;	
	}

	sztStatLine = calloc(SZTSIZE, sizeof(TCHAR));

	if(sztStatLine == NULL)
	{
		free(sztStatus);
		return 1;	
	}
	
	dwTotalCount = 0;	

	//Get all the sessions in the server (hServer)
	nStatus = WTSEnumerateSessions(hServer,Reserved,Version,&ppSessionInfo,&dwTotalCount);

	if (0 == nStatus || 0 == dwTotalCount) 
	{

		_tprintf(_T("WTSEnumerateSessions \"%s\" error: %u\n"),pszServerName,GetLastError( ));
		return 1;
	}

	//Loop trough the session and prints the information bout them
	for (dwCount = 0; (dwCount <  dwTotalCount); dwCount++)
	{
				
		//We only need to display this when the session is active
		if (WTSActive == ppSessionInfo[dwCount].State) 
		{
				
			SessionId = ppSessionInfo[dwCount].SessionId;

			WTSQuerySessionInformation(hServer,SessionId,WTSUserName,&ppBuffer,&pBytesReturned);
			_stprintf(sztStatLine, _T("Server=%s\nWindow station=%s\nThis session Id=%u\nUser=%s\n"),pszServerName,_tcsupr(ppSessionInfo[dwCount].pWinStationName),SessionId,_tcsupr(ppBuffer));
			_tcscpy(sztStatus,sztStatLine );
	
			WTSFreeMemory( ppBuffer);

			WTSQuerySessionInformation(hServer,SessionId,WTSClientName,&ppBuffer,&pBytesReturned);
             _stprintf(sztStatLine, _T("Client machine=%s\n"),_tcsupr(ppBuffer));
             _tcscat(sztStatus, sztStatLine );

			 WTSFreeMemory( ppBuffer);

             WTSQuerySessionInformation(hServer,SessionId,WTSClientAddress,&ppBuffer,&pBytesReturned);
             _stprintf(sztStatLine , _T("Active console session=%u\n"),(DWORD) WTSGetActiveConsoleSessionId ());
             _tcscat(sztStatus, sztStatLine );

			 WTSFreeMemory( ppBuffer);

             _tprintf(_T("%s"),  sztStatus);
		} // if (WTSActive == ppSessionInfo[dwCount].State) 
	} //for (dwCount = 0; (dwCount <  dwTotalCount); dwCount++)

	WTSFreeMemory( ppSessionInfo);

	free(sztStatLine); 
	free(sztStatus); 

	if (hServer != WTS_CURRENT_SERVER_HANDLE)
	{
		(void) WTSCloseServer(  hServer);	
	}

	return 0; 
} //int printTSSession(TCHAR* pszServerName)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\uixport\uixport.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    uixport.c
    This program parses the output of the "COFF -DUMP -SYMBOLS" command
    and extract all public symbols.  This is used to generate .DEF files
    for DLLs.


    FILE HISTORY:
        KeithMo     09-Aug-1992 00.00.00 Created.
        KeithMo     14-Sep-1992 00.00.01 Strip stdcall decoration from symbols.
        KeithMo     16-Oct-1992 00.00.02 Handle goofy []()* in coff output.

        DavidHov    18-Sep-1993 00.00.04 Added exclusion list processing.
                                         The exlusion list is generated
                                         mechanically and constiutes all the
                                         symbols which are not imported
                                         by any known NETUI/RAS/MAC (et al.)
                                         binary.

        DavidHov    22-Sep-1993 00.00.05 Added symbol ignore table and logic.
                                         The ignore table at this time ignores
                                         only the gigantic symbols generated
                                         by C8 when /Gf is used; these names
                                         are strings which are to be merged
                                         at link time.

        DaveWolfe   06-Jul-1994 00.01.01 (Motorola) Added -ppc option for
                                         PowerPC to strip entry point symbols
                                         generated for PPC TOC.
*/

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>


//
//  This is the maximum length (in characters) of any line we'll
//  receive from COFF.  If we receive a longer line, the program
//  won't crash, but we may miss a public symbol.
//

#define MAX_LINE_FROM_COFF      2000

//
//  This is the maximum length (in characters) of any symbol we'll
//  receive from COFF.
//

#define MAX_SYMBOL              247

//
//  This is the maximum length (in characters) of any error message
//  we'll display.
//

#define MAX_ERROR_MESSAGE       256

//
//  This is the length (in characters) of the header->output copy buffer.
//

#define HEADER_COPY_BUFFER_SIZE 256



//
//  Messages.
//

char _szBanner[]                = "%s version 00.01.01\n";
char _szCannotOpenForRead[]     = "Cannot open %s for read access.";
char _szCannotOpenForWrite[]    = "Cannot open %s for write access.";
char _szErrorCopyingHeader[]    = "Error copying header to output.";
char _szInvalidSwitch[]         = "Invalid switch '%c'.\n\n";
char _szSymbolTooLong[]         = "Symbol %s exceeds max symbol length!\n";
char _szExclusionError[]        = "Error processing exclusion list file; ignored" ;
char _szExclusionEmpty[]        = "Exclusion list file specified is empty; ignored" ;


//
//  Globals.
//

char * _pszProgramName;
FILE * _fileIn;
FILE * _fileOut;
FILE * _fileHeader;
int    _fStripLeadingUnderscore;
int    _fNukeStdcallDecoration;
int    _fPowerPC;
int    _fIA64;

char * _pszExclusionListFile = NULL ;
void * _pvExclusionBlock = NULL ;
char * * _apszExclusionArray = NULL ;
int    _cExclusionItems = -1 ;
int    _cExcludedItems = 0 ;
int    _cIgnoredItems = 0 ;


  //  This table contains the prefixes of symbol names to ignore
  //  while building the DEF file.  See ValidSymbol().

static char * apszIgnore [] =
{
    "??_C@_",       //  Ignore generated string symbol names
    NULL
};


//
//  Prototypes.
//

int __cdecl main( int    cArgs,
                   char * pArgs[] );

void Cleanup( void );

void CopyHeaderToOutput( FILE * fHeader,
                         FILE * fOutput );

int ExtractSymbol( char * pszLineFromCoff,
                   char * pszSymbol );

void __cdecl FatalError( int    err,
                 char * pszFmt,
                 ... );

void __cdecl NonFatalError( char * pszFmt,
                    ... );

int IsHexNumber( char * pszHexNumber );

char * NoPath( char * pszPathName );

void ProcessCommandLine( int    cArgs,
                         char * pArgs[] );

void StripStdcallDecoration( char * pszSymbol );

void Usage( void );

   //  Create the exclusion list.

int CreateExclusionList ( char * pszFileName,
                          void * * pvData,
                          char * * * apszStrings ) ;

   //  Check the excluded symbol list for this name

int ExcludedSymbol ( char * pszSymbol ) ;

int ValidSymbol ( const char * psz ) ;

/*******************************************************************

    NAME:       main

    SYNOPSIS:   C program entrypoint.

    ENTRY:      cArgs                   - Number of command line arguments.

                pArgs                   - An array of pointers to the
                                          command line arguments.

    RETURNS:    int                     -  0 if everything ran OK,
                                          !0 if an error occurred.

    NOTES:      See the Usage() function for valid command line arguments.

    HISTORY:
        KeithMo     09-Aug-1992 Created.
        KeithMo     14-Sep-1992 Strip stdcall decoration from symbols.

********************************************************************/
int __cdecl main( int    cArgs,
                   char * pArgs[] )
{
    //
    //  A line read from COFF.
    //

    char szLineFromCoff[MAX_LINE_FROM_COFF+1];

    //
    //  A symbol extracted from the COFF line.
    //

    char szSymbol[MAX_SYMBOL+1];

    //
    //  Get the program name, for our messages.
    //

    _pszProgramName = NoPath( pArgs[0] );

    //
    //  Announce ourselves.
    //

    fprintf( stderr,
             _szBanner,
             _pszProgramName );

    //
    //  Parse the command line arguments.
    //

    ProcessCommandLine( cArgs, pArgs );

    //
    //  If requested, copy the header file before processing
    //  the COFF output.
    //

    if( _fileHeader != NULL )
    {
        CopyHeaderToOutput( _fileHeader, _fileOut );
    }

    //
    //  If an exclusion list file was specified, process it.
    //  If it's empty, ignore it.
    //

    if ( _pszExclusionListFile )
    {
        _cExclusionItems = CreateExclusionList( _pszExclusionListFile,
                                                & _pvExclusionBlock,
                                                & _apszExclusionArray ) ;

        if ( _cExclusionItems < 0 )
        {
            _pszExclusionListFile = NULL ;
           NonFatalError( _szExclusionError ) ;
        }
        else
        if ( _cExclusionItems == 0 )
        {
            _pszExclusionListFile = NULL ;
           NonFatalError( _szExclusionEmpty ) ;
        }
    }

    //
    //  Read the lines from coff, extract the symbols, and
    //  write them to the output file.
    //

    while( fgets( szLineFromCoff, MAX_LINE_FROM_COFF, _fileIn ) != NULL )
    {
        char * pszDisplay = szSymbol;

        if( !ExtractSymbol( szLineFromCoff, szSymbol ) )
        {
            continue;
        }

        if ( ! _fNukeStdcallDecoration )
        {
            StripStdcallDecoration( szSymbol );
        }

        if ( ! ValidSymbol( pszDisplay ) )
        {
            _cIgnoredItems++ ;
            continue ;
        }

        if ( _pszExclusionListFile && ExcludedSymbol( szSymbol ) )
        {
            _cExcludedItems++ ;
            continue ;
        }

        if( _fStripLeadingUnderscore && ( *pszDisplay == '_' ) )
        {
            pszDisplay++;
        }

        fprintf( _fileOut, "%s\n", pszDisplay );
    }

    fprintf( _fileOut, "\032" );

    //  Give a synopsis of exclusion file processesing.

    fprintf( stdout, "\nSymbols ignored: %ld\n", _cIgnoredItems ) ;

    if ( _pszExclusionListFile )
    {
        fprintf( stdout, "\nExcluded symbols registered: %ld, excluded: %ld\n",
                 _cExclusionItems, _cExcludedItems ) ;
    }

    //
    //  Cleanup any open files, then exit.
    //

    Cleanup();
    return 0;

}   // main



/*******************************************************************

    NAME:       Cleanup

    SYNOPSIS:   Cleanup the app just before termination.  Closes any
                open files, frees memory buffers, etc.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/
void Cleanup( void )
{
    if( _fileHeader != NULL )
    {
        fclose( _fileHeader );
    }

    if( _fileIn != stdin )
    {
        fclose( _fileIn );
    }

    if( _fileOut != stdout )
    {
        fclose( _fileOut );
    }

    if ( _pvExclusionBlock )
    {
        free( _pvExclusionBlock ) ;
    }

    if ( _apszExclusionArray )
    {
        free( _apszExclusionArray ) ;
    }

}   // Cleanup



/*******************************************************************

    NAME:       CopyHeaderToOutput

    SYNOPSIS:   Copies the specified header file to the output file.

    ENTRY:      fHeader                 - An open file stream (read access)
                                          to the header file.

                fOutput                 - An open file stream (write access)
                                          to the output file.

    NOTES:      If any errors occur, FatalError() is called to terminate
                the app.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/
void CopyHeaderToOutput( FILE * fHeader,
                         FILE * fOutput )
{
    char   achBuffer[HEADER_COPY_BUFFER_SIZE];
    size_t cbRead;

    while( ( cbRead = fread( achBuffer,
                             sizeof(char),
                             HEADER_COPY_BUFFER_SIZE,
                             fHeader ) ) != 0 )
    {
        if( fwrite( achBuffer,
                    sizeof(char),
                    cbRead,
                    fOutput ) < cbRead )
        {
            break;
        }
    }

    if( ferror( fHeader ) || ferror( fOutput ) )
    {
        FatalError( 2, _szErrorCopyingHeader );
    }

}   // CopyHeaderToOutput



/*******************************************************************

    NAME:       ExtractSymbol

    SYNOPSIS:   Extracts a public symbol from a COFF output line.

    ENTRY:      pszLineFromCoff         - A text line output from the
                                          "COFF -DUMP -SYM" command.

                                          Note:  The text in the line
                                          will be modified by the strtok()
                                          function!

                pszSymbol               - Will receive the extracted symbol,
                                          if one is found.

    RETURNS:    int                     - !0 if a symbol was extracted,
                                           0 otherwise.

    NOTES:      Here's an example of the input (output from LINK32).
                The symbol -$- indicates places where I broke the line
                for clarity.  This just one line:

               009 00000000 SECT2  notype ()    External     |    -$-
               ??0APPLICATION@@IAE@PAUHINSTANCE__@@HIIII@Z        -$-
               (protected:  __thiscall APPLICATION::APPLICATION(  -$-
               struct HINSTANCE__ *,int,unsigned int,unsigned int,-$-
               unsigned int,unsigned int))

               We choose only symbols which are part of a SECT and are
               marked as "notype" and "External"

    HISTORY:
        KeithMo     09-Aug-1992 Created.
        DavidHov    20-Oct-1993 update to new LINK32 output form.

********************************************************************/
int ExtractSymbol( char * pszLineFromCoff,
                   char * pszSymbol )
{
    char * pszDelimiters = " \t\n";
    char * pszSect       = "SECT";
    char * pszNoType     = "notype";
    char * pszExternal   = "External";
    char * pszToken;
    char * pszPotentialSymbol;
    char * pszScan;

    //
    //  Verify that the first token is a hex number.
    //

    pszToken = strtok( pszLineFromCoff, pszDelimiters );

    if( ( pszToken == NULL ) || !IsHexNumber( pszToken ) )
    {
        return 0;
    }

    //
    //  Verify that the second token is a hex number.
    //

    pszToken = strtok( NULL, pszDelimiters );

    if( ( pszToken == NULL ) || !IsHexNumber( pszToken ) )
    {
        return 0;
    }

    //
    //  The third token must be SECTn (where n is one
    //  or more hex digits).
    //

    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL )
    {
        return 0;
    }

    if( (    _strnicmp( pszToken, pszSect, 4 ) )
          || ! IsHexNumber( pszToken + 4 ) )
    {
        return 0 ;
    }

    //
    //  Next, we have to have "notype"
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL ||
        _stricmp( pszToken, pszNoType ) )
    {
        return 0;
    }

    //
    //  Functions have a () next, data exports don't.
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL )
    {
        return 0;
    }

    if ( strcmp( pszToken, "()" ) != 0 )
    {
        return 0;
    }

    //
    //  Next, we need "External"
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL )
    {
        return 0;
    }

    if( pszToken == NULL ||
        _stricmp( pszToken, pszExternal ) )
    {
        return 0;
    }

    //
    //  Now, the symbol introducer: "|"
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL ||
        _stricmp( pszToken, "|" ) )
    {
        return 0;
    }

    //
    //  Finally, the mangled (decorated) symbol itself.
    //

    pszPotentialSymbol = strtok( NULL, pszDelimiters );

    if( pszPotentialSymbol == NULL )
    {
        return 0;
    }

    //
    // Strip prefix from PowerPC function symbols
    //
    if( _fPowerPC )
    {
        pszPotentialSymbol += 2 ;
    }

    //
    // Strip prefix from IA-64 function symbols
    //
    if( _fIA64 )
    {
        pszPotentialSymbol += 1 ;
    }

    if( strlen( pszPotentialSymbol ) > MAX_SYMBOL )
    {
        fprintf( stderr,
                 _szSymbolTooLong,
                 pszPotentialSymbol );

        return 0;
    }

    //
    //  Got one.
    //

    strcpy( pszSymbol, pszPotentialSymbol );
    return 1;

}   // ExtractSymbol



/*******************************************************************

    NAME:       FatalError and NonFatalError

    SYNOPSIS:   Prints an error message to stderr, then terminates
                the application.

    ENTRY:      err                     - An error code for the exit()
                                          stdlib function.

                pszFmt                  - A format string for vsprintf().

                ...                     - Any other arguments required
                                          by the format string.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/

void __cdecl NonFatalError (
    char * pszFmt,
    ... )
{
    char    szBuffer[MAX_ERROR_MESSAGE+1];
    va_list ArgPtr;

    va_start( ArgPtr, pszFmt );

    fprintf( stderr, "%s => ", _pszProgramName );
    vsprintf( szBuffer, pszFmt, ArgPtr );
    fprintf( stderr, "%s\n", szBuffer );

    va_end( ArgPtr );

}   // NonFatalError

void __cdecl FatalError( int    err,
                 char * pszFmt,
                 ... )
{
    char    szBuffer[MAX_ERROR_MESSAGE+1];
    va_list ArgPtr;

    va_start( ArgPtr, pszFmt );

    fprintf( stderr, "%s => ", _pszProgramName );
    vsprintf( szBuffer, pszFmt, ArgPtr );
    fprintf( stderr, "%s\n", szBuffer );

    va_end( ArgPtr );

    Cleanup();
    exit( err );

}   // FatalError



/*******************************************************************

    NAME:       IsHexNumber

    SYNOPSIS:   Determines if the specified string contains a hexadecimal
                number.

    ENTRY:      pszHexNumber            - The hex number.

    EXIT:       int                     - !0 if it *is* a hex number,
                                           0 if it isn't.

    HISTORY:
        KeithMo     12-Aug-1992 Created.

********************************************************************/
int IsHexNumber( char * pszHexNumber )
{
    int  fResult = 1;
    char ch;

    while( ch = *pszHexNumber++ )
    {
        if( !isxdigit( ch ) )
        {
            fResult = 0;
            break;
        }
    }

    return fResult;

}   // IsHexNumber



/*******************************************************************

    NAME:       NoPath

    SYNOPSIS:   Extracts the filename portion of a path.

    ENTRY:      pszPathName             - Contains a path name.  The name
                                          is not necessarily canonicalized,
                                          and may contain just a filename
                                          component.

    EXIT:       char *                  - The filename component.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/
char * NoPath( char * pszPathName )
{
    char * pszTmp;
    char   ch;

    pszTmp = pszPathName;

    while( ( ch = *pszPathName++ ) != '\0' )
    {
        if( ( ch == '\\' ) || ( ch == ':' ) )
        {
            pszTmp = pszPathName;
        }
    }

    return pszTmp;

}   // NoPath



/*******************************************************************

    NAME:       ProcessCommandLine

    SYNOPSIS:   Parse command line arguments, setting appropriate globals.

    ENTRY:      cArgs                   - Number of command line arguments.

                pArgs                   - An array of pointers to the
                                          command line arguments.

    NOTES:      See the Usage() function for valid command line arguments.

    HISTORY:
        KeithMo     12-Aug-1992 Broke out of main().
        DaveWolfe   06-Jul-1994 Added -ppc.

********************************************************************/
void ProcessCommandLine( int    cArgs,
                         char * pArgs[] )
{
    int  i;
    char chSwitch;

    //
    //  Setup our defaults.
    //

    _fileIn     = stdin;
    _fileOut    = stdout;
    _fileHeader = NULL;

    _fStripLeadingUnderscore = 0;
    _fNukeStdcallDecoration  = 0;
    _fPowerPC                = 0;
    _fIA64                   = 0;

    //
    //  Parse the command line arguments.
    //

    for( i = 1 ; i < cArgs ; i++ )
    {
        //
        //  Get the argument.
        //

        char * pszArg = pArgs[i];
        char * pszParam;

        //
        //  All of our valid arguments *must* start
        //  with a switch character.  Enforce this.
        //

        if( ( *pszArg != '-' ) && ( *pszArg != '/' ) )
        {
            Usage();
        }

        chSwitch = *++pszArg;

        //
        //  pszParam will either be NULL (for switches such
        //  as -s) or point to the text just past the colon
        //  (for switches such as -i:file).
        //

        if( ( pszArg[1] == ':' ) && ( pszArg[2] != '\0' ) )
        {
            pszParam = pszArg + 2;
        }
        else
        {
            pszParam = NULL;
        }

        //
        //  Check for valid arguments.
        //

        switch( chSwitch )
        {
        case 'p' :
        case 'P' :
            //
            //  -ppc
            //
            //  Strip prefix ".." from "..symbol".
            //
            if( _stricmp( pszArg, "ppc") != 0 )
            {
                Usage();
            }

            _fPowerPC = 1;
            break;

        case 'h' :
        case 'H' :
            //
            //  -h:header_file
            //
            //  If a header file has already been specified, or
            //  if there is no parameter after the switch, bag-out.
            //

            if( ( _fileHeader != NULL ) || ( pszParam == NULL ) )
            {
                Usage();
            }

            _fileHeader = fopen( pszParam, "r" );

            if( _fileHeader == NULL )
            {
                FatalError( 1, _szCannotOpenForRead, pszParam );
            }
            break;

        case 'i' :
        case 'I' :

            if (pszParam == NULL) {
                //
                //  -ia64
                //
                //  Strip prefix "." from ".symbol".
                //
                if( _stricmp( pszArg, "ia64") != 0 )
                {
                    Usage();
                }

                _fIA64 = 1;
            } else {

                //
                //  -i:input_file
                //
                //  If an input file has already been specified, or
                //  if there is no parameter after the switch, bag-out.
                //

                if( ( _fileIn != stdin ) || ( pszParam == NULL ) )
                {
                    Usage();
                }

                _fileIn = fopen( pszParam, "r" );

                if( _fileIn == NULL )
                {
                    FatalError( 1, _szCannotOpenForRead, pszParam );
                }
            }
            break;

        case 'o' :
        case 'O' :
            //
            //  -o:output_file
            //
            //  If an output file has already been specified, or
            //  if there is no parameter after the switch, bag-out.
            //

            if( ( _fileOut != stdout ) || ( pszParam == NULL ) )
            {
                Usage();
            }

            _fileOut = fopen( pszParam, "w" );

            if( _fileOut == NULL )
            {
                FatalError( 1, _szCannotOpenForWrite, pszParam );
            }
            break;

        case 's' :
        case 'S' :
            //
            //  -s
            //
            //  If this switch has already been specified, bag-out.
            //

            if( _fStripLeadingUnderscore )
            {
                Usage();
            }

            _fStripLeadingUnderscore = 1;
            break;

        case 'n' :
        case 'N' :
            _fNukeStdcallDecoration = 1 ;
            break ;

        case 'x' :
        case 'X' :
            _pszExclusionListFile = pszParam ;
            break ;

        case '?' :
            //
            //  -?
            //
            //  Give the poor user a clue.
            //

            Usage();
            break;

        default :
            //
            //  Invalid switch.
            //
            //  Tell the user the bad news, then bag-out.
            //

            fprintf( stderr, _szInvalidSwitch, chSwitch );
            Usage();
            break;
        }
    }

}   // ProcessCommandLine



/*******************************************************************

    NAME:       StripStdcallDecoration

    SYNOPSIS:   Stdcall builds use a weak form of type-safe linkage.
                This is implemented by appending "@nn" to the end
                of each symbol, where "nn" is the number of *bytes*
                passed as parameters.

                COFF, on the other hand, does *not* want to see
                this symbol decoration in .DEF files.  So, we remove
                it here.

    ENTRY:      pszSymbol               - The symbol to munge.

    NOTES:      This routine is *NOT* DBCS safe!  Do we care?

    HISTORY:
        KeithMo     14-Sep-1992 Created.

********************************************************************/
void StripStdcallDecoration( char * pszSymbol )
{
    int count = 0 ;

    //
    //  Find the last character.
    //

    pszSymbol += strlen( pszSymbol ) - 1;

    //
    //  Skip any *decimal* numbers.
    //

    while( isdigit( *pszSymbol ) )
    {
        pszSymbol--;
        count++ ;
    }

    //
    //  If we're now pointing at a "@", terminate the string here.
    //

    if( count && *pszSymbol == '@' )
    {
        *pszSymbol = '\0';
    }

}   // StripStdcallDecoration



/*******************************************************************

    NAME:       Usage

    SYNOPSIS:   Displays usage information if the user gives us a
                bogus command line.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

        DaveWolfe   06-Jul-1994 Added -ppc option.

********************************************************************/
void Usage( void )
{
    fprintf( stderr, "use: %s [options]\n", _pszProgramName );
    fprintf( stderr, "\n" );
    fprintf( stderr, "Valid options are:\n" );
    fprintf( stderr, "    -i:input_file  = source file\n" );
    fprintf( stderr, "    -o:output_file = destination file\n" );
    fprintf( stderr, "    -h:header_file = header to prepend before symbols\n" );
    fprintf( stderr, "    -s             = strip first leading underscore from symbols\n" );
    fprintf( stderr, "    -n             = do not strip __stdcall decoration @nn\n" );
    fprintf( stderr, "    -x:excl_file   = name of file containing excluded symbols\n" );
    fprintf( stderr, "    -ppc           = input is PowerPC symbol dump\n" );
    fprintf( stderr, "    -ia64          = input is IA-64 symbol dump\n" );
    fprintf( stderr, "    -?             = show this help\n" );
    fprintf( stderr, "\n" );
    fprintf( stderr, "Defaults are:\n" );
    fprintf( stderr, "    input_file  = stdin\n" );
    fprintf( stderr, "    output_file = stdout\n" );
    fprintf( stderr, "    header_file = none\n" );
    fprintf( stderr, "    don't strip first leading underscore from symbol\n" );
    fprintf( stderr, "    input is not PowerPC symbol dump\n" );

    Cleanup();
    exit( 1 );

}   // Usage


/*******************************************************************

    NAME:       CreateExclusionList

    SYNOPSIS:   Reads a text file of excluded export names into memory,
                sorts it and builds a lookup table compatible with
                bsearch().

                Returns -1 if failure or the count of the number
                of items in the created array.

    HISTORY:

********************************************************************/

int __cdecl qsortStrings ( const void * pa, const void * pb )
{
    return strcmp( *((const char * *) pa), *((const char * *) pb) ) ;
}

int CreateExclusionList ( char * pszFileName,
                          void * * pvData,
                          char * * * apszStrings )
{
    int cItems, i ;
    int result = -1 ;
    long cbFileSize, cbBlockSize ;
    char * pszData = NULL,
         * psz,
         * pszNext ;

    char * * ppszArray = NULL ;

    char chRec [ MAX_LINE_FROM_COFF ] ;

    FILE * pf = NULL ;

    do
    {
        pf = fopen( pszFileName, "r" ) ;

        if ( pf == NULL )
            break;

        if (fseek( pf, 0, SEEK_END ) == -1) 
            break;
        cbFileSize = ftell( pf ) ;
        if (fseek( pf, 0, SEEK_SET ) == -1)
            break;

        cbBlockSize = cbFileSize + (cbFileSize / 2) ;

        pszData = (char *) malloc( cbBlockSize ) ;

        if ( pszData == NULL )
            break ;

        for ( cItems = 0, pszNext = pszData ;
              (!feof( pf )) && (psz = fgets( chRec, sizeof chRec, pf )) ; )
        {
            int lgt ;
            char * pszEnd ;

            while ( *psz <= ' ' && *psz != 0 )
            {
                psz++ ;
            }

            if ( (lgt = strlen( psz )) == 0 )
                continue ;

            pszEnd = psz + lgt ;

            do
            {
               --pszEnd ;
            } while ( pszEnd > psz && *pszEnd <= ' ' ) ;

            lgt = (int)(++pszEnd - psz) ;
            *pszEnd = 0 ;

            if ( pszNext + lgt - pszData >= cbBlockSize )
            {
                cItems = -1 ;
                break ;
            }

            strcpy( pszNext, psz ) ;
            pszNext += lgt+1 ;
            cItems++ ;
        }

        *pszNext = 0 ;

        if ( cItems <= 0 )
        {
            if ( cItems == 0 )
                result = 0 ;
            break ;
        }

        ppszArray = (char * *) malloc( cItems * sizeof (char *) ) ;
        if ( ppszArray == NULL )
            break ;

        for ( i = 0, pszNext = pszData ;
              *pszNext ;
              pszNext += strlen( pszNext ) + 1 )
        {
            ppszArray[i++] = pszNext ;
        }

        qsort( (void *) ppszArray,
               cItems,
               sizeof (char *),
               & qsortStrings ) ;

        result = cItems ;

    } while ( 0 ) ;

    if ( pf != NULL )
    {
        fclose( pf ) ;
    }

    if ( result <= 0 )
    {
        if ( pszData )
        {
            free( pszData ) ;
            pszData = NULL ;
        }
        if ( ppszArray )
        {
            free( ppszArray ) ;
            ppszArray = NULL ;
        }
    }

    *pvData = (void *) pszData ;
    *apszStrings = ppszArray ;

    return result ;
}

int ExcludedSymbol ( char * pszSymbol )
{
    if ( _apszExclusionArray == NULL )
    {
        return 0 ;
    }

    return bsearch( (void *) & pszSymbol,
                    (void *) _apszExclusionArray,
                    _cExclusionItems,
                    sizeof (char *),
                    & qsortStrings ) != NULL ;
}

int ValidSymbol ( const char * psz )
{
    int i = 0 ;

    for ( ; apszIgnore[i] ; i++ )
    {
        if ( _strnicmp( apszIgnore[i],
                        psz,
                        strlen( apszIgnore[i] ) ) == 0 )
            return 0 ;
    }
    return 1 ;
}

// End of UIXPORT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\tztool\tztool.c ===
/*
TZTool - Thermal Zone Information Tool
tztool.c
This the MAIN TZTool - C file.

Copyright (c) 1999 Microsoft Corporation

Module Name:

   TZTool - TZTool.c

Abstract:

   TZTool - Thermal Zone Information Tool

Author:

   Vincent Geglia (VincentG)

Notes:

Revision History:

    1.0 - Original version


*/

// Includes

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntpoapi.h>
#include <commctrl.h>
#include "resource.h"
#include "wmium.h"

// Definitions

#define THERMAL_ZONE_GUID               {0xa1bc18c0, 0xa7c8, 0x11d1, {0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10} }
#define COOLING_PASSIVE                 0
#define COOLING_ACTIVE                  1
#define COOLING_UPDATE_TZONE            2
#define TIMER_ID                        1
#define TIMER_POLL_INTERVAL             500
#define MAX_ACTIVE_COOLING_LEVELS       10
#define MAX_THERMAL_ZONES               10

#define K_TO_F(_deg_) (((_deg_) - 2731) * 9 / 5 + 320)

GUID ThermalZoneGuid = THERMAL_ZONE_GUID;

// Structures

typedef struct _THERMAL_INFORMATION {
    ULONG           ThermalStamp;
    ULONG           ThermalConstant1;
    ULONG           ThermalConstant2;
    KAFFINITY       Processors;
    ULONG           SamplingPeriod;
    ULONG           CurrentTemperature;
    ULONG           PassiveTripPoint;
    ULONG           CriticalTripPoint;
    UCHAR           ActiveTripPointCount;
    ULONG           ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
} THERMAL_INFORMATION, *PTHERMAL_INFORMATION;

typedef struct _TZONE_INFO {

    THERMAL_INFORMATION ThermalInfo;
    ULONG64 TimeStamp;
    ULONG TZoneIndex;
    UCHAR TZoneName[100];
} TZONE_INFO, *PTZONE_INFO;

// Global variables

PTZONE_INFO g_TZonePtr = 0;
WMIHANDLE   g_WmiHandle;
INT         g_PollTz = 0;
BOOL        g_Fahrenheit = FALSE;

// Function declarations

INT WINAPI
WinMain (
        IN HINSTANCE hInstance,
        IN HINSTANCE hPrevInstance,
        IN PSTR CmdLine,
        IN INT CmdShow
        );

INT_PTR CALLBACK
TZoneDlgProc (
             IN HWND wnd,
             IN UINT Msg,
             IN WPARAM wParam,
             IN LPARAM lParam
             );

ULONG
UpdateTZoneData (
                IN OUT PTZONE_INFO ReturnedTZoneInfo,
                IN WMIHANDLE *Handle
                );

ULONG64
SystemTimeToUlong (
                  IN LPSYSTEMTIME SysTime
                  );

VOID
SetCoolingMode (
               IN UCHAR Mode
               );

VOID
UpgradePrivileges (
                  VOID
                  );

VOID
UpdateTZoneListBox (
                   IN HANDLE wnd
                   );

VOID
UpdateTZoneDetails (
                   IN HANDLE wnd
                   );

VOID
UpdateTZoneGauge (
                 IN HANDLE wnd
                 );

VOID
UpdateCPUGauge(
    IN HWND hwnd
    );

/*++

Routine Description:

    Windows application Entry Point

Arguments:

    <standard winmain arguments>

Return Value:

    0 if successful, otherwise error status

--*/

INT WINAPI
WinMain (
        IN HINSTANCE hInstance,
        IN HINSTANCE hPrevInstance,
        IN PSTR CmdLine,
        IN INT CmdShow
        )

{

    UCHAR text [200];
    INITCOMMONCONTROLSEX CommonCtl;
    TZONE_INFO TZones [MAX_THERMAL_ZONES];
    ULONG status = 0;


    // Initialize TZ structures

    ZeroMemory (&TZones, sizeof (TZones));
    g_TZonePtr = (PTZONE_INFO) &TZones;

    // Initialize Common Controls DLL for gauge control

    CommonCtl.dwSize = sizeof (CommonCtl);
    CommonCtl.dwICC = ICC_PROGRESS_CLASS;

    InitCommonControlsEx (&CommonCtl);

    // Open WMI data source for the TZs

    status = WmiOpenBlock ((LPGUID) &ThermalZoneGuid,
                           GENERIC_READ,
                           &g_WmiHandle);

    if (status != ERROR_SUCCESS) {

        sprintf (text,
                 "Unable to open thermal zone GUIDs.  This computer may not be equipped with thermal zones, or may not be in ACPI mode.\nError: %d",
                 status);

        MessageBox (NULL,
                    text,
                    "Fatal Error",
                    MB_ICONERROR | MB_OK);

        return status;
    }

    // In order to change the policies, we need greater access privileges

    UpgradePrivileges ();

    // Show the main dialog box

    DialogBox (hInstance,
               MAKEINTRESOURCE (IDD_TZDLG),
               NULL,
               TZoneDlgProc);

    return 0;
}

/*++

Routine Description:

    Standard Windows Dialog Message Loop

Arguments:

    <standard dialog message loop arguments>

Return Value:

    FALSE if message not handled, TRUE if message handled

--*/

INT_PTR CALLBACK
TZoneDlgProc (
             IN HWND wnd,
             IN UINT Msg,
             IN WPARAM wParam,
             IN LPARAM lParam
             )
{
    ULONG Count = 0;
    LRESULT RetVal = 0;
    switch (Msg) {

    case WM_TIMER:

        if (g_PollTz) {
            SetCoolingMode (COOLING_UPDATE_TZONE);
        }

        if (UpdateTZoneData (g_TZonePtr, g_WmiHandle)) {
            UpdateTZoneDetails (wnd);
            UpdateTZoneGauge (wnd);
        }
        UpdateCPUGauge(wnd);
        return TRUE;

    case WM_INITDIALOG:

        // Fill TZ structure with initial values

        UpdateTZoneData (g_TZonePtr, g_WmiHandle);

        // Initialize all controls

        UpdateTZoneListBox (wnd);
        UpdateTZoneDetails (wnd);
        UpdateTZoneGauge (wnd);
        UpdateCPUGauge(wnd);

        // Initialize polling timer

        SetTimer (wnd,
                  TIMER_ID,
                  TIMER_POLL_INTERVAL,
                  NULL);

        // Set gauge colors

        SendDlgItemMessage (wnd,
                            IDC_TZTEMP1,
                            PBM_SETBARCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x0000FF));

        SendDlgItemMessage (wnd,
                            IDC_TZTEMP1,
                            PBM_SETBKCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x000000));

        SendDlgItemMessage (wnd,
                            IDC_THROTTLE,
                            PBM_SETBARCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x0000FF));

        SendDlgItemMessage (wnd,
                            IDC_THROTTLE,
                            PBM_SETBKCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x000000));


        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {


        // Cleanup and exit

        case IDOK:
            KillTimer (wnd, TIMER_ID);
            EndDialog (wnd, 0);
            return TRUE;

            // Check to see if user selected a new TZ

        case IDC_TZSELECT:
            if (HIWORD (wParam) == CBN_SELCHANGE) {
                UpdateTZoneDetails (wnd);
                UpdateTZoneGauge (wnd);
                return TRUE;
            }

        case IDC_POLLTZ:

            // Check to see if user changed the TZ Polling setting

            if (HIWORD (wParam) == BN_CLICKED) {

                RetVal = SendDlgItemMessage (wnd,
                                             IDC_POLLTZ,
                                             BM_GETCHECK,
                                             (WPARAM)0,
                                             (LPARAM)0);

                if (!g_PollTz && RetVal == BST_CHECKED) {
                    g_PollTz = TRUE;
                }

                if (g_PollTz && RetVal == BST_UNCHECKED) {
                    g_PollTz = FALSE;
                }
            }
            break;

        case IDC_FAHR:

            // Check to see if user changed the Fahrenheit setting

            if (HIWORD(wParam) == BN_CLICKED) {
                RetVal = SendDlgItemMessage(wnd,
                                            IDC_FAHR,
                                            BM_GETCHECK,
                                            0,
                                            0);
                if (!g_Fahrenheit && RetVal == BST_CHECKED) {
                    g_Fahrenheit = TRUE;
                    SetDlgItemText(wnd, IDC_MINTEMP, "37F");
                    UpdateTZoneDetails(wnd);
                    UpdateTZoneGauge(wnd);
                } else if (g_Fahrenheit && RetVal == BST_UNCHECKED) {
                    g_Fahrenheit = FALSE;
                    SetDlgItemText(wnd, IDC_MINTEMP, "276K");
                    UpdateTZoneDetails(wnd);
                    UpdateTZoneGauge(wnd);
                }
            }


        default:
            break;

        }

    default:
        break;

    }

    return 0;
}

/*++

Routine Description:

    Issue WMI call to update TZ structures

Arguments:

    ReturnedTZoneInfo - Pointer to array of TZ structures
    Handle - Handle to WMI

Return Value:

    FALSE if no TZs were updated, TRUE if one or more TZs have an update

--*/

ULONG
UpdateTZoneData (
                IN OUT PTZONE_INFO ReturnedTZoneInfo,
                IN WMIHANDLE *Handle
                )
{
    ULONG status = 0;
    ULONG BufferSize = 0;
    PWNODE_ALL_DATA WmiAllData;
    PTHERMAL_INFORMATION ThermalInfo;
    ULONG Offset = 0;
    UCHAR *AllDataBuffer = 0;
    UCHAR *InstanceName = 0;
    ULONG TZCount = 0;
    ULONG Temp = 0;
    SYSTEMTIME SysTime;
    BOOL Updated = FALSE;

    status = WmiQueryAllData (Handle,
                              &BufferSize,
                              0);

    if (status != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    AllDataBuffer = malloc (BufferSize);

    if (!AllDataBuffer) {

        return FALSE;

    }

    status = WmiQueryAllData (Handle,
                              &BufferSize,
                              AllDataBuffer);

    if (status != ERROR_SUCCESS) {
        free (AllDataBuffer);
        return FALSE;
    }

    // BUG BUG Assuming Thermal GUID only has one instance

    while (TZCount < MAX_THERMAL_ZONES) {

        WmiAllData = (PWNODE_ALL_DATA) AllDataBuffer;

        if (WmiAllData->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE) {

            ThermalInfo = (PTHERMAL_INFORMATION) &AllDataBuffer[WmiAllData->DataBlockOffset];
        } else {

            ThermalInfo = (PTHERMAL_INFORMATION) &AllDataBuffer[WmiAllData->OffsetInstanceDataAndLength[0].OffsetInstanceData];
        }

        Offset = (ULONG) AllDataBuffer[WmiAllData->OffsetInstanceNameOffsets];

        InstanceName = (UCHAR *) &AllDataBuffer[Offset + 2];

        // Update TZone structure if timestamp has changed

        if (!ReturnedTZoneInfo[TZCount].TZoneIndex || (ThermalInfo->ThermalStamp != ReturnedTZoneInfo[TZCount].ThermalInfo.ThermalStamp)) {

            strcpy (ReturnedTZoneInfo[TZCount].TZoneName, InstanceName);
            GetSystemTime (&SysTime);
            ReturnedTZoneInfo[TZCount].TimeStamp = SystemTimeToUlong (&SysTime);
            ReturnedTZoneInfo[TZCount].TZoneIndex = TZCount + 1;
            memcpy (&ReturnedTZoneInfo[TZCount].ThermalInfo,
                    ThermalInfo,
                    sizeof (THERMAL_INFORMATION));
            Updated = TRUE;
        }

        if (!WmiAllData->WnodeHeader.Linkage) {

            break;
        }

        AllDataBuffer += WmiAllData->WnodeHeader.Linkage;

        TZCount ++;
    }

    free (AllDataBuffer);

    return Updated;
}

/*++

Routine Description:

    Convert a system time structure to a 64bit ULONG

Arguments:

    SysTime - Pointer to system time structure to compare against current time

Return Value:

    Number of elapsed seconds between SysTime and current time

--*/

ULONG64
SystemTimeToUlong (
                  IN LPSYSTEMTIME SysTime
                  )

{
    ULONG64 TimeCount = 0;

    // BUG BUG Doesn't account for leap year

    TimeCount += SysTime->wYear * 31536000;
    TimeCount += SysTime->wMonth * 2628000;
    TimeCount += SysTime->wDay * 86400;
    TimeCount += SysTime->wHour * 3600;
    TimeCount += SysTime->wMinute * 60;
    TimeCount += SysTime->wSecond;

    return TimeCount;
}

/*++

Routine Description:

    Sets the cooling mode to ACTIVE, PASSIVE, or UPDATE ONLY.  This is accomplished by
    changing the FanThrottleTolerance value in the power policy.  Setting it to maxthrottle
    effectively puts the system into PASSIVE cooling mode.  Setting it to 100% will put
    the system in ACTIVE cooling mode UNLESS the current temperature exceeds the passive
    cooling trip points.

Arguments:

    Mode - Value to select the new cooling mode

Return Value:

    None

--*/

VOID
SetCoolingMode (
               IN UCHAR Mode
               )

{
    SYSTEM_POWER_POLICY SysPolicy;
    ULONG Status = 0;
    UCHAR TempFanThrottleTolerance = 0;

    // BUG BUG - This mechanism will currently only for while the machine is on AC.

    Status = NtPowerInformation(
                               SystemPowerPolicyAc,
                               0,
                               0,
                               &SysPolicy,
                               sizeof (SysPolicy)
                               );

    if (Status != ERROR_SUCCESS) {

        return;
    }

    switch (Mode) {

    case COOLING_PASSIVE:
        SysPolicy.FanThrottleTolerance = SysPolicy.MinThrottle;
        break;

    case COOLING_ACTIVE:
        SysPolicy.FanThrottleTolerance = 100;
        break;

    case COOLING_UPDATE_TZONE:
        TempFanThrottleTolerance = SysPolicy.FanThrottleTolerance;
        SysPolicy.FanThrottleTolerance = SysPolicy.FanThrottleTolerance != SysPolicy.MinThrottle ? SysPolicy.MinThrottle : 100;
        break;

    default:
        return;
    }

    Status = NtPowerInformation(
                               SystemPowerPolicyAc,
                               &SysPolicy,
                               sizeof (SysPolicy),
                               &SysPolicy,
                               sizeof (SysPolicy)
                               );

    if (Status != ERROR_SUCCESS) {

        return;
    }

    if (Mode == COOLING_UPDATE_TZONE) {

        SysPolicy.FanThrottleTolerance = TempFanThrottleTolerance;

        Status = NtPowerInformation(
                                   SystemPowerPolicyAc,
                                   &SysPolicy,
                                   sizeof (SysPolicy),
                                   &SysPolicy,
                                   sizeof (SysPolicy)
                                   );

        if (Status != ERROR_SUCCESS) {

            return;
        }
    }

}

/*++

Routine Description:

    Upgrades the process's access permission to change system power policy

Arguments:

    None

Return Value:

    None

--*/


VOID
UpgradePrivileges (
                  VOID
                  )
{
    TOKEN_PRIVILEGES tkp;
    HANDLE hToken;

    OpenProcessToken (GetCurrentProcess(),
                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                      &hToken);

    LookupPrivilegeValue (NULL,
                          SE_SHUTDOWN_NAME,
                          &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (hToken,
                           FALSE,
                           &tkp,
                           0,
                           NULL,
                           0);

}

/*++

Routine Description:

    Updates the entries presented in the TZ selection combo box

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/


VOID
UpdateTZoneListBox (
                   IN HANDLE wnd
                   )

{
    ULONG Count = 0;

    // Reset the contents

    SendDlgItemMessage (wnd,
                        IDC_TZSELECT,
                        CB_RESETCONTENT,
                        0,
                        0);

    while (Count < MAX_THERMAL_ZONES) {

        if (g_TZonePtr[Count].TZoneIndex) {

            SendDlgItemMessage (wnd,
                                IDC_TZSELECT,
                                CB_ADDSTRING,
                                0,
                                (LPARAM) g_TZonePtr[Count].TZoneName);
        } else {

            break;
        }

        Count ++;
    }

    // Automatically select first TZone

    SendDlgItemMessage (wnd,
                        IDC_TZSELECT,
                        CB_SETCURSEL,
                        0,
                        0);

}

/*++

Routine Description:

    Updates the details for the currently selected TZ

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/

VOID
UpdateTZoneDetails (
                   IN HANDLE wnd
                   )
{
    UCHAR text[1000], texttmp [1000];
    UCHAR CurrentTZone = 0;
    LRESULT RetVal = 0;
    UCHAR Count = 0;
    ULONG Fahrenheit;

    RetVal = SendDlgItemMessage (wnd,
                                 IDC_TZSELECT,
                                 CB_GETCURSEL,
                                 0,
                                 0);

    if (RetVal == CB_ERR) {

        return;
    }

    if (g_Fahrenheit) {
        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint);
        sprintf (text,
                 "Passive Trip Point:\t%d.%dF\nThermal Constant 1:\t%d\nThermal Constant 2:\t%d",
                 Fahrenheit / 10,
                 Fahrenheit % 10,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant1,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant2);

    } else {
        sprintf (text,
                 "Passive Trip Point:\t%d.%dK\nThermal Constant 1:\t%d\nThermal Constant 2:\t%d",
                 g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint / 10,
                 g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint % 10,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant1,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant2);
    }

    SetDlgItemText (wnd,
                    IDC_PSVDETAILS,
                    text);

    ZeroMemory (&text, sizeof (text));

    while (Count < g_TZonePtr[RetVal].ThermalInfo.ActiveTripPointCount) {
        if (g_Fahrenheit) {
            Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count]);
            sprintf (texttmp,
                     "Active Trip Point #%d:\t%d.%dF\n",
                     Count,
                     Fahrenheit / 10,
                     Fahrenheit % 10);
        } else {
            sprintf (texttmp,
                     "Active Trip Point #%d:\t%d.%dK\n",
                     Count,
                     g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count] / 10,
                     g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count] % 10);
        }

        strcat (text, texttmp);
        Count ++;
    }

    SetDlgItemText (wnd,
                    IDC_ACXDETAILS,
                    text);

}

/*++

Routine Description:

    Updates the progress bar control (temp gauge) for the currently selected TZ

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/

VOID
UpdateTZoneGauge (
                 IN HANDLE wnd
                 )

{
    UCHAR CurrentTZone = 0;
    LRESULT RetVal = 0;
    UCHAR text[20];
    ULONG Fahrenheit;

    RetVal = SendDlgItemMessage (wnd,
                                 IDC_TZSELECT,
                                 CB_GETCURSEL,
                                 0,
                                 0);

    if (RetVal == CB_ERR) {

        return;
    }

    if (g_Fahrenheit) {

        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint);
        sprintf (text,
                 "%d.%dF",
                 Fahrenheit / 10,
                 Fahrenheit % 10);

    } else {
        sprintf (text,
                 "%d.%dK",
                 g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint / 10,
                 g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint % 10);
    }

    SetDlgItemText (wnd,
                    IDC_CRTTEMP,
                    text);

    if (g_Fahrenheit) {

        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature);
        sprintf (text,
                 "Current: %d.%dF",
                 Fahrenheit / 10,
                 Fahrenheit % 10);

    } else {
        sprintf (text,
                 "Current: %d.%dK",
                 g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature / 10,
                 g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature % 10);

    }
    SetDlgItemText (wnd,
                    IDC_CURTEMP,
                    text);

    SendDlgItemMessage (wnd,
                        IDC_TZTEMP1,
                        PBM_SETRANGE,
                        0,
                        MAKELPARAM(2760, g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint));

    SendDlgItemMessage (wnd,
                        IDC_TZTEMP1,
                        PBM_SETPOS,
                        (INT) g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature,
                        0);
    return;
}


VOID
UpdateCPUGauge(
    IN HWND hwnd
    )
/*++

Routine Description:

    Updates the current CPU throttling gauge

Arguments:

    hwnd - Supplies the parent dialog hwnd

Return Value:

    None

--*/

{
    PROCESSOR_POWER_INFORMATION ProcInfo;
    NTSTATUS Status;
    UCHAR text[40];

    Status = NtPowerInformation(ProcessorInformation,
                                NULL,
                                0,
                                &ProcInfo,
                                sizeof(ProcInfo));
    if (NT_SUCCESS(Status)) {
        sprintf(text, "%d MHz", ProcInfo.MaxMhz);
        SetDlgItemText(hwnd, IDC_MAXTHROTTLE, text);

        sprintf(text,
                "Current %d MHz (%d %%)",
                ProcInfo.CurrentMhz,
                ProcInfo.CurrentMhz*100/ProcInfo.MaxMhz);
        SetDlgItemText(hwnd, IDC_CURTHROTTLE, text);

        //
        // update throttle gauge
        //
        SendDlgItemMessage (hwnd,
                            IDC_THROTTLE,
                            PBM_SETRANGE,
                            0,
                            MAKELPARAM(0, ProcInfo.MaxMhz));

        SendDlgItemMessage (hwnd,
                            IDC_THROTTLE,
                            PBM_SETPOS,
                            (INT) ProcInfo.CurrentMhz,
                            0);

        //
        // update idle information
        //
        sprintf(text, "C%d", ProcInfo.MaxIdleState);
        SetDlgItemText(hwnd, IDC_MAXIDLE, text);

        //
        // The current idle state reporting ranges from 0-2
        // the max idle state reporting ranges from 1-3
        // probably current is wrong and should be 0-3 representing C0-C3
        // for now add one and don't run this on an MP machine!
        //
        sprintf(text, "C%d", ProcInfo.CurrentIdleState + 1);
        SetDlgItemText(hwnd, IDC_CURIDLE, text);

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\units\unittab.c ===
#include <stdio.h>

//
// From wingnut
//

char *UnitTab[] = {
"/ dimensions                                   ",
"meter                  *a*                     ",
"kg                     *b*                     ",
"sec                    *c*                     ",
"coul                   *d*                     ",
"candela                *e*                     ",
"dollar                 *f*                     ",
"radian                 *g*                     ",
"bit                    *h*                     ",
"erlang                 *i*                     ",
"degC                   *j*                     ",
"                                               ",
"/ constants                                    ",
"                                               ",
"fuzz                   1                       ",
"pi                     3.14159265358979323846  ",
"c                      2.997925+8 m/sec fuzz   ",
"g                      9.80665 m/sec2          ",
"au                     1.49597871+11 m fuzz    ",
"mole                   6.022169+23 fuzz        ",
"e                      1.6021917-19 coul fuzz  ",
"energy                 c2                      ",
"force                  g                       ",
"mercury                1.33322+5 kg/m2-sec2    ",
"hg                     mercury                 ",
"                                               ",
"/ dimensionless                                ",
"                                               ",
"degree                 1|180 pi-radian         ",
"circle                 2 pi-radian             ",
"turn                   2 pi-radian             ",
"grade                  .9 degree               ",
"arcdeg                 1 degree                ",
"arcmin                 1|60 arcdeg             ",
"ccs                    1|36 erlang             ",
"arcsec                 1|60 arcmin             ",
"                                               ",
"steradian              radian2                 ",
"sphere                 4 pi-steradian          ",
"sr                     steradian               ",
"                                               ",
"/ Time                                         ",
"                                               ",
"second                 sec                     ",
"s                      sec                     ",
"minute                 60 sec                  ",
"min                    minute                  ",
"hour                   60 min                  ",
"hr                     hour                    ",
"day                    24 hr                   ",
"da                     day                     ",
"week                   7 day                   ",
"year                   365.24219879 day fuzz   ",
"yr                     year                    ",
"month                  1|12 year               ",
"ms                     millisec                ",
"us                     microsec                ",
"                                               ",
"/ Mass                                         ",
"                                               ",
"gram                   millikg                 ",
"gm                     gram                    ",
"mg                     milligram               ",
"metricton              kilokg                  ",
"                                               ",
"/ Avoirdupois                                  ",
"                                               ",
"lb                     .45359237 kg            ",
"lbf                    lb g                    ",
"ounce                  1|16 lb                 ",
"oz                     ounce                   ",
"dram                   1|16 oz                 ",
"dr                     dram                    ",
"grain                  1|7000 lb               ",
"gr                     grain                   ",
"shortton               2000 lb                 ",
"ton                    shortton                ",
"longton                2240 lb                 ",
"                                               ",
"/ Apothecary                                   ",
"                                               ",
"scruple                20 grain                ",
"apdram                 60 grain                ",
"apounce                480 grain               ",
"appound                5760 grain              ",
"                                               ",
"/ Length                                       ",
"                                               ",
"m                      meter                   ",
"cm                     centimeter              ",
"mm                     millimeter              ",
"km                     kilometer               ",
"nm                     nanometer               ",
"micron                 micrometer              ",
"angstrom               decinanometer           ",
"                                               ",
"inch                   2.54 cm                 ",
"in                     inch                    ",
"foot                   12 in                   ",
"feet                   foot                    ",
"ft                     foot                    ",
"yard                   3 ft                    ",
"yd                     yard                    ",
"rod                    5.5 yd                  ",
"rd                     rod                     ",
"mile                   5280 ft                 ",
"mi                     mile                    ",
"                                               ",
"british                1200|3937 m/ft          ",
"nmile                  1852m                   ",
"                                               ",
"acre                   4840 yd2                ",
"                                               ",
"cc                     cm3                     ",
"liter                  kilocc                  ",
"ml                     milliliter              ",
"                                               ",
"/ US Liquid                                    ",
"                                               ",
"gallon                 231 in3                 ",
"imperial               1.20095                 ",
"gal                    gallon                  ",
"quart                  1|4 gal                 ",
"qt                     quart                   ",
"pint                   1|2 qt                  ",
"pt                     pint                    ",
"                                               ",
"floz                   1|16 pt                 ",
"fldr                   1|8 floz                ",
"                                               ",
"/ US Dry                                       ",
"                                               ",
"dry                    268.8025 in3/gallon fuzz",
"peck                   8 dry-quart             ",
"pk                     peck                    ",
"bushel                 4 peck                  ",
"bu                     bushel                  ",
"                                               ",
"/ British                                      ",
"                                               ",
"brgallon               277.420 in3 fuzz        ",
"brquart                1|4 brgallon            ",
"brpint                 1|2 brquart             ",
"brfloz                 1|20 brpint             ",
"brpeck                 554.84 in3 fuzz         ",
"brbushel               4 brpeck                ",
"                                               ",
"/ Energy Work                                  ",
"                                               ",
"newton                 kg-m/sec2               ",
"nt                     newton                  ",
"joule                  nt-m                    ",
"cal                    4.1868 joule            ",
"                                               ",
"/ Electrical                                   ",
"                                               ",
"coulomb                coul                    ",
"ampere                 coul/sec                ",
"amp                    ampere                  ",
"watt                   joule/sec               ",
"volt                   watt/amp                ",
"ohm                    volt/amp                ",
"mho                    /ohm                    ",
"farad                  coul/volt               ",
"henry                  sec2/farad              ",
"weber                  volt-sec                ",
"                                               ",
"/ Light                                        ",
"                                               ",
"cd                     candela                 ",
"lumen                  cd sr                   ",
"lux                    cd sr/m2                ",
"                                               ",
"/ Money                                        ",
"/ epoch April 28, 1994 wall st j               ",
"                                               ",
"$                       dollar                 ",
"britainpound           1.5135  $               ",
"canadadollar            .72322 $               ",
"francefranc             .17545 $               ",
"japanyen                .00987 $               ",
"mexicopeso              .30581 $               ",
"netherlandsguilder      .53576 $               ",
"switzerlandfranc        .70822 $               ",
"germanymark             .60158 $               ",
#if 0       // 1977 - might as well not be here
"/ epoch May 18, 1977 wall st j                  ",
"argentinapeso           .0030 $                ",
"australiadollar        1.1065 $                ",
"austriaschilling        .0597 $                ",
"belgiumfranc            .0277 $                ",
"brazilcruzeiro          .0733 $                ",
"britainpound           1.7187 $                ",
"canadadollar            .9550 $                ",
"colombiapeso            .0276 $                ",
"denmarkkrone            .1663 $                ",
"equadorsucre            .0365 $                ",
"finlandmarkka           .2456 $                ",
"francefranc             .2021 $                ",
"greecedrachma           .0272 $                ",
"hongkongdollar          .2134 $                ",
"indiarupee              .1145 $                ",
"indonesiarupiah         .00259 $               ",
"iranrial                .0143 $                ",
"iraqdinar              3.41 $                  ",
"israelpound             .1105 $                ",
"italylira               .001130 $              ",
"japanyen                .003607 $              ",
"lebanonpound            .3285 $                ",
"malaysiadollar          .4032 $                ",
"mexicopeso              .0445 $                ",
"netherlandsguilder      .4080 $                ",
"newzealanddollar        .9665 $                ",
"norwaykrone             .1899 $                ",
"pakistanrupee           .1025 $                ",
"perusol                 .0129 $                ",
"phillippinespeso        .1345 $                ",
"portugalescudo          .0259 $                ",
"saudiarabiariyal        .2860 $                ",
"singaporedollar         .4061 $                ",
"southafricarand        1.1522 $                ",
"southkoreawon           .0021 $                ",
"spainpeseta             .01451 $               ",
"swedenkrona             .2296 $                ",
"switzerlandfranc        .3970 $                ",
"thailandbhat            .050 $                 ",
"uruguaypeso             .2330 $                ",
"venezuelabolivar        .2335 $                ",
"germanymark             .4243 $                ",
"                                               ",
"bolivar                venezuelabolivar        ",
"peseta                 spainpeseta             ",
"rand                   southafricarand         ",
"escudo                 portugalescudo          ",
"sol                    perusol                 ",
"dinar                  iraqdinar               ",
"rial                   iranrial                ",
"rupee                  indiarupee              ",
"drachma                greecedrachma           ",
"markka                 finlandmarkka           ",
"sucre                  equadorsucre            ",
"cruzeiro               brazilcruzeiro          ",
#endif
"                                               ",
"mark                   germanymark             ",
"guilder                netherlandsguilder      ",
"peso                   mexicopeso              ",
"yen                    japanyen                ",
"lira                   italylira               ",
"franc                  francefranc             ",
"pound                  britainpound            ",
"poundsterling          britainpound            ",
"                                               ",
"/ Trivia                                       ",
"                                               ",
"%                      1|100                   ",
"admiraltyknot          6080 ft/hr              ",
"apostilb               cd/pi-m2                ",
"are                    1+2 m2                  ",
"arpentcan              27.52 mi                ",
"arpentlin              191.835 ft              ",
"astronomicalunit       au                      ",
"atmosphere             1.01325+5 nt/m2         ",
"atm                    atmosphere              ",
"atomicmassunit         1.66044-27 kg fuzz      ",
"amu                    atomicmassunit          ",
"bag                    94 lb                   ",
"bakersdozen            13                      ",
"bar                    1+5 nt/m2               ",
"barie                  1-1 nt/m2               ",
"barleycorn             1|3 in                  ",
"barn                   1-28 m2                 ",
"barrel                 42 gal                  ",
"barye                  1-1 nt/m2               ",
"bev                    1+9 e-volt              ",
"biot                   10 amp                  ",
"blondel                cd/pi-m2                ",
"boardfoot              144 in3                 ",
"bolt                   40 yd                   ",
"bottommeasure          1|40 in                 ",
"britishthermalunit     1.05506+3 joule fuzz    ",
"btu                    britishthermalunit      ",
"refrigeration          12000 btu/ton-hour      ",
"buck                   dollar                  ",
"cable                  720 ft                  ",
"caliber                1-2 in                  ",
"calorie                cal                     ",
"carat                  205 mg                  ",
"cent                   centidollar             ",
"cental                 100 lb                  ",
"centesimalminute       1-2 grade               ",
"centesimalsecond       1-4 grade               ",
"century                100 year                ",
"cfs                    ft3/sec                 ",
"chain                  66 ft                   ",
"circularinch           1|4 pi-in2              ",
"circularmil            1-6|4 pi-in2            ",
"clusec                 1-8 mm-hg m3/s          ",
"coomb                  4 bu                    ",
"cord                   128 ft3                 ",
"cordfoot               cord                    ",
"crith                  9.06-2 gm               ",
"cubit                  18 in                   ",
"cup                    1|2 pt                  ",
"curie                  3.7+10 /sec             ",
"dalton                 amu                     ",
"decade                 10 yr                   ",
"dipotre                /m                      ",
"displacementton        35 ft3                  ",
"doppelzentner          100 kg                  ",
"dozen                  12                      ",
"drop                   .03 cm3                 ",
"dyne                   cm-gm/sec2              ",
"electronvolt           e-volt                  ",
"ell                    45 in                   ",
"engineerschain         100 ft                  ",
"engineerslink          100|100 ft              ",
"equivalentfootcandle   lumen/pi-ft2            ",
"equivalentlux          lumen/pi-m2             ",
"equivalentphot         cd/pi-cm2               ",
"erg                    cm2-gm/sec2             ",
"ev                     e-volt                  ",
"faraday                9.652+4 coul            ",
"fathom                 6 ft                    ",
"fermi                  1-15 m                  ",
"fifth                  4|5 qt                  ",
"fin                    5 dollar                ",
"finger                 7|8 in                  ",
"firkin                 9 gal                   ",
"footcandle             lumen/ft2               ",
"footlambert            cd/pi-ft2               ",
"fortnight              14 da                   ",
"franklin               3.33564-10 coul         ",
"frigorie               kilocal                 ",
"furlong                220 yd                  ",
"galileo                1-2 m/sec2              ",
"gamma                  1-9 weber/m2            ",
"gauss                  1-4 weber/m2            ",
"geodeticfoot           british-ft              ",
"geographicalmile       1852 m                  ",
"gilbert                7.95775-1 amp           ",
"gill                   1|4 pt                  ",
"gross                  144                     ",
"gunterschain           22 yd                   ",
"hand                   4 in                    ",
"hectare                1+4 m2                  ",
"hefnercandle           .92 cd                  ",
"hertz                  /sec                    ",
"hogshead               2 barrel                ",
"hd                     hogshead                ",
"homestead              1|4 mi2                 ",
"horsepower             550 ft-lb-g/sec         ",
"hp                     horsepower              ",
"hyl                    gm force sec2/m         ",
"hz                     /sec                    ",
"imaginarycubicfoot     1.4 ft3                 ",
"jeroboam               4|5 gal                 ",
"karat                  1|24                    ",
"kcal                   kilocal                 ",
"kcalorie               kilocal                 ",
"kev                    1+3 e-volt              ",
"key                    kg                      ",
"khz                    1+3 /sec                ",
"kilderkin              18 gal                  ",
"knot                   nmile/hr                ",
"lambert                cd/pi-cm2               ",
"langley                cal/cm2                 ",
"last                   80 bu                   ",
"league                 3 mi                    ",
"lightyear              c-yr                    ",
"line                   1|12 in                 ",
"link                   66|100 ft               ",
"longhundredweight      112 lb                  ",
"longquarter            28 lb                   ",
"lusec                  1-6 mm-hg m3/s          ",
"mach                   331.46 m/sec            ",
"magnum                 2 qt                    ",
"marineleague           3 nmile                 ",
"maxwell                1-8 weber               ",
"metriccarat            200 mg                  ",
"mev                    1+6 e-volt              ",
"mgd                    megagal/day             ",
"mh                     millihenry              ",
"mhz                    1+6 /sec                ",
"mil                    1-2 in                  ",
"millenium              1000 year               ",
"minersinch             1.5 ft3/min             ",
"minim                  1|60 fldr               ",
"mo                     month                   ",
"mpg                    mile/gal                ",
"mph                    mile/hr                 ",
"nail                   1|16 yd                 ",
"nauticalmile           nmile                   ",
"nit                    cd/m2                   ",
"noggin                 1|8 qt                  ",
"nox                    1-3 lux                 ",
"ns                     nanosec                 ",
"nttime                 100 nanosec             ",
"oersted                2.5+2 pi-amp/m          ",
"oe                     oersted                 ",
"pace                   36 in                   ",
"palm                   3 in                    ",
"parasang               3.5 mi                  ",
"parsec                 au-radian/arcsec        ",
"pascal                 nt/m2                   ",
"pc                     parsec                  ",
"pennyweight            1|20 oz                 ",
"percent                %                       ",
"perch                  rd                      ",
"pf                     picofarad               ",
"phot                   lumen/cm2               ",
"pica                   1|6 in                  ",
"pieze                  1+3 nt/m2               ",
"pipe                   4 barrel                ",
"point                  1|72 in                 ",
"poise                  gm/cm-sec               ",
"pole                   rd                      ",
"poundal                ft-lb/sec2              ",
"pdl                    poundal                 ",
"proof                  1|200                   ",
"psi                    lb-g/in2                ",
"quarter                9 in                    ",
"quartersection         1|4 mi2                 ",
"quintal                100 kg                  ",
"quire                  25                      ",
"rad                    100 erg/gm              ",
"ream                   500                     ",
"registerton            100 ft3                 ",
"rehoboam               156 floz                ",
"rhe                    10 m2/nt-sec            ",
"rontgen                2.58-4 curie/kg         ",
"rood                   1.21+3 yd               ",
"rope                   20 ft                   ",
"rutherford             1+6 /sec                ",
"rydberg                1.36054+1 ev            ",
"sabin                  1 ft2                   ",
"sack                   3 bu                    ",
"seam                   8 bu                    ",
"section                mi2                     ",
"shippington            40 ft3                  ",
"shorthundredweight     100 lb                  ",
"shortquarter           25 lb                   ",
"siemens                /ohm                    ",
"sigma                  microsec                ",
"skein                  120 yd                  ",
"skot                   1-3 apostilb            ",
"slug                   lb-g-sec2/ft            ",
"span                   9 in                    ",
"spat                   4 pi sr                 ",
"spindle                14400 yd                ",
"square                 100 ft2                 ",
"stere                  m3                      ",
"sthene                 1+3 nt                  ",
"stilb                  cd/cm2                  ",
"stoke                  1-4 m2/sec              ",
"stone                  14 lb                   ",
"strike                 2 bu                    ",
"surveyfoot             british-ft              ",
"surveyorschain         66 ft                   ",
"surveyorslink          66|100 ft               ",
"tablespoon             4 fldr                  ",
"teaspoon               4|3 fldr                ",
"tesla                  weber/m2                ",
"therm                  1+5 btu                 ",
"thermie                1+6 cal                 ",
"timberfoot             ft3                     ",
"tnt                    4.6+6 m2/sec2           ",
"tonne                  1+6 gm                  ",
"torr                   mm hg                   ",
"township               36 mi2                  ",
"tun                    8 barrel                ",
"water                  .22491|2.54 kg/m2-sec2  ",
"wey                    40 bu                   ",
"weymass                252 lb                  ",
"Xunit                  1.00202-13m             ",
"k                      1.38047-16 erg/degC     ",
"                                               ",
"/ Computer                                     ",
"                                               ",
"byte                   8 bit                   ",
"word                   2 byte                  ",
"dword                  4 byte                  ",
"qword                  8 byte                  ",
"quadword               qword                   ",
"paragraph              16 byte                 ",
"kilobyte               1024 byte               ",
"kb                     kilobyte                ",
"megabyte               1024 kb                 ",
"mb                     megabyte                ",
"gigabyte               1024 mb                 ",
"gb                     gigabyte                ",
"terabyte               1024 gb                 ",
"tb                     terabyte                ",
NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\undel\undel.c ===
/*** UNDEL.C -  retrieve deleted files if possible ***************************
*
*       Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
* Purpose:
*  The three tools EXP, RM and UNDEL are used to delete files so
*  that they can be undeleted.  This is done my renaming the file into
*  a hidden directory called DELETED.
*
* Notes:
*  This tool allows the user to view a list of the files that have been
*  'deleted' from the current directory, and to undelete a file from
*  the list.
*
*  To view a list of undeleted files:  UNDEL
*
*  To undelete a file:  UNDEL filename [filename ...]
*
*  If more than one file by that name has been deleted, a list of the
*  deletions, by date, will be presented and the user prompted to
*  choose one.
*
*  If a file by that name exists currently, it is RM'ed before the
*  deleted file is restored.
*
* Revision History:
*  17-Oct-1990 w-barry Temporarily replaced 'rename' with 'rename_NT' until
*                      DosMove completely implemented on NT.
*  29-Jun-1990 SB Do not do index conversion if file is readonly ...
*  29-Jun-1990 SB print filename only once if one instance is to be undel'ed
*  08-Feb-1990 bw Do index file conversion in dump()
*  07-Feb-1990 bw Third arg to readNewIdxRec
*  08-Jan-1990 SB SLM version upgrading added; Add CopyRightYrs Macro
*  03-Jan-1990 SB define QH_TOPIC_NOT_FOUND
*  28-Dec-1989 SB Add #ifdef BEAUTIFY stuff
*  27-Dec-1989 SB Changes for new index file format
*  15-Dec-1989 SB Include os2.h instead of doscalls.h
*                 Qh return code 3 means 'Topic not Found'
*  14-Dec-1989 LN Update Copyright to include 1990
*  23-Oct-1989 LN Version no bumped to 1.01
*  02-Oct-1989 LN Changed Version no to 1.00
*  08-Aug-1989 bw Add Version number, update copyright
*  15-May-1989 wb Add /help
*  24-Jan-1989 bw Use C runtime rename() so fastcopy doesn't get dragged in.
*  30-Oct-1987 bw Changed 'DOS5' to 'OS2'
*  06-Apr-1987 bw Add Usage prompt for /<anything>
*  18-Oct-1990 w-barry Removed 'dead' code.
*  28-Nov-1990 w-barry Switched to Win32 API - Replaced DosQueryFSInfo() with
*                      GetDiskFreeSpace in the Dump() routine.
*
******************************************************************************/

/* I N C L U D E    Files */

#include <sys\types.h>
#include <sys\stat.h>
#include <dos.h>
#include <errno.h>
#include <fcntl.h>
#include <malloc.h>
#include <process.h>
#include <io.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>
#include <rm.h>

/* D E F I N E s */

#define CopyRightYrs "1987-90"
/* Need 2 steps, first to get correct values in and 2nd to paste them */
/* paste() is hacked to allow LEADING  ZEROES    */
#define paste(a, b, c) #a ".0" #b ".00" #c
#define VERSION(major, minor, buildno) paste(major, minor, buildno)
#define QH_TOPIC_NOT_FOUND 3

// Forward Function Declarations...
void       Usage( void );
void       dump( void );
void       undel( char * );
flagType   getRecord( int, int, char * );
long       pfile( char * );


/***  main - Entry point
*
* Usage:
*
*   See above
*
*************************************************************************/

__cdecl main(c, v)
int c;
char *v[];
{
    register char *p;

    ConvertAppToOem( c, v );
    SHIFT(c,v);
    if (!c)
        dump();
    else
        if (fSwitChr(**v)) {
            p = *v;
            if (!_strcmpi(++p, "help")) {
                int iRetCode = (int) _spawnlp(P_WAIT, "qh.exe", "qh", "/u",
                                        "undel.exe", NULL);
                /* for Return Code QH_TOPIC_NOT_FOUND do Usage(),
                 *   and -1 means that the spawn failed
                 */
                if (iRetCode != QH_TOPIC_NOT_FOUND && iRetCode != -1)
                    exit(0);
            }
            Usage();
        }
        while (c) {
            undel(*v);
            SHIFT(c,v);
        }
    return(0);
}


/*** pfile - Display the size and date of a file
*
* Purpose:
*
*   This is used to generate a list of files.  It displays one
*   line of list output.
*
* Input:
*   p -  File to list
*
* Output:
*
*   Returns Size of the file, or 0L if it does not exist.
*
*************************************************************************/

long pfile(p)
char *p;
{
    struct _stat sbuf;

    if (_stat(p, &sbuf)) {
        printf("%s %s\n", p, error());
        return 0L;
    }
    else {
        char *t = ctime(&sbuf.st_mtime);
        // This NULLs the \n in string returned by ctime()
        *(t+24) = '\0';
        printf("%8ld %s", sbuf.st_size, t);
        return sbuf.st_size;
    }
}


/*** getRecord - Get one file's worth of into from the index file
*
* Purpose:
*
*   A proper DELETED directory has a file called 'index' that holds a
*   list of the files that the directory contains.  This is necessary
*   because the files are named DELETED.XXX.  This function reads the
*   next file record from 'index'.
*
* Input:
*   fh - Handle of index file.
*   i  - Number of record to _read from index file
*   p  - Target buffer to place record.
*
* Output:
*
*   Returns TRUE if record _read, FALSE otherwise.
*
* Notes:
*
*   Assumes NEW format.
*
*************************************************************************/

flagType getRecord(fh, i, p)
int fh, i;
char *p;
{
    /* UNDONE: Can read the index file to a table of longs and use
     * UNDONE: this. Current stuff is to make it work [SB]
     */

    /* Seek to the beginning of the index file, past the header */
    if (_lseek(fh, (long) RM_RECLEN, SEEK_SET) == -1) {
        return FALSE;
    }
    /* Read (i - 1) records */
    if (i < 0)
        return TRUE;
    for (; i ; i--)
        if (!readNewIdxRec(fh, p, MAX_PATH))
            return FALSE;
    /* Read in the ith record, which is the one we need */
    return( (flagType)readNewIdxRec(fh, p, MAX_PATH) );
}


/*** undel - Do all the work for one file.
*
* Purpose:
*
*   Undeletes one file.
*
* Input:
*   p - Name of file
*
* Output: None
*
*************************************************************************/

void undel(p)
char *p;
{
    int fhidx,                                /* Index file handle */
        iEntry,                               /* Entry no in index file */
        iDelCount,                            /* No of times RMed */
        iDelIndex,                            /* deleted.xxx index value */
        i, j;
    char *buf, *idx;
    char *szLongName;
    char rec[RM_RECLEN];
    char *dbuf;

    buf = malloc(MAX_PATH);
    idx = malloc(MAX_PATH);
    dbuf = malloc(MAX_PATH);
    szLongName = malloc(MAX_PATH);

    pname(p);
    fileext(p, buf);
    upd(p, RM_DIR, idx);
    strcpy(szLongName, idx);
    strcat(idx, "\\");
    strcat(idx, RM_IDX);

    if ((fhidx = _open(idx, O_RDWR | O_BINARY)) == -1)
        printf("not deleted\n");
    else {
        convertIdxFile(fhidx, szLongName);
        /* scan and count number of instances deleted */
        iEntry = -1;
        iDelCount = 0;
        while (getRecord(fhidx, ++iEntry, szLongName))
            if (!_strcmpi(szLongName, buf)) {
                /* Save found entry */
                i = iEntry;
                iDelCount++;
                iDelIndex = (_lseek(fhidx, 0L, SEEK_CUR)
                             - strlen(szLongName)) / RM_RECLEN;
            }
        /* none found */
        if (iDelCount == 0)
            printf("not deleted\n");
        else {
            if (iDelCount == 1)
                iEntry = i;
            /* More than one deleted */
            else {
                printf("%s  More than one are deleted:\n\n", szLongName);
                i = iDelIndex = 0;
                iEntry = -1;
                printf("No     Size Timestamp\n\n");
                while (getRecord(fhidx, ++iEntry, szLongName))
                    if (!_strcmpi(szLongName, buf)) {
                        iDelIndex = (_lseek(fhidx, 0L, SEEK_CUR)
                                    - strlen(szLongName)) / RM_RECLEN;
                        sprintf(dbuf, "deleted.%03x", iDelIndex);
                        upd(idx, dbuf, dbuf);
                        printf("%2d ", ++i);
                        pfile(dbuf);
                        printf("\n");
                }
                while (TRUE) {
                    printf("\nEnter number to undelete(1-%d): ", iDelCount);
                    fgetl(szLongName, 80, stdin);
                    i = atoi(szLongName)-1;
                    if (i >= 0 && i < iDelCount)
                        break;
                }
                iEntry = -1;
                j = 0;
                while (getRecord(fhidx, ++iEntry, szLongName))
                    if (!_strcmpi(szLongName, buf))
                        if (j++ == i)
                            break;
                iDelIndex = (_lseek(fhidx, 0L, SEEK_CUR)
                             - strlen(szLongName)) / RM_RECLEN;
            }
            /* At this stage relevant entry is (iEntry)
             * and this corresponds to ('deleted.%03x', iDelIndex)
             */
            getRecord(fhidx, iEntry, szLongName);
            _close(fhidx);
            fdelete(p);
            printf("%s\t", szLongName);
            fflush(stdout);
            sprintf(dbuf, "deleted.%03x", iDelIndex);
            upd(idx, dbuf, dbuf);

            if (rename(dbuf, p))
                printf(" rename failed - %s\n", error());
            else {
                printf("[OK]\n");
                if ((fhidx = _open(idx, O_RDWR | O_BINARY)) != -1) {
                    long lOffPrev,        /* Offset of Previous Entry */
                         lOff;            /* Offset of current entry  */

                    getRecord(fhidx, iEntry, szLongName);
                    lOff = _lseek(fhidx, 0L, SEEK_CUR);
                    getRecord(fhidx, iEntry - 1, szLongName);
                    lOffPrev = _lseek(fhidx, 0L, SEEK_CUR);
                    for (;lOffPrev != lOff; lOffPrev += RM_RECLEN) {
                        memset((char far *)rec, 0, RM_RECLEN);
                        writeIdxRec(fhidx, rec);
                    }
                }
            }
        }
        _close(fhidx);
    }
}


/*** dump - display info about DELETED directory
*
* Purpose:
*
*   Displays info contained in INDEX file
*
* Input: None
*
* Output: None
*
*************************************************************************/

void dump()
{
    int fhidx, i;
    char *buf = (*tools_alloc)(MAX_PATH);
    char *idx = (*tools_alloc)(MAX_PATH);
    char *szName = (*tools_alloc)(MAX_PATH);
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    int totfiles;
    long totbytes, totalloc, bPerA, l;

    sprintf(idx, "%s\\%s", RM_DIR, RM_IDX);
    sprintf (szName, "%s", RM_DIR);

    if( !GetDiskFreeSpace( NULL, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        printf(" file system query failed - %s\n", error());
    }
    bPerA = cBytesPerSec * cSecsPerClus;

    if ((fhidx = _open(idx, O_RDWR | O_BINARY)) != -1) {
        convertIdxFile(fhidx, szName);
        totalloc = totbytes = 0L;
        totfiles = 0;
        i = 0;
        while (getRecord(fhidx, i++, buf))
            if (*buf) {
                if (i == 1)
                    printf("The following have been deleted:\n\n    Size Timestamp\t\t   Filename\n\n");
#ifdef BEAUTIFY
                    //Or optionally
                    printf("    size wdy mmm dd hh:mm:ss yyyy  filename\n\n");
#endif
                strcpy(szName, buf);
                sprintf(buf, "deleted.%03x", (_lseek(fhidx, 0L, SEEK_CUR)
                        - strlen(buf)) / RM_RECLEN);
                upd(idx, buf, buf);
                totbytes += (l = pfile(buf));
                printf("  %s\n", szName);
                l = l + bPerA - 1;
                l = l / bPerA;
                l = l * bPerA;
                totalloc += l;
                totfiles++;
            }
        _close(fhidx);
        printf("\n%ld(%ld) bytes in %d deleted files\n", totalloc, totbytes, totfiles);
    }
    // Maybe the file is readonly
    else if (errno == EACCES) {
        if ((fhidx = _open(idx, O_RDONLY | O_BINARY)) != -1) {
            // Cannot convert Index file for this case
            totalloc = totbytes = 0L;
            totfiles = 0;
            i = 0;
            while (getRecord(fhidx, i++, buf))
                if (*buf) {
                    if (i == 1)
                        printf("The following have been deleted:\n\n    Size Timestamp\t\t   Filename\n\n");
#ifdef BEAUTIFY
                        //Or optionally
                        printf("    size wdy mmm dd hh:mm:ss yyyy  filename\n\n");
#endif
                    strcpy(szName, buf);
                    sprintf(buf, "deleted.%03x", (_lseek(fhidx, 0L, SEEK_CUR)
                        - strlen(buf)) / RM_RECLEN);
                    upd(idx, buf, buf);
                    totbytes += (l = pfile(buf));
                    printf("  %s\n", szName);
                    l = l + bPerA - 1;
                    l = l / bPerA;
                    l = l * bPerA;
                    totalloc += l;
                    totfiles++;
                }
            _close(fhidx);
            printf("\n%ld(%ld) bytes in %d deleted files\n", totalloc, totbytes, totfiles);
        }
    }
    free(buf);
    free(idx);
    free(szName);
}


/*** Usage - standard usage function; help user
*
* Purpose:
*
*   The usual.
*
*************************************************************************/

void Usage()
{
    printf(
"Microsoft File Undelete Utility.  Version %s\n"
"Copyright (C) Microsoft Corp %s. All rights reserved.\n\n"
"Usage: UNDEL [/help] [files]\n",
    VERSION(rmj, rmm, rup), CopyRightYrs);

    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\units\units.c ===
#include <windows.h>
#include <stdio.h>
#include <signal.h>
#include <float.h>
#include <time.h>
#include <malloc.h>
#include <stdlib.h>
#include <math.h>

static char Name[] = "Ken Reneris. Units ala Unix style";



#define DBL     double
#define MAXTYPE 5

extern  UCHAR *UnitTab[];
UCHAR   token[] = " \t\n";

typedef struct _UNIT {
    struct _UNIT    *Next;

    PSZ             UnitName;
    PSZ             Conversion;
} UNIT, *PUNIT;

PUNIT       UnitList;
BOOLEAN     Muund;

typedef struct _HALFVALUE {
    DBL         Accum;

    ULONG       NoType;
    struct {
        PUNIT       Unit;
        ULONG       Pow;
    } Type [MAXTYPE];

} HALFVALUE, *PHALFVALUE;

typedef struct _FULLVALUE {
    ULONG       Fuzz;
    HALFVALUE   Nom;
    HALFVALUE   Dom;
} FULLVALUE, *PFULLVALUE;

struct {
    PSZ         Prefix;
    ULONG       stringlen;
    DBL         Scaler;
} BuiltInScalers[] = {
    "giga",     4, 1000000000.0,
    "mega",     4,    1000000.0,
    "kilo",     4,       1000.0,
    "centi",    5,          0.01,
    "milli",    5,          0.001,
    "micro",    5,          0.000001,
    "nano",     4,          0.000000001,
    "decinano", 8,          0.0000000001,
    NULL
};

struct {
    PSZ         BaseType;
    PSZ         DefaultDump;
} BuiltInDumps[] = {
    "sec",   "hour second millisec microsec nttime nanosec",
    "bit",   "terabyte gigabyte megabyte kilobyte dword byte bit",
    "meter", "km meter cm mm micron mile feet yard inch",
    "kg",    "kb gram kilokg milligram ton lb ounce dram",
    NULL
};

#define ASSERT(_exp_)   if (_exp_) { AssertFailed (__FILE__, __LINE__); }



PVOID   zalloc (IN ULONG len);
PSZ     StrDup (IN PSZ String);
VOID    ReadUnitTab (VOID);
PUNIT   LookupUnit (PSZ UnitName);
VOID    DumpValue (IN PFULLVALUE Value);
VOID    InitializeValue (IN PFULLVALUE Value);
VOID    ConvertValue (PFULLVALUE, PSZ, PFULLVALUE, PSZ);
BOOLEAN ProcessString (PUNIT, PSZ, PFULLVALUE);
PSZ     CopyUnitName (PSZ Out, PSZ String);
PSZ     CopyWord (PSZ Out, PSZ String);
PSZ     SkipSpace (PSZ String);
BOOLEAN MatchPattern (PUCHAR String, PUCHAR Pattern);
VOID    ReduceTypes (IN OUT PHALFVALUE MValue, IN OUT PHALFVALUE DValue);
VOID    AddTypes (IN OUT PHALFVALUE Dest, IN PHALFVALUE Child);
BOOLEAN DumpMatchingTypes (PSZ Str);
VOID    GetInput (PSZ Desc, PSZ Str);
VOID    AssertFailed (PSZ FileName, ULONG LineNo);


void __cdecl main(int argc, char **argv)
{
    UCHAR       have[80], want[80], want2[200];
    FULLVALUE   hValue, wValue;
    PSZ         p;
    ULONG       i;

    ReadUnitTab ();

    if (argc > 1) {
        //
        // Arguments on the command line.  Argv[1] is "have"
        //

        argv++;
        argc -= 2;
        strcpy (have, *(argv++));

        if (DumpMatchingTypes (have)) {
            exit (0);
        }

        if (!ProcessString (NULL, have, &hValue)) {
            printf ("Usage: Units [have] [want]\n");
            exit   (1);
        }

        //
        // If no Argv[2], then check for default dump
        //

        if (!argc  &&  hValue.Nom.NoType) {
            for (i=0; BuiltInDumps[i].BaseType; i++) {
                if (strcmp (BuiltInDumps[i].BaseType, hValue.Nom.Type[0].Unit->UnitName) == 0) {

                    //
                    // Dump defaults
                    //

                    p = BuiltInDumps[i].DefaultDump;
                    while (*p) {
                        p = CopyWord(want, p);

                        if (ProcessString (NULL, want, &wValue)) {
                            ConvertValue (&hValue, have, &wValue, want);
                        }
                    }
                    break;
                }
            }
        }

        //
        // Dump argv[2..n]
        //

        for ( ; argc; argc--, argv++) {
            if (!ProcessString (NULL, *argv, &wValue)) {
                exit (1);
            }

            ConvertValue (&hValue, have, &wValue, *argv);
        }

        exit (1);
    }

    //
    // Interactive... ask "have" & "want"
    //

    for (; ;) {
        for (; ;) {
            GetInput ("You have: ", have);
            if (ProcessString (NULL, have, &hValue)) {
                break;
            }
        }

        GetInput ("You want: ", want2);
        p = want2;
        do {
            p = CopyWord (want, p);

            if (ProcessString (NULL, want, &wValue)) {
                ConvertValue (&hValue, have, &wValue, want);
            }
        } while (*p);
        printf ("\n");
    }

    return ;
}

VOID
GetInput (
    PSZ     Desc,
    PSZ     Str
    )
{
    for (; ;) {
        printf (Desc);
        if (!gets(Str)) {
            exit(1);
        }
        _strlwr (Str);

        if (strcmp (Str, "q") == 0) {
            exit (1);
        }

        if (!DumpMatchingTypes (Str)) {
            break;
        }
    }
}

BOOLEAN DumpMatchingTypes (PSZ Str)
{
    PSZ         Title, Line;
    ULONG       LineNo;
    UCHAR       UnitName[80];
    BOOLEAN     DumpTitle;

    if (!strchr (Str, '*') && !strchr (Str, '?')  && !strchr(Str, '[')) {
        return FALSE;
    }

    //
    // Dump matching known unitnames
    //

    printf ("\nKnown types/groups matching: %s\n", Str);
    Title = NULL;
    for (LineNo = 0; UnitTab[LineNo]; LineNo++) {
        Line = UnitTab[LineNo];
        if (Line[0] == '/') {
            Title = Line;
            DumpTitle = MatchPattern (Title, Str);
        }

        CopyUnitName (UnitName, Line);
        if (!UnitName[0]) {
            continue;
        }

        if (MatchPattern (UnitName, Str) || DumpTitle) {
            if (Title) {
                printf ("%s\n", Title);
                Title = NULL;
            }
            printf ("    %s\n", Line);

        }
    }
    printf ("\n");
    return TRUE;
}



PSZ SkipSpace (PSZ String)
{
    while (*String && (*String == ' ' ||  *String < ' ' ||  *String == '^')) {
        String ++;
    }

    return String;
}

PSZ CopyNumber (PSZ Out, PSZ String)
{
    while (*String >= '0' && *String <= '9' || *String == '.') {
        *(Out++) = *(String++);
    }

    *Out = 0;
    return String;
}

PSZ CopyWord (PSZ Out, PSZ String)
{
    UCHAR   c;

    while (*String) {
        if (*String <= ' ') {
            break;
        }

        *(Out++) = *(String++);
    }

    *Out = 0;
    return SkipSpace (String);
}



PSZ CopyUnitName (PSZ Out, PSZ String)
{
    UCHAR   c;

    while (c = *String) {
        if (c >= '0'  &&  c <= '9'  ||  c == '.') {
            break;
        }

        if (c == '-'  ||  c == '+'  ||  c == '/'  ||  c == ' ') {
            break;
        }

        if (c == '^'  ||  c < ' ') {
            String++;
            continue;
        }

        *(Out++) = *(String++);
    }

    *Out = 0;
    return String;
}


VOID
AssertFailed (PSZ FileName, ULONG LineNo)
{
    printf ("Assert failed - file %s line %d\n", FileName, LineNo);
    exit (1);
}


PSZ
GetBaseType (
    IN PSZ          Out,
    IN PHALFVALUE   HValue
    )
{
    ULONG       i;

    if (HValue->NoType == 0) {
        Out += sprintf (Out, "constant");
    } else {
        for (i=0; i < HValue->NoType; i++) {
            Out += sprintf (Out, "%s%s", i ? "-" : "", HValue->Type[i].Unit->UnitName);
            if (HValue->Type[i].Pow != 1) {
                Out += sprintf (Out, "^%d", HValue->Type[i].Pow);
            }
        }
    }
    return Out;
}

VOID
GetBaseTypes (
    OUT PSZ     Out,
    IN PFULLVALUE   Value
    )
/**
 *  Returns ascii dump of values data type
 */
{
    PUNIT   Unit;
    ULONG   i;

    Out = GetBaseType (Out, &Value->Nom);

    if (Value->Dom.NoType) {
        Out += sprintf (Out, "/");
        Out  = GetBaseType (Out, &Value->Dom);
    }
}

VOID
DumpValue (
    IN PFULLVALUE   Value
    )
{
    UCHAR   s[80];

    GetBaseTypes (s, Value);
    printf ("%g/%g type %s\n", Value->Nom.Accum, Value->Dom.Accum, s);
}

VOID
SortType (
    IN PHALFVALUE   Value
    )
{
    ULONG   i, j;
    ULONG   hpow;
    PUNIT   hunit;


    //
    // Sort by lowest power, then alphabetical
    //

    for (i=0; i < Value->NoType; i++) {
        for (j=i+1; j < Value->NoType; j++) {
            if (Value->Type[i].Pow > Value->Type[j].Pow ||
               (Value->Type[i].Pow == Value->Type[j].Pow  &&
                strcmp (Value->Type[i].Unit->UnitName, Value->Type[j].Unit->UnitName) > 0)) {

                // swap
                hpow  = Value->Type[i].Pow;
                hunit = Value->Type[i].Unit;
                Value->Type[i].Pow  = Value->Type[j].Pow;
                Value->Type[i].Unit = Value->Type[j].Unit;
                Value->Type[j].Pow  = hpow;
                Value->Type[j].Unit = hunit;
            }
        }
    }
}


VOID
FormatDbl (
    OUT PSZ     s,
    IN  DBL     Value
    )
/**
 * Function to print double "Value" into string "s".  This
 * functions sole purpose is to get a better readable reresentation
 * of the value into ascii
 */
{
    PSZ     p1, p2, dp;
    UCHAR   t[80];
    LONG    i;

    i = 18 - sprintf (t, "%.1f", Value);
    if (i < 0) {
        i = 0;
    }
    sprintf (t, "%.*f", i, Value);

    //
    // strip off trailing zeros
    //

    for (dp=t; *dp; dp++) {
        if (*dp == '.') {
            for (p1=p2=dp+1; *p2; p2++) {
                if (*p2 != '0') {
                    p1 = p2;
                }
            }

            p1[1] = 0;
            if (p1 == dp+1  &&  p1[0] == '0') {
                // it's ".0" remove the whole thing
                *dp = 0;
            }

            break;
        }
    }

    i = (LONG)(dp - t);     // # of digits before decimal point
    i = i % 3;
    if (i == 0) {
        i = 3;
    }

    //
    // Copy to decimal point while adding commas
    //

    for (p1=s, p2=t; *p2 && *p2 != '.'; p2++) {
        if (i-- == 0) {
            *(p1++) = ',';
            i = 2;
        }

        *(p1++) = *p2;
    }

    //
    // Copy remainer
    //

    do {
        *(p1++) = *p2;
    } while (*(p2++));

    //
    // Did result == 0?  Probabily lost precision
    //

    if (strcmp (s, "0") == 0) {
        sprintf (s, "%.18g", Value);
    }
}


VOID
ConvertValue (
    IN PFULLVALUE   hValue,
    IN PSZ      have,
    IN PFULLVALUE   wValue,
    IN PSZ      want
    )
{
    DBL         ans;
    UCHAR       s1[80], s2[80], cf[80];
    FULLVALUE   Junk1, Junk2;
    BOOLEAN     flag;
    DBL         hAccum, wAccum;
    PSZ         p1, p2, p3, p4, p5;

    have   = SkipSpace(have);
    want   = SkipSpace(want);
    hAccum = hValue->Nom.Accum / hValue->Dom.Accum;
    wAccum = wValue->Nom.Accum / wValue->Dom.Accum;
    ans    = hAccum / wAccum;

    p3     = "";
    p5     = NULL;

    //
    // See if types match by checking if they cancle each other out
    //

    Junk1 = *hValue;
    Junk2 = *wValue;
    AddTypes (&Junk1.Nom, &Junk2.Dom);
    AddTypes (&Junk1.Dom, &Junk2.Nom);
    ReduceTypes (&Junk1.Nom, &Junk1.Dom);

    if (Junk1.Nom.NoType + Junk1.Dom.NoType != 0) {

        //
        // See if types are inverse
        //

        Junk1 = *hValue;
        Junk2 = *wValue;
        AddTypes (&Junk1.Nom, &Junk2.Nom);
        AddTypes (&Junk1.Dom, &Junk2.Dom);
        ReduceTypes (&Junk1.Nom, &Junk1.Dom);

        if (Junk1.Nom.NoType + Junk1.Dom.NoType == 0) {

            // inverse result
            ans = 1.0 / (hAccum / (1.0 / wAccum));
            p5  = "Warning";

        } else {

            // types are not conforming
            p5 = "Conformance";
        }
    }

    cf[0] = 0;
    if (p5) {
        SortType (&hValue->Nom);
        SortType (&hValue->Dom);
        SortType (&wValue->Nom);
        SortType (&wValue->Dom);
        GetBaseTypes (s1, hValue);
        GetBaseTypes (s2, wValue);
        sprintf (cf, "    (%s: %s -> %s)", p5, s1, s2);
    }

    FormatDbl (s1, ans);            // fancy
    sprintf (s2, "%.g", ans);       // bland

    p1 = (have[0] >= 'a'  &&  have[0] <= 'z') ? "1" : "";
    p2 = (hValue->Fuzz | wValue->Fuzz) ? "(fuzzy) " : "",
    printf ("    %s%s -> %s %s%s%s%s\n", p1, have, s1, p2, p3, want, cf);

    p4 = strchr (s2, 'e');
    if (p4   &&  !strchr(s1,'e')  &&  atoi(p4+2) > 9) {
        // print bland answer as well
        printf ("    %s%s -> %s %s%s%s%s\n", p1, have, s2, p2, p3, want, cf);
    }
}

BOOLEAN
ProcessString (
    IN PUNIT    Unit,
    IN PSZ      String,
    OUT PFULLVALUE  ReturnValue
    )
{
    UCHAR       s[80], c;
    ULONG       i, j;
    FULLVALUE   ChildValue;
    PHALFVALUE  MValue, DValue, hldvalue;

    ReturnValue->Fuzz = 0;
    MValue = &ReturnValue->Nom;
    DValue = &ReturnValue->Dom;

    MValue->Accum  = 1.0;
    MValue->NoType = 0;

    DValue->Accum  = 1.0;
    DValue->NoType = 0;

    String = SkipSpace(String);
    c = *String;

    if (c == '*') {
        //
        // This is a base value
        //

        MValue->NoType = 1;
        MValue->Type[0].Unit = Unit;
        MValue->Type[0].Pow  = 1;
        return TRUE;
    }

    if (c >= '0' &&  c <= '9'  ||  c == '.') {
        //
        // Constant multiplcation
        //

        String = CopyNumber (s, String);
        String = SkipSpace(String);
        MValue->Accum *= atof(s);
    }

    if (*String == '|') {
        //
        // Constant Division
        //

        String++;
        String = CopyNumber (s, String);
        if (s[0]) {
            DValue->Accum *= atof(s);
        }
    }

    if (*String == '+'  ||  *String == '-') {
        //
        // 10^x
        //

        s[0] = *(String++);
        String = CopyNumber (s+1, String);
        MValue->Accum *= pow (10.0, atof(s));
    }

    for (; ;) {
        String = SkipSpace(String);
        if (!*String) {
            break;
        }

        switch (*String) {
            case '/':
                // flip denominator & numerator
                hldvalue = MValue;
                MValue   = DValue;
                DValue   = hldvalue;
                String++;
                continue;       // get next token

            case '-':
                // skip these
                String++;
                continue;

            default:
                break;
        }

        //
        // Find sub unit type
        //

        String = CopyUnitName (s, String);
        Unit   = LookupUnit (s);
        if (!Unit) {

            //
            // Check for common scaler prefix on keyword
            //

            for (i=0; BuiltInScalers[i].Prefix; i++) {
                if (strncmp (s,
                        BuiltInScalers[i].Prefix,
                        BuiltInScalers[i].stringlen) == 0) {

                    // Scale the value & skip word prefix
                    MValue->Accum *= BuiltInScalers[i].Scaler;
                    Unit = LookupUnit (s + BuiltInScalers[i].stringlen);
                    break;
                }
            }

            if (!Unit) {
                printf ("Unit type '%s' unkown\n", s);
                return FALSE;
            }
        }


        //
        // Get conversion value for this component
        //

        if (!ProcessString (Unit, Unit->Conversion, &ChildValue)) {
            return FALSE;
        }

        if (strcmp (Unit->UnitName, "fuzz") == 0) {
            ReturnValue->Fuzz = 1;
        }

        if (*String >= '1'  &&  *String <= '9') {
            // raise power
            i = *(String++) - '0';

            ChildValue.Nom.Accum = pow (ChildValue.Nom.Accum, i);
            ChildValue.Dom.Accum = pow (ChildValue.Dom.Accum, i);

            for (j=0; j < ChildValue.Nom.NoType; j++) {
                ChildValue.Nom.Type[j].Pow *= i;
            }

            for (j=0; j < ChildValue.Dom.NoType; j++) {
                ChildValue.Dom.Type[i].Pow *= i;
            }
        }

        //
        // Merge values from child
        //

        ReturnValue->Fuzz |= ChildValue.Fuzz;
        MValue->Accum *= ChildValue.Nom.Accum;
        DValue->Accum *= ChildValue.Dom.Accum;

        //
        // Merge data types from child
        //

        AddTypes (MValue, &ChildValue.Nom);
        AddTypes (DValue, &ChildValue.Dom);
        ReduceTypes (MValue, DValue);
    }
    return TRUE;
}


VOID
AddTypes (
    IN OUT PHALFVALUE   Dest,
    IN PHALFVALUE       Child
    )
/**
 *  Add's types from Child to Dest.  If the data type already exist in
 *  dest then it's power is raised; otherwise the new type is added to the list
 *
 */
{
    ULONG   i, j;

    for (i=0; i < Child->NoType; i++) {
        for (j=0; j < Dest->NoType; j++) {
            if (Child->Type[i].Unit == Dest->Type[j].Unit) {
                // unit already is destionation - move it
                Dest->Type[j].Pow  += Child->Type[i].Pow;
                Child->Type[i].Unit = NULL;
                Child->Type[i].Pow  = 0;
            }
        }

        if (Child->Type[i].Unit) {
            // unit not in destionation - add it
            j = (Dest->NoType++);
            ASSERT (j >= MAXTYPE);
            Dest->Type[j].Unit = Child->Type[i].Unit;
            Dest->Type[j].Pow  = Child->Type[i].Pow;
        }
    }
}

VOID
ReduceTypes (
    IN OUT PHALFVALUE   MValue,
    IN OUT PHALFVALUE   DValue
    )
/**
 *  Divides & cancles data types.
 */
{
    ULONG       i, j, k;
    BOOLEAN     Restart;

    Restart = TRUE;
    while (Restart) {
        Restart = FALSE;

        for (i=0; i < MValue->NoType; i++) {
            for (j=0; j < DValue->NoType; j++) {
                if (MValue->Type[i].Unit == DValue->Type[j].Unit) {
                    // matching types - reduce
                    MValue->Type[i].Pow -= DValue->Type[j].Pow;
                    DValue->Type[j].Unit = NULL;
                    DValue->Type[j].Pow  = 0;
                }

                if (DValue->Type[j].Pow == 0) {
                    // pull this type out of the denominator
                    for (k=j+1; k < DValue->NoType; k++) {
                        DValue->Type[k-1] = DValue->Type[k];
                    }
                    DValue->NoType -= 1;
                    Restart = TRUE;
                    continue;
                }
            }

            if (MValue->Type[i].Pow == 0) {
                // pull this type out of the numerator
                for (k=i+1; k < DValue->NoType; k++) {
                    DValue->Type[k-1] = DValue->Type[k];
                }
                MValue->NoType -= 1;
                Restart = TRUE;
                continue;
            }
        }
    }
}



VOID
ReadUnitTab (VOID)
{
    UCHAR       Line[80], s[80];
    ULONG       LineNo;
    PUNIT       Unit;
    PSZ         p, p1;

    for (LineNo = 0; UnitTab[LineNo]; LineNo++) {
        strcpy (Line, UnitTab[LineNo]);

        //
        // Strip off trailing blanks
        //

        for (p=p1=Line; *p; p++) {
            if (*p != ' ') {
                p1 = p;
            }
        }
        p1[1] = 0;

        //
        // First word is type of unit
        //

        p = SkipSpace (Line);
        if (*p == 0  ||  *p == '/') {
            continue;
        }

        p = CopyUnitName (s, p);
        Unit = zalloc (sizeof(UNIT));
        Unit->UnitName = StrDup (s);

        //
        // Rest of line is Conversion string
        //

        p = SkipSpace (p);
        Unit->Conversion = StrDup (p);

        //
        // Add Unit to list of all known units
        //

        Unit->Next = UnitList;
        UnitList = Unit;
    }
}

PUNIT LookupUnit (PSZ UnitName)
{
    PUNIT   Unit;
    UCHAR   Name[40];
    ULONG   i;

    for (i=0; UnitName[i]; i++) {
        Name[i] = UnitName[i];
        if (Name[i] >= '0'  &&  Name[i] <= '9') {
            break;
        }
    }

    Name[i] = 0;
    for (Unit=UnitList; Unit; Unit = Unit->Next) {
        if (strcmp (Unit->UnitName, Name) == 0) {
            break;
        }
    }

    return Unit;
}


PSZ StrDup (IN PSZ String)
{
    ULONG   len;
    PSZ     p;

    // allocate & duplicate string

    len = strlen(String)+1;
    p   = malloc (len);
    if (!p) {
        printf ("Out of memory\n");
        exit (1);
    }

    memcpy (p, String, len);
    return p;
}


PVOID zalloc (IN ULONG len)
{
    PVOID   p;

    // allocate & zero memory

    p = malloc (len);
    if (!p) {
        printf ("Out of memory\n");
        exit (1);
    }

    memset (p, 0, len);
    return p;
}




/*** MatchPattern - check if string matches pattern
 *
 *   Supports:
 *        *      - Matches any number of characters (including zero)
 *        ?      - Matches any 1 character
 *        [set]  - Matches any charater to charater in set
 *                   (set can be a list or range)
 *
 */

BOOLEAN MatchPattern (PUCHAR String, PUCHAR Pattern)
{
    UCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = (UCHAR)tolower(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (tolower(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vdmperf\calcperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Enstrom (marke) 28-Mar-1991

Revision History:

--*/

#ifndef _CALCPERFH_INCLUDED_
#define _CALCPERFH_INCLUDED_

#define MAX_PROCESSOR 8
#define DATA_LIST_LENGTH 100
#define DELAY_SECONDS 2

//
// Hi-Tech macro to figure out how much a field has changed by.
//

#define delta(FLD) (PerfInfo.FLD - PreviousPerfInfo.FLD)

//
// display const
//

#define IX_PUSHF        0
#define IX_POPF         1
#define IX_IRET         2
#define IX_HLT          3
#define IX_CLI          4
#define IX_STI          5
#define IX_BOP          6
#define IX_SEGNOTP      7
#define IX_VDMOPCODEF   8
#define IX_INTNN        9
#define IX_INTO         10
#define IX_INB          11
#define IX_INW          12
#define IX_OUTB         13
#define IX_OUTW         14
#define IX_INSB         15
#define IX_INSW         16
#define IX_OUTSB        17
#define IX_OUTSW        18

#define SAVE_SUBJECTS  19
#define BORDER_WIDTH   2
#define INDENT_WIDTH   8
#define GRAPH_WIDTH    130
#define GRAPH_HEIGHT   40
#define PERF_METER_CPU_CYCLE 10

//
//  time constant for sampling performance
//

#define PERF_TIME_DELAY 1000

//
//  types of display modes
//

#define DISPLAY_MODE_CPU_ONLY   0
#define DISPLAY_MODE_CPU        10
#define DISPLAY_MODE_VM         20
#define DISPLAY_MODE_CACHE      30
#define DISPLAY_MODE_POOL       40
#define DISPLAY_MODE_IO         50
#define DISPLAY_MODE_LPC        60
#define DISPLAY_MODE_SVR        70

//
// structure to save screen statistics
//

typedef struct _CPU_DATA_LIST
{
    PUCHAR   KernelTime;
    PUCHAR   UserTime;
    PUCHAR   TotalTime;
} CPU_DATA_LIST,*PCPU_DATA_LIST;



typedef struct _PERF_DATA_LIST
{
    PULONG  PerfData;
} PERF_DATA_LIST,*PPERF_DATA_LIST;

//
//  This info packet is associated with each
//  performance item
//

typedef struct tagDISPLAYITEM
{
    HDC     MemoryDC;
    HBITMAP MemoryBitmap;
    ULONG   Max;
    ULONG   PositionX;
    ULONG   PositionY;
    ULONG   Width;
    ULONG   Height;
    ULONG   NumberOfElements;
    ULONG   CurrentDrawingPos;
    RECT    Border;
    RECT    GraphBorder;
    RECT    TextBorder;
    BOOL    Display;
    BOOL    ChangeScale;
    ULONG   KernelTime[DATA_LIST_LENGTH];
    ULONG   UserTime[DATA_LIST_LENGTH];
    ULONG   TotalTime[DATA_LIST_LENGTH];
} DISPLAY_ITEM,*PDISPLAY_ITEM;

//
// flag to activate each menu selection
//

#define DISPLAY_INACTIVE 0
#define DISPLAY_ACTIVE   1


//
//  Keep book-keeping info for all processors
//

typedef struct _CPU_VALUE
{
        LARGE_INTEGER   KernelTime;
        LARGE_INTEGER   UserTime;
        LARGE_INTEGER   IdleTime;
        ULONG           InterruptCount;
} CPU_VALUE,*PCPU_VALUE;



BOOL
UpdatePerfInfo(
   PULONG   DataPointer,
   ULONG    NewDataValue,
   PULONG   OldMaxValue
   );


VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   );

#endif /* _CALCPERFH_INCLUDED */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vdmperf\calcperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   CalcPerf.c

Abstract:

   calculate perfoemance statistics

Author:



Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "calcperf.h"

SYSTEM_VDM_INSTEMUL_INFO PerfInfo;
SYSTEM_VDM_INSTEMUL_INFO PreviousPerfInfo;

//
//  make the maximum for pages available a "grow only" max. (since the
//  amount of memory in a machine is limited. Set to 1 Mbytes here.
//

ULONG                                       PgAvailMax = 16384;
ULONG                                       PreviousInterruptCount;
ULONG                                       InterruptCount;


ULONG
InitPerfInfo()
/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{
    NTSTATUS Status;

    Status = NtQuerySystemInformation(
                SystemVdmInstemulInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        ExitProcess(1);
        }

    PreviousPerfInfo = PerfInfo;

    return(0);
}





BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   )

/*++

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{
    NTSTATUS Status;

    Status = NtQuerySystemInformation(
                SystemVdmInstemulInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        ExitProcess(1);
        }


    PerfListItem[IX_PUSHF].ChangeScale  = UpdatePerfInfo(
                    &PerfListItem[IX_PUSHF].TotalTime[0],
                    delta(OpcodePUSHF),
                    &PerfListItem[IX_PUSHF].Max);

    PerfListItem[IX_POPF].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_POPF].TotalTime[0],
                    delta(OpcodePOPF),
                    &PerfListItem[IX_POPF].Max);

    PerfListItem[IX_IRET].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_IRET].TotalTime[0],
                    delta(OpcodeIRET),
                    &PerfListItem[IX_IRET].Max);

    PerfListItem[IX_HLT].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_HLT].TotalTime[0],
                    delta(OpcodeHLT),
                    &PerfListItem[IX_HLT].Max);

    PerfListItem[IX_CLI].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_CLI].TotalTime[0],
                    delta(OpcodeCLI),
                    &PerfListItem[IX_CLI].Max);

    PerfListItem[IX_STI].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_STI].TotalTime[0],
                    delta(OpcodeSTI),
                    &PerfListItem[IX_STI].Max);

    PerfListItem[IX_BOP].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_BOP].TotalTime[0],
                    delta(BopCount),
                    &PerfListItem[IX_BOP].Max);

    PerfListItem[IX_SEGNOTP].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_SEGNOTP].TotalTime[0],
                    delta(SegmentNotPresent),
                    &PerfListItem[IX_SEGNOTP].Max);

    PerfListItem[IX_VDMOPCODEF].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_VDMOPCODEF].TotalTime[0],
                    delta(VdmOpcode0F),
                    &PerfListItem[IX_VDMOPCODEF].Max);

    PerfListItem[IX_INB].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_INB].TotalTime[0],
                    delta(OpcodeINB),
                    &PerfListItem[IX_INB].Max);

    PerfListItem[IX_INW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_INW].TotalTime[0],
                    delta(OpcodeINW),
                    &PerfListItem[IX_INW].Max);

    PerfListItem[IX_OUTB].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTB].TotalTime[0],
                    delta(OpcodeOUTB),
                    &PerfListItem[IX_OUTB].Max);

    PerfListItem[IX_OUTW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTW].TotalTime[0],
                    delta(OpcodeOUTW),
                    &PerfListItem[IX_OUTW].Max);

    PerfListItem[IX_INSW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_INSW].TotalTime[0],
                    delta(OpcodeINSW),
                    &PerfListItem[IX_INSW].Max);

    PerfListItem[IX_OUTSB].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTSB].TotalTime[0],
                    delta(OpcodeOUTSB),
                    &PerfListItem[IX_OUTSB].Max);

    PerfListItem[IX_OUTSW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTSW].TotalTime[0],
                    delta(OpcodeOUTSW),
                    &PerfListItem[IX_OUTSW].Max);

    PreviousPerfInfo = PerfInfo;

    return(TRUE);
}


BOOL
UpdatePerfInfo(
   PULONG    DataPointer,
   ULONG     NewDataValue,
   PULONG    OldMaxValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //


    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;

    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {

        DataPointer[Index] = DataPointer[Index-1];



        if (DataPointer[Index] > ScanMax) {
            ScanMax = DataPointer[Index];
        }
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;

    if (NewDataValue > ScanMax) {
        ScanMax = NewDataValue;
    }

    //
    //  If OldMaxValue = NULL then do not do a max limit check
    //

    if (OldMaxValue == NULL) {
        return(FALSE);
    }


    //
    //  If Max values changed then undate the new max
    //  value and return TRUE.
    //

    if (ScanMax != *OldMaxValue) {
        *OldMaxValue = ScanMax;
        return(TRUE);
    }

    return(FALSE);

}



VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   )

/*++

Routine Description:

    Init all perf data structures

Arguments:

    PerfListItem  - array of all perf categories
    NumberOfItems - Number of items to init

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   ListIndex,DataIndex;


    for (ListIndex=0;ListIndex<NumberOfItems;ListIndex++) {
        PerfListItem[ListIndex].Max = 100;
        PerfListItem[ListIndex].ChangeScale = FALSE;
        for (DataIndex=0;DataIndex<DATA_LIST_LENGTH;DataIndex++) {
            PerfListItem[ListIndex].TotalTime[DataIndex] = 0;
            PerfListItem[ListIndex].KernelTime[DataIndex] = 0;
            PerfListItem[ListIndex].UserTime[DataIndex] = 0;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\upd\upd.c ===
/*
 *  UPD: update
 *
 * HISTORY:
 *
 *   4/13/86  danl  Fix /d bug.  Print warning on eq time ne length
 *   4/11/86  danl  Remove test for length just before copyfile
 *   4/09/86  danl  Converted to ztools\lib
 *   5/07/86  danl  Add msg if no such source found
 *   5/29/86  danl  Add /s flag
 *   6/02/86  danl  Add /g flag
 *   6/04/86  danl  Allow %n with /g flag
 *   6/10/86  danl  Allow blank lines in /g file, # are not echo'd
 *   6/12/86  danl  Output \n and ends of lines
 *   6/26/86  danl  Convert from fatal to usage
 *   7/01/86  danl  Add /a flag
 *  12/04/86  danl  Add /p flag
 *  12/24/86  danl  Use malloc for pPat
 *   2/24/87  brianwi Use findclose()
 *   2/25/87  brianwi Add 'echo' and 'rem' to /g files
 *  07-Apr-87 danl    Add fAnyUpd
 *  13-Apr-87 brianwi Issue error message if source dir invalid
 *  07-May-87 danl    Add /e switch
 *  22-May-87 brianwi Fix descent from root directory bug
 *  20-Aug-87 brianwi Fix Null Pointer with /o ( free(pPat) in walk() )
 */
#include <malloc.h>
#include <math.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

// Forward Function Declarations...
int savespec( char * );
int copyfile( char *, struct findType *, char * );
void walk( char *, struct findType *, void *);
void RecWalk( char *, struct findType *, void * );
void saveext( char * );
void __cdecl usage( char *, ... );
void getfile( int, char ** );


char const rgstrUsage[] = {
    "Usage: UPD [/nxdfvosape] {src directories}+ dest directory [{wildcard specs}*]\n"
    "       UPD /g file\n"
    "    Options:\n"
    "       -n  No saving of replaced files to deleted directory\n"
    "       -x  eXclude files, see tools.ini\n"
    "       -d  Descend into subdirectories\n"
    "       -f  Files differ, then update\n"
    "       -v  Verbose\n"
    "       -o  Only files already existing in dest are updated\n"
    "       -s  Subdirectory DEBUG has priority\n"
    "       -a  Archive bit on source should NOT be reset\n"
    "       -p  Print actions, but do nothing\n"
    "       -e  Exit codes 1-error or no src else 0\n"
    "           Default is 1-update done 0-no updates done\n"
    "       -g  Get params from file\n"
    };

#define BUFLEN  MAX_PATH
#define MAXSPEC 32
#define MAXFIL  256
#define MAXARGV 20

char *exclude[MAXFIL], dir[BUFLEN];
unsigned _stack = 4096;
flagType fInGetfile = FALSE;
flagType _fExpand = FALSE;
flagType fDescend = FALSE;
flagType fAll = FALSE;
flagType fExclude = FALSE;
flagType fDel = TRUE;
flagType fVerbose = FALSE;
flagType fOnly = FALSE;
flagType fSubDebug = FALSE;     /* TRUE => priority to subdir DEBUG */
flagType fArchiveReset = TRUE;
flagType fPrintOnly = FALSE;
flagType fErrorExit = FALSE;    /* TRUE => exit (1) errors or no src else 0 */
flagType fNoSrc = FALSE;        /* TRUE => "No src msg emitted" */

int numexcl = 0;
int cCopied = 0;
int fAnyUpd = 0;
int nWildSpecs = 0;
char *wildSpecs[MAXSPEC];
struct findType buf;
char source[BUFLEN], dest[BUFLEN], srcDebug[BUFLEN];

/* for use by getfile */
char *argv[MAXARGV];
char bufIn[BUFLEN];
char strLine[BUFLEN];
char ekoLine[BUFLEN]; /* undestroyed copy of line for echo */


savespec (p)
char *p;
{
    char namebuf[ 16 ];
    int i;

    buf.fbuf.dwFileAttributes = 0;
    namebuf[ 0 ] = 0;
    if (strchr(p, '\\') || strchr(p, ':' ) )
        return FALSE;
    ffirst( p, FILE_ATTRIBUTE_DIRECTORY, &buf );
    findclose( &buf );
    if ( /* !HASATTR( buf.attr, FILE_ATTRIBUTE_DIRECTORY ) && */
        filename( p, namebuf )
    ) {
        fileext( p, namebuf);
        upper( namebuf );
        for (i=0; i<nWildSpecs; i++)
            if (!strcmp( namebuf, wildSpecs[ i ]))
                return TRUE;

        if (nWildSpecs < MAXSPEC) {
            wildSpecs[ nWildSpecs++ ]  = _strdup (namebuf);
            return TRUE;
            }
        else
            usage( "Too many wild card specifications - ", namebuf, 0 );
        }

    return FALSE;
}


copyfile( src, srctype, dst )
char *src, *dst;
struct findType *srctype;
{
    int i;
    char *result, temp[ 20 ]; /* temp for storing file names */
    flagType fNewfile = FALSE;

    if ( fExclude ) {
        fileext( src, temp );

        for (i = 0; i< numexcl; i++) {
            if( !_strcmpi( exclude[i], temp ) ) {
                return( FALSE );
            }
        }
    }
    fflush( stdout );
        /* if the file already exists, fdelete will return 0; then don't    */
        /* notify the user that a file transfer has taken place.  Otherwise */
        /* a new file has been created so tell the user about it.           */
    printf( "  %s => %s", src, dst );
    fAnyUpd = 1;
    if ( !fPrintOnly ) {
        if (fDel) fNewfile = (flagType)((fdelete(dst)) ? TRUE : FALSE );
        if (!(result = fcopy( src, dst ))) {
            if (fArchiveReset)
                SetFileAttributes( src, srctype->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_ARCHIVE );
            if (fVerbose || fNewfile) printf( " [OK]" );
            }
        else
            printf( " %s - %s", result, error() );
    }
    else
        printf ( " [no upd]" );
    printf( "\n" );
    fflush( stdout );
    return TRUE;
}

void
walk (
    char            *p,
    struct findType *b,
    void            *dummy
    )
{
    int fNotFound;
    char *pPat;
    char *pT = p;
    struct findType *bT = b;
    struct findType bufT;

    if( strcmp( bT->fbuf.cFileName, "." ) &&
        strcmp( bT->fbuf.cFileName, ".." )
      ) {
        if (HASATTR (bT->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
                /* do nothing if you find a dir */
        } else if( !HASATTR( bT->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM  ) ) {
            //
            //  Note: windows does not support FILE_ATTRIBUTE_VOLUME_LABEL, so
            //        it was removed from above
            //
            pPat = malloc ( BUFLEN );
            if (pPat) {
                strcpy( pPat, dest );
                if (*(strend( pPat ) - 1) != '\\') {
                    strcat( pPat, "\\" );
                }
                fileext( pT, strend ( pPat ) );
    
                /* ffirst == 0 => file found */
    
                if (fOnly && ffirst( pPat, -1, &buf ) )  {
                    free ( pPat );
                    return;
                }
                if (fOnly) {
                    findclose( &buf );
                }
    
                /* so far we know src\file and dest\file exist */
                if (fSubDebug) {
                    /* now check to see if src\DEBUG\file exists */
                    drive(pT, srcDebug);
                    path(pT, srcDebug + strlen(srcDebug));
                    strcat(srcDebug + strlen(srcDebug), "debug\\");
                    fileext(pT, srcDebug + strlen(srcDebug));
                    if( !ffirst( srcDebug, -1, &bufT ) ) {
                        findclose( &bufT );
                        /* it exists so use it for the compares below */
                        pT = srcDebug;
                        bT = &bufT;
                    }
                }
    
                cCopied++;
    
                if( ( fNotFound = ffirst( pPat, -1, &buf ) ) ||
                    ( CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) < 0 ) ||
                    ( fAll &&
                      CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) > 0
                    )
                  ) {
                    copyfile( pT, bT, pPat );
                } else if( !fNotFound &&
                           CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) == 0 &&
                           buf.fbuf.nFileSizeLow != bT->fbuf.nFileSizeLow
                         ) {
                    printf("\n\007UPD: warning - %s not copied\n", pT);
                    printf("\007UPD: warning - same time, different length in src & dest\n", pT);
                }
                findclose( &buf );
                free ( pPat );
            }
        }
    }
    dummy;
}

/*  a first walking routine, just copies the files on given directory */
/*  doesn't deal with nested subdirectories.  Ie split the process up into */
/*  two parts, first deal with files on current directory, then deal with */
/*  subdirectories as necessary. */



/* only called when fDescend is true */
void
RecWalk (
    char            *p,
    struct findType *b,
    void            *dummy
    )
{
    char *pPat;
    char *pDestEnd;
    int i;

    if (strcmp (b->fbuf.cFileName, ".") && strcmp (b->fbuf.cFileName, ".."))
        if (HASATTR (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) && 
            !HASATTR (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) 
        {
            /* ignore Hidden and System directories */
            pPat = malloc ( BUFLEN );
            if (pPat) {
                if ( (pDestEnd = strend(dest))[-1] != '\\' )
                    strcat(pDestEnd, "\\");
                fileext(p, strend(pDestEnd));
                sprintf( pPat, "%s\\*.*", p);
                forfile( pPat, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, RecWalk, NULL );
                for (i=0; i<nWildSpecs; i++) {
                     sprintf( pPat, "%s\\%s", p, wildSpecs[ i ] );
                     forfile( pPat, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, walk, NULL );
                     }
                *pDestEnd = '\0';
                free ( pPat );
            }
        }
    dummy;
}


void
saveext (p)
char *p;
{
    upper (p) ;
    if (numexcl < MAXFIL)
        exclude [numexcl++]  = _strdup (p);
}


void __cdecl usage( char *p, ... )
{
    char **rgstr;

    rgstr = &p;
    if (*rgstr) {
        fprintf (stderr, "UPD: ");
        while (*rgstr)
            fprintf (stderr, "%s", *rgstr++);
        fprintf (stderr, "\n");
        }
    fputs(rgstrUsage, stderr);

    exit ((fErrorExit ? 1 : 0));
}


__cdecl
main (c, v)
int c;
char *v[];
{
    int i, j, k;
    FILE *fh;
    char *p, *p1, namebuf[ BUFLEN ];

    _fExpand = FALSE;
    fDescend = FALSE;
    fAll = FALSE;
    fExclude = FALSE;
    fDel = TRUE;
    fOnly = FALSE;
    fSubDebug = FALSE;
    fArchiveReset = TRUE;
    fPrintOnly = FALSE;
    numexcl = 0;
    cCopied = 0;
    nWildSpecs = 0;

    if (!fInGetfile)
        SHIFT(c, v);    /* Flush the command name */
    /*
     * 13-SEPT-90   w-barry
     * Added test for arguments remaining before test for switch char.
     */
    while( c && fSwitChr ( *v[ 0 ] ) ) {
        p = v[ 0 ];
        SHIFT(c, v);
        while (*++p)
            switch (tolower(*p)) {
                case 'a':
                    fArchiveReset = FALSE;
                    break;
                case 'g':
                    if (fInGetfile)
                        usage( "/g allowed only on command line", 0);
                    getfile(c, v);
                    break;
                case 'e':
                    fErrorExit = TRUE;
                case 'x':
                    fExclude = TRUE;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'd':
                    fDescend = TRUE;
                    break;
                case 'f':
                    fAll = TRUE;
                    break;
                case 'n':
                    fDel = FALSE;
                    break;
                case 'o':
                    fOnly = TRUE;
                    break;
                case 'p':
                    fPrintOnly = TRUE;
                    break;
                case 's':
                    fSubDebug = TRUE;
                    break;
                default:
                    usage( "Invalid switch - ", p, 0);
                }
        }

    if (fSubDebug && fDescend) {
        printf("UPD: /s and /d both specified, /d ignored\n");
        fDescend = FALSE;
        }

    if (fExclude)
        if  ((fh = swopen ("$USER:\\tools.ini", "upd")) ) {
           while (swread (p1 = dir, BUFLEN, fh)) {
                while  (*(p = strbskip (p1, " ")))  {
                    if  (*(p1 = strbscan (p, " ")))
                        *p1++ = 0;
                    saveext (p) ;
                    }
                }
            swclose (fh) ;
            }

        /* Must be at least one source dir and the dest dir. */
    if (c < 2)
        usage( 0 );

        /* Save away any wildcard specs at end of argument list */
    for (i=c-1; i>=2; i--)
        if (!savespec( v[ i ] ))
            break;
        else
            c--;

        /* Still must be at least one source dir and the dest dir. */
    if (c < 2)
        usage( 0 );

        /* Make sure destination is a valid directory */

    rootpath( v[ c-1 ], dest );
    if (ffirst( dest, FILE_ATTRIBUTE_DIRECTORY, &buf ) == -1)
        usage( "Destination directory does not exist - ", v[ c-1 ], 0 );
    else {
        findclose( &buf );
        c--;
        }

    if (!nWildSpecs)
        savespec( "*.*" );

    if (fVerbose) {
        printf( "Copying all files matching:" );
        for (i=0; i<nWildSpecs; i++)
            printf( "  %s", wildSpecs[ i ] );
        printf( "\n" );
        printf( "To destination directory:    %s\n", dest );
        printf( "From the following source directories:\n" );
        }
    for (i=0; i<c; i++) {
        if (rootpath( v[ i ], namebuf )) {
            printf( "\aSource directory does not exist - %s\n", v[ i ]);
            continue;
        }

        if (fVerbose) printf( "  %s\n", namebuf );

        if (namebuf[k = strlen( namebuf ) - 1] == '\\')
            namebuf[k] = '\0';

        for (j=0; j<nWildSpecs; j++) {
            sprintf( source, "%s\\%s", namebuf, wildSpecs[ j ] );
            cCopied = 0;
            forfile( source, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, walk, NULL );
            if (!cCopied) {
                printf( "UPD: no src file matching %s\\%s\n", namebuf, wildSpecs[ j ] );
                fNoSrc = 1;
                }
            }
        if (fDescend) {
            sprintf( source, "%s\\*.*", namebuf );
            forfile( source, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, RecWalk, NULL );
            }
/*        if (fVerbose) printf( "\n" ); */
        }

    if (!fInGetfile)
        return( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );

    return 0;
}

/*  call if UPD /g getfile, reads lines from getfile and for each line
    calls main */

void getfile(c, v)
int c;
char *v[];
{
    FILE *fp;
    int cargv = 0;
    int i, j;
    char *p;

    ConvertAppToOem( c, v );
    if( c == 0 ) {
        usage("no getfile specified", 0);
    }
    fInGetfile = TRUE;
    if( ( fp = fopen( *v, "r" ) ) == (FILE *)NULL ) {
        usage("error opening ", *v, 0);
    }
    SHIFT(c, v);

    /*
     * 13-SEPT-90   w-barry
     *      Changed open to fopen and switched to fgets instead of assembly
     * routines 'getl' and 'getlinit'.
     *
     * getlinit((char far *)bufIn, BUFLEN, fh);
     * while (getl(strLine, BUFLEN) != NULL) {
     */
    while( fgets( strLine, BUFLEN, fp ) != NULL ) {
        if( *strLine == '#' )
            continue;
        if( *strLine == ';') {
            printf( "%s\n", strLine );
            continue;
            }
        /* fgets doesn't strip the trailing \n */
        *strbscan(strLine, "\n") = '\0';
        cargv = 0;
        /* convert strLine into argv */
        p = strbskip(strLine, " ");
        strcpy (ekoLine, p + 5);
        while (*p) {
            argv[cargv++] = p;
            p = strbscan(p, " ");
            if (*p)
                *p++ = '\0';
            p = strbskip(p, " ");
            }

        if (!_stricmp (argv[0], "rem")) continue;
        if (!_stricmp (argv[0], "echo"))
        {
            if      (!_stricmp (argv[1], "on" ))
            {
                fVerbose = TRUE;
                printf ("Verbose On\n");
            }
            else if (!_stricmp (argv[1], "off"))
                 {
                     fVerbose = FALSE;
                     printf ("Verbose Off\n");
                 }
            else printf ("%s\n", ekoLine);
            continue;
        }

        for (i = 0; i < cargv; i++) {
            if (*(p = argv[i]) == '%') {
                if ((j = atoi(++p)) < c)
                    argv[i] = v[j];
                else
                    usage("bad arg ", argv[i], 0);
                }
            }

        if (cargv)
            main(cargv, argv);
        }
    fclose( fp );

    exit( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\updrn\updrn.c ===
/*
 *  UPDRN: UPD with rename
 *
 * HISTORY:
 *  manis : 22-May-87 : first written and released
 *  29-May-87   danl    Added explicit test for only two args
 *                      Removed rootpath tests
 *                      Added string.h
 *                      Don't remove trailing '\' from args to /g
 *  12-Jun-87   brianwi Get around FAPI one-open dir limitation
 */

#include <malloc.h>
#include <math.h>
#include <ctype.h>
#include <fcntl.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

// Forward Function Declarations..
void docopy( char *, struct findType * );
int setup( char *, int, void (*)() );
void __cdecl usage( char *, ... );
void getfile( int, char ** );


char const rgstrUsage[] = {
    "Usage: UPDRN [/fnvape] srcfile destfile\n"
    "       UPDRN /g file {arg}*\n"
    "\n"
    "   /f  Files differ, then copy\n"
    "   /n  No saving of replaced file to deleted directory\n"
    "   /v  Verbose\n"
    "   /a  Archive bit on source should NOT be reset\n"
    "   /p  Print actions, but do nothing\n"
    "   /e  Exit codes 1-error or no src else 0\n"
    "       Default is 1-copy done 0-no copy done\n"
    "   /g  Get params from file\n"
    };

#define BUFLEN  MAX_PATH
#define MAXARGV 20

unsigned _stack = 4096;
flagType fInGetfile = FALSE;
flagType fAll = FALSE;
flagType fDel = TRUE;
flagType fVerbose = FALSE;
flagType fArchiveReset = TRUE;
flagType fPrintOnly = FALSE;
flagType fErrorExit = FALSE;    /* TRUE => exit (1) errors or no src else 0 */
flagType fNoSrc = FALSE;        /* TRUE => "No src msg emitted" */

int cCopied = 0;
int fAnyUpd = 0;
struct findType buf;
char source[BUFLEN], dest[BUFLEN] ;

/* for use by getfile */
char *argv[MAXARGV];
char bufIn[BUFLEN];
char strLine[BUFLEN];
char ekoLine[BUFLEN]; /* undestroyed copy of line for echo */


void copyfile(src, srctype, dst)
char *src, *dst;
struct findType *srctype;
{
    char *result;
    flagType fNewfile = FALSE;

    /* if the file already exists, fdelete will return 0; then don't */
    /* notify the user that a file transfer has taken place.Otherwise*/
    /* a new file has been created so tell the user about it.        */

    printf("  %s => %s", src, dst);
    fAnyUpd = 1;
    if (!fPrintOnly) {
        if( fDel ) {
           fNewfile = (flagType)( (fdelete(dst)) ? TRUE : FALSE );
        }
        if (!(result = fcopy(src, dst))) {
            if (fArchiveReset)
                SetFileAttributes( src, srctype->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_ARCHIVE );
            if (fVerbose || fNewfile) printf(" [OK]");
            }
        else
            printf(" %s - %s", result, error());
    }
    else
        printf (" [no copy]");
    printf("\n");
    fflush(stdout);
}

void docopy (p, b)
/* copy source file to destination file based on time stamps */
/* and different switches.                                   */
char *p;
struct findType *b;
{
    int fNotFound;
    char *pPat;
    char *pT = p;
    struct findType *bT = b;

    pPat = malloc (BUFLEN);
    if (pPat) {
        strcpy(pPat, dest);
    
        cCopied++;
    
        if( ( fNotFound = ffirst(pPat, ~(FILE_ATTRIBUTE_DIRECTORY), &buf)) ||
            ( CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) < 0 ) ||
             ( fAll &&
               CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) > 0
             )
          ) {
             copyfile(pT, bT, pPat);
        }
        else if( !fNotFound &&
                 CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) == 0 &&
                 buf.fbuf.nFileSizeLow != bT->fbuf.nFileSizeLow
               ) {
            printf("\n\007UPDRN: warning - %s not copied\n", pT);
            printf("\007UPDRN: warning - same time, different length in src & dest\n", pT);
        }
    
        findclose( &buf );
        free (pPat);
    }
}

setup(pat, attr, rtn)
/* set up buffer for find first call. if the source file is valid */
/* and ffirst call is successful, call the routine "rtn".         */
char *pat;
int attr;
void (*rtn)();
{
    struct findType *fbuf;
    char *buf;

        if ((fbuf=(struct findType *)malloc(sizeof (*fbuf) + MAX_PATH ))==NULL)
        return FALSE;

    if (ffirst (pat, attr, fbuf)) {
        free ((char *) fbuf);
        return FALSE;
        }

        if ((buf = (char *)malloc(MAX_PATH)) == NULL) {
        free ((char *) fbuf);
        return FALSE;
        }

    drive (pat, buf);
    path (pat, strend (buf));
    pat = strend (buf);

    strcpy (pat, fbuf->fbuf.cFileName);
    _strlwr (pat);
    findclose (fbuf);
    (*rtn) (buf, fbuf);


    free (buf);
    free ((char *) fbuf);

    return TRUE;
}

void __cdecl usage( char *p, ... )
/* prints error messages */
{
    char **rgstr;

    rgstr = &p;
    if (*rgstr) {
        fprintf (stderr, "UPDRN: ");
        while (*rgstr)
            fprintf (stderr, "%s", *rgstr++);
        fprintf (stderr, "\n");
        }
    fputs (rgstrUsage, stderr);

    exit ((fErrorExit ? 1 : 0));
}

int
__cdecl
main (c, v)
int c;
char *v[];
{
    char *p, namebuf[ BUFLEN ];

    fAll = FALSE;
    fDel = TRUE;
    fArchiveReset = TRUE;
    fPrintOnly = FALSE;
    cCopied = 0;

    if (!fInGetfile)
        ConvertAppToOem( c, v );
        SHIFT(c, v);    /* Flush the command name */
    while( c && fSwitChr( *v[0] ) ) {
        p = v[ 0 ];
        SHIFT(c, v);
        while (*++p)
            switch (tolower(*p)) {
                case 'a':
                    fArchiveReset = FALSE;
                    break;
                case 'g':
                    if (fInGetfile)
                        usage("/g allowed only on command line", 0);
                    getfile(c, v);
                    break;
                case 'e':
                    fErrorExit = TRUE;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'f':
                    fAll = TRUE;
                    break;
                case 'n':
                    fDel = FALSE;
                    break;
                case 'p':
                    fPrintOnly = TRUE;
                    break;
                default:
                    usage("Invalid switch - ", p, 0);
                }
        }

        /* Must be at one source file and dest file. */
    if (c != 2)
        usage(0);

        /* Make sure source and destination dirs are valid */
        /* Wildcards not allowed                           */

    rootpath( v[1], dest );
    rootpath( v[0], source);

    if (!filename(source, namebuf))
        usage("Source file name not specified - ", source, 0);

    if (fileext(source, namebuf))
       if (strpbrk(namebuf,"*")!=NULL)
           usage("Wild cards not allowed - ", source, 0);

    if (fileext(dest, namebuf)){
     if (strpbrk(namebuf,"*")!=NULL)
        usage("Wild cards not allowed - ", dest, 0);
    }
    else
        usage("Destination file not specified - ", dest, 0);

    /* now compcopy the source file to dest file. source
       file has subset of the attributes specified      */

    if (fVerbose) {
       printf("Comparing and copying srcfile:   %s\n", source);
       printf("          To destination file:   %s\n", dest);
    }

    cCopied = 0;
    setup(source, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_ARCHIVE, (void ( *)())docopy);
    if (!cCopied) {
        printf("UPDRN: no src file matching %s\n", source);
        fNoSrc = 1;
    }

    if (!fInGetfile)
        return( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );

    return 0;
}

/*  call if UPDRN /g getfile, reads lines from getfile and for each line
    calls main */

void getfile(c, v)
int c;
char *v[];
{
    int cargv = 0;
    FILE *fp;
    int i, j;
    char *p, *p2;
    char lbuf[BUFLEN];

    /*
     * 13-SEPT-90   w-barry
     *
     * Change open() to fopen() and replace assembly routines getl() and
     * getlinit() with fgets.
     */
    if (c == 0)
        usage("no getfile specified", 0);
    fInGetfile = TRUE;
    if( ( fp = fopen( *v, "r" ) ) == NULL ) {
        usage("error opening ", *v, 0);
    }
    SHIFT(c, v);
/*  getlinit((char far *)bufIn, BUFLEN, fh);
 *  while (getl(strLine, BUFLEN) != NULL) {
 */

    while( fgets( strLine, BUFLEN, fp ) != NULL ) {
        if (*strLine == '#')
            continue;
        if (*strLine == ';') {
            printf("%s\n", strLine);
            continue;
            }
        /* fgets doesn't remove \n */
        *strbscan(strLine, "\n") = '\0';
        cargv = 0;
        /* convert strLine into argv */
        p = strbskip(strLine, " ");
        strcpy (ekoLine, p + 5);
        while (*p) {
            argv[cargv++] = p;
            p = strbscan(p, " ");
            if (*p)
                *p++ = '\0';
            p = strbskip(p, " ");
            }

        if (!_stricmp (argv[0], "rem")) continue;
        if (!_stricmp (argv[0], "echo"))
        {
            if      (!_stricmp (argv[1], "on"))
            {
                fVerbose = TRUE;
                printf ("Verbose On\n");
            }
            else if (!_stricmp (argv[1], "off"))
                 {
                     fVerbose = FALSE;
                     printf ("Verbose Off\n");
                 }
            else printf ("%s\n", ekoLine);
            continue;
        }

     /* replace the arguments in the file : %0, %1 etc     */
     /* with the arguments from the command line           */
     /* lbuf : holds the strings formed by replacing %0 etc*/

        p2 = lbuf;
        for (i = 0; i < cargv; i++) {
            if (*(p = argv[i]) == '%') {
                if ((j = atoi(++p)) < c) {
                    strcpy(p2, v[j]);
                    argv[i] = strcat(p2,++p);
                    p2 += strlen(argv[i])+1;
                }
                else
                    usage("bad arg ", argv[i], 0);
                }
            }

        if (cargv)
            main(cargv, argv);
    }
    fclose( fp );
    exit( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\uwdump\uwdump.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    uwdump.c

Abstract:

    This module implements a program which dumps the function table and
    unwind data for a specified executable file. It is an AMD64 specific
    program.

Author:

    David N. Cutler (davec) 6-Feb-2001

Environment:

    User mode.

Revision History:

    None.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// Define AMD64 exception handling structures and function prototypes.
//
// Define unwind operation codes.
//

typedef enum _UNWIND_OP_CODES {
    UWOP_PUSH_NONVOL = 0,
    UWOP_ALLOC_LARGE,
    UWOP_ALLOC_SMALL,
    UWOP_SET_FPREG,
    UWOP_SAVE_NONVOL,
    UWOP_SAVE_NONVOL_FAR,
    UWOP_SAVE_XMM,
    UWOP_SAVE_XMM_FAR,
    UWOP_SAVE_XMM128,
    UWOP_SAVE_XMM128_FAR,
    UWOP_PUSH_MACHFRAME
} UNWIND_OP_CODES, *PUNWIND_OP_CODES;

//
// Define unwind code structure.
//

typedef union _UNWIND_CODE {
    struct {
        UCHAR CodeOffset;
        UCHAR UnwindOp : 4;
        UCHAR OpInfo : 4;
    };

    USHORT FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;

//
// Define unwind information flags.
//

#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4

//
// Define unwind information structure.
//

typedef struct _UNWIND_INFO {
    UCHAR Version : 3;
    UCHAR Flags : 5;
    UCHAR SizeOfProlog;
    UCHAR CountOfCodes;
    UCHAR FrameRegister : 4;
    UCHAR FrameOffset : 4;
    UNWIND_CODE UnwindCode[1];

//
// The unwind codes are followed by an optional DWORD aligned field that
// contains the exception handler address or the address of chained unwind
// information. If an exception handler address is specified, then it is
// followed by the language specified exception handler data.
//
//  union {
//      ULONG ExceptionHandler;
//      ULONG FunctionEntry;
//  };
//
//  ULONG ExceptionData[];
//

} UNWIND_INFO, *PUNWIND_INFO;

//
// Define function table entry - a function table entry is generated for
// each frame function.
//

typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

//
// Scope table structure definition.
//

typedef struct _SCOPE_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG HandlerAddress;
    ULONG JumpTarget;
} SCOPE_ENTRY;

typedef struct _SCOPE_TABLE {
    ULONG Count;
    struct
    {
        ULONG BeginAddress;
        ULONG EndAddress;
        ULONG HandlerAddress;
        ULONG JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE, *PSCOPE_TABLE;

//
// Define register names.
//

PCHAR Register[] = {"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
                    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
                    "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xxm6",
                    "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12",
                    "xmm13", "xxm14", "xmm15"};

//
// Define the sector size and header buffer.
//

#define SECTOR_SIZE 512
CHAR LocalBuffer[SECTOR_SIZE * 2];

//
// Define input file stream.
//

FILE * InputFile;

//
// This gobal indicates whether we are processing an executable or an obj.
//

BOOLEAN IsObj;

//
// Define forward referenced prototypes.
//

VOID
DumpPdata (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PIMAGE_SECTION_HEADER PdataHeader
    );

VOID
DumpUData (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN ULONG Virtual
    );

PIMAGE_SECTION_HEADER
FindSectionHeader (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PCHAR SectionName
    );

VOID
ReadData (
    IN ULONG Position,
    OUT PVOID Buffer,
    IN ULONG Count
    );

USHORT
ReadWord (
    IN ULONG Position
    );

ULONG
ReadDword (
    IN ULONG Position
    );

//
// Main program.
//

int
__cdecl
main(
    int argc,
    char **argv
    )

{

    PIMAGE_FILE_HEADER FileHeader;
    PCHAR FileName;
    ULONG Index;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG NumberOfSections;
    PIMAGE_SECTION_HEADER PDataHeader;
    PIMAGE_SECTION_HEADER SectionHeaders;

    if (argc < 2) {
        printf("no executable file specified\n");

    } else {

        //
        // Open the input file.
        //

        FileName = argv[1];
        InputFile = fopen(FileName, "rb");
        if (InputFile != NULL) {

            //
            // Read the file header.
            //

            if (fread(&LocalBuffer[0],
                      sizeof(CHAR),
                      SECTOR_SIZE * 2,
                      InputFile) == (SECTOR_SIZE * 2)) {

                //
                // Get the NT header address.
                //

                NtHeaders = RtlImageNtHeader(&LocalBuffer[0]);
                if (NtHeaders != NULL) {
                    IsObj = FALSE;
                    FileHeader = &NtHeaders->FileHeader;
                } else {
                    IsObj = TRUE;
                    FileHeader = (PIMAGE_FILE_HEADER)LocalBuffer;
                }

                printf("FileHeader->Machine %d\n",FileHeader->Machine);

                if (FileHeader->Machine == IMAGE_FILE_MACHINE_AMD64) {

                    //
                    // Look up the .pdata section.
                    //

                    NumberOfSections = FileHeader->NumberOfSections;

                    SectionHeaders =
                        (PIMAGE_SECTION_HEADER)((PUCHAR)(FileHeader + 1) +
                                                FileHeader->SizeOfOptionalHeader);

                    PDataHeader = FindSectionHeader(NumberOfSections,
                                                    SectionHeaders,
                                                    ".pdata");

                    if (PDataHeader != NULL) {
                        printf("Dumping Unwind Information for file %s\n\n", FileName);
                        DumpPdata(NumberOfSections,
                                  &SectionHeaders[0],
                                  PDataHeader);

                        return 0;
                    }

                    printf("no .pdata section in image\n");

                } else {
                    printf("the specified file is not an amd64 executable\n");
                }

            } else {
                printf("premature end of file encountered on input file\n");
            }

            fclose(InputFile);

        } else {
            printf("can't open input file %s\n", FileName);
        }
    }

    return 0;
}

VOID
DumpPdata (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PIMAGE_SECTION_HEADER PdataHeader
    )

{

    RUNTIME_FUNCTION Entry;
    ULONG Number;
    ULONG Offset;
    ULONG SectionSize;

    //
    // Dump a .pdata function table entry and then dump the associated
    // unwind data.
    //

    if (IsObj == FALSE) {
        SectionSize = PdataHeader->Misc.VirtualSize;
    } else {
        SectionSize = PdataHeader->SizeOfRawData;
    }

    Number = 1;
    Offset = 0;
    do {

        //
        // Read and dump the next function table entry.
        //

        ReadData(PdataHeader->PointerToRawData + Offset,
                 &Entry,
                 sizeof(RUNTIME_FUNCTION));

        printf(".pdata entry %d 0x%08lX 0x%08lX\n",
               Number,
               Entry.BeginAddress,
               Entry.EndAddress);

        //
        // Dump the unwind data assoicated with the function table entry.
        //

        DumpUData(NumberOfSections, SectionHeaders, Entry.UnwindData);

        //
        // Increment the entry number and update the offset to the next
        // function table entry.
        //

        Number += 1;
        Offset += sizeof(RUNTIME_FUNCTION);
    } while (Offset < SectionSize);

    //
    // Function offset and size of raw data should be equal if there is
    // the correct amount of data in the .pdata section.
    //

    if (Offset != SectionSize) {
        printf("incorrect size of raw data in .pdata, 0x%lx\n",
               PdataHeader->SizeOfRawData);
    }

    return;
}

VOID
DumpUData (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN ULONG Virtual
    )

{

    ULONG Allocation;
    ULONG Count;
    ULONG Displacement;
    ULONG FrameOffset = 0;
    ULONG FrameRegister = 0;
    ULONG Handler;
    ULONG Index;
    ULONG Offset;
    SCOPE_ENTRY ScopeEntry;
    UNWIND_CODE UnwindCode;
    UNWIND_INFO UnwindInfo;
    PIMAGE_SECTION_HEADER XdataHeader;

    //
    // Locate the section that contains the unwind data.
    //

    printf("\n");
    printf("  Unwind data: 0x%08lX\n\n", Virtual);

    if (IsObj == FALSE) {
        XdataHeader = SectionHeaders;
        for (Index = 0; Index < NumberOfSections; Index += 1) {
            if ((XdataHeader->VirtualAddress <= Virtual) &&
                (Virtual < (XdataHeader->VirtualAddress + XdataHeader->Misc.VirtualSize))) {
                break;
            }
    
            XdataHeader += 1;
        }
    
        if (Index == NumberOfSections) {
            printf("    unwind data address outside of image\n\n");
            return;
        }

        Offset = Virtual -
                 XdataHeader->VirtualAddress +
                 XdataHeader->PointerToRawData; 

    } else {

        //
        // This is an .obj, so there is only one Xdata header
        //

        XdataHeader = FindSectionHeader(NumberOfSections,
                                        SectionHeaders,
                                        ".xdata");

        Offset = Virtual + XdataHeader->PointerToRawData;
    }

    //
    // Read unwind information.
    //

    ReadData(Offset,
             &UnwindInfo,
             sizeof(UNWIND_INFO) - sizeof(UNWIND_CODE));

    //
    // Dump unwind version.
    //

    printf("    Unwind version: %d\n", UnwindInfo.Version);

    //
    // Dump unwind flags.
    //

    printf("    Unwind Flags: ");
    if ((UnwindInfo.Flags & UNW_FLAG_EHANDLER) != 0) {
        printf("EHANDLER ");
    }

    if ((UnwindInfo.Flags & UNW_FLAG_UHANDLER) != 0) {
        printf("UHANDLER ");
    }

    if ((UnwindInfo.Flags & UNW_FLAG_CHAININFO) != 0) {
        printf("CHAININFO");
    }

    if (UnwindInfo.Flags == 0) {
        printf("None");
    }

    printf("\n");

    //
    // Dump size of prologue.
    //

    printf("    Size of prologue: 0x%02lX\n", UnwindInfo.SizeOfProlog);

    //
    // Dump number of unwind codes.
    //

    printf("    Count of codes: %d\n", UnwindInfo.CountOfCodes);

    //
    // Dump frame register if specified.
    //

    if (UnwindInfo.FrameRegister != 0) {
        FrameOffset = UnwindInfo.FrameOffset * 16;
        FrameRegister = UnwindInfo.FrameRegister;
        printf("    Frame register: %s\n", Register[FrameRegister]);
        printf("    Frame offset: 0x%lx\n", FrameOffset);
    }

    //
    // Dump the unwind codes.
    //

    Offset += sizeof(UNWIND_INFO) - sizeof(UNWIND_CODE);
    if (UnwindInfo.CountOfCodes != 0) {
        printf("    Unwind codes:\n\n");
        Count = UnwindInfo.CountOfCodes;
        do {
            Count -= 1;
            UnwindCode.FrameOffset = ReadWord(Offset);
            Offset += sizeof(USHORT);
            printf("      Code offset: 0x%02lX, ", UnwindCode.CodeOffset);
            switch (UnwindCode.UnwindOp) {
            case UWOP_PUSH_NONVOL:
                printf("PUSH_NONVOL, register=%s\n", Register[UnwindCode.OpInfo]);
                break;

            case UWOP_ALLOC_LARGE:
                Count -= 1;
                Allocation = ReadWord(Offset);
                Offset += sizeof(USHORT);
                if (UnwindCode.OpInfo == 0) {
                    Allocation *= 8;

                } else {
                    Count -= 1;
                    Allocation = (Allocation << 16) + ReadWord(Offset);
                    Offset += sizeof(USHORT);
                }

                printf("ALLOC_LARGE, size=0x%lX\n", Allocation);
                break;

            case UWOP_ALLOC_SMALL:
                Allocation = (UnwindCode.OpInfo * 8) + 8;
                printf("ALLOC_SMALL, size=0x%lX\n", Allocation);
                break;

            case UWOP_SET_FPREG:
                printf("SET_FPREG, register=%s, offset=0x%02lX\n",
                       Register[FrameRegister], FrameOffset);
                break;

            case UWOP_SAVE_NONVOL:
                Count -= 1;
                Displacement = ReadWord(Offset) * 8;
                Offset += sizeof(USHORT);
                printf("SAVE_NONVOL, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo],
                       Displacement);
                break;

            case UWOP_SAVE_NONVOL_FAR:
                Count -= 2;
                Displacement = ReadWord(Offset) << 16;
                Offset += sizeof(USHORT);
                Displacement = Displacement + ReadWord(Offset);
                Offset += sizeof(USHORT);
                printf("SAVE_NONVOL_FAR, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo],
                       Displacement);
                break;

            case UWOP_SAVE_XMM:
                Count -= 1;
                Displacement = ReadWord(Offset) * 8;
                Offset += sizeof(USHORT);
                printf("SAVE_XMM, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_SAVE_XMM_FAR:
                Count -= 2;
                Displacement = ReadWord(Offset) << 16;
                Offset += sizeof(USHORT);
                Displacement = Displacement + ReadWord(Offset);
                Offset += sizeof(USHORT);
                printf("SAVE_XMM_FAR, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_SAVE_XMM128:
                Count -= 1;
                Displacement = ReadWord(Offset) * 16;
                Offset += sizeof(USHORT);
                printf("SAVE_XMM128, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_SAVE_XMM128_FAR:
                Count -= 2;
                Displacement = ReadWord(Offset) << 16;
                Offset += sizeof(USHORT);
                Displacement = Displacement + ReadWord(Offset);
                Offset += sizeof(USHORT);
                printf("SAVE_XMM128_FAR, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_PUSH_MACHFRAME:
                if (UnwindCode.OpInfo == 0) {
                    printf("PUSH_MACHFRAME without error code\n");

                } else {
                    printf("PUSH_MACHFRAME with error code\n");
                }

                break;
            }

        } while (Count != 0);
    }

    //
    // Dump exception data if there is an excpetion or termination
    // handler.
    //

    if (((UnwindInfo.Flags & UNW_FLAG_EHANDLER) != 0) ||
        ((UnwindInfo.Flags & UNW_FLAG_UHANDLER) != 0)) {

        if ((UnwindInfo.CountOfCodes & 1) != 0) {
            Offset += sizeof(USHORT);
        }

        Handler = ReadDword(Offset);
        Offset += sizeof(ULONG);
        Count = ReadDword(Offset);
        Offset += sizeof(ULONG);
        printf("\n");
        printf("    Language specific handler: 0x%08lX\n", Handler);
        printf("    Count of scope table entries: %d\n\n", Count);
        if (Count != 0) {
            printf("         Begin       End      Handler    Target\n");
            do {
                ReadData(Offset, &ScopeEntry, sizeof(SCOPE_ENTRY));
                printf("      0x%08lX 0x%08lX 0x%08lX 0x%08lX\n",
                       ScopeEntry.BeginAddress,
                       ScopeEntry.EndAddress,
                       ScopeEntry.HandlerAddress,
                       ScopeEntry.JumpTarget);

                Count -= 1;
                Offset += sizeof(SCOPE_ENTRY);
            } while (Count != 0);
        }
    }

    printf("\n");
    return;
}

PIMAGE_SECTION_HEADER
FindSectionHeader (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PCHAR SectionName
    )
{
    ULONG RemainingSections;
    PIMAGE_SECTION_HEADER SectionHeader;

    SectionHeader = SectionHeaders;
    RemainingSections = NumberOfSections;

    while (RemainingSections > 0) {

        if (strncmp(SectionHeader->Name,
                    SectionName,
                    IMAGE_SIZEOF_SHORT_NAME) == 0) {

            return SectionHeader;
        }

        RemainingSections -= 1;
        SectionHeader += 1;
    }

    return NULL;
}

VOID
ReadData (
    IN ULONG Position,
    OUT PVOID Buffer,
    IN ULONG Count
    )

{

    if (fseek(InputFile,
              Position,
              SEEK_SET) == 0) {

        if (fread((PCHAR)Buffer,
                  1,
                  Count,
                  InputFile) == Count) {

           return;
        }
    }

    printf("premature end of file encounterd on inpout file\n");
    exit(0);
}

USHORT
ReadWord (
    IN ULONG Position
    )

{

    USHORT Buffer;

    ReadData(Position, &Buffer, sizeof(USHORT));
    return Buffer;
}

ULONG
ReadDword (
    IN ULONG Position
    )

{

    ULONG Buffer;

    ReadData(Position, &Buffer, sizeof(ULONG));
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vdmperf\draw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Draw.c

Abstract:

   Win32 application to display performance statictics. This routine implements
   graphics output for display windows.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-07-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <math.h>
#include <errno.h>
#include "vdmperf.h"

extern DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
extern VDMPERF_INFO    VdmperfInfo;
extern PUCHAR          PerfNames[];



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Calculate all parameters to fit the given number of
    windows into the app window. Fill out the data structure
    for each sub-window

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/

{
    RECT    ClientRect;
    int     cx,cy;
    UINT    Index;
    int     ActiveWindows,IndexX,IndexY;
    int     WindowsX,WindowsY,WindowWidth,WindowHeight;
    int     LastRowWidth,LoopWidth;
    double  fWindowsX,fActiveWindows,fcx,fcy;

    //
    //  Find out the client area bounds
    //

    GetClientRect(hWnd,&ClientRect);

    cx = ClientRect.right;
    cy = ClientRect.bottom - 2;   // subtract 2 to give a little more border

    //
    //  Find out how many perf windows are active
    //

    ActiveWindows = 0;

    for (Index=0;Index<NumberOfWindows;Index++) {
        if (DisplayItems[Index].Display == TRUE) {
            ActiveWindows++;
        }
    }

    //
    // Return if there are no active windows to display
    //

    if (ActiveWindows == 0) {
        return(TRUE);
    }


    //
    //  Now convert the window dimensions to floating point and
    //  then take the square root of the window dimension to find
    //  out the number of windows in the x direction
    //

    fActiveWindows = 1.0 * ActiveWindows;

    fcx = 1.0 * cx;
    fcy = 1.0 * cy;

    if (fcy != 0.0) {
        fWindowsX = sqrt((fcx * fActiveWindows) / fcy);
    }   else {

        //
        // If fcy = 0 then return since this is an error condition that
        // would cause a divide by zero.
        //

        return(FALSE);
    }

    //
    // convert back to integer
    //

    WindowsX = (int)fWindowsX;

    if (WindowsX == 0) {
        WindowsX = 1;
    } else if (WindowsX > ActiveWindows) {
        WindowsX = ActiveWindows;
    }

    WindowsY = ActiveWindows / WindowsX;

    //
    //  Add on extra line to Y to take care of the left over windows ie:
    //  if there are 15 active windows and the x number = 7 then y = 2 with 1
    //  left over.
    //

    Index = ActiveWindows - (WindowsX * WindowsY);

    if (Index > 0) {
        WindowsY++;
        LastRowWidth = cx / Index;
    } else {
        LastRowWidth = cx / WindowsX;
    }

    WindowWidth  = cx / WindowsX;
    WindowHeight = cy / WindowsY;

    //
    // Assign positions for each active window
    //

    Index  = 0;

    for (IndexY=0;IndexY<WindowsY;IndexY++) {
        for (IndexX=0;IndexX<WindowsX;IndexX++) {

            //
            // Find the next active display item
            //

            while ((DisplayItems[Index].Display != TRUE) && (Index < NumberOfWindows)) {
                Index++;
            }

            //
            //  Add y fixup for last row
            //

            if (IndexY == WindowsY - 1) {
                LoopWidth = LastRowWidth;
            } else {
                LoopWidth = WindowWidth;
            }


            DisplayItems[Index].PositionX = LoopWidth  * IndexX;
            DisplayItems[Index].PositionY = WindowHeight * IndexY + 1;  // +1 for more top border
            DisplayItems[Index].Width     = LoopWidth - 1;
            DisplayItems[Index].Height    = WindowHeight - 1;

            //
            // Last Column fix-up to use all of window.
            //

            if (IndexX == WindowsX - 1) {
                DisplayItems[Index].Width = cx - DisplayItems[Index].PositionX - 1;
            }

            //
            //
            //

            Index++;

            if (Index >= NumberOfWindows) {
                break;
            }

        }


        if (Index >= NumberOfWindows) {
            break;
        }


    }

    return(TRUE);
}



VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Calculate all borders for graphics windows

Arguments:

    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;
    LONG    GraphHeight,TextHeight;
    BOOLEAN TextWindow;

    double  fx1,fx2,fy1;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->PositionX + 2;
    x2 = DisplayItem->PositionX + DisplayItem->Width - 2;
    y1 = DisplayItem->PositionY + 2;
    y2 = DisplayItem->PositionY + DisplayItem->Height - 2;

    //
    // find out in there is enough space for a text window
    //

    if ((y2 - y1 - 12) > 30) {

        TextWindow = TRUE;

        //
        // Calculate dimensions for a text window and a graphics window
        //
        // fx1 = portion of the window - bordres and free space
        //
        // fx2 = fraction of window used for graphics
        //
        // fy1 = fraction of winddow used for text
        //

        fx1 = (y2 - y1 - 10);

        fx2 = fx1 * 0.6666;
        fy1 = fx1 * 0.3333;

        GraphHeight = (LONG)fx2;
        TextHeight  = (LONG)fy1;

        if (TextHeight > 20) {
            GraphHeight += TextHeight-20;
            TextHeight = 20;
        }

        //
        // Calculate window boundaries
        //

        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y1 + 4 + GraphHeight + 1;

        tx1 = x1 + 4;
        tx2 = x2 - 4;
        ty1 = gy2 + 1 + 2 + 1;  // border,free space,border
        ty2 = gy2 + TextHeight + 1;

    }   else {

        TextWindow = FALSE;
        GraphHeight = y2 - y1 - 10;
        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y2 - 4;
        tx1 = tx2 = ty1 = ty2 = 0;

    }

    //
    // Fill in structures for drawing text and graphics
    //

    DisplayItem->Border.left        = x1;
    DisplayItem->Border.right       = x2;
    DisplayItem->Border.top         = y1;
    DisplayItem->Border.bottom      = y2;

    DisplayItem->GraphBorder.left   = gx1;
    DisplayItem->GraphBorder.right  = gx2;
    DisplayItem->GraphBorder.top    = gy1;
    DisplayItem->GraphBorder.bottom = gy2;

    DisplayItem->TextBorder.left    = tx1;
    DisplayItem->TextBorder.right   = tx2;
    DisplayItem->TextBorder.top     = ty1;
    DisplayItem->TextBorder.bottom  = ty2;
}




VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw the window frame for a performance window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    DrawRect;
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->Border.left;
    x2 = DisplayItem->Border.right;
    y1 = DisplayItem->Border.top;
    y2 = DisplayItem->Border.bottom;

    gx1 = DisplayItem->GraphBorder.left;
    gx2 = DisplayItem->GraphBorder.right;
    gy1 = DisplayItem->GraphBorder.top;
    gy2 = DisplayItem->GraphBorder.bottom;

    tx1 = DisplayItem->TextBorder.left;
    tx2 = DisplayItem->TextBorder.right;
    ty1 = DisplayItem->TextBorder.top;
    ty2 = DisplayItem->TextBorder.bottom;

    //
    // Draw top border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y1 + 2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    //
    // Draw Left border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x1 + 2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    //
    // Draw right border in dark shade
    //


    DrawRect.left   = x2 - 2;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // draw bottom in dark shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y2-2;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // Draw graphics area single border
    //

    //
    // Draw top border in dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy1+1;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // Draw Left border in Dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx1 + 1;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // Draw right border in Light shade
    //


    DrawRect.left   = gx2 - 1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    //
    // draw bottom in Light shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy2-1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    if (tx2 > 0) {

        //
        // Draw top border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty1 + 1;

        FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

        //
        // Draw Left border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx1 + 1;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

        //
        // Draw right border in Light shade
        //


        DrawRect.left   = tx2 - 1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

        //
        // draw bottom in Light shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty2-1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    }
}




VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    )
/*++

Routine Description:

    Draw text into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    TextRect;
    UCHAR   TextStr[50];
    UINT    FontSize;

    //
    // Check that text display is enabled
    //

    if (DisplayItem->TextBorder.right == 0) {
        return;
    }

    TextRect.left = DisplayItem->TextBorder.left +1;
    TextRect.right = DisplayItem->TextBorder.right -1;
    TextRect.top = DisplayItem->TextBorder.top +1;
    TextRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&TextRect,VdmperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  TextRect.bottom - TextRect.top;

    if (FontSize >= 15) {
        VdmperfInfo.hOldFont = SelectObject(hDC,VdmperfInfo.LargeFont);
    } else if (FontSize > 10) {
        VdmperfInfo.hOldFont = SelectObject(hDC,VdmperfInfo.MediumFont);
    } else {
        VdmperfInfo.hOldFont = SelectObject(hDC,VdmperfInfo.SmallFont);
    }

    DrawText(
                hDC,
                PerfNames[Item],
                strlen(PerfNames[Item]),
                &TextRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );


    //
    // Build the numeric value
    //

    wsprintf(TextStr,"   %li",DisplayItem->TotalTime[0]);

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &TextRect,
                DT_RIGHT | DT_VCENTER | DT_SINGLELINE
             );




    SelectObject(hDC,VdmperfInfo.hOldFont);

}





VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw graphics into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect;
    ULONG   Scale,i,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth +1;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&MemGraphRect,VdmperfInfo.hBackground);

    MemGraphRect.right  = GraphWidth;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //

    //
    //  Outline object in green
    //



    SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }


    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
        LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->TotalTime[i] * GraphHeight)/DisplayItem->Max);

    }

    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
                    MemGraphRect.right - Scale * i,
                    MemGraphRect.bottom - (DisplayItem->KernelTime[i] * GraphHeight)/DisplayItem->Max
               );

        }

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hGreenPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->UserTime[i] * GraphHeight)/DisplayItem->Max);

        }
    }


    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}

VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Shift memory bitmap 1 location left then draw the 1 new data point.
    BitBlt this to the screen.


Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect,FillArea;
    ULONG   Scale,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    //
    // Shift memory image left by scale
    //


    BitBlt( DisplayItem->MemoryDC,
            0,
            0,
            GraphWidth+1 - Scale,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            Scale,
            0,
            SRCCOPY);


    //
    // Fill The new area on the right of the screen
    //

    FillArea.left   = GraphWidth +1 - Scale;
    FillArea.right  = GraphWidth +1;
    FillArea.top    = 0;
    FillArea.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&FillArea,VdmperfInfo.hBackground);


    //
    // Draw the 1 new data point
    //

    SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    LineTo(DisplayItem->MemoryDC,
            MemGraphRect.right - Scale,
            MemGraphRect.bottom - (DisplayItem->TotalTime[1] * GraphHeight)/DisplayItem->Max);


    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->KernelTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hGreenPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->UserTime[1] * GraphHeight)/DisplayItem->Max
              );

    }


    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}



BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Create a memory context and a memory bitmap for each perf window



Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    int     Width;
    int     Height;

    if (DisplayItem->Display == TRUE) {

        //
        //  Calculate width of memory bitmap needed
        //

        Width  = DisplayItem->GraphBorder.right - DisplayItem->GraphBorder.left;
        Height = DisplayItem->GraphBorder.bottom - DisplayItem->GraphBorder.top;

        if ((Width<=0) || (Height <= 0)) {

            //
            // Disable this window that is to small to be seen
            //

            DisplayItem->Display = FALSE;

            return(TRUE);
        }

        //
        //  Create DC and Bitmap
        //

        DisplayItem->MemoryDC     = CreateCompatibleDC(hDC);

        if (DisplayItem->MemoryDC == NULL) {
            return(FALSE);
        }

        //DbgPrint("Createcompatiblebitmap %i %i\n",Width,Height);

        DisplayItem->MemoryBitmap = CreateCompatibleBitmap(hDC,Width,Height);

        if (DisplayItem->MemoryBitmap == 0) {
            return(FALSE);
        }

        SelectObject(DisplayItem->MemoryDC,DisplayItem->MemoryBitmap);

    }

    return(TRUE);
}



VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Delete memory bitmap and context

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    if (DisplayItem->MemoryDC != NULL) {
        DeleteDC(DisplayItem->MemoryDC);
    }

    if (DisplayItem->MemoryBitmap != NULL) {
        DeleteObject(DisplayItem->MemoryBitmap);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vdmperf\vdmperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Vdmperf.c

Abstract:

   Win32 application to display VDM performance statictics.

Author:

   Mark Lucovsky (stolen from Mark Enstrom  (marke) winperf)

Environment:

   Win32

Revision History:

   11-05-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include "vdmperf.h"



//
// global handles
//

HANDLE  hInst;


//
// Selected Display Mode (read from wp2.ini), default set here.
//

DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
VDMPERF_INFO    VdmperfInfo;


//
// Window names
//

PUCHAR PerfNames[] = {
    "PUSHF",
    "POPF",
    "IRET",
    "HLT",
    "CLI",
    "STI",
    "BOP",
    "SEG_NOT_P",
    "VDMOPCODEF",
    "INTNN",
    "INTO",
    "INB",
    "INW",
    "OUTB",
    "OUTW",
    "INSB",
    "INSW",
    "OUTSB",
    "OUTSW"
};





int
__cdecl
main(USHORT argc, CHAR **argv)
/*++

Routine Description:

   Windows entry point routine


Arguments:

Return Value:

   status of operation

Revision History:

      03-21-91      Initial code

--*/
{

//
//
//

   HANDLE   hInstance     = MGetInstHandle();
   HANDLE   hPrevInstance = (HANDLE)NULL;
   LPSTR    lpCmdLine     = MGetCmdLine();
   INT      nCmdShow      = SW_SHOWDEFAULT;
   USHORT   _argc         = argc;
   CHAR     **_argv       = argv;
   MSG      msg;
   HBRUSH   BackBrush;


    //
    // check for other instances of this program
    //

    BackBrush = CreateSolidBrush(RGB(192,192,192));

    if (!InitApplication(hInstance,BackBrush)) {
        DbgPrint("Init Application fails\n");
        return (FALSE);
    }


    //
    // Perform initializations that apply to a specific instance
    //

    if (!InitInstance(hInstance, nCmdShow)){
        DbgPrint("Init Instance failed\n");
        return (FALSE);
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //


    while (GetMessage(&msg,        // message structure
            (HWND)NULL,            // handle of window receiving the message
            0,                     // lowest message to examine
            0))                    // highest message to examine
        {
        TranslateMessage(&msg);    // Translates virtual key codes
        DispatchMessage(&msg);     // Dispatches message to window
    }

    DeleteObject(BackBrush);

    return ((INT)msg.wParam);           // Returns the value from PostQuitMessage
}




BOOL
InitApplication(
    HANDLE  hInstance,
    HBRUSH  hBackground)

/*++

Routine Description:

   Initializes window data and registers window class.

Arguments:

   hInstance   - current instance
   hBackground - background fill brush

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{
    WNDCLASS  wc;
    BOOL      ReturnStatus;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = CS_DBLCLKS;                          // Class style(s).
    wc.lpfnWndProc   = MainWndProc;                         // Function to retrieve messages for
                                                            // windows of this class.
    wc.cbClsExtra    = 0;                                   // No per-class extra data.
    wc.cbWndExtra    = 0;                                   // No per-window extra data.
    wc.hInstance     = hInstance;                           // Application that owns the class.
    wc.hIcon         = LoadIcon(hInstance,                  //
                            MAKEINTRESOURCE(WINPERF_ICON)); // Load Winperf icon
    wc.hCursor       = LoadCursor((HANDLE)NULL, IDC_ARROW); // Load default cursor
    wc.hbrBackground = hBackground;;                        // Use background passed to routine
    wc.lpszMenuName  = "vdmperfMenu";                       // Name of menu resource in .RC file.
    wc.lpszClassName = "VdmPerfClass";                      // Name used in call to CreateWindow.

    ReturnStatus = RegisterClass(&wc);

    return(ReturnStatus);

}





BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    )

/*++

Routine Description:

   Save instance handle and create main window. This function performs
   initialization tasks that cannot be shared by multiple instances.

Arguments:

    hInstance - Current instance identifier.
    nCmdShow  - Param for first ShowWindow() call.

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{


    DWORD   WindowStyle;

    //
    // Save the instance handle in a static variable, which will be used in
    // many subsequent calls from this application to Windows.
    //

    hInst = hInstance;

    //
    // init the window position and size to be in the upper corner of
    // the screen, 200x100
    //


    //
    //  What I want here is a way to get the WINDOW dimensions
    //

    VdmperfInfo.WindowPositionX = 640 - 200;
    VdmperfInfo.WindowPositionY = 0;
    VdmperfInfo.WindowSizeX     = 200;
    VdmperfInfo.WindowSizeY     = 100;

    //
    //  read profile data from .ini file
    //

    InitProfileData(&VdmperfInfo);

    VdmperfInfo.hMenu = LoadMenu(hInstance,"vdmperfMenu");

    //
    // Create a main window for this application instance.
    //

    VdmperfInfo.hWndMain = CreateWindow(
        "VdmPerfClass",                 // See RegisterClass() call.
        "VDM Perf",                   // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // window style
        VdmperfInfo.WindowPositionX,   // Default horizontal position.
        VdmperfInfo.WindowPositionY,   // Default vertical position.
        VdmperfInfo.WindowSizeX,       // Default width.
        VdmperfInfo.WindowSizeY,       // Default height.
        (HWND)NULL,                     // Overlapped windows have no parent.
        (HMENU)NULL,                    // Use the window class menu.
        hInstance,                      // This instance owns this window.
        (LPVOID)NULL                    // Pointer not needed.
    );

    //
    // Decide on whether or not to display the menu and caption
    // based on the window class read from the .ini file
    //

    if (VdmperfInfo.DisplayMode==STYLE_ENABLE_MENU) {
        VdmperfInfo.DisplayMenu = TRUE;
    } else {
        VdmperfInfo.DisplayMenu = FALSE;
        WindowStyle = GetWindowLong(VdmperfInfo.hWndMain,GWL_STYLE);
        WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
        SetWindowPos(VdmperfInfo.hWndMain, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
        SetWindowLong(VdmperfInfo.hWndMain,GWL_STYLE,WindowStyle);
        SetMenu(VdmperfInfo.hWndMain,NULL);
    }

    //
    // If window could not be created, return "failure"
    //

    if (!VdmperfInfo.hWndMain) {
      return (FALSE);
    }

    //
    // Make the window visible; update its client area; and return "success"
    //

    SetFocus(VdmperfInfo.hWndMain);
    ShowWindow(VdmperfInfo.hWndMain, SW_SHOWNORMAL);
    UpdateWindow(VdmperfInfo.hWndMain);

    return (TRUE);

}



LRESULT
APIENTRY
MainWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   message - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{
    PAINTSTRUCT   ps;

    //
    //   process each message
    //

    switch (message) {

        //
        // create window
        //

        case WM_CREATE:
        {
            HDC hDC = GetDC(hWnd);
            BOOLEAN   Fit;
            UINT      Index;


            //
            // make brushes and pens
            //

            VdmperfInfo.hBluePen     = CreatePen(PS_SOLID,1,RGB(0,0,128));
            VdmperfInfo.hRedPen      = CreatePen(PS_SOLID,1,RGB(255,0,0));
            VdmperfInfo.hGreenPen    = CreatePen(PS_SOLID,1,RGB(0,255,0));
            VdmperfInfo.hDotPen      = CreatePen(PS_DOT,1,RGB(0,0,0));

            VdmperfInfo.hBackground  = CreateSolidBrush(RGB(192,192,192));
            VdmperfInfo.hLightBrush  = CreateSolidBrush(RGB(255,255,255));
            VdmperfInfo.hDarkBrush   = CreateSolidBrush(RGB(128,128,128));
            VdmperfInfo.hRedBrush    = CreateSolidBrush(RGB(255,000,000));
            VdmperfInfo.hGreenBrush  = CreateSolidBrush(RGB(000,255,000));
            VdmperfInfo.hBlueBrush   = CreateSolidBrush(RGB(000,000,255));

            //
            //  create thee fonts using NT default font families
            //

            VdmperfInfo.SmallFont      = CreateFont(8,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Small Fonts");

            VdmperfInfo.MediumFont      = CreateFont(10,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");

            VdmperfInfo.LargeFont      = CreateFont(14,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");


            //
            // create a system timer event to call performance gathering routines by.
            //

            VdmperfInfo.TimerId = SetTimer(hWnd,(UINT)TIMER_ID,(UINT)1000 * DELAY_SECONDS,(TIMERPROC)NULL);

            //
            // init display variables
            //

            InitPerfWindowDisplay(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            //
            //  Fit the perf windows into the main window
            //

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                DbgPrint("FitPerfWindows Fails         !\n");
            }

            for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                CalcDrawFrame(&PerfDataList[Index]);


                if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                    MessageBox(hWnd,"Error Allocating Memory","Vdmperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }

            }

            //
            // init performance routines
            //

            InitPerfInfo();

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);

      }
      break;

      //
      // re-size
      //

      case WM_SIZE:

      {
            int     i;
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;
            BOOLEAN Fit;

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            VdmperfInfo.WindowPositionX = ClientRect.left;
            VdmperfInfo.WindowPositionY = ClientRect.top;
            VdmperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            VdmperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                DbgPrint("WM_SIZE error, FitPerf returns FALSE\n");
            }

            for (i=0;i<SAVE_SUBJECTS;i++) {
                DeleteMemoryContext(&PerfDataList[i]);
                CalcDrawFrame(&PerfDataList[i]);

                if (!CreateMemoryContext(hDC,&PerfDataList[i])) {
                    MessageBox(hWnd,"Error Allocating Memory","Vdmperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }
            }

            //
            // force window to be re-painted
            //

            InvalidateRect(hWnd,(LPRECT)NULL,TRUE);

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);


      }
      break;

      case WM_MOVE:
      {
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            VdmperfInfo.WindowPositionX = ClientRect.left;
            VdmperfInfo.WindowPositionY = ClientRect.top;
            VdmperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            VdmperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            ReleaseDC(hWnd,hDC);
      }

      break;


      //
      // command from application menu
      //

      case WM_COMMAND:


            switch (wParam){

               //
               // exit window
               //

               case IDM_EXIT:

                  DestroyWindow(hWnd);
                  break;

               //
               // about command
               //

            case IDM_SELECT:
            {
                HDC     hDC = GetDC(hWnd);
                int     Index;
                BOOLEAN fit;

                if (DialogBox(hInst,MAKEINTRESOURCE(IDM_SEL_DLG),hWnd,SelectDlgProc) == DIALOG_SUCCESS) {

                    fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

                    if (!fit) {
                        DbgPrint("Fit Fails\n");
                    }

                    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                        DeleteMemoryContext(&PerfDataList[Index]);
                        CalcDrawFrame(&PerfDataList[Index]);

                        if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                            MessageBox(hWnd,"Error Allocating Memory","Vdmperf",MB_OK);
                            DestroyWindow(hWnd);
                            break;
                        }


                    }
                    InvalidateRect(hWnd,(LPRECT)NULL,TRUE);
                }

                ReleaseDC(hWnd,hDC);

            }
            break;


            default:

                return (DefWindowProc(hWnd, message, wParam, lParam));
            }

            break;

        case WM_PAINT:

            //
            // repaint the window
            //

            {
                int i;
                HDC hDC = BeginPaint(hWnd,&ps);

                SelectObject(hDC,GetStockObject(NULL_BRUSH));

                for (i=0;i<SAVE_SUBJECTS;i++) {

                    if (PerfDataList[i].Display == TRUE) {

                        DrawFrame(hDC,&PerfDataList[i]);

                        DrawPerfText(hDC,&PerfDataList[i],i);
                        DrawPerfGraph(hDC,&PerfDataList[i]);

                    }
                }

                EndPaint(hWnd,&ps);
            }
            break;


        case WM_TIMER:
        {
            int i;
            HDC hDC = GetDC(hWnd);

            CalcCpuTime(PerfDataList);

            //
            // update all performance information
            //


            for (i=0;i<SAVE_SUBJECTS;i++) {

                if (PerfDataList[i].Display == TRUE) {

                    DrawPerfText(hDC,&PerfDataList[i],i);

                    if (PerfDataList[i].ChangeScale) {
                        DrawPerfGraph(hDC,&PerfDataList[i]);
                    } else {
                        ShiftPerfGraph(hDC,&PerfDataList[i]);
                    }

                }
            }

            ReleaseDC(hWnd,hDC);

        }
        break;

        //
        // handle a double click
        //

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            DWORD   WindowStyle;


            //
            // get old window style, take out caption and menu
            //

            if (!IsIconic(hWnd)) {

                if (VdmperfInfo.DisplayMenu) {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
                    SetMenu(hWnd,NULL);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    VdmperfInfo.DisplayMode=STYLE_DISABLE_MENU;
                    VdmperfInfo.DisplayMenu = FALSE;

                } else {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
                    SetMenu(hWnd,VdmperfInfo.hMenu);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    VdmperfInfo.DisplayMode=STYLE_ENABLE_MENU;
                    VdmperfInfo.DisplayMenu = TRUE;
                }
            } else {
                DefWindowProc(hWnd, message, wParam, lParam);
            }

        }
        break;

        //
        //  enable dragging with mouse in non-client
        //

        case WM_NCHITTEST:
        {

            lParam = DefWindowProc(hWnd, message, wParam, lParam);
            if ((VdmperfInfo.DisplayMenu==FALSE) && (lParam == HTCLIENT)) {
                return(HTCAPTION);
            } else {
                return(lParam);
            }


        }
        break;

        case WM_DESTROY:
        {
            UINT    Index;

            //
            // Save profile info
            //

            SaveProfileData(&VdmperfInfo);

            //
            // Delete Windows Objects
            //

            KillTimer(hWnd,TIMER_ID);

            DeleteObject(VdmperfInfo.hBluePen);
            DeleteObject(VdmperfInfo.hRedPen);
            DeleteObject(VdmperfInfo.hGreenPen);
            DeleteObject(VdmperfInfo.hBackground);
            DeleteObject(VdmperfInfo.hLightBrush);
            DeleteObject(VdmperfInfo.hDarkBrush);

            for (Index=0;Index<SAVE_SUBJECTS;Index++ ) {
                DeleteMemoryContext(&PerfDataList[Index]);
            }

            //
            // Destroy window
            //

            PostQuitMessage(0);
         }
         break;


        default:

            //
            // Passes message on if unproccessed
            //

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   unsigned message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process message for select dialog box.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    UINT    ButtonState;
    UINT    Index;

    switch (message) {

    case WM_INITDIALOG:

        //
        // Init Buttons with PerfDataList Structure
        //

        for (Index=0;Index<SAVE_SUBJECTS;Index++) {
            int Idm;
            switch ( Index ) {
                case IX_PUSHF       : Idm = IDM_PUSHF     ; break;
                case IX_POPF        : Idm = IDM_POPF      ; break;
                case IX_IRET        : Idm = IDM_IRET      ; break;
                case IX_HLT         : Idm = IDM_HLT       ; break;
                case IX_CLI         : Idm = IDM_CLI       ; break;
                case IX_STI         : Idm = IDM_STI       ; break;
                case IX_BOP         : Idm = IDM_BOP       ; break;
                case IX_SEGNOTP     : Idm = IDM_SEGNOTP   ; break;
                case IX_VDMOPCODEF  : Idm = IDM_VDMOPCODEF; break;
                case IX_INTNN       : Idm = IDM_INTNN     ; break;
                case IX_INTO        : Idm = IDM_INTO      ; break;
                case IX_INB         : Idm = IDM_INB       ; break;
                case IX_INW         : Idm = IDM_INW       ; break;
                case IX_OUTB        : Idm = IDM_OUTB      ; break;
                case IX_OUTW        : Idm = IDM_OUTW      ; break;
                case IX_INSB        : Idm = IDM_INSB      ; break;
                case IX_INSW        : Idm = IDM_INSW      ; break;
                case IX_OUTSB       : Idm = IDM_OUTSB     ; break;
                case IX_OUTSW       : Idm = IDM_OUTSW     ; break;
                }

            //
            // Set or clear radio button based on display variable
            //

            if (PerfDataList[Index].Display == TRUE) {
                CheckDlgButton(hDlg,Idm,1);
            } else {
                CheckDlgButton(hDlg,Idm,0);
            }

        }

        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {

               //
               // end function
               //

           case IDOK:

                //DbgPrint("IDOK: Check button states\n");

                for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                    int Idm;
                    switch ( Index ) {
                        case IX_PUSHF       : Idm = IDM_PUSHF     ; break;
                        case IX_POPF        : Idm = IDM_POPF      ; break;
                        case IX_IRET        : Idm = IDM_IRET      ; break;
                        case IX_HLT         : Idm = IDM_HLT       ; break;
                        case IX_CLI         : Idm = IDM_CLI       ; break;
                        case IX_STI         : Idm = IDM_STI       ; break;
                        case IX_BOP         : Idm = IDM_BOP       ; break;
                        case IX_SEGNOTP     : Idm = IDM_SEGNOTP   ; break;
                        case IX_VDMOPCODEF  : Idm = IDM_VDMOPCODEF; break;
                        case IX_INTNN       : Idm = IDM_INTNN     ; break;
                        case IX_INTO        : Idm = IDM_INTO      ; break;
                        case IX_INB         : Idm = IDM_INB       ; break;
                        case IX_INW         : Idm = IDM_INW       ; break;
                        case IX_OUTB        : Idm = IDM_OUTB      ; break;
                        case IX_OUTW        : Idm = IDM_OUTW      ; break;
                        case IX_INSB        : Idm = IDM_INSB      ; break;
                        case IX_INSW        : Idm = IDM_INSW      ; break;
                        case IX_OUTSB       : Idm = IDM_OUTSB     ; break;
                        case IX_OUTSW       : Idm = IDM_OUTSW     ; break;
                        }
                   ButtonState = IsDlgButtonChecked(hDlg,Idm);
                   if (ButtonState == 1) {
                       PerfDataList[Index].Display = TRUE;
                       VdmperfInfo.DisplayElement[Index] = 1;
                   } else {
                       PerfDataList[Index].Display = FALSE;
                       VdmperfInfo.DisplayElement[Index] = 0;
                   }

                }


                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);

           case IDCANCEL:

                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);


            case IDM_PUSHF     :
            case IDM_POPF      :
            case IDM_IRET      :
            case IDM_HLT       :
            case IDM_CLI       :
            case IDM_STI       :
            case IDM_SEGNOTP   :
            case IDM_BOP       :
            case IDM_VDMOPCODEF:
            case IDM_INTNN     :
            case IDM_INTO      :
            case IDM_INB       :
            case IDM_INW       :
            case IDM_OUTB      :
            case IDM_OUTW      :
            case IDM_INSB      :
            case IDM_INSW      :
            case IDM_OUTSB     :
            case IDM_OUTSW     :

                   //
                   // Turn on or off button
                   //

                   ButtonState = IsDlgButtonChecked(hDlg,(UINT)wParam);

                   //DbgPrint("ButtonState = %i\n",ButtonState);

                   if (ButtonState == 0) {

                       //
                       // Set Button
                       //

                       ButtonState = 1;

                   }  else if (ButtonState == 1) {

                       //
                       // Clear Button
                       //

                       ButtonState = 0;

                   } else {

                       ButtonState = 0;
                   }

                   CheckDlgButton(hDlg,(UINT)wParam,ButtonState);
                   return(TRUE);
        }

    }
    return (FALSE);
}




VOID
InitProfileData(PVDMPERF_INFO pVdmperfInfo)

/*++

Routine Description:

    Attempt tp read the following fields from the vdmperf.ini file

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None, values are set to default before a call to this operation. If there is a problem then
    default:values are left unchanged.

Revision History:

      02-17-91      Initial code

--*/

{
    DWORD   PositionX,PositionY,SizeX,SizeY,Mode,Index,Element[SAVE_SUBJECTS];
    UCHAR   TempStr[256];

    PositionX = GetPrivateProfileInt("vdmperf","PositionX"  ,pVdmperfInfo->WindowPositionX,"vdmperf.ini");
    PositionY = GetPrivateProfileInt("vdmperf","PositionY"  ,pVdmperfInfo->WindowPositionY,"vdmperf.ini");
    SizeX     = GetPrivateProfileInt("vdmperf","SizeX"      ,pVdmperfInfo->WindowSizeX    ,"vdmperf.ini");
    SizeY     = GetPrivateProfileInt("vdmperf","SizeY"      ,pVdmperfInfo->WindowSizeY    ,"vdmperf.ini");

    //
    // read the first deiplay element with default 1
    //

    Element[0] = GetPrivateProfileInt("vdmperf","DisplayElement0",1,"vdmperf.ini");

    //
    // read the rest of the display elements with default 0
    //

    for (Index=1;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"DisplayElement%i",Index);
        Element[Index] = GetPrivateProfileInt("vdmperf",TempStr,0,"vdmperf.ini");
    }

    Mode      = GetPrivateProfileInt("vdmperf","DisplayMode",pVdmperfInfo->DisplayMode    ,"vdmperf.ini");

    pVdmperfInfo->WindowPositionX = PositionX;
    pVdmperfInfo->WindowPositionY = PositionY;
    pVdmperfInfo->WindowSizeX     = SizeX;
    pVdmperfInfo->WindowSizeY     = SizeY;

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        pVdmperfInfo->DisplayElement[Index] = Element[Index];
    }
    pVdmperfInfo->DisplayMode     = Mode;
}




VOID
SaveProfileData(PVDMPERF_INFO pVdmperfInfo)

/*++

Routine Description:

    Save profile data

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None.

Revision History:

      02-17-91      Initial code

--*/

{
    UCHAR    TempStr[50],TempName[50];
    UINT     Index;

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowPositionX);
    WritePrivateProfileString("vdmperf","PositionX",TempStr,"vdmperf.ini");

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowPositionY);
    WritePrivateProfileString("vdmperf","PositionY",TempStr,"vdmperf.ini");

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowSizeX);
    WritePrivateProfileString("vdmperf","SizeX",TempStr,"vdmperf.ini");

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowSizeY);
    WritePrivateProfileString("vdmperf","SizeY",TempStr,"vdmperf.ini");

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"%li",pVdmperfInfo->DisplayElement[Index]);
        wsprintf(TempName,"DisplayElement%li",Index);
        WritePrivateProfileString("vdmperf",TempName,TempStr,"vdmperf.ini");

    }


    wsprintf(TempStr,"%li",pVdmperfInfo->DisplayMode);
    WritePrivateProfileString("vdmperf","DisplayMode",TempStr,"vdmperf.ini");

}









BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Init All perf windows to active, init data

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/
{
    int     Index1;
    UINT    Index;

    for (Index=0;Index<NumberOfWindows;Index++) {

        if (VdmperfInfo.DisplayElement[Index] == 0) {
            DisplayItems[Index].Display = FALSE;
        } else {
            DisplayItems[Index].Display = TRUE;
        }

        DisplayItems[Index].CurrentDrawingPos = 0;

        DisplayItems[Index].NumberOfElements = 1;

        for (Index1=0;Index1<DATA_LIST_LENGTH;Index1++) {
            DisplayItems[Index].KernelTime[Index1] = 0;
            DisplayItems[Index].UserTime[Index1] = 0;
            DisplayItems[Index].TotalTime[Index1] = 0;
        }
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vdmperf\vdmperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.h

Abstract:

   This module contains the definit

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _WINPERFH_INCLUDED_
#define _WINPERFH_INCLUDED_

#define DIALOG_SUCCESS  100
#define DIALOG_CANCEL   0

#define IDM_EXIT        1100
#define IDM_SELECT      1101
#define IDM_ALL         1103
#define TIMER_ID        1001
#define IDM_IO_GRP      1002
#define IDM_OP_GRP      1003
#define IDM_SEL_DLG     1004
#define IDM_STYLE_GRP   1005


#define IDM_INSB        101
#define IDM_INSW        102
#define IDM_OUTSB       103
#define IDM_OUTSW       104
#define IDM_INB         105
#define IDM_INW         106
#define IDM_OUTB        107
#define IDM_OUTW        108
#define IDM_VDMOPCODEF  109
#define IDM_PUSHF       110
#define IDM_POPF        111
#define IDM_INTNN       112
#define IDM_INTO        113
#define IDM_IRET        114
#define IDM_HLT         115
#define IDM_CLI         116
#define IDM_STI         117
#define IDM_BOP         118
#define IDM_SEGNOTP     119

#define WINPERF_ICON 1011


#include "calcperf.h"

typedef struct _VDMPERF_INFO
{
    DWORD   WindowPositionX;
    DWORD   WindowPositionY;
    DWORD   WindowSizeX;
    DWORD   WindowSizeY;
    DWORD   DisplayElement[SAVE_SUBJECTS];
    DWORD   DisplayMode;
    HPEN    hBluePen;
    HPEN    hRedPen;
    HPEN    hGreenPen;
    HPEN    hDotPen;
    HBRUSH  hBackground;
    HBRUSH  hRedBrush;
    HBRUSH  hGreenBrush;
    HBRUSH  hBlueBrush;
    HBRUSH  hLightBrush;
    HBRUSH  hDarkBrush;
    HFONT   LargeFont;
    HFONT   MediumFont;
    HFONT   SmallFont;
    HFONT   hOldFont;
    HMENU   hMenu;
    HWND    hWndMain;
    UINT_PTR TimerId;
    BOOL    DisplayMenu;
} VDMPERF_INFO,*PVDMPERF_INFO;

BOOL
InitApplication(
   HANDLE hInstance,
   HBRUSH hBackground
   );

BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    );

LRESULT APIENTRY
MainWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM DWORD,
   LPARAM lParam
   );



INT_PTR APIENTRY
CpuWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM DWORD,
   LPARAM lParam
   );


INT_PTR
APIENTRY About(
   HWND     hDlg,
   unsigned message,
   WPARAM   DWORD,
   LPARAM   lParam
   );

#include <port1632.h>


VOID
UpdateCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient
   );

VOID
DrawCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient,
   IN   ULONG DisplayItem
   );

VOID
ReScalePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   );

ULONG
InitPerfInfo(VOID);


VOID
InitProfileData(PVDMPERF_INFO pVdmperfInfo);

VOID
SaveProfileData(PVDMPERF_INFO pVdmperfInfo);

VOID
DrawPerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );


VOID
UpdatePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

//
//  change style constants
//

#define STYLE_ENABLE_MENU  WS_OVERLAPPEDWINDOW
#define STYLE_DISABLE_MENU (WS_THICKFRAME+WS_BORDER)


LONG APIENTRY
DbgWndProc(
   HWND   hWnd,
   UINT   message,
   DWORD  wParam,
   LONG   lParam
   );



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );


BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   unsigned message,
   WPARAM wParam,
   LPARAM lParam
   );

VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    );


VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawCpuBarGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

#endif /* _WINPERFH_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\cmdline.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CmdLine.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "CmdLine.h"
#include "VrfUtil.h"
#include "VGlobal.h"

/////////////////////////////////////////////////////////////////////////////
//
// Execute command line
//

DWORD CmdLineExecute( INT argc, TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    BOOL bHaveNewFlags;
    BOOL bHaveNewDrivers;
    BOOL bHaveVolatile;
    BOOL bVolatileAddDriver;
    BOOL bHaveDisk;
    DWORD dwExitCode;
    DWORD dwNewFlags;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CStringArray astrNewDrivers;
    CString strAllDrivers;

    dwExitCode = EXIT_CODE_SUCCESS;

    //
    // See if the user asked for help
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfHelp( argc,
                                                argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done printing out the help strings
        //

        goto Done;
    }

    //
    // See if the user asked to reset all the existing verifier settings
    // 

    bFoundCmdLineSwitch = CmdLineFindResetSwitch( argc,
                                                  argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        if( VrfDeleteAllVerifierSettings() )
        {
            if( FALSE != g_bSettingsSaved )
            {
                //
                // Had some non-void verifier settings before 
                //

                dwExitCode = EXIT_CODE_REBOOT_NEEDED;
                
                VrfMesssageFromResource( IDS_REBOOT );
            }
            else
            {
                //
                // Nothing has changed
                //

                dwExitCode = EXIT_CODE_SUCCESS;

                VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
            }
        }
        else
        {
            dwExitCode = EXIT_CODE_ERROR;
        }

        goto Done;

        //
        // We are deleting the settings
        //
    }

    //
    // See if we need to start logging statistics
    //

    bFoundCmdLineSwitch = CmdLineExecuteIfLog( argc,
                                               argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done logging
        //

        goto Done;
    }

    //
    // See if the user asked to dump the current statistics 
    // to the console
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfQuery( argc,
                                                 argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done with the query
        //

        goto Done;
    }

    //
    // See if the user asked to dump the current registry settings 
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfQuerySettings( argc,
                                                         argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done with the settings query
        //

        goto Done;
    }

    //
    // Get the new flags, drivers and volatile 
    // if they have been specified
    //

    bHaveNewFlags = FALSE;
    bHaveNewDrivers = FALSE;
    bHaveVolatile = FALSE;
    bHaveDisk = FALSE;

    CmdLineGetFlagsDriversVolatileDisk(
        argc,
        argv,
        dwNewFlags,
        bHaveNewFlags,
        astrNewDrivers,
        bHaveNewDrivers,
        bHaveVolatile,
        bVolatileAddDriver,
        bHaveDisk);

    //
    // Enable or disable the disk verifier for all disks.
    //

    g_NewVerifierSettings.m_aDiskData.SetVerifyAllDisks( bHaveDisk );
    g_NewVerifierSettings.m_aDiskData.SaveNewSettings();

    if( FALSE != bHaveNewFlags || FALSE != bHaveNewDrivers )
    {
        //
        // Some new drivers, disks and/or flags have been specified.
        //

        if( FALSE != bHaveVolatile )
        {
            if( FALSE != bHaveNewFlags || FALSE != bHaveNewDrivers )
            {
                //
                // Have new volative settings
                //

                if( bHaveNewFlags )
                {
                    VrfSetNewFlagsVolatile( dwNewFlags );
                }
                else
                {
                    if( astrNewDrivers.GetSize() > 0 )
                    {
                        //
                        // Have some new drivers to add or remove
                        // from the verify list
                        //

                        if( bVolatileAddDriver )
                        {
                            //
                            // Add some drivers
                            //

                            VrfAddDriversVolatile( astrNewDrivers );
                        }
                        else
                        {
                            //
                            // Remove some drivers
                            //

                            VrfRemoveDriversVolatile( astrNewDrivers );
                        }
                    }
                }
            }
        }
        else
        {
            //
            // Have new persistent settings (registry)
            //

            //
            // Try to get the old settings
            //

            VrtLoadCurrentRegistrySettings( g_bAllDriversVerified,
                                            g_astrVerifyDriverNamesRegistry,
                                            g_dwVerifierFlagsRegistry );

            if( bHaveNewDrivers )
            {
                //
                // Concat all the new driver names in only one string,
                // separated with spaces
                //

                nDrivers = astrNewDrivers.GetSize();

                for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
                {
                    if( strAllDrivers.GetLength() > 0 )
                    {
                        strAllDrivers += _T( ' ' );
                    }

                    strAllDrivers += astrNewDrivers.ElementAt( nCrtDriver );
                }
            }

            //
            // If:
            //
            // - we are switching to "all drivers verified" OR
            // - we are switching to a new set of drivers to be verified OR
            // - we are switching to other verifier flags
            //

            if( ( bHaveNewDrivers && 
                  strAllDrivers.CompareNoCase( _T( "*" ) ) == 0 && 
                  TRUE != g_bAllDriversVerified )       ||

                ( bHaveNewDrivers && 
                  strAllDrivers.CompareNoCase( _T( "*" ) ) != 0 && 
                  VrfIsDriversSetDifferent( strAllDrivers, g_astrVerifyDriverNamesRegistry ) ) ||

                ( bHaveNewFlags && dwNewFlags != g_dwVerifierFlagsRegistry ) )
            {
                //
                // These are different settings from what we had before
                //

                VrfWriteVerifierSettings( bHaveNewDrivers,
                                          strAllDrivers,
                                          bHaveNewFlags,
                                          dwNewFlags );
            }
        }
    }

    if( g_bSettingsSaved )
    {
        VrfMesssageFromResource( IDS_NEW_SETTINGS );

        g_OldDiskData = g_NewVerifierSettings.m_aDiskData;

        VrfDumpRegistrySettingsToConsole();

        _putts( _T("\n" ) );

        VrfMesssageFromResource( IDS_REBOOT );
    }
    else
    {
        VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
    }

Done:

    return dwExitCode;
}


/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked for help and print out the help strings
// 

BOOL CmdLineExecuteIfHelp( INT argc, 
                           TCHAR *argv[] )
{
    BOOL bPrintedHelp;
    TCHAR szCmdLineSwitch[ 64 ];

    bPrintedHelp = FALSE;

    VERIFY( VrfLoadString( IDS_HELP_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for help switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[ 1 ], szCmdLineSwitch) == 0)
    {
        CmdLinePrintHelpInformation();

        bPrintedHelp = TRUE;
    }

    return bPrintedHelp;
}

/////////////////////////////////////////////////////////////////////////////
VOID CmdLinePrintHelpInformation()
{
    VrfTPrintfResourceFormat( IDS_HELP_LINE1, VER_PRODUCTVERSION_STR );

    puts( VER_LEGALCOPYRIGHT_STR );

    VrfPrintStringFromResources( IDS_HELP_LINE3 );
    VrfPrintStringFromResources( IDS_HELP_LINE4 );
    VrfPrintStringFromResources( IDS_HELP_LINE5 );
    VrfPrintStringFromResources( IDS_HELP_LINE6 );
    VrfPrintStringFromResources( IDS_HELP_LINE7 );
    VrfPrintStringFromResources( IDS_HELP_LINE8 );
    VrfPrintStringFromResources( IDS_HELP_LINE9 );
    VrfPrintStringFromResources( IDS_HELP_LINE10 );
    VrfPrintStringFromResources( IDS_HELP_LINE11 );
    VrfPrintStringFromResources( IDS_HELP_LINE12 );
    VrfPrintStringFromResources( IDS_HELP_LINE13 );
    VrfPrintStringFromResources( IDS_HELP_LINE14 );
    VrfPrintStringFromResources( IDS_HELP_LINE15 );
    VrfPrintStringFromResources( IDS_HELP_LINE16 );
    VrfPrintStringFromResources( IDS_HELP_LINE17 );
    VrfPrintStringFromResources( IDS_HELP_LINE18 );
    VrfPrintStringFromResources( IDS_HELP_LINE19 );
    VrfPrintStringFromResources( IDS_HELP_LINE20 );
    VrfPrintStringFromResources( IDS_HELP_LINE21 );
    VrfPrintStringFromResources( IDS_HELP_LINE22 );
    VrfPrintStringFromResources( IDS_HELP_LINE23 );
    VrfPrintStringFromResources( IDS_HELP_LINE24 );
    VrfPrintStringFromResources( IDS_HELP_LINE25 );
    VrfPrintStringFromResources( IDS_HELP_LINE26 );
    VrfPrintStringFromResources( IDS_HELP_LINE27 );
    VrfPrintStringFromResources( IDS_HELP_LINE28 );
    VrfPrintStringFromResources( IDS_HELP_LINE29 );
    VrfPrintStringFromResources( IDS_HELP_LINE30 );
    VrfPrintStringFromResources( IDS_HELP_LINE31 );
}

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked to reset all the existing verifier settings
// 

BOOL CmdLineFindResetSwitch( INT argc,
                             TCHAR *argv[] )
{
    BOOL bFound;
    TCHAR szCmdLineOption[ 64 ];

    bFound = FALSE;

    if( 2 == argc )
    {
        VERIFY( VrfLoadString( IDS_RESET_CMDLINE_SWITCH,
                               szCmdLineOption,
                               ARRAY_LENGTH( szCmdLineOption ) ) );

        bFound = ( _tcsicmp( argv[ 1 ], szCmdLineOption) == 0 );
    }

    return bFound;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to start logging statistics
//

BOOL CmdLineExecuteIfLog( INT argc,
                          TCHAR *argv[] )
{
    INT nCrtArg;
    BOOL bStartLogging;
    LPCTSTR szLogFileName;
    DWORD dwLogMillisec;
    FILE *file;
    TCHAR szLogCmdLineOption[ 64 ];
    TCHAR szIntervalCmdLineOption[ 64 ];

    bStartLogging = FALSE;

    szLogFileName = NULL;

    if( argc < 2 )
    {
        //
        // Need at least /log LOG_FILE_NAME IN THE CMD LINE
        //

        goto Done;
    }
    
    //
    // Default log period - 30 sec
    //

    dwLogMillisec = 30000; 

    VERIFY( VrfLoadString( IDS_LOG_CMDLINE_SWITCH,
                           szLogCmdLineOption,
                           ARRAY_LENGTH( szLogCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_INTERVAL_CMDLINE_SWITCH,
                           szIntervalCmdLineOption,
                           ARRAY_LENGTH( szIntervalCmdLineOption ) ) );


    for( nCrtArg = 1; nCrtArg < argc - 1; nCrtArg += 1 )
    {
        if( _tcsicmp( argv[ nCrtArg ], szLogCmdLineOption) == 0 )
        {
            //
            // Start logging
            //

            bStartLogging = TRUE;

            szLogFileName = argv[ nCrtArg + 1 ];
        }
        else
        {
            if( _tcsicmp( argv[ nCrtArg ], szIntervalCmdLineOption) == 0 )
            {
                //
                // Logging period
                //

                dwLogMillisec = _ttoi( argv[ nCrtArg + 1 ] ) * 1000;
            }
        }
    }

    if( TRUE == bStartLogging )
    {
        ASSERT( szLogFileName != NULL );

        while( TRUE )
        {
            //
            // Open the file
            //

            file = _tfopen( szLogFileName, TEXT("a+") );

            if( file == NULL )
            {
                //
                // print a error message
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_APPEND_FILE,
                    szLogFileName );

                break;
            }

            //
            // Dump current information
            //

            if( ! VrfDumpStateToFile ( file ) ) 
            {
                //
                // Insufficient disk space ?
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_WRITE_FILE,
                    szLogFileName );
            }

            fflush( file );

            VrfFTPrintf(
                file,
                TEXT("\n\n") );

            //
            // Close the file
            //

            fclose( file );

            //
            // Sleep
            //

            Sleep( dwLogMillisec );
        }
    }

Done:
    return bStartLogging;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuery( INT argc,
                            TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    TCHAR szCmdLineSwitch[ 64 ];

    bFoundCmdLineSwitch = FALSE;

    VERIFY( VrfLoadString( IDS_QUERY_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for our switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[1], szCmdLineSwitch) == 0)
    {
        bFoundCmdLineSwitch = TRUE;

        VrfDumpStateToFile( stdout );
    }

    return bFoundCmdLineSwitch;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuerySettings( INT argc,
                                    TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    TCHAR szCmdLineSwitch[ 64 ];

    bFoundCmdLineSwitch = FALSE;

    VERIFY( VrfLoadString( IDS_QUERYSETT_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for our switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[1], szCmdLineSwitch) == 0)
    {
        bFoundCmdLineSwitch = TRUE;

        VrfDumpRegistrySettingsToConsole();
    }

    return bFoundCmdLineSwitch;
}

/////////////////////////////////////////////////////////////////////////////
//
// Get the new flags, drivers and volatile 
// if they have been specified
//

VOID CmdLineGetFlagsDriversVolatileDisk( INT argc,
                                         TCHAR *argv[],
                                         DWORD &dwNewFlags,
                                         BOOL &bHaveNewFlags,
                                         CStringArray &astrNewDrivers,
                                         BOOL &bHaveNewDrivers,
                                         BOOL &bHaveVolatile,
                                         BOOL &bVolatileAddDriver,
                                         BOOL &bHaveDisk)
{
    INT nCrtArg;
    NTSTATUS Status;
    UNICODE_STRING ustrFlags;
    TCHAR szFlagsCmdLineOption[ 64 ];
    TCHAR szDiskCmdLineOption[ 64 ];
    TCHAR szAllCmdLineOption[ 64 ];
    TCHAR szVolatileCmdLineOption[ 64 ];
    TCHAR szDriversCmdLineOption[ 64 ];
    TCHAR szAddDriversCmdLineOption[ 64 ];
    TCHAR szRemoveDriversCmdLineOption[ 64 ];
    TCHAR szStandardCmdLineOption[ 64 ];
#ifndef UNICODE
    //
    // ANSI
    //

    INT nNameLength;
    LPWSTR szUnicodeName;
#endif //#ifndef UNICODE
 
    astrNewDrivers.RemoveAll();

    bHaveNewFlags = FALSE;
    bHaveNewDrivers = FALSE;
    bHaveVolatile = FALSE;
    bHaveDisk = FALSE;

    //
    // Load the switches from the resources
    //

    VERIFY( VrfLoadString( IDS_FLAGS_CMDLINE_SWITCH,
                           szFlagsCmdLineOption,
                           ARRAY_LENGTH( szFlagsCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_DISK_CMDLINE_SWITCH,
                           szDiskCmdLineOption,
                           ARRAY_LENGTH( szDiskCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_ALL_CMDLINE_SWITCH,
                           szAllCmdLineOption,
                           ARRAY_LENGTH( szAllCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_DONTREBOOT_CMDLINE_SWITCH,
                           szVolatileCmdLineOption,
                           ARRAY_LENGTH( szVolatileCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_DRIVER_CMDLINE_SWITCH,
                           szDriversCmdLineOption,
                           ARRAY_LENGTH( szDriversCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_ADDDRIVER_CMDLINE_SWITCH,
                           szAddDriversCmdLineOption,
                           ARRAY_LENGTH( szAddDriversCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_REMOVEDRIVER_CMDLINE_SWITCH,
                           szRemoveDriversCmdLineOption,
                           ARRAY_LENGTH( szRemoveDriversCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_STANDARD_CMDLINE_SWITCH,
                           szStandardCmdLineOption,
                           ARRAY_LENGTH( szStandardCmdLineOption ) ) );
    //
    // Parse all the cmd line arguments, looking for ours
    //

    for( nCrtArg = 1; nCrtArg < argc; nCrtArg += 1 )
    {
        if( _tcsicmp( argv[ nCrtArg ], szFlagsCmdLineOption) == 0 )
        {
            if( nCrtArg < argc - 1 )
            {
                //
                // Not the last cmd line arg - look for the flags next
                //
                
#ifdef UNICODE
                //
                // UNICODE
                //
                
                RtlInitUnicodeString( &ustrFlags,
                                      argv[ nCrtArg + 1 ] );

#else
                //
                // ANSI
                //

                nNameLength = strlen( argv[ nCrtArg + 1 ] );

                szUnicodeName = new WCHAR[ nNameLength + 1 ];

                if( NULL == szUnicodeName )
                {
                    VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

                    goto DoneWithFlags;
                }

                MultiByteToWideChar( CP_ACP, 
                                     0, 
                                     argv[ nCrtArg + 1 ], 
                                     -1, 
                                     szUnicodeName, 
                                     nNameLength + 1 );

                RtlInitUnicodeString( &ustrFlags,
                                      szUnicodeName );
#endif 
                Status = RtlUnicodeStringToInteger( &ustrFlags,
                                                    0,
                                                    &dwNewFlags );

                if( NT_SUCCESS( Status ) )
                {
                    bHaveNewFlags = TRUE;
                }

#ifndef UNICODE
                //
                // ANSI
                //

                ASSERT( NULL != szUnicodeName );

                delete [] szUnicodeName;
                
                szUnicodeName = NULL;

DoneWithFlags:
                NOTHING;
#endif 
            }
        }
        else if( _tcsicmp( argv[ nCrtArg ], szDiskCmdLineOption) == 0 )
        {
            //
            // Verify all disks.
            //

            bHaveVolatile = FALSE;

            bHaveDisk = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szAllCmdLineOption) == 0 )
        {
            //
            // Verify all drivers.
            //

            bHaveVolatile = FALSE;

            astrNewDrivers.Add( _T( '*' ) );

            bHaveNewDrivers = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szStandardCmdLineOption) == 0 )
        {
            //
            // Standard verifier flags.
            //

            dwNewFlags = VrfGetStandardFlags();

            bHaveNewFlags = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szVolatileCmdLineOption) == 0 )
        {
            //
            // Volatile
            //

            bHaveVolatile = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szDriversCmdLineOption) == 0 )
        {
            //
            // /Driver
            //

            bHaveVolatile = FALSE;

            CmdLineGetDriversFromArgv( argc,
                                       argv,
                                       nCrtArg + 1,
                                       astrNewDrivers,
                                       bHaveNewDrivers );

            //
            // All done - all the rest of argumentshave been driver names
            //

            break;
        }
        else if( bHaveVolatile && _tcsicmp( argv[ nCrtArg ], szAddDriversCmdLineOption) == 0 )
        {
            //
            // /adddriver
            //

            bVolatileAddDriver = TRUE;

            CmdLineGetDriversFromArgv( argc,
                                       argv,
                                       nCrtArg + 1,
                                       astrNewDrivers,
                                       bHaveNewDrivers );

            //
            // All done - all the rest of argumentshave been driver names
            //

            break;
        }
        else if( bHaveVolatile && _tcsicmp( argv[ nCrtArg ], szRemoveDriversCmdLineOption) == 0 )
        {
            //
            // /removedriver
            //

            bVolatileAddDriver = FALSE;

            CmdLineGetDriversFromArgv( argc,
                                       argv,
                                       nCrtArg + 1,
                                       astrNewDrivers,
                                       bHaveNewDrivers );

            //
            // All done - all the rest of arguments have been driver names
            //

            break;
        }
    }

    //
    // If we have new drivers look if they are miniports
    //

    if( bHaveNewDrivers )
    {
        VrfAddMiniports( astrNewDrivers );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Everything that follows after /driver, /adddriver, /removedriver
// should be driver names. Extract these from the command line
//

VOID CmdLineGetDriversFromArgv(  INT argc,
                                 TCHAR *argv[],
                                 INT nFirstDriverArgIndex,
                                 CStringArray &astrNewDrivers,
                                 BOOL &bHaveNewDrivers )
{
    INT nDriverArg;

    bHaveNewDrivers = FALSE;
    astrNewDrivers.RemoveAll();

    //
    // Everything in the command line from here on should be driver names
    //

    for( nDriverArg = nFirstDriverArgIndex; nDriverArg < argc; nDriverArg += 1 )
    {
        astrNewDrivers.Add( argv[ nDriverArg ] );
    }

    bHaveNewDrivers = ( astrNewDrivers.GetSize() > 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\csetpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CSetPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "CSetPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_CUSTSETT_PREDEF_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CUSTSETT_PREDEF_RADIO,      IDH_DV_EnablePredefined,
    IDC_CUSTSETT_FULLLIST_RADIO,    IDH_DV_IndividualSettings,
    IDC_CUSTSETT_TYPICAL_CHECK,     IDH_DV_Standard,
    IDC_CUSTSETT_EXCESS_CHECK,      IDH_DV_Rigorous,
    IDC_CUSTSETT_LOWRES_CHECK,      IDH_DV_LowResource,
    IDC_CUSTSETT_DISK_CHECK,        IDH_DV_DiskCheck,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CCustSettPage property page

IMPLEMENT_DYNCREATE(CCustSettPage, CVerifierPropertyPage)

CCustSettPage::CCustSettPage() 
    : CVerifierPropertyPage( CCustSettPage::IDD )
{
    //{{AFX_DATA_INIT(CCustSettPage)
    m_bTypicalTests = FALSE;
    m_bExcessiveTests = FALSE;
    m_bLowResTests = FALSE;
    m_bDiskTests = FALSE;
    m_nCrtRadio = -1;
    //}}AFX_DATA_INIT
}

CCustSettPage::~CCustSettPage()
{
}

void CCustSettPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustSettPage)
    DDX_Control(pDX, IDC_CUSTSETT_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_CUSTSETT_TYPICAL_CHECK, m_TypicalTestsCheck);
    DDX_Control(pDX, IDC_CUSTSETT_LOWRES_CHECK, m_LowresTestsCheck);
    DDX_Control(pDX, IDC_CUSTSETT_DISK_CHECK, m_DiskTestsCheck);
    DDX_Control(pDX, IDC_CUSTSETT_EXCESS_CHECK, m_ExcessTestsCheck);
    DDX_Check(pDX, IDC_CUSTSETT_TYPICAL_CHECK, m_bTypicalTests);
    DDX_Check(pDX, IDC_CUSTSETT_EXCESS_CHECK, m_bExcessiveTests);
    DDX_Check(pDX, IDC_CUSTSETT_LOWRES_CHECK, m_bLowResTests);
    DDX_Check(pDX, IDC_CUSTSETT_DISK_CHECK, m_bDiskTests);
    DDX_Radio(pDX, IDC_CUSTSETT_PREDEF_RADIO, m_nCrtRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCustSettPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CCustSettPage)
    ON_BN_CLICKED(IDC_CUSTSETT_FULLLIST_RADIO, OnFulllistRadio)
    ON_BN_CLICKED(IDC_CUSTSETT_PREDEF_RADIO, OnPredefRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CCustSettPage::EnablePredefCheckboxes( BOOL bEnable )
{
    m_TypicalTestsCheck.EnableWindow( bEnable );
    m_LowresTestsCheck.EnableWindow( bEnable );
    m_ExcessTestsCheck.EnableWindow( bEnable );
    m_DiskTestsCheck.EnableWindow( bEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CCustSettPage message handlers


/////////////////////////////////////////////////////////////////////////////
LRESULT CCustSettPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        if( IDC_CUSTSETT_PREDEF_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio )
        {
            //
            // Use predefined settings
            //

            if( FALSE == m_bTypicalTests     &&
                FALSE == m_bExcessiveTests   && 
                FALSE == m_bLowResTests      &&
                FALSE == m_bDiskTests )
            {
                //
                // No tests are currently selected - we cannot continue
                //

                VrfErrorResourceFormat( IDS_NO_TESTS_SELECTED );
            }
            else
            {
                //
                // Set our data according to the GUI
                //

                //
                // Use predefined settings
                //

                g_NewVerifierSettings.m_SettingsBits.EnableTypicalTests( m_bTypicalTests );
    
                g_NewVerifierSettings.m_SettingsBits.EnableExcessiveTests( m_bExcessiveTests );

                g_NewVerifierSettings.m_SettingsBits.EnableLowResTests( m_bLowResTests );

                g_bShowDiskPropertyPage = m_bDiskTests;

                //
                // Go to the next page
                //

                if( FALSE != m_bTypicalTests ||
                    FALSE != m_bExcessiveTests ||
                    FALSE != m_bLowResTests )
                {
                    //
                    // We have at least one type of test that applies to drivers.
                    //

                    lNextPageId = IDD_DRVSET_PAGE;
                }
                else
                {
                    //
                    // Only the disk integrity checking is enabled.
                    //

                    ASSERT( FALSE != m_bDiskTests );

                    lNextPageId = IDD_DISK_LIST_PAGE;
                }
            }
        }
        else
        {
            //
            // Select the tests to be performed from a full list
            //

            lNextPageId = IDD_FULL_LIST_SETT_PAGE;
        }
    }

    if( -1 != lNextPageId )
    {
        //
        // Have some valid custom settings and we are going to the next page
        //

        g_NewVerifierSettings.m_SettingsBits.m_SettingsType = CSettingsBits::SettingsTypeCustom;
    }

    GoingToNextPageNotify( lNextPageId );
    
	return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CCustSettPage::OnWizardBack() 
{
    g_bShowDiskPropertyPage = FALSE;
	
	return CVerifierPropertyPage::OnWizardBack();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCustSettPage::OnInitDialog() 
{
    //
    // Don't try to reconstruct the current data from the registry
    // to the GUI because it's too hard. Always start with standard tests.
    //

    m_nCrtRadio = IDC_CUSTSETT_PREDEF_RADIO - FIRST_RADIO_BUTTON_ID;

    m_bTypicalTests     = TRUE;
    m_bExcessiveTests   = FALSE;
    m_bLowResTests      = FALSE;
    m_bDiskTests        = FALSE;

    CVerifierPropertyPage::OnInitDialog();

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_PREDEFINED );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CCustSettPage::OnFulllistRadio() 
{
    EnablePredefCheckboxes( FALSE );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_LIST );
}

/////////////////////////////////////////////////////////////////////////////
void CCustSettPage::OnPredefRadio() 
{
    EnablePredefCheckboxes( TRUE );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_PREDEFINED );
}

/////////////////////////////////////////////////////////////
BOOL CCustSettPage::OnSetActive() 
{
    m_pParentSheet->SetWizardButtons( PSWIZB_NEXT |
                                      PSWIZB_BACK );
	
	return CVerifierPropertyPage::OnSetActive();
}
/////////////////////////////////////////////////////////////
LONG CCustSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CCustSettPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\cdlpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CDLPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_CDLPAGE_H__7A756DBE_9A1C_4558_80EA_53E7AC45A6A4__INCLUDED_)
#define AFX_CDLPAGE_H__7A756DBE_9A1C_4558_80EA_53E7AC45A6A4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CDLPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CConfirmDriverListPage dialog

class CConfirmDriverListPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CConfirmDriverListPage)

// Construction
public:
	CConfirmDriverListPage();
	~CConfirmDriverListPage();

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    BOOL SetContextStrings( ULONG uTitleResId );

    VOID SortTheList();
    BOOL GetColumnStrValue( LPARAM lItemData, 
                            CString &strName );

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

protected:
    VOID SetupListHeader();
    VOID FillTheList();

    VOID AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData );

protected:
    //
    // Dialog Data
    //

    CPropertySheet      *m_pParentSheet;

    CString             m_strTitle;

    INT m_nSortColumnIndex;        // driver name (0) or provider name (1)
    BOOL m_bAscendSortDrvName;     // sort ascendent the driver names
    BOOL m_bAscendSortProvName;    // sort ascendent the provider names


	//{{AFX_DATA(CConfirmDriverListPage)
	enum { IDD = IDD_CONFIRM_DRIVERS_PAGE };
	CStatic	m_NextDescription;
	CButton	m_TitleStatic;
	CListCtrl	m_DriversList;
	//}}AFX_DATA

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CConfirmDriverListPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CConfirmDriverListPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnColumnclickConfdrvList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CDLPAGE_H__7A756DBE_9A1C_4558_80EA_53E7AC45A6A4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\csetpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CSetPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_CSETPAGE_H__4DAAEAE1_F3E9_42D0_B0F5_5FAC8C40A12B__INCLUDED_)
#define AFX_CSETPAGE_H__4DAAEAE1_F3E9_42D0_B0F5_5FAC8C40A12B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CSetPage.h : header file
//

#include "vsetting.h"
#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CCustSettPage dialog

class CCustSettPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CCustSettPage)

public:
    //
    // Construction
    //

	CCustSettPage();
	~CCustSettPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Methods
    //
    
    VOID EnablePredefCheckboxes( BOOL bEnable );

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Dialog Data
    //

    //{{AFX_DATA(CCustSettPage)
    enum { IDD = IDD_CUSTSETT_PAGE };
    CStatic	m_NextDescription;
    CButton	m_TypicalTestsCheck;
    CButton	m_LowresTestsCheck;
    CButton	m_ExcessTestsCheck;
    CButton m_DiskTestsCheck;
    BOOL	m_bTypicalTests;
    BOOL	m_bExcessiveTests;
    BOOL	m_bIndividialTests;
    BOOL	m_bLowResTests;
    BOOL    m_bDiskTests;
    int		m_nCrtRadio;
    //}}AFX_DATA


    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CCustSettPage)
    public:
    virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CCustSettPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnFulllistRadio();
    afx_msg void OnPredefRadio();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CSETPAGE_H__4DAAEAE1_F3E9_42D0_B0F5_5FAC8C40A12B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\cmdline.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CmdLine.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#ifndef __CMD_LINE_H_INCLUDED__
#define __CMD_LINE_H_INCLUDED__

/////////////////////////////////////////////////////////////////////////////
//
// Execute command line
//

DWORD CmdLineExecute( INT argc, 
                      TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked for help and print out the help strings
// 

BOOL CmdLineExecuteIfHelp( INT argc, 
                           TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// Print out help information
//

VOID CmdLinePrintHelpInformation();

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked to reset all the existing verifier settings
// 

BOOL CmdLineFindResetSwitch( INT argc,
                             TCHAR *argv[] );


/////////////////////////////////////////////////////////////////////////////
//
// See if we need to start logging statistics
//

BOOL CmdLineExecuteIfLog( INT argc,
                          TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to start logging statistics
//

BOOL CmdLineExecuteIfQuery( INT argc,
                            TCHAR *argv[] );


/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuerySettings( INT argc,
                                    TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// Get the new flags, drivers and volatile 
// if they have been specified
//

VOID CmdLineGetFlagsDriversVolatileDisk( INT argc,
                                         TCHAR *argv[],
                                         DWORD &dwNewFlags,
                                         BOOL &bHaveNewFlags,
                                         CStringArray &astrNewDrivers,
                                         BOOL &bHaveNewDrivers,
                                         BOOL &bHaveVolatile,
                                         BOOL &bVolatileAddDriver,  // TRUE if /adddriver, FALSE if /removedriver
                                         BOOL &bHaveDisk);    

/////////////////////////////////////////////////////////////////////////////
//
// Everything that follows after /driver, /adddriver, /removedriver
// should be driver names. Extract these from the command line
//

VOID CmdLineGetDriversFromArgv(  INT argc,
                                 TCHAR *argv[],
                                 INT nFirstDriverArgIndex,
                                 CStringArray &astrNewDrivers,
                                 BOOL &bHaveNewDrivers );

#endif //#ifndef __CMD_LINE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\cdlpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: CDLPage.cpp
// author: DMihai
// created: 11/1/00
//

#include "stdafx.h"
#include "verifier.h"

#include "CDLPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CONFDRV_LIST,               IDH_DV_UnsignedDriversList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CConfirmDriverListPage property page

IMPLEMENT_DYNCREATE(CConfirmDriverListPage, CVerifierPropertyPage)

CConfirmDriverListPage::CConfirmDriverListPage() 
    : CVerifierPropertyPage(CConfirmDriverListPage::IDD)
{
	//{{AFX_DATA_INIT(CConfirmDriverListPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pParentSheet = NULL;

    m_nSortColumnIndex = 0;
    m_bAscendSortDrvName = FALSE;
    m_bAscendSortProvName = FALSE;
}

CConfirmDriverListPage::~CConfirmDriverListPage()
{
}

void CConfirmDriverListPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfirmDriverListPage)
	DDX_Control(pDX, IDC_CONFDRV_NEXT_DESCR_STATIC, m_NextDescription);
	DDX_Control(pDX, IDC_CONFDRV_TITLE_STATIC, m_TitleStatic);
	DDX_Control(pDX, IDC_CONFDRV_LIST, m_DriversList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfirmDriverListPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CConfirmDriverListPage)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_CONFDRV_LIST, OnColumnclickConfdrvList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::SetupListHeader()
{
    LVCOLUMN lvColumn;
    CString strName;
    CString strDescription;
    CRect rectWnd;
    
    VERIFY( strName.LoadString( IDS_NAME ) );
    VERIFY( strDescription.LoadString( IDS_DESCRIPTION ) );

    //
    // list's regtangle
    //

    m_DriversList.GetClientRect( &rectWnd );
  
    //
    // Column 0
    //

    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.30 );
    lvColumn.pszText = strName.GetBuffer( strName.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
        strName.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.65 );
    lvColumn.pszText = strDescription.GetBuffer( strDescription.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
        strDescription.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::FillTheList()
{
    INT_PTR nDriversNo;
    INT_PTR nCrtDriverIndex;
    CDriverData *pCrtDrvData;
    const CDriverDataArray &DrvDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;

    m_DriversList.DeleteAllItems();

    //
    // Parse the driver data array
    //

    nDriversNo = DrvDataArray.GetSize();

    for( nCrtDriverIndex = 0; nCrtDriverIndex < nDriversNo; nCrtDriverIndex += 1)
    {
        pCrtDrvData = DrvDataArray.GetAt( nCrtDriverIndex );

        ASSERT_VALID( pCrtDrvData );

        if( g_NewVerifierSettings.m_DriversSet.ShouldDriverBeVerified( pCrtDrvData ) )
        {
            AddListItem( nCrtDriverIndex, 
                         pCrtDrvData );
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData )
{
    INT nActualIndex;
    LVITEM lvItem;

    ASSERT_VALID( pCrtDrvData );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0
    //

    lvItem.pszText = pCrtDrvData->m_strName.GetBuffer( pCrtDrvData->m_strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nIndexInArray;
    lvItem.iItem = m_DriversList.GetItemCount();
    lvItem.iSubItem = 0;
    
    nActualIndex = m_DriversList.InsertItem( &lvItem );
    
    pCrtDrvData->m_strName.ReleaseBuffer();

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1
    //

    lvItem.pszText = pCrtDrvData->m_strFileDescription.GetBuffer( 
        pCrtDrvData->m_strFileDescription.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;

    m_DriversList.SetItem( &lvItem );

    pCrtDrvData->m_strFileDescription.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::SetContextStrings( ULONG uTitleResId )
{
    return m_strTitle.LoadString( uTitleResId );
}

/////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::SortTheList()
{
    m_DriversList.SortItems( StringCmpFunc, (LPARAM)this );
}

/////////////////////////////////////////////////////////////
int CALLBACK CConfirmDriverListPage::StringCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    CString strName1;
    CString strName2;

    CConfirmDriverListPage *pThis = (CConfirmDriverListPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first name
    //

    bSuccess = pThis->GetColumnStrValue( lParam1, 
                                         strName1 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetColumnStrValue( lParam2, 
                                         strName2 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = strName1.CompareNoCase( strName2 );
    
    if( 0 == pThis->m_nSortColumnIndex )
    {
        //
        // Sort by driver name
        //

        if( FALSE != pThis->m_bAscendSortDrvName )
        {
            nCmpRez *= -1;
        }
    }
    else
    {
        //
        // Sort by provider name
        //

        if( FALSE != pThis->m_bAscendSortProvName )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}
/////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::GetColumnStrValue( LPARAM lItemData, 
                                                CString &strName )
{
    CDriverData *pCrtDrvData;

    pCrtDrvData = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetAt( (INT_PTR) lItemData );

    ASSERT_VALID( pCrtDrvData );
    
    if( 0 == m_nSortColumnIndex )
    {
        //
        // Sort by driver name
        //

        strName = pCrtDrvData->m_strName;
    }
    else
    {
        //
        // Sort by provider name
        //

        strName = pCrtDrvData->m_strCompanyName;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::OnSetActive() 
{
    INT nItemsInList;
    BOOL bResult;

    m_TitleStatic.SetWindowText( m_strTitle );

    FillTheList();
    SortTheList();
    
    nItemsInList = m_DriversList.GetItemCount();

    if( nItemsInList < 1 )
    {
        //
        // No drivers have been selected to be verified
        //

        bResult = FALSE;
    }
    else
    {
        
        if( (FALSE == g_bShowDiskPropertyPage) &&
            (FALSE == g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk()) )
        {
            //
            // This is the last step of the wizard
            //

            m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                                PSWIZB_FINISH );

            VrfSetWindowText( m_NextDescription, IDS_CONFDRV_PAGE_NEXT_DESCR_FINISH );
        }
        else
        {
            //
            // We need to show the "select disks" page at the end.
            //

            m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                                PSWIZB_NEXT );

            VrfSetWindowText( m_NextDescription, IDS_CONFDRV_PAGE_NEXT_DESCR_NEXT );
        }

        bResult = CVerifierPropertyPage::OnSetActive();
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CConfirmDriverListPage message handlers

BOOL CConfirmDriverListPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();
	
    //
    // Setup the list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_DriversList.GetExtendedStyle() );

    SetupListHeader();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::OnWizardFinish() 
{
    //
    // The disk verifier should be disabled if we got here.
    //

    ASSERT( FALSE == g_bShowDiskPropertyPage );
    ASSERT( FALSE == g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk() );

    CVerifierPropertyPage::OnWizardFinish();

    return g_NewVerifierSettings.SaveToRegistry();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CConfirmDriverListPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    //
    // The disk verifier should be enabled if we got here.
    //

    ASSERT( FALSE != g_bShowDiskPropertyPage ||
            FALSE != g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk() );

    lNextPageId = IDD_DISK_LIST_PAGE;

    GoingToNextPageNotify( lNextPageId );

    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
void CConfirmDriverListPage::OnColumnclickConfdrvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the provider name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortProvName = !m_bAscendSortProvName;
        }
    }
    else
    {
        //
        // Clicked on the driver name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortDrvName = !m_bAscendSortDrvName;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CConfirmDriverListPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CConfirmDriverListPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\dcntpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DCntPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "DCntPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_PERDRVC_DRIVER_COMBO,       IDH_DV_Counters_DriverList,
    IDC_PERDRVC_LIST,               IDH_DV_DriverCounters,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDriverCountersPage property page

IMPLEMENT_DYNCREATE(CDriverCountersPage, CVerifierPropertyPage)

CDriverCountersPage::CDriverCountersPage() : CVerifierPropertyPage(CDriverCountersPage::IDD)
{
	//{{AFX_DATA_INIT(CDriverCountersPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 0;
    m_bAscendSortName = FALSE;
    m_bAscendSortValue = FALSE;

    m_uTimerHandler = 0;

    m_pParentSheet = NULL;
}

CDriverCountersPage::~CDriverCountersPage()
{
}

void CDriverCountersPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // Query the kernel
        //

        VrfGetRuntimeVerifierData( &m_RuntimeVerifierData );
    }

    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDriverCountersPage)
    DDX_Control(pDX, IDC_PERDRVC_DRIVER_COMBO, m_DriversCombo);
    DDX_Control(pDX, IDC_PERDRVC_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_PERDRVC_LIST, m_CountersList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverCountersPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CDriverCountersPage)
    ON_WM_TIMER()
    ON_CBN_SELENDOK(IDC_PERDRVC_DRIVER_COMBO, OnSelendokDriverCombo)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PERDRVC_LIST, OnColumnclickPerdrvcList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////

VOID CDriverCountersPage::SetupListHeader()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strCounter, strValue;
    
    VERIFY( strCounter.LoadString( IDS_COUNTER ) );
    VERIFY( strValue.LoadString( IDS_VALUE ) );

    //
    // List's regtangle
    //

    m_CountersList.GetClientRect( &rectWnd );
    
    //
    // Column 0 - counter
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.50 );
    lvColumn.pszText = strCounter.GetBuffer( strCounter.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_CountersList.InsertColumn( 0, &lvColumn ) != -1 );
        strCounter.ReleaseBuffer();
    }
    else 
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_CountersList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    lvColumn.pszText = strValue.GetBuffer( strValue.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_CountersList.InsertColumn( 1, &lvColumn ) != -1 );
        strValue.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_CountersList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::FillTheList()
{
    CRuntimeDriverData *pRuntimeDriverData;

    pRuntimeDriverData = GetCurrentDrvRuntimeData();

    AddAllListItems( pRuntimeDriverData );
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::AddAllListItems( CRuntimeDriverData *pRuntimeDriverData )
{
    if( NULL != pRuntimeDriverData )
    {
        ASSERT_VALID( pRuntimeDriverData );

        //
        // N.B.
        //
        // If you change this order then you need to change GetCounterValue as well
        //

        AddCounterInList( 0, IDS_CURRENTPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->CurrentPagedPoolAllocations );
        AddCounterInList( 1, IDS_PEAKPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->PeakPagedPoolAllocations );
        AddCounterInList( 2, IDS_PAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->PagedPoolUsageInBytes );
        AddCounterInList( 3, IDS_PEAKPAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->PeakPagedPoolUsageInBytes );

        AddCounterInList( 4, IDS_CURRENTNONPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->CurrentNonPagedPoolAllocations );
        AddCounterInList( 5, IDS_PEAKNONPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->PeakNonPagedPoolAllocations );
        AddCounterInList( 6, IDS_NONPAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->NonPagedPoolUsageInBytes );
        AddCounterInList( 7, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->PeakNonPagedPoolUsageInBytes );
    }
    else
    {
        //
        // N.B.
        //
        // If you change this order then you need to change GetCounterValue as well
        //

        AddCounterInList( 0, IDS_CURRENTPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 1, IDS_PEAKPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 2, IDS_PAGEDPOOLUSAGEINBYTES_LIST );
        AddCounterInList( 3, IDS_PEAKPAGEDPOOLUSAGEINBYTES_LIST );

        AddCounterInList( 4, IDS_CURRENTNONPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 5, IDS_PEAKNONPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 6, IDS_NONPAGEDPOOLUSAGEINBYTES_LIST );
        AddCounterInList( 7, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES_LIST );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::RefreshTheList()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtCounterIndex;
    SIZE_T sizeValue;
    CRuntimeDriverData *pRuntimeDriverData;

    pRuntimeDriverData = GetCurrentDrvRuntimeData();

    nListItems = m_CountersList.GetItemCount();

    if( NULL != pRuntimeDriverData )
    {
        for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
        {
            nCrtCounterIndex = m_CountersList.GetItemData( nCrtListItem );

            sizeValue = GetCounterValue( nCrtCounterIndex, pRuntimeDriverData );

            UpdateCounterValueInList( nCrtListItem, sizeValue );
        }
    }
    else
    {
        //
        // N.B.
        //
        // If you change this order then you need to
        // change AddAllListItems as well
        //

        for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
        {
            UpdateCounterValueInList( nCrtListItem, g_szVoidText );
        }
    }

    SortTheList();
}

/////////////////////////////////////////////////////////////
INT CDriverCountersPage::AddCounterInList( INT nItemData, 
                                           ULONG  uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    nActualIndex = -1;

    VERIFY( strName.LoadString( uIdResourceString ) );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - counter's name
    //

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_CountersList.GetItemCount();

    nActualIndex = m_CountersList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

Done:
    //
    // All done
    //

    return nActualIndex;
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::AddCounterInList( INT nItemData, 
                                            ULONG  uIdResourceString,
                                            SIZE_T sizeValue )
{
    INT nActualIndex;

    nActualIndex = AddCounterInList( nItemData, uIdResourceString );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - counter's value
    //
    
    UpdateCounterValueInList( nActualIndex,
                              sizeValue );

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
SIZE_T CDriverCountersPage::GetCounterValue( INT_PTR nCounterIndex, CRuntimeDriverData *pRuntimeDriverData /*= NULL*/ )
{
    SIZE_T sizeValue;

    if( NULL == pRuntimeDriverData )
    {
        pRuntimeDriverData = GetCurrentDrvRuntimeData();
    }

    if( NULL == pRuntimeDriverData )
    {
        //
        // No driver is curently selected in the combo
        //

        return 0;
    }
    
    //
    // N.B. 
    //
    // If you change this switch statement you need to change AddAllListItems as well
    //

    switch( nCounterIndex )
    {
    case 0:
        sizeValue = pRuntimeDriverData->CurrentPagedPoolAllocations;
        break;

    case 1:
        sizeValue = pRuntimeDriverData->PeakPagedPoolAllocations;
        break;

    case 2:
        sizeValue = pRuntimeDriverData->PagedPoolUsageInBytes;
        break;

    case 3:
        sizeValue = pRuntimeDriverData->PeakPagedPoolUsageInBytes;
        break;

    case 4:
        sizeValue = pRuntimeDriverData->CurrentNonPagedPoolAllocations;
        break;

    case 5:
        sizeValue = pRuntimeDriverData->PeakNonPagedPoolAllocations;
        break;

    case 6:
        sizeValue = pRuntimeDriverData->NonPagedPoolUsageInBytes;
        break;

    case 7:
        sizeValue = pRuntimeDriverData->PeakNonPagedPoolUsageInBytes;
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        sizeValue = 0;

        break;
    }

    return sizeValue;
}

/////////////////////////////////////////////////////////////
BOOL CDriverCountersPage::GetCounterName( LPARAM lItemData, 
                                          TCHAR *szCounterName,
                                          ULONG uCounterNameBufferLen )
{
    INT nItemIndex;
    BOOL bResult;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    bResult = FALSE;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lItemData;

    nItemIndex = m_CountersList.FindItem( &FindInfo );

    if( nItemIndex < 0 || nItemIndex > 7 )
    {
        ASSERT( FALSE );
    }
    else
    {
        //
        // Found our item - get the name
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 0;
        lvItem.pszText = szCounterName;
        lvItem.cchTextMax = uCounterNameBufferLen;

        bResult = m_CountersList.GetItem( &lvItem );
        
        if( bResult == FALSE )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bResult;
}


/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::UpdateCounterValueInList( INT nItemIndex,
                                                    LPTSTR szValue )
{
    LVITEM lvItem;

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = szValue;
    VERIFY( m_CountersList.SetItem( &lvItem ) );
}


/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::UpdateCounterValueInList( INT nItemIndex,
                                                    SIZE_T sizeValue )
{
    TCHAR szValue[ 32 ];

#ifndef _WIN64

    //
    // 32 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%u" ),
                sizeValue );

#else

    //
    // 64 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%I64u" ),
                sizeValue );

#endif

    szValue[ ARRAY_LENGTH( szValue ) - 1 ] = 0;

    UpdateCounterValueInList( nItemIndex,
                              szValue );
                              
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::RefreshCombo()
{
    BOOL *pbAlreadyInCombo;
    CRuntimeDriverData *pRuntimeDriverData;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    INT nCrtSelectedItem;
    INT nCrtItemIndex;
    INT nComboItemCount;
    INT nActualIndex;
    CString strCurrentDriverName;
    CString strDriverName;

    nDrivers = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( 0 >= nDrivers )
    {
        //
        // No drivers are currently verified - delete the combo-box content
        //

        m_DriversCombo.ResetContent();
        m_DriversCombo.SetCurSel( CB_ERR );
        m_DriversCombo.EnableWindow( FALSE );

        OnSelendokDriverCombo();
    }
    else
    {
        nCrtSelectedItem = 0;
        nComboItemCount = m_DriversCombo.GetCount();

        //
        // Note the currently selected driver name
        //

        GetCurrentSelDriverName( strCurrentDriverName );

        //
        // Allocate an array of BOOL values, one for each driver in
        // our runtime data array
        //

        pbAlreadyInCombo = new BOOL[ nDrivers ];

        if( NULL == pbAlreadyInCombo )
        {
            goto Done;
        }

        for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver++ )
        {
            pbAlreadyInCombo[ nCrtDriver ] = FALSE;
        }

        //
        // Parse all the items currently in the combo-box
        //

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DriversCombo.GetLBText( nCrtItemIndex, strDriverName );

            //
            // Parse all the currently verified drivers
            //

            for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver++ )
            {
                pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver );

                ASSERT_VALID( pRuntimeDriverData );

                if( strDriverName.CompareNoCase( pRuntimeDriverData->m_strName ) == 0 )
                {
                    pbAlreadyInCombo[ nCrtDriver ] = TRUE;

                    break;
                }
            }

            if( nCrtDriver >= nDrivers )
            {
                //
                // We need to delete the current combo item because
                // the corresponfing driver is no longer verified 
                //

                m_DriversCombo.DeleteString( nCrtItemIndex );

                nCrtItemIndex--;
                nComboItemCount--;
            }
        }

        //
        // Add the new items in the combo
        //

        for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver++ )
        {
            if( FALSE == pbAlreadyInCombo[ nCrtDriver ] )
            {
                pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver );

                ASSERT_VALID( pRuntimeDriverData );

                nActualIndex = m_DriversCombo.AddString( pRuntimeDriverData->m_strName );

                if( nActualIndex != CB_ERR )
                {   
                    m_DriversCombo.SetItemData( nActualIndex, nCrtDriver );
                }   
            }
        }

        delete [] pbAlreadyInCombo;

        //
        // Restore the old current selection in the combo
        //

        nComboItemCount = m_DriversCombo.GetCount();

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DriversCombo.GetLBText( nCrtItemIndex, strDriverName );

            if( strDriverName.CompareNoCase( strCurrentDriverName ) == 0 )
            {
                nCrtSelectedItem = nCrtItemIndex;
                break;
            }
        }

        m_DriversCombo.SetCurSel( nCrtSelectedItem );
        OnSelendokDriverCombo();
     }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::RefreshInfo() 
{
    if( UpdateData( FALSE ) )
    {
        //
        // Refresh the combo content - this will also 
        // refresh the counters list
        //

        RefreshCombo();
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::GetCurrentSelDriverName( CString &strName )
{
    INT nCrtSel;

    nCrtSel = m_DriversCombo.GetCurSel();

    if( CB_ERR != nCrtSel )
    {
        m_DriversCombo.GetLBText( nCrtSel, strName );
    }
    else
    {
        strName.Empty();
    }
}

/////////////////////////////////////////////////////////////
CRuntimeDriverData *CDriverCountersPage::GetCurrentDrvRuntimeData()
{
    INT nCrtComboSelection;
    INT_PTR nCrtDriverIndex;
    CRuntimeDriverData *pRuntimeDriverData;

    pRuntimeDriverData = NULL;

    nCrtDriverIndex = -1;

    nCrtComboSelection = m_DriversCombo.GetCurSel();
    
    if( nCrtComboSelection != CB_ERR )
    {
        nCrtDriverIndex = m_DriversCombo.GetItemData( nCrtComboSelection );

        if( nCrtDriverIndex >= 0 && nCrtDriverIndex < m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() )
        {
            pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriverIndex );

            ASSERT_VALID( pRuntimeDriverData );
        }
    }

    return pRuntimeDriverData;
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by counter value - this is probably not very useful
        // but we are providing it to be consistent with all
        // the lists being sortable by any column
        //

        m_CountersList.SortItems( CounterValueCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by driver name
        //

        m_CountersList.SortItems( CounterNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverCountersPage::CounterValueCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    SIZE_T size1;
    SIZE_T size2;
    int nCmpRez = 0;

    CDriverCountersPage *pThis = (CDriverCountersPage *)lParamSort;
    ASSERT_VALID( pThis );

    size1 = pThis->GetCounterValue( (INT) lParam1 );
    size2 = pThis->GetCounterValue( (INT) lParam2 );

    if( size1 > size2 )
    {
        nCmpRez = 1;
    }
    else
    {
        if( size1 < size2 )
        {
            nCmpRez = -1;
        }
    }

    if( FALSE != pThis->m_bAscendSortValue )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverCountersPage::CounterNameCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szCounterName1[ _MAX_PATH ];
    TCHAR szCounterName2[ _MAX_PATH ];

    CDriverCountersPage *pThis = (CDriverCountersPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first counter name
    //

    bSuccess = pThis->GetCounterName( lParam1, 
                                      szCounterName1,
                                      ARRAY_LENGTH( szCounterName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second counter name
    //

    bSuccess = pThis->GetCounterName( lParam2, 
                                      szCounterName2,
                                      ARRAY_LENGTH( szCounterName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szCounterName1, szCounterName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}


/////////////////////////////////////////////////////////////
// CDriverCountersPage message handlers

BOOL CDriverCountersPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // Setup the settings bits list
    //

    m_CountersList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_CountersList.GetExtendedStyle() );

    m_CountersList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_CountersList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeader();
    FillTheList();
    SortTheList();

    RefreshCombo();

    VrfSetWindowText( m_NextDescription, IDS_DCNT_PAGE_NEXT_DESCR );

    VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
                                        5000,
                                        NULL ) );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        ASSERT_VALID( m_pParentSheet );

        if( m_pParentSheet->GetActivePage() == this )
        {
            //
            // Refresh the displayed data 
            //

            RefreshInfo();
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverCountersPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_FINISH );
    	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////
void CDriverCountersPage::OnSelendokDriverCombo() 
{
    RefreshTheList();
}

/////////////////////////////////////////////////////////////
void CDriverCountersPage::OnColumnclickPerdrvcList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the counter value column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortValue = !m_bAscendSortValue;
        }
    }
    else
    {
        //
        // Clicked on the counter name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CDriverCountersPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverCountersPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\dcntpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DCntPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_DCNTPAGE_H__49C83C54_F12D_4A9C_A6F3_D25F988B337D__INCLUDED_)
#define AFX_DCNTPAGE_H__49C83C54_F12D_4A9C_A6F3_D25F988B337D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DCntPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverCountersPage dialog

class CDriverCountersPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDriverCountersPage)

public:
    //
    // Construction
    //

	CDriverCountersPage();
	~CDriverCountersPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    VOID SetupListHeader();

    VOID FillTheList();
    VOID AddAllListItems( CRuntimeDriverData *pRuntimeDriverData );
    VOID RefreshTheList();
    
    INT AddCounterInList( INT nItemData, 
                          ULONG  uIdResourceString );

    VOID AddCounterInList( INT nItemData, 
                           ULONG  uIdResourceString,
                           SIZE_T sizeValue );
    
    SIZE_T GetCounterValue( INT_PTR nCounterIndex,
                            CRuntimeDriverData *pRuntimeDriverData = NULL);

    BOOL   GetCounterName( LPARAM lItemData, 
                           TCHAR *szCounterName,
                           ULONG uCounterNameBufferLen );

    VOID UpdateCounterValueInList( INT nItemIndex,
                                   LPTSTR szValue );
    VOID UpdateCounterValueInList( INT nItemIndex,
                                   SIZE_T sizeValue );


    VOID RefreshInfo();
    VOID RefreshCombo();
    
    VOID GetCurrentSelDriverName( CString &strName );
    CRuntimeDriverData *GetCurrentDrvRuntimeData();

    VOID SortTheList();

    static int CALLBACK CounterValueCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK CounterNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Dialog Data
    //

    INT m_nSortColumnIndex;     // counter name (0) or counter value (1)
    BOOL m_bAscendSortName;     // sort ascendent the counter names
    BOOL m_bAscendSortValue;    // sort ascendent the counter values

    UINT_PTR m_uTimerHandler;   // timer handler, returned by SetTimer()

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Dialog data
    //

    //{{AFX_DATA(CDriverCountersPage)
	enum { IDD = IDD_PERDRIVER_COUNTERS_PAGE };
	CComboBox	m_DriversCombo;
	CStatic	m_NextDescription;
	CListCtrl	m_CountersList;
    int m_nUpdateIntervalIndex;
	//}}AFX_DATA

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDriverCountersPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CDriverCountersPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnTimer(UINT nIDEvent);
    afx_msg void OnSelendokDriverCombo();
    afx_msg void OnColumnclickPerdrvcList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DCNTPAGE_H__49C83C54_F12D_4A9C_A6F3_D25F988B337D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\disk.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    disk.h

Abstract:

    This utility adds and removes lower filter drivers
    for a given disk

Author:
    Sidhartha
   
Environment:

    User mode only

Notes:

    - the filter is not checked for validity before it is added to the driver
      stack; if an invalid filter is added, the device may no longer be
      accessible.
    - all code works irrespective of character set (ANSI, Unicode, ...)

Revision History:



--*/

#ifndef __VERIFIER_DISK_H__
#define __VERIFIER_DISK_H__

#ifdef __cplusplus
extern "C"
{
#endif //#ifdef __cplusplus


BOOLEAN 
DiskEnumerate(
    IN LPTSTR Filter,
    OUT LPTSTR* DiskDevicesForDisplayP,
    OUT LPTSTR* DiskDevicesPDONameP,
    OUT LPTSTR* VerifierEnabledP
    );

BOOLEAN
AddFilter(
    IN LPTSTR Filter,
    IN LPTSTR DiskDevicesPDONameP
    );

BOOLEAN
DelFilter(
    IN LPTSTR Filter,
    IN LPTSTR DiskDevicesPDONameP
    );

BOOLEAN
FreeDiskMultiSz( 
    IN LPTSTR MultiSz
    );


#ifdef __cplusplus
}; //extern "C"
#endif //#ifdef __cplusplus


#endif // #ifndef __VERIFIER_DISK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\disk.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    disk.c

Abstract:

    This utility adds and removes lower filter drivers
    for a given disk

Author:
    Sidhartha
   
Environment:

    User mode only

Notes:

    - the filter is not checked for validity before it is added to the driver
      stack; if an invalid filter is added, the device may no longer be
      accessible.
    - all code works irrespective of character set (ANSI, Unicode, ...)

Revision History:



--*/

#include <stdafx.h>
#include <setupapi.h>
#include <initguid.h>
#include <ntddstor.h>
#include <ntddvol.h>

#include "verifier.h"
#include "disk.h"
#include "VrfUtil.h"

#define GETVOLUMEPATH_MAX_LEN_RETRY   1000


#ifdef __cplusplus
extern "C"
{
#endif //#ifdef __cplusplus

typedef 
BOOLEAN 
(*DISK_ENUMERATE_CALLBACK)(
    PVOID,
    HDEVINFO,
    SP_DEVINFO_DATA*
    );

BOOLEAN
AddFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    );

BOOLEAN
RemoveFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    );

BOOLEAN
PrintFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters,
    IN LPTSTR FilterDriver,
    IN OUT LPTSTR *VerifierEnabled
    );

LPTSTR
GetFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    );

BOOLEAN 
PrintDeviceName(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN OUT LPTSTR *DiskDevicesForDisplay,
    IN OUT LPTSTR *DiskDevicesPDOName
    );

BOOLEAN
DeviceNameMatches(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR DeviceName
    );

PBYTE
GetDeviceRegistryProperty(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD Property,
    OUT PDWORD PropertyRegDataType
    );

BOOLEAN
PrependSzToMultiSz(
    IN     LPTSTR  SzToPrepend,
    IN OUT LPTSTR *MultiSz
    );

SIZE_T
GetMultiSzLength(
    IN LPTSTR MultiSz
    );

SIZE_T
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPTSTR  FindThis,
    IN  LPTSTR  FindWithin,
    OUT SIZE_T  *NewStringLength
    );


BOOLEAN 
DiskVerify(
    DISK_ENUMERATE_CALLBACK CallBack,
    PVOID Context,
    LPTSTR deviceName
    );

BOOLEAN 
DiskEnumerateCallback (
    PVOID Context,
    HDEVINFO DevInfo,
    SP_DEVINFO_DATA *DevInfoData
    );

BOOLEAN  
AddCallback (
    PVOID Context,
    HDEVINFO DevInfo,
    SP_DEVINFO_DATA *DevInfoData
    );

BOOLEAN  
DelCallback (
    PVOID Context,
    HDEVINFO DevInfo,
    SP_DEVINFO_DATA *DevInfoData
    );

LPTSTR 
GetDriveLetters (
    IN HDEVINFO DeviceInfoSet,
	IN PSP_DEVINFO_DATA DeviceInfoData
    );

LPTSTR 
GetDriveLettersFromVolume (
    IN ULONG  DeviceNumber
    );

LPTSTR 
PrintDriveLetters(
    IN  PTSTR   VolumeName
    );


BOOLEAN
StrConcatWithSpace(
    IN     LPTSTR  SzToAppend,
    IN OUT LPTSTR *drives
    );

typedef struct _DISPLAY_STRUCT{
    LPTSTR  Filter;
    LPTSTR* DiskDevicesForDisplay;
    LPTSTR* DiskDevicesPDOName;
    LPTSTR* VerifierEnabled;
    }DISPLAY_STRUCT, 
    *PDISPLAY_STRUCT;

typedef struct _ADD_REMOVE_STRUCT{
    LPTSTR Filter;
    }ADD_REMOVE_STRUCT, 
    *PADD_REMOVE_STRUCT;


BOOLEAN 
DiskEnumerate(
    IN LPTSTR Filter,
    OUT LPTSTR* DiskDevicesForDisplayP,
    OUT LPTSTR* DiskDevicesPDONameP,
    OUT LPTSTR* VerifierEnabledP
    )                

/*++

Routine Description:

    This function enumerates all disk drives present on the systen.
   
Arguments:

    Filter - The name of the filter drver whose presence we want to 
             check on any disk
             
    DiskDevicesForDisplayP - Placeholder for User Friendly Disk names
    
    DiskDevicesPDONameP    - Placeholder for PDO device names
    
    VerifierEnabledP       - Placeholder for Information regarding presence 
                             of Filter on a particular disk
                                 
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise
--*/

{
    DISPLAY_STRUCT Display; 
    DISK_ENUMERATE_CALLBACK CallBack;
    BOOLEAN Status;

    LPTSTR DiskDevicesForDisplay = NULL;
    LPTSTR DiskDevicesPDOName = NULL;
    LPTSTR VerifierEnabled = NULL;
    //
    //Initialize the Multisz strings with \0 (i.e. an empty MultiSz String)
    //
    DiskDevicesForDisplay = (LPTSTR)malloc(sizeof(TCHAR));
    if(DiskDevicesForDisplay == NULL ){
        
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
        
        goto ErrorReturn;
    }
    DiskDevicesForDisplay[0] = 0;
    
    DiskDevicesPDOName = (LPTSTR)malloc(sizeof(TCHAR));
    if( DiskDevicesPDOName == NULL ){
        
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        goto ErrorReturn;
    }
    DiskDevicesPDOName[0] = 0;
    
    VerifierEnabled = (LPTSTR)malloc(sizeof(TCHAR));
    if( VerifierEnabled == NULL ){
        
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        goto ErrorReturn;
    }
    VerifierEnabled[0] = 0;
    
    CallBack = DiskEnumerateCallback;
    Display.Filter = Filter;
    Display.DiskDevicesForDisplay = &DiskDevicesForDisplay;
    Display.DiskDevicesPDOName = &DiskDevicesPDOName;
    Display.VerifierEnabled = &VerifierEnabled;
    Status = DiskVerify(CallBack,(PVOID) &Display,NULL);
    if( !Status ) {

        goto ErrorReturn;
    }

    *DiskDevicesForDisplayP = DiskDevicesForDisplay;
    *DiskDevicesPDONameP = DiskDevicesPDOName;
    *VerifierEnabledP = VerifierEnabled;
    
    return TRUE;

ErrorReturn:

    if(DiskDevicesForDisplay != NULL) {

        free( DiskDevicesForDisplay );
    }

    if(DiskDevicesPDOName != NULL) {

        free( DiskDevicesPDOName );
    }

    if(VerifierEnabled != NULL) {

        free(VerifierEnabled);
    }

    return FALSE;
}

BOOLEAN 
DiskEnumerateCallback (
    PVOID Context,
    HDEVINFO DevInfo,
    SP_DEVINFO_DATA *DevInfoData
    )

/*++

Routine Description:

    This function is a callback to be executed whenever a disk is discovered
   
Arguments:

    Context - Points to all the relevant information needed to succesfully enumerate the disk               
    
    DevInfo  - The device information set which contains DeviceInfoData
    
    DevInfoData - Information needed to deal with the given device

    
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise
    
--*/


{
    PDISPLAY_STRUCT PDisplay;
    BOOLEAN Status;

    PDisplay = (PDISPLAY_STRUCT) Context;
    //
    //Add newly discoverd disks to the list 
    //
    Status = PrintDeviceName(DevInfo,
                             DevInfoData,
                             PDisplay->DiskDevicesForDisplay, 
                             PDisplay->DiskDevicesPDOName);
    if(!Status) {
        return Status;
    }

    Status = PrintFilters(DevInfo,
                          DevInfoData,FALSE,
                          PDisplay->Filter,
                          PDisplay->VerifierEnabled);
    return Status;
}

BOOLEAN
AddFilter(
    IN LPTSTR Filter,
    IN LPTSTR DiskDevicesPDONameP
    )

/*++

Routine Description:

    This function adds the filter on the specified disk device
   
Arguments:

    Filter - Name of the filter to be added
    
    DiskDevicesPDONameP - PDO device name of the disk
    
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise
    
--*/


{
    ADD_REMOVE_STRUCT AddRemove; 
    DISK_ENUMERATE_CALLBACK CallBack;
    BOOLEAN Status;

    AddRemove.Filter = Filter;
    CallBack = AddCallback;
    Status = DiskVerify(CallBack,(PVOID) &AddRemove,DiskDevicesPDONameP);
    
    return Status;
}

BOOLEAN
DelFilter(
    IN LPTSTR Filter,
    IN LPTSTR DiskDevicesPDONameP
    )

/*++

Routine Description:

    This function removes the filter on the specified disk device
   
Arguments:

    Filter - Name of the filter to be added
    
    DiskDevicesPDONameP - PDO device name of the disk
    
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise
    
--*/

{
    ADD_REMOVE_STRUCT AddRemove; 
    DISK_ENUMERATE_CALLBACK CallBack;
    BOOLEAN Status;

    AddRemove.Filter = Filter;
    CallBack = DelCallback;
    Status = DiskVerify(CallBack,(PVOID) &AddRemove,DiskDevicesPDONameP);
    
    return Status;
}

BOOLEAN  
AddCallback (
    PVOID Context,
    HDEVINFO DevInfo,
    SP_DEVINFO_DATA *DevInfoData
    )

/*++

Routine Description:

    This function is a callback to be executed whenever a disk is matched, and
    a filter needs to be added/deleted
   
Arguments:

    Context - Points to all the relevant information needed to succesfully identify the disk               
    
    DevInfo  - The device information set which contains DeviceInfoData
    
    DevInfoData - Information needed to deal with the given device
    
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise
    
--*/

{
    PADD_REMOVE_STRUCT PAddRemove;
    BOOLEAN Status;

    PAddRemove = (PADD_REMOVE_STRUCT) Context;

    Status = AddFilterDriver(DevInfo,
                             DevInfoData,
                             PAddRemove->Filter,
                             FALSE);

    if( !Status ) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN  
DelCallback (
    PVOID Context,
    HDEVINFO DevInfo,
    SP_DEVINFO_DATA *DevInfoData
    )

/*++

Routine Description:

    This function is a callback to be executed whenever a disk is matched, and
    a filter needs to be added/deleted
   
Arguments:

    Context - Points to all the relevant information needed to succesfully identify the disk               
    
    DevInfo  - The device information set which contains DeviceInfoData
    
    DevInfoData - Information needed to deal with the given device  
    
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise
    
--*/

{
    PADD_REMOVE_STRUCT PAddRemove;
    BOOLEAN Status;

    PAddRemove = (PADD_REMOVE_STRUCT) Context;

    Status = RemoveFilterDriver(DevInfo,
                                DevInfoData,
                                PAddRemove->Filter,
                                FALSE); 
    if( !Status ){
        return FALSE;
    }
    return TRUE;        
}

BOOLEAN 
DiskVerify(
    DISK_ENUMERATE_CALLBACK CallBack,
    PVOID Context,
    LPTSTR deviceName
    )

/*++

Routine Description:

    This function enumerates all disk drives. It also is used to add/remove 
    filter drivers. It triggers callbacks upon detecting a disk.

Arguments:

    CallBack - The routine to be executed upon succesfull detection of a disk
    
    Context  - Points to all the relevant information needed to succesfully identify the disk               
    
Return Value:              
    
    Returns TRUE if successful, FALSE otherwise

--*/
{
   
    //
    // these two constants are used to help enumerate through the list of all
    // disks and volumes on the system. Adding another GUID should "just work"
    //
    const GUID * deviceGuids[] = {
        &DiskClassGuid,
    };
    
    HDEVINFO                 devInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA          devInfoData;

    int deviceIndex;

    BOOLEAN upperFilter   = FALSE;
    BOOLEAN deviceMatch = FALSE;
    BOOLEAN Status;
    BOOLEAN Sucess;

   
    //
    // get a list of devices which support the given interface
    //
    devInfo = SetupDiGetClassDevs( deviceGuids[0],
                                   NULL,
                                   NULL,
                                   DIGCF_PROFILE |
                                   DIGCF_DEVICEINTERFACE |
                                   DIGCF_PRESENT );

    if( devInfo == INVALID_HANDLE_VALUE ) {
        VrfErrorResourceFormat( IDS_CANNOT_GET_DEVICES_LIST );
        return FALSE;
    }

    //
    // step through the list of devices for this handle
    // get device info at index deviceIndex, the function returns FALSE
    // when there is no device at the given index.
    //
    deviceIndex=0;
    do{
        //
        // if a device name was specified, and it doesn't match this one,
        // stop. If there is a match (or no name was specified), mark that
        // there was a match.
        //
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        Sucess = (SetupDiEnumDeviceInfo( devInfo, deviceIndex++, &devInfoData ) != FALSE);

        if( !Sucess ) {
            break;
        }

        if( deviceName != NULL && !DeviceNameMatches( devInfo, &devInfoData, deviceName )) {
            continue;
        } else {
            deviceMatch = TRUE;
        }
        Status = (*CallBack)(Context,devInfo,&devInfoData);
        if( !Status ){
            return FALSE;
        }
    }while(Sucess);

    if( devInfo != INVALID_HANDLE_VALUE ) {
        Status =  ( SetupDiDestroyDeviceInfoList( devInfo ) != FALSE );
    }

    if( !deviceMatch ) {        
        VrfErrorResourceFormat( IDS_NO_DEVICES_MATCH_NAME,
                                deviceName );
        return FALSE;
    } 
  
   return TRUE;    
} 

BOOLEAN
AddFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    )

/*++

Routine Description:

    Adds the given filter driver to the list of lower filter drivers for the
    disk. Note: The filter is prepended to the list of drivers, which will put 
    it at the bottom of the filter driver stack

Arguments:

    DeviceInfoSet  - The device information set which contains DeviceInfoData   
    
    DeviceInfoData - Information needed to deal with the given device
    
    Filter         - The filter to add

Return Value:
 
    If we are successful in adding the driver, as a lower driver to disk, returns 
    TRUE, FALSE otherwise

--*/

{
    SIZE_T length; 
    SIZE_T size; 
    LPTSTR buffer = NULL; 
    BOOLEAN SetupDiSetDeviceRegistryPropertyReturn;
    BOOLEAN Success;
   
    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    Success = TRUE;

    length = 0; 
    size   = 0; 

    buffer = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilter );
    if( buffer == NULL ){

        //
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we can just put one there
        // make room for the string, string null terminator, and multisz null
        // terminator
        //
        length = _tcslen(Filter)+1;
        size   = (length+1)*sizeof(_TCHAR);
        buffer = (LPTSTR)malloc( size );
        
        if( buffer == NULL ){

            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

            Success = FALSE;
        
            goto Done;
            
        }
        
        memset(buffer, 0, size);

        memcpy(buffer, Filter, length*sizeof(_TCHAR));
    } else {
        LPTSTR buffer2;
        //
        // remove all instances of filter from driver list
        //
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
        //
        // allocate a buffer large enough to add the new filter
        // GetMultiSzLength already includes length of terminating NULL
        // determing the new length of the string
        //
        length = GetMultiSzLength(buffer) + _tcslen(Filter) + 1;
        size   = length*sizeof(_TCHAR);
        
        buffer2 = (LPTSTR)malloc( size );
        if (buffer2 == NULL) {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

            Success = FALSE; 

            goto Done;
        }
        memset(buffer2, 0, size);
        
        memcpy(buffer2, buffer, GetMultiSzLength(buffer)*sizeof(_TCHAR));      
        free(buffer);
        buffer = buffer2;
        //
        // add the driver to the driver list
        //
        PrependSzToMultiSz(Filter, &buffer);
    }

    //
    // set the new list of filters in place
    //

    SetupDiSetDeviceRegistryPropertyReturn = (
    SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                      DeviceInfoData,
                                      (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                      (PBYTE)buffer,
                                      ((ULONG) GetMultiSzLength(buffer)*sizeof(_TCHAR))) != FALSE ); 
    if(!SetupDiSetDeviceRegistryPropertyReturn){
        
        TRACE(_T("in AddUpperFilterDriver(): ")
              _T("couldn't set registry value! error: %u\n"), 
              GetLastError());

        VrfErrorResourceFormat( IDS_CANNOT_SET_DEVICE_REGISTRY_PROPERTY );

        Success = FALSE; 

        goto Done;
    }

Done:

    if(buffer != NULL) {

        free( buffer );
    }

    return Success;
}


BOOLEAN
RemoveFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    )

/*++

Routine Description:

    Removes all instances of the given filter driver from the list of lower
    filter drivers for the device.

Arguments:

    DeviceInfoSet  - The device information set which contains DeviceInfoData
    
    DeviceInfoData - Information needed to deal with the given device
    
    Filter - The filter to remove

Return Value:

    returns TRUE if successful, FALSE otherwise

--*/
{
    SIZE_T length;
    SIZE_T size;
    LPTSTR buffer;
    BOOL   success;

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    success = FALSE;
    length  = 0;
    size    = 0;
    buffer  = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilter );

    if( buffer == NULL ){
        return (TRUE);
    } else {
        //
        // remove all instances of filter from driver list
        //
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
    }

    length = GetMultiSzLength(buffer);

    ASSERT ( length > 0 );

    if( length == 1 ){
        //
        // if the length of the list is 1, the return value from
        // GetMultiSzLength() was just accounting for the trailing '\0', so we can
        // delete the registry key, by setting it to NULL.
        //
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                    NULL,
                                                    0 );
    } else {
        //
        // set the new list of drivers into the registry
        //
        size = length*sizeof(_TCHAR);
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                    (PBYTE)buffer,
                                                    (ULONG)size );
    }

    free( buffer );

    if( !success ){
        TRACE(_T("in RemoveUpperFilterDriver(): ")
              _T("couldn't set registry value! error: %i\n"), 
              GetLastError());

        VrfErrorResourceFormat( IDS_CANNOT_SET_DEVICE_REGISTRY_PROPERTY );

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
PrintFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters,
    IN LPTSTR FilterDriver,
    IN OUT LPTSTR *VerifierEnabled
    )

/*++

Routine Description:

    Looks at all the lower filters installed for the disk. It tells us if
    DiskVerifier is installed for that particular disk. 

Arguments:

    DeviceInfoSet   - The device information set which contains 
                      DeviceInfoData
    
    DeviceInfoData  - Information needed to deal with the given device
    
    FilterDriver    - The name of the Filter driver for Disk Verifier
    
    DiskDevices     - MultiSZ style string listing all devices 
    
    VerifierEnabled - MultiSZ style string indicating if Verifier Enabled          
    
Return Value:

    Returns TRUE if successful, FALSE otherwise    

--*/

{
    
    LPTSTR buffer;
    SIZE_T filterPosition;
    LPTSTR temp;
    int StrCmpReturn;

    buffer = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilters );
    if ( buffer != NULL ) {
        //
        // go through the multisz and print out each driver
        //
        temp=buffer;
        filterPosition=0;
        while( *temp != _T('\0') ){
            StrCmpReturn = _tcsicmp(FilterDriver,temp);
            if(StrCmpReturn == 0 ){
                         PrependSzToMultiSz( _T("1"),VerifierEnabled);
                         free( buffer );
                         return TRUE;
            }
            temp = temp+_tcslen(temp)+1;
            filterPosition++;
        }
        free( buffer );
    }
    PrependSzToMultiSz( _T("0"),VerifierEnabled);
    return TRUE;
}


BOOLEAN PrintDeviceName(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN OUT LPTSTR *DiskDevicesForDisplay,
    IN OUT LPTSTR *DiskDevicesPDOName
    )

/*++

Routine Description:

    Looks up the PDO device name, and user friendly name for disk. 
    
Arguments:

    DeviceInfoSet         - The device information set which contains
                            DeviceInfoData
                            
    DeviceInfoData        - Information needed to deal with the given device
    
    DiskDevicesForDisplay - User Friendly Names for Disk
    
    DiskDevicesPDOName    - PDO specified device names for disk
    
Return Value:

    Returns TRUE if successful, FALSE otherwise    

--*/

{
   DWORD   regDataType;
   LPTSTR  deviceName;
   LPTSTR  driveLetters;
   int     StrCmpReturned;
   BOOL    bResult;
        
   deviceName = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            &regDataType );
   if( deviceName == NULL ) {
        TRACE(_T("in PrintDeviceName(): registry key is NULL! error: %u\n"),
               GetLastError());

	        VrfErrorResourceFormat( IDS_CANNOT_GET_DEVICE_REGISTRY_PROPERTY );

        return FALSE;
    }

    if( regDataType != REG_SZ ){
        TRACE(_T("in PrintDeviceName(): registry key is not an SZ!\n"));

        return FALSE;
    } else {
        //
        // if the device name starts with \Device, cut that off (all
        // devices will start with it, so it is redundant)
        //
        StrCmpReturned = _tcsncmp(deviceName, _T("\\Device"), 7);
        if( StrCmpReturned == 0 ){
                memmove(deviceName,
                        deviceName+7,
                        (_tcslen(deviceName)-6)*sizeof(_TCHAR) );
        }
        PrependSzToMultiSz(deviceName,DiskDevicesPDOName);
        free( deviceName );
    }
    
    deviceName =  (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                      DeviceInfoData,
                                                      SPDRP_FRIENDLYNAME ,
                                                      &regDataType );
    if( deviceName == NULL ){
        TRACE(_T("in PrintDeviceName(): registry key is NULL! error: %u\n"),
               GetLastError());
        //
        //We could not obtain the friendly name for disk, setting it to Unknown.
        //

        deviceName = (LPTSTR)malloc(sizeof(TCHAR) * 64);
        if ( !deviceName ) {
	        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
	        return FALSE;
        }
        bResult	   = VrfLoadString(IDS_UNKNOWN,
                                   deviceName,
                                   64 );
        if ( !bResult ) {
	        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
	        return FALSE;
        }
    }
    
    //
    // just to make sure we are getting the expected type of buffer
    //
    if( regDataType != REG_SZ ){
        TRACE(_T("in PrintDeviceName(): registry key is not an SZ!\n"));
        return FALSE;
    }else{
        driveLetters = GetDriveLetters( DeviceInfoSet,
                                        DeviceInfoData);
        if(driveLetters){
            StrConcatWithSpace(driveLetters,&deviceName);
        }
        PrependSzToMultiSz(deviceName,DiskDevicesForDisplay);
        free( deviceName );
    }

    return TRUE;
}

LPTSTR
GetFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    )

/*++


Routine Description:
    Returns a buffer containing the list of lower filters for the device.The 
    buffer must be freed by the caller.

Arguments:
    DeviceInfoSet  - The device information set which contains DeviceInfoData
    
    DeviceInfoData - Information needed to deal with the given device
    
    UpperFilters   - Switch to select Upper/Lower filter. Currently we 
                     use Lower.

Return Value:

    MultiSz style string containing all lower Filters for the disk is 
    returned. NULL is returned if there is no buffer, or an error occurs.


--*/
{
    DWORD  regDataType;
    LPTSTR buffer;
    buffer = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                 DeviceInfoData,
                                                 (UpperFilters ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                  &regDataType );

    if( buffer != NULL && regDataType != REG_MULTI_SZ ){
        TRACE(_T("in GetUpperFilters(): ")
              _T("registry key is not a MULTI_SZ!\n"));
        free( buffer );
        return (NULL);
    }
    return (buffer);
}

BOOLEAN
DeviceNameMatches(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR DeviceName
    )

/*++

Routine Description:
 
 Searches if DeviceName matches the name of the device specified by
 DeviceInfoData

Arguments:

    DeviceInfoSet  - The device information set which contains DeviceInfoData
    
    DeviceInfoData - Information needed to deal with the given device
    
    DeviceName     - the name to try to match
    
Return Value:

    Returns TRUE if successful, FALSE otherwise    
                                                       
--*/

{
    BOOLEAN matching = FALSE;
    DWORD   regDataType;
    LPTSTR  deviceName;
    int StrCmpReturn;
     
    deviceName = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                                     &regDataType );

    if( deviceName != NULL) {
        
        if( regDataType != REG_SZ ){
            TRACE(_T("in DeviceNameMatches(): registry key is not an SZ!\n"));
            matching = FALSE;
        }else{
            //
            // if the device name starts with \Device, cut that off (all
            // devices will start with it, so it is redundant)
            //
            StrCmpReturn = _tcsncmp(deviceName, _T("\\Device"), 7); 
            if( StrCmpReturn == 0 ){
                memmove(deviceName,
                        deviceName+7,
                        (_tcslen(deviceName)-6)*sizeof(_TCHAR) );
            }

            matching = (_tcscmp(deviceName, DeviceName) == 0);
        }
        free( deviceName );
    } else {
        TRACE(_T("in DeviceNameMatches(): registry key is NULL!\n"));
        
        VrfErrorResourceFormat( IDS_CANNOT_GET_DEVICE_REGISTRY_PROPERTY );

        matching = FALSE;
    }

    return (matching);
}

PBYTE
GetDeviceRegistryProperty(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD Property,
    OUT PDWORD PropertyRegDataType
    )

/*++

Routine Description:

    A wrapper around SetupDiGetDeviceRegistryProperty, so that I don't have to
    deal with memory allocation anywhere else.

Arguments:

    DeviceInfoSet  - The device information set which contains DeviceInfoData
    
    DeviceInfoData - Information needed to deal with the given device
    
    Property       - which property to get (SPDRP_XXX)
    
    PropertyRegDataType - the type of registry property

Return Value:

    Returns buffer for Registery property

--*/

{
    DWORD length = 0;
    PBYTE buffer = NULL;
    BOOL SetupDiGetDeviceRegistryPropertyReturn;

    SetupDiGetDeviceRegistryPropertyReturn = SetupDiGetDeviceRegistryProperty( 
                                             DeviceInfoSet,
                                             DeviceInfoData,
                                             Property,
                                             NULL,  
                                             NULL,  
                                             0,     
                                             &length);

    if( SetupDiGetDeviceRegistryPropertyReturn ){
        //
        // we should not be successful at this point, so this call succeeding
        // is an error condition
        //
        TRACE(_T("in GetDeviceRegistryProperty(): ")
              _T("call SetupDiGetDeviceRegistryProperty did not fail\n"),
               GetLastError());

        VrfErrorResourceFormat( IDS_CANNOT_GET_DEVICE_REGISTRY_PROPERTY );

        return (NULL);
    }

    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
        //
        // this means there are no upper filter drivers loaded, so we can just
        // return.
        //
        return (NULL);
    }

    //
    // since we don't have a buffer yet, it is "insufficient"; we allocate
    // one and try again.
    //
    buffer = (PBYTE)malloc( length );
    if( buffer == NULL ) {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
        return (NULL);
    }

    SetupDiGetDeviceRegistryPropertyReturn = SetupDiGetDeviceRegistryProperty( 
                                             DeviceInfoSet,
                                             DeviceInfoData,
                                             Property,
                                             PropertyRegDataType,
                                             buffer,
                                             length,
                                             NULL);

    if( !SetupDiGetDeviceRegistryPropertyReturn) {
        TRACE(_T("in GetDeviceRegistryProperty(): ")
              _T("couldn't get registry property! error: %i\n"),
               GetLastError());

        VrfErrorResourceFormat( IDS_CANNOT_GET_DEVICE_REGISTRY_PROPERTY );

        free( buffer );
        return (NULL);
    }

    return (buffer);
}


BOOLEAN
PrependSzToMultiSz(
    IN     LPTSTR  SzToPrepend,
    IN OUT LPTSTR *MultiSz
    )

/*++

Routine Description:

    Prepends the given string to a MultiSz.Note: This WILL allocate and free 
    memory, so don't keep pointers to the MultiSz passed in.

Arguments:

   SzToPrepend - string to prepend
   
   MultiSz     - pointer to a MultiSz which will be prepended-to
   
Return Value:

   Returns true if successful, false if not (will only fail in memory
   allocation)

--*/

{
    SIZE_T szLen;
    SIZE_T multiSzLen;
    LPTSTR newMultiSz = NULL;

    ASSERT(SzToPrepend != NULL);
    ASSERT(MultiSz != NULL);

    szLen = (_tcslen(SzToPrepend)+1)*sizeof(_TCHAR);
    multiSzLen = GetMultiSzLength(*MultiSz)*sizeof(_TCHAR);
    newMultiSz = (LPTSTR)malloc( szLen+multiSzLen );

    if( newMultiSz == NULL ){
        return (FALSE);
    }
    //
    // recopy the old MultiSz into proper position into the new buffer.
    // the (char*) cast is necessary, because newMultiSz may be a wchar*, and
    // szLen is in bytes.
    //
    memcpy( ((char*)newMultiSz) + szLen, *MultiSz, multiSzLen );

    _tcscpy( newMultiSz, SzToPrepend );

    free( *MultiSz );
    *MultiSz = newMultiSz;

    return (TRUE);
}


SIZE_T
GetMultiSzLength(
    IN LPTSTR MultiSz
    )

/*++

Routine Description:

    Calculates the size of the buffer required to hold a particular MultiSz

Arguments:

    MultiSz - the MultiSz to get the length of
    
Return Value:
 
    Returns the length (in characters) of the buffer required to hold this
    MultiSz, INCLUDING the trailing null.
    example: GetMultiSzLength("foo\0bar\0") returns 9
    note: since MultiSz cannot be null, a number >= 1 will always be returned

--*/

{
    SIZE_T len = 0;
    SIZE_T totalLen = 0;

    ASSERT( MultiSz != NULL );

    while( *MultiSz != _T('\0') ){
        len = _tcslen(MultiSz)+1;
        MultiSz += len;
        totalLen += len;
    }

    return (totalLen+1);
}


SIZE_T
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPTSTR FindThis,
    IN  LPTSTR FindWithin,
    OUT SIZE_T *NewLength
    )

/*++

Routine Description:
    Deletes all instances of a string from within a multi-sz.

Arguments:
    FindThis        - the string to find and remove
    
    FindWithin      - the string having the instances removed
    
    NewStringLength - the new string length

Return Value:
    
    Returns the no. of string occurences deleted from MultiSz    

--*/

{
    LPTSTR search;
    SIZE_T currentOffset;
    DWORD  instancesDeleted;
    SIZE_T searchLen;

    ASSERT(FindThis != NULL);
    ASSERT(FindWithin != NULL);
    ASSERT(NewLength != NULL);

    currentOffset = 0;
    instancesDeleted = 0;
    search = FindWithin;

    *NewLength = GetMultiSzLength(FindWithin);
    //
    // loop while the multisz null terminator is not found
    //
    while ( *search != _T('\0') ){
        //
        // length of string + null char; used in more than a couple places
        //
        searchLen = _tcslen(search) + 1;

        if( _tcsicmp(search, FindThis) == 0 ){
        //
        // they match, shift the contents of the multisz, to overwrite the
        // string (and terminating null), and update the length
        //
        instancesDeleted++;
        *NewLength -= searchLen;
        memmove( search,
                 search + searchLen,
                 (*NewLength - currentOffset) * sizeof(TCHAR) );
        } else {
            
        currentOffset += searchLen;
        search        += searchLen;
        }
    }

    return instancesDeleted;
}


BOOLEAN
FreeDiskMultiSz( 
    IN LPTSTR MultiSz
    )
{
    ASSERT( MultiSz != NULL );
    
    free( MultiSz );

    return TRUE;
}

LPTSTR 
GetDriveLetters (
    IN HDEVINFO DeviceInfoSet,
	IN PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

    Looks up the drive letters for the specified disk. Finds the 
	device number of the disk, and passes it on to the volume code 
    
Arguments:

    DeviceInfoSet         - The device information set which contains
                            DeviceInfoData
                            
    DeviceInfoData        - Information needed to deal with the given device
       
Return Value:

    Returns the list of drives present on the disk if successful, 
	NULL otherwise    

--*/

{
	SP_DEVICE_INTERFACE_DATA            DeviceInterfaceData;
	ULONG                               cbDetail;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDetail;
	BOOL								Status;
	HANDLE			                    hDisk;
	STORAGE_DEVICE_NUMBER			    devNumber;
	DWORD								cbBytes;
    
	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
    
	cbDetail = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + 
               MAX_PATH * sizeof(WCHAR);
    pDetail  = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LMEM_FIXED, cbDetail);
    if (pDetail == NULL) {
	   return NULL;                
    }
    pDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
	Status = SetupDiEnumDeviceInterfaces (DeviceInfoSet, 
										  DeviceInfoData, 
									      &DiskClassGuid, 
									      0, 
									      &DeviceInterfaceData);
	if (! Status) {
		LocalFree(pDetail);
		return NULL;
    }

	Status = SetupDiGetDeviceInterfaceDetail(DeviceInfoSet, 
											 &DeviceInterfaceData, 
											 pDetail, 
											 cbDetail, 
											 NULL,
											 NULL);
    if (! Status) {
		LocalFree(pDetail);
		return NULL;
    }

	hDisk = CreateFile(pDetail->DevicePath, 
	                   GENERIC_READ, 
                       FILE_SHARE_READ | FILE_SHARE_WRITE, 
					   NULL, 
					   OPEN_EXISTING, 
                       FILE_ATTRIBUTE_NORMAL,
					   NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
		LocalFree(pDetail);
        return NULL;
    }

    Status = DeviceIoControl(hDisk, 
							 IOCTL_STORAGE_GET_DEVICE_NUMBER, 
							 NULL, 
							 0,
                             &devNumber, 
							 sizeof(devNumber), 
							 &cbBytes, 
							 NULL);
    if (!Status) {
		LocalFree(pDetail);
        return NULL;
    } 
	LocalFree(pDetail);
	return GetDriveLettersFromVolume (devNumber.DeviceNumber);
}

LPTSTR 
GetDriveLettersFromVolume (
    IN ULONG  DeviceNumber
    )

/*++

Routine Description:

    Looks up the drive letter(s) and volume_label(s) for the specified 
    disk(device number) by parsing the volumes.
    
Arguments:

    DeviceNumber - Unique Number identifying the physical disk
       
Return Value:

    Returns the list of drives present on the disk if successful, 
    NULL otherwise    

--*/
{
    HANDLE                      h = INVALID_HANDLE_VALUE;
    HANDLE                      hVol;
    TCHAR                       volumeName[MAX_PATH];
    TCHAR                       originalVolumeName[MAX_PATH];
    DWORD                       cbBytes;
    PVOLUME_DISK_EXTENTS        PVolDiskExtent;
    LPTSTR                      drives; 
    LPTSTR                      temp;
    BOOL                        b;
    BOOL                        First;
    int                         maxDisks;
    int                         i;
    int                         j;
    size_t                      tempLen;
    TCHAR                       OpenParan[]  = TEXT(" ( ");
    TCHAR                       CloseParan[] = TEXT(")");

    drives = NULL;
    First = TRUE;

    StrConcatWithSpace(OpenParan,&drives);

    for (;;) {      
        if(First) {
            //
            //Using FindFirstVolumeA, as it is the Non-Unicode version
            //of FindFirstVolume
            //
            h = FindFirstVolume(volumeName, MAX_PATH);
            if (h == INVALID_HANDLE_VALUE) {
               return NULL;
            }
            First = FALSE;
            b = TRUE;
        } else {
            b = FindNextVolume(h, volumeName, MAX_PATH);
        }
        if (!b) {
            break;
        }
        tempLen = _tcslen(volumeName);
        _tcsncpy(originalVolumeName,
                 volumeName,
                  tempLen - 1);
        _tcscpy(originalVolumeName + tempLen - 1,
                volumeName + tempLen);
        
        //
        //To open a handle correctly, CreateFile expects the name
        //of the Volume without the trailing \ returned by
        //FindFirstVolume / FindNextVolume
        //
        hVol = CreateFile(originalVolumeName, 
                          GENERIC_READ, 
                          FILE_SHARE_READ | FILE_SHARE_WRITE, 
                          NULL, 
                          OPEN_EXISTING, 
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL);

        if (hVol == INVALID_HANDLE_VALUE) {
            continue;
        }
        PVolDiskExtent = (PVOLUME_DISK_EXTENTS) LocalAlloc(LMEM_FIXED, sizeof(VOLUME_DISK_EXTENTS));
        if(!PVolDiskExtent) {
            continue;
        }
        //
        //This IOCTL has to be called with a minimum of 
        //size VOLUME_DISK_EXTENTS. If more entries are present
        //it can be obtained by PVolDiskExtent->NumberOfDiskExtents
        //
        b = DeviceIoControl(hVol, 
                            IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, 
                            NULL, 
                            0,
                            PVolDiskExtent, 
                            sizeof(VOLUME_DISK_EXTENTS),
                            &cbBytes, 
                            NULL);

        if (!b) {
            //
            //Now, we can read how much memory is actually required
            //to read in the disk info
            //
            if(GetLastError() == ERROR_MORE_DATA){
                maxDisks = PVolDiskExtent->NumberOfDiskExtents;
                LocalFree(PVolDiskExtent);
                PVolDiskExtent = (PVOLUME_DISK_EXTENTS) LocalAlloc(LMEM_FIXED, sizeof(VOLUME_DISK_EXTENTS) + (sizeof(DISK_EXTENT) * maxDisks));
                if(!PVolDiskExtent) {
                    continue;
                }
                
                b = DeviceIoControl(hVol, 
                                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, 
                                    NULL,
                                    0,
                                    PVolDiskExtent, 
                                    sizeof(VOLUME_DISK_EXTENTS) + (sizeof(DISK_EXTENT) * maxDisks), 
                                    &cbBytes, 
                                    NULL);
                
                if (!b) {
                        continue;
                }
                
                for(j=0;j<maxDisks;j++){
                    if(PVolDiskExtent->Extents[j].DiskNumber == DeviceNumber) {
                        temp = PrintDriveLetters(volumeName);
                        if(temp) {
                            StrConcatWithSpace(temp,&drives);
                            FreeDiskMultiSz(temp);
                        }
                    }
                }
            
            } else {
                continue;
            }
        } else {
            if(PVolDiskExtent->Extents[0].DiskNumber == DeviceNumber) {
                temp = PrintDriveLetters(volumeName);
                if(temp) {
                    StrConcatWithSpace(temp,&drives);
                    FreeDiskMultiSz(temp);
                }
            }
        }
        CloseHandle(hVol);
        LocalFree(PVolDiskExtent);
    }

    if(h != INVALID_HANDLE_VALUE) {
        FindVolumeClose(h);
    }
    StrConcatWithSpace(CloseParan,&drives);
    return drives;
}

LPTSTR
PrintDriveLetters(
    IN  PTSTR   VolumeName
    )

/*++

Routine Description:

    Looks up the drive letters for the specified Volume
    
Arguments:

    VolumeName - Name of the Volume
       
Return Value:

    A list of drive letter(s) for the specified volume

--*/

{
    BOOL        b;
    DWORD       len;
    LPTSTR      volumePaths, p;
    LPTSTR      drives; 
    TCHAR       volumeName1[MAX_PATH];
    DWORD       lpVolumeSerialNumber;    
    DWORD       lpMaximumComponentLength;
    DWORD       lpFileSystemFlags;       

             

    drives = NULL;
    b = GetVolumePathNamesForVolumeName(VolumeName, 
                                        NULL, 
                                        0, 
                                        &len);
    
    if (!b) {
        if(GetLastError() != ERROR_MORE_DATA) {
            return NULL;
        }
    }
    volumePaths = (LPTSTR) LocalAlloc(LMEM_FIXED, len*sizeof(TCHAR));
    if (!volumePaths) {
        return NULL;
    }

    b = GetVolumePathNamesForVolumeName(VolumeName, 
                                        volumePaths, 
                                        len, 
                                        NULL);

    
    if (!b ) {

        if( GetLastError() != ERROR_MORE_DATA) {
            LocalFree(volumePaths);
            return NULL;
        } else {
            //
            //Warning - This is a hack. For some reason the non-unicode
            //version of GetVolumePathNamesForVolumeNameA does not return
            //the correct length to be used. So we hope it will not be  
            //greater then GETVOLUMEPATH_MAX_LEN_RETRY. But if the correct len is 
            //returned, we used that previosly
            //
            LocalFree(volumePaths);
            len = GETVOLUMEPATH_MAX_LEN_RETRY;
            volumePaths = (LPTSTR) LocalAlloc(LMEM_FIXED, GETVOLUMEPATH_MAX_LEN_RETRY*sizeof(TCHAR));
            if (!volumePaths) {
                return NULL;
            }
            b = GetVolumePathNamesForVolumeName(VolumeName, 
                                                volumePaths, 
                                                len, 
                                                NULL);
            if (!b ) {
                LocalFree(volumePaths);
                return NULL;
            }
        }
    }

    if (!volumePaths[0]) {
        return NULL;
    }
    p = volumePaths;

    
    for (;;) {
        if(_tcslen(p) > 2) {
            p[_tcslen(p) - 1] = _T(' ');
        }
        StrConcatWithSpace(p,&drives);
        while (*p++);
        //
        //The drive letters returned are a collection of strings,
        //and the end is marked with \0\0. If we reached the end,
        //stop, else traverse the string list
        //
        if (*p == 0) {
            break;
        }
    }

    LocalFree(volumePaths);
    return drives;
}


BOOLEAN
StrConcatWithSpace(
    IN     LPTSTR  SzToAppend,
    IN OUT LPTSTR *drives
    )

/*++

Routine Description:

    Concatenates the given string to the drive list. Note: This WILL 
    allocate and free memory, so don't keep pointers to the drives 
    passed in. Do no pass uninitialized pointers. *drives should 
    be NULL if empty

Arguments:

   SzToAppend  - string to prepend
   
   drives      - pointer to the existing drive list 
   
Return Value:

   Returns true if successful, false if not (will only fail in memory
   allocation)

--*/

{
    SIZE_T szLen;
    SIZE_T driveLen;
    LPTSTR newdrives = NULL;

    ASSERT(SzToAppend != NULL);
    ASSERT(drives != NULL);
    
    szLen = (_tcslen(SzToAppend))*sizeof(_TCHAR);
    if(*drives == NULL) {
        driveLen = sizeof(_TCHAR) ;
    } else {
        driveLen  = (_tcslen(*drives) + 1)*sizeof(_TCHAR);
    }
    newdrives = (LPTSTR)malloc(szLen+driveLen);

    if( newdrives == NULL ){
        return (FALSE);
    }
    
    if(*drives == NULL){
        _tcscpy( newdrives, SzToAppend);
    } else {
        _tcscpy(newdrives, *drives);
        //_tcscat(newdrives, _T(" "));
        _tcscat(newdrives, SzToAppend);
    }
    
    free( *drives );
    *drives = newdrives;

    return (TRUE);
}


#ifdef __cplusplus
}; //extern "C"
#endif //#ifdef __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\dstspage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DStsPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include <Cderr.h>
#include "verifier.h"

#include "DStsPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"
#include "VBitsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CRTSTAT_SETTBITS_LIST,      IDH_DV_CurrentSettings,
    IDC_CRTSTAT_DRIVERS_LIST,       IDH_DV_CurrentVerifiedDrivers,
    IDC_CRTSTAT_CHSETT_BUTTON,      IDH_DV_Changebut,
    IDC_CRTSTAT_ADDDRV_BUTTON,      IDH_DV_Addbut,
    IDC_CRTSTAT_REMDRVT_BUTTON,     IDH_DV_Removebut,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDriverStatusPage property page

IMPLEMENT_DYNCREATE(CDriverStatusPage, CVerifierPropertyPage)

CDriverStatusPage::CDriverStatusPage() : CVerifierPropertyPage(CDriverStatusPage::IDD)
{
	//{{AFX_DATA_INIT(CDriverStatusPage)
    //}}AFX_DATA_INIT

    m_uTimerHandler = 0;

    //
    // Driver list sort parameters
    //

    m_nSortColumnIndexDrv = 0;
    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvStatusSort = FALSE;

    //
    // Settings bits sort parameters
    //

    m_nSortColumnIndexSettbits = 1;
    m_bAscendSortEnabledBits = FALSE;
    m_bAscendSortNameBits = FALSE;

    m_pParentSheet = NULL;
}

CDriverStatusPage::~CDriverStatusPage()
{
}

VOID CDriverStatusPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // Query the kernel
        //

        if( TRUE != VrfGetRuntimeVerifierData( &m_RuntimeVerifierData )     ||
            m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() == 0 )
        {
            //
            // Don't have any verified drivers currently
            //

            //
            // Clear all settings bits just in case the kernel
            // didn't return them to us all zero ;-)
            //

            m_RuntimeVerifierData.m_bSpecialPool    = FALSE;
            m_RuntimeVerifierData.m_bPoolTracking   = FALSE;
            m_RuntimeVerifierData.m_bForceIrql      = FALSE;
            m_RuntimeVerifierData.m_bIo             = FALSE;
            m_RuntimeVerifierData.m_bEnhIo          = FALSE;
            m_RuntimeVerifierData.m_bDeadlockDetect = FALSE;
            m_RuntimeVerifierData.m_bDMAVerif       = FALSE;
            m_RuntimeVerifierData.m_bLowRes         = FALSE;
        }
    }

    CVerifierPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CDriverStatusPage)
	DDX_Control(pDX, IDC_CRTSTAT_SETTBITS_LIST, m_SettBitsList);
	DDX_Control(pDX, IDC_CRTSTAT_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_CRTSTAT_DRIVERS_LIST, m_DriversList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverStatusPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CDriverStatusPage)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_CRTSTAT_DRIVERS_LIST, OnColumnclickCrtstatDriversList)
    ON_WM_TIMER()
	ON_BN_CLICKED(IDC_CRTSTAT_CHSETT_BUTTON, OnChsettButton)
	ON_BN_CLICKED(IDC_CRTSTAT_ADDDRV_BUTTON, OnAdddrvButton)
	ON_BN_CLICKED(IDC_CRTSTAT_REMDRVT_BUTTON, OnRemdrvtButton)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CRTSTAT_SETTBITS_LIST, OnColumnclickCrtstatSettbitsList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::RefreshInfo() 
{
    if( UpdateData( FALSE ) )
    {
        //
        // Refresh the settings bits list
        //

        RefreshListSettBits();
        //SortTheListSettBits();

        //
        // Refresh the drivers list
        //

        FillTheListDrivers();
        SortTheListDrivers();
    }
}

/////////////////////////////////////////////////////////////
//
// Driver status list control methods
//

VOID CDriverStatusPage::SetupListHeaderDrivers()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strDrivers, strStatus;
    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_STATUS ) );

    //
    // List's regtangle
    //

    m_DriversList.GetClientRect( &rectWnd );
    
    //
    // Column 0
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.50 );
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
        strDrivers.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.44 );
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
        strStatus.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::FillTheListDrivers()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    int nItemCount;
    int nCrtListItem;
    INT_PTR nCrtVerifiedDriver;
    INT_PTR nDriversNo;
    TCHAR szDriverName[ _MAX_PATH ];
    BOOL bResult;
    CString strText;

    //
    // The number of drivers currently verified
    //

    nDriversNo = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( nDriversNo == 0 )
    {
        //
        // Clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
    }
    else
    {
        //
        // There are some drivers currently verified
        //

        pbAlreadyInList = new BOOL[ nDriversNo ];
        
        if( pbAlreadyInList == NULL )
        {
            return;
        }
        
        for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver+= 1)
        {
            pbAlreadyInList[ nCrtVerifiedDriver ] = FALSE;
        }

        //
        // Parse all the current list items
        //

        nItemCount = m_DriversList.GetItemCount();

        for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem+= 1 )
        {
            //
            // Get the current driver's name from the list
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nCrtListItem;
            lvItem.iSubItem = 0;
            lvItem.pszText = szDriverName;
            lvItem.cchTextMax = ARRAY_LENGTH( szDriverName );

            bResult = m_DriversList.GetItem( &lvItem );
            if( bResult == FALSE )
            {
                //
                // Could not get the current item's attributes?!?
                //

                ASSERT( FALSE );

                //
                // Remove this item from the list
                //

                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem -= 1;
                nItemCount -= 1;
            }
            else
            {
                //
                // see is the current driver is still in m_RuntimeVerifierData
                //

                for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver+= 1)
                {
                    if( m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtVerifiedDriver )
                        ->m_strName.CompareNoCase( szDriverName ) == 0 )
                    {
                        //
                        // Update the item's data with the current index in the array
                        //

                        lvItem.mask = LVIF_PARAM;
                        lvItem.lParam = nCrtVerifiedDriver;
                        
                        VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                        //
                        // Update the second column
                        //

                        UpdateStatusColumnDrivers( nCrtListItem, nCrtVerifiedDriver ); 

                        //
                        // Mark the current driver as updated
                        //

                        pbAlreadyInList[ nCrtVerifiedDriver ] = TRUE;

                        break;
                    }
                }

                //
                // If the driver is no longer verified, remove it from the list
                //

                if( nCrtVerifiedDriver >= nDriversNo )
                {
                    VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                    nCrtListItem -= 1;
                    nItemCount -= 1;
                }
            }
        }

        //
        // Add the drivers that were not in the list before this update
        //

        for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver += 1)
        {
            if( ! pbAlreadyInList[ nCrtVerifiedDriver ] )
            {
                // 
                // Add a new item for this
                //

                ZeroMemory( &lvItem, sizeof( lvItem ) );

                //
                // sub-item 0
                //

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.lParam = nCrtVerifiedDriver;
                lvItem.iItem = m_DriversList.GetItemCount();
                lvItem.iSubItem = 0;
                
                strText = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtVerifiedDriver )->m_strName;
                
                lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

                if( NULL != lvItem.pszText  )
                {
                    nActualIndex = m_DriversList.InsertItem( &lvItem );
                    
                    VERIFY( nActualIndex != -1 );

                    strText.ReleaseBuffer();

                    //
                    // sub-item 1
                    //

                    UpdateStatusColumnDrivers( nActualIndex, nCrtVerifiedDriver ); 
                }
            }
        }

        delete [] pbAlreadyInList;
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::UpdateStatusColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver )
{
    CRuntimeDriverData *pCrtDriverData;
    LVITEM lvItem;
    CString strStatus;

    ASSERT( nItemIndex >= 0 && 
            nItemIndex < m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() &&
            nItemIndex < m_DriversList.GetItemCount() &&
            nCrtDriver >= 0 &&
            nCrtDriver < m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() &&
            nCrtDriver < m_DriversList.GetItemCount() );

    pCrtDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver );

    ASSERT_VALID( pCrtDriverData );

    //
    // Determine what's the appropriate value for the second column
    //

    if( ! pCrtDriverData->Loads )
    {
        VERIFY( strStatus.LoadString( IDS_NEVER_LOADED ) );
    }
    else
    {
        if( pCrtDriverData->Loads == pCrtDriverData->Unloads )
        {
            VERIFY( strStatus.LoadString( IDS_UNLOADED ) );
        }
        else
        {
            if( pCrtDriverData->Loads > pCrtDriverData->Unloads )
            {
                VERIFY( strStatus.LoadString( IDS_LOADED ) );
            }
            else
            {
                ASSERT( FALSE );
                VERIFY( strStatus.LoadString( IDS_UNKNOWN ) );
            }
        }
    }

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = (INT)nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );

    if (NULL != lvItem.pszText)
    {
        VERIFY( m_DriversList.SetItem( &lvItem ) );
        strStatus.ReleaseBuffer();
    }
    else
    {
        lvItem.pszText = g_szVoidText;
        VERIFY( m_DriversList.SetItem( &lvItem ) );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::DrvStatusCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    int nCmpRez = 0;
    CRuntimeDriverData *pDriverData1;
    CRuntimeDriverData *pDriverData2;

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Difference between loads and unloads #
    //

    pDriverData1 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex1 );

    ASSERT_VALID( pDriverData1 );

    pDriverData2 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex2 );

    ASSERT_VALID( pDriverData2 );

    LONG lLoadDiff1 = (LONG) pDriverData1->Loads - (LONG) pDriverData1->Unloads;
    LONG lLoadDiff2 = (LONG) pDriverData2->Loads - (LONG) pDriverData2->Unloads;

    if( lLoadDiff1 == lLoadDiff2 )
    {
        //
        // Both loaded or both not loaded
        //

        if( pDriverData1->Loads == pDriverData2->Loads )
        {
            //
            // Loaded same number of times
            //

            nCmpRez = 0;
        }
        else
        {
            if( pDriverData1->Loads > pDriverData2->Loads )
            {
                nCmpRez = 2;
            }
            else
            {
                nCmpRez = -2;
            }
        }
    }
    else
    {
        if( lLoadDiff1 > lLoadDiff2 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }
    }

    if( FALSE != pThis->m_bAscendDrvStatusSort )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::DrvNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    int nCmpRez = 0;
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CRuntimeDriverData *pDriverData1;
    CRuntimeDriverData *pDriverData2;

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    pDriverData1 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex1 );

    ASSERT_VALID( pDriverData1 );

    pDriverData2 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex2 );

    ASSERT_VALID( pDriverData2 );

    nCmpRez = pDriverData1->m_strName.CompareNoCase( pDriverData2->m_strName );
    
    if( FALSE != pThis->m_bAscendDrvNameSort )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
//
// Settings bits list control methods
//

VOID CDriverStatusPage::SetupListHeaderSettBits()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettBitsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.25 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettBitsList.InsertColumn( 0, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettBitsList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.75 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettBitsList.InsertColumn( 1, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else 
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettBitsList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::FillTheListSettBits()
{
    //
    // N.B. 
    //
    // If you change the first parameter (index - stored in the item's data) 
    // you need to change the switch statement in IsSettBitEnabled as well
    //

    AddListItemSettBits( 0, m_RuntimeVerifierData.m_bSpecialPool,  IDS_SPECIAL_POOL  );
    AddListItemSettBits( 1, m_RuntimeVerifierData.m_bPoolTracking, IDS_POOL_TRACKING );
    AddListItemSettBits( 2, m_RuntimeVerifierData.m_bForceIrql,    IDS_FORCE_IRQL_CHECKING );
    AddListItemSettBits( 3, m_RuntimeVerifierData.m_bIo,           IDS_IO_VERIFICATION );
    AddListItemSettBits( 4, m_RuntimeVerifierData.m_bEnhIo,        IDS_ENH_IO_VERIFICATION );
    AddListItemSettBits( 5, m_RuntimeVerifierData.m_bDeadlockDetect, IDS_DEADLOCK_DETECTION );
    AddListItemSettBits( 6, m_RuntimeVerifierData.m_bDMAVerif,     IDS_DMA_CHECHKING );
    AddListItemSettBits( 7, m_RuntimeVerifierData.m_bLowRes,       IDS_LOW_RESOURCE_SIMULATION );
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::RefreshListSettBits()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtVerifierBit;
    BOOL bEnabled;
 
    nListItems = m_SettBitsList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
    {
        nCrtVerifierBit = m_SettBitsList.GetItemData( nCrtListItem );

        bEnabled = IsSettBitEnabled( nCrtVerifierBit );

        UpdateStatusColumnSettBits( nCrtListItem, bEnabled );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverStatusPage::SettbitsGetBitName( LPARAM lItemData, 
                                            TCHAR *szBitName,
                                            ULONG uBitNameBufferLen )
{
    INT nItemIndex;
    BOOL bResult;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    bResult = FALSE;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lItemData;

    nItemIndex = m_SettBitsList.FindItem( &FindInfo );

    if( nItemIndex < 0 || nItemIndex > 7 )
    {
        ASSERT( FALSE );
    }
    else
    {
        //
        // Found our item - get the name
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBitName;
        lvItem.cchTextMax = uBitNameBufferLen;

        bResult = m_SettBitsList.GetItem( &lvItem );
        ASSERT( bResult );
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverStatusPage::IsSettBitEnabled( INT_PTR nBitIndex )
{
    BOOL bEnabled;

    //
    // N.B. 
    //
    // If you change this switch statement you need to change FillTheListSettBits as well
    //

    switch( nBitIndex )
    {
    case 0:
        bEnabled = m_RuntimeVerifierData.m_bSpecialPool;
        break;

    case 1:
        bEnabled = m_RuntimeVerifierData.m_bPoolTracking;
        break;

    case 2:
        bEnabled = m_RuntimeVerifierData.m_bForceIrql;
        break;

    case 3:
        bEnabled = m_RuntimeVerifierData.m_bIo;
        break;

    case 4:
        bEnabled = m_RuntimeVerifierData.m_bEnhIo;
        break;

    case 5:
        bEnabled = m_RuntimeVerifierData.m_bDeadlockDetect;
        break;

    case 6:
        bEnabled = m_RuntimeVerifierData.m_bDMAVerif;
        break;

    case 7:
        bEnabled = m_RuntimeVerifierData.m_bLowRes;
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        bEnabled = FALSE;

        break;
    }

    return bEnabled;
}

/////////////////////////////////////////////////////////////////////////////
VOID CDriverStatusPage::AddListItemSettBits( INT nItemData, BOOL bEnabled, ULONG uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strText;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled 
    //

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    
    lvItem.iItem = m_SettBitsList.GetItemCount();

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

    if (NULL != lvItem.pszText)
    {
        nActualIndex = m_SettBitsList.InsertItem( &lvItem );
        strText.ReleaseBuffer();
    }
    else
    {
        lvItem.pszText = g_szVoidText;
        nActualIndex = m_SettBitsList.InsertItem( &lvItem );
    }

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strText.LoadString( uIdResourceString ) );

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettBitsList.SetItem( &lvItem ) );

    strText.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::UpdateStatusColumnSettBits( INT nItemIndex, BOOL bEnabled )
{
    LVITEM lvItem;
    CString strText;

    ASSERT( nItemIndex < m_SettBitsList.GetItemCount() );

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 0;
    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

    if (NULL != lvItem.pszText)
    {
        VERIFY( m_SettBitsList.SetItem( &lvItem ) );
        strText.ReleaseBuffer();
    }
    else
    {
        lvItem.pszText = g_szVoidText;
        VERIFY( m_SettBitsList.SetItem( &lvItem ) );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::SettbitsNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szBitName1[ _MAX_PATH ];
    TCHAR szBitName2[ _MAX_PATH ];

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first bit name
    //

    bSuccess = pThis->SettbitsGetBitName( lParam1, 
                                          szBitName1,
                                          ARRAY_LENGTH( szBitName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second bit name
    //

    bSuccess = pThis->SettbitsGetBitName( lParam2, 
                                          szBitName2,
                                          ARRAY_LENGTH( szBitName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szBitName1, szBitName2 );
    
    if( FALSE != pThis->m_bAscendSortNameBits )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::SettbitsEnabledCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bEnabled1;
    BOOL bEnabled2;

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    bEnabled1 = pThis->IsSettBitEnabled( (INT) lParam1 );
    bEnabled2 = pThis->IsSettBitEnabled( (INT) lParam2 );

    if( bEnabled1 == bEnabled2 )
    {
        nCmpRez = 0;
    }
    else
    {
        if( FALSE == bEnabled1 )
        {
            nCmpRez = -1;
        }
        else
        {
            nCmpRez = 1;
        }
    }

    if( FALSE != pThis->m_bAscendSortEnabledBits )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
//
// Other methods
//

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::SortTheListDrivers()
{
    if( 0 != m_nSortColumnIndexDrv )
    {
        //
        // Sort by status
        //

        m_DriversList.SortItems( DrvStatusCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by driver name
        //

        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::SortTheListSettBits()
{
    if( 0 != m_nSortColumnIndexSettbits )
    {
        //
        // Sort by bit name
        //

        m_SettBitsList.SortItems( SettbitsNameCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by enabled/disabled
        //

        m_SettBitsList.SortItems( SettbitsEnabledCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
// CDriverStatusPage message handlers

BOOL CDriverStatusPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    m_bTimerBlocked = FALSE;

    //
    // Setup the settings bits list
    //

    m_SettBitsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_SettBitsList.GetExtendedStyle() );

    m_SettBitsList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_SettBitsList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderSettBits();
    FillTheListSettBits();
    //SortTheListSettBits();

    //
    // Setup the drivers list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_DriversList.GetExtendedStyle() );

    m_DriversList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_DriversList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderDrivers();
    FillTheListDrivers();
    SortTheListDrivers();

    VrfSetWindowText( m_NextDescription, IDS_CRTSTAT_PAGE_NEXT_DESCR );

    VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
                                        5000,
                                        NULL ) );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the status column
        //

        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendDrvStatusSort = !m_bAscendDrvStatusSort;
        }
    }
    else
    {
        //
        // Clicked on the driver name column
        //

        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }

    m_nSortColumnIndexDrv = pNMListView->iSubItem;

    SortTheListDrivers();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::OnTimer(UINT nIDEvent) 
{
    if( m_bTimerBlocked != TRUE && nIDEvent == REFRESH_TIMER_ID )
    {
        ASSERT_VALID( m_pParentSheet );

        if( m_pParentSheet->GetActivePage() == this )
        {
            //
            // Refresh the displayed data 
            //

            RefreshInfo();
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverStatusPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_NEXT );
    	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CDriverStatusPage::OnWizardNext() 
{
    GoingToNextPageNotify( IDD_GLOBAL_COUNTERS_PAGE );

	return IDD_GLOBAL_COUNTERS_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnChsettButton() 
{
    CVolatileBitsDlg dlg;
    
    if( IDOK == dlg.DoModal() )
    {
        RefreshInfo();
    }
}

/////////////////////////////////////////////////////////////////////////////
#define VRF_MAX_CHARS_FOR_OPEN  4096

void CDriverStatusPage::OnAdddrvButton() 
{
    POSITION pos;
    BOOL bEnabledSome = FALSE;
    DWORD dwRetValue;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    int nFileNameStartIndex;
    INT_PTR nResult;
    TCHAR szDriversDir[ _MAX_PATH ];
    TCHAR szAppTitle[ _MAX_PATH ];
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "sys" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Drivers (*.sys)|*.sys||" ) );  // only one filter

    //
    // check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];

        if (szFilesBuffer == NULL)
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
            goto Done;
        }

        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    //
    // Dialog title
    //

    if( VrfLoadString(
        IDS_APPTITLE,
        szAppTitle,
        ARRAY_LENGTH( szAppTitle ) ) )
    {
        fileDlg.m_ofn.lpstrTitle = szAppTitle;
    }

    //
    // We change directory first time we try this to %windir%\system32\drivers
    //

    dwRetValue = ExpandEnvironmentStrings(
        _T( "%windir%\\system32\\drivers" ),
        szDriversDir,
        ARRAY_LENGTH( szDriversDir ) );

    if( dwRetValue > 0 && dwRetValue <= ARRAY_LENGTH( szDriversDir ) )
    {
        fileDlg.m_ofn.lpstrInitialDir = szDriversDir;
    }

    //
    // Show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            VrfErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            VrfErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // Split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // This shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // skip the backslash
            //

            nFileNameStartIndex += 1;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this driver to the current verification list
        //

        if( VrfAddDriverVolatile( strFileName ) )
        {
            bEnabledSome = TRUE;
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // Refresh
    //

    if( bEnabledSome == TRUE )
    {
        RefreshInfo();
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete [] szFilesBuffer;
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnRemdrvtButton() 
{
    INT nItems;
    INT nCrtItem;
    INT_PTR nIndexInArray;
    CRuntimeDriverData *pRuntimeDriverData;
    BOOL bDisabledSome = FALSE;

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // The number of items in the list
    //

    nItems = m_DriversList.GetItemCount();
    
    //
    // Parse all the items, looking for the selected ones.
    //

    for( nCrtItem = 0; nCrtItem < nItems; nCrtItem += 1 )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) & LVIS_SELECTED )
        {
            //
            // Get the index of the corresponding entry in the array
            //

            nIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            //
            // sanity checks
            //

            if( nIndexInArray >= m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() )
            {
                ASSERT( FALSE );
                continue;
            }

            pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nIndexInArray );
            ASSERT_VALID( pRuntimeDriverData );

            if( VrfRemoveDriverVolatile( pRuntimeDriverData->m_strName ) )
            {
                bDisabledSome = TRUE;
            }
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // If we disabled some drivers' verification we need to refresh the list
    //

    if( bDisabledSome )
    {
        RefreshInfo();
    }
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnColumnclickCrtstatSettbitsList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the bit name column
        //

        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortNameBits = !m_bAscendSortNameBits;
        }
    }
    else
    {
        //
        // Clicked on the enabled/disabled column
        //

        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortEnabledBits = !m_bAscendSortEnabledBits;
        }
    }

    m_nSortColumnIndexSettbits = pNMListView->iSubItem;

    SortTheListSettBits();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
LONG CDriverStatusPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\diskpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999-2001
//
//
//
// module: DiskPage.h
// author: DMihai
// created: 11/7/01
//
// Description:
//  

#if !defined(AFX_DISKPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_)
#define AFX_DISKPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DiskPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDiskListPage dialog

class CDiskListPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDiskListPage)

public:
    //
    // Construction
    //

	CDiskListPage();
	~CDiskListPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    VOID SetupListHeader();
    VOID FillTheList();
    VOID AddListItem( INT_PTR nItemData, 
                      CDiskData *pDiskData );

    BOOL GetNewVerifiedDisks();
    BOOL GetCheckFromItemData( INT nItemData );
    BOOL GetBitNameFromItemData( LPARAM lParam,
                                 TCHAR *szName,
                                 ULONG uNameBufferLength );

    VOID SortTheList();
    BOOL GetColumnStrValue( LPARAM lItemData, 
                            CString &strName );

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

    static int CALLBACK CheckedStatusCmpFunc( LPARAM lParam1,
                                              LPARAM lParam2,
                                              LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    INT m_nSortColumnIndex;        // selected status (0) or settings name (1)
    BOOL m_bAscendSortSelected;    // sort ascendent the selected status
    BOOL m_bAscendSortName;        // sort ascendent the settings name

    //
    // Dialog Data
    //


    //{{AFX_DATA(CDiskListPage)
	enum { IDD = IDD_DISK_LIST_PAGE };
	CListCtrl	m_DiskList;
	CStatic	m_NextDescription;
	//}}AFX_DATA


    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CDiskListPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CDiskListPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnColumnclickDiskList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DISKPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\diskpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DiskPage.cpp
// author: DMihai
// created: 11/7/01
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "DiskPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_DISKLIST_LIST,                IDH_DV_DisksEnabled_Disk_FullList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDiskListPage property page

IMPLEMENT_DYNCREATE(CDiskListPage, CVerifierPropertyPage)

CDiskListPage::CDiskListPage() 
    : CVerifierPropertyPage(CDiskListPage::IDD)
{
	//{{AFX_DATA_INIT(CDiskListPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 1;
    m_bAscendSortSelected = FALSE;
    m_bAscendSortName = TRUE;
}

CDiskListPage::~CDiskListPage()
{
}

void CDiskListPage::DoDataExchange(CDataExchange* pDX)
{
	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDiskListPage)
	DDX_Control(pDX, IDC_DISKLIST_LIST, m_DiskList);
	DDX_Control(pDX, IDC_DISKLIST_NEXT_DESCR_STATIC, m_NextDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDiskListPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CDiskListPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_DISKLIST_LIST, OnColumnclickDiskList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CDiskListPage::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_DiskList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.12 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DiskList.InsertColumn( 0, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DiskList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_DISK ) );

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.87 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DiskList.InsertColumn( 1, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DiskList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////////////////////
VOID CDiskListPage::FillTheList()
{
    INT_PTR nDisksNo;
    INT_PTR nCrtDiskIndex;
    CDiskData *pCrtDiskData;
    const CDiskDataArray &DiskDataArray = g_NewVerifierSettings.m_aDiskData;

    m_DiskList.DeleteAllItems();

    //
    // Parse the driver data array
    //

    nDisksNo = DiskDataArray.GetSize();

    for( nCrtDiskIndex = 0; nCrtDiskIndex < nDisksNo; nCrtDiskIndex += 1)
    {
        pCrtDiskData = DiskDataArray.GetAt( nCrtDiskIndex );

        ASSERT_VALID( pCrtDiskData );

        AddListItem( nCrtDiskIndex, 
                     pCrtDiskData );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDiskListPage::GetNewVerifiedDisks()
{
    INT nListItemCount; 
    INT nCrtListItem;
    INT_PTR nCrtDisksArrayIndex;
    BOOL bSomeDisksVerified;
    BOOL bVerified;
    CDiskData *pCrtDiskData;
    CDiskDataArray &DiskDataArray = g_NewVerifierSettings.m_aDiskData;
   
    bSomeDisksVerified = FALSE;

    nListItemCount = m_DiskList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItemCount; nCrtListItem += 1 )
    {
        //
        // Verification status for the current list item
        //

        bVerified = m_DiskList.GetCheck( nCrtListItem );

        if( bVerified )
        {
            bSomeDisksVerified = TRUE;
        }

        //
        // Set the right verify state in our disk array 
        //

        nCrtDisksArrayIndex = m_DiskList.GetItemData( nCrtListItem );

        pCrtDiskData = DiskDataArray.GetAt( nCrtDisksArrayIndex );

        ASSERT_VALID( pCrtDiskData );

        pCrtDiskData->m_bVerifierEnabled = bVerified;
    }

    return bSomeDisksVerified;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDiskListPage::GetCheckFromItemData( INT nItemData )
{
    BOOL bChecked = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = nItemData;

    nItemIndex = m_DiskList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        bChecked = m_DiskList.GetCheck( nItemIndex );
    }

    return bChecked;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDiskListPage::GetBitNameFromItemData( LPARAM lParam,
                                                    TCHAR *szName,
                                                    ULONG uNameBufferLength )
{
    BOOL bSuccess = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam;

    nItemIndex = m_DiskList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        //
        // Found it
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 1;
        lvItem.pszText = szName;
        lvItem.cchTextMax = uNameBufferLength;

        bSuccess = m_DiskList.GetItem( &lvItem );
        ASSERT( bSuccess );
    }

    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
VOID CDiskListPage::AddListItem( INT_PTR nItemData, 
                                 CDiskData *pDiskData )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    ASSERT_VALID( pDiskData );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // Sub-item 0 - enabled/diabled - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_DiskList.GetItemCount();

    nActualIndex = m_DiskList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_DiskList.SetCheck( nActualIndex, pDiskData->m_bVerifierEnabled );

    //
    // Sub-item 1 - disk name
    //

    lvItem.pszText = pDiskData->m_strDiskDevicesForDisplay.GetBuffer( 
        pDiskData->m_strDiskDevicesForDisplay.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_DiskList.SetItem( &lvItem ) );

    pDiskData->m_strDiskDevicesForDisplay.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CDiskListPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by settings name
        //

        m_DiskList.SortItems( StringCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by selected status
        //

        m_DiskList.SortItems( CheckedStatusCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CDiskListPage::StringCmpFunc( LPARAM lParam1,
                                           LPARAM lParam2,
                                           LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szBitName1[ _MAX_PATH ];
    TCHAR szBitName2[ _MAX_PATH ];

    CDiskListPage *pThis = (CDiskListPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 != pThis->m_nSortColumnIndex );

    //
    // Get the first name
    //

    bSuccess = pThis->GetBitNameFromItemData( lParam1, 
                                              szBitName1,
                                              ARRAY_LENGTH( szBitName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetBitNameFromItemData( lParam2, 
                                              szBitName2,
                                              ARRAY_LENGTH( szBitName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szBitName1, szBitName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
int CALLBACK CDiskListPage::CheckedStatusCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    int nCmpRez = 0;
    INT nItemIndex;
    BOOL bVerified1;
    BOOL bVerified2;
    LVFINDINFO FindInfo;

    CDiskListPage *pThis = (CDiskListPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 == pThis->m_nSortColumnIndex );

    //
    // Find the first item
    //

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam1;

    nItemIndex = pThis->m_DiskList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified1 = pThis->m_DiskList.GetCheck( nItemIndex );

    //
    // Find the second item
    //

    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam2;

    nItemIndex = pThis->m_DiskList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified2 = pThis->m_DiskList.GetCheck( nItemIndex );

    //
    // Compare them
    //
    
    if( bVerified1 != bVerified2 )
    {
        if( FALSE != bVerified1 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }

        if( FALSE != pThis->m_bAscendSortSelected )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////////////////////
// CDiskListPage message handlers

BOOL CDiskListPage::OnWizardFinish() 
{
    BOOL bExitTheApp;

    bExitTheApp = FALSE;

    if( GetNewVerifiedDisks() == TRUE )
    {
        g_NewVerifierSettings.SaveToRegistry();
	    
        //
        // Exit the app
        //

	    bExitTheApp = CVerifierPropertyPage::OnWizardFinish();
    }
    else
    {
        VrfErrorResourceFormat( IDS_SELECT_AT_LEAST_ONE_DISK );
    }

    return bExitTheApp;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDiskListPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();

    //
    // setup the list
    //

    m_DiskList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_DiskList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList();
	
    VrfSetWindowText( m_NextDescription, IDS_DISKLIST_PAGE_FINISH_DESCR );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CDiskListPage::OnColumnclickDiskList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }
    else
    {
        //
        // Clicked on the selected status column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortSelected = !m_bAscendSortSelected;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDiskListPage::OnSetActive() 
{
    //
    // This is always the last page of the wizard.
    //

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_FINISH );

    return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////
LONG CDiskListPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDiskListPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\dsetpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DSetPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "DSetPage.h"
#include "VSheet.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_DRVSET_NOTSIGNED_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_DRVSET_NOTSIGNED_RADIO,     IDH_DV_SelectUnsigned,
    IDC_DRVSET_OLDVER_RADIO,        IDH_DV_SelectOlderversions,
    IDC_DRVSET_ALLDRV_RADIO,        IDH_DV_SelectAll,
    IDC_DRVSET_NAMESLIST_RADIO,     IDH_DV_SelectFromList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDriverSetPage property page

IMPLEMENT_DYNCREATE(CDriverSetPage, CVerifierPropertyPage)

CDriverSetPage::CDriverSetPage() 
    : CVerifierPropertyPage( CDriverSetPage::IDD )
{
    //{{AFX_DATA_INIT(CDriverSetPage)
	m_nCrtRadio = -1;
	//}}AFX_DATA_INIT
}

CDriverSetPage::~CDriverSetPage()
{
}

void CDriverSetPage::DoDataExchange(CDataExchange* pDX)
{
	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDriverSetPage)
	DDX_Control(pDX, IDC_DRVSET_NEXT_DESCR_STATIC, m_NextDescription);
	DDX_Radio(pDX, IDC_DRVSET_NOTSIGNED_RADIO, m_nCrtRadio);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverSetPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CDriverSetPage)
	ON_BN_CLICKED(IDC_DRVSET_ALLDRV_RADIO, OnAlldrvRadio)
	ON_BN_CLICKED(IDC_DRVSET_NAMESLIST_RADIO, OnNameslistRadio)
	ON_BN_CLICKED(IDC_DRVSET_NOTSIGNED_RADIO, OnNotsignedRadio)
	ON_BN_CLICKED(IDC_DRVSET_OLDVER_RADIO, OnOldverRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CDriverSetPage message handlers

/////////////////////////////////////////////////////////////////////////////
LRESULT CDriverSetPage::OnWizardBack() 
{
    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();
	
	return CVerifierPropertyPage::OnWizardBack();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CDriverSetPage::OnWizardNext() 
{
    LRESULT lNextPageId;
    BOOL bHaveDriversToVerify;

    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        if( m_nCrtRadio != IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID )
        {
            //
            // Look if we already have loaded the list of drivers
            // with version information, etc. and if we need it
            //

            ASSERT( IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID != m_nCrtRadio );

            if( TRUE != g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized )
            {
                if( NULL == g_SlowProgressDlg.m_hWnd )
                {
                    //
                    // This is the first time we are showing the 
                    // "slow progress" dialog so create it first
                    //

                    g_SlowProgressDlg.Create( CSlowProgressDlg::IDD, AfxGetMainWnd() );
                }

                //
                // Show the dialog
                //

                g_SlowProgressDlg.ShowWindow( SW_SHOW );

                //
                // Start the worker thread to do the work in background
                // while the initial thread updates the GUI. If the thread ends
                // successfully it will press our "Next" button at the end, after setting
                // g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized to TRUE
                //

                g_SlowProgressDlg.StartWorkerThread( CSlowProgressDlg::LoadDriverDataWorkerThread,
                                                     IDS_LOADING_DRIVER_INFORMATION );

                //
                // Wait for the "next" button again
                //

                goto Done;
            }
        }

        //
        // We have already loaded information (name, version, etc.) about 
        // the currently loaded drivers if have gotten to this point and 
        // we are not in the "verify all drivers" case.
        //

        //
        // Select the set of drivers corresponding to user's selection
        //

        switch( m_nCrtRadio )
        {
        case IDC_DRVSET_NAMESLIST_RADIO - FIRST_RADIO_BUTTON_ID:
            
            //
            // Custom list of drivers
            //

            g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetCustom;

            lNextPageId = IDD_SELECT_DRIVERS_PAGE;
            
            break;

        case IDC_DRVSET_OLDVER_RADIO - FIRST_RADIO_BUTTON_ID:
            //
            // Drivers compiled for old versions of Windows
            //

            //
            // The list of drivers is ready because we waited the 
            // worker thread to finish up execution - go to the next page
            //

            g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetOldOs;
            
            bHaveDriversToVerify = g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers();

            if( TRUE == bHaveDriversToVerify )
            {
                //
                // We have at least one old driver to verify
                //

                lNextPageId = IDD_CONFIRM_DRIVERS_PAGE;

                //
                // Set the title of the driver list confirmation page
                //

                ASSERT_VALID( m_pParentSheet );

                m_pParentSheet->SetContextStrings( IDS_OLD_DRIVERS_LIST );
            }
            else
            {
                //
                // We don't have any old drivers currently installed
                //

                VrfMesssageFromResource( IDS_NO_OLD_DRIVERS_FOUND );
            }

            break;

        case IDC_DRVSET_NOTSIGNED_RADIO - FIRST_RADIO_BUTTON_ID:
            //
            // Not signed drivers
            //

            if( FALSE == g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized ) 
            {
                //
                // We should have displayed the "slow progress" dialog 
                // at least once before (when we have loaded the list of drivers)
                // so we don't even try to create the modeless dialog.
                //

                ASSERT( NULL != g_SlowProgressDlg.m_hWnd );
                
                //
                // Show the dialog though
                //

                g_SlowProgressDlg.ShowWindow( SW_SHOW );
                
                //
                // Start the worker thread to do the work in background
                // while the initial thread updates the GUI. If the thread ends
                // successfully it will press our "Next" button at the end, after setting
                // g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized to TRUE
                //

                g_SlowProgressDlg.StartWorkerThread( CSlowProgressDlg::SearchUnsignedDriversWorkerThread,
                                                     IDS_SEARCHING_FOR_UNSIGNED_DRIVERS );

                //
                // Wait for the "next" button again
                //

                goto Done;
            }
            else
            {
                g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetNotSigned;

                bHaveDriversToVerify = g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers();

                if( TRUE == bHaveDriversToVerify )
                {
                    //
                    // The list of drivers is ready - go to the next page
                    //

                    lNextPageId = IDD_CONFIRM_DRIVERS_PAGE;

                    //
                    // Set the title of the driver list confirmation page
                    //

                    ASSERT_VALID( m_pParentSheet );

                    m_pParentSheet->SetContextStrings( IDS_UNSIGNED_DRIVERS_LIST );
                }
                else
                {
                    //
                    // We don't have any unsigned drivers currently installed
                    //

                    VrfMesssageFromResource( IDS_NO_UNSIGNED_DRIVERS_FOUND );
                }
            }
            break;

        case IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID:
            
            //
            // We can get here only if the disk integrity checking is enabled.
            //

            ASSERT( FALSE != g_bShowDiskPropertyPage ||
                    FALSE != g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk() );

            g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetAllDrivers;

            lNextPageId = IDD_DISK_LIST_PAGE;
            
            break;

        default:

            ASSERT( FALSE );
            break;
        }
    }

    GoingToNextPageNotify( lNextPageId );

Done:
    return lNextPageId;
}


/////////////////////////////////////////////////////////////////////////////
BOOL CDriverSetPage::OnWizardFinish() 
{
    BOOL bFinish;

    bFinish = FALSE;

    if( UpdateData( TRUE ) == TRUE )
    {
        //
        // If the user has pressed the "Finish" button that
        // would mean that she selected "all drivers" to be verified
        //

        ASSERT( IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio );

        g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetAllDrivers;
        
        bFinish = g_NewVerifierSettings.SaveToRegistry();
    }
	
	CVerifierPropertyPage::OnWizardFinish();

    return bFinish;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverSetPage::OnSetActive() 
{
    switch( m_nCrtRadio )
    {
    case IDC_DRVSET_NAMESLIST_RADIO - FIRST_RADIO_BUTTON_ID:
        VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_NAMELIST );
        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );
        break;

    case IDC_DRVSET_OLDVER_RADIO - FIRST_RADIO_BUTTON_ID:
        VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_OLD );
        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );
        break;

    case IDC_DRVSET_NOTSIGNED_RADIO - FIRST_RADIO_BUTTON_ID:
        VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED );
        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );
        break;

    case IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID:
        if( (FALSE == g_bShowDiskPropertyPage) &&
            (FALSE == g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk()) )
        {
            m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_FINISH );
            VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_ALL );
        }
        else
        {
            VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_ALL_HAVEDISKS );
            m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );
        }
        break;

    default:

        ASSERT( FALSE );
        break;
    }

	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverSetPage::OnInitDialog() 
{
    //
    // Don't try to reconstruct the current data from the registry
    // to the GUI because it's too hard. Always start with the 
    // default radio button: unsigned drivers
    //

    m_nCrtRadio = IDC_DRVSET_NOTSIGNED_RADIO - FIRST_RADIO_BUTTON_ID;
	
	CVerifierPropertyPage::OnInitDialog();

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CDriverSetPage::OnAlldrvRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    if( FALSE != g_bShowDiskPropertyPage ||
        FALSE != g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk() )
    {
        //
        // We need to show the next page with the disks to be verified.
        //

        m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
        VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_ALL_HAVEDISKS );
    }
    else
    {
        //
        // No disk integrity checking is enabled so this is the last page.
        //

        m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
        VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_ALL );
    }
}

void CDriverSetPage::OnNameslistRadio() 
{
    ASSERT_VALID( m_pParentSheet );
    
    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_NAMELIST );
}

void CDriverSetPage::OnNotsignedRadio() 
{
    ASSERT_VALID( m_pParentSheet );
    
    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED );
}

void CDriverSetPage::OnOldverRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_OLD );
}

/////////////////////////////////////////////////////////////
void CDriverSetPage::OnCancel() 
{
    g_SlowProgressDlg.KillWorkerThread();
	
	CVerifierPropertyPage::OnCancel();
}

/////////////////////////////////////////////////////////////
LONG CDriverSetPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverSetPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\dstspage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DStsPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_DRIVERSTATUSPAGE_H__24C9AD87_924A_4E7B_99D3_A69947701E74__INCLUDED_)
#define AFX_DRIVERSTATUSPAGE_H__24C9AD87_924A_4E7B_99D3_A69947701E74__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DriverStatusPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverStatusPage dialog

class CDriverStatusPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDriverStatusPage)

// Construction
public:
	CDriverStatusPage();
	~CDriverStatusPage();

protected:
    //
    // Data
    //

    CPropertySheet *m_pParentSheet;

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Driver list sort parameters
    //

    INT m_nSortColumnIndexDrv;      // sort by name (0) or by status (1)
    BOOL m_bAscendDrvNameSort;      // sort ascendent by name
    BOOL m_bAscendDrvStatusSort;    // sort ascendent by status

    //
    // Settings bits sort parameters
    //

    INT m_nSortColumnIndexSettbits; // sort by enabled/disabled (0) or by bit name (1)
    BOOL m_bAscendSortEnabledBits;  // sort ascendent by enabled/disabled
    BOOL m_bAscendSortNameBits;     // sort ascendent by bit name

    //
    // Timer handler, returned by SetTimer()
    //

    UINT_PTR m_uTimerHandler;   

    BOOL m_bTimerBlocked;

    //
    // Dialog Data
    //

	//{{AFX_DATA(CDriverStatusPage)
	enum { IDD = IDD_DRVSTATUS_STAT_PAGE };
	CListCtrl	m_SettBitsList;
	CStatic	m_NextDescription;
    CListCtrl	m_DriversList;
	//}}AFX_DATA
public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:

    VOID RefreshInfo();

    //
    // Driver status list control methods
    //

    VOID SetupListHeaderDrivers();
    VOID FillTheListDrivers();
    VOID UpdateStatusColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver );
    VOID SortTheListDrivers();

    static int CALLBACK DrvStatusCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK DrvNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    //
    // Settings bits list control methods
    //

    VOID SetupListHeaderSettBits();
    VOID FillTheListSettBits();
    VOID AddListItemSettBits( INT nItemData, BOOL bEnabled, ULONG uIdResourceString );
    VOID UpdateStatusColumnSettBits( INT nIndexInList, BOOL bEnabled );
    VOID RefreshListSettBits();
    VOID SortTheListSettBits();

    BOOL SettbitsGetBitName( LPARAM lItemData, 
                             TCHAR *szBitName,
                             ULONG uBitNameBufferLen );

    BOOL IsSettBitEnabled( INT_PTR nBitIndex );

    static int CALLBACK SettbitsEnabledCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK SettbitsNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CDriverStatusPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
    virtual VOID DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDriverStatusPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg VOID OnTimer(UINT nIDEvent);
	afx_msg void OnChsettButton();
	afx_msg void OnAdddrvButton();
	afx_msg void OnRemdrvtButton();
	afx_msg void OnColumnclickCrtstatSettbitsList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DRIVERSTATUSPAGE_H__24C9AD87_924A_4E7B_99D3_A69947701E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\dsetpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DSetPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_DSETPAGE_H__FCB7F146_7EE5_4A08_B7B4_ECE172A70098__INCLUDED_)
#define AFX_DSETPAGE_H__FCB7F146_7EE5_4A08_B7B4_ECE172A70098__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DSetPage.h : header file
//

#include "vsetting.h"
#include "VerfPage.h"

//
// Forward declarations
//

class CVerifierPropSheet;

/////////////////////////////////////////////////////////////////////////////
// CDriverSetPage dialog

class CDriverSetPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDriverSetPage)

public:
    //
    // Construction/destruction
    //

	CDriverSetPage();
	~CDriverSetPage();

    //
    // Methods
    //

    VOID SetParentSheet( CVerifierPropSheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Dialog Data
    //

    CVerifierPropSheet      *m_pParentSheet;

    //{{AFX_DATA(CDriverSetPage)
	enum { IDD = IDD_DRVSET_PAGE };
	CStatic	m_NextDescription;
	int		m_nCrtRadio;
	//}}AFX_DATA

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CDriverSetPage)
    public:
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    virtual BOOL OnSetActive();
    virtual void OnCancel();
    virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CDriverSetPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnAlldrvRadio();
    afx_msg void OnNameslistRadio();
    afx_msg void OnNotsignedRadio();
    afx_msg void OnOldverRadio();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DSETPAGE_H__FCB7F146_7EE5_4A08_B7B4_ECE172A70098__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\flpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: FLPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "FLPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_FLSETT_LIST,                IDH_DV_SettingsEnabled_TestType_FullList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CFullListSettingsPage property page

IMPLEMENT_DYNCREATE(CFullListSettingsPage, CVerifierPropertyPage)

CFullListSettingsPage::CFullListSettingsPage() 
    : CVerifierPropertyPage(CFullListSettingsPage::IDD)
{
	//{{AFX_DATA_INIT(CFullListSettingsPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 1;
    m_bAscendSortSelected = FALSE;
    m_bAscendSortName = TRUE;

    m_bIoVerif = FALSE;
    m_bIrqLevel = FALSE;
    m_bLowRes = FALSE;
    m_bPoolTrack = FALSE;
    m_bSPool = FALSE;
    m_bDeadlock = FALSE;
    m_bDMA = FALSE;
    m_bEnhIoVerif = FALSE;
    m_bDiskIntegrity = FALSE;
}

CFullListSettingsPage::~CFullListSettingsPage()
{
}

void CFullListSettingsPage::DoDataExchange(CDataExchange* pDX)
{

	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFullListSettingsPage)
	DDX_Control(pDX, IDC_FLSETT_LIST, m_SettingsList);
	DDX_Control(pDX, IDC_FLSETT_NEXT_DESCR_STATIC, m_NextDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFullListSettingsPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CFullListSettingsPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_FLSETT_LIST, OnColumnclickFlsettList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettingsList.GetClientRect( &re