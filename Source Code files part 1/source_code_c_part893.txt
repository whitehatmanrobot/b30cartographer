efore you've finished initializing it, possibly causing an access
* violation.)
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

HDD_OBJ
DdHmgAlloc(
    ULONGSIZE_T cb,
    DD_OBJTYPE  objt,
    FSHORT      fs) // fs can be a combination of the following:
                    //  HMGR_NO_ZERO_INIT   - Don't zero initialize
                    //  HMGR_MAKE_PUBLIC    - Allow object to be lockable by
                    //                        any process
                    //  HMGR_ALLOC_LOCK     - Do an DdHmgLock on the object and
                    //                        return a pointer instead of handle
{
    HDD_OBJ Handle;
    PVOID   pv;

    ASSERTGDI(objt != (DD_OBJTYPE) DD_DEF_TYPE, "DdHmgAlloc objt is bad");
    ASSERTGDI(cb >= 8, "ERROR DdHmgr writes in first 8 bytes");

    //
    // Allocate a pointer.
    //

    pv = DdAllocateObject(cb, (ULONG) objt, ((fs & HMGR_NO_ZERO_INIT) == 0));

    if (pv != (PVOID) NULL)
    {
        //
        // We need the semaphore to access the free list
        //

        DdHmgAcquireHmgrSemaphore();

        //
        // Allocate a handle: can only fail if we run out of memory or bits to 
        // store the handle index.
        //
        
        Handle = hDdGetFreeHandle(objt);

        if (Handle != (HDD_OBJ) 0)
        {
            //
            // Store a pointer to the object in the entry corresponding to the
            // allocated handle and initialize the handle data.
            //

            ((DD_ENTRYOBJ *) &(gpentDdHmgr[DdHmgIfromH(Handle)]))->vSetup((PDD_OBJ) pv, objt, fs);

            //
            // Store the object handle at the beginning of the object memory.
            //

            ((DD_OBJECT *)pv)->hHmgr = (HANDLE)Handle;

            DdHmgReleaseHmgrSemaphore();

            return ((fs & HMGR_ALLOC_LOCK) ? (HDD_OBJ)pv : Handle);
        }
        else
        {
            //
            // We just failed a handle allocation.  Release the memory.
            //

            WARNING("Failed DdHmgAlloc to allocate a handle\n");

            DdHmgReleaseHmgrSemaphore();
            DdFreeObject(pv,(ULONG) objt);
        }
    }

    return((HDD_OBJ) 0);
}

/******************************Public*Routine******************************\
* DdFreeObject
*
* Frees the object from where it was allocated. We have this as a separate
* function in case we implement lookaside lists (as in GDI) later.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

VOID 
DdFreeObject(PVOID pvFree, ULONG ulType)
{
    VFREEMEM(pvFree);
}

/******************************Public*Routine******************************\
* DdHmgFree
*
* Free an object from the handle manager.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

VOID 
DdHmgFree(HDD_OBJ hobj)
{
    UINT       uiIndex = (UINT) DdHmgIfromH(hobj);
    PDD_OBJ    pobjTmp;
    DD_OBJTYPE objtTmp;

    ASSERTGDI(uiIndex != 0, "ERROR DdHmgFree invalid 0 handle");

    if (uiIndex < gcMaxDdHmgr)
    {
        //
        // Acquire the handle manager lock before touching gpentDdHmgr
        //

        DdHmgAcquireHmgrSemaphore();


        PDD_ENTRY pentTmp = &gpentDdHmgr[uiIndex];

        pobjTmp = pentTmp->einfo.pobj;
        objtTmp = pentTmp->Objt;

        //
        // Free the object handle
        //

        ((DD_ENTRYOBJ *) pentTmp)->vFree(uiIndex);


        DdHmgReleaseHmgrSemaphore();

        if (pobjTmp)
        {
            DdFreeObject((PVOID)pobjTmp, (ULONG) objtTmp);
        }
    }
    else
    {
        WARNING1("DdHmgFree: bad handle index");
    }
}

/*****************************Exported*Routine*****************************\
* HDD_OBJ DdHmgNextOwned(hobj, pid)
*
* Report the next object owned by specified process
*
* Must be called with the Hmgr semaphore acquired.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

HDD_OBJ
FASTCALL
DdHmgNextOwned(
    HDD_OBJ hobj,
    W32PID pid)
{
    PDD_ENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) DdHmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxDdHmgr)
    {
        pentTmp = (PDD_ENTRYOBJ) &gpentDdHmgr[uiIndex];

        if (pentTmp->bOwnedBy(pid))
        {
            LONG_PTR uiIndex1 = (LONG_PTR)DD_MAKE_HMGR_HANDLE(uiIndex,pentTmp->FullUnique);

            return((HDD_OBJ)(uiIndex1 & 0xFFFFFFFF));
        }

        // Advance to next object
        uiIndex++;
    }

    // No objects found

    return((HDD_OBJ) 0);
}

/*****************************Exported*Routine*****************************\
* HDD_OBJ DdHmgNextObjt
*
* Report the next object of a certain type.
*
* Must be called with the Hmgr semaphore acquired.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

PDD_OBJ
FASTCALL
DdHmgNextObjt(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt)
{
    PDD_ENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) DdHmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxDdHmgr)
    {
        pentTmp = (PDD_ENTRYOBJ) &gpentDdHmgr[uiIndex];

        if (pentTmp->Objt == objt)
        {
            return(pentTmp->einfo.pobj);
        }

        //
        // Advance to next object
        //

        uiIndex++;
    }

    //
    // no objects found
    //

    return((PDD_OBJ) 0);
}

/*******************************Routine************************************\
* DdHmgLock
*
* Description:
*
*   Acquire an exclusive lock on an object, PID owner must match current PID
*   or be a public.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

PDD_OBJ
FASTCALL
DdHmgLock(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt,
    BOOL       underSemaphore
    )
{
    PDD_OBJ pobj    = (PDD_OBJ)NULL;
    UINT    uiIndex = (UINT)DdHmgIfromH(hobj);

    //
    // Acquire the handle manager lock before touching gpentDdHmgr
    // Only do this if we are not already under the semaphore
    //

    if (!underSemaphore) {
        DdHmgAcquireHmgrSemaphore();
    }
 
    if (uiIndex < gcMaxDdHmgr)
    {
        PDD_ENTRY pentry = &gpentDdHmgr[uiIndex];

        if (VerifyObjectOwner(pentry))
        {
            if ((pentry->Objt == objt) &&
                (pentry->FullUnique == DdHmgUfromH(hobj)))
            {
                ULONG_PTR thread = (ULONG_PTR)PsGetCurrentThread();

                pobj = pentry->einfo.pobj;

                if ((pobj->cExclusiveLock == 0) ||
                    (pobj->Tid == thread))
                {
                    INC_EXCLUSIVE_REF_CNT(pobj);
                    pobj->Tid = thread;
                }
                else
                {
                    WARNING1("DdHmgLock: object already locked by another thread");
                    pobj = (PDD_OBJ)NULL;
                }
            }
            else
            {
                DdHmgPrintBadHandle(hobj, objt);
            }
        }
        else
        {
            DdHmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        DdHmgPrintBadHandle(hobj, objt);
    }

    if (!underSemaphore) {
        DdHmgReleaseHmgrSemaphore();
    }

    return(pobj);
}

/******************************Public*Routine******************************\
* DdHmgQueryLock
*
* This returns the number of times an object has been Locked.
*
* Expects: A valid handle.  The handle should be validated and locked
*          before calling this. Note we don't need to grab the semaphore 
*          because this call assumes the handle has already been locked 
*          down and we are just reading memory.
*
* Returns: The number of times the object has been locked.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

ULONG 
FASTCALL 
DdHmgQueryLock(HDD_OBJ hobj)
{
    //
    // Acquire the handle manager lock before touching gpentDdHmgr
    //

    DdHmgAcquireHmgrSemaphore();

    UINT uiIndex = (UINT)DdHmgIfromH(hobj);
    ASSERTGDI(uiIndex < gcMaxDdHmgr, "DdHmgQueryLock invalid handle");

    ULONG ulRes = gpentDdHmgr[uiIndex].einfo.pobj->cExclusiveLock;

    DdHmgReleaseHmgrSemaphore();

    return ulRes;
}

/******************************Public*Routine******************************\
* HDD_OBJ hDdGetFreeHandle()
*
* Get the next available handle. If the handle table is full, we grow it. 
* This function can fail under any of these circumstances:
* 1. Handle manager didn't initialize
* 2. Insufficient memory to grow the handle table
* 3. Insufficient bits to store the handle index
*
* Note: 
*    We must already have the HmgrSemaphore
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

HDD_OBJ 
hDdGetFreeHandle(
    DD_OBJTYPE objt
    )
{
    LONG_PTR uiIndex;

    // 
    // Handle manager initialized and bounds check
    //

    if ((gpentDdHmgr == NULL) || (gcMaxDdHmgr == DD_MAX_HANDLE_COUNT))
    {
        return ((HDD_OBJ)0);
    }
    
    //
    // Check if there is a free handle we can use
    //

    if (ghFreeDdHmgr != (HDD_OBJ) 0)
    {
        PDD_ENTRYOBJ pentTmp;

        uiIndex = (LONG_PTR)ghFreeDdHmgr;
        pentTmp = (PDD_ENTRYOBJ) &gpentDdHmgr[uiIndex];
        ghFreeDdHmgr = pentTmp->einfo.hFree;

        pentTmp->FullUnique = DD_USUNIQUE(pentTmp->FullUnique,objt);

        uiIndex = (LONG_PTR)DD_MAKE_HMGR_HANDLE(uiIndex,pentTmp->FullUnique);

        return((HDD_OBJ)(uiIndex & 0xFFFFFFFF));
    }

    //
    // Check if we've run out of handles
    //
    
    if (gcMaxDdHmgr == gcSizeDdHmgr)
    {
        // Increase the table size
        
        ULONG dwNewSize = gcSizeDdHmgr + DD_TABLESIZE_DELTA;

        // Allocate a new block 
        DD_ENTRY *ptHmgr = (DD_ENTRY *)PALLOCMEM(sizeof(DD_ENTRY) * dwNewSize, 'ddht');

        if (ptHmgr == NULL)
        {
            WARNING("DdHmgr failed to grow handle table\n");
            return ((HDD_OBJ) 0);
        }

        // 
        // Copy the old handles into the new table
        //

        RtlMoveMemory(ptHmgr, gpentDdHmgr, sizeof(DD_ENTRY) * gcSizeDdHmgr);

        gcSizeDdHmgr = dwNewSize;
        gpentDdHmgrLast = gpentDdHmgr;
        VFREEMEM(gpentDdHmgr); 
        gpentDdHmgr = ptHmgr;
    }
    
    //
    // Allocate a new handle table entry and set the uniqueness value.
    //

    uiIndex = DD_USUNIQUE(DD_UNIQUE_INCREMENT,objt);
    gpentDdHmgr[gcMaxDdHmgr].FullUnique = (USHORT) uiIndex;
    uiIndex = (LONG_PTR)DD_MAKE_HMGR_HANDLE(gcMaxDdHmgr,uiIndex);
    gcMaxDdHmgr++;

    return((HDD_OBJ)(uiIndex & 0xFFFFFFFF));
}

/******************************Public*Routines*****************************\
* DdHmgAcquireHmgrSemaphore                                                *
* DdHmgReleaseHmgrSemaphore                                                *
*                                                                          *
* Convenience functions for the handle manager semaphore.                  *
*                                                                          *
\**************************************************************************/

VOID
DdHmgAcquireHmgrSemaphore()
{
    EngAcquireSemaphore(ghsemHmgr);
}

VOID
DdHmgReleaseHmgrSemaphore()
{
    EngReleaseSemaphore(ghsemHmgr);
}

/******************************Public*Routine******************************\
* DdHmgPrintBadHandle
*
*   Simple routine that prints out a warning when a handle manager
*   lock fails due to a bad handle.
*
\**************************************************************************/

#if DBG

CONST CHAR* aszDdType[] = {
    "hdef",         // DD_DEF_TYPE
    "hddraw",       // DD_DIRECTDRAW_TYPE
    "hddrawsurf",   // DD_SURFACE_TYPE
    "hd3d",         // D3D_HANDLE_TYPE
    "hddrawvport",  // DD_VIDEOPORT_TYPE
    "hmotioncomp",  // DD_MOTIONCOMP_TYPE
    "hunused",      //
};

VOID
DdHmgPrintBadHandle(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt
    )
{
    static CHAR *szSystem = "System";
    static CHAR *szUnknown = "???";
    CHAR        *pszImage;

    {
        PETHREAD    pet;
        PEPROCESS   pep;

        if (pep = PsGetCurrentProcess())
        {
            pszImage = (CHAR *)PsGetProcessImageFileName(pep);
            if (*pszImage == '\0')
            {
                pszImage = szSystem;
            }
        }
        else
        {
            pszImage = szUnknown;
        }
    }

    KdPrint(("DXG: %s or DLL gave bad handle 0x%p as an %s.\n",
               pszImage,                     hobj,   aszDdType[objt]));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddraw.cxx ===
/******************************Module*Header*******************************\
* Module Name: ddraw.cxx
*
* Contains all of GDI's private DirectDraw APIs.
*
* Created: 3-Dec-1995
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"


#if 0
#define DBG_DDKHEAP
#define DDKHEAP(Args) KdPrint(Args)
#else
#define DDKHEAP(Args)
#endif

#if 0
#define DBG_DDKSURF
#define DDKSURF(Args) KdPrint(Args)
#else
#define DDKSURF(Args)
#endif


// Several AGP routines take an hdev that is some cookie useful in
// AGP operations.  On NT, it's a pointer to the EDD_DIRECTDRAW_GLOBAL.
// This macro is largely just a marker in case it changes in the
// future.

#define AGP_HDEV(peDirectDrawGlobal) ((HANDLE)peDirectDrawGlobal)

// This variable is kept for stress debugging purposes.  When a mode change
// or desktop change is pending and an application has outstanding locks
// on the frame buffer, we will by default wait up to 7 seconds for the
// application to release its locks, before we will unmap the view anyway.
// 'gfpUnmap' will be user-mode address of the unmapped frame buffer, which
// will be useful for determining in stress whether an application had its
// frame buffer access rescinded, or whether it was using a completely bogus
// frame buffer pointer to begin with:

FLATPTR gfpUnmap = 0;

// The following global variables are kept only for debugging purposes, to
// aid in tracking DC drawing to surfaces that have been lost:

HDC ghdcGetDC;
HDC ghdcCantLose;

#ifdef DX_REDIRECTION

// The following global variable is kept the boolean value if system are in
// redirection mode or not.
//
// If system is in redirection mode, we disable ...
//
//  + Overlay.
//  + Primary surface lock (LATER).
//
// !!! Currently this is 'per system' status, so that we can have global variable
// !!! simply here, but it could be 'per process' or 'per hWnd' in later version.
// !!! (it's up to how Window manager manage its status)

BOOL gbDxRedirection = FALSE;

#endif // DX_REDIRECTION


#if DBG

/******************************Public*Routine******************************\
* VOID vDdAssertDevlock
*
* Debug code for verifying that the devlock is currently held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdAssertShareDevlock()
{
#if 0 // TODO: DBG - IsSem...
    ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
                    "DD_ASSERTSHAREDEVLOCK failed");
#endif
}

VOID
vDdAssertDevlock(
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal
    )
{
    ASSERTGDI(DxEngIsHdevLockedByCurrentThread(peDirectDrawGlobal->hdev),
              "DD_ASSERTDEVLOCK failed because Devlock is not held");
}

/******************************Public*Routine******************************\
* VOID vDdAssertNoDevlock
*
* Debug code for verifying that the devlock is currently not held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdAssertNoDevlock(
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal
    )
{
    ASSERTGDI(!DxEngIsHdevLockedByCurrentThread(peDirectDrawGlobal->hdev),
              "DD_ASSERTNODEVLOCK failed because Devlock held but shouldn't be!");
}

#endif // DBG

/******************************Public*Routine******************************\
* BOOL bDdIntersect
*
* Ubiquitous lower-right exclusive intersection detection.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline
BOOL
bDdIntersect(
    RECTL* pA,
    RECTL* pB
    )
{
    return((pA->left   < pB->right) &&
           (pA->top    < pB->bottom) &&
           (pA->right  > pB->left) &&
           (pA->bottom > pB->top));
}

/******************************Public*Routine******************************\
* BOOL bDdValidateDriverData
*
* Performs some parameter validation on the info DirectDraw info returned
* from the driver.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdValidateDriverData(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL            b;
    DDNTCORECAPS*   pCaps;

    b = TRUE;

    if ((peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 8)  &&
        (peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 16) &&
        (peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 24) &&
        (peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 32))
    {
        RIP("HalInfo.vmiData.ddpfDisplay.dwRGBBitCount not 8, 16, 24 or 32");
        b = FALSE;
    }

    if (peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch == 0)
    {
        RIP("HalInfo.vmiData.lDisplayPitch is 0");
        b = FALSE;
    }

    pCaps = &peDirectDrawGlobal->HalInfo.ddCaps;

    // Check to see if 'Blt' must be hooked:

    if (pCaps->dwCaps & (DDCAPS_BLT
                       | DDCAPS_BLTCOLORFILL
                       | DDCAPS_COLORKEY))
    {
        if (!(peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_BLT) ||
            (peDirectDrawGlobal->SurfaceCallBacks.Blt == NULL))
        {
            RIP("HalInfo.ddCaps.dwCaps indicate driver must hook Blt\n");
            b = FALSE;
        }
    }

    // We only permit a subset of the DirectDraw capabilities to be hooked
    // by the driver, because the kernel-mode code paths for any other
    // capabilities have not been tested:

    if (pCaps->dwCaps & (DDCAPS_GDI
                       | DDCAPS_PALETTE
                       | DDCAPS_ZOVERLAYS
                       | DDCAPS_BANKSWITCHED))
    {
        RIP("HalInfo.ddCaps.dwCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    if (pCaps->dwCaps2 & (DDCAPS2_CERTIFIED))
    {
        RIP("HalInfo.ddCaps.dwCaps2 has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    if (pCaps->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY
                               | DDSCAPS_WRITEONLY
                               | DDSCAPS_OWNDC
                               | DDSCAPS_MODEX))
    {
        RIP("HalInfo.ddCaps.ddsCaps.dwCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    if (pCaps->dwFXCaps & ( DDFXCAPS_BLTROTATION
                          | DDFXCAPS_BLTROTATION90))
    {
        RIP("HalInfo.ddCaps.dwFXCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    /*
     * WINBUG #55100 2-1-2000 bhouse Alpha restrictions need to be revisited when AlphaBlt DDI is enabled.
     * We used to check and fail on the presence of either of the following bits:
     * DDFXALPHACAPS_BLTALPHASURFACES           0x00000008l
     * DDFXALPHACAPS_OVERLAYALPHASURFACES       0x00000100l
     */

    if (pCaps->dwPalCaps != 0)
    {
        RIP("HalInfo.ddCaps.dwPalCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    // GDI will handle the emulation of system-memory to video-memory blts.
    // Page-locking from user-mode is not allowed on NT, so
    // DDSCAPS2_NOPAGELOCKEDREQUIRED should always be set:

    if (!(pCaps->dwCaps & DDCAPS_CANBLTSYSMEM) &&
        (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_BLT) &&
        (peDirectDrawGlobal->SurfaceCallBacks.Blt != NULL))
    {
        peDirectDrawGlobal->flDriver |= DD_DRIVER_FLAG_EMULATE_SYSTEM_TO_VIDEO;

        pCaps->dwCaps2   |= DDCAPS2_NOPAGELOCKREQUIRED;
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bDdGetDriverInfo
*
* Assumes devlock already held.
*
* In case the driver partially filled in the structure before it decided
* to fail, we always zero the buffer in the event of failure.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdGetDriverInfo(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    const GUID*             pGuid,
    VOID*                   pvBuffer,
    ULONG                   cjSize,
    ULONG*                  pjSizeReturned
    )
{
    PDD_GETDRIVERINFO       pfnGetDriverInfo;
    DD_GETDRIVERINFODATA    GetDriverInfoData;
    DWORD                   dwRet = DDHAL_DRIVER_NOTHANDLED;
    DWORD                   dwSize;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    pfnGetDriverInfo = peDirectDrawGlobal->HalInfo.GetDriverInfo;

    if( ( pfnGetDriverInfo != NULL ) &&
        (peDirectDrawGlobal->HalInfo.dwFlags & DDHALINFO_GETDRIVERINFOSET))
    {
        RtlZeroMemory(&GetDriverInfoData, sizeof(GetDriverInfoData));

        GetDriverInfoData.dhpdev         = peDirectDrawGlobal->dhpdev;
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = *pGuid;
        GetDriverInfoData.dwExpectedSize = cjSize;
        GetDriverInfoData.lpvData        = pvBuffer;
        GetDriverInfoData.ddRVal         = DDERR_CURRENTLYNOTAVAIL;

        dwRet = pfnGetDriverInfo(&GetDriverInfoData);
    }

    if (dwRet == DDHAL_DRIVER_HANDLED &&
        GetDriverInfoData.ddRVal == DD_OK)
    {
        if (pjSizeReturned != NULL)
        {
            *pjSizeReturned = GetDriverInfoData.dwActualSize;
        }

        return TRUE;
    }
    else
    {
        RtlZeroMemory(pvBuffer, cjSize);

        if (pjSizeReturned != NULL)
        {
            *pjSizeReturned = 0;
        }

        return FALSE;
    }
}

/******************************Public*Routine******************************\
* BOOL bDdIoQueryInterface
*
*  12-Feb-1998 -by- Drew Bliss [drewb]
* Made vDdQueryMiniportDxApiSupport generic for QI requests.
\**************************************************************************/

BOOL
bDdIoQueryInterface(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    const GUID*             pguid,
    DWORD                   cjInterface,
    DWORD                   dwDesiredVersion,
    INTERFACE*              pInterface
    )
{
    BOOL                bSuccess;
    PDEVICE_OBJECT      hDevice;
    KEVENT              event;
    PIRP                pIrp;
    IO_STATUS_BLOCK     Iosb;
    PIO_STACK_LOCATION  stack;
    DDGETIRQINFO        GetIrqInfo;

    bSuccess = FALSE;                       // Assume failure

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);   // Synchronize call into miniport

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    hDevice = (PDEVICE_OBJECT) po.hScreen();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    pIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                        hDevice,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &Iosb);
    if (pIrp != NULL)
    {
        pIrp->IoStatus.Status = Iosb.Status = STATUS_NOT_SUPPORTED;

        stack = IoGetNextIrpStackLocation(pIrp);

        stack->MajorFunction
            = IRP_MJ_PNP;

        stack->MinorFunction
            = IRP_MN_QUERY_INTERFACE;

        stack->Parameters.QueryInterface.InterfaceType
            = pguid;

        stack->Parameters.QueryInterface.Size
            = (USHORT)cjInterface;

        stack->Parameters.QueryInterface.Version
            = (USHORT)dwDesiredVersion;

        stack->Parameters.QueryInterface.Interface
            = pInterface;

        stack->Parameters.QueryInterface.InterfaceSpecificData
            = NULL;

        // Note that we allow newer interfaces to work with older system
        // code so that new drivers can run on older systems.

        if (NT_SUCCESS(IoCallDriver(hDevice, pIrp)))
        {
            if ((pInterface->Version >= dwDesiredVersion) &&
                (pInterface->Size >= cjInterface) &&
                (pInterface->Context != NULL))
            {
                bSuccess = TRUE;
            }
            else
            {
                WARNING("bDdIoQueryInterface: "
                        "Driver returned invalid QueryInterface data.");
            }
        }
    }
    else
    {
        WARNING("bDdIoQueryInterface: Unable to build request.");
    }

    return bSuccess;
}

/******************************Public*Routine******************************\
* BOOL bDdGetAllDriverInfo
*
* Makes GetDriverInfo HAL calls to determine capabilities of the device,
* such as for Direct3D or VPE.
*
* Assumes devlock already held.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdGetAllDriverInfo(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    DWORD               dwMaxVideoPorts;
    ULONG               cjMaxVideoPorts;
    DDVIDEOPORTCAPS*    pVideoPortCaps;
    ULONG               i;
    DWORD               dwRet;
    DWORD               dwOverride;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    // Get driver override info:

    dwOverride = po.dwDriverCapableOverride();

    // Get DXAPI info:

    vDdQueryMiniportDxApiSupport(peDirectDrawGlobal);

    // Get AGP info:

    if (!bDdIoQueryInterface(peDirectDrawGlobal,
                             &GUID_AGP_INTERFACE,
                             sizeof(AGP_INTERFACE),
                             AGP_INTERFACE_VERSION,
                             (INTERFACE *)
                             &peDirectDrawGlobal->AgpInterface))
    {
        RtlZeroMemory(&peDirectDrawGlobal->AgpInterface,
                      sizeof(peDirectDrawGlobal->AgpInterface));
    }

    if ((peDirectDrawGlobal->HalInfo.GetDriverInfo != NULL) &&
        (peDirectDrawGlobal->HalInfo.dwFlags & DDHALINFO_GETDRIVERINFOSET))
    {
        // DX5 callbacks are never used on NT so we do not bother to ask the driver for them
        // We simply zero them out

        RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks2,
                      sizeof(peDirectDrawGlobal->D3dCallBacks2));

        // Get D3DCallbacks3.  If this fails the callbacks will
        // be NULL. Also check if this driver is capable of doing D3D or not

        if ((!(dwOverride & DRIVER_NOT_CAPABLE_D3D))
          &&bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_D3DCallbacks3,
                             &peDirectDrawGlobal->D3dCallBacks3,
                             sizeof(peDirectDrawGlobal->D3dCallBacks3),
                             NULL))
        {
            // It needs to accept a new GUID
            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_D3DParseUnknownCommandCallback,
                                 &D3DParseUnknownCommand, 0, NULL))
            {
                peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_D3DCALLBACKS3;
            }
            else
            {
                // If the GUID is not recognized, stub out Callbacks3
                WARNING("vDdGetAllDriverInfo: Driver failed GUID_D3DParseUnknownCommandCallback but understood GUID_D3DCallbacks3");
                RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks3,
                              sizeof(peDirectDrawGlobal->D3dCallBacks3));
                return FALSE;
            }
        }

        // Note: GUID_ZPixelFormats is not queried because kernel doesn't need to
        //       store the DDPIXELFORMATS data

        // Get DXAPI ("Kernel-Mode") capabilities.

        dwRet = DXERR_GENERIC;
        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_KernelCaps,
                             &peDirectDrawGlobal->DDKernelCaps,
                             sizeof(peDirectDrawGlobal->DDKernelCaps),
                             NULL))
        {
            /*
             * They may have said that they have IRQ capabilites, but
             * we need to make sure this is really the case.  For this,
             * we can call the GetIRQInfo function in the miniport.
             */
            if( peDirectDrawGlobal->DxApiInterface.DxGetIrqInfo != NULL )
            {
                DDGETIRQINFO GetIRQInfo;

                dwRet = peDirectDrawGlobal->DxApiInterface.DxGetIrqInfo(
                    peDirectDrawGlobal->HwDeviceExtension,
                    NULL,
                    &GetIRQInfo);
                if( GetIRQInfo.dwFlags != IRQINFO_HANDLED )
                {
                    dwRet = DXERR_GENERIC;
                }
            }
        }

        if( dwRet != DX_OK )
        {
            peDirectDrawGlobal->DDKernelCaps.dwIRQCaps = 0;
            peDirectDrawGlobal->DDKernelCaps.dwCaps &= ~( DDKERNELCAPS_AUTOFLIP |
                DDKERNELCAPS_CAPTURE_SYSMEM | DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM );
        }

        // Get VPE info:

        dwMaxVideoPorts = peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts;
        if (dwMaxVideoPorts != 0)
        {
            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_VideoPortCallbacks,
                                 &peDirectDrawGlobal->VideoPortCallBacks,
                                 sizeof(peDirectDrawGlobal->VideoPortCallBacks),
                                 NULL))
            {
                cjMaxVideoPorts = sizeof(DDVIDEOPORTCAPS) * dwMaxVideoPorts;

                pVideoPortCaps = (DDVIDEOPORTCAPS*) PALLOCMEM(cjMaxVideoPorts,
                                                              'pddG');
                if (pVideoPortCaps != NULL)
                {
                    if (bDdGetDriverInfo(peDirectDrawGlobal,
                                         &GUID_VideoPortCaps,
                                         pVideoPortCaps,
                                         cjMaxVideoPorts,
                                         NULL))
                    {
                        peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts
                            = dwMaxVideoPorts;
                        peDirectDrawGlobal->lpDDVideoPortCaps
                            = pVideoPortCaps;
                        peDirectDrawGlobal->flDriverInfo
                            |= DD_DRIVERINFO_VIDEOPORT;

                        for (i = 0; i < dwMaxVideoPorts; i++)
                        {
                            if (peDirectDrawGlobal->DDKernelCaps.dwIRQCaps
                                    & (DDIRQ_VPORT0_VSYNC << (i * 2)) &&
                                (peDirectDrawGlobal->DDKernelCaps.dwCaps
                                    & DDKERNELCAPS_AUTOFLIP))
                            {
                                // Can do software autoflipping.

                                pVideoPortCaps[i].dwCaps |= DDVPCAPS_AUTOFLIP;
                                pVideoPortCaps[i].dwNumAutoFlipSurfaces
                                    = MAX_AUTOFLIP_BUFFERS;
                                if (pVideoPortCaps[i].dwCaps & DDVPCAPS_VBISURFACE)
                                {
                                    pVideoPortCaps[i].dwNumVBIAutoFlipSurfaces
                                         = MAX_AUTOFLIP_BUFFERS;
                                }
                            }
                        }
                    }
                    else
                    {
                        RIP("vDdGetAllDriverInfo: Driver failed GUID_VideoPortCaps");

                        RtlZeroMemory(&peDirectDrawGlobal->VideoPortCallBacks,
                                sizeof(peDirectDrawGlobal->VideoPortCallBacks));

                        VFREEMEM(pVideoPortCaps);
                    }
                }
            }
        }

        // Get ColorControl info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_ColorControlCallbacks,
                             &peDirectDrawGlobal->ColorControlCallBacks,
                             sizeof(peDirectDrawGlobal->ColorControlCallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_COLORCONTROL;
        }

        // Get Miscellaneous info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_MiscellaneousCallbacks,
                             &peDirectDrawGlobal->MiscellaneousCallBacks,
                             sizeof(peDirectDrawGlobal->MiscellaneousCallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MISCELLANEOUS;
        }

        // Get Miscellaneous2 info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_Miscellaneous2Callbacks,
                             &peDirectDrawGlobal->Miscellaneous2CallBacks,
                             sizeof(peDirectDrawGlobal->Miscellaneous2CallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MISCELLANEOUS2;
        }
        else
        {
            // If the GUID is not recognized, stub out D3DCallbacks3...
            RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks3,
                          sizeof(peDirectDrawGlobal->D3dCallBacks3));
            // ... and clear the bit
            peDirectDrawGlobal->flDriverInfo &= ~DD_DRIVERINFO_D3DCALLBACKS3;
            // Stub out all other d3d driver info
            RtlZeroMemory(&peDirectDrawGlobal->D3dDriverData,
                          sizeof(peDirectDrawGlobal->D3dDriverData));
            RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks,
                          sizeof(peDirectDrawGlobal->D3dCallBacks));
            RtlZeroMemory(&peDirectDrawGlobal->D3dBufCallbacks,
                          sizeof(peDirectDrawGlobal->D3dBufCallbacks));
        }

        // Get NT info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_NTCallbacks,
                             &peDirectDrawGlobal->NTCallBacks,
                             sizeof(peDirectDrawGlobal->NTCallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_NT;
        }

        // Get MoreCaps info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_DDMoreCaps,
                             &peDirectDrawGlobal->MoreCaps,
                             sizeof(peDirectDrawGlobal->MoreCaps),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MORECAPS;
        }

        // Get PrivateDriverCaps info. If the driver is not capable of D3D
        // then don't do it

        if ((!(dwOverride & DRIVER_NOT_CAPABLE_D3D))
            &&(bDdGetDriverInfo(peDirectDrawGlobal,
                                &GUID_NTPrivateDriverCaps,
                                &peDirectDrawGlobal->PrivateCaps,
                                sizeof(peDirectDrawGlobal->PrivateCaps),
                                NULL)))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_PRIVATECAPS;
        }

        // Get DXAPI ("Kernel-Mode") call-backs.  Note that we don't bother
        // with a flag because user-mode never needs to know whether the
        // driver has actually hooked these or not.

        bDdGetDriverInfo(peDirectDrawGlobal,
                         &GUID_KernelCallbacks,
                         &peDirectDrawGlobal->DxApiCallBacks,
                         sizeof(peDirectDrawGlobal->DxApiCallBacks),
                         NULL);

        // Get MotionComp info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_MotionCompCallbacks,
                             &peDirectDrawGlobal->MotionCompCallbacks,
                             sizeof(peDirectDrawGlobal->MotionCompCallbacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MOTIONCOMP;
        }
     }

    // Determine if the device supports gamma ramps or not

    peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &= ~DDCAPS2_PRIMARYGAMMA;
    if ((po.iDitherFormat() == BMF_8BPP)  ||
        ((PPFNVALID(po, IcmSetDeviceGammaRamp)) &&
        (po.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP)))
    {
        peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 |= DDCAPS2_PRIMARYGAMMA;
    }

    // Squish any ROP caps that the driver may have set so apps will
    // know that they're not supported.

    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwRops ) );
    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwSVBRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwSVBRops ) );
    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwVSBRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwVSBRops ) );
    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwSSBRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwSSBRops ) );

    return TRUE;
}

/******************************Public*Routine******************************\
* DWORD dwDdSetAGPPolicy()
*
* Reads the DirectDraw AGP policy value from the registry and adjusts as
* necessary.
*
* Note: This policy only restricts the size per heap. If the driver exposes
* more than 1 heap, it should do extra work to determine reasonable heap
* sizes based on total physical memory and perhaps other data.
*
*  28-Sep-1999 -by- John Stephens [johnstep]
* Copied from llDdAssertModeTimeout().
\**************************************************************************/

#define AGP_BASE_MEMORY_PAGES       ((64 * 1024 * 1024) / PAGE_SIZE)

// The following are the limits of an AGP reservation:

#define AGP_MINIMUM_MAX_PAGES   ((8 * 1024 * 1024) / PAGE_SIZE)
#define AGP_MAXIMUM_MAX_PAGES ((256 * 1024 * 1024) / PAGE_SIZE)

DWORD
dwDdSetAgpPolicy(
    )
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    DWORD                       Policy;
    PKEY_VALUE_FULL_INFORMATION Information;
    SYSTEM_BASIC_INFORMATION    BasicInfo;
    SYSINF_PAGE_COUNT           PageCount;

    status = ZwQuerySystemInformation(SystemBasicInformation,
                                      (VOID*) &BasicInfo,
                                      sizeof BasicInfo,
                                      NULL);

    if (!NT_SUCCESS(status) || 
        (BasicInfo.NumberOfPhysicalPages < AGP_MINIMUM_MAX_PAGES))
    {
        return 0;
    }

    // By default, we let them use all of the memory minus 64 Meg

    PageCount = BasicInfo.NumberOfPhysicalPages - AGP_BASE_MEMORY_PAGES;
    if (PageCount < AGP_MAXIMUM_MAX_PAGES) {
        Policy = (DWORD)PageCount;
    } else {
        Policy = AGP_MAXIMUM_MAX_PAGES;
    }

    if ((Policy < AGP_MINIMUM_MAX_PAGES) ||
        (BasicInfo.NumberOfPhysicalPages < AGP_BASE_MEMORY_PAGES))
    {
        // But some drivers (nvidia) really need to have at least 8 Meg, so we
        // need to give them at least that much.
        Policy = AGP_MINIMUM_MAX_PAGES;
    }

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\GraphicsDrivers");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, L"AGPPolicyMaxPages");

        Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"AGPPolicyMaxPages") +
                 sizeof(DWORD);


        Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, ' ddG');

        if (Information)
        {
            status = ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length);

            if (NT_SUCCESS(status))
            {
                Policy = *( (LPDWORD) ((((PUCHAR)Information) +
                            Information->DataOffset)) );
            }

            VFREEMEM(Information);
        }

        ZwCloseKey(hkRegistry);
    }

    // Clamp policy maximum pages:

    if (Policy < AGP_MINIMUM_MAX_PAGES)
    {
        Policy = 0;
    }
    else 
    {
        Policy = min(Policy, AGP_MAXIMUM_MAX_PAGES);
        if (BasicInfo.NumberOfPhysicalPages > AGP_BASE_MEMORY_PAGES)
        {
            Policy = (DWORD)min( Policy, 
                (BasicInfo.NumberOfPhysicalPages -
                    AGP_BASE_MEMORY_PAGES));
        }

        // Round down to the nearest 64 KB multiple and convert to bytes:

        Policy = (Policy & ~0xF) * PAGE_SIZE;
    }

    return Policy;
}

/******************************Public*Routine******************************\
* VOID vDdInitHeaps
*
* Initializes video memory heaps returned by the driver.
*
* Assumes devlock already held and AGP functions queried.
*
*  6-Feb-1998 -by- Drew Bliss [drewb]
* Wrote it.
\**************************************************************************/

VOID
vDdInitHeaps(EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal)
{
    DWORD dwHeap;
    VIDEOMEMORY* pHeap;

    DDKHEAP(("DDKHEAP: Initializing %d heaps\n",
             peDirectDrawGlobal->dwNumHeaps));

    // Set the AGP policy here:

    dwAGPPolicyMaxBytes = dwDdSetAgpPolicy();

    // Initialize heaps which aren't preallocated.
    pHeap = peDirectDrawGlobal->pvmList;
    for (dwHeap = 0;
         dwHeap < peDirectDrawGlobal->dwNumHeaps;
         pHeap++, dwHeap++)
    {
        // If the current heap is an AGP heap but we were unable to
        // get access to the AGP control functions then we can't use it,
        // so remove it from the list.
        //
        // The heap is also disabled in the case where a driver reports
        // a non-local heap but doesn't report non-local vidmem caps.
        if ((pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            (peDirectDrawGlobal->AgpInterface.Context == NULL ||
             (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
              DDCAPS2_NONLOCALVIDMEM) == 0))
        {
            DDKHEAP(("DDKHEAP: Disabling AGP heap %d\n", dwHeap));

            pHeap->dwFlags |= VIDMEM_HEAPDISABLED;
        }
        else if (!(pHeap->dwFlags & VIDMEM_ISHEAP))
        {
            // Get any heap alignment restrictions from driver:

            DD_GETHEAPALIGNMENTDATA GetHeapAlignmentData;
            HEAPALIGNMENT* pHeapAlignment = NULL;

            RtlZeroMemory(&GetHeapAlignmentData, sizeof GetHeapAlignmentData);

            GetHeapAlignmentData.dwInstance =
                (ULONG_PTR) peDirectDrawGlobal->dhpdev;
            GetHeapAlignmentData.dwHeap = dwHeap;
            GetHeapAlignmentData.ddRVal = DDERR_GENERIC;
            GetHeapAlignmentData.Alignment.dwSize =
                sizeof GetHeapAlignmentData.Alignment;

            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_GetHeapAlignment,
                                 &GetHeapAlignmentData,
                                 sizeof GetHeapAlignmentData,
                                 NULL))
            {
                pHeapAlignment = &GetHeapAlignmentData.Alignment;
            }

            DDKHEAP(("DDKHEAP: Initializing heap %d, flags %X\n",
                     dwHeap, pHeap->dwFlags));

            if (HeapVidMemInit(pHeap,
                               peDirectDrawGlobal->
                               HalInfo.vmiData.lDisplayPitch,
                               AGP_HDEV(peDirectDrawGlobal),
                               pHeapAlignment) == NULL)
            {
                DDKHEAP(("DDKHEAP: Heap %d failed init\n", dwHeap));

                pHeap->dwFlags |= VIDMEM_HEAPDISABLED;
            }
            else
            {
                DDKHEAP(("DDKHEAP: Heap %d is %08X\n",
                         dwHeap, pHeap->lpHeap));
                if (pHeap->dwFlags & VIDMEM_ISNONLOCAL)
                {
                    pHeap->lpHeap->hdevAGP = AGP_HDEV(peDirectDrawGlobal);
                }
            }
        }
    }

    {
        ULONG ulHeaps=peDirectDrawGlobal->dwNumHeaps;
        ULONG cjData=sizeof(DD_MORESURFACECAPS)-sizeof(DDSCAPSEX)*2+
              ulHeaps*sizeof(DDSCAPSEX)*2;
        // allocate memory in ddraw style, add some junk after data strucure
        // so that not well behaved driver does not break the kernel.
        PDD_MORESURFACECAPS pDDMoreSurfaceCaps=(PDD_MORESURFACECAPS)
                PALLOCMEM(cjData+0x400,'pddG');

        RtlZeroMemory(&peDirectDrawGlobal->MoreSurfaceCaps,
                      sizeof(peDirectDrawGlobal->MoreSurfaceCaps));

        if (pDDMoreSurfaceCaps!=NULL)
        {
            RtlZeroMemory(pDDMoreSurfaceCaps, cjData);
            pDDMoreSurfaceCaps->dwSize=cjData;
            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_DDMoreSurfaceCaps,
                                 pDDMoreSurfaceCaps,
                                 cjData,
                                 &cjData))
            {
                // now fill ddscaps into heaps
                // directdraw runtime does not expect the heap restrictions
                ULONG cjCopy= (ULONG)min(sizeof(DD_MORESURFACECAPS)-sizeof(DDSCAPSEX)*2,cjData);
                pDDMoreSurfaceCaps->dwSize=cjCopy;
                RtlCopyMemory(&peDirectDrawGlobal->MoreSurfaceCaps,
                              pDDMoreSurfaceCaps,
                              cjCopy);

                // now Copy ddxCapsex/ExAlt members to heaps...
                pHeap = peDirectDrawGlobal->pvmList;
                for (dwHeap = 0;
                     dwHeap < ulHeaps;
                     pHeap++, dwHeap++)
                {
                    if (!(pHeap->dwFlags&VIDMEM_HEAPDISABLED))
                    {
                        RtlCopyMemory(
                                &pHeap->lpHeap->ddsCapsEx,
                                &pDDMoreSurfaceCaps->ddsExtendedHeapRestrictions[dwHeap].ddsCapsEx,
                                sizeof(DDSCAPSEX));
                        RtlCopyMemory(
                                &pHeap->lpHeap->ddsCapsExAlt,
                                &pDDMoreSurfaceCaps->ddsExtendedHeapRestrictions[dwHeap].ddsCapsExAlt,
                                sizeof(DDSCAPSEX));
                    }
                }
                peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MORESURFACECAPS;
            }
            VFREEMEM(pDDMoreSurfaceCaps);
        }
    }
}

/******************************Public*Routine******************************\
* VOID UpdateNonLocalHeap
*
* Notifies the driver when the AGP heap information changes.
*
*   2-Mar-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void UpdateNonLocalHeap(
            EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
            DWORD                   dwHeapIndex
            )
{
    DD_UPDATENONLOCALHEAPDATA UpdateNonLocalHeapData;
    LPVIDMEM      lpVidMem = &(peDirectDrawGlobal->pvmList[dwHeapIndex]);

    UpdateNonLocalHeapData.lpDD = peDirectDrawGlobal;
    UpdateNonLocalHeapData.dwHeap = dwHeapIndex;
    UpdateNonLocalHeapData.fpGARTLin = lpVidMem->lpHeap->fpGARTLin;
    UpdateNonLocalHeapData.fpGARTDev = lpVidMem->lpHeap->fpGARTDev;
    UpdateNonLocalHeapData.ulPolicyMaxBytes = 0;
    UpdateNonLocalHeapData.ddRVal = DDERR_GENERIC;

    bDdGetDriverInfo(peDirectDrawGlobal,
        &GUID_UpdateNonLocalHeap,
        &UpdateNonLocalHeapData,
        sizeof UpdateNonLocalHeapData,
        NULL);
}

/******************************Public*Routine******************************\
* VOID InitAgpHeap
*
* We do not want to call AGPReserve in HeapVidMemInit since it is called on
* every mode change, so instead we have a seperate function that reserves the
* AGP memory and it is called after the rest of the heap is initialized.
*
*  22-Feb-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID 
InitAgpHeap( 
            EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
            DWORD                   dwHeapIndex,
            HANDLE                  hdev
            )
{
    DWORD         dwSize;
    FLATPTR       fpLinStart;
    LARGE_INTEGER liDevStart;
    PVOID         pvReservation;
    BOOL          fIsUC;
    BOOL          fIsWC;
    DWORD         dwSizeReserved = 0;
    LPVIDMEM      lpVidMem = &(peDirectDrawGlobal->pvmList[dwHeapIndex]);

    /*
     * Compute the size of the heap.
     */
    dwSize = lpVidMem->lpHeap->dwTotalSize;
    DDASSERT( 0UL != dwSize );

    if( lpVidMem->dwFlags & VIDMEM_ISWC )
    {
        fIsUC = FALSE;
        fIsWC = TRUE;
    }
    else
    {
        fIsUC = TRUE;
        fIsWC = FALSE;
    }

    /*
     * Allocate a bit mask to keep track of which pages have been 
     * committed or not.
     */
    lpVidMem->lpHeap->dwAgpCommitMaskSize = 
        (GetHeapSizeInPages(lpVidMem, lpVidMem->lpHeap->stride) / BITS_IN_BYTE) + 1;
    lpVidMem->lpHeap->pAgpCommitMask = 
        (BYTE*) PALLOCMEM(lpVidMem->lpHeap->dwAgpCommitMaskSize, 'pddG');
    if( lpVidMem->lpHeap->pAgpCommitMask == NULL )
    {
        lpVidMem->dwFlags |= VIDMEM_HEAPDISABLED;
        return;
    }

    if( !(dwSizeReserved = AGPReserve( hdev, dwSize, fIsUC, fIsWC,
                                       &fpLinStart, &liDevStart,
                                       &pvReservation )) )
    {
        VDPF(( 0, V, "Could not reserve a GART address range for a "
               "linear heap of size 0x%08x", dwSize ));
        VFREEMEM(lpVidMem->lpHeap->pAgpCommitMask);
        lpVidMem->lpHeap->pAgpCommitMask = NULL;
        lpVidMem->dwFlags |= VIDMEM_HEAPDISABLED;
        return;
    }
    else
    {
        VDPF((4,V, "Allocated a GART address range starting at "
              "0x%08x (linear) 0x%08x:0x%08x (physical) of size %d",
              fpLinStart, liDevStart.HighPart, liDevStart.LowPart,
              dwSizeReserved ));
    }

    if (dwSizeReserved != dwSize)
    {
        VDPF((0,V,"WARNING! This system required that the full "
              "nonlocal aperture could not be reserved!"));
        VDPF((0,V,"         Requested aperture:%08x, "
              "Reserved aperture:%08x", dwSize, dwSizeReserved));
    }

    /*
     * Update the heap for the new start address
     * (and end address for a linear heap).
     */
    lpVidMem->fpStart = fpLinStart;
    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
        LPVMEML plh;

        lpVidMem->fpEnd = ( fpLinStart + dwSizeReserved ) - 1UL;
        lpVidMem->lpHeap->dwTotalSize = dwSizeReserved;
        plh = (LPVMEML)lpVidMem->lpHeap->freeList;
        if( ( plh != NULL ) && ( plh->ptr == 0 ) )
        {
            plh->ptr = lpVidMem->fpStart;
            plh->size = dwSizeReserved;
        }
    }
    else
    {
        LPVMEMR prh;
        DWORD   dwHeight;

        DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
        dwHeight = dwSizeReserved / lpVidMem->lpHeap->stride;
        lpVidMem->lpHeap->dwTotalSize = dwHeight * lpVidMem->lpHeap->stride;
        prh = (LPVMEMR)lpVidMem->lpHeap->freeList;
        if( ( prh != NULL ) && ( prh->cy != 0x7fffffff ) )
        {
            prh->ptr = lpVidMem->fpStart;
            prh->cy = dwHeight;
            prh->size = (lpVidMem->dwWidth << 16 ) | dwHeight;
        }
    }

    lpVidMem->lpHeap->fpGARTLin      = fpLinStart;
    // Fill in partial physical address for Win9x.
    lpVidMem->lpHeap->fpGARTDev      = liDevStart.LowPart;
    // Fill in complete physical address for NT.
    lpVidMem->lpHeap->liPhysAGPBase  = liDevStart;
    lpVidMem->lpHeap->pvPhysRsrv     = pvReservation;

    UpdateNonLocalHeap( peDirectDrawGlobal, dwHeapIndex );

} /* InitAgpHeap */

/******************************Public*Routine******************************\
* VOID CheckAgpHeaps
*
* This funtion is called periodically to make sure that we initialize any
* uninitialized AGP heaps.
*
*  22-Feb-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void CheckAgpHeaps(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    LPVIDMEM    pHeap;
    DWORD       i;

    pHeap = peDirectDrawGlobal->pvmList;
    for( i = 0; i < peDirectDrawGlobal->dwNumHeaps; pHeap++, i++)
    {
        if ((pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            !(pHeap->dwFlags & VIDMEM_ISHEAP) &&
            !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
            (pHeap->lpHeap->pvPhysRsrv == NULL))
        {
            InitAgpHeap( peDirectDrawGlobal, 
                         i,
                         AGP_HDEV(peDirectDrawGlobal));
        }
    }
}

/******************************Public*Routine******************************\
* VOID MapAllAgpHeaps
*
* This funtion is virtually map all AGP heaps.  It also virtually commits
* them to everything that is physically committed.
*
*  25-Apr-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void MapAllAgpHeaps(
    EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocal
    )
{
    if (peDirectDrawLocal->ppeMapAgp != NULL)
    {
        VIDEOMEMORY*            pvmHeap;
        DWORD                   i;
        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
        for (i = 0; i < peDirectDrawGlobal->dwNumHeaps; i++)
        {
            pvmHeap = &peDirectDrawGlobal->pvmList[i];

            if ((pvmHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
                !(pvmHeap->dwFlags & VIDMEM_ISHEAP) &&
                !(pvmHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
                (pvmHeap->lpHeap != NULL) &&
                (pvmHeap->lpHeap->pvPhysRsrv != NULL) && 
                (peDirectDrawLocal->ppeMapAgp[i] == NULL))
            {
                // Reserve address space for the heap:

                if (bDdMapAgpHeap(peDirectDrawLocal, pvmHeap))
                {
                    if (peDirectDrawLocal->ppeMapAgp[i] != NULL)
                    {
                        AGPCommitAllVirtual (peDirectDrawLocal, pvmHeap, i);
                    }
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDdDisableDriver
*
* Frees and destroys all driver state.  Note that this may be called
* even while the driver is still only partially enabled.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableDriver(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    if (peDirectDrawGlobal->pvmList != NULL)
    {
        DWORD dwHeap;
        VIDEOMEMORY* pHeap;

        // Shut down heaps.

        DDKHEAP(("DDKHEAP: Shutting down %d heaps\n",
                 peDirectDrawGlobal->dwNumHeaps));

        pHeap = peDirectDrawGlobal->pvmList;
        for (dwHeap = 0;
             dwHeap < peDirectDrawGlobal->dwNumHeaps;
             pHeap++, dwHeap++)
        {
            if ((pHeap->dwFlags & VIDMEM_HEAPDISABLED) == 0 &&
                pHeap->lpHeap != NULL)
            {
                DDKHEAP(("DDKHEAP: Uninitializing heap %d\n", dwHeap));

                HeapVidMemFini(pHeap, AGP_HDEV(peDirectDrawGlobal));
            }
        }

        VFREEMEM(peDirectDrawGlobal->pvmList);
        peDirectDrawGlobal->pvmList = NULL;
    }

    if (peDirectDrawGlobal->pdwFourCC != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pdwFourCC);
        peDirectDrawGlobal->pdwFourCC = NULL;
    }

    if (peDirectDrawGlobal->lpDDVideoPortCaps != NULL)
    {

        VFREEMEM(peDirectDrawGlobal->lpDDVideoPortCaps);
        peDirectDrawGlobal->lpDDVideoPortCaps = NULL;
    }

    if (peDirectDrawGlobal->hDxApi != NULL)
    {
        vDdUnloadDxApiImage(peDirectDrawGlobal);
    }

    if (peDirectDrawGlobal->hdcCache != NULL)
    {
        // need to chage to 'current' since while it's in cache, it's 'none'
        DxEngSetDCOwner((HDC) peDirectDrawGlobal->hdcCache, OBJECT_OWNER_CURRENT);
        DxEngDeleteDC((HDC) peDirectDrawGlobal->hdcCache, TRUE);
        peDirectDrawGlobal->hdcCache = NULL;
    }

    if (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED)
    {
        peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_DRIVER_ENABLED;

        (*PPFNDRV(po, DisableDirectDraw))(po.dhpdev());
    }

    RtlZeroMemory((DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobal,
            sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));
}

/******************************Public*Routine******************************\
* VOID vDdEnableDriver
*
* Calls the driver's DrvGetDirectDrawInfo and DrvEnableDirectDraw
* functions to enable and initialize the driver and mode dependent
* portions of the global DirectDraw object.
*
* Assumes devlock already held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdEnableDriver(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL                        bSuccess;
    PFN_DrvGetDirectDrawInfo    pfnGetDirectDrawInfo;
    PFN_DrvEnableDirectDraw     pfnEnableDirectDraw;
    PFN_DrvDisableDirectDraw    pfnDisableDirectDraw;
    DWORD                       dwNumHeaps;
    DWORD                       dwNumFourCC;
    VIDEOMEMORY*                pvmList;
    DWORD*                      pdwFourCC;
    ULONG                       iDitherFormat;
    DWORD                       dw;

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

    // Call the driver to see what it can do:

    pfnGetDirectDrawInfo = PPFNDRV(po, GetDirectDrawInfo);
    pfnEnableDirectDraw  = PPFNDRV(po, EnableDirectDraw);
    pfnDisableDirectDraw = PPFNDRV(po, DisableDirectDraw);

    // To support DirectDraw, the driver must hook all three required
    // DirectDraw functions.

    bSuccess = ((pfnGetDirectDrawInfo != NULL) &&
                (pfnEnableDirectDraw != NULL)  &&
                (pfnDisableDirectDraw != NULL));

    dwNumHeaps = 0;
    dwNumFourCC = 0;

    peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_DRIVER_ENABLED;

    // Do the first DrvGetDirectDrawInfo query for this PDEV to
    // determine the number of heaps and the number of FourCC
    // codes that the driver supports, so that we know how
    // much memory to allocate:

    if ((bSuccess) &&
        (pfnGetDirectDrawInfo((DHPDEV) peDirectDrawGlobal->dhpdev,
                              &peDirectDrawGlobal->HalInfo,
                              &dwNumHeaps,
                              NULL,
                              &dwNumFourCC,
                              NULL)))
    {
        pvmList   = NULL;
        pdwFourCC = NULL;

        DDKHEAP(("DDKHEAP: Driver reports dwNumHeaps %d\n", dwNumHeaps));

        if (dwNumHeaps != 0)
        {
            pvmList = (VIDEOMEMORY*)
                      PALLOCMEM(sizeof(VIDEOMEMORY) * dwNumHeaps, 'vddG');
            peDirectDrawGlobal->dwNumHeaps = dwNumHeaps;
            peDirectDrawGlobal->pvmList = pvmList;

            if (pvmList == NULL)
                bSuccess = FALSE;
        }

        if (dwNumFourCC != 0)
        {
            pdwFourCC = (DWORD*)
                        PALLOCMEM(sizeof(DWORD) * dwNumFourCC, 'fddG');
            peDirectDrawGlobal->dwNumFourCC = dwNumFourCC;
            peDirectDrawGlobal->pdwFourCC = pdwFourCC;

            if (pdwFourCC == NULL)
                bSuccess = FALSE;
        }

        if (bSuccess)
        {
            // Do the second DrvGetDirectDrawInfo that actually
            // gets all the data:

            if (pfnGetDirectDrawInfo((DHPDEV) peDirectDrawGlobal->dhpdev,
                                     &peDirectDrawGlobal->HalInfo,
                                     &dwNumHeaps,
                                     pvmList,
                                     &dwNumFourCC,
                                     pdwFourCC))
            {
                // Ensure that the driver doesn't give us an invalid address
                // for its primary surface (like a user-mode address or NULL):
                if (peDirectDrawGlobal->HalInfo.vmiData.pvPrimary != NULL)
                {
                    dw = *((volatile DWORD *) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary);
                    *((volatile DWORD *) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary) = 0xabcdabcd;
                    *((volatile DWORD *) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary) = dw;

                    if (pfnEnableDirectDraw((DHPDEV) peDirectDrawGlobal->dhpdev,
                                    &peDirectDrawGlobal->CallBacks,
                                    &peDirectDrawGlobal->SurfaceCallBacks,
                                    &peDirectDrawGlobal->PaletteCallBacks))
                    {
                        // Check the driver's capability status
                        DWORD dwOverride = po.dwDriverCapableOverride();

                        // check for D3D support here
                        if ( (!(dwOverride & DRIVER_NOT_CAPABLE_D3D))
                           &&(peDirectDrawGlobal->HalInfo.dwSize == sizeof(DD_HALINFO)) )
                        {
                            // for ease of porting, NT5 HALINFO has the same pointers
                            // to D3D data as DX5
                            if(peDirectDrawGlobal->HalInfo.lpD3DGlobalDriverData != NULL &&
                               ((D3DNTHAL_GLOBALDRIVERDATA*)
                                peDirectDrawGlobal->HalInfo.lpD3DGlobalDriverData)->dwSize ==
                               sizeof(D3DNTHAL_GLOBALDRIVERDATA))
                            {
                                peDirectDrawGlobal->D3dDriverData =
                                    *(D3DNTHAL_GLOBALDRIVERDATA*)peDirectDrawGlobal->HalInfo.lpD3DGlobalDriverData;
                                if( peDirectDrawGlobal->HalInfo.lpD3DHALCallbacks != NULL &&
                                    ((D3DNTHAL_CALLBACKS*)peDirectDrawGlobal->HalInfo.lpD3DHALCallbacks)->dwSize ==
                                    sizeof(D3DNTHAL_CALLBACKS))
                                {
                                    peDirectDrawGlobal->D3dCallBacks =
                                        *(D3DNTHAL_CALLBACKS*)peDirectDrawGlobal->HalInfo.lpD3DHALCallbacks;

                                    if( peDirectDrawGlobal->HalInfo.lpD3DBufCallbacks != NULL &&
                                        ((PDD_D3DBUFCALLBACKS)peDirectDrawGlobal->HalInfo.lpD3DBufCallbacks)->dwSize ==
                                        sizeof(DD_D3DBUFCALLBACKS))
                                    {
                                        peDirectDrawGlobal->D3dBufCallbacks =
                                            *(PDD_D3DBUFCALLBACKS)peDirectDrawGlobal->HalInfo.lpD3DBufCallbacks;
                                    }
                                }
                                else
                                {
                                    // D3DCaps succeeded but D3DCallbacks didn't, so we
                                    // must zero D3DCaps:

                                    RtlZeroMemory(&peDirectDrawGlobal->D3dDriverData,
                                                  sizeof(peDirectDrawGlobal->D3dDriverData));
                                }
                            }
                        }

                        // Use the GetDriverInfo HAL call to query any
                        // additional capabilities such as for Direct3D or
                        // VPE:

                        if (bDdGetAllDriverInfo(peDirectDrawGlobal))
                        {
                            if (bDdValidateDriverData(peDirectDrawGlobal))
                            {
                                // Initialize as many heaps as possible.
                                vDdInitHeaps(peDirectDrawGlobal);

                                peDirectDrawGlobal->fl |= DD_GLOBAL_FLAG_DRIVER_ENABLED;
                                return;
                            }
                        }

                        pfnDisableDirectDraw((DHPDEV) peDirectDrawGlobal->dhpdev);
                    }
                }
                else
                {
                    WARNING("vDdEnableDriver: Driver returned invalid vmiData.pvPrimary\n");
                }
            }
        }
    }

    // Something didn't work, so zero out all of the caps that we may have
    // gotten before the failure occurred.

    peDirectDrawGlobal->flDriver = 0;
    peDirectDrawGlobal->flDriverInfo = 0;
    if (peDirectDrawGlobal->pdwFourCC != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pdwFourCC);
        peDirectDrawGlobal->pdwFourCC = NULL;
    }
    peDirectDrawGlobal->dwNumFourCC = 0;

    if (peDirectDrawGlobal->pvmList != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pvmList);
        peDirectDrawGlobal->pvmList = NULL;
    }
    peDirectDrawGlobal->dwNumHeaps = 0;

    RtlZeroMemory( &peDirectDrawGlobal->DxApiInterface,
        sizeof( peDirectDrawGlobal->DxApiInterface ) );
    RtlZeroMemory( &peDirectDrawGlobal->AgpInterface,
        sizeof( peDirectDrawGlobal->AgpInterface ) );
    RtlZeroMemory( &peDirectDrawGlobal->DDKernelCaps,
        sizeof( peDirectDrawGlobal->DDKernelCaps ) );
    RtlZeroMemory( &peDirectDrawGlobal->DxApiCallBacks,
        sizeof( peDirectDrawGlobal->DxApiCallBacks ) );
    RtlZeroMemory(&peDirectDrawGlobal->D3dDriverData,
        sizeof(peDirectDrawGlobal->D3dDriverData));
    RtlZeroMemory(&peDirectDrawGlobal->CallBacks,
        sizeof(peDirectDrawGlobal->CallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks,
        sizeof(peDirectDrawGlobal->D3dCallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->D3dBufCallbacks,
        sizeof(peDirectDrawGlobal->D3dBufCallbacks));
    RtlZeroMemory(&peDirectDrawGlobal->SurfaceCallBacks,
        sizeof(peDirectDrawGlobal->SurfaceCallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->PaletteCallBacks,
        sizeof(peDirectDrawGlobal->PaletteCallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->HalInfo,
        sizeof(peDirectDrawGlobal->HalInfo));

    peDirectDrawGlobal->HalInfo.dwSize =
        sizeof(peDirectDrawGlobal->HalInfo);
    peDirectDrawGlobal->HalInfo.ddCaps.dwSize =
        sizeof(peDirectDrawGlobal->HalInfo.ddCaps);
    peDirectDrawGlobal->HalInfo.ddCaps.dwCaps = DDCAPS_NOHARDWARE;

    // Okay, we can't use the driver.  Initialize what information we need
    // from the PDEV so that system memory surfaces may still be used:

    iDitherFormat = po.iDitherFormat();
    if (iDitherFormat == BMF_4BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 4;
    }
    else if (iDitherFormat == BMF_8BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 8;
    }
    else if (iDitherFormat == BMF_16BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 16;
    }
    else if (iDitherFormat == BMF_24BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 24;
    }
    else if (iDitherFormat == BMF_32BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 32;
    }
    else
    {
        RIP("Invalid iDitherFormat()");
    }
}

/******************************Public*Routine******************************\
* VOID vDdIncrementReferenceCount
*
* Devlock must be held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdIncrementReferenceCount(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    peDirectDrawGlobal->cDriverReferences++;

    if (peDirectDrawGlobal->cDriverReferences == 1)
    {
        PDEVOBJ po(peDirectDrawGlobal->hdev);

        // Add a reference to the PDEV so that it won't be deleted
        // until the last D3D structure is freed.  We do this
        // so that on dynamic mode changes, we can keep the active
        // DirectDraw driver state around.  This is so that if we ever
        // return to the original mode, we can resume any Direct3D
        // accelerations exactly where we were originally.
        //
        // The DirectDraw convention is that if an accelerated Direct3D
        // application is started at 640x480, and the mode changes to
        // 800x600, the application stops drawing (unless it recreates
        // all its execute buffers and all other DirectX state).  But if
        // the display is returned back to the original 640x480 mode, all
        // the application has to do is 'restore' its surfaces, and it can
        // keep running.
        //
        // To allow this we have to keep around the driver's 640x480
        // instance even when the display is 800x600.  But if the
        // application terminated while at 800x600, we would have to clean
        // up the 640x480 driver instance.  Once that happens, the 640x480
        // PDEV can be completely deleted.  This is why we reference
        // count the PDEV:

        po.vReferencePdev();
    }
}

/******************************Public*Routine******************************\
* VOID vDdDecrementReferenceCount
*
* Devlock must not be held entering the function if PDEV may be unloaded.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDecrementReferenceCount(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL bUnreference = FALSE;

    {
        EDD_DEVLOCK eDevlock(peDirectDrawGlobal->hdev);

        ASSERTGDI(peDirectDrawGlobal->cDriverReferences > 0,
                "Weird reference count");

        if (--peDirectDrawGlobal->cDriverReferences == 0)
        {
            bUnreference = TRUE;
        }
    }

    if (bUnreference)
    {
        PDEVOBJ po(peDirectDrawGlobal->hdev);

        // If this dev lock is not held then we may free this driver.
        po.vUnreferencePdev();
    }
}

/******************************Public*Routine******************************\
* LONGLONG llDdAssertModeTimeout()
*
* Reads the DirectDraw timeout value from the registry.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Lifted it from AndreVa's code.
\**************************************************************************/

LONGLONG
llDdAssertModeTimeout(
    )
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    LONGLONG                    llTimeout;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;

    llTimeout = 0;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\GraphicsDrivers\\DCI");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, L"Timeout");

        Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"Timeout") +
                 sizeof(DWORD);

        Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, ' ddG');

        if (Information)
        {
            status = ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length);

            if (NT_SUCCESS(status))
            {
                llTimeout = ((LONGLONG) -10000) * 1000 * (
                          *(LPDWORD) ((((PUCHAR)Information) +
                            Information->DataOffset)));
            }

            VFREEMEM(Information);
        }

        ZwCloseKey(hkRegistry);
    }

    return(llTimeout);
}

/******************************Public*Routine******************************\
* BOOL bDdMapAgpHeap
*
* Maps an AGP heap into a virtual address space.
*
*  25-Aug-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

BOOL
bDdMapAgpHeap(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    VIDEOMEMORY*            pvmHeap
    )
{
    BOOL                    bSuccess = FALSE;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;
    BYTE*                   pAgpVirtualCommitMask;
    DWORD                   dwAgpVirtualCommitMaskSize;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    peMap = (EDD_VMEMMAPPING*) PALLOCMEM(sizeof(EDD_VMEMMAPPING), ' ddG');

    dwAgpVirtualCommitMaskSize = pvmHeap->lpHeap->dwAgpCommitMaskSize;
    if (dwAgpVirtualCommitMaskSize > 0)
    {
        pAgpVirtualCommitMask = (BYTE*)PALLOCMEM(dwAgpVirtualCommitMaskSize,
            ' ddG');
    }
    else
    {
        pAgpVirtualCommitMask = NULL;
    }
    if (pAgpVirtualCommitMask == NULL)
    {
        VFREEMEM(peMap);
        peMap = NULL;
    }

    if (peMap)
    {
        peMap->pvVirtAddr =
            peDirectDrawGlobal->AgpInterface.AgpServices.
                AgpReserveVirtual(peDirectDrawGlobal->AgpInterface.Context,
                                  NtCurrentProcess(),
                                  pvmHeap->lpHeap->pvPhysRsrv,
                                  &peMap->pvReservation);

        if (peMap->pvVirtAddr != NULL)
        {
            peMap->cReferences = 1;
            peMap->fl          = DD_VMEMMAPPING_FLAG_AGP;
            peMap->ulMapped    = 0;
            peMap->iHeapIndex  = (DWORD)
                (pvmHeap - peDirectDrawGlobal->pvmList);
            peMap->pAgpVirtualCommitMask = pAgpVirtualCommitMask;
            peMap->dwAgpVirtualCommitMaskSize = dwAgpVirtualCommitMaskSize;

            ASSERTGDI(peDirectDrawLocal->
                ppeMapAgp[peMap->iHeapIndex] == NULL,
                "Heap already mapped");

            peDirectDrawLocal->ppeMapAgp[peMap->iHeapIndex] = peMap;
            peDirectDrawLocal->iAgpHeapsMapped++;

            DDKHEAP(("DDKHEAP: Res %08X reserved %08X, size %X\n",
                    peMap->pvReservation, peMap->pvVirtAddr,
                    pvmHeap->lpHeap->dwTotalSize));

            bSuccess = TRUE;
        }
        else
        {
            VFREEMEM(peMap);
        }
    }

    return bSuccess;
}

/******************************Public*Routine******************************\
* VOID vDdUnmapMemory
*
* Deletes the user mode mapping of the frame buffer.
* We may be in a different process from the one in which
* the mapping was initially created in.
*
* The devlock must be held to call this function.
*
* Note: This should only be called from vDdUnreferenceVirtualMap
*
*  1-Oct-1998 -by- Anuj Gosalia [anujg]
* Wrote it.
\**************************************************************************/

VOID
vDdUnmapMemory(
    EDD_VMEMMAPPING*        peMap,
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    HANDLE                  ProcessHandle
    )
{
    DD_MAPMEMORYDATA        MapMemoryData;
    DWORD                   dwRet;
    NTSTATUS                Status;

    DDKHEAP(("vDdUnmapMemory: peDirectDrawGlobal=%x, fpProcess=%x\n",
            peDirectDrawGlobal, peMap->fpProcess));

    // Call driver to unmap memory:

    MapMemoryData.lpDD        = peDirectDrawGlobal;
    MapMemoryData.bMap        = FALSE;
    MapMemoryData.hProcess    = ProcessHandle;
    MapMemoryData.fpProcess   = peMap->fpProcess;

    dwRet = peDirectDrawGlobal->CallBacks.MapMemory(&MapMemoryData);

    ASSERTGDI((dwRet == DDHAL_DRIVER_NOTHANDLED) ||
              (MapMemoryData.ddRVal == DD_OK),
              "Driver failed DirectDraw memory unmap\n");
}

/******************************Public*Routine******************************\
* VOID vDdUnmapAgpHeap
*
* Decommits all virtual memory in an AGP heap, then releases the heap
* mapping. If the AGP heap is now empty, this function will decommit the
* physical memory as well.
*
* Note: This should only be called from vDdUnreferenceVirtualMap
*
*  19-Jan-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

VOID
vDdUnmapAgpHeap(
    EDD_VMEMMAPPING*        peMap,
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal
    )
{
    VIDEOMEMORY*            pvmHeap;
    ULONG                   ulOffs;
    BOOL                    bSuccess;
    ULONG                   ulPages;
    ULONG                   ulHeapPages;

    pvmHeap = peDirectDrawGlobal->pvmList + peMap->iHeapIndex;

    ASSERTGDI(peMap != NULL,
        "Request to unmap an AGP heap which has not been mapped");
    ASSERTGDI(pvmHeap->lpHeap->pvPhysRsrv != NULL,
        "AGP reservation context is NULL in heap");

    if (!(peDirectDrawLocal->fl & DD_LOCAL_DISABLED))
    {
        bSuccess = AGPDecommitVirtual( peMap,
                                       peDirectDrawGlobal,
                                       peDirectDrawLocal,
                                       pvmHeap->lpHeap->dwTotalSize); 

        peDirectDrawGlobal->AgpInterface.AgpServices.
            AgpReleaseVirtual(peDirectDrawGlobal->AgpInterface.Context,
                              peMap->pvReservation); 

        peDirectDrawLocal->iAgpHeapsMapped--;
    }

    // If the heap is now empty but memory is still committed, go ahead and
    // decommit all the physical AGP memory:

    if ((pvmHeap->lpHeap->allocList == NULL) &&
        (pvmHeap->lpHeap->dwCommitedSize > 0))
    {
        DWORD                 dwTemp;
        EDD_DIRECTDRAW_LOCAL* peTempLocal; 
        EDD_VMEMMAPPING*      peTempMap;

        // We may have other processes that have virtual commits outstanding
        // even though they didn't allocate any AGP memory, so we can
        // decommit them now.

        peTempLocal = peDirectDrawGlobal->peDirectDrawLocalList;
        while (peTempLocal != NULL )
        {
            if (peTempLocal != peDirectDrawLocal)
            {
                if ((peTempLocal->ppeMapAgp != NULL) &&
                    !(peTempLocal->fl & DD_LOCAL_DISABLED))
                {
                    peTempMap = peTempLocal->ppeMapAgp[peMap->iHeapIndex];
                    if (peTempMap != NULL)
                    {
                        AGPDecommitVirtual( peTempMap,
                                            peDirectDrawGlobal,
                                            peTempLocal,
                                            pvmHeap->lpHeap->dwTotalSize); 
                    }
                }
            }
            peTempLocal = peTempLocal->peDirectDrawLocalNext;
        }

        bSuccess = AGPDecommitAll(
            AGP_HDEV(peDirectDrawGlobal),
            pvmHeap->lpHeap->pvPhysRsrv,
            pvmHeap->lpHeap->pAgpCommitMask,
            pvmHeap->lpHeap->dwAgpCommitMaskSize,
            &dwTemp,
            pvmHeap->lpHeap->dwTotalSize);

        ASSERTGDI(bSuccess, "Failed to decommit AGP memory");

        pvmHeap->lpHeap->dwCommitedSize = 0;
    }
    else 
    {
        CleanupAgpCommits( pvmHeap, pvmHeap->lpHeap->hdevAGP, 
            peDirectDrawGlobal, peMap->iHeapIndex );
    }
}

/******************************Public*Routine******************************\
* VOID vDdUnreferenceVirtualMap
*
*  24-Aug-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

VOID
vDdUnreferenceVirtualMap(
    EDD_VMEMMAPPING*        peMap,
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    HANDLE                  ProcessHandle,
    BOOL                    bMapToDummyPage
    )
{
    BOOL    bUnmapMemory = FALSE;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    // If this was the last surface holding a pointer in the mapping we can
    // can free it now. This involves calling the driver since it was the
    // one who created the mapping in the first place. If this is not the
    // last reference, and the memory has not been aliased yet, do so now:

    if (--(peMap->cReferences) == 0)
    {
        bUnmapMemory = TRUE;
    }
    else if (!(peMap->fl & DD_VMEMMAPPING_FLAG_ALIASED) && bMapToDummyPage)
    {
        NTSTATUS    Status;

        EngAcquireSemaphore(ghsemDummyPage);

        if (gpDummyPage == NULL)
        {
            // Allocate dummy page which is used to map all disabled user
            // mode vid mem mapping to:

            gpDummyPage = ExAllocatePoolWithTag(
                              (POOL_TYPE)(SESSION_POOL_MASK | NonPagedPool),
                              PAGE_SIZE, 'DddG');

            if (gpDummyPage == NULL)
            {
                WARNING("vDdUnreferenceVirtualMap: could not allocate dummy page");
                Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                ASSERTGDI(((ULONG_PTR)gpDummyPage & (PAGE_SIZE - 1)) == 0,
                          "vDdUnreferenceVirtualMap: "
                          "Dummy page is not page aligned\n");
                DDKHEAP(("Allocated dummy page\n"));
                gcDummyPageRefCnt = 0;
            }
        }

        if (gpDummyPage != NULL)
        {
            DDKHEAP(("vDdUnreferenceVirtualMap: "
                "Attempting to remap vid mem to dummy page\n"));

            // There are outstanding locks to this memory. Map it to a dummy
            // page and proceed.

            // Calling services while attached is never a good idea.
            // However, MmMapUserAddressesToPage handles this case, so we
            // can attach and call:

            KeAttachProcess(PsGetProcessPcb(peDirectDrawLocal->Process));

            if (!(peMap->fl & DD_VMEMMAPPING_FLAG_AGP))
            {
                Status = MmMapUserAddressesToPage(
                    (VOID*) peMap->fpProcess, 0, gpDummyPage);
            }
            else
            {
                Status = AGPMapToDummy (peMap, peDirectDrawGlobal, gpDummyPage);
            }

            if (!NT_SUCCESS(Status))
            {
                DDKHEAP(("MmMapUserAddressesToPage failed: %08X\n", Status));
            }

            KeDetachProcess();
        }

        if (!NT_SUCCESS(Status))
        {
            EDD_SURFACE*    peSurface;

            WARNING("vDdUnreferenceVirtualMap: "
                "failed to map user addresses to dummy page\n");

            // Something went wrong so we must unmap the memory and remove
            // any references to this map:

            bUnmapMemory = TRUE;

            // We need to traverse the surfaces of this local and mark all
            // pointers to this mapping as NULL:

            peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

            while (peSurface)
            {
                if (peSurface->peMap == peMap)
                {
                    peSurface->peMap = NULL;

                    // Each mapping took a reference count on the surface's
                    // DirectDraw global, so undo that here:

                    vDdDecrementReferenceCount(
                        peSurface->peVirtualMapDdGlobal);
                    peSurface->peVirtualMapDdGlobal = NULL;
                }

                peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
            }
        }
        else
        {
            peMap->fl |= DD_VMEMMAPPING_FLAG_ALIASED;
            gcDummyPageRefCnt++;
        }

        EngReleaseSemaphore(ghsemDummyPage);
    }

    if (bUnmapMemory)
    {
        if (!(peMap->fl & DD_VMEMMAPPING_FLAG_AGP))
        {
            vDdUnmapMemory(peMap, peDirectDrawGlobal, ProcessHandle);
        }
        else
        {
            vDdUnmapAgpHeap(peMap, peDirectDrawGlobal, peDirectDrawLocal);
        }

        EngAcquireSemaphore(ghsemDummyPage);

        if (peMap->fl & DD_VMEMMAPPING_FLAG_ALIASED)
        {
            ASSERTGDI(gcDummyPageRefCnt > 0,
                "Dummy page reference count will be < 0");
            ASSERTGDI(gpDummyPage != NULL,
                "Dereferencing dummy page which has not been allocated");
            gcDummyPageRefCnt--;
        }

        if ((gpDummyPage != NULL) && (gcDummyPageRefCnt == 0))
        {
            ExFreePool(gpDummyPage);
            gpDummyPage = NULL;
            DDKHEAP(("Freed dummy page\n"));
        }

        EngReleaseSemaphore(ghsemDummyPage);

        if (peMap->pAgpVirtualCommitMask != NULL)
        {
            VFREEMEM(peMap->pAgpVirtualCommitMask);
        }
        VFREEMEM(peMap);
    }
}

/******************************Public*Routine******************************\
* BOOL DxDdEnableDirectDraw
*
* Allocates the global DirectDraw object and then enables the driver
* for DirectDraw.
*
* Assumes devlock already held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
DxDdEnableDirectDraw(
    HDEV hdev,
    BOOL bEnableDriver
    )
{
    BOOL                    bRet = FALSE;       // Assume failure
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    KEVENT*                 pAssertModeEvent;

    PDEVOBJ po(hdev);

    // Don't bother doing anything for printers.

    if (!po.bDisplayPDEV())
    {
        return(TRUE);
    }

    // Note that this must be zero initialized, because we promised
    // the driver that we would.  Don't zero-initialize the driver
    // state, though, because there may be some open references to
    // it!

    peDirectDrawGlobal = po.peDirectDrawGlobal();

    RtlZeroMemory((_DD_DIRECTDRAW_LOCAL*) peDirectDrawGlobal,
            sizeof(_DD_DIRECTDRAW_LOCAL));
    RtlZeroMemory((_DD_DIRECTDRAW_GLOBAL*) peDirectDrawGlobal,
            sizeof(_DD_DIRECTDRAW_GLOBAL));
    RtlZeroMemory((DD_DIRECTDRAW_GLOBAL_PDEV_DATA*) peDirectDrawGlobal,
            sizeof(DD_DIRECTDRAW_GLOBAL_PDEV_DATA));

    // Initialize our private structures:

    peDirectDrawGlobal->hdev   = po.hdev();
    peDirectDrawGlobal->dhpdev = po.dhpdev();
    peDirectDrawGlobal->bSuspended = FALSE;

    // The VideoPort HAL calls oddly reference PDD_DIRECTDRAW_LOCAL
    // instead of PDD_DIRECTDRAW_GLOBAL.  The driver will never reference
    // anything in the local structure other than 'lpGbl', so we simply
    // add a DIRECTDRAW_LOCAL structure to the definition of the
    // DIRECTDRAW_GLOBAL structure that points to itself:

    peDirectDrawGlobal->lpGbl  = peDirectDrawGlobal;

    peDirectDrawGlobal->llAssertModeTimeout
                               = llDdAssertModeTimeout();

    // The event must live in non-paged pool:

    pAssertModeEvent = (KEVENT*) PALLOCNONPAGED(sizeof(KEVENT),'eddG');

    if (pAssertModeEvent != NULL)
    {
        peDirectDrawGlobal->pAssertModeEvent = pAssertModeEvent;

        KeInitializeEvent(pAssertModeEvent,
                          SynchronizationEvent,
                          FALSE);

        if (bEnableDriver)
        {
            vDdEnableDriver(peDirectDrawGlobal);
        }

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID DxDdDisableDirectDraw
*
* Note: This function may be called without bDdEnableDirectDraw having
*       first been called!
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdDisableDirectDraw(
    HDEV hdev,
    BOOL bDisableDriver
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    PDEVOBJ po(hdev);

    peDirectDrawGlobal = po.peDirectDrawGlobal();

    // Don't bother doing anything more if we were never enabled in the
    // first place.

    if ((peDirectDrawGlobal == NULL) || 
        (peDirectDrawGlobal->hdev == NULL))
    {
        return;
    }

    EDD_DEVLOCK eDevLock(hdev);

    if (bDisableDriver)
    {
        vDdDisableDriver(peDirectDrawGlobal);
    }

    if (peDirectDrawGlobal->pAssertModeEvent != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pAssertModeEvent);
    }

    RtlZeroMemory(peDirectDrawGlobal, sizeof(*peDirectDrawGlobal));
}

/******************************Public*Routine******************************\
* VOID vDdDisableDirectDrawObject
*
* Disables a DirectDraw object.  This amounts to simply unmapping the
* view of the frame buffer.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableDirectDrawObject(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    HANDLE                  ProcessHandle;
    CLIENT_ID               ClientId;
    EDD_VIDEOPORT*          peVideoPort;
    BOOL                    bUnmapAgpHeaps;

    bUnmapAgpHeaps = peDirectDrawLocal->iAgpHeapsMapped > 0;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    // We may be in a different process from the one in which the
    // memory was originally mapped.  Consequently, we have to open
    // a handle to the process in which the mapping was created.
    // We are guaranteed that the process will still exist because
    // this view is always unmapped at process termination.

    ProcessHandle = NULL;

    if (bUnmapAgpHeaps ||
        ((peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED) &&
         (peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_MAPMEMORY)))
    {
        ClientId.UniqueThread = (HANDLE) NULL;
        ClientId.UniqueProcess = peDirectDrawLocal->UniqueProcess;

        InitializeObjectAttributes(&ObjectAttributes,
                                   NULL,
                                   OBJ_INHERIT | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);

        Status = ZwOpenProcess(&ProcessHandle,
                               PROCESS_DUP_HANDLE,
                               &ObjectAttributes,
                               &ClientId);

        if (!NT_SUCCESS(Status))
        {
            WARNING("vDdDisableDirectDrawObject: "
                    "Couldn't open process handle");
            ProcessHandle = NULL;
        }
    }

    if (peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED)
    {
        peDirectDrawLocal->fl &= ~DD_LOCAL_FLAG_MEMORY_MAPPED;
        peDirectDrawGlobal->cMaps--;

        ASSERTGDI(peDirectDrawGlobal->cMaps >= 0, "Invalid map count");

        if ((peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_MAPMEMORY) &&
            ProcessHandle != NULL)
        {
            vDdUnreferenceVirtualMap(peDirectDrawLocal->peMapCurrent,
                                     peDirectDrawGlobal,
                                     peDirectDrawLocal,
                                     ProcessHandle,
                                     TRUE);

            peDirectDrawLocal->peMapCurrent = NULL;
        }
    }

    // Unmap AGP heaps if necessary:

    if (bUnmapAgpHeaps && (ProcessHandle != NULL))
    {
        DWORD i;
        EDD_VMEMMAPPING** ppeMapAgp;

        ppeMapAgp = peDirectDrawLocal->ppeMapAgp;

        for (i = 0; i < peDirectDrawGlobal->dwNumHeaps; i++, ppeMapAgp++)
        {
            if (*ppeMapAgp != NULL)
            {
                vDdUnreferenceVirtualMap(*ppeMapAgp,
                                         peDirectDrawGlobal,
                                         peDirectDrawLocal,
                                         ProcessHandle,
                                         TRUE);

                *ppeMapAgp = NULL;
            }
        }
    }

    if (ProcessHandle != NULL)
    {
        Status = ZwClose(ProcessHandle);
        ASSERTGDI(NT_SUCCESS(Status), "Failed close handle");
    }

    // Stop any active videoports:

    for (peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
         peVideoPort != NULL;
         peVideoPort = peVideoPort->peVideoPort_DdNext)
    {
        vDdStopVideoPort(peVideoPort);
    }
}

/******************************Public*Routine******************************\
* HANDLE hDdCreateDirectDrawLocal
*
* Creates a new local DirectDraw object for a process attaching to
* a PDEV for which we've already enabled DirectDraw.  Note that the
* DirectDraw user-mode process will actually think of this as its
* 'global' DirectDraw object.
*
* Assumes devlock already held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HANDLE
hDdCreateDirectDrawLocal(
    PDEVOBJ&    po
    )
{
    HANDLE                  h;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING**       ppeMapAgp;

    h = 0;

    peDirectDrawGlobal = po.peDirectDrawGlobal();

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    if (peDirectDrawGlobal->dwNumHeaps > 0)
    {
        // Allocate an array to hold per-process AGP heap information.
        ppeMapAgp = (EDD_VMEMMAPPING**)
            PALLOCMEM(sizeof(EDD_VMEMMAPPING*) *
                      peDirectDrawGlobal->dwNumHeaps,
                      'pddG');
        if (ppeMapAgp == NULL)
        {
            return h;
        }
    }
    else
    {
        ppeMapAgp = NULL;
    }

    // We allocate this via the handle manager so that we can use the
    // existing handle manager process clean-up mechanisms:


    peDirectDrawLocal = (EDD_DIRECTDRAW_LOCAL*) DdHmgAlloc(
                                 sizeof(EDD_DIRECTDRAW_LOCAL),
                                 DD_DIRECTDRAW_TYPE,
                                 HMGR_ALLOC_LOCK);
    if (peDirectDrawLocal != NULL)
    {
        // Insert this object at the head of the object list:

        peDirectDrawLocal->peDirectDrawLocalNext
            = peDirectDrawGlobal->peDirectDrawLocalList;

        peDirectDrawGlobal->peDirectDrawLocalList = peDirectDrawLocal;

        // Initialize surface list:

        InitializeListHead(&(peDirectDrawLocal->ListHead_eSurface));

        // Initialize private GDI data:

        peDirectDrawLocal->peDirectDrawGlobal = peDirectDrawGlobal;
        peDirectDrawLocal->lpGbl = peDirectDrawGlobal;
        peDirectDrawLocal->UniqueProcess = PsGetCurrentThreadProcessId();
        peDirectDrawLocal->Process = PsGetCurrentProcess();

        peDirectDrawLocal->ppeMapAgp = ppeMapAgp;

        peDirectDrawLocal->peMapCurrent = NULL;

        // This has reference to PDEVOBJ, so increment ref count of PDEVOBJ:

        po.vReferencePdev();

        // Do an HmgUnlock:

        h = peDirectDrawLocal->hHmgr;
        DEC_EXCLUSIVE_REF_CNT(peDirectDrawLocal);

        // Setup the AGP heaps if the driver exposes any

        MapAllAgpHeaps( peDirectDrawLocal );
    }
    else if (ppeMapAgp != NULL)
    {
        VFREEMEM(ppeMapAgp);
    }

    return(h);
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteDirectDrawObject
*
* Deletes a kernel-mode representation of the DirectDraw object.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteDirectDrawObject(
    HANDLE  hDirectDrawLocal,
    BOOL    bProcessTermination
    )
{
    BOOL                        bRet;
    BOOL                        b;
    VOID*                       pRemove;
    EDD_DIRECTDRAW_LOCAL*       peDirectDrawLocal;
    EDD_DIRECTDRAW_LOCAL*       peTmp;
    EDD_DIRECTDRAW_GLOBAL*      peDirectDrawGlobal;
    EDD_VIDEOPORT*              peVideoPort;
    EDD_VIDEOPORT*              peVideoPortNext;
    EDD_MOTIONCOMP*             peMotionComp;
    EDD_MOTIONCOMP*             peMotionCompNext;
    EDD_SURFACE*                peSurface;
    EDD_SURFACE*                peSurfaceNext;

    bRet = FALSE;

    peDirectDrawLocal = (EDD_DIRECTDRAW_LOCAL*)
        DdHmgLock((HDD_OBJ) hDirectDrawLocal, DD_DIRECTDRAW_TYPE, FALSE);

    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        PDEVOBJ po(peDirectDrawGlobal->hdev);

        b = TRUE;

        // Now, try to delete all videoports associated with this object:

        for (peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
             peVideoPort != NULL;
             peVideoPort = peVideoPortNext)
        {
            // Don't reference peVideoPort after it's been deleted!

            peVideoPortNext = peVideoPort->peVideoPort_DdNext;
            b &= bDdDeleteVideoPortObject(peVideoPort->hGet(), NULL);
        }

        for (peMotionComp = peDirectDrawLocal->peMotionComp_DdList;
             peMotionComp != NULL;
             peMotionComp = peMotionCompNext)
        {
            peMotionCompNext = peMotionComp->peMotionComp_DdNext;
            b &= bDdDeleteMotionCompObject(peMotionComp->hGet(), NULL);
        }

        // Next, try to delete all surfaces associated with this object:

        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

        while (peSurface)
        {
            // Don't reference peSurface after it's been deleted!

            peSurfaceNext = peDirectDrawLocal->peSurface_Enum(peSurface);

            // Delete the surface

            b &= bDdDeleteSurfaceObject(peSurface->hGet(), NULL);

            // Move onto next one

            peSurface = peSurfaceNext;
        }

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            // If they set a gamma ramp, restore it now

            if (peDirectDrawLocal->pGammaRamp != NULL)
            {
                DxEngSetDeviceGammaRamp(
                    po.hdev(),
                    peDirectDrawLocal->pGammaRamp,
                    TRUE);
                VFREEMEM(peDirectDrawLocal->pGammaRamp);
                peDirectDrawLocal->pGammaRamp = NULL;
            }

            if (peDirectDrawGlobal->Miscellaneous2CallBacks.DestroyDDLocal)
            {
                DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
                DD_DESTROYDDLOCALDATA destDDLcl;
                destDDLcl.dwFlags = 0;
                destDDLcl.pDDLcl  = peDirectDrawLocal;
                dwRet = peDirectDrawGlobal->Miscellaneous2CallBacks.DestroyDDLocal(&destDDLcl);
                if (dwRet == DDHAL_DRIVER_NOTHANDLED)
                {
                    WARNING("bDdDeleteDirectDrawObject: failed DestroyDDLocal\n");
                }
            }

            // Only delete the DirectDraw object if we successfully deleted
            // all linked surface objects:

            if (b)
            {
                DWORD       dwHeap;
                LPVIDMEM    pHeap;

                // Remove object from the handle manager:

                pRemove = DdHmgRemoveObject((HDD_OBJ) hDirectDrawLocal,
                                            1,
                                            0,
                                            TRUE,
                                            DD_DIRECTDRAW_TYPE);

                ASSERTGDI(pRemove != NULL, "Couldn't delete DirectDraw object");

                vDdDisableDirectDrawObject(peDirectDrawLocal);

                // Now that we've cleanup up the surfaces, now we will cleanup any 
                // agp commits that need to be.

                pHeap = peDirectDrawGlobal->pvmList;
                for (dwHeap = 0;
                     dwHeap < peDirectDrawGlobal->dwNumHeaps;
                     pHeap++, dwHeap++)
                {
                    if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
                        !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
                        (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
                        (pHeap->lpHeap != NULL))
                    {
                        CleanupAgpCommits( pHeap, pHeap->lpHeap->hdevAGP, 
                            peDirectDrawGlobal, dwHeap );
                    }
                }

                ////////////////////////////////////////////////////////////
                // Remove the global DirectDraw object from the PDEV when
                // the last associated local object is destroyed, and
                // call the driver:

                if (peDirectDrawGlobal->peDirectDrawLocalList == peDirectDrawLocal)
                {
                    peDirectDrawGlobal->peDirectDrawLocalList
                        = peDirectDrawLocal->peDirectDrawLocalNext;
                }
                else
                {
                    for (peTmp = peDirectDrawGlobal->peDirectDrawLocalList;
                         peTmp->peDirectDrawLocalNext != peDirectDrawLocal;
                         peTmp = peTmp->peDirectDrawLocalNext)
                         ;

                    peTmp->peDirectDrawLocalNext
                        = peDirectDrawLocal->peDirectDrawLocalNext;
                }

                // We're all done with this object, so free the memory and
                // leave:

                if (peDirectDrawLocal->ppeMapAgp != NULL)
                {
                    VFREEMEM(peDirectDrawLocal->ppeMapAgp);
                }

                DdFreeObject(peDirectDrawLocal, DD_DIRECTDRAW_TYPE);

                bRet = TRUE;
            }
            else
            {
                WARNING("bDdDeleteDirectDrawObject: A surface was busy\n");
                if (bProcessTermination)
                {
                    peDirectDrawLocal->fl |= DD_LOCAL_DISABLED;
                }
            }
        }

        if (bRet)
        {
            // Unreference PDEVOBJ - must not have devlock
            po.vUnreferencePdev();
        }

        // Note that we can't force a repaint here by calling
        // UserRedrawDesktop because we may be in a bad process context.
    }
    else
    {
        WARNING("bDdDeleteDirectDrawObject: Bad handle or object busy\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDdRelinquishSurfaceOrBufferLock
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdRelinquishSurfaceOrBufferLock(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface
    )
{
    DD_UNLOCKDATA   UnlockData;
    EDD_SURFACE*    peTmp;

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);
    ASSERTGDI(peSurface->cLocks > 0, "Must have non-zero locks to relinquish");

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        if (peDirectDrawGlobal->D3dBufCallbacks.UnlockD3DBuffer != NULL)
        {
            UnlockData.lpDD        = peDirectDrawGlobal;
            UnlockData.lpDDSurface = peSurface;

            peDirectDrawGlobal->D3dBufCallbacks.UnlockD3DBuffer(&UnlockData);
        }
    }
    else
    {
        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
            DDHAL_SURFCB32_UNLOCK)
        {
            UnlockData.lpDD        = peDirectDrawGlobal;
            UnlockData.lpDDSurface = peSurface;

            peDirectDrawGlobal->SurfaceCallBacks.Unlock(&UnlockData);
        }
    }

    // An application may take multiple locks on the same surface:

    if (--peSurface->cLocks == 0)
    {
        if (!(peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) ||
            ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
             (peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST)))
        {
            peDirectDrawGlobal->cSurfaceLocks--;
        }

        if (peSurface->peMap ||
            (peSurface->fl & DD_SURFACE_FLAG_FAKE_ALIAS_LOCK))
        {
            peDirectDrawGlobal->cSurfaceAliasedLocks--;
            peSurface->fl &= ~DD_SURFACE_FLAG_FAKE_ALIAS_LOCK;
        }

        // Primary surface unlocks require special handling for stuff like
        // pointer exclusion:

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            // Since all locks for this surface have been relinquished, remove
            // it from the locked surface list.

            if (peDirectDrawGlobal->peSurface_PrimaryLockList == peSurface)
            {
                peDirectDrawGlobal->peSurface_PrimaryLockList
                    = peSurface->peSurface_PrimaryLockNext;
            }
            else
            {
                for (peTmp = peDirectDrawGlobal->peSurface_PrimaryLockList;
                     peTmp->peSurface_PrimaryLockNext != peSurface;
                     peTmp = peTmp->peSurface_PrimaryLockNext)
                {
                    ASSERTGDI(peTmp != NULL, "Can't find surface in lock list");
                }

                peTmp->peSurface_PrimaryLockNext
                    = peSurface->peSurface_PrimaryLockNext;
            }

            peSurface->peSurface_PrimaryLockNext = NULL;

            // Redraw any sprites:

            DxEngSpUnTearDownSprites(peDirectDrawGlobal->hdev,
                                     &peSurface->rclLock,
                                     TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDdLooseManagedSurfaceObject
*
* Informs the driver that it should clean up any video memory allocated for
* a persistent managed surface since a mode switch has occured.
*
*  13-May-1999 -by- Sameer Nene [snene]
* Wrote it.
\**************************************************************************/

VOID
vDdLooseManagedSurfaceObject(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface,
    DWORD*                  pdwRet          // For returning driver return code,
    )                                       //   may be NULL
{
    DD_DESTROYSURFACEDATA   DestroySurfaceData;

    DD_ASSERTSHAREDEVLOCK();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DDKHEAP(("DDKHEAP: Loosing surface %X (%X)\n",
             peSurface->hGet(), peSurface));

    // Due to video mode change, this driver managed surface is lives in "different" video
    // driver then what the driver actually "manage" this surface.
    // So we don't do anything here, since it has been "loose" already since mode change happened.

    if (!(peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER))
    {
        DestroySurfaceData.lpDD        = peDirectDrawGlobal;
        DestroySurfaceData.lpDDSurface = peSurface;
        DestroySurfaceData.lpDDSurface->dwFlags |= DDRAWISURF_INVALID;
        if ((peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
            peDirectDrawGlobal->D3dBufCallbacks.DestroyD3DBuffer != NULL)
        {
            peDirectDrawGlobal->D3dBufCallbacks.DestroyD3DBuffer(&DestroySurfaceData);
        }
        else if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
            (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_DESTROYSURFACE))
        {
            peDirectDrawGlobal->SurfaceCallBacks.DestroySurface(&DestroySurfaceData);
        }
        DestroySurfaceData.lpDDSurface->dwFlags &= ~DDRAWISURF_INVALID;
    }
    else
    {
        // WARNING("vDdLooseManagedSurfaceObject: called with DD_SURFACE_FLAG_WRONG_DRIVER");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = DDHAL_DRIVER_HANDLED;
    }
}

/******************************Public*Routine******************************\
* VOID SafeFreeUserMem
*
* Frees user mem and switches to the correct process if required.
*
*  5-Apr-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
SafeFreeUserMem(
    PVOID       pv,
    PEPROCESS   Process
    )
{
    if (PsGetCurrentProcess() == Process)
    {
        EngFreeUserMem(pv);
    }
    else
    {
        // Calling services while attached is never a good idea.  However,
        // free virtual memory handles this case, so we can attach and
        // call.
        //
        // Note that the process must exist.  We are guaranteed that this
        // is the case because we automatically delete all surfaces on
        // process deletion.

        KeAttachProcess(PsGetProcessPcb(Process));
        EngFreeUserMem(pv);
        KeDetachProcess();
    }
}

/******************************Public*Routine******************************\
* VOID DeferMemoryFree
*
* Places the memory into a list to be freed at a later time when it's safe.
*
*  5-Apr-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
DeferMemoryFree(
    PVOID                  pv,
    EDD_SURFACE*           peSurface
    )
{
    DD_USERMEM_DEFER* pDefer;

    pDefer = (DD_USERMEM_DEFER*) PALLOCMEM(sizeof(DD_USERMEM_DEFER),
                                               'pddG');
    if (pDefer != NULL)
    {
        pDefer->pUserMem = pv;
        pDefer->peSurface = peSurface;
        pDefer->pNext = peSurface->peDirectDrawLocal->peDirectDrawGlobal->pUserMemDefer;
        peSurface->peDirectDrawLocal->peDirectDrawGlobal->pUserMemDefer = pDefer;
        peSurface->fl |= DD_SURFACE_FLAG_DEFER_USERMEM;
    }
}

/******************************Public*Routine******************************\
* VOID vDdDisableSurfaceObject
*
* Disables a kernel-mode representation of the surface.  This is also
* known as marking the surface as 'lost'.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableSurfaceObject(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface,
    DWORD*                  pdwRet          // For returning driver return code,
    )                                       //   may be NULL
{
    DWORD                   dwRet;
    DXOBJ*                  pDxObj;
    DXOBJ*                  pDxObjNext;
    DD_FLIPDATA             FlipData;
    EDD_SURFACE*            peSurfaceCurrent;
    EDD_SURFACE*            peSurfacePrimary;
    DD_DESTROYSURFACEDATA   DestroySurfaceData;
    DD_UPDATEOVERLAYDATA    UpdateOverlayData;

    DD_ASSERTSHAREDEVLOCK();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DDKHEAP(("DDKHEAP: Disabling surface %X (%X)\n",
             peSurface->hGet(), peSurface));

    // If this surface is a destination surface for the videoport, turn it
    // off:

    if (peSurface->lpVideoPort != NULL)
    {
        vDdStopVideoPort(pedFromLp(peSurface->lpVideoPort));

        ASSERTGDI(peSurface->lpVideoPort == NULL, "Expected surface clean-up");
    }

    // Mark the DXAPI instance of the surface as lost:

    if (peSurface->hSurface != NULL)
    {
        vDdDxApiFreeSurface( (DXOBJ*) peSurface->hSurface, FALSE );
        peSurface->hSurface = NULL;
    }

    if (peSurface->peDxSurface != NULL)
    {
        vDdLoseDxObjects(peDirectDrawGlobal,
                         peSurface->peDxSurface->pDxObj_List,
                         (PVOID) peSurface->peDxSurface,
                         LO_SURFACE );
    }

    if (peSurface->peDxSurface != NULL)
    {
        peDirectDrawGlobal->pfnLoseObject(peSurface->peDxSurface,
                                          LO_SURFACE);
    }

    if (peSurface->hbmGdi != NULL)
    {
        // It's not always possible to delete the cached GDI
        // bitmap here, because we might have to first un-select
        // the bitmap from its DC, and doing so requires an
        // exclusive lock on the DC, which may not be possible
        // if another thread is currently in kernel mode with the
        // DC locked, just waiting for us to release the devlock.
        //
        // But we desperately need to delete the driver's
        // realization at this point, before a mode change happens
        // which renders its associations invalid.  So we do that
        // now.
        //
        // This may leave the surface in an unusable state (which
        // is true even for non-DrvDeriveSurface surfaces).
        // That's okay, because the surface can't be selected into
        // any other DC, and the DC is marked as 'disabled' in the
        // following snibbet of code.

        // Bug 330141 : sr(hbmGdi) does not work since it fails
        // when we are called on a non-creating thread in mode
        // change, thus not deleting the bitmap.

        SURFOBJ* pso;

        if ((pso = DxEngAltLockSurface(peSurface->hbmGdi)) != NULL)
        {
            if (pso->dhsurf != NULL)
            {
                (*PPFNDRV(po, DeleteDeviceBitmap))(pso->dhsurf);
                pso->dhsurf = NULL;
            }

            EngUnlockSurface(pso);
        }
    }

    if (peSurface->hdc != NULL)
    {
        // We've given out a DC to the application via GetDC that
        // allows it to have GDI draw directly on the surface.
        // The problem is that we want to unmap the application's
        // view of the frame buffer -- but now we can have GDI
        // drawing to it.  So if we simply forced the unmap, GDI
        // would access violate if the DC was ever used again.
        //
        // We also can't simply delete the DC, because there may
        // be another thread already in kernel mode that has locked
        // the DC and is waiting on the devlock -- which we have.
        //
        // Note that the DC can not simply be deleted here, because
        // it may validly be in-use by another thread that has made
        // it to the kernel.  The DC deletion has to wait until
        // bDdDeleteSurfaceObject.

        if (!DxEngSetDCState(peSurface->hdc,DCSTATE_FULLSCREEN,(ULONG_PTR)TRUE))
        {
            WARNING("vDdDisableSurfaceObject: Couldn't mark DC as disabled.\n");
            ghdcCantLose = peSurface->hdc;
#if DBG_HIDEYUKN
            DbgBreakPoint();
#endif
        }
    }

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        // System-memory surfaces should only ever need to be disabled from
        // the same process in which they were created:

        if (peSurface->hSecure)
        {
            ASSERTGDI(peSurface->peDirectDrawLocal->Process
                == PsGetCurrentProcess(),
                "vDdDisableSurfaceObject: SYSMEM object disabled in wrong process");

            MmUnsecureVirtualMemory(peSurface->hSecure);

            peSurface->hSecure = NULL;
        }
    }
    else
    {
        if (peSurface->cLocks != 0)
        {
            // We're unmapping the frame buffer view while there are outstanding
            // frame buffer locks; keep track of the address for debugging
            // purposes, since the application is undoubtedly about to access-
            // violate:

            gfpUnmap = peSurface->peDirectDrawLocal->fpProcess;

        #if DBG
            DbgPrint("GDI vDdDisableSurfaceObject: Preemptively unmapping application's\n");
            DbgPrint("                             frame buffer view at 0x%lx!\n\n", gfpUnmap);
        #endif
        }

        // Remove any outstanding locks and repaint the mouse pointer:

        while (peSurface->cLocks != 0)
        {
            vDdRelinquishSurfaceOrBufferLock(peDirectDrawGlobal, peSurface);
        }

        // If this surface is the currently visible one as a result of a flip,
        // then switch back to the primary GDI surface:

        peSurfaceCurrent = peDirectDrawGlobal->peSurfaceCurrent;
        peSurfacePrimary = peDirectDrawGlobal->peSurfacePrimary;

        if ((peSurfaceCurrent == peSurface) || (peSurfacePrimary == peSurface))
        {
            // We may be in a different process from the one that created the
            // surface, so don't flip to the primary if it's a user-memory
            // allocated surface:

            if ((peSurfacePrimary != NULL) &&
                !(peSurfacePrimary->fl & DD_SURFACE_FLAG_UMEM_ALLOCATED))
            {
                ASSERTGDI((peSurfaceCurrent != NULL) && (peSurfacePrimary != NULL),
                        "Both surfaces must be non-NULL");
                ASSERTGDI(peSurfacePrimary->fl & DD_SURFACE_FLAG_PRIMARY,
                        "Primary flag is confused.");

                if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_FLIP)
                {
                    // If the current isn't the primary, then swap back to the primary:

                    if (!(peSurfaceCurrent->fl & DD_SURFACE_FLAG_PRIMARY))
                    {
                        FlipData.ddRVal     = DDERR_GENERIC;
                        FlipData.lpDD       = peDirectDrawGlobal;
                        FlipData.lpSurfCurr = peSurfaceCurrent;
                        FlipData.lpSurfTarg = peSurfacePrimary;
                        FlipData.dwFlags    = 0;
                        FlipData.lpSurfCurrLeft = NULL;
                        FlipData.lpSurfTargLeft = NULL;

                        peSurfacePrimary->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;

                        do {
                            dwRet = peDirectDrawGlobal->SurfaceCallBacks.Flip(&FlipData);

                        } while ((dwRet == DDHAL_DRIVER_HANDLED) &&
                                 (FlipData.ddRVal == DDERR_WASSTILLDRAWING));

                        ASSERTGDI((dwRet == DDHAL_DRIVER_HANDLED) &&
                                  (FlipData.ddRVal == DD_OK),
                                  "Driver failed when cleaning up flip surfaces");
                    }
                }
            }

            peDirectDrawGlobal->peSurfaceCurrent = NULL;
            peDirectDrawGlobal->peSurfacePrimary = NULL;
        }

        // Make sure the overlay is marked as hidden before it's deleted, so
        // that we don't have to rely on drivers doing it in their DestroySurface
        // routine:

        if ((peSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
            (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                DDHAL_SURFCB32_UPDATEOVERLAY)                 &&
            (peSurface->fl & DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED))
        {
            UpdateOverlayData.lpDD            = peDirectDrawGlobal;
            UpdateOverlayData.lpDDDestSurface = NULL;
            UpdateOverlayData.lpDDSrcSurface  = peSurface;
            UpdateOverlayData.dwFlags         = DDOVER_HIDE;
            UpdateOverlayData.ddRVal          = DDERR_GENERIC;

            peDirectDrawGlobal->SurfaceCallBacks.UpdateOverlay(&UpdateOverlayData);
        }

        // If we allocated user-mode memory on the driver's behalf, we'll
        // free it now.  This is complicated by the fact that we may be
        // in a different process context.

        if (peSurface->fl & DD_SURFACE_FLAG_UMEM_ALLOCATED)
        {
            ASSERTGDI(peSurface->fpVidMem != NULL, "Expected non-NULL fpVidMem");

            DDKHEAP(("DDKHEAP: Fre um %08X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->hGet(), peSurface));

            if (peSurface->fl & DD_SURFACE_FLAG_ALIAS_LOCK)
            {
                DeferMemoryFree((PVOID)peSurface->fpVidMem, peSurface);
            }
            else
            {
                SafeFreeUserMem((PVOID)peSurface->fpVidMem,  peSurface->peDirectDrawLocal->Process);
            }
            peSurface->fpVidMem = 0;
        }

        if (peSurface->fl & DD_SURFACE_FLAG_VMEM_ALLOCATED)
        {
            ASSERTGDI(peSurface->lpVidMemHeap != NULL &&
                      peSurface->lpVidMemHeap->lpHeap &&
                      peSurface->fpHeapOffset != NULL,
                      "Expected non-NULL lpVidMemHeap and fpHeapOffset");

            DDKHEAP(("DDKHEAP: Fre vm %08X, o %08X, heap %X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->fpHeapOffset,
                     peSurface->lpVidMemHeap->lpHeap,
                     peSurface->hGet(), peSurface));

            DxDdHeapVidMemFree(peSurface->lpVidMemHeap->lpHeap,
                               peSurface->fpHeapOffset);

            peSurface->lpVidMemHeap = NULL;
            peSurface->fpVidMem = 0;
            peSurface->fpHeapOffset = 0;
        }

        // Delete the driver's surface instance.  Note that we may be calling
        // here from a process different from the one in which the surface was
        // created, meaning that the driver cannot make function calls like
        // EngFreeUserMem.

        if (peSurface->fl & DD_SURFACE_FLAG_DRIVER_CREATED)
        {
            EDD_DIRECTDRAW_GLOBAL *peDdGlobalDriver;

            if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
            {
                WARNING("vDdDisableSurfaceObject: Call driver other than current."); 

                peDdGlobalDriver = peSurface->peDdGlobalCreator;
            }
            else
            {
                peDdGlobalDriver = peSurface->peDirectDrawGlobal;
            }

            DestroySurfaceData.lpDD        = peDdGlobalDriver;
            DestroySurfaceData.lpDDSurface = peSurface;

            if ((peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
                peDdGlobalDriver->D3dBufCallbacks.DestroyD3DBuffer != NULL)
            {
                dwRet = peDdGlobalDriver->
                    D3dBufCallbacks.DestroyD3DBuffer(&DestroySurfaceData);
            }
            else if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
                     (peDdGlobalDriver->SurfaceCallBacks.dwFlags &
                      DDHAL_SURFCB32_DESTROYSURFACE))
            {
                dwRet = peDdGlobalDriver->
                    SurfaceCallBacks.DestroySurface(&DestroySurfaceData);
            }

            // Drivers are supposed to return DDHAL_DRIVER_NOTHANDLED from
            // DestroySurface if they returned DDHAL_DRIVER_NOTHANDLED from
            // CreateSurface, which is the case for PLEASEALLOC_*.  We
            // munged the return code for PLEASEALLOC_* at CreateSurface
            // time; we have to munge it now, too:

            if ((dwRet == DDHAL_DRIVER_NOTHANDLED) &&
                (peSurface->fl & (DD_SURFACE_FLAG_UMEM_ALLOCATED |
                                  DD_SURFACE_FLAG_VMEM_ALLOCATED)))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
            }

            // Decrement ref count on driver if driver managed surface.

            if (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)
            {
                ASSERTGDI(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE,
                  "vDdDisableSurfaceObject: missing complete flag.");

                vDdDecrementReferenceCount(peDdGlobalDriver);
            }
        }
    }

    // Mark the surface as lost and reset some flags now for if the
    // surface gets reused:

    if (!(peSurface->bLost))
    {
        peSurface->bLost = TRUE;

        // If this surface is not lost formerly, but just lost here
        // decrement active surface ref. count.

        ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface > 0,
                  "cActiveSurface will be negative");

        peSurface->peDirectDrawLocal->cActiveSurface--;
    }

    // We used to zero the flags, but we need DD_SURFACE_FLAG_DEFER_USERMEM
    // to survive until we call DeleteSurfaceObject.
    peSurface->fl &= DD_SURFACE_FLAG_DEFER_USERMEM;

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }
}

/******************************Public*Routine******************************\
* EDD_SURFACE* peSurfaceFindAttachedMipMap
*
* Transmogrified from misc.c's FindAttachedMipMap.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline
EDD_SURFACE*
peSurfaceFindAttachedMipMap(
    EDD_SURFACE* peSurface
    )
{
    DD_ATTACHLIST*  pAttachList;
    EDD_SURFACE*    peSurfaceAttached;

    for (pAttachList = peSurface->lpAttachList;
         pAttachList != NULL;
         pAttachList = pAttachList->lpLink)
    {
        peSurfaceAttached = pedFromLp(pAttachList->lpAttached);
        if (peSurfaceAttached->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            return(peSurfaceAttached);
        }
    }
    return(NULL);
}

/******************************Public*Routine******************************\
* EDD_SURFACE* peSurfaceFindParentMipMap
*
* Transmogrified from misc.c's FindParentMipMap.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline
EDD_SURFACE*
peSurfaceFindParentMipMap(
    EDD_SURFACE* peSurface
    )
{
    DD_ATTACHLIST*  pAttachList;
    EDD_SURFACE*    peSurfaceAttached;

    for (pAttachList = peSurface->lpAttachListFrom;
         pAttachList != NULL;
         pAttachList = pAttachList->lpLink)
    {
        peSurfaceAttached = pedFromLp(pAttachList->lpAttached);
        if (peSurfaceAttached->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            return(peSurfaceAttached);
        }
    }
    return(NULL);
}

/******************************Public*Routine******************************\
* VOID vDdUpdateMipMapCount
*
* Transmogrified from ddsatch.c's UpdateMipMapCount.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdUpdateMipMapCount(
    EDD_SURFACE*    peSurface
    )
{
    EDD_SURFACE*    peSurfaceParent;
    DWORD           dwLevels;

    DD_ASSERTDEVLOCK(peSurface->peDirectDrawGlobal);

    // Find the top most level mip-map in the chain:

    peSurfaceParent = peSurface;
    while (peSurfaceParent != NULL)
    {
        peSurface = peSurfaceParent;
        peSurfaceParent = peSurfaceFindParentMipMap(peSurface);
    }
    peSurfaceParent = peSurface;

    // We have the top-most level in the mip-map chain.  Now count the
    // levels in the chain:

    dwLevels = 0;
    while (peSurface != NULL)
    {
        dwLevels++;
        peSurface = peSurfaceFindAttachedMipMap(peSurface);
    }

    // Now update all the levels with their new mip-map count:

    peSurface = peSurfaceParent;
    while (peSurface != NULL)
    {
        peSurface->dwMipMapCount = dwLevels;
        dwLevels--;
        peSurface = peSurfaceFindAttachedMipMap(peSurface);
    }

    ASSERTGDI(dwLevels == 0, "Unexpected ending surface count");
}

/******************************Public*Routine******************************\
* BOOL bDdRemoveAttachedSurface
*
* Transmogrified from ddsatch.c's DeleteOneLink.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdRemoveAttachedSurface(
    EDD_SURFACE*    peSurface,
    EDD_SURFACE*    peSurfaceAttached
    )
{
    BOOL                bRet = FALSE;
    DD_ATTACHLIST*      pAttachCurrent;
    DD_ATTACHLIST*      pAttachLast;

    // See if specified surface is attached:

    pAttachCurrent = peSurface->lpAttachList;
    pAttachLast = NULL;
    while (pAttachCurrent != NULL)
    {
        if (pAttachCurrent->lpAttached == peSurfaceAttached)
            break;

        pAttachLast = pAttachCurrent;
        pAttachCurrent = pAttachCurrent->lpLink;
    }
    if (pAttachCurrent != NULL)
    {
        // Delete the attached-from link:

        if (pAttachLast == NULL)
        {
            peSurface->lpAttachList = pAttachCurrent->lpLink;
        }
        else
        {
            pAttachLast->lpLink = pAttachCurrent->lpLink;
        }
        VFREEMEM(pAttachCurrent);

        // Remove the attached-to link:

        pAttachCurrent = peSurfaceAttached->lpAttachListFrom;
        pAttachLast = NULL;
        while (pAttachCurrent != NULL)
        {
            if (pAttachCurrent->lpAttached == peSurface)
                break;

            pAttachLast = pAttachCurrent;
            pAttachCurrent = pAttachCurrent->lpLink;
        }

        // Delete the attached-to link:

        if (pAttachLast == NULL)
        {
            peSurfaceAttached->lpAttachListFrom = pAttachCurrent->lpLink;
        }
        else
        {
            pAttachLast->lpLink = pAttachCurrent->lpLink;
        }
        VFREEMEM(pAttachCurrent);

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDdDeleteReferringAttachments
*
* This surface is being deleted.  Remove any attachments to or from other
* surfaces.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDeleteReferringAttachments(
    EDD_SURFACE*    peSurface
    )
{
    DD_ATTACHLIST*  pAttachList;
    EDD_SURFACE*    peSurfaceAttachedTo;
    EDD_SURFACE*    peSurfaceAttachedFrom;
    BOOL            b;

    while (peSurface->lpAttachList != NULL)
    {
        peSurfaceAttachedTo
            = pedFromLp(peSurface->lpAttachList->lpAttached);

        b = bDdRemoveAttachedSurface(peSurface, peSurfaceAttachedTo);
        vDdUpdateMipMapCount(peSurfaceAttachedTo);

        ASSERTGDI(b, "Unexpected bDdRemoveAttachedSurface failure\n");
    }

    while (peSurface->lpAttachListFrom != NULL)
    {
        peSurfaceAttachedFrom
            = pedFromLp(peSurface->lpAttachListFrom->lpAttached);

        b = bDdRemoveAttachedSurface(peSurfaceAttachedFrom, peSurface);
        vDdUpdateMipMapCount(peSurfaceAttachedFrom);

        ASSERTGDI(b, "Unexpected bDdRemoveAttachedSurface failure\n");
    }
}

/******************************Public*Routine******************************\
* void vDdReleaseVirtualMap
*
* Released the reference a surface has on a VMEMMAPPING structure
*
*  28-Oct-1998 -by- Anuj Gosalia [anujg]
* Wrote it.
\**************************************************************************/

void vDdReleaseVirtualMap(EDD_SURFACE* peSurface)
{
    EDD_DIRECTDRAW_GLOBAL*  peVirtualMapDdGlobal;

    // Hold share to prevent video mode change.
    {
        EDD_SHARELOCK eShareLock(TRUE);

        peVirtualMapDdGlobal = peSurface->peVirtualMapDdGlobal;

        DDKHEAP(("vDdReleaseVirtualMap: peSurface=%lx, "
                "peVirtualMapDdGlobal=%lx, peDirectDrawGlobal=%lx\n",
                peSurface, peVirtualMapDdGlobal,
                peSurface->peDirectDrawGlobal));

        // See peVirtualMapDdGlobal is still present, since
        // video mode change occured before locking share
        // lock at above, this will be null by mode change thread.

        if (peVirtualMapDdGlobal)
        {
            EDD_DEVLOCK eDevlock(peVirtualMapDdGlobal);

            vDdUnreferenceVirtualMap(peSurface->peMap,
                                     peVirtualMapDdGlobal,
                                     peSurface->peDirectDrawLocal,
                                     NtCurrentProcess(),
                                     FALSE);

            peSurface->peMap = NULL;
            peSurface->peVirtualMapDdGlobal = NULL;
        }
    }

    if (peVirtualMapDdGlobal)
    {
        // Decrement the the driver instance
        // Note: To free the driver instance we must not be holding the devlock:

        vDdDecrementReferenceCount(peVirtualMapDdGlobal);
    }
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteSurfaceObject
*
* Deletes and frees a kernel-mode representation of the surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteSurfaceObject(
    HANDLE  hSurface,
    DWORD*  pdwRet          // For returning driver return code, may be NULL
    )
{
    BOOL                    bRet;
    EDD_SURFACE*            peSurface;
    EDD_SURFACE*            peTmp;
    VOID*                   pvRemove;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwRet;

    bRet = FALSE;
    dwRet = DDHAL_DRIVER_NOTHANDLED;

    peSurface = (EDD_SURFACE*) DdHmgLock((HDD_OBJ) hSurface, DD_SURFACE_TYPE, FALSE);

    if (peSurface != NULL)
    {
        PDEVOBJ poSurface;
        PDEVOBJ poMapping;
        BOOL    bUnrefMappingPdev = FALSE;

        peDirectDrawLocal  = peSurface->peDirectDrawLocal;
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        {
            EDD_SHAREDEVLOCK eDevLock(peDirectDrawGlobal);

            // Prevent from deleting GDI's PDEV if this is last Virtual map refer it.
            // We still need GDI's PDEV in order to call driver just below. so we
            //  -UN-reference it after we finish with driver.

            poSurface.vInit(peDirectDrawGlobal->hdev);
            poSurface.vReferencePdev();

            // If we have "aliased" video memory mapping, take ref count on the owner
            // of its mapping if it's different from current surface owner (due to video
            // mode change)

            if (peSurface->peMap)
            {
                // PDEVOBJ for owner of mapping

                poMapping.vInit(peSurface->peVirtualMapDdGlobal->hdev);

                // Is it different from current surface owner ?
 
                if (poMapping.bValid() &&
                    (poMapping.hdev() != poSurface.hdev()))
                {
                    poMapping.vReferencePdev();
                    bUnrefMappingPdev = TRUE;
                }
            }

            // Note that 'bDdReleaseDC' and 'bDeleteSurface' may fail if
            // another thread of the application is in the kernel using that
            // DC.  This can occur only if we're not currently doing the
            // process cleanup code (because process cleanup ensures that
            // only one thread from the process is still running).  It's okay,
            // because process-termination cleanup for the DC object itself
            // will take care of cleanup.

            if (peSurface->hdc)
            {
                // Note that any locks on behalf of the GetDC are taken care
                // of in 'vDdDisableSurfaceObject'.

                if (!bDdReleaseDC(peSurface, TRUE))
                {
                    WARNING("bDdDeleteSurfaceObject: Couldn't release DC\n");
                }
            }

            if (peSurface->hbmGdi)
            {
                // Delete the actual bitmap surface.  We are doing this from
                // the owning processes thread.

                DxEngDeleteSurface((HSURF) peSurface->hbmGdi);
                peSurface->hbmGdi = NULL;

                if (peSurface->hpalGdi)
                {
                    EngDeletePalette(peSurface->hpalGdi);
                    peSurface->hpalGdi = NULL;
                }
            }

            DDKSURF(("DDKSURF: Removing %X (%X)\n", hSurface, peSurface));

            pvRemove = DdHmgRemoveObject((HDD_OBJ) hSurface,
                                     DdHmgQueryLock((HDD_OBJ) hSurface),
                                     0,
                                     TRUE,
                                     DD_SURFACE_TYPE);

            ASSERTGDI(pvRemove != NULL, "Outstanding surfaces locks");

            // Remove any attachments:

            vDdDeleteReferringAttachments(peSurface);

            // Uncompleted surfaces are marked as 'lost' until they're completed,
            // but we still have to call the driver if that's the case:

            if (!(peSurface->bLost) ||
                !(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE))
            {
                vDdDisableSurfaceObject(peDirectDrawGlobal, peSurface, &dwRet);
            }

            if (peSurface->peMap)
            {
                vDdReleaseVirtualMap(peSurface);
            }

            // Remove from the surface linked-list:

            RemoveEntryList(&(peSurface->List_eSurface));

            // Decrement number of surface in DirectDrawLocal.

            peDirectDrawLocal->cSurface--;

            // The surface object is about to be freed, call CreateSurfaceEx, to
            // inform the driver to disassociate the cookie if the driver can

            if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
                && (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                && (peSurface->pGraphicsDeviceCreator == poSurface.pGraphicsDevice())
                && (0 != peSurface->dwSurfaceHandle)
               )
            {
                DD_CREATESURFACEEXDATA CreateSurfaceExData;
                ASSERTGDI(NULL==peSurface->hSecure,
                    "bDdDeleteSurfaceObject: SYSMEM object not unsecured upon delete");
                peSurface->fpVidMem = NULL;
                CreateSurfaceExData.ddRVal          = DDERR_GENERIC;
                CreateSurfaceExData.dwFlags         = 0;
                CreateSurfaceExData.lpDDLcl         = peDirectDrawLocal;
                CreateSurfaceExData.lpDDSLcl        = peSurface;
                // just notify driver that this system memory surface has been freed
                peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);

            }

            // If the surface has some outstanding system memory that needs
            // to be freed, now's the time to do it.

            if (peSurface->fl & DD_SURFACE_FLAG_DEFER_USERMEM)
            {
                DD_USERMEM_DEFER* pDefer = peDirectDrawGlobal->pUserMemDefer;
                DD_USERMEM_DEFER* pLast = NULL;
                DD_USERMEM_DEFER* pDeferTemp;

                while (pDefer != NULL)
                {
                    pDeferTemp = pDefer;
                    pDefer = pDefer->pNext;
                    if (pDeferTemp->peSurface == peSurface)
                    {
                        SafeFreeUserMem(pDeferTemp->pUserMem, peDirectDrawLocal->Process);

                        if (pLast == NULL)
                        {
                            peDirectDrawGlobal->pUserMemDefer = pDefer;
                        }
                        else
                        {
                            pLast->pNext = pDefer;
                        }
                        VFREEMEM(pDeferTemp);
                    }
                    else
                    {
                        pLast = pDeferTemp;
                    }
                }
            }

            // We're all done with this object, so free the memory and
            // leave:

            DdFreeObject(peSurface, DD_SURFACE_TYPE);
        }

        // Now, we've done. release GDI's PDEV if this is last one.

        if (bUnrefMappingPdev)
        {
            poMapping.vUnreferencePdev();
        }

        poSurface.vUnreferencePdev();

        bRet = TRUE;
    }
    else
    {
        WARNING1("bDdDeleteSurfaceObject: Bad handle or object was busy\n");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDdDisableAllDirectDrawObjects
*
* Temporarily disables all DirectDraw surfaces and local objects.
*
* NOTE: Caller must be holding User critical section.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableAllDirectDrawObjects(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_SURFACE*            peSurface;
    NTSTATUS                status;

    DD_ASSERTSHAREDEVLOCK();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    // We may have to wait the standard 7 seconds for any locks to be
    // released before we go ahead and let the mode change happen.  We
    // do this only when cDirectDrawDisableLocks() == 1 to allow the
    // HDEV to be disabled recursively (i.e., this routine is re-entrant).

    peDirectDrawGlobal->bSuspended = TRUE;

    if (peDirectDrawGlobal->cSurfaceLocks >
        peDirectDrawGlobal->cSurfaceAliasedLocks)
    {
        // Release the devlock while waiting on the event:

        DxEngUnlockHdev(po.hdev());

        status = KeWaitForSingleObject(peDirectDrawGlobal->pAssertModeEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       (LARGE_INTEGER*) &peDirectDrawGlobal->
                                            llAssertModeTimeout);

        ASSERTGDI(NT_SUCCESS(status), "Wait error\n");

        DxEngLockHdev(po.hdev());

        // Now that we have the devlock, reset the event to not-signaled
        // for the next time we have to wait on someone's DirectDraw Lock
        // (someone may have signaled the event after the time-out, but
        // before we managed to acquire the devlock):

        KeResetEvent(peDirectDrawGlobal->pAssertModeEvent);
    }

    // Mark all surfaces associated with this device as lost and unmap all
    // views of the frame buffer:

    for (peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
         peDirectDrawLocal != NULL;
         peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext)
    {
        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

        while (peSurface)
        {
            if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
            {
                // Lost video memory surface.

                if((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                    !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
                {
                    vDdLooseManagedSurfaceObject(peDirectDrawGlobal,
                                                 peSurface,
                                                 NULL);
                }
                else
                {
                    vDdDisableSurfaceObject(peDirectDrawGlobal,
                                            peSurface,
                                            NULL);
                }
            }
            else if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
                      && (peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice())
                      && (0 != peSurface->dwSurfaceHandle))
            {
                // Disassociate this system memory surface from driver.

                DD_CREATESURFACEEXDATA CreateSurfaceExData;
                FLATPTR                fpVidMem = peSurface->fpVidMem; // keep backup
                PDD_ATTACHLIST     lpAttachList = peSurface->lpAttachList; // keep backup
                PDD_ATTACHLIST lpAttachListFrom = peSurface->lpAttachListFrom; // keep backup
                peSurface->fpVidMem             = NULL;
                peSurface->lpAttachList         = NULL;
                peSurface->lpAttachListFrom     = NULL;
                CreateSurfaceExData.ddRVal      = DDERR_GENERIC;
                CreateSurfaceExData.dwFlags     = 0;
                CreateSurfaceExData.lpDDLcl     = peDirectDrawLocal;
                CreateSurfaceExData.lpDDSLcl    = peSurface;
                peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
                peSurface->fpVidMem             = fpVidMem; // restore backup
                peSurface->lpAttachList         = lpAttachList; // restore backup
                peSurface->lpAttachListFrom     = lpAttachListFrom; // restore backup

                // workaround for smidisp.dll and just in case driver didn't clear-out dwReserved1

                if (((DD_SURFACE_GLOBAL *)peSurface)->dwReserved1)
                {
                    WARNING("Driver forget to clear SURFACE_GBL.dwReserved1 at CreateSurfaceEx()");
                }
                if (((DD_SURFACE_LOCAL *)peSurface)->dwReserved1)
                {
                    WARNING("Driver forget to clear SURFACE_LCL.dwReserved1 at CreateSurfaceEx()");
                }

                ((DD_SURFACE_GLOBAL *)peSurface)->dwReserved1 = 0;
                ((DD_SURFACE_LOCAL *)peSurface)->dwReserved1 = 0;
            }

            peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
        }

        vDdDisableDirectDrawObject(peDirectDrawLocal);
    }

    ASSERTGDI(peDirectDrawGlobal->cSurfaceLocks == 0,
        "There was a mismatch between global count of locks and actual");
}

/******************************Public*Routine******************************\
* BOOL DxDdGetDirectDrawBounds
*
* Gets the accumulated blt access rectangle to the primary surface. Returns
* FALSE if a DirectDraw blt to the primary has not occurred.
*
*  4-Nov-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

BOOL
DxDdGetDirectDrawBounds(
    HDEV    hdev,
    RECT*   prcBounds
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    PDEVOBJ po(hdev);

    peDirectDrawGlobal = po.peDirectDrawGlobal();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    if (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_BOUNDS_SET)
    {
        // Return the bounds rectangle and reset the bounds flag:

        *((RECTL*) prcBounds) = peDirectDrawGlobal->rclBounds;
        peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_BOUNDS_SET;

        return TRUE;
    }

    return FALSE;
}

/******************************Public*Routine******************************\
* VOID vDdRestoreSystemMemorySurface
*
* Reassociate dwSurfaceHandle to kernel surface by calling driver's CreateSurfaceEx
*
*  2-May-2002 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID
vDdRestoreSystemMemorySurface(
    HDEV hdev
    )
{
    PDEVOBJ                po(hdev);
    EDD_DIRECTDRAW_GLOBAL *peDirectDrawGlobal = po.peDirectDrawGlobal();

    // Reassociate system memory surface to driver (which disassociated by ResumeDirectDraw)

    if (peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
    {
        for (EDD_DIRECTDRAW_LOCAL *peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
             peDirectDrawLocal != NULL;
             peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext)
        {
            EDD_SURFACE *peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

            while (peSurface)
            {
                if ((peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                     && (peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice())
                     && (0 != peSurface->dwSurfaceHandle)
                     && (peSurface->ddpfSurface.dwFlags & DDPF_FOURCC))
                {
                    switch (peSurface->ddpfSurface.dwFourCC)
                    {
                        case FOURCC_DXT1:
                        case FOURCC_DXT2:
                        case FOURCC_DXT3:
                        case FOURCC_DXT4:
                        case FOURCC_DXT5:
                            peSurface->wWidth = peSurface->wWidthOriginal;
                            peSurface->wHeight = peSurface->wHeightOriginal;
                    }
                }

                peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
            }

            KeAttachProcess(PsGetProcessPcb(peDirectDrawLocal->Process));

            peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

            while (peSurface)
            {
                // Only restore when this system memory surface previously
                // called to this driver and we called CreateSurfaceEx.

                if ((peSurface->fl & DD_SURFACE_FLAG_SYSMEM_CREATESURFACEEX)
                     && (peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice()))
                {
                    DD_CREATESURFACEEXDATA CreateSurfaceExData;

                    ASSERTGDI(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY,
                              "DXG:ResumeDirectDraw: no system memory flag");
                    ASSERTGDI(peSurface->dwSurfaceHandle != 0,
                              "DXG:ResumeDirectDraw: dwSurfaceHandle is 0");

                    CreateSurfaceExData.dwFlags        = 0;
                    CreateSurfaceExData.ddRVal         = DDERR_GENERIC;
                    CreateSurfaceExData.lpDDLcl        = peDirectDrawLocal;
                    CreateSurfaceExData.lpDDSLcl       = peSurface;
                    po.peDirectDrawGlobal()->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);

                    if (CreateSurfaceExData.ddRVal != DD_OK)
                    {
                        WARNING("DxDdResumeDirectDraw(): Reassociate system memory surface failed");
                    }
                }

                peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
            }

            KeDetachProcess();
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxDdSuspendDirectDraw
*
* Temporarily disables DirectDraw for the specified device.
*
* NOTE: Caller must be holding User critical section.
*
* NOTE: Caller must NOT be holding devlock, unless DirectDraw is already
*       disabled.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdSuspendDirectDraw(
    HDEV    hdev,
    ULONG   fl
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    LONG*                   pl;
    HDEV                    hdevCurrent;
    BOOL                    bChildren = (fl & DXG_SR_DDRAW_CHILDREN);

    // Bump the mode uniqueness to let user-mode DirectDraw know that
    // someone else has done a mode change.  (Full-screen switches count as
    // full-screen, too).  Do it interlocked because we're not holding a
    // global lock:

    INC_DISPLAY_UNIQUENESS();

    // If bChildren is TRUE, make sure we've really got a meta driver:

    if (bChildren)
    {
        PDEVOBJ po(hdev);
        ASSERTGDI(po.bValid() && po.bDisplayPDEV(), "Invalid HDEV");

        bChildren = po.bMetaDriver();
    }

    hdevCurrent = bChildren ? DxEngEnumerateHdev(NULL) : hdev;

    do
    {
        PDEVOBJ po(hdevCurrent);
        ASSERTGDI(po.bValid(), "Invalid HDEV");
        ASSERTGDI(po.bDisplayPDEV(), "Not a display HDEV");

        if (!bChildren || (po.hdevParent() == hdev))
        {
            peDirectDrawGlobal = po.peDirectDrawGlobal();

            EDD_SHARELOCK eShareLock(FALSE);

            if (fl & DXG_SR_DDRAW_MODECHANGE)
            {
                // ShareLock must be held by caller for video mode change.

                DD_ASSERTSHAREDEVLOCK();

                // We need to completely release the devlock soon, so we must not
                // be called with the devlock already held.  If we don't do this,
                // any thread calling Unlock will be locked out until the timeout.

                DD_ASSERTNODEVLOCK(peDirectDrawGlobal);
            }
            else
            {
                eShareLock.vLock();
            }

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            ASSERTGDI(peDirectDrawGlobal->hdev != NULL,
                "Can't suspend DirectDraw on an HDEV that was never DDraw enabled!");

            if (po.cDirectDrawDisableLocks() == 0)
            {
                // Notify any kernel-mode DXAPI clients that have hooked the
                // relevant event:

                vDdNotifyEvent(peDirectDrawGlobal, DDEVENT_PREDOSBOX);

                // Disable all DirectDraw object.

                vDdDisableAllDirectDrawObjects(peDirectDrawGlobal);
            }

            // Increment the disable lock-count event if a DirectDraw global
            // object hasn't been created:

            po.cDirectDrawDisableLocks(po.cDirectDrawDisableLocks() + 1);
        }

        if (bChildren)
        {
            hdevCurrent = DxEngEnumerateHdev(hdevCurrent);
        }

    } while (bChildren && hdevCurrent);
}

/******************************Public*Routine******************************\
* VOID DxDdResumeDirectDraw
*
* Permits DirectDraw to be reenabled for the specified device.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdResumeDirectDraw(
    HDEV    hdev,
    ULONG   fl
    )
{
    LONG*   pl;
    HDEV    hdevCurrent;
    BOOL    bChildren = fl & DXG_SR_DDRAW_CHILDREN;

    // Bump the mode uniqueness again.  We do this both before and after
    // the mode change actually occurs to give DirectDraw proper
    // notification.  If kernel-mode starts failing DdBlt calls because
    // the mode has changed, this implies that we have to let DirectDraw
    // know before the mode change occurs; but if we let DirectDraw know
    // only before the mode change occurs, it might re-enable us before
    // the new mode is actually set, so we also have to let it know after
    // the mode change has occured.

    INC_DISPLAY_UNIQUENESS();

    // If bChildren is TRUE, make sure we've really got a meta driver:

    if (bChildren)
    {
        PDEVOBJ po(hdev);
        ASSERTGDI(po.bValid() && po.bDisplayPDEV(), "Invalid HDEV");

        bChildren = po.bMetaDriver();
    }

    hdevCurrent = bChildren ? DxEngEnumerateHdev(NULL) : hdev;

    do
    {
        PDEVOBJ po(hdevCurrent);
        ASSERTGDI(po.bValid(), "Invalid HDEV");
        ASSERTGDI(po.bDisplayPDEV(), "Not a display HDEV");

        if (!bChildren || (po.hdevParent() == hdev))
        {
            // Decrement the disable lock-count even if a DirectDraw global object
            // hasn't been created:

            EDD_DEVLOCK eDevlock(po.hdev());

            ASSERTGDI(po.cDirectDrawDisableLocks() != 0,
                "Must have called disable previously to be able to enable DirectDraw.");

            po.cDirectDrawDisableLocks(po.cDirectDrawDisableLocks() - 1);

            if (po.cDirectDrawDisableLocks() == 0)
            {
                // Notify any kernel-mode DXAPI clients that have hooked the relevant
                // event.  Note that thie mode change is done, but DirectDraw is still
                // in a suspended state. [Is that a problem?]

                vDdNotifyEvent(po.peDirectDrawGlobal(), DDEVENT_POSTDOSBOX);

                // Reassociate system memory surface if needed.

                vDdRestoreSystemMemorySurface(po.hdev());
            }
        }

        if (bChildren)
        {
            hdevCurrent = DxEngEnumerateHdev(hdevCurrent);
        }

    } while (bChildren && hdevCurrent);
}

/******************************Public*Routine******************************\
* VOID DxDdDynamicModeChange
*
* Transfers DirectDraw driver instances between two PDEVs.
*
* The devlock and handle manager semaphore must be held to call this function!
*
* NOTE: This is the last step that should be taken in the dynamic mode
*       change process, so that in this routine we can assume that the
*       call tables and the like for the respective HDEVs have already
*       been swapped.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew,
    ULONG   fl
    )
{
    DD_DIRECTDRAW_GLOBAL_DRIVER_DATA    GlobalDriverDataSwap;
    EDD_DIRECTDRAW_GLOBAL*              peDirectDrawGlobalOld;
    EDD_DIRECTDRAW_GLOBAL*              peDirectDrawGlobalNew;
    D3DNTHAL_OBJECT*                    pdhobj;
    EDD_SURFACE*                        peSurface;
    HDD_OBJ                             hobj;
    LONG                                cReferencesOld;
    LONG                                cReferencesNew;
    LONG                                cAdjustOld;
    LONG                                cAdjustNew;
    FLONG                               flOld;
    FLONG                               flNew;
    LPDDVIDEOPORTCAPS                   lpDDVideoPortCaps;
    DWORD                               dwHeap;
    VIDEOMEMORY*                        pHeap;
    DWORD                               dwHeapNew;
    VIDEOMEMORY*                        pHeapNew;
    BOOL                                bSwappedAGP;

    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);

    peDirectDrawGlobalOld = poOld.peDirectDrawGlobal();
    peDirectDrawGlobalNew = poNew.peDirectDrawGlobal();

    DDKHEAP(("peDDGOld=%lx, cDriverReferences=%d\n",
             peDirectDrawGlobalOld, peDirectDrawGlobalOld->cDriverReferences));
    DDKHEAP(("peDDGNew=%lx, cDriverReferences=%d\n",
             peDirectDrawGlobalNew, peDirectDrawGlobalNew->cDriverReferences));

    // Notify any kernel-mode DXAPI clients that have hooked the relevant
    // events.

    vDdNotifyEvent(peDirectDrawGlobalOld, DDEVENT_PRERESCHANGE);
    vDdNotifyEvent(peDirectDrawGlobalOld, DDEVENT_POSTRESCHANGE);
    vDdNotifyEvent(peDirectDrawGlobalNew, DDEVENT_PRERESCHANGE);
    vDdNotifyEvent(peDirectDrawGlobalNew, DDEVENT_POSTRESCHANGE);

    // The DD_GLOBAL_FLAG_DRIVER_ENABLED flag transfers to the new PDEV
    // along with the driver instance:

    flOld = peDirectDrawGlobalOld->fl;
    flNew = peDirectDrawGlobalNew->fl;

    peDirectDrawGlobalOld->fl         = (flOld & ~DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (flNew & DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (DD_GLOBAL_FLAG_MODE_CHANGED);
    peDirectDrawGlobalOld->bSuspended = TRUE;
    peDirectDrawGlobalOld->dhpdev     = poOld.dhpdev();
    peDirectDrawGlobalOld->hdev       = poOld.hdev();

    peDirectDrawGlobalNew->fl         = (flNew & ~DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (flOld & DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (DD_GLOBAL_FLAG_MODE_CHANGED);
    peDirectDrawGlobalNew->bSuspended = TRUE;
    peDirectDrawGlobalNew->dhpdev     = poNew.dhpdev();
    peDirectDrawGlobalNew->hdev       = poNew.hdev();

    // Transfer heap AGP 'handles':
    //
    // since AGP handle stay with its driver instance.

    pHeap = peDirectDrawGlobalOld->pvmList;
    for (dwHeap = 0;
         dwHeap < peDirectDrawGlobalOld->dwNumHeaps;
         pHeap++, dwHeap++)
    {
        if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
            !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
            (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            (pHeap->lpHeap != NULL) &&
            (pHeap->lpHeap->hdevAGP == AGP_HDEV(peDirectDrawGlobalOld)))
        {
            pHeap->lpHeap->hdevAGP = AGP_HDEV(peDirectDrawGlobalNew);
        }
    }

    pHeap = peDirectDrawGlobalNew->pvmList;
    for (dwHeap = 0;
         dwHeap < peDirectDrawGlobalNew->dwNumHeaps;
         pHeap++, dwHeap++)
    {
        if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
            !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
            (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            (pHeap->lpHeap != NULL) &&
            (pHeap->lpHeap->hdevAGP == AGP_HDEV(peDirectDrawGlobalNew)))
        {
            pHeap->lpHeap->hdevAGP = AGP_HDEV(peDirectDrawGlobalOld);
        }
    }

    // DirectDraw objects and surfaces stay with the PDEV, but driver
    // instances are swapped:

    RtlCopyMemory(&GlobalDriverDataSwap,
                  (DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalOld,
                  sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));

    RtlCopyMemory((DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalOld,
                  (DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalNew,
                  sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));

    RtlCopyMemory((DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalNew,
                  &GlobalDriverDataSwap,
                  sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));

    // If the old object had an initialized AGP heap, make sure that it stays 
    // with the old object (swap it back).  We only want to do this if it's
    // not a one-to-many or many-to-one mode change, however.

    bSwappedAGP = FALSE;
    if (!poNew.bMetaDriver() && 
        !poOld.bMetaDriver() &&
        (poNew.pldev() == poOld.pldev()))
    {
        pHeap = peDirectDrawGlobalOld->pvmList;
        for (dwHeap = 0;
             dwHeap < peDirectDrawGlobalOld->dwNumHeaps;
             pHeap++, dwHeap++)
        {
            if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
                !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
                (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
                (pHeap->lpHeap != NULL) &&
                (pHeap->lpHeap->pvPhysRsrv == NULL))
            {
                // The old object has a heap, find the corresponding heap in the
                // new object.

                pHeapNew = peDirectDrawGlobalNew->pvmList;
                for (dwHeapNew = 0;
                     dwHeapNew < peDirectDrawGlobalNew->dwNumHeaps;
                     pHeapNew++, dwHeapNew++)
                {   
                    if ((pHeapNew->dwFlags == pHeap->dwFlags) &&
                        (pHeapNew->lpHeap != NULL) &&
                        (pHeapNew->lpHeap->pvPhysRsrv != NULL))
                    {
                        SwapHeaps( pHeap, pHeapNew );

                        // We used to tear down the heap and create a new one
                        // with each mode change, but now we keep the one heap 
                        // active acrross mode changes.  This means that we don't
                        // need to notify the driver the driver of the heap change,
                        // but this is a behavior change and some drivers depend
                        // on this notification so we'll do it anyway.

                        UpdateNonLocalHeap( peDirectDrawGlobalOld, dwHeap );
                        bSwappedAGP = TRUE;
                    }
                }
            }
        }
    }

    // Also swap video port caps, which are part of the DIRETCDRAW_GLOBAL

    lpDDVideoPortCaps = peDirectDrawGlobalOld->lpDDVideoPortCaps;
    peDirectDrawGlobalOld->lpDDVideoPortCaps = peDirectDrawGlobalNew->lpDDVideoPortCaps;
    peDirectDrawGlobalNew->lpDDVideoPortCaps = lpDDVideoPortCaps;

    cReferencesNew = 0;
    cReferencesOld = 0;
    cAdjustNew = 0;
    cAdjustOld = 0;

    // Transfer ownership of any Direct3D objects to its new PDEV:
    //
    // since it stay with its driver instance.

    DdHmgAcquireHmgrSemaphore();

    hobj = 0;
    while (pdhobj = (D3DNTHAL_OBJECT*) DdHmgNextObjt(hobj, D3D_HANDLE_TYPE))
    {
        hobj = (HDD_OBJ) pdhobj->hGet();

        if (pdhobj->peDdGlobal == peDirectDrawGlobalOld)
        {
            pdhobj->peDdGlobal = peDirectDrawGlobalNew;
            cReferencesNew++;
        }
        else if (pdhobj->peDdGlobal == peDirectDrawGlobalNew)
        {
            pdhobj->peDdGlobal = peDirectDrawGlobalOld;
            cReferencesOld++;
        }
    }

    hobj = 0;
    while (peSurface = (EDD_SURFACE*) DdHmgNextObjt(hobj, DD_SURFACE_TYPE))
    {
        hobj = (HDD_OBJ) peSurface->hGet();

        // Transfer VMEMMAPPING structures
        //
        // since it stay with its driver instance.  We do not switch these
        // for AGP surfaces since we no longer switch the AGP heaps.

        if (peSurface->peVirtualMapDdGlobal == peDirectDrawGlobalOld)
        {
            DDKHEAP(("vDdDynamicModeChange: %x->%x matches old global\n",
                     peSurface, peSurface->peVirtualMapDdGlobal));

            if ((peSurface->peMap != NULL) &&
                (peSurface->peMap->fl & DD_VMEMMAPPING_FLAG_AGP) &&
                bSwappedAGP)
            {
                cAdjustOld++;
            }
            else
            {
                peSurface->peVirtualMapDdGlobal = peDirectDrawGlobalNew;
                cReferencesNew++;
            }
        }
        else if (peSurface->peVirtualMapDdGlobal == peDirectDrawGlobalNew)
        {
            DDKHEAP(("vDdDynamicModeChange: %x->%x matches new global\n",
                     peSurface, peSurface->peVirtualMapDdGlobal));
            if ((peSurface->peMap != NULL) &&
                (peSurface->peMap->fl & DD_VMEMMAPPING_FLAG_AGP) &&
                bSwappedAGP)
            {
                cAdjustNew++;
            }
            else
            {
                peSurface->peVirtualMapDdGlobal = peDirectDrawGlobalOld;
                cReferencesOld++;
            }
        }

        // If surface is "driver managed"...
        //
        // driver managed surface will stay with its driver instance.

        if (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)
        {
            // And if we are doing mode change across "different" video drivers
            // mark wrong driver flag while it live in there until go back
            // to original creator driver.
            //
            // And peDdGlobalCreator should go with driver instance.

            // If video mode change happen with same driver, surface with just stay where it is.

            if (poOld.pldev() == poNew.pldev())
            {
                // Driver reference has been swapped, but this surface will continue to
                // stick with same, so need adjust it (= transfer back).

                if (peSurface->peDdGlobalCreator == peDirectDrawGlobalOld)
                {
                    if (!(peSurface->bLost))
                    {
                        cAdjustOld++;
                    }

                #if DBG_HIDEYUKN
                    KdPrint(("DXG: same pldev, stay with old\n"));
                #endif
                }
                else if (peSurface->peDdGlobalCreator == peDirectDrawGlobalNew)
                {
                    if (!(peSurface->bLost))
                    {
                        cAdjustNew++;
                    }

                #if DBG_HIDEYUKN
                    KdPrint(("DXG: same pldev, stay with new\n"));
                #endif
                }
            }
            else // if (poOld.pldev() != poNew.poNew())
            {
                if (peSurface->peDdGlobalCreator == peDirectDrawGlobalOld)
                {
                    // This surface is currently associated to old driver
                    // (= where actually will be new after swap)

                    // Transfer the surface to new (where it will be Old).

                    peSurface->peDdGlobalCreator = peDirectDrawGlobalNew;

                    if (peSurface->peDdGlobalCreator == peSurface->peDirectDrawGlobal)
                    {
                        peSurface->fl &= ~DD_SURFACE_FLAG_WRONG_DRIVER;

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to new, clear wrong driver\n"));
                    #endif
                    }
                    else
                    {
                        peSurface->fl |= DD_SURFACE_FLAG_WRONG_DRIVER; 

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to new, set wrong driver\n"));
                    #endif
                    }

                    // Driver reference count has been swapped already in above. so new DdGlobal
                    // already has reference for this surface. Increment this for later verification.

                    if (!(peSurface->bLost))
                    {
                        cReferencesNew++;
                    }
                }
                else if (peSurface->peDdGlobalCreator == peDirectDrawGlobalNew)
                {
                    // This surface is currently associated to new (where it will be old after swap)

                    // Transfer the surface to old (where it will be new).

                    peSurface->peDdGlobalCreator = peDirectDrawGlobalOld;

                    if (peSurface->peDdGlobalCreator == peSurface->peDirectDrawGlobal)
                    {
                        peSurface->fl &= ~DD_SURFACE_FLAG_WRONG_DRIVER;

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to old, clear wrong driver\n"));
                    #endif
                    }
                    else
                    {
                        peSurface->fl |= DD_SURFACE_FLAG_WRONG_DRIVER;

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to old, set wrong driver\n"));
                    #endif
                    }

                    // if surface is not losted, make sure reference is stay with old driver
                    // (this is for later assertion).

                    if (!(peSurface->bLost))
                    {
                        cReferencesOld++;
                    }
                }
            }
        }
    }

    DdHmgReleaseHmgrSemaphore();

#if DBG_HIDEYUKN
    KdPrint(("DXG:Reference Counts BEFORE Adjust\n"));
    KdPrint(("DXG:DdGlobalOld->cDriverReference (%d) = cReferencesOld (%d) + cAdjustNew (%d)\n",
              peDirectDrawGlobalOld->cDriverReferences,cReferencesOld,cAdjustNew));
    KdPrint(("DXG:DdGlobalNew->cDriverReference (%d) = cReferencesNew (%d) + cAdjustOld (%d)\n",
              peDirectDrawGlobalNew->cDriverReferences,cReferencesNew,cAdjustOld));
#endif

    // We used to transfer all of the surfaces from the old PDEV to the new
    // one, but now we only do that for the non-agp surfaces, which means that
    // we need to adjust the cDriverReferences accordingly.

    ASSERTGDI(cReferencesOld + cAdjustNew == peDirectDrawGlobalOld->cDriverReferences,
        "Mis-match in old D3D driver references");
    ASSERTGDI(cReferencesNew + cAdjustOld == peDirectDrawGlobalNew->cDriverReferences,
        "Mis-match in new D3D driver references");

    // Transfer the PDEV references:
    //
    // I'm going to try to explain this.  DXG keeps a single ref count on each
    // PDEV that either has a surface or a context associated with it, so on
    // entering this funtion, we have a single ref count on the old PDEV.
    // If we transfer all of the surfaces to the new PDEV, then we can decrement
    // from the ref from the old PDEV and add on to the new PDEV.  If some of the
    // surfaces continue with the old PDEV, however, then we need to make sure
    // that we keep ref on that PDEV as well.

    peDirectDrawGlobalNew->cDriverReferences -= cAdjustOld;
    peDirectDrawGlobalNew->cDriverReferences += cAdjustNew;
    peDirectDrawGlobalOld->cDriverReferences -= cAdjustNew;
    peDirectDrawGlobalOld->cDriverReferences += cAdjustOld;

#if DBG_HIDEYUKN
    KdPrint(("DXG:Reference Counts AFTER Adjust\n"));
    KdPrint(("DXG:DdGlobalOld->cDriverReferences = %d\n",peDirectDrawGlobalOld->cDriverReferences));
    KdPrint(("DXG:DdGlobalNew->cDriverReferences = %d\n",peDirectDrawGlobalNew->cDriverReferences));
#endif

    if (cReferencesNew || cAdjustOld)
    {
        // The old PDEV had references on it
        if (peDirectDrawGlobalOld->cDriverReferences == 0)
        {
            //but it doesn't now, so remove it
            poOld.vUnreferencePdev();
        }
    }
    else
    {
        // The old PDEV did not have refernces on it
        if (peDirectDrawGlobalOld->cDriverReferences > 0)
        {
            // but it does not, so add it
            poOld.vReferencePdev();      
        }
    }

    if (cReferencesOld || cAdjustNew)
    {
        // The new PDEV had references on it
        if (peDirectDrawGlobalNew->cDriverReferences == 0)
        {
            // but it doesn't now, so remove it
            poNew.vUnreferencePdev();
        }
    }
    else
    {
        // The new PDEV did not have references on it
        if (peDirectDrawGlobalNew->cDriverReferences > 0)
        {
            // but it does now, so add it
            poNew.vReferencePdev();      
        }
    }

    // Move DirectDraw lock count.
    //
    // - this point, the disabled flag has *NOT* been swapped YET, so
    //   we need to move the lock count to where it *will be* disabled "after this call"
    //   not the device currently disabled.
    // 
    // So if poNew is disabled at here, GDI will make poOld disabled (after this call),
    // thus transfer disabled lock to poOld.

    if (!poNew.bMetaDriver() && !poOld.bMetaDriver())
    {
        // Mode change between display drivers.

        if (poNew.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment

            ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 1,"Old PDEV cDirectDrawLocks <= 0");
            ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 2,"New PDEV cDirectDrawLocks <= 1");

            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() + 1);
            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() - 1);
        }

        if (poOld.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment

            ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 1,"New PDEV cDirectDrawLocks <= 0");
            ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 2,"Old PDEV cDirectDrawLocks <= 1");

            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() + 1);
            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() - 1);
        }
    }
    else if (poNew.bMetaDriver() && poOld.bMetaDriver())
    {
        // Mode change between DDMLs, nothing need to do.
        // Because the hdev for Meta driver is ALWAYS created newly, never reused.
        // (see gre\drvsup\hCreateHDEV()).
    }
    else if (poOld.bMetaDriver() || poNew.bMetaDriver())
    {
        // Since at this point, the meta driver flag has been swapped.
        //
        // - when poOld is meta, we are doing 1 -> 2 mode change.
        // - when poNew is meta, we are doing 2 -> 1 mode change.

        if (poNew.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment
            //
            // ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 1,"A: Old PDEV cDirectDrawLocks <= 0");
            // ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 2,"B: New PDEV cDirectDrawLocks <= 1");

            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() + 1);
            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() - 1);
        }

        if (poOld.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment
            //
            // ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 1,"C: New PDEV cDirectDrawLocks <= 0");
            // ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 2,"D: Old PDEV cDirectDrawLocks <= 1");

            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() + 1);
            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() - 1);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDdMapMemory
*
* Creates a user-mode mapping of the device's entire frame buffer in the
* current process.
*
* The devlock must be held to call this function.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vDdMapMemory(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    HRESULT*                pResult
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwRet;
    DD_MAPMEMORYDATA        MapMemoryData;
    SIZE_T                  CommitSize;
    HANDLE                  pSection;
    HANDLE                  SectionHandle;
    NTSTATUS                Status;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    if (!(peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_MAPMEMORY))
    {
        peDirectDrawLocal->fl |= DD_LOCAL_FLAG_MEMORY_MAPPED;
        peDirectDrawGlobal->cMaps++;
    }
    else
    {
        MapMemoryData.lpDD      = peDirectDrawGlobal;
        MapMemoryData.bMap      = TRUE;
        MapMemoryData.hProcess  = NtCurrentProcess();
        MapMemoryData.fpProcess = NULL;

        dwRet = peDirectDrawGlobal->CallBacks.MapMemory(&MapMemoryData);

        *pResult = MapMemoryData.ddRVal;

        if (*pResult == DD_OK)
        {
            // Allocate new EDD_VMEMMAPPING object
            peDirectDrawLocal->peMapCurrent = (EDD_VMEMMAPPING*)
                PALLOCMEM(sizeof(EDD_VMEMMAPPING), ' ddG');

            if (peDirectDrawLocal->peMapCurrent)
            {
                peDirectDrawLocal->peMapCurrent->fpProcess =
                    MapMemoryData.fpProcess;
                peDirectDrawLocal->peMapCurrent->cReferences = 1;

                peDirectDrawLocal->fpProcess = MapMemoryData.fpProcess;
                peDirectDrawLocal->fl |= DD_LOCAL_FLAG_MEMORY_MAPPED;
                peDirectDrawGlobal->cMaps++;

                ASSERTGDI(peDirectDrawLocal->fpProcess != 0,
                    "Expected non-NULL fpProcess value from MapMemory");
                ASSERTGDI((ULONG) peDirectDrawLocal->fpProcess
                        < MM_USER_PROBE_ADDRESS,
                    "Expected user-mode fpProcess value from MapMemory");
            }
            else
            {
                WARNING("vDdMapMemory: "
                    "Could not allocate memory for peMapCurrent\n");

                // Clean up the driver mapping since we are failing vDdMapMemory call!

                MapMemoryData.lpDD      = peDirectDrawGlobal;
                MapMemoryData.bMap      = FALSE;
                MapMemoryData.hProcess  = NtCurrentProcess();

                // Keep fpProcess as what driver returned at above call.
                //
                // MapMemoryData.fpProcess = MapMemoryData.fpProcess;

                // Don't really care if this succeeds. It's bad news anyway

                peDirectDrawGlobal->CallBacks.MapMemory(&MapMemoryData);

                return;
            }
        }
        else
        {
            WARNING("vDdMapMemory: Driver failed DdMapMemory\n");
        }
    }
}

/******************************Public*Routine******************************\
* VOID pDdLockSurfaceOrBuffer
*
* Returns a user-mode pointer to the surface or D3D buffer.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID*
pDdLockSurfaceOrBuffer(
    EDD_SURFACE*    peSurface,
    BOOL            bHasRect,
    RECTL*          pArea,
    DWORD           dwFlags,      // DDLOCK_WAIT, DDLOCK_NOSYSLOCK
    HRESULT*        pResult       // ddRVal result of call (may be NULL)
    )
{
    VOID*                   pvRet;
    DD_LOCKDATA             LockData;
    DD_UNLOCKDATA           UnlockData;
    EDD_DIRECTDRAW_GLOBAL*  peDdGlobalDriver;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    DWORD                   dwTmp;
    DWORD                   dwRedraw;
    PDD_SURFCB_LOCK         pfnLock;

    pvRet = NULL;
    LockData.ddRVal = DDERR_GENERIC;

    peDirectDrawLocal  = peSurface->peDirectDrawLocal;

    // Due to video mode change across different video driver, currently
    // this "driver managed" surface is associated to different driver
    // than the driver who actually manage it. So we must call the driver
    // which actually manage the surface.

    // Hold share lock and devlock for video mode change.
    // peSurface->fl can be changed by mode change, so we need to access
    // there under holding share lock.

    EDD_SHARELOCK eSharelock(TRUE);

    if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
    {
        // If surface is owned by different driver, lock right driver.

        if (peSurface->peDirectDrawGlobal != peSurface->peDdGlobalCreator)
        {
            peDdGlobalDriver = peSurface->peDdGlobalCreator;
        }

        // WARNING("pDdLockSurfaceOrBuffer: Lock on wrong driver");
    }
    else
    {
        peDdGlobalDriver = peSurface->peDirectDrawGlobal;
    }

    EDD_DEVLOCK eDevlock(peDdGlobalDriver);

    // For system memory surface, just return here without involving driver.

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pvRet = (VOID*) peSurface->fpVidMem;
        LockData.ddRVal = DD_OK;
        goto Exit;
    }

    // In case if videomode change just happened, make sure new mode
    // has DirectDraw capability.

    if (!(peDdGlobalDriver->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED))
    {
        LockData.ddRVal = DDERR_SURFACELOST;
        goto Exit;
    }

    // We have to check both to see if the surface is disabled and if
    // DirectDraw is disabled.  We have to do the latter because we may
    // be in a situtation where we're denying locks, but all the
    // individual surfaces have not yet been marked as disabled.

    if (peSurface->bLost)
    {
        LockData.ddRVal = DDERR_SURFACELOST;
        goto Exit;
    }

    if ((peDdGlobalDriver->bSuspended) ||
        (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER))
    {
        // Only the "driver managed surface" surface has DDSCAPS2_DONOTPERSIST
        // can be locked when driver is suspended or surface lives in different driver.

        if ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
            !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
        {
            // WARNING("pDdLockSurfaceOrBuffer: Call driver other than current to lock driver managed surface"); 
        }
        else
        {
            LockData.ddRVal = DDERR_SURFACELOST;
            goto Exit;
        }
    }

    LockData.dwFlags     = dwFlags & (
                            DDLOCK_SURFACEMEMORYPTR |
                            DDLOCK_DISCARDCONTENTS |
                            DDLOCK_NOOVERWRITE | 
                            DDLOCK_READONLY |
                            DDLOCK_WRITEONLY |
                            DDLOCK_HASVOLUMETEXTUREBOXRECT |
                            DDLOCK_NODIRTYUPDATE);
    LockData.lpDD        = peDdGlobalDriver;
    LockData.lpDDSurface = peSurface;
    LockData.bHasRect    = bHasRect;

    if (bHasRect)
    {
        // Validate lock area.

        LONG left, top, right, bottom;
        LONG front, back, SurfaceDepth;

        if ((peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) &&
            (LockData.dwFlags & DDLOCK_HASVOLUMETEXTUREBOXRECT))
        {
            left    = pArea->left  & 0xFFFF;
            top     = pArea->top;
            right   = pArea->right & 0xFFFF;
            bottom  = pArea->bottom;
            front   = (ULONG)(pArea->left)  >> 16;
            back    = (ULONG)(pArea->right) >> 16;
            SurfaceDepth = peSurface->dwBlockSizeY;
        }
        else
        {
            left    = pArea->left;
            top     = pArea->top;
            right   = pArea->right;
            bottom  = pArea->bottom;
        }

        // Ensure that the driver and 'bSpTearDownSprites'
        // don't fall over when given a bad rectangle:

        if ((left   >= right)                    ||
            (top    >= bottom)                   ||
            (left   < 0)                         ||
            (top    < 0)                         ||
            (right  > (LONG) peSurface->wWidth)  ||
            (bottom > (LONG) peSurface->wHeight))
        {
            if (!(left == 0 && right == 0 && 
                 (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
                 (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)))
            {
                bHasRect = FALSE;
            }
        }

        if ((peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) &&
            (LockData.dwFlags & DDLOCK_HASVOLUMETEXTUREBOXRECT))
        {
            if ((front >= back) ||
                (front < 0)     ||
                (back  > SurfaceDepth))
            {
                bHasRect = FALSE;
            }
        }
    }

    if (!bHasRect)
    {
        // Lock entire surface. (all depth if volume).

        LockData.rArea.left   = 0;
        LockData.rArea.top    = 0;
        LockData.rArea.right  = peSurface->wWidth;
        LockData.rArea.bottom = peSurface->wHeight;

        // Mask off DDLOCK_HASVOLUMETEXTUREBOXRECT.

        LockData.dwFlags &= ~DDLOCK_HASVOLUMETEXTUREBOXRECT;
    }
    else
    {
        LockData.rArea = *pArea;
    }

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        // AGP surfaces don't need fpProcess:

        LockData.fpProcess = 0;
    }
    else
    {
        if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
        {
            // If this surface currently lives in different driver,
            // don't do video memory mapping to usermode address.
            // Driver should be able to lock surface without this.
            // Unless otherwise, driver should fail in Lock.

            LockData.fpProcess = 0;
        }
        else
        { 
            // Map the memory into the application's address space if that
            // hasn't already been done:

            if (!(peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED))
            {
                vDdMapMemory(peDirectDrawLocal, &LockData.ddRVal);
            }

            // Only proceed if we were successful in mapping the memory:

            if (!(peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED))
            {
                goto Exit;
            }

            LockData.fpProcess = peDirectDrawLocal->fpProcess;
        }
    }

    // If the surface is driver managed, we don't want to create any aliases
    // so we reset the NOSYSLOCK flag:

    if ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
        !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
    {
        dwFlags &= ~DDLOCK_NOSYSLOCK;
    }

    // We allow only one "aliased" lock at any time. Thus if there already
    // exists an aliased lock (peMap !=NULL) then we fail all other requests
    // for locks. Also if there are already non aliased locks then we fail
    // any requests for aliased locks.
    // All this restrictions are put in due to the fact that we do not keep
    // track of access rects for each surface in the kernel. If we did, we
    // would just store a peMap pointer per access rect and not require these
    // checks.

    if ((peSurface->peMap || 
        (peSurface->fl & DD_SURFACE_FLAG_FAKE_ALIAS_LOCK)) ||
        (peSurface->cLocks && (dwFlags & DDLOCK_NOSYSLOCK)))
    {
        WARNING("pDdLockSurfaceOrBuffer: Failing lock since we cannot have more than one aliased lock");
        LockData.ddRVal = DDERR_SURFACEBUSY;
        goto Exit;
    }

    // If the VisRgn has changed since the application last queried
    // it, fail the call with a unique error code so that they know
    // to requery the VisRgn and try again.  We do this only if we
    // haven't been asked to wait (we assume 'bWait' is equivalent
    // to 'bInternal').

    if (!(dwFlags & DDLOCK_WAIT) &&
        (peSurface->fl & DD_SURFACE_FLAG_PRIMARY) &&
        (peSurface->iVisRgnUniqueness != VISRGN_UNIQUENESS()))
    {
        LockData.ddRVal = DDERR_VISRGNCHANGED;
        goto Exit;
    }

    dwTmp = DDHAL_DRIVER_NOTHANDLED;

    // Pick the appropriate lock function.

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        pfnLock = peDdGlobalDriver->D3dBufCallbacks.LockD3DBuffer;
    }
    else
    {
        if (peDdGlobalDriver->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_LOCK)
        {
            pfnLock = peDdGlobalDriver->SurfaceCallBacks.Lock;
        }
        else
        {
            pfnLock = NULL;
        }
    }

    if (pfnLock != NULL)
    {
        do
        {
            dwTmp = pfnLock(&LockData);
        } while ((dwFlags & DDLOCK_WAIT) &&
                 (dwTmp == DDHAL_DRIVER_HANDLED) &&
                 (LockData.ddRVal == DDERR_WASSTILLDRAWING));
    }

    if ((dwTmp == DDHAL_DRIVER_NOTHANDLED) ||
        (LockData.ddRVal == DD_OK))
    {
        // We successfully did the lock!
        //
        // If this is the primary surface and no window has been
        // associated with the surface via DdResetVisRgn, then
        // we have to force a redraw at Unlock time if any
        // VisRgn has changed since the first Lock.
        //
        // If there is a window associated with the surface, then
        // we have already checked that peSurface->iVisRgnUniqueness
        // == po.iVisRgnUniqueness().

        if (peSurface->cLocks++ == 0)
        {
            // If the surface is driver managed, we don't bother to
            // increment the global lock count since we don't want to break
            // locks when "losing" surfaces.

            if (!(peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) ||
                ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                 (peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST)))
            {
                peDdGlobalDriver->cSurfaceLocks++;
            }

            peSurface->iVisRgnUniqueness = VISRGN_UNIQUENESS();
        }
        else
        {
            if (peSurface->rclLock.left   < LockData.rArea.left)
                LockData.rArea.left   = peSurface->rclLock.left;

            if (peSurface->rclLock.top    < LockData.rArea.top)
                LockData.rArea.top    = peSurface->rclLock.top;

            if (peSurface->rclLock.right  > LockData.rArea.right)
                LockData.rArea.right  = peSurface->rclLock.right;

            if (peSurface->rclLock.bottom > LockData.rArea.bottom)
                LockData.rArea.bottom = peSurface->rclLock.bottom;
        }

        // If this is the primary surface, then union the current DirectDraw
        // bounds rectangle with the lock area rectangle.

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            if (peDdGlobalDriver->fl & DD_GLOBAL_FLAG_BOUNDS_SET)
            {
                if (LockData.rArea.left < peDdGlobalDriver->rclBounds.left)
                    peDdGlobalDriver->rclBounds.left = LockData.rArea.left;

                if (LockData.rArea.top < peDdGlobalDriver->rclBounds.top)
                    peDdGlobalDriver->rclBounds.top = LockData.rArea.top;

                if (LockData.rArea.right > peDdGlobalDriver->rclBounds.right)
                    peDdGlobalDriver->rclBounds.right = LockData.rArea.right;

                if (LockData.rArea.bottom > peDdGlobalDriver->rclBounds.bottom)
                    peDdGlobalDriver->rclBounds.bottom = LockData.rArea.bottom;
            }
            else
            {
                peDdGlobalDriver->rclBounds = LockData.rArea;
                peDdGlobalDriver->fl |= DD_GLOBAL_FLAG_BOUNDS_SET;
            }
        }

        // If there was a flip pending, then there is not now.

        if (peSurface->fl & DD_SURFACE_FLAG_FLIP_PENDING)
        {
            peSurface->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
        }

        // Stash away surface lock data:

        peSurface->rclLock = LockData.rArea;

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            if (peSurface->cLocks == 1)
            {
                // Add this surface to the head of the locked list:

                peSurface->peSurface_PrimaryLockNext
                    = peDdGlobalDriver->peSurface_PrimaryLockList;
                peDdGlobalDriver->peSurface_PrimaryLockList
                    = peSurface;
            }

            // If this is the primary surface, tear down any
            // sprites that intersect with the specified
            // rectangle:
    
            if (DxEngSpTearDownSprites(peDdGlobalDriver->hdev,
                       &LockData.rArea,
                       TRUE))
            {
                // Here's some weirdness for you.  That sprite
                // tear-down we just did may have involved
                // accelerator operations, which means the
                // accelerator may be still in use if we
                // immediately returned to the application,
                // which of course is bad.
                //
                // You might think that a fix to this would
                // be to put the sprite tear-down *before*
                // the call to the driver's DdLock routine.
                // But then you get the problem that DdLock
                // would *always* return DDERR_WASSTILLDRAWING,
                // and we would have to re-draw the sprites,
                // meaning that the application would get into
                // an endless loop if it was itself (like all
                // of DirectDraw's HAL code) looping on
                // DDERR_WASSTILLDRAWING.
                //
                // To solve this problem, we'll simply wait for
                // accelerator idle after tearing-down the
                // sprite.  We do this by calling DdLock/DdUnlock
                // again:

                if (peDdGlobalDriver->SurfaceCallBacks.dwFlags
                    & DDHAL_SURFCB32_LOCK)
                {
                    do
                    {
                        dwRedraw = peDdGlobalDriver->
                               SurfaceCallBacks.Lock(&LockData);
                    } while ((dwRedraw == DDHAL_DRIVER_HANDLED) &&
                          (LockData.ddRVal == DDERR_WASSTILLDRAWING));
                }
        
                if (peDdGlobalDriver->SurfaceCallBacks.dwFlags
                     & DDHAL_SURFCB32_UNLOCK)
                {
                    UnlockData.lpDD        = peDdGlobalDriver;
                    UnlockData.lpDDSurface = peSurface;
        
                    peDdGlobalDriver->
                    SurfaceCallBacks.Unlock(&UnlockData);
                }
            }
        }

        LockData.ddRVal = DD_OK;

        if (dwTmp == DDHAL_DRIVER_HANDLED)
        {
            // If it says it handled the call, the driver is
            // expected to have computed the address in the
            // client's address space:

            pvRet = (VOID*) LockData.lpSurfData;

            ASSERTGDI(pvRet != NULL,
                      "Expected non-NULL lock pointer value (DRIVER_HANDLED)");
            ASSERTGDI(pvRet < (PVOID) MM_USER_PROBE_ADDRESS,
                      "Expected user-mode lock pointer value (DRIVER_HANDLED)");
        }
        else
        {
            if (peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                pvRet = (VOID*)peSurface->fpVidMem;
            }
            else
            {
                pvRet = (VOID*) (peDirectDrawLocal->fpProcess
                                 + peSurface->fpVidMem);
            }

            ASSERTGDI(pvRet != NULL,
                      "Expected non-NULL lock pointer value (DRIVER_NOT_HANDLED)");
            ASSERTGDI(pvRet < (PVOID) MM_USER_PROBE_ADDRESS,
                      "Expected user-mode lock pointer value (DRIVER_NOT_HANDLED)");

            // DirectDraw has a goofy convention that when a
            // driver returns DD_OK and DDHAL_DRIVER_HANDLED
            // from a Lock, that the driver is also supposed to
            // adjust the pointer to point to the upper left
            // corner of the specified rectangle.
            //
            // This doesn't make a heck of a lot of sense for
            // odd formats such as YUV surfaces, but oh well --
            // since kernel-mode is acting like a driver to
            // user-mode DirectDraw, we have to do the adjustment:

            if (bHasRect)
            {
                pvRet = (VOID*)
                    ((BYTE*) pvRet
                     + (pArea->top * peSurface->lPitch)
                     + (pArea->left
                        * (peSurface->ddpfSurface.dwRGBBitCount >> 3)));
            }
        }

        // If this was an "aliased" lock, we store the corresponding pointer
        // to the EDD_VMEMMAPPING
        if (dwFlags & DDLOCK_NOSYSLOCK)
        {
            if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM))
            {
                peSurface->peMap = peDirectDrawLocal->peMapCurrent;

                ASSERTGDI(peSurface->peMap != NULL,
                    "Expected video memory to be mapped into user space");
            }
            else
            {
                // If the non-local surface was not allocated from one of
                // our managed heaps, then lpVidMemHeap will be NULL and
                // we cannot alias the heap, so we don't do the aliased
                // lock.

                if (peSurface->lpVidMemHeap != NULL)
                {
                    peSurface->peMap = peDirectDrawLocal->ppeMapAgp[
                        (peSurface->lpVidMemHeap -
                        peDdGlobalDriver->pvmList)];
                }
            }

            // If the map pointer is NULL, then the surface lock cannot be
            // aliased so proceed as if DDLOCK_NOSYSLOCK was not passed.
            // Otherwise, take the appropriate reference counts now:

            if (peSurface->peMap != NULL)
            {
                peSurface->fl |= DD_SURFACE_FLAG_ALIAS_LOCK; 
                peDdGlobalDriver->cSurfaceAliasedLocks++;
                peSurface->peMap->cReferences++;
                // Keep a reference of the driver instance used to create this mapping
                peSurface->peVirtualMapDdGlobal = peDdGlobalDriver;
                vDdIncrementReferenceCount(peDdGlobalDriver);
                DDKHEAP(("Taken aliased lock: peSurface=%lx, peMap=%lx, "
                        "peDdGlobalDriver=%lx\n",
                        peSurface, peSurface->peMap, peDdGlobalDriver));
            }
            else
            {
                // We have a private driver cap that will enable us to treat
                // AGP surface locks as aliased even though the driver doesn't
                // expose an AGP heap.  This is to enable drivers to work around
                // anything that we happen to do wrong in our AGP code without
                // them incurring the 7 second tiemout on every mode change.

                if ((peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
                    (peDdGlobalDriver->PrivateCaps.dwPrivateCaps & DDHAL_PRIVATECAP_RESERVED1))

                {
                    peSurface->fl |= DD_SURFACE_FLAG_ALIAS_LOCK; 
                    peDdGlobalDriver->cSurfaceAliasedLocks++;
                    peSurface->fl |= DD_SURFACE_FLAG_FAKE_ALIAS_LOCK;
                }

                // Just to avoid possible problems in the future, turn
                // off the flag here:

                dwFlags &= ~DDLOCK_NOSYSLOCK;
            }
        }
    }
    else
    {
        if (LockData.ddRVal != DDERR_WASSTILLDRAWING)
        {
            WARNING("pDdLockSurface: Driver failed DdLock\n");
        }
    }

 Exit:
    if (pResult)
    {
        *pResult = LockData.ddRVal;
    }

    return(pvRet);
}

/******************************Public*Routine******************************\
* BOOL bDdUnlockSurfaceOrBuffer
*
* DirectDraw unlock for surfaces and D3D buffers.
*
* Note that the Devlock MUST NOT be held when entering this function
* if the surface is the primary surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdUnlockSurfaceOrBuffer(
    EDD_SURFACE* peSurface
    )
{
    BOOL                    b;
    BOOL                    bRedraw;
    BOOL                    bFreeVirtualMap = FALSE;
    EDD_DIRECTDRAW_GLOBAL  *peDdGlobalDriver;

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        return(TRUE);
    }

    peSurface->fl &= ~DD_SURFACE_FLAG_ALIAS_LOCK; 
    b = FALSE;
    bRedraw = FALSE;

    {
        // Don't hold ShareLock togather (see vDdDisableAllDirectDrawObjects)
        // Give a change to signal AssertMode event.

        EDD_DEVLOCK eDevlock(peSurface->peDirectDrawGlobal);

        // Due to video mode change across different video driver, currently
        // this "driver managed" surface is associated to different driver
        // than the driver who actually manage it. So we must call the driver
        // which actually manage the surface.
        //
        // peSurface->fl can be changed by mode change, thus we access there
        // under holding devlock.

        if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
        {
            // If surface is owned by different driver, lock right driver.

            if (peSurface->peDirectDrawGlobal != peSurface->peDdGlobalCreator)
            {
                // Unlike DdLockSurfaceOrBuffer case, we can't just unlock and
                // lock with new device. Because, we can't hold sharelock (see above)
                // so when we unlock device, there is a chance to mode change happens.
                // thus, after we relock the device, we have to make sure peDdGlobalCreator
                // is continue to be save as before. Otherwise loop until it match.

                do {
                    peDdGlobalDriver = peSurface->peDdGlobalCreator;
                    eDevlock.vUnlockDevice();
                    eDevlock.vUpdateDevice(peDdGlobalDriver);
                    eDevlock.vLockDevice();
                } while (peDdGlobalDriver !=
                         ((EDD_DIRECTDRAW_GLOBAL volatile *)(peSurface->peDdGlobalCreator)));

                // WARNING("pDdLockSurfaceOrBuffer: Unlock on wrong driver");
            }
        }
        else
        {
            peDdGlobalDriver = peSurface->peDirectDrawGlobal;
        }

        // Make sure there was a previous lock:

        if (peSurface->cLocks > 0)
        {
            if ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
            {
                // Driver managed surface can be unlock ANYTIME.
                // (even PDEV is disabled)
            }
            else
            {
                PDEVOBJ po(peDdGlobalDriver->hdev);

                ASSERTGDI(!po.bDisabled(),
                         "Surface is disabled but there are outstanding locks?");
            }

            vDdRelinquishSurfaceOrBufferLock(peDdGlobalDriver, peSurface);

            // Does lock went to 0 after "Relinquish" ?

            if (peSurface->cLocks == 0)
            {
                // Was this an aliased lock ?

                if (peSurface->peMap)
                {
                    bFreeVirtualMap = TRUE;
                }

                // If the API-disabled flag is set and we got this far into
                // Unlock, it means that there is a DdSuspendDirectDraw()
                // call pending, and that thread is waiting for all surface
                // locks related to the device to be released.
                //
                // If this is the last lock to be released, signal the event
                // so that the AssertMode thread can continue on.

                if ((peDdGlobalDriver->cSurfaceLocks == 0) &&
                    (peDdGlobalDriver->bSuspended))
                {
                    KeSetEvent(peDdGlobalDriver->pAssertModeEvent,
                               0,
                               FALSE);
                }

                // NOTE: This should really test if the surface has a clipper. But
                //       it can't because of comapatibility with Win95, where
                //       applications expect a primary surface lock to be atomic
                //       even if they haven't attached a clipper object.
                //       (Microsoft's own OPENGL32.DLL does this, that shipped
                //       in NT 5.0.)  However, this means that applications
                //       that are full-screen double buffering can possibly
                //       be causing a whole bunch of repaints when it does a
                //       direct lock on (what is now) the back buffer.
                //
                //       Potentially, this 'if' should have an additional
                //       condition, and that is not to do it if the application
                //       is in exclusive mode:

                if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
                {
                    // If the VisRgn changed while the application was writing
                    // to the surface, it may have started drawing over the
                    // the wrong window, so fix it up.
                    //
                    // Alas, right now a DirectDraw application doesn't always
                    // tell us what window it was drawing to, so we can't fix
                    // up only the affected windows.  Instead, we solve it the
                    // brute-force way and redraw *all* windows:

                    if (peSurface->iVisRgnUniqueness != VISRGN_UNIQUENESS())
                    {
                        // We can't call UserRedrawDesktop here because it
                        // grabs the User critical section, and we're already
                        // holding the devlock -- which could cause a possible
                        // deadlock.  Since it's a posted message it obviously
                        // doesn't have to be done under the devlock.

                        bRedraw = TRUE;

                        // Note that we should not update peSurface->
                        // iVisRgnUniqueness here.  That's because if the
                        // application has attached a window to the surface, it
                        // has to be notified that the clipping has changed --
                        // which is done by returning DDERR_VISRGNCHANGED on the
                        // next Lock or Blt call.  And if the application has
                        // not attached a window, we automatically update the
                        // uniqueness at the next Lock time.
                    }
                }
            }

            b = TRUE;
        }
        else // if (peSurface->cLocks == 0)
        {
            // The lock count is 0 but we may have a "broken" lock.
            if (peSurface->peMap)
            {
                bFreeVirtualMap = TRUE;
            }
            else
            {
                WARNING("bDdUnlockSurfaceOrBuffer: Surface already unlocked\n");
            }
        }
    }

    if (bRedraw)
    {
        PDEVOBJ po(peDdGlobalDriver->hdev);

        // We can redraw only if we're not holding the devlock, because
        // User needs to acquire its critical section.  The User lock
        // must always be acquired before the devlock, which is why
        // we can't call User if we're already holding the devlock.
        //
        // I don't trust any callers enough to merely assert that we're
        // not holding the devlock; I'll actually check...

        if (!DxEngIsHdevLockedByCurrentThread(po.hdev()))
        {
            DxEngRedrawDesktop();
        }
    }

    if (bFreeVirtualMap)
    {
        // We can release virtual map if we're not holding the devlock,
        // because it might release GDI's PDEV if this is last reference.

        vDdReleaseVirtualMap(peSurface);
    }

    return(b);
}

/******************************Public*Routine******************************\
* HANDLE DxDdCreateDirectDrawObject
*
* Creates a DirectDraw object.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdCreateDirectDrawObject(
    HDC     hdc
    )
{
    HANDLE  hDirectDrawLocal;

    hDirectDrawLocal = 0;       // Assume failure

    PVOID pvLockedDC = DxEngLockDC(hdc);

    if (pvLockedDC)
    {
        PDEVOBJ po((HDEV)DxEngGetDCState(hdc,DCSTATE_HDEV));

        if (po.bValid() && po.bDisplayPDEV())
        {
            // Note that we aren't checking to see if the PDEV is disabled,
            // so that DirectDraw could be started even when full-screen:

            EDD_DEVLOCK eDevlock(po.hdev());

            if (!(po.bDisabled()))
            {
                CheckAgpHeaps(po.peDirectDrawGlobal());
            }

            // DirectDraw works only at 8bpp or higher:

            if (po.iDitherFormat() >= BMF_8BPP)
            {
                hDirectDrawLocal = hDdCreateDirectDrawLocal(po);
            }
        }

        DxEngUnlockDC(pvLockedDC);
    }
    else
    {
        WARNING("DxDdCreateDirectDrawObject: Bad DC\n");
    }

    return(hDirectDrawLocal);
}

/******************************Public*Routine******************************\
* BOOL DxDdDeleteDirectDrawObject
*
* Deletes a kernel-mode representation of the surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdDeleteDirectDrawObject(
    HANDLE  hDirectDrawLocal
    )
{
    return(bDdDeleteDirectDrawObject(hDirectDrawLocal, FALSE));
}

/******************************Public*Routine******************************\
* HANDLE DxDdQueryDirectDrawObject
*
* Queries a DirectDraw object.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdQueryDirectDrawObject(
    HANDLE                      hDirectDrawLocal,
    DD_HALINFO*                 pHalInfo,
    DWORD*                      pCallBackFlags,
    LPD3DNTHAL_CALLBACKS        puD3dCallbacks,
    LPD3DNTHAL_GLOBALDRIVERDATA puD3dDriverData,
    PDD_D3DBUFCALLBACKS         puD3dBufferCallbacks,
    LPDDSURFACEDESC             puD3dTextureFormats,
    DWORD*                      puNumHeaps,
    VIDEOMEMORY*                puvmList,
    DWORD*                      puNumFourCC,
    DWORD*                      puFourCC
    )
{
    BOOL                    b;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    ULONG                   cBytes;

    b = FALSE;              // Assume failure

    // The most fundamental basis of accelerated DirectDraw is that it
    // allows direct access to the frame buffer by the application.  If
    // security permissions prohibit reading from the screen, we cannot
    // allow accelerated DirectDraw:

    if (DxEngScreenAccessCheck())
    {
        peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDrawLocal);
        if (peDirectDrawLocal != NULL)
        {
            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            // A registry timeout value of 'zero' signifies that DirectDraw
            // accelerations cannot be enabled.  Note that the timeout is
            // non-positive because it's a relative time duration.

            if (peDirectDrawGlobal->llAssertModeTimeout < 0)
            {
                DWORD   dwOverride;
                PDEVOBJ po(peDirectDrawGlobal->hdev);
    
                // Get driver override info:

                dwOverride = po.dwDriverCapableOverride();

                __try
                {
                    DD_HALINFO ddhi = peDirectDrawGlobal->HalInfo;

                    if ( dwOverride & DRIVER_NOT_CAPABLE_D3D )
                    {
                        // If the driver is not capable of doing D3D, turn the CAPS
                        // off

                        ddhi.ddCaps.dwCaps &= ~DDCAPS_3D;
                        ddhi.lpD3DGlobalDriverData = 0;
                        ddhi.lpD3DHALCallbacks = 0;
                    }

#ifdef DX_REDIRECTION
                    if ( gbDxRedirection )
                    {
                        // If we are in redirection mode, disable overlay.

                        ddhi.ddCaps.dwCaps &= ~DDCAPS_OVERLAY;
                        ddhi.ddCaps.dwMaxVisibleOverlays = 0;
                    }
#endif // DX_REDIRECTION

                    ProbeAndWriteStructure(pHalInfo,
                                           ddhi,
                                           DD_HALINFO);

                    ProbeForWrite(pCallBackFlags, 3 * sizeof(ULONG), sizeof(ULONG));
                    pCallBackFlags[0] = peDirectDrawGlobal->CallBacks.dwFlags;
                    pCallBackFlags[1] = peDirectDrawGlobal->SurfaceCallBacks.dwFlags;
                    pCallBackFlags[2] = peDirectDrawGlobal->PaletteCallBacks.dwFlags;

                    if (puD3dCallbacks != NULL)
                    {
                        ProbeAndWriteStructure(puD3dCallbacks,
                                               peDirectDrawGlobal->D3dCallBacks,
                                               D3DNTHAL_CALLBACKS);
                    }

                    if (puD3dDriverData != NULL)
                    {
                        ProbeAndWriteStructure(puD3dDriverData,
                                               peDirectDrawGlobal->D3dDriverData,
                                               D3DNTHAL_GLOBALDRIVERDATA);
                    }

                    if (puD3dBufferCallbacks != NULL)
                    {
                        ProbeAndWriteStructure(puD3dBufferCallbacks,
                                               peDirectDrawGlobal->D3dBufCallbacks,
                                               DD_D3DBUFCALLBACKS);
                    }

                    if (puD3dTextureFormats != NULL)
                    {
                        ProbeForWrite(puD3dTextureFormats,
                                      peDirectDrawGlobal->D3dDriverData.dwNumTextureFormats*
                                      sizeof(DDSURFACEDESC), sizeof(DWORD));
                        RtlCopyMemory(puD3dTextureFormats,
                                      peDirectDrawGlobal->D3dDriverData.lpTextureFormats,
                                      peDirectDrawGlobal->D3dDriverData.dwNumTextureFormats*
                                      sizeof(DDSURFACEDESC));
                    }

                    ProbeAndWriteUlong(puNumFourCC, peDirectDrawGlobal->dwNumFourCC);

                    // Offscreen heap allocations are handled directly
                    // in the kernel so don't report any memory back to
                    // user mode.

                    ProbeAndWriteUlong(puNumHeaps, 0);

                    if (puFourCC != NULL)
                    {
                        cBytes = sizeof(ULONG) * peDirectDrawGlobal->dwNumFourCC;

                        ProbeForWrite(puFourCC, cBytes, sizeof(ULONG));
                        RtlCopyMemory(puFourCC, peDirectDrawGlobal->pdwFourCC, cBytes);
                    }

                    b = TRUE;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("DxDdQueryDirectDrawObject: Passed bad pointers\n");
                }
            }
            else
            {
                WARNING("DxDdQueryDirectDrawObject: DirectDraw disabled in registry\n");
            }
        }
        else
        {
            WARNING("DxDdQueryDirectDrawObject: Bad handle or busy\n");
        }
    }
    else
    {
        WARNING("DxDdCreateDirectDrawObject: Don't have screen read permission");
    }

    return(b);
}

/******************************Public*Routine******************************\
* EDD_SURFACE* peDdOpenNewSurfaceObject
*
* Creates a new kernel-mode surface by re-using the old surface if it's
* lost, or by allocating a new surface.
*
* NOTE: Leaves the surface exclusive locked!
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EDD_SURFACE*
peDdOpenNewSurfaceObject(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    HANDLE                  hSurface,
    DD_SURFACE_GLOBAL*      pSurfaceGlobal,
    DD_SURFACE_LOCAL*       pSurfaceLocal,
    DD_SURFACE_MORE*        pSurfaceMore
    )
{
    EDD_SURFACE* peSurface;

    BOOL         bSurfaceAlloced = FALSE;

    // First, try to resurrect the old surface if there is one:

    peSurface = NULL;
    if (hSurface != 0)
    {
        peSurface = (EDD_SURFACE*) DdHmgLock((HDD_OBJ) hSurface, DD_SURFACE_TYPE, FALSE);
        if (peSurface == NULL)
        {
            WARNING("peDdOpenNewSurfaceObject: hDDSurface wasn't set to 0\n");
        }
        else if ((peSurface->peDirectDrawLocal != peDirectDrawLocal) ||
                 (!(peSurface->bLost)))
        {
            WARNING("peDdOpenNewSurfaceObject: Couldn't re-use surface\n");
            DEC_EXCLUSIVE_REF_CNT(peSurface);
            peSurface = NULL;
            return(peSurface);
        }

#if DBG
        if (peSurface != NULL)
        {
            DDKSURF(("DDKSURF: Reusing %X (%X)\n", hSurface, peSurface));
        }
#endif
    }

    if (peSurface == NULL)
    {
        peSurface = (EDD_SURFACE*) DdHmgAlloc(sizeof(EDD_SURFACE),
                                              DD_SURFACE_TYPE,
                                              HMGR_ALLOC_LOCK);
        if (peSurface != NULL)
        {
            bSurfaceAlloced = TRUE;

            // Win95's DirectDraw makes a number of allocations that represent
            // a single surface, and have pointers between the different
            // parts.  We make just one allocation and so the pointers refer
            // back to ourselves.  Note that the power of C++ means that
            // 'lpGbl = peSurface' assigns 'lpGbl' the address to the
            // DD_SURFACE_GLOBAL part of 'peSurface':

            peSurface->lpGbl              = peSurface;
            peSurface->lpSurfMore         = peSurface;
            peSurface->lpLcl              = peSurface;

            peSurface->peDirectDrawLocal  = peDirectDrawLocal;
            peSurface->peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            // Remember original creator of this surface (in case for video mode change).

            PDEVOBJ po(peSurface->peDirectDrawGlobal->hdev);

            // and remember which graphics device has association.
            peSurface->pldevCreator           = po.pldev();           // driver
            peSurface->pGraphicsDeviceCreator = po.pGraphicsDevice(); // hardware

            // No locks yet
            peSurface->peMap = NULL;

            // This is new surface, so it keeps lost state initially.
            // The surface will be marked as lost until 'vDdCompleteSurfaceObject'
            // is called on it:

            peSurface->bLost = TRUE;

            DDKSURF(("DDKSURF: Created %X (%X)\n", peSurface->hGet(), peSurface));
        }
    }

    if ((peSurface != NULL) &&
        !(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE))
    {
        // We do this under try ~ except, because pSurfaceGlobal/Local/More
        // could be user mode buffer.

        __try
        {
            peSurface->fpVidMem        = pSurfaceGlobal->fpVidMem;
            peSurface->lPitch          = pSurfaceGlobal->lPitch;
            peSurface->wWidth          = pSurfaceGlobal->wWidth;
            peSurface->wHeight         = pSurfaceGlobal->wHeight;
            peSurface->wWidthOriginal  = pSurfaceGlobal->wWidth;
            peSurface->wHeightOriginal = pSurfaceGlobal->wHeight;
            peSurface->ddpfSurface     = pSurfaceGlobal->ddpfSurface;
            peSurface->ddsCaps         = pSurfaceLocal->ddsCaps;
            // Copy just the driver managed flag
            peSurface->dwFlags        &= ~DDRAWISURF_DRIVERMANAGED;
            peSurface->dwFlags        |= (pSurfaceLocal->dwFlags & DDRAWISURF_DRIVERMANAGED);
            peSurface->ddsCapsEx       = pSurfaceMore->ddsCapsEx;
            peSurface->dwSurfaceHandle = pSurfaceMore->dwSurfaceHandle;
            // Copy the slice pitch for sysmem volume textures
            if ((peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                (peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME))
            {
                peSurface->dwBlockSizeY = pSurfaceGlobal->dwBlockSizeY;
            }

            if (!(peSurface->bLost))
            {
                peSurface->bLost = TRUE;

                // Surface wasn't losted formerly, but here we put null to make it lost forcely.
                // This might causes some leak in driver, but anyway we should decrement
                // active surface count here.

                ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface > 0,
                          "cActiveSurface will be negative");

                peSurface->peDirectDrawLocal->cActiveSurface--;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            if (bSurfaceAlloced)
            {
                DdFreeObject(peSurface, DD_SURFACE_TYPE);
            }
            else
            {
                DEC_EXCLUSIVE_REF_CNT(peSurface);
            }

            peSurface = NULL;
        }
    }

    // if everything went fine, and this is newly allocated surface ...

    if (peSurface && bSurfaceAlloced)
    {
        // Add this to the head of the surface list hanging off the
        // local DirectDraw object.
        //
        // This list is protected because we have exclusive access to
        // the local DirectDraw object:

        InsertHeadList(&(peDirectDrawLocal->ListHead_eSurface),
                       &(peSurface->List_eSurface));

        peDirectDrawLocal->cSurface++;
    }

    return(peSurface);
}

/******************************Public*Routine******************************\
* BOOL bDdValidateSurfaceDescription
*
* Validates surface description information.
* Can be used before surface actually exists to validate data
* prior to creation.
*
*  6-Feb-1998 -by- Drew Bliss [drewb]
* Split from bDdValidateSurfaceObject.
\**************************************************************************/

BOOL
bDdValidateSurfaceDescription(
    DD_SURFACE_GLOBAL* pSurfaceGlobal,
    DD_SURFACE_LOCAL*  pSurfaceLocal
    )
{
    // Protect against math overflow:

    if (!(pSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        if ((pSurfaceGlobal->wWidth > DD_MAXIMUM_COORDINATE)  ||
            (pSurfaceGlobal->wWidth <= 0)                     ||
            (pSurfaceGlobal->wHeight > DD_MAXIMUM_COORDINATE) ||
            (pSurfaceGlobal->wHeight <= 0))
        {
            WARNING("bDdValidateSurfaceDescription: Bad dimensions");
            return(FALSE);
        }

        // dwRGBBitCount is overloaded with dwYUVBitCount:

        if ((pSurfaceGlobal->ddpfSurface.dwRGBBitCount < 1) &&
            !(pSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC))
        {
            WARNING("bDdValidateSurfaceDescription: Bad bit count");
            return(FALSE);
        }

        if (pSurfaceGlobal->ddpfSurface.dwFlags & DDPF_RGB)
        {
            if ((pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 1)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 2)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 4)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 8)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 16) &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 24) &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 32))
            {
                WARNING("bDdValidateSurfaceDescription: "
                        "dwRGBBitCount not 1, 2, 4, 8, 16, 24 or 32");
                return(FALSE);
            }
        }
    }

    return(TRUE);
}
/******************************Public*Routine******************************\
* BOOL bDdValidateSystemMemoryObject
*
* Checks surface description and parameters for an existing
* system-memory surface.
*
* Checks suitable for pre-creation testing should be in
* bDdValidateSurfaceDescription.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdValidateSystemMemoryObject(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface
    )
{
    if (!bDdValidateSurfaceDescription(peSurface, peSurface))
    {
        return FALSE;
    }

    if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        if (ABS(peSurface->lPitch) > 4 * DD_MAXIMUM_COORDINATE)
        {
            WARNING("bDdValidateSurfaceObject: Bad dimensions");
            return(FALSE);
        }

        // The width in bytes must not be more than the pitch.

        if (peSurface->wWidth * peSurface->ddpfSurface.dwRGBBitCount >
            (ULONG) 8 * ABS(peSurface->lPitch))
        {
            WARNING("bDdValidateSurfaceObject: Bad pitch");
            return(FALSE);
        }
    }

    if ((peSurface->fpVidMem & 3) || (peSurface->lPitch & 3))
    {
        WARNING("bDdValidateSurfaceObject: Bad alignment");
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bDdSecureSystemMemorySurface
*
* For system-memory surfaces, the user-mode DirectDraw component allocates
* the actual bits for storage.  Since we will need to access those bits
* from kernel mode for the duration of the life of the surface, we must
* ensure that they're valid user-mode bits and that the pages will never
* be decommitted until the kernel-mode surface is destroyed.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdSecureSystemMemorySurface(
    EDD_SURFACE*    peSurface
    )
{
    FLATPTR fpStart;
    FLATPTR fpEnd;
    DWORD dwHeight;

    // Note that bDdValidateSurfaceObject has already ensured that
    // lPitch, fpVidMem, and the dimensions are "reasonable".

    if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        dwHeight = peSurface->wHeight;
    }
    else
    {
        dwHeight = 1;
    }


    if (peSurface->lPitch >= 0)
    {
        fpStart = peSurface->fpVidMem;
        fpEnd   = fpStart + dwHeight * peSurface->lPitch;
    }
    else
    {
        fpEnd   = peSurface->fpVidMem - peSurface->lPitch;
        fpStart = fpEnd + dwHeight * peSurface->lPitch;
    }


    ASSERTGDI(fpEnd >= fpStart, "Messed up fpStart and fpEnd");

    __try
    {
        ProbeForWrite((VOID*) fpStart, (ULONG)(ULONG_PTR)((BYTE*)fpEnd - (BYTE*)fpStart),
            sizeof(DWORD));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("bDdSecureSystemMemorySurface: fpVidMem wasn't valid and writable");
        return(FALSE);
    }

    peSurface->hSecure = MmSecureVirtualMemory((VOID*) fpStart,
                                               fpEnd - fpStart,
                                               PAGE_READWRITE);

    return(peSurface->hSecure != 0);
}

/******************************Public*Routine******************************\
* VOID vDdCompleteSurfaceObject
*
* Add the object to the surface list and initialize some miscellaneous
* fields.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdCompleteSurfaceObject(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    EDD_SURFACE*            peSurface
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    FLATPTR                 fpStartOffset;
    LONG                    lDisplayPitch;
    DWORD                   dwDepth;
    DWORD                   dwBitsPixel;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    // Calculate the 2-d coordinate 'hint' for 2-d cards so that
    // hopefully they don't need to do these three divides each
    // time they need to use the surface:

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        dwBitsPixel = peSurface->ddpfSurface.dwRGBBitCount;

        if ((dwBitsPixel > 0) && (peSurface->lpVidMemHeap != NULL))
        {
            fpStartOffset =
                peSurface->fpHeapOffset - peSurface->lpVidMemHeap->fpStart;

            if (peSurface->lpVidMemHeap->dwFlags & VMEMHEAP_RECTANGULAR)
            {
                lDisplayPitch = peSurface->lpVidMemHeap->lpHeap->stride;
            }
            else
            {
                lDisplayPitch = 1;
            }
        }
        else
        {
            fpStartOffset = 0;
            lDisplayPitch = 1;
            dwBitsPixel = 1;
        }
    }
    else
    {
        fpStartOffset  = peSurface->fpVidMem
            - peDirectDrawGlobal->HalInfo.vmiData.fpPrimary;
        lDisplayPitch  = peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch;
        dwBitsPixel =
            peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount;
    }

    peSurface->yHint = (LONG) (fpStartOffset / lDisplayPitch);
    peSurface->xHint =
        (LONG) (8 * (fpStartOffset % lDisplayPitch) / dwBitsPixel);

    // Make sure some other flags are correct:

    peSurface->ddsCaps.dwCaps &= ~DDSCAPS_PRIMARYSURFACE;
    if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
    {
        peSurface->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
    }

    // Remember who is creator (needed for driver managed surface).

    peSurface->peDdGlobalCreator = peDirectDrawGlobal;

    // And if this is driver managed surface, keep reference on driver.

    if (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)
    {
        ASSERTGDI(peSurface->fl & DD_SURFACE_FLAG_DRIVER_CREATED,
                  "vDdCompleteSurfaceObject: driver managed surface must be driver created.");

        vDdIncrementReferenceCount(peDirectDrawGlobal);
    }

    // This denotes, among other things, that the surface has been added
    // to the surface list, so on deletion it will have to ben removed
    // from the surface list:

    peSurface->fl |= DD_SURFACE_FLAG_CREATE_COMPLETE;

    // We've had stress failures where there is some funky reuse of the
    // surfaces and we assert because the hbmGdi wasn't cleaned up.  We
    // do it here since we're on the same process as a final check.

    if (peSurface->hbmGdi)
    {
        DxEngDeleteSurface( (HSURF) peSurface->hbmGdi);
        peSurface->hbmGdi = NULL;

        if (peSurface->hpalGdi)
        {
            EngDeletePalette(peSurface->hpalGdi);
            peSurface->hpalGdi = NULL;
        }
    }
}

/******************************Public*Routine******************************\
* HANDLE DxDdCreateSurfaceObject
*
* Creates a kernel-mode representation of the surface, given a location
* in off-screen memory allocated by user-mode DirectDraw.
*
* We expect DirectDraw to already have called DxDdCreateSurface, which
* gives the driver a chance at creating the surface.  In the future, I expect
* all off-screen memory management to be moved to the kernel, with all surface
* allocations being handled via DxDdCreateSurface.  This function call will
* then be extraneous.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdCreateSurfaceObject(
    HANDLE                  hDirectDrawLocal,
    HANDLE                  hSurface,
    PDD_SURFACE_LOCAL       puSurfaceLocal,
    PDD_SURFACE_MORE        puSurfaceMore,
    PDD_SURFACE_GLOBAL      puSurfaceGlobal,
    BOOL                    bComplete       // TRUE if surface is now complete.
                                            // FALSE if we're just creating a
                                            // kernel handle to handle attaches;
                                            // the surface will be filled-out
                                            // and 'completed' in a later call
    )                                       // to DxDdCreateSurfaceObject.
{
    HANDLE                  hRet;
    DD_SURFACE_LOCAL        SurfaceLocal;
    DD_SURFACE_MORE         SurfaceMore;
    DD_SURFACE_GLOBAL       SurfaceGlobal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_SURFACE*            peSurface;

    hRet = 0;

    __try
    {
        SurfaceLocal  = ProbeAndReadStructure(puSurfaceLocal,  DD_SURFACE_LOCAL);
        SurfaceMore   = ProbeAndReadStructure(puSurfaceMore,   DD_SURFACE_MORE);
        SurfaceGlobal = ProbeAndReadStructure(puSurfaceGlobal, DD_SURFACE_GLOBAL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(hRet);
    }

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDrawLocal);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (SurfaceLocal.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            // This is system memory

            peSurface = peDdOpenNewSurfaceObject(peDirectDrawLocal,
                                                 hSurface,
                                                 &SurfaceGlobal,
                                                 &SurfaceLocal,
                                                 &SurfaceMore);
            if (peSurface)
            {
                if (bComplete)
                {
                    if ((bDdValidateSystemMemoryObject(peDirectDrawGlobal,
                                                       peSurface)) &&
                        (bDdSecureSystemMemorySurface(peSurface)))
                    {
                        ASSERTGDI(peSurface->hbmGdi == NULL,
                            "DxDdCreateSurfaceObject: Invalid cached bitmap");

                        // If this surface is in lost state, make it active.

                        if (peSurface->bLost)
                        {
                            peSurface->bLost = FALSE;

                            // Now this surface is ready to go, increment active surface ref. count.

                            peSurface->peDirectDrawLocal->cActiveSurface++;

                            ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface <=
                                      peSurface->peDirectDrawLocal->cSurface,
                                      "cActiveSurface is > than cSurface");
                        }

                        // We were successful, so unlock the surface:

                        hRet = peSurface->hGet();
                        DEC_EXCLUSIVE_REF_CNT(peSurface);   // Unlock
                    }
                    else
                    {
                        // Delete the surface.  Note that it may or may not
                        // yet have been completed:

                        bDdDeleteSurfaceObject(peSurface->hGet(), NULL);
                    }
                }
                else
                {
                    // This must be a complex surface (e.g. MipMap) that is getting called via the attach function.
                    // DDraw should call this again later to complete the surface.

                    hRet = peSurface->hGet();
                    DEC_EXCLUSIVE_REF_CNT(peSurface);   // Unlock
                }
            }
        }
        else if (!(peDirectDrawGlobal->bSuspended))
        {
            // This is any video memory

            peSurface = peDdOpenNewSurfaceObject(peDirectDrawLocal,
                                                 hSurface,
                                                 &SurfaceGlobal,
                                                 &SurfaceLocal,
                                                 &SurfaceMore);
            if (peSurface != NULL)
            {
                if ((bComplete) &&
                    !(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE))
                {
                    // Only the kernel can create vidmem surface objects now, so
                    // if we're asked to 'complete' a surface that the kernel
                    // hasn't allocated, it's an error and no object should
                    // be completed.  This weird code path is actually hit when
                    // user-mode DirectDraw  tries to create a primary surface on
                    // a device whose driver doesn't support DirectDraw.

                    bDdDeleteSurfaceObject(peSurface->hGet(), NULL);
                    WARNING("DxDdCreateSurfaceObject: No DirectDraw driver");
                }
                else
                {
                    if (bComplete)
                    {
                        ASSERTGDI(peSurface->hbmGdi == NULL,
                            "DxDdCreateSurfaceObject: Invalid cached bitmap");

                        // If this surface is in lost state, make it active.

                        if (peSurface->bLost)
                        {
                            peSurface->bLost = FALSE;   // Surface can now be used

                            // Now this surface is ready to go, increment active surface ref. count.

                            peSurface->peDirectDrawLocal->cActiveSurface++;

                            ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface <=
                                      peSurface->peDirectDrawLocal->cSurface,
                                      "cActiveSurface is > than cSurface");
                        }
                    }

                    // No need to call the CreateSurfaceEx here for this case

                    // We were successful, so unlock the surface:

                    hRet = peSurface->hGet();
                    DEC_EXCLUSIVE_REF_CNT(peSurface);   // Unlock
                }
            }
        }
        else
        {
            WARNING("DxDdCreateSurfaceObject: "
                    "Can't create because disabled\n");
        }
    }
    else
    {
        WARNING("DxDdCreateSurfaceObjec: Bad handle or busy\n");
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* BOOL DxDdDeleteSurfaceObject
*
* Deletes a kernel-mode representation of the surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdDeleteSurfaceObject(
    HANDLE  hSurface
    )
{
    return(bDdDeleteSurfaceObject(hSurface, NULL));
}

/******************************Public*Routine******************************\
* ULONG DxDdResetVisrgn
*
* Registers a window for clipping.
*
*   Remembers the current VisRgn state.  Must be called before the VisRgn
* is downloaded and used.
*
* hwnd is currently not used.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdResetVisrgn(
    HANDLE      hSurface,
    HWND        hwnd            //  0 indicates no window clipping
    )                           // -1 indicates any window can be written to
                                // otherwise indicates a particular window
{
    BOOL                    bRet;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_SURFACE        eLockSurface;

    bRet = FALSE;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // We only care about the changes to the primary

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            peSurface->iVisRgnUniqueness = VISRGN_UNIQUENESS();
        }

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ULONG DxDdReenableDirectDrawObject
*
* Resets the DirectDraw object after a mode change or after full-screen.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdReenableDirectDrawObject(
    HANDLE hDirectDrawLocal,
    BOOL*  pubNewMode
    )
{
    BOOL                    b;
    HDC                     hdc;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    bModeChanged;

    b = FALSE;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDrawLocal);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        // Get a DC on this HDEV so we can determine if the app has
        // access to it.  A NULL vis-region will be returned whenever
        // something like a desktop has switched.

        hdc = DxEngGetDesktopDC(DCTYPE_DIRECT, FALSE, FALSE);

        PDEVOBJ po(peDirectDrawGlobal->hdev);

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            if (DxEngGetDCState(hdc,DCSTATE_VISRGNCOMPLEX) != NULLREGION)
            {
                // DirectDraw can't be re-enabled while full-screen, or
                // while USER has told us to disable DirectDraw, or when
                // the colour depth is less than 8bpp:

                if (!(po.bDisabled()) &&
                    !(po.bDeleted()) &&
                    (po.cDirectDrawDisableLocks() == 0) &&
                    (po.iDitherFormat() >= BMF_8BPP) &&
                    (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED))
                {
                    bModeChanged
                        = (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_MODE_CHANGED) != 0;

                    CheckAgpHeaps(peDirectDrawGlobal);

                    MapAllAgpHeaps(peDirectDrawLocal);

                    b = TRUE;

                    peDirectDrawGlobal->bSuspended = FALSE;

                    peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_MODE_CHANGED;

                    __try
                    {
                        ProbeAndWriteStructure(pubNewMode, bModeChanged, BOOL);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }
                }
            }
        }

        if (hdc)
        {
            DxEngDeleteDC(hdc, FALSE);
        }
    }
    else
    {
        WARNING("DxDdReenableDirectDrawObject: Bad handle or busy\n");
    }

    return(b);
}

/******************************Public*Routine******************************\
* HBITMAP hbmDdCreateAndLockGdiSurface
*
* Creates a GDI surface derived from a DirectDraw surface.  This routine
* may call the driver's DdLock function if it hasn't hooked (or fails)
* the DrvDeriveSurface call which gets the driver to wrap a GDI surface
* around a DirectDraw surface.
*
* Note that for the primary (GDI) surface, we can't simply return a handle
* back to the surface stashed in the PDEV.  There are a couple of reasons
* for this:
*
*   o The surface contains the palette, and at 8bpp the palette for
*     a DirectDraw GetDC surface must have the DIB-Section flag set
*     for proper colour matching.  But the primary device surface can
*     not have its palette marked as a DIB-Section.
*
*   o GreSelectBitmap doesn't allow one surface to be selected into more
*     than one DC.
*
*  22-Feb-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HBITMAP
hbmDdCreateAndLockGdiSurface(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface,
    PALETTEENTRY*           puColorTable    // Points to user-mode table
    )
{
    VOID*               pvScan0;
    VOID*               pvBits;
    LONG                cjBits;
    HBITMAP             hbm;
    ULONG               iMode;
    ULONG               cColors;
    ULONG               i;
    ULONG               iFormat = 0;

    // No color table is used for surfaces greater than 8bpp.

    cColors = 0;
    if (peSurface->ddpfSurface.dwRGBBitCount <= 8)
    {
        cColors = 1 << peSurface->ddpfSurface.dwRGBBitCount;

        // Verify that the color table is safe to look at:

        if (puColorTable != NULL)
        {
            __try
            {
                ProbeForRead(puColorTable, cColors * sizeof(PALETTEENTRY), 1);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("hbmDdCreateAndLockGdiSurface: Bad color table pointer");
                return(0);
            }
        }

        // The bitmap's color table can be shared with the primary surface only
        // if both are 8bpp:

        if (puColorTable == NULL)
        {
            if ((peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 8) ||
                (peSurface->ddpfSurface.dwRGBBitCount != 8))
            {
                WARNING("hbmDdCreateAndLockGdiSurface: Can't create shared palettes");
                return(0);
            }
        }
    }

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    if (peSurface->hbmGdi != NULL)
    {
        // Ah ha, we already have a cached GDI surface.  See if we need
        // to call 'Lock', and then get out:

        SURFOBJ* pso;

        if ((pso = EngLockSurface((HSURF)(peSurface->hbmGdi))) != NULL)
        {
            if (peSurface->fl & DD_SURFACE_FLAG_BITMAP_NEEDS_LOCKING)
            {
                pvScan0 =
                    pDdLockSurfaceOrBuffer(peSurface, FALSE, NULL, DDLOCK_WAIT, NULL);

                ASSERTGDI(pvScan0 != NULL,
                    "Driver failed lock call when it succeeded it before.  Tsk, tsk");

                // The drivers allowed to move the surface around between locks, so
                // update the bitmap address:
                if ((pvScan0 != pso->pvScan0) &&
                    (pvScan0 != NULL))
                {
                    pso->pvScan0 = pvScan0;
                    pso->pvBits  = pvScan0;
                }
            }

            // If it's 8bpp or less, we have to update the color table.

            if (peSurface->ddpfSurface.dwRGBBitCount <= 8)
            {
                // Update the color table.

                // Note that the scumy application might have delete the cached
                // bitmap, so we have to check for bValid() here.  (It's been a
                // bad app, so we just protect against crashing, and don't bother
                // to re-create a good bitmap for him.)

                DxEngUploadPaletteEntryToSurface(po.hdev(),pso,puColorTable,cColors);
            }

            EngUnlockSurface(pso);
        }
    }
    else
    {
        // Okay, we have to create a GDI surface on the spot.
        //
        // First, The DirectDraw surface must be marked as RGB (even at 8bpp).
        // GDI doesn't (yet) support drawing to YUV surfaces or the like.  It
        // also doesn't support 2bpp surfaces.

        if ((peSurface->ddpfSurface.dwFlags & DDPF_RGB) &&
            (peSurface->ddpfSurface.dwRGBBitCount != 2))
        {
            // We have to have the devlock since we'll be grunging around in
            // the PDEV:

            DD_ASSERTDEVLOCK(peDirectDrawGlobal);

            switch (peSurface->ddpfSurface.dwRGBBitCount)
            {
            case 1:
                iFormat = BMF_1BPP; break;
            case 4:
                iFormat = BMF_4BPP; break;
            case 8:
                iFormat = BMF_8BPP; break;
            case 16:
                iFormat = BMF_16BPP; break;
            case 24:
                iFormat = BMF_24BPP; break;
            case 32:
                iFormat = BMF_32BPP; break;
            default:
                RIP("hbmDdCreateAndLockGdiSurface: Illegal dwRGBBitCount\n");
            }

            iMode = (iFormat <= BMF_8BPP) ? PAL_INDEXED : PAL_BITFIELDS;

            HPALETTE hpal = EngCreatePalette(iMode,
                                       cColors,
                                       (ULONG*) puColorTable,
                                       peSurface->ddpfSurface.dwRBitMask,
                                       peSurface->ddpfSurface.dwGBitMask,
                                       peSurface->ddpfSurface.dwBBitMask);

            if (hpal)
            {
                if ((cColors == 256) && (puColorTable == NULL))
                {
                    ASSERTGDI(po.bIsPalManaged(), "Expected palettized display");

                    // Make this palette share the same colour table as the
                    // screen, so that we always get identity blts:

                    DxEngSyncPaletteTableWithDevice(hpal,po.hdev());
                }

                hbm = 0;

                // First, try getting the driver to create the surface, assuming
                // it's a video memory surface.

                if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                    PPFNVALID(po, DeriveSurface))
                {
                    hbm = PPFNDRV(po, DeriveSurface)(peDirectDrawGlobal,
                                                     peSurface);
                    if (hbm)
                    {
                        SURFOBJ* pso = EngLockSurface((HSURF)hbm);
                        if (pso)
                        {
                            // Mark surface as DirectDraw surface.

                            DxEngMarkSurfaceAsDirectDraw(pso,peSurface->hGet());

                            // Select the created palette to surface palette.

                            DxEngSelectPaletteToSurface(pso,hpal);

                            EngUnlockSurface(pso);
                        }
                        else
                        {
                            EngDeleteSurface((HSURF)hbm);
                            hbm = 0;
                        }
                    }
                }

                // Next, try getting GDI to create the surface:

                if (hbm == 0)
                {
                    // Note that this lock will fail when the PDEV isn't active,
                    // meaning that GetDC will return 0 when full-screen.
                    // GDI won't barf on any calls where the HDC is passed in as
                    // 0, so this is okay.

                    pvScan0 = pDdLockSurfaceOrBuffer(peSurface, FALSE,
                                                     NULL, DDLOCK_WAIT, NULL);
                    if (pvScan0 != NULL)
                    {
                        FLONG fl;
                        SIZEL sizl;

                        sizl.cx = peSurface->wWidth;
                        sizl.cy = peSurface->wHeight;
                        fl      = BMF_TOPDOWN;
                        pvBits  = pvScan0;
                        cjBits  = (LONG) peSurface->wHeight * peSurface->lPitch;
                        if (cjBits < 0)
                        {
                            fl = 0;
                            cjBits = -cjBits;
                            pvBits = (BYTE*) pvScan0 - cjBits - peSurface->lPitch;
                        }

                        hbm = EngCreateBitmap(sizl,
                                              0,
                                              iFormat,
                                              fl,
                                              pvBits);

                        // Mark the palette as a DIB-Section so that any color-
                        // matching on the DC actually uses the entire device
                        // palette, NOT what the logical palette selected into
                        // the DC.

                        DxEngSetPaletteState(hpal,PALSTATE_DIBSECTION,(ULONG_PTR)TRUE);

                        if (hbm)
                        {
                            SURFOBJ* pso = EngLockSurface((HSURF) hbm);
                            if (pso)
                            {
                                peSurface->fl |= DD_SURFACE_FLAG_BITMAP_NEEDS_LOCKING;

                                // Select the created palette to surface palette.

                                DxEngSelectPaletteToSurface(pso,hpal);

                                // Mark surface as DirectDraw surface.

                                DxEngMarkSurfaceAsDirectDraw(pso,peSurface->hGet());

                                // Override some fields which we couldn't specify in
                                // the 'EngCreateBitmap' call.  The following 3 are due to
                                // the fact that we couldn't pass in a stride:

                                pso->lDelta    = peSurface->lPitch;
                                pso->pvScan0   = pvScan0;
                                pso->cjBits    = cjBits;
                                pso->fjBitmap |= BMF_DONTCACHE;

                                if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                                {
                                    pso->fjBitmap |= BMF_NOTSYSMEM;
                                }

                                EngUnlockSurface(pso);
                            }
                            else
                            {
                                EngDeleteSurface((HSURF)hbm);
                                hbm = 0;
                            }
                        }
                        else
                        {
                            bDdUnlockSurfaceOrBuffer(peSurface);
                        }
                    }
                }

                if (hbm)
                {
                    // Success, we're done!
                    //
                    // Set handle owner to current process.

                    DxEngSetBitmapOwner(hbm, OBJECT_OWNER_CURRENT);

                    peSurface->hbmGdi = hbm;

                    // TODO: Palette needs to be owned by this process.

                    peSurface->hpalGdi = hpal;
                }
                else
                {
                    EngDeletePalette(hpal);
                }
            }
        }
        else if (!(peSurface->ddpfSurface.dwFlags & DDPF_ZBUFFER))
        {
            WARNING("hbbDdCreateAndLockGdiSurface: Invalid surface or RGB type\n");
        }
    }

    return(peSurface->hbmGdi);
}

/******************************Public*Routine******************************\
* VOID vDdUnlockGdiSurface
*
* Unlocks the view required for the GDI bitmap if necessary (that is, if
* the driver didn't hook DrvDeriveSurface, or failed it).
*
*  22-Feb-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL
vDdUnlockGdiSurface(
    EDD_SURFACE*    peSurface
    )
{
    if (peSurface->fl & DD_SURFACE_FLAG_BITMAP_NEEDS_LOCKING)
    {
        bDdUnlockSurfaceOrBuffer(peSurface);
    }
}

/******************************Public*Routine******************************\
* HDC DxDdGetDC
*
* Creates a DC that can be used to draw to an off-screen DirectDraw
* surface.
*
* Essentially, this works as follows:
*
*   o Do a DirectDraw Lock on the specified surface;
*   o CreateDIBSection of the appropriate format pointing to that surface;
*   o CreateCompatibleDC to get a DC;
*   o Select the DIBSection into the compatible DC
*
* At 8bpp, however, the DIBSection is not a 'normal' DIBSection.  It's
* created with no palette so that it it behaves as a device-dependent
* bitmap: the color table is the same as the display.
*
* GDI will do all drawing to the surface using the user-mode mapping of
* the frame buffer.  Since all drawing to the created DC will occur in the
* context of the application's process, this is not a problem.  We do have
* to watch out that we don't blow away the section view while a thread is
* in kernel-mode GDI drawing; however, this problem would have to be solved
* even if using a kernel-mode mapping of the section because we don't want
* any drawing intended for an old PDEV to get through to a new PDEV after
* a mode change has occured, for example.
*
* A tricky part of GetDC is how to blow away the surface lock while a thread
* could be in kernel-mode GDI about to draw using the surface pointer.  We
* solve that problem by changing the DC's VisRgn to be an empty region when
* trying to blow away all the surface locks.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
DxDdGetDC(
    HANDLE          hSurface,
    PALETTEENTRY*   puColorTable
    )
{
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HDC                     hdc;
    HBITMAP                 hbm;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        // DirectDraw doesn't let an application have more than one active
        // GetDC DC to a surface at a time:

        if (peSurface->hdc != 0)
        {
            return(0);
        }

        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // Grab the devlock because hbmDdCreateAndLockGdiSurface grunges
        // around in the global data.

        EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

        if (!peSurface->bLost)
        {
            // Note that 'hbmDdCreateAndLockGdiSurface' keeps a bitmap cache,
            // so this should usually be pretty quick:

            hbm = hbmDdCreateAndLockGdiSurface(peDirectDrawGlobal,
                                               peSurface,
                                               puColorTable);
            if (hbm != NULL)
            {
                // First, try to get a DC from the cache:

                hdc = (HDC) peDirectDrawGlobal->hdcCache;
                if (hdc != NULL)
                {
                    // This will succeed only if we atomically managed to
                    // grab the cached DC (there may be other threads
                    // calling 'bDdReleaseDC' at exactly the same time).

                    if (InterlockedCompareExchangePointer(
                                &peDirectDrawGlobal->hdcCache,
                                NULL,
                                (VOID*) hdc) == hdc)
                    {

                        // Set the DC's ownership to the current process so
                        // that it will get cleaned up if the process terminates
                        // unexpectedly.

                        BOOL bSet = DxEngSetDCOwner(hdc, OBJECT_OWNER_CURRENT);

                        ASSERTGDI(bSet, "DxDdGetDC: Cached DC was invalid");
                    }
                    else
                    {
                        hdc = NULL;
                    }
                }

                if (hdc == NULL)
                {
                    // Now, create the DC for the actual drawing, owned by the
                    // current process.

                    hdc = DxEngCreateMemoryDC(peDirectDrawGlobal->hdev);
                }

                if (hdc)
                {
                    // Finally, select our surface into the DC.  It
                    // doesn't matter if this fails for some bizarre
                    // reason; the default bitmap will be stuck in there
                    // instead.

                    HBITMAP hbmOld = DxEngSelectBitmap(hdc, hbm);

                    ASSERTGDI(hbmOld, "DxDdGetDC: Invalid selection");

                    peSurface->hdc = hdc;

                    // I'm paranoid, so let's verify that we've set things
                    // up correctly:

                    #if 0 // TODO: DBG - DC
                    {
                        DCOBJ dco(hdc);
                        ASSERTGDI(dco.bValid(),
                            "DxDdGetDC: Should have a valid DC");
                        ASSERTGDI(!dco.bFullScreen(),
                            "DxDdGetDC: DC shouldn't be disabled");
                        ASSERTGDI(dco.bSynchronizeAccess(),
                            "DxDdGetDC: Should mark devlock needed");
                        ASSERTGDI(dco.pSurfaceEff()->bDirectDraw(),
                            "DxDdGetDC: Should mark as DDraw surface");
                        ASSERTGDI(dco.dctp() == DCTYPE_MEMORY,
                            "DxDdGetDC: Should be memory DC");
                    }
                    #endif

                    // For debugging purposes:

                    ghdcGetDC = hdc;

                    return(hdc);
                }

                vDdUnlockGdiSurface(peSurface);
            }
            else
            {
                WARNING("DxDdGetDC: hbmDdCreateAndLockGdiSurface failed\n");
            }
        }
    }
    else
    {
        WARNING("DxDdGetDC: Couldn't lock the surface\n");
    }

    return(0);
}

/******************************Public*Routine******************************\
* BOOL bDdReleaseDC
*
* Deletes a DC created via DdGetDC.
*
* The devlock should not be held when entering this function.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdReleaseDC(
    EDD_SURFACE*    peSurface,
    BOOL            bForce              // True when cleaning up surface
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    bRet = FALSE;
    BOOL                    bClean;
    HDC                     hdc;

    hdc = peSurface->hdc;
    if (hdc)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

#if 0 // Temporary disable DC cache for bug 176728

        // See if there's already a DC in the one-deep cache:

        if (!peDirectDrawGlobal->hdcCache)
        {
            // Okay, it looks like we can cache this DC.  Clean it up first,
            // which among other things unselects the current DirectDraw
            // GDI surface.  Then set the owner to 'none' so that it
            // doesn't get deleted when the current process terminates and
            // no one can touch it until we pick up from cache.

            if (DxEngCleanDC(hdc) &&
                DxEngSetDCOwner(hdc, OBJECT_OWNER_NONE))
            {
                // Atomically try to stick the DC into the cache.  Note that
                // it's okay if this fails and we fall into 'bDeleteDCInternal',
                //
                // Note that we use 'InterlockedCompareExchangePointer' so that
                // we can avoid acquiring the devlock in most cases through
                // bDdReleaseDC.  So if someone changes this code to acquire
                // the devlock, there's really no pointer in doing this via
                // an Interlocked method.

                if (InterlockedCompareExchangePointer(
                                &peDirectDrawGlobal->hdcCache,
                                (VOID*) hdc,
                                NULL) == NULL)
                {
                    // Success, we cached the DC!

                    hdc = NULL;
                }
                else
                {
                    // Need to be belonging to current process in order to delete.
                    // since we already changed the owner to 'none' above.

                    DxEngSetDCOwner(hdc, OBJECT_OWNER_CURRENT);
                }
            }
            else
            {
                WARNING("bDdReleaseDC: Not caching DC, app may have deleted it");
            }
        }

#endif

        if (hdc)
        {
            // There's already a DC in the cache.  So delete this one.
            //
            // Note that the application could have called DeleteObject(hdc)
            // or SelectObject(hdc, hSomeOtherBitmap) with the DC we gave
            // them.  That's okay, though: nothing will crash, just some of
            // the below operations may fail because they've already been
            // done:

            if (!DxEngDeleteDC(hdc, TRUE))
            {
                WARNING("bDdReleaseDC: Couldn't delete DC\n");
            }
        }

        // Call the driver's DdUnlock if necessary:

        vDdUnlockGdiSurface(peSurface);

        peSurface->hdc = NULL;

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DxDdReleaseDC
*
* User-mode callable routine to delete a DC created via DdGetDC.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdReleaseDC(
    HANDLE  hSurface
    )
{
    BOOL               bRet;
    EDD_LOCK_SURFACE   eLockSurface;
    EDD_SURFACE*       peSurface;

    bRet = FALSE;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
    bRet = bDdReleaseDC(peSurface, FALSE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DxDdAttachSurface
*
* Transmogrified from Win95's ddsatch.c AddAttachedSurface.  Don't blame
* me for this wonderful attach system; the attach links are used by drivers
* and so we have to be compatible with Win95.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdAttachSurface(
    HANDLE  hSurfaceFrom,   // hSurfaceFrom will point 'to' hSurfaceTo
                            //   (think of this as the main surface)
    HANDLE  hSurfaceTo      // hSurfaceTo will point 'from' hSurfaceFrom
    )                       //   (think of this as the secondary surface)
{
    EDD_LOCK_SURFACE    eLockSurfaceFrom;
    EDD_LOCK_SURFACE    eLockSurfaceTo;
    EDD_SURFACE*        peSurfaceFrom;
    EDD_SURFACE*        peSurfaceTo;
    DD_ATTACHLIST*      pAttachFrom;
    DD_ATTACHLIST*      pAttachTo;
    DD_ATTACHLIST*      pAttach;
    DD_ATTACHLIST*      pAttachTemp;
    BOOL                bAttach;
    BOOL                bRet;

    bRet = FALSE;           // Assume failure

    peSurfaceFrom = eLockSurfaceFrom.peLock(hSurfaceFrom);
    peSurfaceTo   = eLockSurfaceTo.peLock(hSurfaceTo);
    if ((peSurfaceFrom != NULL) && (peSurfaceTo != NULL))
    {
        if (peSurfaceFrom->peDirectDrawLocal == peSurfaceTo->peDirectDrawLocal)
        {
            // Use the devlock to synchronize additions and deletions to
            // the attach list:

            EDD_DEVLOCK eDevLock(peSurfaceFrom->peDirectDrawGlobal);

            // First, see if the surface is already attached or in the
            // chain.  If so, don't add it again

            bAttach = TRUE;
            for (pAttach = peSurfaceFrom->lpAttachListFrom;
                 pAttach != NULL;
                 pAttach = pAttach->lpAttached->lpAttachListFrom)
            {
                for (pAttachTemp = pAttach;
                    pAttachTemp != NULL;
                    pAttachTemp = pAttachTemp->lpLink)
                {
                    if (pedFromLp(pAttachTemp->lpAttached) == peSurfaceTo)
                        bAttach = FALSE;
                }
            }
            for (pAttach = peSurfaceTo->lpAttachList;
                 pAttach != NULL;
                 pAttach = pAttach->lpAttached->lpAttachList)
            {
                for (pAttachTemp = pAttach;
                    pAttachTemp != NULL;
                    pAttachTemp = pAttachTemp->lpLink)
                {
                    if (pedFromLp(pAttachTemp->lpAttached) == peSurfaceTo)
                        bAttach = FALSE;
                }
            }

            if (bAttach)
            {
                pAttachFrom = (DD_ATTACHLIST*) PALLOCMEM(sizeof(*pAttachFrom),
                                                         'addG');
                if (pAttachFrom != NULL)
                {
                    pAttachTo = (DD_ATTACHLIST*) PALLOCMEM(sizeof(*pAttachTo),
                                                           'addG');
                    if (pAttachTo != NULL)
                    {
                        pAttachFrom->lpAttached = peSurfaceTo;
                        pAttachFrom->lpLink = peSurfaceFrom->lpAttachList;
                        peSurfaceFrom->lpAttachList = pAttachFrom;

                        pAttachTo->lpAttached = peSurfaceFrom;
                        pAttachTo->lpLink = peSurfaceTo->lpAttachListFrom;
                        peSurfaceTo->lpAttachListFrom = pAttachTo;

                        vDdUpdateMipMapCount(peSurfaceTo);
                        bRet = TRUE;
                    }

                    if (!bRet)
                    {
                        VFREEMEM(pAttachFrom);
                    }
                }
            }
            else
            {
                WARNING("DxDdAttachSurface: Surfaces already attached");
                bRet = TRUE;
            }
        }
        else
        {
            WARNING("DxDdAttachSurface: Surfaces not for same device");
        }
    }
    else
    {
        WARNING("DxDdAttachSurface: Invalid surface specified");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID DxDdUnattachSurface
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxDdUnattachSurface(
    HANDLE  hSurface,
    HANDLE  hSurfaceAttached
    )
{
    EDD_LOCK_SURFACE    eLockSurface;
    EDD_LOCK_SURFACE    eLockSurfaceAttached;
    EDD_SURFACE*        peSurface;
    EDD_SURFACE*        peSurfaceAttached;

    peSurface         = eLockSurface.peLock(hSurface);
    peSurfaceAttached = eLockSurfaceAttached.peLock(hSurfaceAttached);
    if ((peSurface != NULL) && (peSurfaceAttached != NULL))
    {
        // Use the devlock to synchronize additions and deletions to
        // the attach list:

        EDD_DEVLOCK eDevLock(peSurface->peDirectDrawGlobal);

        if (bDdRemoveAttachedSurface(peSurface, peSurfaceAttached))
        {
            vDdUpdateMipMapCount(peSurface);
            vDdUpdateMipMapCount(peSurfaceAttached);
        }
        else
        {
            WARNING("DxDdUnattachSurface: Surface not attached");
        }
    }
    else
    {
        WARNING("DxDdUnattachSurface: Invalid surface specified");
    }
}

/******************************Public*Routine******************************\
* DWORD dwDdBltViaGdi
*
* This routine will attempt to do a non-stretching, non-system-memory to
* non-system-memory blt, or system-memory to non-system-memory blt via the
* driver's CopyBits routine.  The motivation for this is two-fold:
*
* 1.  If the system-memory to video-memory blt has to be emulated, we can
*     do a better emulation job here from the kernel than the HEL can from
*     user-mode, where it has to call Lock/Unlock.  We get a couple of
*     benefits:
*
*           o We can do the blt in one kernel-mode transition, instead
*             of the two previously needed for the lock and unlock;
*
*           o Because we don't have to hold from user-mode a DirectDraw Lock
*             on the video memory, we don't run the risk of having to
*             redraw if the clipping changes asynchronously;
*
*           o We can handle blts underneath emulated sprites without having
*             to tear down the sprites, by virtue of going through
*             SpCopyBits.  This means, among other things, that the
*             cursor won't flash.
*
* 2.  For non-system-memory to video-memory blts, we can handle blts to the
*     underneath emulated sprites without having to tear down the sprites,
*     by virtue of going through SpCopyBits.
*
* Returns DDHAL_DRIVER_HANDLED if GDI handled the blt; DDHAL_DRIVER_NOTHANDLED
* if the blt should be handled by the driver's HAL.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
dwDdBltViaGdi(
    EDD_SURFACE*    peSurfaceDest,
    EDD_SURFACE*    peSurfaceSrc,
    DD_BLTDATA*     pBltData
    )
{
    DWORD                   dwRet = DDHAL_DRIVER_NOTHANDLED;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HBITMAP                 hbmDest;
    HBITMAP                 hbmSrc;
    BOOL                    bGdiCandidate;

    // If the sources are compatible, and the destination is video-memory,
    // we may want to call the driver through GDI.  We do this primarily
    // to handle blts that occur underneath  emulated sprites, so that we
    // don't have to tear down the sprite.

    if ((peSurfaceSrc != NULL) &&
        (peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        peDirectDrawGlobal = peSurfaceDest->peDirectDrawGlobal;

        PDEVOBJ po(peDirectDrawGlobal->hdev);

        // We're acting as the HEL for system-memory to video-memory
        // blts, and so those cases always have to go through GDI.
        //
        // Otherwise, we go through CopyBits only if:
        //
        //    o The destination is the primary GDI surface;
        //    o Sprites are visible;
        //    o The source surface can be accelerated;
        //    o There isn't a stretch.

        bGdiCandidate = FALSE;

        // If we're emulating system-memory to video-memory blts, we have
        // to take all system-memory to video-memory blts here (we never
        // said we'd do stretches or anything weird, but we don't want to
        // pass any system-memory to video-memory calls at all to the driver,
        // since it may fall-over when it gets a surface type it doesn't
        // expect).

        if ((peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
            (peDirectDrawGlobal->flDriver & DD_DRIVER_FLAG_EMULATE_SYSTEM_TO_VIDEO) &&
            (peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))
        {
            bGdiCandidate = TRUE;

            // As a robustness thing, don't let *any* system-memory to video-
            // memory blts down to the driver if it didn't ask for it.

            dwRet = DDHAL_DRIVER_HANDLED;
        }

        // If the destination is the primary GDI surface and any sprites
        // are visible, we also vector through GDI in order to be able to
        // handle blts underneath sprites without flashing.

        else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                 (DxEngSpSpritesVisible(peDirectDrawGlobal->hdev)) &&
                 ((PPFNVALID(po, DeriveSurface)) ||
                  (peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)))
        {
            bGdiCandidate = TRUE;
        }

        // Add cases where CopyBits can not handle the blit
        //
        // 1. color keying
        // 2. FX blit(mirror)
        // 3. Blit has color space conversion, e.g. YUV to RGB

        if (bGdiCandidate)
        {
            bGdiCandidate=FALSE;

            if (!(pBltData->dwFlags & (DDBLT_KEYSRCOVERRIDE |
                                      DDBLT_KEYDESTOVERRIDE |
                                      DDBLT_KEYSRC |
                                      DDBLT_KEYDEST |
                                      DDBLT_DDFX)) &&
                 (peSurfaceDest->ddpfSurface.dwRGBBitCount
                     == peSurfaceSrc->ddpfSurface.dwRGBBitCount))
            {
                DWORD dwDestFlags = peSurfaceDest->ddpfSurface.dwFlags;
                DWORD dwSrcFlags  = peSurfaceSrc->ddpfSurface.dwFlags;

                dwDestFlags &= (DDPF_RGB|DDPF_PALETTEINDEXED8);
                dwSrcFlags &= (DDPF_RGB|DDPF_PALETTEINDEXED8);

                if ((dwDestFlags != 0) && (dwDestFlags==dwSrcFlags))
                {
                    if (!(dwSrcFlags & DDPF_PALETTEINDEXED8))
                    {
                        if ((peSurfaceDest->ddpfSurface.dwRBitMask
                                == peSurfaceSrc->ddpfSurface.dwRBitMask) &&
                              (peSurfaceDest->ddpfSurface.dwGBitMask
                                == peSurfaceSrc->ddpfSurface.dwGBitMask) &&
                              (peSurfaceDest->ddpfSurface.dwBBitMask
                                == peSurfaceSrc->ddpfSurface.dwBBitMask))
                        {
                            bGdiCandidate=TRUE;
                        }
                    }
                    else
                    {
                        bGdiCandidate=TRUE;
                    }
                }
            }
        }

        if ((bGdiCandidate)                                      &&
            ((pBltData->rDest.right - pBltData->rDest.left)
                == (pBltData->rSrc.right - pBltData->rSrc.left)) &&
            ((pBltData->rDest.bottom - pBltData->rDest.top)
                == (pBltData->rSrc.bottom - pBltData->rSrc.top)))
        {
            // At this point, GDI is definitely going to handle the
            // blt (or die trying):

            dwRet = DDHAL_DRIVER_HANDLED;
            pBltData->ddRVal = DD_OK;

            // If a hardware flip is pending on this surface, then wait for
            // the flip to finish before continuing:

            if (peSurfaceDest->fl & DD_SURFACE_FLAG_FLIP_PENDING)
            {
                ASSERTGDI(
                    (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_GETFLIPSTATUS) &&
                    peDirectDrawGlobal->SurfaceCallBacks.GetFlipStatus,
                    "Flip pending but GetFlipStatus unsupported by driver?");

                DD_GETFLIPSTATUSDATA GetFlipStatusData;
                DWORD dwFlipRet;

                GetFlipStatusData.lpDD = peDirectDrawGlobal;
                GetFlipStatusData.lpDDSurface = peSurfaceDest;
                GetFlipStatusData.dwFlags = DDGFS_ISFLIPDONE;
                GetFlipStatusData.GetFlipStatus = NULL;
                GetFlipStatusData.ddRVal = DDERR_GENERIC;

                do
                {
                    dwFlipRet = peDirectDrawGlobal->
                        SurfaceCallBacks.GetFlipStatus(&GetFlipStatusData);

                } while (
                    (dwFlipRet == DDHAL_DRIVER_HANDLED) &&
                    (GetFlipStatusData.ddRVal == DDERR_WASSTILLDRAWING));

                peSurfaceDest->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
            }

            // If the surfaces are primary (GDI) surfaces, just use
            // the GDI surface we have stashed in the PDEV:

            hbmDest = (HBITMAP) po.hsurf();
            hbmSrc  = (HBITMAP) po.hsurf();

            if (!(peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                hbmDest = hbmDdCreateAndLockGdiSurface(peDirectDrawGlobal,
                                                       peSurfaceDest,
                                                       NULL);
            }

            if (!(peSurfaceSrc->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                hbmSrc = hbmDdCreateAndLockGdiSurface(peDirectDrawGlobal,
                                                      peSurfaceSrc,
                                                      NULL);
            }

            SURFOBJ *psoDest = EngLockSurface((HSURF) hbmDest);
            SURFOBJ *psoSrc  = EngLockSurface((HSURF) hbmSrc);

            if (psoDest && psoSrc)
            {
                PDEVOBJ po(peDirectDrawGlobal->hdev);

                // A malicious app may have given us stretch values on
                // system-memory to video-memory blts, so check:

                if (((pBltData->rDest.right - pBltData->rDest.left)
                    == (pBltData->rSrc.right - pBltData->rSrc.left)) &&
                    ((pBltData->rDest.bottom - pBltData->rDest.top)
                    == (pBltData->rSrc.bottom - pBltData->rSrc.top)))
                {
                    (*PPFNGET(po, CopyBits, SURFOBJ_HOOK(psoDest)))
                         (psoDest,
                          psoSrc,
                          NULL,
                          NULL,
                          &pBltData->rDest,
                          (POINTL*) &pBltData->rSrc);
                }
            }

            if (psoDest)
            {
                EngUnlockSurface(psoDest);
            }

            if (psoSrc)
            {
                EngUnlockSurface(psoSrc);
            }

            if (!(peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                vDdUnlockGdiSurface(peSurfaceDest);
            }

            if (!(peSurfaceSrc->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                vDdUnlockGdiSurface(peSurfaceSrc);
            }
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdBlt
*
* DirectDraw blt.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdBlt(
    HANDLE      hSurfaceDest,
    HANDLE      hSurfaceSrc,
    PDD_BLTDATA puBltData
    )
{
    DWORD       dwRet;
    DD_BLTDATA  BltData;
#ifdef DX_REDIRECTION
    HWND        hWnd;
#endif // DX_REDIRECTION

    __try
    {
        ProbeForRead(puBltData, sizeof(DD_BLTDATA), sizeof(DWORD));

        // To save some copying time, we copy only those fields which are
        // supported for NT drivers:

        BltData.rDest.left            = puBltData->rDest.left;
        BltData.rDest.top             = puBltData->rDest.top;
        BltData.rDest.right           = puBltData->rDest.right;
        BltData.rDest.bottom          = puBltData->rDest.bottom;
        BltData.rSrc.left             = puBltData->rSrc.left;
        BltData.rSrc.top              = puBltData->rSrc.top;
        BltData.rSrc.right            = puBltData->rSrc.right;
        BltData.rSrc.bottom           = puBltData->rSrc.bottom;

        BltData.dwFlags               = puBltData->dwFlags;
        BltData.bltFX.dwFillColor     = puBltData->bltFX.dwFillColor;
        BltData.bltFX.ddckSrcColorkey = puBltData->bltFX.ddckSrcColorkey;
        BltData.bltFX.ddckDestColorkey= puBltData->bltFX.ddckDestColorkey;
        BltData.bltFX.dwDDFX          = puBltData->bltFX.dwDDFX;

#ifdef DX_REDIRECTION
        // DD_BLTDATA.Blt member contains hWnd.
        hWnd                          = (HWND)(puBltData->Blt);
#endif // DX_REDIRECTION
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet          = DDHAL_DRIVER_NOTHANDLED;
    BltData.ddRVal = DDERR_GENERIC;

#ifdef DX_REDIRECTION
    // if hWnd is given and redirection is enabled on the hWnd,
    // we just fail this call here, and let ddraw runtime to uses
    // emulation code, which eventually call GDI Blt functions.

    if (hWnd)
    {
        if (DxEngGetRedirectionBitmap(hWnd))
        {
            return(dwRet);
        }
    }
#endif // DX_REDIRECTION

    EDD_SURFACE*            peSurfaceDest;
    EDD_SURFACE*            peSurfaceSrc;
    DWORD                   dwFlags;
    EDD_LOCK_SURFACE        eLockSurfaceDest;
    EDD_LOCK_SURFACE        eLockSurfaceSrc;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwSrcCaps;
    DWORD                   dwDestCaps;
    DDNTCORECAPS*           pCaps;
    BOOL                    bUnTearDown;

    peSurfaceDest = eLockSurfaceDest.peLock(hSurfaceDest);
    BltData.lpDDDestSurface = peSurfaceDest;

    if (peSurfaceDest != NULL)
    {
        peDirectDrawGlobal = peSurfaceDest->peDirectDrawGlobal;

        // We support only a specific set of Blt calls down to the driver
        // that we're willing to support and to test.

        dwFlags = BltData.dwFlags;
        if (((dwFlags & (DDBLT_ROTATIONANGLE)) == 0) &&
            ((dwFlags & (DDBLT_ROP
                       | DDBLT_COLORFILL
                       | DDBLT_DEPTHFILL)) != 0))
        {
            // I think ROPs are goofy, so we always tell the application
            // that our hardware can only do SRCCOPY blts, but we should
            // make sure the driver doesn't fall over if it gets something
            // unexpected.  And they can look at this even if DDBLT_DDFX
            // isn't set:

            BltData.bltFX.dwROP = 0xCC0000; // SRCCOPY in DirectDraw format

            // No support for IsClipped for now -- we would have to
            // validate and copy the prDestRects array:

            BltData.IsClipped = FALSE;

            if (dwFlags & DDBLT_DDFX)
            {
                // The only DDBLT_DDFX functionality we allow down to the
                // driver is DDBLTFX_NOTEARING:
                //           DDBLTFX_MIRRORLEFTRIGHT
                //           DDBLTFX_MIRRORUPDOWN

                if (BltData.bltFX.dwDDFX & ~(DDBLTFX_NOTEARING
                                            |DDBLTFX_MIRRORLEFTRIGHT
                                            |DDBLTFX_MIRRORUPDOWN)
                                            )
                {
                    WARNING("DxDdBlt: Invalid dwDDFX\n");
                    return(dwRet);
                }
            }

            if (dwFlags & (DDBLT_COLORFILL | DDBLT_DEPTHFILL))
            {
                // Do simpler stuff 'cause we don't need to lock a source:

                BltData.lpDDSrcSurface = NULL;
                peSurfaceSrc = NULL;

                if (peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    WARNING("DxDdBlt: Can't blt to system memory surface");
                    return(dwRet);
                }
            }
            else
            {
                // Lock the source surface:

                peSurfaceSrc = eLockSurfaceSrc.peLock(hSurfaceSrc);
                BltData.lpDDSrcSurface = peSurfaceSrc;

                // Ensure that both surfaces belong to the same DirectDraw
                // object, and check source rectangle:

                if ((peSurfaceSrc == NULL)                               ||
                    (peSurfaceSrc->peDirectDrawLocal !=
                            peSurfaceDest->peDirectDrawLocal)            ||
                    (BltData.rSrc.left   < 0)                            ||
                    (BltData.rSrc.top    < 0)                            ||
                    (BltData.rSrc.right  > (LONG) peSurfaceSrc->wWidth)  ||
                    (BltData.rSrc.bottom > (LONG) peSurfaceSrc->wHeight) ||
                    (BltData.rSrc.left  >= BltData.rSrc.right)           ||
                    (BltData.rSrc.top   >= BltData.rSrc.bottom))
                {
                    WARNING("DxDdBlt: Invalid source surface or source rectangle\n");
                    return(dwRet);
                }

                // Make sure the blts are between surface types that the
                // driver will expect, otherwise the driver may fall-over
                // if called with NtCrash or some other malicious program.

                dwSrcCaps = peSurfaceSrc->ddsCaps.dwCaps;
                dwDestCaps = peSurfaceDest->ddsCaps.dwCaps;
                pCaps = &peDirectDrawGlobal->HalInfo.ddCaps;

                // If the dest surface is the primary, DDraw will
                // ask the kernel to Blt from system to video memory
                // even if the driver doesn't specify this capability
                // because it knows that the kernel can emulate it properly.
                // The kernel used to set this cap, be we changed it because
                // it was eating up too many handles and creating inefficiencies.

                if (((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                      (dwDestCaps & DDSCAPS_SYSTEMMEMORY) &&
                      !(pCaps->dwVSBCaps & DDCAPS_BLT)) ||

                     ((dwDestCaps & DDSCAPS_VIDEOMEMORY) &&
                      (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) &&
                      (!(pCaps->dwSVBCaps & DDCAPS_BLT) &&
                      !(peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))) ||

                     ((dwSrcCaps & DDSCAPS_SYSTEMMEMORY) &&
                      (dwDestCaps & DDSCAPS_SYSTEMMEMORY) &&
                      !(pCaps->dwSSBCaps & DDCAPS_BLT)))
                {
                    WARNING("DxDdBlt: Illegal system memory surface");
                    return(dwRet);
                }
            }

            // Make sure that we weren't given rectangle coordinates
            // which might cause the driver to crash.  Note that we
            // don't allow inverting stretch blts:

            if ((BltData.rDest.left   >= 0)                             &&
                (BltData.rDest.top    >= 0)                             &&
                (BltData.rDest.right  <= (LONG) peSurfaceDest->wWidth)  &&
                (BltData.rDest.bottom <= (LONG) peSurfaceDest->wHeight) &&
                (BltData.rDest.left    < BltData.rDest.right)           &&
                (BltData.rDest.top     < BltData.rDest.bottom))
            {
                // Make sure that the surfaces aren't associated
                // with a PDEV whose mode has gone away.
                //
                // Also ensure that there are no outstanding
                // surface locks if running on a brain-dead video
                // card that crashes if the accelerator runs at
                // the same time the frame buffer is accessed.

                EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

                // We will return SURFACELOST when ...
                //
                // 1) This device is suspended.
                // 2) The driver managed surface is managed by other device.
                // 3) One of surface is losted.
                // 4) The visible region has been changed when surface is primary.

                if (peDirectDrawGlobal->bSuspended)                                 // 1)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_WRONG_DRIVER) ||
                         ((peSurfaceSrc != NULL) &&
                          (peSurfaceSrc->fl & DD_SURFACE_FLAG_WRONG_DRIVER)))       // 2)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->bLost) ||
                         ((peSurfaceSrc != NULL) && (peSurfaceSrc->bLost)))         // 3)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                         (peSurfaceDest->iVisRgnUniqueness != VISRGN_UNIQUENESS())) // 4)
                {
                    // The VisRgn changed since the application last queried
                    // it; fail the call with a unique error code so that
                    // they  know to requery the VisRgn and try again:

                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_VISRGNCHANGED;
                }
                else
                {
                    if (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps & DDCAPS_BLT)
                    {
                        BltData.lpDD = peDirectDrawGlobal;

                        // Give GDI a crack at doing the Blt.  GDI may handle
                        // the blt only for the following cases:
                        //
                        // o When the blt occurs underneath a simulated sprite;
                        // o To emulate system-memory to video-memory HEL blts.

                        dwRet = dwDdBltViaGdi(peSurfaceDest,
                                              peSurfaceSrc,
                                              &BltData);

                        if (dwRet != DDHAL_DRIVER_HANDLED)
                        {
                            // This is the normal code path.  First, exclude the
                            // mouse pointer and any other sprites if necessary:

                            DEVEXCLUDERECT dxo;

                            if (peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY)
                            {
                                dxo.vExclude(peDirectDrawGlobal->hdev,
                                               &BltData.rDest);
                            }

                            // Call the driver to do the blt:

                            dwRet = peDirectDrawGlobal->SurfaceCallBacks.
                                            Blt(&BltData);

                            // If there was a flip pending, and the hardware
                            // blt succeeded, then unset the flag:

                            if ((peSurfaceDest->fl & DD_SURFACE_FLAG_FLIP_PENDING) &&
                                (dwRet == DDHAL_DRIVER_HANDLED) &&
                                (BltData.ddRVal == DD_OK))
                            {
                                peSurfaceDest->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
                            }
                        }

                        // If the destination surface is the primary, update
                        // the bounds rect for this device:

                        if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                            (dwRet == DDHAL_DRIVER_HANDLED) &&
                            (BltData.ddRVal == DD_OK))
                        {
                            // Union the current DirectDraw bounds rectangle
                            // with the destination blt rectangle:
                            //
                            // BltData.IsClipped will always be FALSE since
                            // it is currently unsupported, so we only
                            // consider BltData.rDest:

                            if (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_BOUNDS_SET)
                            {
                                if (BltData.rDest.left < peDirectDrawGlobal->rclBounds.left)
                                    peDirectDrawGlobal->rclBounds.left = BltData.rDest.left;

                                if (BltData.rDest.top < peDirectDrawGlobal->rclBounds.top)
                                    peDirectDrawGlobal->rclBounds.top = BltData.rDest.top;

                                if (BltData.rDest.right > peDirectDrawGlobal->rclBounds.right)
                                    peDirectDrawGlobal->rclBounds.right = BltData.rDest.right;

                                if (BltData.rDest.bottom > peDirectDrawGlobal->rclBounds.bottom)
                                    peDirectDrawGlobal->rclBounds.bottom = BltData.rDest.bottom;
                            }
                            else
                            {
                                peDirectDrawGlobal->rclBounds = BltData.rDest;
                                peDirectDrawGlobal->fl |= DD_GLOBAL_FLAG_BOUNDS_SET;
                            }
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdBlt: Invalid destination rectangle\n");
            }
        }
        else
        {
            WARNING("DxDdBlt: Invalid dwFlags\n");
        }
    }
    else
    {
        WARNING("DxDdBlt: Couldn't lock destination surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puBltData->ddRVal, BltData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdFlip
*
* DirectDraw flip.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
DWORD
APIENTRY
DxDdFlip(
    HANDLE       hSurfaceCurrent,
    HANDLE       hSurfaceTarget,
    HANDLE       hSurfaceCurrentLeft,
    HANDLE       hSurfaceTargetLeft,
    PDD_FLIPDATA puFlipData
    )
{
    DWORD       dwRet;
    DD_FLIPDATA FlipData;

    __try
    {
        FlipData = ProbeAndReadStructure(puFlipData, DD_FLIPDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet           = DDHAL_DRIVER_NOTHANDLED;
    FlipData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceCurrent;
    EDD_SURFACE*            peSurfaceCurrentLeft;
    EDD_SURFACE*            peSurfaceTarget;
    EDD_SURFACE*            peSurfaceTargetLeft;
    EDD_LOCK_SURFACE        eLockSurfaceCurrent;
    EDD_LOCK_SURFACE        eLockSurfaceCurrentLeft;
    EDD_LOCK_SURFACE        eLockSurfaceTarget;
    EDD_LOCK_SURFACE        eLockSurfaceTargetLeft;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurfaceCurrent = eLockSurfaceCurrent.peLock(hSurfaceCurrent);
    peSurfaceTarget  = eLockSurfaceTarget.peLock(hSurfaceTarget);

    BOOL bLeftSurfaceOk=FALSE;

    if (FlipData.dwFlags & DDFLIP_STEREO)
    {
        peSurfaceTargetLeft  = eLockSurfaceTargetLeft.peLock(hSurfaceTargetLeft);
        peSurfaceCurrentLeft = eLockSurfaceCurrentLeft.peLock(hSurfaceCurrentLeft);

        // first check if left surface is ok
        // in stereo mode

        if ((peSurfaceCurrentLeft != NULL) &&
            (peSurfaceTargetLeft != NULL) &&
            (peSurfaceCurrent != peSurfaceTargetLeft) &&
            (peSurfaceCurrent != peSurfaceCurrentLeft) &&
            (peSurfaceTarget != peSurfaceTargetLeft) &&
            (peSurfaceTarget != peSurfaceCurrentLeft) &&
            (peSurfaceCurrentLeft != peSurfaceTargetLeft) &&
            (peSurfaceCurrent->peDirectDrawLocal ==
                peSurfaceTargetLeft->peDirectDrawLocal) &&
            (peSurfaceCurrent->peDirectDrawLocal ==
                peSurfaceCurrentLeft->peDirectDrawLocal)
        )
        {
           bLeftSurfaceOk=TRUE;
        } else
        {
          peSurfaceTargetLeft = NULL;
          peSurfaceCurrentLeft = NULL;
        }
    } else
    {
      peSurfaceTargetLeft = NULL;
      peSurfaceCurrentLeft = NULL;
      bLeftSurfaceOk=TRUE;
    }

    // Make sure surfaces belong to the same DirectDraw object and no
    // bad commands are specified:

    if ( bLeftSurfaceOk &&
        (peSurfaceCurrent != NULL) &&
        (peSurfaceTarget != NULL) &&
        (peSurfaceCurrent->peDirectDrawLocal ==
                peSurfaceTarget->peDirectDrawLocal) &&
        ((FlipData.dwFlags & ~DDFLIP_VALID) == 0))
    {
        peDirectDrawGlobal = peSurfaceCurrent->peDirectDrawGlobal;

        // Flipping to the same surface is OK as long as it's an overlay
        // and the ODD/EVEN flag is specified and supported by the driver

        if ((peSurfaceCurrent != peSurfaceTarget) ||
            ((FlipData.dwFlags & (DDFLIP_EVEN|DDFLIP_ODD)) &&
            ( peSurfaceCurrent->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) &&
            (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 & DDCAPS2_CANFLIPODDEVEN)))
        {

            // Make sure that the target is flippable:
            if (peSurfaceCurrentLeft != NULL && peSurfaceTargetLeft != NULL)
            {
                if (!((peSurfaceCurrent->wHeight == peSurfaceTargetLeft->wHeight) &&
                    (peSurfaceCurrent->wWidth  == peSurfaceTargetLeft->wWidth) &&
                    (peSurfaceCurrentLeft->wHeight == peSurfaceTargetLeft->wHeight) &&
                    (peSurfaceCurrentLeft->wWidth  == peSurfaceTargetLeft->wWidth) &&
                    !(peSurfaceCurrentLeft->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                    !(peSurfaceTargetLeft->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)))
                {
                    bLeftSurfaceOk = FALSE;
                }
            }

            if ( bLeftSurfaceOk &&
                (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_FLIP) &&
                (peSurfaceCurrent->wHeight == peSurfaceTarget->wHeight) &&
                (peSurfaceCurrent->wWidth  == peSurfaceTarget->wWidth) &&
                !(peSurfaceCurrent->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                !(peSurfaceTarget->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
            {
                FlipData.lpDD       = peDirectDrawGlobal;
                FlipData.lpSurfCurr = peSurfaceCurrent;
                FlipData.lpSurfCurrLeft = peSurfaceCurrentLeft;
                FlipData.lpSurfTarg = peSurfaceTarget;
                FlipData.lpSurfTargLeft = peSurfaceTargetLeft;

                EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                if (peSurfaceCurrentLeft != NULL && peSurfaceTargetLeft != NULL)
                {
                    bLeftSurfaceOk =!(peSurfaceCurrentLeft->bLost) &&
                                    !(peSurfaceTargetLeft->bLost);
                }

                if (!bLeftSurfaceOk ||
                    (peSurfaceCurrent->bLost) ||
                    (peSurfaceTarget->bLost))
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    FlipData.ddRVal = DDERR_SURFACELOST;
                }
                else
                {
                    dwRet = peDirectDrawGlobal->SurfaceCallBacks.Flip(&FlipData);

                    // Remember this surface so that if it gets deleted, we can
                    // flip back to the GDI surface, assuming it's not an
                    // overlay surface:

                    if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                        (FlipData.ddRVal == DD_OK))
                    {
                        // Keep track of the hardware flip on this surface so if
                        // we do emulated blts to it, we will wait for the flip
                        // to complete first:

                        if(peSurfaceCurrent != peSurfaceTarget)
                        {
                            peSurfaceCurrent->fl |= DD_SURFACE_FLAG_FLIP_PENDING;
                        }

                        if(peSurfaceTarget->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                        {
                            if(peSurfaceCurrent->fl & DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED)
                            {
                                peSurfaceTarget->fl |= DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED;
                                if(peSurfaceCurrent != peSurfaceTarget)
                                {
                                    peSurfaceCurrent->fl &= ~DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED;
                                }
                            }
                        }
                        else
                        {
                            peSurfaceCurrent->ddsCaps.dwCaps &= ~DDSCAPS_PRIMARYSURFACE;
                            peSurfaceTarget->ddsCaps.dwCaps  |= DDSCAPS_PRIMARYSURFACE;

                            peDirectDrawGlobal->peSurfaceCurrent = peSurfaceTarget;
                            if (peSurfaceCurrent->fl & DD_SURFACE_FLAG_PRIMARY)
                            {
                                peDirectDrawGlobal->peSurfacePrimary
                                                    = peSurfaceCurrent;
                            }
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdFlip: Non-flippable surface\n");
            }
        }
        else
        {
            WARNING("DxDdFlip: Invalid flip to same surface\n");
        }
    }
    else
    {
        WARNING("DxDdFlip: Invalid surfaces or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puFlipData->ddRVal, FlipData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}


/******************************Public*Routine******************************\
* DWORD DxDdLock
*
* DirectDraw function to return a user-mode pointer to the screen or
* off-screen surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdLock(
    HANDLE       hSurface,
    PDD_LOCKDATA puLockData,
    HDC          hdcClip
    )
{
    DD_LOCKDATA LockData;

    __try
    {
        LockData = ProbeAndReadStructure(puLockData, DD_LOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    LockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*        peSurface;
    EDD_LOCK_SURFACE    eLockSurface;

    // Note that we have to let down DDLOCK_READONLY, DDLOCK_WRITE,
    // and DDLOCK_WAIT for compatibility.  Note also that a
    // DDLOCK_SURFACEMEMORY flag also gets passed down by default.

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        ((LockData.dwFlags & ~(DDLOCK_VALID)) == 0))
    {
        LockData.lpSurfData = pDdLockSurfaceOrBuffer(peSurface,
                                                     LockData.bHasRect,
                                                     &LockData.rArea,
                                                     // We remove the wait flag since it better to spin in user mode
                                                     LockData.dwFlags & (~DDLOCK_WAIT),
                                                     &LockData.ddRVal);
    }
    else
    {
        WARNING("DxDdLock: Invalid surface or flags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteHandle(&puLockData->lpSurfData, LockData.lpSurfData);
        ProbeAndWriteRVal(&puLockData->ddRVal,       LockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // This function must always return DDHAL_DRIVER_HANDLED, otherwise
    // DirectDraw will simply use the 'fpVidMem' value, which on NT is
    // an offset and not a pointer:

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdUnlock
*
* DirectDraw unlock.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdUnlock(
    HANDLE         hSurface,
    PDD_UNLOCKDATA puUnlockData
    )
{
    DWORD         dwRet;
    DD_UNLOCKDATA UnlockData;

    __try
    {
        UnlockData = ProbeAndReadStructure(puUnlockData, DD_UNLOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    UnlockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        if (bDdUnlockSurfaceOrBuffer(peSurface))
        {
            UnlockData.ddRVal = DD_OK;
        }
    }
    else
    {
        WARNING("DxDdUnlock: Invalid surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUnlockData->ddRVal, UnlockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdLockD3D
*
* DirectDraw function to return a user-mode pointer to the screen or
* off-screen surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdLockD3D(
    HANDLE       hSurface,
    PDD_LOCKDATA puLockData
    )
{
    DD_LOCKDATA LockData;

    __try
    {
        LockData = ProbeAndReadStructure(puLockData, DD_LOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    LockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*        peSurface;
    EDD_LOCK_SURFACE    eLockSurface;

    // Note that we have to let down DDLOCK_READONLY, DDLOCK_WRITE,
    // and DDLOCK_WAIT for compatibility.  Note also that a
    // DDLOCK_SURFACEMEMORY flag also gets passed down by default.

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        ((LockData.dwFlags & ~(DDLOCK_VALID)) == 0))
    {
        LockData.lpSurfData = pDdLockSurfaceOrBuffer(peSurface,
                                                     LockData.bHasRect,
                                                     &LockData.rArea,
                                                     // We remove the wait flag since it better to spin in user mode
                                                     LockData.dwFlags & (~DDLOCK_WAIT),
                                                     &LockData.ddRVal);
    }
    else
    {
        WARNING("DxDdLockD3D: Invalid surface or flags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteHandle(&puLockData->lpSurfData, LockData.lpSurfData);
        ProbeAndWriteRVal(&puLockData->ddRVal,       LockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // This function must always return DDHAL_DRIVER_HANDLED, otherwise
    // DirectDraw will simply use the 'fpVidMem' value, which on NT is
    // an offset and not a pointer:

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdUnlockD3D
*
* DirectDraw unlock.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdUnlockD3D(
    HANDLE         hSurface,
    PDD_UNLOCKDATA puUnlockData
    )
{
    DWORD         dwRet;
    DD_UNLOCKDATA UnlockData;

    __try
    {
        UnlockData = ProbeAndReadStructure(puUnlockData, DD_UNLOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    UnlockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        if (bDdUnlockSurfaceOrBuffer(peSurface))
        {
            UnlockData.ddRVal = DD_OK;
        }
    }
    else
    {
        WARNING("DxDdUnlockD3D: Invalid surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUnlockData->ddRVal, UnlockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetFlipStatus
*
* DirectDraw API to get the page-flip status.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetFlipStatus(
    HANDLE                hSurface,
    PDD_GETFLIPSTATUSDATA puGetFlipStatusData
    )
{
    DWORD                dwRet;
    DD_GETFLIPSTATUSDATA GetFlipStatusData;

    __try
    {
        GetFlipStatusData = ProbeAndReadStructure(puGetFlipStatusData,
                                                  DD_GETFLIPSTATUSDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_NOTHANDLED;
    GetFlipStatusData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        ((GetFlipStatusData.dwFlags & ~(DDGFS_CANFLIP
                                      | DDGFS_ISFLIPDONE)) == 0))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_GETFLIPSTATUS)
        {
            GetFlipStatusData.lpDD        = peDirectDrawGlobal;
            GetFlipStatusData.lpDDSurface = peSurface;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                GetFlipStatusData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                        SurfaceCallBacks.GetFlipStatus(&GetFlipStatusData);

                // If a flip was pending, and has completed, then turn off
                // the flag:

                if ((peSurface->fl & DD_SURFACE_FLAG_FLIP_PENDING) &&
                    (GetFlipStatusData.dwFlags & DDGFS_ISFLIPDONE) &&
                    (dwRet == DDHAL_DRIVER_HANDLED) &&
                    (GetFlipStatusData.ddRVal == DD_OK))
                {
                    peSurface->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetFlipStatus: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetFlipStatusData->ddRVal,
                          GetFlipStatusData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetBltStatus
*
* DirectDraw API to get the accelerator's accelerator status.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetBltStatus(
    HANDLE               hSurface,
    PDD_GETBLTSTATUSDATA puGetBltStatusData
    )
{
    DWORD               dwRet;
    DD_GETBLTSTATUSDATA GetBltStatusData;

    __try
    {
        GetBltStatusData = ProbeAndReadStructure(puGetBltStatusData,
                                                 DD_GETBLTSTATUSDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    GetBltStatusData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        ((GetBltStatusData.dwFlags & ~(DDGBS_CANBLT
                                     | DDGBS_ISBLTDONE)) == 0))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_GETBLTSTATUS)
        {
            GetBltStatusData.lpDD        = peDirectDrawGlobal;
            GetBltStatusData.lpDDSurface = peSurface;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                GetBltStatusData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.GetBltStatus(&GetBltStatusData);
            }
        }
    }
    else
    {
        WARNING("DxDdGetBltStatus: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetBltStatusData->ddRVal, GetBltStatusData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdWaitForVerticalBlank
*
* DirectDraw API to wait for vertical blank.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdWaitForVerticalBlank(
    HANDLE                       hDirectDraw,
    PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData
    )
{
    DWORD                       dwRet;
    DD_WAITFORVERTICALBLANKDATA WaitForVerticalBlankData;

    __try
    {
        WaitForVerticalBlankData =
            ProbeAndReadStructure(puWaitForVerticalBlankData,
                                  DD_WAITFORVERTICALBLANKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                           = DDHAL_DRIVER_NOTHANDLED;
    WaitForVerticalBlankData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if ((peDirectDrawLocal != NULL) &&
        ((WaitForVerticalBlankData.dwFlags & ~(DDWAITVB_I_TESTVB
                                             | DDWAITVB_BLOCKBEGIN
                                             | DDWAITVB_BLOCKBEGINEVENT
                                             | DDWAITVB_BLOCKEND)) == 0) &&
        (WaitForVerticalBlankData.dwFlags != 0))
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->CallBacks.dwFlags &
                    DDHAL_CB32_WAITFORVERTICALBLANK)
        {
            WaitForVerticalBlankData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peDirectDrawGlobal->bSuspended)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                WaitForVerticalBlankData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    CallBacks.WaitForVerticalBlank(&WaitForVerticalBlankData);
            }
        }
    }
    else
    {
        WARNING("DxDdWaitForVerticalBlank: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puWaitForVerticalBlankData->ddRVal,
                          WaitForVerticalBlankData.ddRVal);
        ProbeAndWriteUlong(&puWaitForVerticalBlankData->bIsInVB,
                           WaitForVerticalBlankData.bIsInVB);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD dwDdCanCreateSurfaceOrBuffer
*
* Handles DxDdCanCreateSurface and DxDdCanCreateD3DBuffer.
*
*  3-Feb-1998 -by- Drew Bliss [drewb]
* Merged common code from calling routines.
\**************************************************************************/

DWORD
dwDdCanCreateSurfaceOrBuffer(
    BOOL                     bSurface,
    HANDLE                   hDirectDraw,
    PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    )
{
    DWORD                   dwRet;
    DD_CANCREATESURFACEDATA CanCreateSurfaceData;
    DDSURFACEDESC2*         puSurfaceDescription;
    DDSURFACEDESC2          SurfaceDescription;

    __try
    {
        CanCreateSurfaceData = ProbeAndReadStructure(puCanCreateSurfaceData,
                                                     DD_CANCREATESURFACEDATA);

        puSurfaceDescription = (DDSURFACEDESC2 *)CanCreateSurfaceData.lpDDSurfaceDesc;

        SurfaceDescription  = ProbeAndReadStructure(puSurfaceDescription,
                                                    DDSURFACEDESC2);

        CanCreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*)&SurfaceDescription;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    // All video memory heaps are handled in the kernel so if
    // this routine cannot create a surface then user-mode can't
    // either.  Always returns DRIVER_HANDLED to enforce this.
    dwRet                       = DDHAL_DRIVER_HANDLED;
    CanCreateSurfaceData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        // Choose function to call.
        PDD_CANCREATESURFACE pfnCanCreate;

        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if (bSurface)
        {
            pfnCanCreate =
                (peDirectDrawGlobal->CallBacks.dwFlags &
                 DDHAL_CB32_CANCREATESURFACE) ?
                 peDirectDrawGlobal->CallBacks.CanCreateSurface :
                NULL;
        }
        else
        {
            pfnCanCreate =
                peDirectDrawGlobal->D3dBufCallbacks.CanCreateD3DBuffer;
        }

        if (pfnCanCreate != NULL)
        {
            CanCreateSurfaceData.lpDD = peDirectDrawGlobal;

            if (!peDirectDrawGlobal->bSuspended)
            {
                dwRet = pfnCanCreate(&CanCreateSurfaceData);
            }
            else
            {
                CanCreateSurfaceData.ddRVal = DDERR_SURFACELOST;
            }
        }
        else
        {
            WARNING("dwDdCanCreateSurface: Driver doesn't hook call\n");
        }
    }
    else
    {
        WARNING("dwDdCanCreateSurface: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCanCreateSurfaceData->ddRVal,
                          CanCreateSurfaceData.ddRVal);
        ProbeAndWriteStructure(puSurfaceDescription,
                               SurfaceDescription,
                               DDSURFACEDESC);
        // Driver can update ddpfPixelFormat.dwYUVBitCount
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCanCreateSurface
*
* Queries the driver to determine whether it can support a DirectDraw
* surface that is different from the primary display.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCanCreateSurface(
    HANDLE                   hDirectDraw,
    PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    )
{
    return dwDdCanCreateSurfaceOrBuffer(TRUE, hDirectDraw,
                                        puCanCreateSurfaceData);
}

/******************************Public*Routine******************************\
* DWORD DxDdCanCreateD3DBuffer
*
* Queries the driver to determine whether it can support a given D3D Buffer
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCanCreateD3DBuffer(
    HANDLE                   hDirectDraw,
    PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    )
{
    return dwDdCanCreateSurfaceOrBuffer(FALSE, hDirectDraw,
                                        puCanCreateSurfaceData);
}

/******************************Public*Routine******************************\
* HRESULT hrDdCommitAgpSurface
*
* Ensures that user-mode addresses are reserved in the current process
* and commits pages for the given surface.
*
*  7-May-1998 -by- Drew Bliss [drewb]
* Wrote it.
\**************************************************************************/

HRESULT
hrDdCommitAgpSurface(
    EDD_SURFACE*    peSurface,
    DWORD           dwSurfaceSize
    )
{
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;
    VIDEOMEMORY*            pvmHeap;
    DWORD                   iHeapIndex;

    peDirectDrawLocal = peSurface->peDirectDrawLocal;
    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    pvmHeap = peSurface->lpVidMemHeap;

    ASSERTGDI(peDirectDrawLocal->ppeMapAgp != NULL,
              "Committing AGP surface with no heaps\n");

    iHeapIndex = (DWORD) (pvmHeap - peDirectDrawGlobal->pvmList);
    peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
    if (peMap == NULL)
    {
        MapAllAgpHeaps(peDirectDrawLocal);
        peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
        if (peMap == NULL)
        {
            return DDERR_OUTOFMEMORY;
        }
    }

    peSurface->fpVidMem =
        (FLATPTR)(peMap->pvVirtAddr) +
        (peSurface->fpHeapOffset - pvmHeap->fpStart);
    return DD_OK;
}

/******************************Public*Routine******************************\
* HRESULT hrDdAllocSurface
*
* Allocates memory for the given surface.
*
*  3-Feb-1998 -by- Drew Bliss [drewb]
* Wrote it.
\**************************************************************************/

HRESULT
hrDdAllocSurface(
    EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal,
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal,
    EDD_SURFACE* peSurface
    )
{
    HRESULT hr = DDERR_OUTOFVIDEOMEMORY;
    BOOL bAllowNewPitch = TRUE;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    ASSERTGDI(!(peSurface->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY |
                                             DDSCAPS_PRIMARYSURFACE)),
              "hrDdAllocSurface: System-memory or primary request");

    // If 'fpVidMem' is DDHAL_PLEASEALLOC_USERMEM, that means
    // the driver wants us to allocate a chunk of user-mode
    // memory on the driver's behalf:

    if (peSurface->fpVidMem == DDHAL_PLEASEALLOC_USERMEM)
    {
        // The driver was involved in this surface creation so
        // mark it as such.
        peSurface->fl |= DD_SURFACE_FLAG_DRIVER_CREATED;
    
        peSurface->fpVidMem =
            (FLATPTR) EngAllocUserMem(peSurface->dwUserMemSize, 'pddG');
        if (peSurface->fpVidMem != 0)
        {
            peSurface->fl |= DD_SURFACE_FLAG_UMEM_ALLOCATED;
            hr = DD_OK;

            DDKHEAP(("DDKHEAP: New um %08X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->hGet(), peSurface));
        }
        else
        {
            hr = DDERR_OUTOFMEMORY;
        }

        // FIX: WINBUG #388284
        //
        // - MATROX G200: STRESS: dxg ASSERT when YV12 overlay surface gets created in system memory
        //
        // Set bAllowNewPitch to FALSE to avoid hitting assertion in below.
        //
        // Matrox G200 does not support YU12 overlay surface format, but they want to
        // support this format for application compatibility, thus video driver ask us
        // to allocate YU12 overlay surface in system memory, so that they can Blt
        // with software emulation.

        bAllowNewPitch = FALSE;
    }
    else
    {
        DWORD dwWidth, dwHeight;
        DWORD dwSurfaceSize;

        if (peSurface->fpVidMem == DDHAL_PLEASEALLOC_BLOCKSIZE)
        {
            // The driver wants a surface of a particular size to be
            // allocated.
            dwWidth = peSurface->dwBlockSizeX;
            dwHeight = peSurface->dwBlockSizeY;
            bAllowNewPitch = FALSE;

            // The driver was involved in this surface creation so
            // mark it as such.
            peSurface->fl |= DD_SURFACE_FLAG_DRIVER_CREATED;
        }
        else
        {
            // The driver didn't specify a size so determine it from
            // the surface dimensions.

            if (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
            {
                // Execute buffers are long, thin surfaces for the purposes
                // of VM allocation.
                dwWidth = peSurface->dwLinearSize;
                dwHeight = 1;
            }
            else
            {
                // This lPitch may have been expanded by ComputePitch
                // to cover global alignment restrictions.
                dwWidth = labs(peSurface->lPitch);
                dwHeight = peSurface->wHeight;
            }

            // The driver didn't do anything special for this allocation
            // so don't call it when the surface is destroyed.
        }

        DWORD dwFlags = 0;

        // In user mode DDHA_SKIPRECTANGULARHEAPS keys off of
        // DDRAWISURFGBL_LATEALLOCATELINEAR.  Right now we just leave
        // it off.

        if (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
            DDCAPS2_NONLOCALVIDMEMCAPS)
        {
            dwFlags |= DDHA_ALLOWNONLOCALMEMORY;
        }

        if (peDirectDrawGlobal->D3dDriverData.hwCaps.dwDevCaps &
            D3DDEVCAPS_TEXTURENONLOCALVIDMEM)
        {
            dwFlags |= DDHA_ALLOWNONLOCALTEXTURES;
        }

        LONG lNewPitch = 0;
        DWORD dwNewCaps = 0;
        DWORD dwRet;
        DD_FREEDRIVERMEMORYDATA FreeDriverMemoryData;

        do {
            dwRet = DDHAL_DRIVER_NOTHANDLED;

            // Attempt to allocate the surface.
            peSurface->fpHeapOffset =
                DdHeapAlloc(peDirectDrawGlobal->dwNumHeaps,
                            peDirectDrawGlobal->pvmList,
                            AGP_HDEV(peDirectDrawGlobal),
                            &peDirectDrawGlobal->HalInfo.vmiData,
                            dwWidth,
                            dwHeight,
                            peSurface,
                            dwFlags,
                            &peSurface->lpVidMemHeap,
                            &lNewPitch,
                            &dwNewCaps,
                            &dwSurfaceSize);

            // If the surface could not be allocated, try calling the
            // driver to see if it can free up some room (such as by
            // getting rid of GDI surfaces).
            if ((peSurface->fpHeapOffset == 0) &&
                !(peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->NTCallBacks.dwFlags &
                    DDHAL_NTCB32_FREEDRIVERMEMORY))
            {
                DD_ASSERTDEVLOCK(peDirectDrawGlobal);

                FreeDriverMemoryData.lpDD = peDirectDrawGlobal;
                FreeDriverMemoryData.lpDDSurface = peSurface;
                FreeDriverMemoryData.ddRVal = DDERR_GENERIC;

                dwRet = peDirectDrawGlobal->NTCallBacks.
                    FreeDriverMemory(&FreeDriverMemoryData);
            }
        } while ((dwRet == DDHAL_DRIVER_HANDLED) &&
                 (FreeDriverMemoryData.ddRVal == DD_OK));

        // If the surface could not be allocated with the optimal caps,
        // try allocating with the alternate caps.
        if (peSurface->fpHeapOffset == 0)
        {
            peSurface->fpHeapOffset =
                DdHeapAlloc(peDirectDrawGlobal->dwNumHeaps,
                            peDirectDrawGlobal->pvmList,
                            AGP_HDEV(peDirectDrawGlobal),
                            &peDirectDrawGlobal->HalInfo.vmiData,
                            dwWidth,
                            dwHeight,
                            peSurface,
                            dwFlags | DDHA_USEALTCAPS,
                            &peSurface->lpVidMemHeap,
                            &lNewPitch,
                            &dwNewCaps,
                            &dwSurfaceSize);
        }

        if (peSurface->fpHeapOffset != 0)
        {
            // If this surface was allocated from an AGP heap then
            // we must make sure that the heap has a user-mode mapping
            // for this process and we must commit the necessary user-mode
            // pages.
            if (dwNewCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                hr = hrDdCommitAgpSurface(peSurface, dwSurfaceSize);

                if (hr != DD_OK)
                {
                    DxDdHeapVidMemFree(peSurface->lpVidMemHeap->lpHeap,
                                       peSurface->fpHeapOffset);
                    return hr;
                }
            }
            else
            {
                peSurface->fpVidMem = peSurface->fpHeapOffset;
            }

            hr = DD_OK;
            peSurface->fl |= DD_SURFACE_FLAG_VMEM_ALLOCATED;

            // The particular heap that was used for the allocation may
            // modify certain aspects of the surface.  Update the surface
            // to reflect any changes.
            //
            // The stride is not relevant for an execute buffer so we don't
            // override it in that case.

            if (lNewPitch != 0 && bAllowNewPitch &&
                !(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
            {
                peSurface->lPitch = lNewPitch;
            }

            peSurface->ddsCaps.dwCaps |= dwNewCaps;

            ASSERTGDI((peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) ||
                      peSurface->lPitch > 0,
                      "Unexpected negative surface pitch");
            ASSERTGDI((peSurface->fl & DD_SURFACE_FLAG_DRIVER_CREATED) ||
                      ((peSurface->ddpfSurface.dwFlags &
                        (DDPF_RGB | DDPF_ZBUFFER)) &&
                       (peSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY) == 0),
                      "Unexpected non-driver surface type");

            DDKHEAP(("DDKHEAP: New vm %08X, o %08X, heap %X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->fpHeapOffset,
                     peSurface->lpVidMemHeap->lpHeap,
                     peSurface->hGet(), peSurface));
        }
    }

#if DBG
    if (hr == DD_OK &&
        (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) == 0)
    {
        ASSERTGDI((peSurface->fpVidMem & 3) == 0 &&
                  (peSurface->lPitch & 3) == 0,
                  "Unaligned surface pointer or pitch");
        ASSERTGDI(ABS(peSurface->lPitch) <= 4 * DD_MAXIMUM_COORDINATE,
                  "Pitch out of range");

        // The width in bytes must not be more than the pitch.
        // There are weird cases when this is actually valid (e.g. planar YUV formats), but in all
        // such cases it would involve FOURCCs and the driver telling us which block size to allocate.
        ASSERTGDI((peSurface->wWidth * peSurface->ddpfSurface.dwRGBBitCount <=
                  (ULONG) 8 * ABS(peSurface->lPitch) ||
                  (!bAllowNewPitch && (peSurface->ddpfSurface.dwFlags & DDPF_FOURCC))),
                  "Pitch less than width");
    }
#endif

    return hr;
}

/******************************Public*Routine******************************\
* DWORD dwDdCreateSurfaceOrBuffer
*
* Handles DxDdCreateSurface and DxDdCreateD3DBuffer.
*
*  3-Feb-1998 -by- Drew Bliss [drewb]
* Merged common code from calling functions.
\**************************************************************************/

DWORD dwDdCreateSurfaceOrBuffer(
    HANDLE                  hDirectDraw,
    HANDLE*                 phSurfaceHandles,
    DDSURFACEDESC*          puSurfaceDescription,
    DD_SURFACE_GLOBAL*      puSurfaceGlobalData,
    DD_SURFACE_LOCAL*       puSurfaceLocalData,
    DD_SURFACE_MORE*        puSurfaceMoreData,
    DD_CREATESURFACEDATA*   puCreateSurfaceData,
    HANDLE*                 puhReturnSurfaceHandles
    )
{
    DWORD                   dwRet;
    DD_CREATESURFACEDATA    CreateSurfaceData;
    DDSURFACEDESC2          SurfaceDescription;
    ULONG                   dwNumToCreate;
    HANDLE                  hSecureSurfaceHandles;
    HANDLE                  hSecureGlobals;
    HANDLE                  hSecureLocals;
    HANDLE                  hSecureMore;
    HANDLE                  hSecureReturn;
    ULONG                   cjHandles;
    ULONG                   cjGlobals;
    ULONG                   cjLocals;
    ULONG                   cjMore;
    ULONG                   i;
    ULONG                   j;
    ULONG                   k;
    BOOL                    bAutomicCreate;
    BOOL                    bNotifyCreation;
    ULONG                   dwStart;
    ULONG                   dwEnd;

    __try
    {
        CreateSurfaceData = ProbeAndReadStructure(puCreateSurfaceData,
                                                  DD_CREATESURFACEDATA);
        SurfaceDescription = ProbeAndReadStructure((DDSURFACEDESC2*)puSurfaceDescription,
                                                   DDSURFACEDESC2);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    // All video memory heaps are handled in the kernel so if
    // this routine cannot create a surface then user-mode can't
    // either.  Always returns DRIVER_HANDLED to enforce this.

    dwRet                    = DDHAL_DRIVER_HANDLED;
    CreateSurfaceData.ddRVal = DDERR_GENERIC;
    dwNumToCreate = CreateSurfaceData.dwSCnt;

    EDD_SURFACE**           peSurface;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DD_SURFACE_LOCAL*       pSurfaceLocal;
    BOOL                    bKeepSurface;
    PDD_CREATESURFACE       pfnCreate;

    DD_SURFACE_LOCAL**      pSList = NULL;
    EDD_SURFACE*            peSurfaceOnStack = NULL;
    BOOL                    bAnyType = TRUE;
    DWORD                   dwForceMemType = 0;

    peSurface = NULL;
    bKeepSurface = FALSE;
    bAutomicCreate = FALSE;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);

    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        // Hold the devlock throughout this process for
        // the driver call and to protect heap manipulations.

        EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

        if ((peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED) &&
            !(peDirectDrawGlobal->bSuspended))
        {
            // If the display pitch is 0 (which we should have already caught, but we want to
            // be safe), fail the call now or else vDdCompleteSurfaceObject will blue screen.

            if (peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch == 0)
            {
                CreateSurfaceData.ddRVal = DDERR_GENERIC;
            }
            else
            {
                // Secure all of the arrays that we are working with

                hSecureSurfaceHandles = 0;
                hSecureGlobals = 0;
                hSecureLocals = 0;
                hSecureMore = 0;
                hSecureReturn = 0;

                if (!BALLOC_OVERFLOW1(dwNumToCreate, HANDLE) &&
                    !BALLOC_OVERFLOW1(dwNumToCreate, DD_SURFACE_GLOBAL) &&
                    !BALLOC_OVERFLOW1(dwNumToCreate, DD_SURFACE_LOCAL) &&
                    !BALLOC_OVERFLOW1(dwNumToCreate, DD_SURFACE_MORE))
                {
                    cjHandles = dwNumToCreate * sizeof(HANDLE);
                    cjGlobals = dwNumToCreate * sizeof(DD_SURFACE_GLOBAL);
                    cjLocals = dwNumToCreate * sizeof(DD_SURFACE_LOCAL);
                    cjMore = dwNumToCreate * sizeof(DD_SURFACE_MORE);

                    if (phSurfaceHandles &&
                        puSurfaceGlobalData &&
                        puSurfaceLocalData &&
                        puSurfaceMoreData &&
                        puhReturnSurfaceHandles)
                    {
                        __try
                        {
                            ProbeForWrite(phSurfaceHandles, cjHandles, sizeof(UCHAR));
                            hSecureSurfaceHandles = MmSecureVirtualMemory(phSurfaceHandles,
                                                                          cjHandles,
                                                                          PAGE_READWRITE);

                            ProbeForWrite(puSurfaceGlobalData, cjGlobals, sizeof(UCHAR));
                            hSecureGlobals = MmSecureVirtualMemory(puSurfaceGlobalData,
                                                                   cjGlobals,
                                                                   PAGE_READWRITE);

                            ProbeForWrite(puSurfaceLocalData, cjLocals, sizeof(UCHAR));
                            hSecureLocals = MmSecureVirtualMemory(puSurfaceLocalData,
                                                                  cjLocals,
                                                                  PAGE_READWRITE);

                            ProbeForWrite(puSurfaceMoreData, cjMore, sizeof(UCHAR));
                            hSecureMore = MmSecureVirtualMemory(puSurfaceMoreData,
                                                                cjMore,
                                                                PAGE_READWRITE);

                            ProbeForWrite(puhReturnSurfaceHandles, cjHandles, sizeof(UCHAR));
                            hSecureReturn = MmSecureVirtualMemory(puhReturnSurfaceHandles,
                                                                  cjHandles,
                                                                  PAGE_READWRITE);
                            RtlZeroMemory(puhReturnSurfaceHandles, cjHandles);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }
                }

                // Allocate placeholder where we keep pointers to peSurface.

                if (dwNumToCreate > 1)
                {
                    peSurface = (EDD_SURFACE**) PALLOCMEM(sizeof(EDD_SURFACE*) * dwNumToCreate, 'pddG');
                }
                else
                {
                    peSurface = &peSurfaceOnStack;
                }
            }

            if ((hSecureSurfaceHandles != 0) &&
                (hSecureGlobals != 0) &&
                (hSecureLocals != 0) &&
                (hSecureMore != 0) &&
                (hSecureReturn != 0) &&
                (peSurface != NULL))
            {
                // if driver supports atomic creation and we are creating more than 1 surface,
                // allocate surface list.

                if ((peDirectDrawGlobal->PrivateCaps.dwPrivateCaps & DDHAL_PRIVATECAP_ATOMICSURFACECREATION) &&
                    (dwNumToCreate > 1))
                {
                    pSList = (DD_SURFACE_LOCAL**) PALLOCMEM(sizeof(DD_SURFACE_LOCAL*) * dwNumToCreate, 'pddG');
                    if (pSList != NULL)
                    {
                        bAutomicCreate = TRUE;
                    }
                }
                else
                {
                    pSList = NULL;
                }

                // Determine which function to call.

                if (puSurfaceLocalData[0].ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
                {
                    pfnCreate = peDirectDrawGlobal->D3dBufCallbacks.CreateD3DBuffer;
                }
                else
                {
                    pfnCreate =
                        (peDirectDrawGlobal->CallBacks.dwFlags &
                        DDHAL_CB32_CREATESURFACE) ?
                        peDirectDrawGlobal->CallBacks.CreateSurface :
                        NULL;
                }

                CreateSurfaceData.ddRVal = DD_OK;

                for (i = 0; (i < dwNumToCreate) && (CreateSurfaceData.ddRVal == DD_OK); i++)
                {
                    // Do some basic parameter checking to avoid creating
                    // surfaces based on bad information.

                    if (!(puSurfaceLocalData[i].ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        bDdValidateSurfaceDescription(&puSurfaceGlobalData[i], &puSurfaceLocalData[i]))
                    {
                        peSurface[i] = peDdOpenNewSurfaceObject(peDirectDrawLocal,
                                                                phSurfaceHandles[i],
                                                                &puSurfaceGlobalData[i],
                                                                &puSurfaceLocalData[i],
                                                                &puSurfaceMoreData[i]);
                        if (peSurface[i] != NULL)
                        {
                            bKeepSurface = TRUE;
                            dwRet = DDHAL_DRIVER_NOTHANDLED;

                            pSurfaceLocal = peSurface[i];

                            peSurface[i]->fpVidMem = 0;
                            peSurface[i]->fpHeapOffset = 0;
                            peSurface[i]->hCreatorProcess =
                            peDirectDrawLocal->UniqueProcess;

                            // Setup some internal flags that are required because some
                            // drivers look at them and not setting them for NT5 cause
                            // regressions in NT4 drivers and incompatibilites between
                            // Win9X driver code.

                            if ((SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_OVERLAY) ||
                                ((SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
                                (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps & DDCAPS_OVERLAY)))
                            {
                                peSurface[i]->dwFlags |= DDRAWISURF_HASOVERLAYDATA;
                                puSurfaceLocalData[i].dwFlags |= DDRAWISURF_HASOVERLAYDATA;
                            }

                            if (SurfaceDescription.dwFlags & DDSD_PIXELFORMAT)
                            {
                                if (!(SurfaceDescription.ddpfPixelFormat.dwFlags & DDPF_RGB) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwRGBBitCount !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount) ||
                                    ((SurfaceDescription.ddpfPixelFormat.dwRGBBitCount != 8) &&
                                    ((SurfaceDescription.ddpfPixelFormat.dwRBitMask !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRBitMask) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwGBitMask !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwGBitMask) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwBBitMask !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwBBitMask) ||
                                    ((SurfaceDescription.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) &&
                                    (!(peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwRGBAlphaBitMask !=
                                    peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBAlphaBitMask))))))
                                {
                                    if (!(SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                                    {
                                        peSurface[i]->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
                                        puSurfaceLocalData[i].dwFlags |= DDRAWISURF_HASPIXELFORMAT;
                                    }
                                }
                            }

                            // If this is an automic create, we need to complete all of the surfaces
                            // only after the final create surface is called, otherwise we need to
                            // complete each surface as we go through the loop.

                            if (bAutomicCreate)
                            {
                                dwStart = 0;

                                if (i == (dwNumToCreate - 1))
                                {
                                    dwEnd = dwNumToCreate;
                                }
                                else
                                {
                                    dwEnd = 0;
                                }
                            }
                            else
                            {
                                dwStart = i;
                                dwEnd = i + 1;
                            }

                            // Primary surfaces aren't truly allocated, so
                            // intercept requests for primary allocations and
                            // trivially succeed them with recorded primary information.

                            bNotifyCreation = TRUE;

                            if (peSurface[i]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                            {
                                peSurface[i]->fpVidMem =
                                    peDirectDrawGlobal->HalInfo.vmiData.fpPrimary;
                                peSurface[i]->lPitch =
                                    peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch;
                                peSurface[i]->wWidth =
                                    peDirectDrawGlobal->HalInfo.vmiData.dwDisplayWidth;
                                peSurface[i]->wHeight =
                                    peDirectDrawGlobal->HalInfo.vmiData.dwDisplayHeight;
                                peSurface[i]->ddpfSurface =
                                    peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay;

                                peSurface[i]->fl |= DD_SURFACE_FLAG_PRIMARY;

                                CreateSurfaceData.ddRVal = DD_OK;
                                dwRet = DDHAL_DRIVER_HANDLED;

                                if (!(peDirectDrawGlobal->PrivateCaps.dwPrivateCaps & DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION))
                                {
                                    bNotifyCreation = FALSE;
                                }

                                DDKHEAP(("DDKHEAP: Allocated primary %X, surf %X (%X)\n",
                                         peSurface[i]->fpVidMem, peSurface[i]->hGet(),
                                         peSurface[i]));
                            }

                            if (dwStart != dwEnd)
                            {
                                // Determines whether the memory type was explicit or not, so we know
                                // if we can change it if an allocation fails later.

                                if (dwForceMemType == 0)
                                {
                                    bAnyType = !(peSurface[dwStart]->ddsCaps.dwCaps &
                                               (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM));

                                    // if it's not any type, initialize force mem type so that always
                                    // that type for all surfaces.

                                    if (!bAnyType)
                                    {
                                        dwForceMemType = peSurface[dwStart]->ddsCaps.dwCaps &
                                                            (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                    }
                                }

                                // if force allocations, set the same memory type as the first one

                                if (dwForceMemType)
                                {
                                    for (j = dwStart; j < dwEnd; j++)
                                    {
                                        peSurface[j]->ddsCaps.dwCaps &=
                                            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                        peSurface[j]->ddsCaps.dwCaps |= dwForceMemType;
                                    }
                                }

                                if ((pfnCreate != NULL) && bNotifyCreation)
                                {
                                    // Let the driver attempt to allocate the surface first.

                                    CreateSurfaceData.lpDD            = peDirectDrawGlobal;
                                    CreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*)&SurfaceDescription;

                                    if (bAutomicCreate)
                                    {
                                        for (j = dwStart; j < dwEnd; j++)
                                        {
                                            pSList[j] = peSurface[j];
                                        }

                                        CreateSurfaceData.lplpSList       = pSList;
                                        CreateSurfaceData.dwSCnt          = dwNumToCreate;
                                    }
                                    else
                                    {
                                        CreateSurfaceData.lplpSList       = &pSurfaceLocal;
                                        CreateSurfaceData.dwSCnt          = 1;
                                    }

                                    dwRet = pfnCreate(&CreateSurfaceData);

                                    if (dwRet == DDHAL_DRIVER_HANDLED)
                                    {
                                        if (CreateSurfaceData.ddRVal == DD_OK)
                                        {
                                            for (j = dwStart; j < dwEnd; j++)
                                            {
                                                // Set the driver created flag because the driver
                                                // involved itself in the creation.

                                                peSurface[j]->fl |=
                                                    DD_SURFACE_FLAG_DRIVER_CREATED;
                                            }

                                            for (j = dwStart;
                                                 (j < dwEnd) && (CreateSurfaceData.ddRVal == DD_OK);
                                                 j++)
                                            {
                                                // If the surfaces were allocated from one of our non-local
                                                // heaps, commit sufficient virtual memory and fill in the
                                                // virtual address for fpVidMem so the surface can be locked
                                                // and accessed by user mode apps:

                                                if ((peSurface[j]->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
                                                    (peSurface[j]->lpVidMemHeap != NULL) &&
                                                    (peSurface[j]->lpVidMemHeap->lpHeap != NULL) &&
                                                   !(peSurface[j]->lpVidMemHeap->dwFlags & VIDMEM_ISHEAP) &&
                                                    (peSurface[j]->lpVidMemHeap->dwFlags & VIDMEM_ISNONLOCAL))
                                                {
                                                    CreateSurfaceData.ddRVal =
                                                        hrDdCommitAgpSurface(peSurface[j], 0);
                                                }
                                            }

                                            if (CreateSurfaceData.ddRVal == DD_OK)
                                            {
                                                if (dwForceMemType == 0)
                                                {
                                                    // All surfaces must be of the same type as the first 
                                                    // so we remember the type of surface type which
                                                    // we have successfully created.

                                                    // This only has meaning non-atomic case, since
                                                    // if driver can do atomic creation and handled it
                                                    // without error, that's driver's responsibility to
                                                    // make sure all surface came from same type of memory.

                                                    dwForceMemType =
                                                        peSurface[dwStart]->ddsCaps.dwCaps &
                                                            (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                                }
                                            }
                                        }

                                        DDKHEAP(("DDHKEAP: Driver alloced %X, "
                                                 "hr %X, surf %X (%X)\n",
                                                peSurface[i]->fpVidMem,
                                                CreateSurfaceData.ddRVal,
                                                peSurface[i]->hGet(),
                                                peSurface[i]));
                                    }
                                    else  if (peSurface[dwStart]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                                    {
                                        // Driver possible to return NOTHANDLED for notification of
                                        // primary surface cration, but creation itself is done by
                                        // us in above, but we had "notified" to driver, make
                                        // the surface as driver created. (so that we call driver
                                        // when destroy).

                                        peSurface[dwStart]->fl |=
                                            DD_SURFACE_FLAG_DRIVER_CREATED;
                                    }
                                }

                                if (dwRet == DDHAL_DRIVER_NOTHANDLED)
                                {
                                    // FIX WINBUG: #322363
                                    // Prevent setup blue-screen playing intro AVI on nv3 display drivers

                                    if ((SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                                        (SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                                    {
                                        // Mask off system memory flag
                                        WARNING("Driver turn on SYSTEMMEMORY flag, disable it");
                                        SurfaceDescription.ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                                    }

                                    dwRet = DDHAL_DRIVER_HANDLED;

                                    for (j = dwStart;
                                         (j < dwEnd) && (CreateSurfaceData.ddRVal == DD_OK);
                                         j++)
                                    {
                                        if (peSurface[j]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                                        {
                                            // Driver possible to return NOTHANDLED for notification of
                                            // primary surface cration, but creation itself is done by
                                            // us in above, so just ignore driver return.
                                            // Since this is just "notification" to driver, we don't
                                            // except any work in driver basically.

                                            CreateSurfaceData.ddRVal = DD_OK;
                                        }
                                        else
                                        {
                                            // FIX WINBUG: #322363
                                            // Prevent setup blue-screen playing intro AVI on nv3 display drivers

                                            if ((peSurface[j]->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                                                (peSurface[j]->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                                            {
                                                // Mask off system memory flag
                                                WARNING("Driver turn on SYSTEMMEMORY flag, disable it");
                                                peSurface[j]->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                                            }

                                            if (peSurface[j]->fpVidMem != DDHAL_PLEASEALLOC_USERMEM)
                                            {
                                                // Force allocations to the same memory type as the first

                                                if (dwForceMemType)
                                                {
                                                    peSurface[j]->ddsCaps.dwCaps &=
                                                            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                                    peSurface[j]->ddsCaps.dwCaps |= dwForceMemType;
                                                }

                                                // The driver didn't allocate a vidmem surface, so try
                                                // to allocate one from system-managed memory.

                                                CreateSurfaceData.ddRVal =
                                                    hrDdAllocSurface(peDirectDrawLocal,
                                                                     peDirectDrawGlobal,
                                                                     peSurface[j]);

                                                DDKHEAP(("DDHKEAP: Heap alloced %X, "
                                                    "hr %X, surf %X (%X)\n",
                                                    peSurface[j]->fpVidMem,
                                                    CreateSurfaceData.ddRVal,
                                                    peSurface[j]->hGet(),
                                                    peSurface[j]));

                                                if (CreateSurfaceData.ddRVal == DD_OK)
                                                {
                                                    if (dwForceMemType == 0)
                                                    {
                                                        // All surfaces must be of the same type as the first 
                                                        // so we remember the type of surface type which
                                                        // we have successfully created first time.

                                                        dwForceMemType =
                                                            peSurface[j]->ddsCaps.dwCaps &
                                                                (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                // No forcemem things for user mode memory allocation.
                                                //
                                                // The driver didn't allocate a vidmem surface, so try
                                                // to allocate one from system-managed memory.

                                                CreateSurfaceData.ddRVal =
                                                    hrDdAllocSurface(peDirectDrawLocal,
                                                                     peDirectDrawGlobal,
                                                                     peSurface[j]);
                                            }
                                        }
                                    }
                                }

                                // An attempt to allocate was made either by the driver
                                // or by the system allocator.  If the attempt succeeded,
                                // complete the surface creation.

                                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                                    (CreateSurfaceData.ddRVal == DD_OK))
                                {
                                    // The object is complete.  We can ignore any
                                    // following DxDdCreateSurfaceObject calls that may
                                    // occur on this object.

                                    for (j = dwStart; j < dwEnd; j++)
                                    {
                                        vDdCompleteSurfaceObject(peDirectDrawLocal, peSurface[j]);

                                #if 0
                                        ASSERTGDI((peSurface[j]->fl & DD_SURFACE_FLAG_PRIMARY) ||
                                            (peSurface[j]->fpVidMem !=
                                            peDirectDrawGlobal->HalInfo.vmiData.fpPrimary),
                                            "Expected primary surface to be marked as such");
                                #endif
                                        ASSERTGDI(peSurface[j]->hbmGdi == NULL,
                                            "DxDdCreateSurface: Invalid cached bitmap");

                                        if (peSurface[j]->bLost)
                                        {
                                            // Surface is ready for use.
                                            peSurface[j]->bLost = FALSE;

                                            // Now this surface is ready to go, increment active surface ref. count.
                                            peSurface[j]->peDirectDrawLocal->cActiveSurface++;

                                            ASSERTGDI(peSurface[j]->peDirectDrawLocal->cActiveSurface <=
                                                      peSurface[j]->peDirectDrawLocal->cSurface,
                                                "cActiveSurface is > than cSurface");
                                        }

                                        // Copy surface information to local storage
                                        // for access after the unlock.

                                        puSurfaceGlobalData[j] = *peSurface[j];
                                        puSurfaceLocalData[j].ddsCaps = peSurface[j]->ddsCaps;
                                        puSurfaceMoreData[j].ddsCapsEx = peSurface[j]->ddsCapsEx;

                                        // We were successful, so unlock the surface:

                                        puhReturnSurfaceHandles[j] = peSurface[j]->hGet();
                                    }
                                }

                            } // if (dwStart != dwEnd)
                        }
                        else
                        {
                            WARNING("DxDdCreateSurface: Couldn't allocate surface\n");
                            CreateSurfaceData.ddRVal = DDERR_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        WARNING("DxDdCreateSurface: Bad surface description\n");
                        CreateSurfaceData.ddRVal = DDERR_INVALIDPARAMS;
                    }

                } // For loop

                // The surface object is now created, call CreateSurfaceEx, to
                // inform the driver to associate a cookie if the driver can

                if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
                    && (CreateSurfaceData.ddRVal == DD_OK)
                    && (NULL != peSurface[0])
                    && (0 != peSurface[0]->dwSurfaceHandle)
                   )
                {
                    DD_CREATESURFACEEXDATA CreateSurfaceExData;
                    CreateSurfaceExData.ddRVal          = DDERR_GENERIC;
                    CreateSurfaceExData.dwFlags         = 0;
                    CreateSurfaceExData.lpDDLcl         = peDirectDrawLocal;
                    CreateSurfaceExData.lpDDSLcl        = peSurface[0];

                    dwRet = peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
                    if (dwRet != DDHAL_DRIVER_HANDLED)
                    {
                        // For now, simply warn that the driver failed to associate the surface with the
                        // token and continue
                        WARNING("dwDdCreateSurfaceOrBuffer: DDI call to the driver not handled\n");
                        dwRet = DDHAL_DRIVER_HANDLED;
                        CreateSurfaceData.ddRVal = DDERR_GENERIC;
                    }
                    else
                    {
                        // need to prop the return value as if it's in CreateSurfaceData
                        CreateSurfaceData.ddRVal = CreateSurfaceExData.ddRVal;
                    }
                }

                // Unlock the surfaces and clean up any failures.

                for (j = 0; j < i; j++)
                {
                    if (peSurface[j] != NULL)
                    {
                        if (CreateSurfaceData.ddRVal != DD_OK)
                        {
                            // Failure, so clean up the surface object.
                            bDdDeleteSurfaceObject(peSurface[j]->hGet(), NULL);

                            // bKeepSurface is left at TRUE so that any
                            // failure codes get written back.  Ensure
                            // that fpVidMem is zero on return.
                            puSurfaceGlobalData[j].fpVidMem = 0;
                            puhReturnSurfaceHandles[j] = 0;
                        }
                        else
                        {
                            DEC_EXCLUSIVE_REF_CNT(peSurface[j]);
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdCreateSurface: Unable to allocate or secure memory\n");
            }

            if (hSecureSurfaceHandles)
            {
                MmUnsecureVirtualMemory(hSecureSurfaceHandles);
            }
            if (hSecureGlobals)
            {
                MmUnsecureVirtualMemory(hSecureGlobals);
            }
            if (hSecureLocals)
            {
                MmUnsecureVirtualMemory(hSecureLocals);
            }
            if (hSecureMore)
            {
                MmUnsecureVirtualMemory(hSecureMore);
            }
            if (hSecureReturn)
            {
                MmUnsecureVirtualMemory(hSecureReturn);
            }
            if (peSurface != &peSurfaceOnStack)
            {
                VFREEMEM(peSurface);
            }
            if (pSList != NULL)
            {
                VFREEMEM(pSList);
            }
        }
        else
        {
            if (!(peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED))
            {
                WARNING("DxDdCreateSurface: Driver doesn't support this mode\n");
            }
            else
            {
                CreateSurfaceData.ddRVal = DDERR_SURFACELOST;
            }
        }
    }
    else
    {
        WARNING("DxDdCreateSurface: Invalid object\n");
    }

    DDKHEAP(("DDKHEAP: Create returns %X, rval %X\n",
             dwRet, CreateSurfaceData.ddRVal));

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            ProbeAndWriteRVal(&puCreateSurfaceData->ddRVal,
                              CreateSurfaceData.ddRVal);
        }

        if (bKeepSurface)
        {
            ProbeAndWriteStructure((DDSURFACEDESC2*)puSurfaceDescription,
                                   SurfaceDescription,
                                   DDSURFACEDESC2);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCreateSurface
*
* Corresponds to HAL CreateSurface entry point.
*
* Calls the driver to create a DirectDraw surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCreateSurface(
    HANDLE                  hDirectDraw,
    HANDLE*                 puhSurfaceHandle,
    DDSURFACEDESC*          puSurfaceDescription,
    DD_SURFACE_GLOBAL*      puSurfaceGlobalData,
    DD_SURFACE_LOCAL*       puSurfaceLocalData,
    DD_SURFACE_MORE*        puSurfaceMoreData,
    DD_CREATESURFACEDATA*   puCreateSurfaceData,
    HANDLE*                 puhSurface
    )
{
    return dwDdCreateSurfaceOrBuffer(hDirectDraw, puhSurfaceHandle,
                                     puSurfaceDescription, puSurfaceGlobalData,
                                     puSurfaceLocalData, puSurfaceMoreData,
                                     puCreateSurfaceData, puhSurface);
}

/******************************Public*Routine******************************\
* DWORD DxDdDestroySurface
*
* Calls the driver to delete a surface it created via CreateSurface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdDestroySurface(
    HANDLE  hSurface,
    BOOL    bRealDestroy
    )
{
    DWORD                   dwRet;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    b;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            if(bRealDestroy)
            {
                vDdDisableSurfaceObject(peDirectDrawGlobal,
                                        peSurface,
                                        &dwRet);
            }
            else
            {
                vDdLooseManagedSurfaceObject(peDirectDrawGlobal,
                                             peSurface,
                                             &dwRet);
                return(dwRet);
            }
        }

        // vDdDisableSurfaceObject doesn't delete the DC because it may
        // be called from a different process than the one that created
        // the DC.  However, at this point we're guaranteed to be in the
        // process that created the DC, so we should delete it now:

        if (peSurface->hdc)
        {
            b = DxEngDeleteDC(peSurface->hdc, TRUE);

            // DC may still be in use, which would cause the delete to fail,
            // so we don't assert on the return value (the DC will still get
            // cleaned up at process termination):

            if (!b)
            {
                WARNING("DxDdDestroySurface: bDeleteDCInternal failed");
            }

            peSurface->hdc = 0;
        }
    }
    else
    {
        WARNING("DxDdDestroySurface: Couldn't lock DirectDraw surface");
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCreateD3DBuffer
*
* Calls the driver to create a D3D buffer.
*
* Corresponds to HAL CreateD3DBuffer entry point.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCreateD3DBuffer(
    HANDLE                  hDirectDraw,
    HANDLE*                 puhSurfaceHandle,
    DDSURFACEDESC*          puSurfaceDescription,
    DD_SURFACE_GLOBAL*      puSurfaceGlobalData,
    DD_SURFACE_LOCAL*       puSurfaceLocalData,
    DD_SURFACE_MORE*        puSurfaceMoreData,
    DD_CREATESURFACEDATA*   puCreateSurfaceData,
    HANDLE*                 puhSurface
    )
{
    return dwDdCreateSurfaceOrBuffer(hDirectDraw, puhSurfaceHandle,
                                     puSurfaceDescription, puSurfaceGlobalData,
                                     puSurfaceLocalData, puSurfaceMoreData,
                                     puCreateSurfaceData, puhSurface);
}

/******************************Public*Routine******************************\
* DWORD DxDdDestroyD3DBuffer
*
* Calls the driver to delete a surface it created via CreateD3DBuffer.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdDestroyD3DBuffer(
    HANDLE  hSurface
    )
{
    DWORD                   dwRet;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            vDdDisableSurfaceObject(peDirectDrawGlobal,
                                    peSurface,
                                    &dwRet);
        }
    }
    else
    {
        WARNING("DxDdDestroyD3DBuffer: Couldn't lock DirectDraw surface");
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdSetColorKey
*
* This entry point is always hooked by NT kernel, regardless of whether
* the driver hooks it or not.
*
* Note that this call does not necessary need to be called on an overlay
* surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdSetColorKey(
    HANDLE              hSurface,
    PDD_SETCOLORKEYDATA puSetColorKeyData
    )
{
    DWORD              dwRet;
    DD_SETCOLORKEYDATA SetColorKeyData;

    __try
    {
        SetColorKeyData = ProbeAndReadStructure(puSetColorKeyData,
                                                DD_SETCOLORKEYDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                  = DDHAL_DRIVER_NOTHANDLED;
    SetColorKeyData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        if (SetColorKeyData.dwFlags & DDCKEY_SRCBLT)
        {
            peSurface->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
            peSurface->ddckCKSrcBlt = SetColorKeyData.ckNew;
        }

        // If the driver doesn't hook SetColorKey, we return
        // DDHAL_DRIVER_NOTHANDLED, which means okay.

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_SETCOLORKEY)
        {
            SetColorKeyData.lpDD        = peDirectDrawGlobal;
            SetColorKeyData.lpDDSurface = peSurface;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                SetColorKeyData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.SetColorKey(&SetColorKeyData);
            }
        }
    }
    else
    {
        WARNING("DxDdSetColorKey: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puSetColorKeyData->ddRVal, SetColorKeyData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdAddAttachedSurface
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdAddAttachedSurface(
    HANDLE                      hSurface,
    HANDLE                      hSurfaceAttached,
    PDD_ADDATTACHEDSURFACEDATA  puAddAttachedSurfaceData
    )
{
    DWORD                       dwRet;
    DD_ADDATTACHEDSURFACEDATA   AddAttachedSurfaceData;

    __try
    {
        AddAttachedSurfaceData = ProbeAndReadStructure(puAddAttachedSurfaceData,
                                                       DD_ADDATTACHEDSURFACEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                         = DDHAL_DRIVER_NOTHANDLED;
    AddAttachedSurfaceData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_SURFACE*            peSurfaceAttached;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_LOCK_SURFACE        eLockSurfaceAttached;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    peSurfaceAttached = eLockSurfaceAttached.peLock(hSurfaceAttached);
    if ((peSurface != NULL) &&
        (peSurfaceAttached != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        !(peSurfaceAttached->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        (peSurface->peDirectDrawLocal == peSurfaceAttached->peDirectDrawLocal))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // If the driver doesn't hook AddAttachedSurface, we return
        // DDHAL_DRIVER_NOTHANDLED, which means okay.

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_ADDATTACHEDSURFACE)
        {
            AddAttachedSurfaceData.lpDD           = peDirectDrawGlobal;
            AddAttachedSurfaceData.lpDDSurface    = peSurface;
            AddAttachedSurfaceData.lpSurfAttached = peSurfaceAttached;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((peSurface->bLost) || (peSurfaceAttached->bLost))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                AddAttachedSurfaceData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.AddAttachedSurface(&AddAttachedSurfaceData);
            }
        }
    }
    else
    {
        WARNING("DxDdAddAttachedSurface: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puAddAttachedSurfaceData->ddRVal,
                          AddAttachedSurfaceData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdUpdateOverlay
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdUpdateOverlay(
    HANDLE                  hSurfaceDestination,
    HANDLE                  hSurfaceSource,
    PDD_UPDATEOVERLAYDATA   puUpdateOverlayData
    )
{
    DWORD                dwRet;
    DD_UPDATEOVERLAYDATA UpdateOverlayData;
    EDD_VIDEOPORT*       peVideoPort = NULL;
    EDD_DXSURFACE*       peDxSurface;
    DWORD                dwOldFlags;

    __try
    {
        UpdateOverlayData = ProbeAndReadStructure(puUpdateOverlayData,
                                                  DD_UPDATEOVERLAYDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_NOTHANDLED;
    UpdateOverlayData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceSource;
    EDD_SURFACE*            peSurfaceDestination;
    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurfaceSource;
    EDD_LOCK_SURFACE        eLockSurfaceDestination;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    // 'peSurfaceSource' is the overlay surface, 'peSurfaceDestination' is
    // the surface to be overlayed.

    peSurfaceSource = eLockSurfaceSource.peLock(hSurfaceSource);
    if ((peSurfaceSource != NULL) &&
        !(peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        (peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
    {
        peDirectDrawGlobal = peSurfaceSource->peDirectDrawGlobal;

        // If we're being asked to hide the overlay, then we don't need
        // check any more parameters:

        peSurfaceDestination = NULL;
        if (!(UpdateOverlayData.dwFlags & DDOVER_HIDE))
        {
            // Okay, we have to validate every parameter in this call:

            peSurfaceDestination
                = eLockSurfaceDestination.peLock(hSurfaceDestination);

            if ((peSurfaceDestination == NULL)                                    ||
                (peSurfaceDestination->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)     ||
                (peSurfaceDestination->peDirectDrawLocal !=
                    peSurfaceSource->peDirectDrawLocal)                           ||
                (UpdateOverlayData.rDest.left   < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.top    < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.right  > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.bottom > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.left  >= UpdateOverlayData.rDest.right)  ||
                (UpdateOverlayData.rDest.top   >= UpdateOverlayData.rDest.bottom) ||
                (UpdateOverlayData.rSrc.left    < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.top     < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.right   > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.bottom  > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.left   >= UpdateOverlayData.rSrc.right)   ||
                (UpdateOverlayData.rSrc.top    >= UpdateOverlayData.rSrc.bottom))
            {
                WARNING("DxDdUpdateOverlay: Invalid destination or rectangle\n");
                return(dwRet);
            }

            // We don't keep track of pSurfaceLocal->ddckCKSrcOverlay in
            // kernel mode, so we always expect the user-mode call to convert
            // to DDOVER_KEYDESTOVERRIDE or DDOVER_KEYSRCOVERRIDE.  It is by
            // no means fatal if this is not the case, so we only do a warning:

            if ((UpdateOverlayData.dwFlags & DDOVER_KEYDEST) ||
                (UpdateOverlayData.dwFlags & DDOVER_KEYSRC))
            {
                WARNING("DxDdUpdateOverlay: Expected user-mode to set OVERRIDE\n");
            }

            // If using a video port, disable autoflipping and hardware
            // bob when neccesary

            if( peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
            {
                peVideoPort = (EDD_VIDEOPORT*) peSurfaceSource->lpVideoPort;
                if( peVideoPort != NULL )
                {
                    if( ( peVideoPort->peDxVideoPort->bSoftwareAutoflip ) ||
                        ( peVideoPort->peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SOFTWAREBOB ) )
                    {
                        UpdateOverlayData.dwFlags &= ~(DDOVER_AUTOFLIP|DDOVER_BOBHARDWARE);
                    }
                }
            }

            // If this surface is being used by DxApi, change to weave if
            // DxApi told it to and visa versa.

            peDxSurface = peSurfaceSource->peDxSurface;
            if( peDxSurface != NULL )
            {
                if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_SET )
                {
                    if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_BOB )
                    {
                        UpdateOverlayData.dwFlags |= DDOVER_BOB;
                    }
                    else if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_WEAVE )
                    {
                        UpdateOverlayData.dwFlags &= ~DDOVER_BOB | DDOVER_BOBHARDWARE;
                    }
                }
            }
        }

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags
                & DDHAL_SURFCB32_UPDATEOVERLAY)
        {
            UpdateOverlayData.lpDD            = peDirectDrawGlobal;
            UpdateOverlayData.lpDDDestSurface = peSurfaceDestination;
            UpdateOverlayData.lpDDSrcSurface  = peSurfaceSource;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((peSurfaceSource->bLost) ||
                ((peSurfaceDestination != NULL) && (peSurfaceDestination->bLost)))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                UpdateOverlayData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                peSurfaceSource->fl |= DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED;

                dwRet = peDirectDrawGlobal->SurfaceCallBacks.UpdateOverlay(
                                            &UpdateOverlayData);

                // If it failed due to hardware autoflipping/bobbing
                // and software autoflipping is an option, try again
                // without hardware autolfipping.  If it works, we will
                // revert to software autoflipping.

                if( ( dwRet == DDHAL_DRIVER_HANDLED ) &&
                    ( UpdateOverlayData.ddRVal != DD_OK ) &&
                    ( UpdateOverlayData.dwFlags & (DDOVER_AUTOFLIP|DDOVER_BOBHARDWARE) ) &&
                    ( peDirectDrawGlobal->DDKernelCaps.dwCaps & DDKERNELCAPS_AUTOFLIP ) )
                {
                    dwOldFlags = UpdateOverlayData.dwFlags;
                    UpdateOverlayData.dwFlags &= ~(DDOVER_AUTOFLIP|DDOVER_BOBHARDWARE);
                    dwRet = peDirectDrawGlobal->SurfaceCallBacks.UpdateOverlay(
                                            &UpdateOverlayData);
                    if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                        (UpdateOverlayData.ddRVal == DD_OK))
                    {
                        if( dwOldFlags & DDOVER_AUTOFLIP )
                        {
                            peVideoPort->peDxVideoPort->bSoftwareAutoflip = TRUE;
                            if( peVideoPort->cAutoflipVideo > 0 )
                            {
                                peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP;
                            }
                            if( peVideoPort->cAutoflipVbi > 0 )
                            {
                                peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI;
                            }
                        }
                        if( dwOldFlags & DDOVER_BOBHARDWARE )
                        {
                            peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_SOFTWAREBOB;
                        }
                    }
                }
                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (UpdateOverlayData.ddRVal == DD_OK))
                {
                    // Update the DXAPI data for all surfaces in the chain:

                    if( peVideoPort != NULL )
                    {
                        if( UpdateOverlayData.dwFlags & DDOVER_BOB )
                        {
                            peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_BOB;
                        }
                        else
                        {
                            peVideoPort->peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_BOB;
                        }
                    }
                    peSurface = peSurfaceSource;
                    while (TRUE)
                    {
                        peSurface->dwOverlayFlags = UpdateOverlayData.dwFlags;

                        peSurface->dwOverlaySrcWidth
                            = UpdateOverlayData.rSrc.right -
                              UpdateOverlayData.rSrc.left;
                        peSurface->dwOverlaySrcHeight
                            = UpdateOverlayData.rSrc.bottom -
                              UpdateOverlayData.rSrc.top;
                        peSurface->dwOverlayDestWidth
                            = UpdateOverlayData.rDest.right -
                              UpdateOverlayData.rDest.left;
                        peSurface->dwOverlayDestHeight
                            = UpdateOverlayData.rDest.bottom -
                              UpdateOverlayData.rDest.top;

                        peSurface->rcOverlaySrc.left =
                              UpdateOverlayData.rSrc.left;
                        peSurface->rcOverlaySrc.right =
                              UpdateOverlayData.rSrc.right;
                        peSurface->rcOverlaySrc.top =
                              UpdateOverlayData.rSrc.top;
                        peSurface->rcOverlaySrc.bottom =
                              UpdateOverlayData.rSrc.bottom;

                        vDdSynchronizeSurface(peSurface);

                        if (peSurface->lpAttachList == NULL)
                            break;

                        peSurface
                            = pedFromLp(peSurface->lpAttachList->lpAttached);
                    }
                }
            }
        }
    }
    else
    {
        WARNING("DxDdUpdateOverlay: Invalid source or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUpdateOverlayData->ddRVal, UpdateOverlayData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdSetOverlayPosition
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdSetOverlayPosition(
    HANDLE                      hSurfaceSource,
    HANDLE                      hSurfaceDestination,
    PDD_SETOVERLAYPOSITIONDATA  puSetOverlayPositionData
    )
{
    DWORD                     dwRet;
    DD_SETOVERLAYPOSITIONDATA SetOverlayPositionData;

    __try
    {
        SetOverlayPositionData = ProbeAndReadStructure(puSetOverlayPositionData,
                                                       DD_SETOVERLAYPOSITIONDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                         = DDHAL_DRIVER_NOTHANDLED;
    SetOverlayPositionData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceSource;
    EDD_SURFACE*            peSurfaceDestination;
    EDD_LOCK_SURFACE        eLockSurfaceSource;
    EDD_LOCK_SURFACE        eLockSurfaceDestination;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurfaceSource      = eLockSurfaceSource.peLock(hSurfaceSource);
    peSurfaceDestination = eLockSurfaceSource.peLock(hSurfaceDestination);
    if ((peSurfaceSource != NULL) &&
        (peSurfaceDestination != NULL) &&
        (peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        !(peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        !(peSurfaceDestination->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        peDirectDrawGlobal = peSurfaceSource->peDirectDrawGlobal;

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_SETOVERLAYPOSITION)
        {
            SetOverlayPositionData.lpDD            = peDirectDrawGlobal;
            SetOverlayPositionData.lpDDSrcSurface  = peSurfaceSource;
            SetOverlayPositionData.lpDDDestSurface = peSurfaceDestination;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((peSurfaceSource->bLost) || (peSurfaceDestination->bLost))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                SetOverlayPositionData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.SetOverlayPosition(&SetOverlayPositionData);
            }
        }
    }
    else
    {
        WARNING("DxDdSetOverlayPosition: Invalid surfaces or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puSetOverlayPositionData->ddRVal,
                          SetOverlayPositionData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetScanLine
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetScanLine(
    HANDLE              hDirectDraw,
    PDD_GETSCANLINEDATA puGetScanLineData
    )
{
    DWORD              dwRet;
    DD_GETSCANLINEDATA GetScanLineData;

    __try
    {
        GetScanLineData = ProbeAndReadStructure(puGetScanLineData,
                                                DD_GETSCANLINEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                  = DDHAL_DRIVER_NOTHANDLED;
    GetScanLineData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_GETSCANLINE)
        {
            GetScanLineData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peDirectDrawGlobal->bSuspended)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                GetScanLineData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    CallBacks.GetScanLine(&GetScanLineData);
            }
        }
    }
    else
    {
        WARNING("DxDdGetScanLine: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetScanLineData->ddRVal,
                          GetScanLineData.ddRVal);
        ProbeAndWriteUlong(&puGetScanLineData->dwScanLine,
                           GetScanLineData.dwScanLine);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdSetExclusiveMode
*
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdSetExclusiveMode(
    HANDLE                      hDirectDraw,
    PDD_SETEXCLUSIVEMODEDATA    puSetExclusiveModeData
    )
{
    DWORD                   dwRet;
    DD_SETEXCLUSIVEMODEDATA SetExclusiveModeData;

    __try
    {
        SetExclusiveModeData = ProbeAndReadStructure(puSetExclusiveModeData,
                                                     DD_SETEXCLUSIVEMODEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    SetExclusiveModeData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->NTCallBacks.dwFlags &
            DDHAL_NTCB32_SETEXCLUSIVEMODE)
        {
            SetExclusiveModeData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (!peDirectDrawGlobal->bSuspended)
            {
                dwRet = peDirectDrawGlobal->NTCallBacks.
                    SetExclusiveMode(&SetExclusiveModeData);
            }
            else
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                WARNING("DxDdSetExclusiveMode: "
                        "Can't set exclusive mode because disabled\n");
            }
        }
    }
    else
    {
        WARNING("DxDdSetExclusiveMode: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puSetExclusiveModeData->ddRVal,
                          SetExclusiveModeData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdFlipToGDISurface
*
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdFlipToGDISurface(
    HANDLE                      hDirectDraw,
    PDD_FLIPTOGDISURFACEDATA    puFlipToGDISurfaceData
    )
{
    DWORD                   dwRet;
    DD_FLIPTOGDISURFACEDATA FlipToGDISurfaceData;

    __try
    {
        FlipToGDISurfaceData = ProbeAndReadStructure(puFlipToGDISurfaceData,
                                                     DD_FLIPTOGDISURFACEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    FlipToGDISurfaceData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->NTCallBacks.dwFlags &
            DDHAL_NTCB32_FLIPTOGDISURFACE)
        {
            FlipToGDISurfaceData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (!peDirectDrawGlobal->bSuspended)
            {
                dwRet = peDirectDrawGlobal->NTCallBacks.
                    FlipToGDISurface(&FlipToGDISurfaceData);
            }
            else
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                WARNING("DxDdFlipToGDISurface: "
                        "Can't flip because disabled\n");
            }
        }
    }
    else
    {
        WARNING("DxDdFlipToGDISurface: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puFlipToGDISurfaceData->ddRVal,
                          FlipToGDISurfaceData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDdGetVailDriverMemory
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetAvailDriverMemory(
    HANDLE                          hDirectDraw,
    PDD_GETAVAILDRIVERMEMORYDATA    puGetAvailDriverMemoryData
    )
{
    DD_GETAVAILDRIVERMEMORYDATA GetAvailDriverMemoryData;
    DWORD                       dwHeap;
    VIDEOMEMORY*                pHeap;
    DWORD                       dwAllocated = 0;
    DWORD                       dwFree = 0;

    __try
    {
        GetAvailDriverMemoryData
            = ProbeAndReadStructure(puGetAvailDriverMemoryData,
                                    DD_GETAVAILDRIVERMEMORYDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    GetAvailDriverMemoryData.ddRVal = DD_OK;
    GetAvailDriverMemoryData.dwTotal = 0;
    GetAvailDriverMemoryData.dwFree = 0;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        // First count up all the memory for the heaps we control in kernel.
        pHeap = peDirectDrawGlobal->pvmList;
        for (dwHeap = 0;
             dwHeap < peDirectDrawGlobal->dwNumHeaps;
             pHeap++, dwHeap++)
        {
        /*
         * We use ddsCapsAlt as we wish to return the total amount
         * of memory of the given type it is possible to allocate
         * regardless of whether it is desirable to allocate that
         * type of memory from a given heap or not.
         */
            if( (pHeap->dwFlags & VIDMEM_HEAPDISABLED) == 0 &&
                (GetAvailDriverMemoryData.DDSCaps.dwCaps &
                 pHeap->ddsCapsAlt.dwCaps) == 0 )
            {
                dwFree += VidMemAmountFree( pHeap->lpHeap );
                dwAllocated += VidMemAmountAllocated( pHeap->lpHeap );
            }
        }

        if (peDirectDrawGlobal->MiscellaneousCallBacks.dwFlags &
                DDHAL_MISCCB32_GETAVAILDRIVERMEMORY)
        {
            GetAvailDriverMemoryData.lpDD = peDirectDrawGlobal;

            if (peDirectDrawGlobal->bSuspended)
            {
                GetAvailDriverMemoryData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                peDirectDrawGlobal->MiscellaneousCallBacks.
                    GetAvailDriverMemory(&GetAvailDriverMemoryData);
            }
        }
    }
    else
    {
        WARNING("DxDdGetAvailDriverMemory: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
    ProbeAndWriteRVal(&puGetAvailDriverMemoryData->ddRVal,
              GetAvailDriverMemoryData.ddRVal);
    ProbeAndWriteUlong(&puGetAvailDriverMemoryData->dwTotal,
               GetAvailDriverMemoryData.dwTotal + dwAllocated + dwFree);
    ProbeAndWriteUlong(&puGetAvailDriverMemoryData->dwFree,
               GetAvailDriverMemoryData.dwFree + dwFree);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(DDHAL_DRIVER_HANDLED);
}

/*****************************Private*Routine******************************\
* DWORD DxDdColorControl
*
* Not to be confused with the VideoPort ColorControl function.
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdColorControl(
    HANDLE                  hSurface,
    PDD_COLORCONTROLDATA    puColorControlData
    )
{
    DWORD               dwRet;
    DD_COLORCONTROLDATA ColorControlData;
    DDCOLORCONTROL      ColorInfo;

    __try
    {
        ColorControlData = ProbeAndReadStructure(puColorControlData,
                                                 DD_COLORCONTROLDATA);
        ColorInfo = ProbeAndReadStructure(ColorControlData.lpColorData,
                                          DDCOLORCONTROL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    ColorControlData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // NOTE: For security, gotta reset when switching desktops

        if (peDirectDrawGlobal->ColorControlCallBacks.dwFlags &
                    DDHAL_COLOR_COLORCONTROL)
        {
            ColorControlData.lpDD        = peDirectDrawGlobal;
            ColorControlData.lpDDSurface = peSurface;
            ColorControlData.lpColorData = &ColorInfo;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                ColorControlData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    ColorControlCallBacks.ColorControl(&ColorControlData);
            }
        }
    }
    else
    {
        WARNING("DxColorControl: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puColorControlData->ddRVal, ColorControlData.ddRVal);
        ProbeAndWriteStructure(ColorControlData.lpColorData,
                               ColorInfo,
                               DDCOLORCONTROL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDdGetDriverInfo
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetDriverInfo(
    HANDLE                  hDirectDraw,
    PDD_GETDRIVERINFODATA   puGetDriverInfoData
    )
{
    DD_GETDRIVERINFODATA    GetDriverInfoData;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    GUID*                   pGuid;
    VOID*                   pvData;
    ULONG                   cjData;
    // Needed for Z-Pixels and others which don't cache information
    // in the global.
    // 1K should be enough for about 30 DDPIXELFORMATS,
    // which should be plenty
    DWORD adwBuffer[256];

    __try
    {
        GetDriverInfoData = ProbeAndReadStructure(puGetDriverInfoData,
                                                  DD_GETDRIVERINFODATA);

        // Assume failure:

        puGetDriverInfoData->ddRVal = DDERR_GENERIC;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
        pGuid              = &GetDriverInfoData.guidInfo;
        pvData             = NULL;

        // Note that the actual addresses of the call-backs won't be of
        // much interest to user-mode DirectDraw, but it will still use the
        // dwFlags field of the CALLBACKS structure.

        if (IsEqualIID(pGuid, &GUID_VideoPortCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_VIDEOPORT))
        {
            pvData = &peDirectDrawGlobal->VideoPortCallBacks;
            cjData = sizeof(peDirectDrawGlobal->VideoPortCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_VideoPortCaps) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_VIDEOPORT))
        {
            pvData = peDirectDrawGlobal->lpDDVideoPortCaps;
            cjData = peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts
                   * sizeof(DDVIDEOPORTCAPS);
        }

        if (IsEqualIID(pGuid, &GUID_KernelCaps) )
        {
            pvData = &(peDirectDrawGlobal->DDKernelCaps);
            cjData = sizeof(DDKERNELCAPS);
        }

        if (IsEqualIID(pGuid, &GUID_ColorControlCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_COLORCONTROL))
        {
            pvData = &peDirectDrawGlobal->ColorControlCallBacks;
            cjData = sizeof(peDirectDrawGlobal->ColorControlCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_MiscellaneousCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MISCELLANEOUS))
        {
            pvData = &peDirectDrawGlobal->MiscellaneousCallBacks;
            cjData = sizeof(peDirectDrawGlobal->MiscellaneousCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_Miscellaneous2Callbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MISCELLANEOUS2))
        {
            pvData = &peDirectDrawGlobal->Miscellaneous2CallBacks;
            cjData = sizeof(peDirectDrawGlobal->Miscellaneous2CallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_NTCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_NT))
        {
            pvData = &peDirectDrawGlobal->NTCallBacks;
            cjData = sizeof(peDirectDrawGlobal->NTCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_D3DCallbacks3) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_D3DCALLBACKS3))
        {
            pvData = &peDirectDrawGlobal->D3dCallBacks3;
            cjData = sizeof(peDirectDrawGlobal->D3dCallBacks3);
        }

        if (IsEqualIID(pGuid, &GUID_MotionCompCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MOTIONCOMP))
        {
            pvData = &peDirectDrawGlobal->MotionCompCallbacks;
            cjData = sizeof(peDirectDrawGlobal->MotionCompCallbacks);
        }

        if (IsEqualIID(pGuid, &GUID_DDMoreCaps) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MORECAPS))
        {
            pvData = &peDirectDrawGlobal->MoreCaps;
            cjData = sizeof(peDirectDrawGlobal->MoreCaps);
        }

        if (IsEqualIID(pGuid, &GUID_DDMoreSurfaceCaps))
        {
            pvData = &peDirectDrawGlobal->MoreSurfaceCaps;
            cjData = sizeof(DD_MORESURFACECAPS)-2*sizeof(DDSCAPSEX);
        }
        //
        // The information for the following GUIDs does not
        // need to be kept around in the kernel so the call
        // is passed directly to the driver.
        //

        if (pvData == NULL)
        {
            cjData = 0;

            if (IsEqualIID(pGuid, &GUID_D3DExtendedCaps))
            {
                cjData = sizeof(D3DNTHAL_D3DEXTENDEDCAPS);
            }

            if (IsEqualIID(pGuid, &GUID_ZPixelFormats))
            {
                cjData = sizeof(adwBuffer);
            }

            if (IsEqualIID(pGuid, &GUID_NonLocalVidMemCaps))
            {
                cjData = sizeof(DD_NONLOCALVIDMEMCAPS);
            }

            if (IsEqualIID(pGuid, &GUID_DDStereoMode))
            {
                cjData = sizeof(DD_STEREOMODE);
                __try
                {
                    ProbeForRead(GetDriverInfoData.lpvData, cjData, sizeof(ULONG));
                    RtlCopyMemory(adwBuffer, GetDriverInfoData.lpvData, cjData);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                        return(DDHAL_DRIVER_NOTHANDLED);
                }
            }

            if (cjData > 0)
            {
                ASSERTGDI(sizeof(adwBuffer) >= cjData,
                          "adwBuffer too small");

                EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                if (bDdGetDriverInfo(peDirectDrawGlobal, pGuid,
                                     adwBuffer, cjData, &cjData))
                {
                    pvData = adwBuffer;
                }
            }
        }

        if (pvData != NULL)
        {
            __try
            {

                ProbeForWrite(GetDriverInfoData.lpvData, cjData, sizeof(ULONG));

                RtlCopyMemory(GetDriverInfoData.lpvData, pvData, cjData);

                ProbeAndWriteUlong(&puGetDriverInfoData->dwActualSize, cjData);
                ProbeAndWriteRVal(&puGetDriverInfoData->ddRVal, DD_OK);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return(DDHAL_DRIVER_NOTHANDLED);
            }
        }
    }
    else
    {
        WARNING("DxDdGetDriverInfo: Invalid object\n");
    }

    return(DDHAL_DRIVER_HANDLED);
}
/******************************Public*Routine******************************\
* DWORD DxDdGetDxHandle
*
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdGetDxHandle(
    HANDLE  hDirectDraw,
    HANDLE  hSurface,
    BOOL    bRelease
    )
{
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HANDLE                  hRet;

    hRet = NULL;

    if( hDirectDraw != NULL )
    {
        peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
        if(  peDirectDrawLocal != NULL )
        {
            // Use the devlock to synchronize additions and deletions to
            // the attach list:

            EDD_DEVLOCK eDevLock(peDirectDrawLocal->peDirectDrawGlobal);

            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
            if( !bRelease )
            {
                if( bDdLoadDxApi( peDirectDrawLocal ) &&
                    ( peDirectDrawGlobal->hDirectDraw != NULL ) )
                {
                    hRet = hDirectDraw;
                    peDirectDrawGlobal->dwDxApiExplicitLoads++;
                }
            }
            else if( ( peDirectDrawGlobal->hDirectDraw != NULL ) && bRelease &&
                ( peDirectDrawGlobal->dwDxApiExplicitLoads > 0 ) )
            {
                vDdUnloadDxApi( peDirectDrawGlobal );
                hRet = hDirectDraw;
                peDirectDrawGlobal->dwDxApiExplicitLoads--;
            }
        }
    }

    else if( hSurface != NULL )
    {
        peSurface = eLockSurface.peLock(hSurface);
        if( peSurface != NULL )
        {
            // Use the devlock to synchronize additions and deletions to
            // the attach list:

            EDD_DEVLOCK eDevLock(peSurface->peDirectDrawGlobal);

            // They must open the DirectDraw handle before opening the
            // surface handle, otherwise we fail.

            if( peSurface->peDirectDrawGlobal->hDirectDraw != NULL )
            {
                if ((peSurface->bLost)                                    ||
                    (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                {
                    WARNING("DxDdGetDxHandle: Video surface is bad/lost/system");
                }
                else if( ( peSurface->hSurface == NULL ) && !bRelease )
                {
                    peSurface->hSurface = hDdOpenDxApiSurface( peSurface );
                    if( peSurface->hSurface != NULL )
                    {
                        hRet = hSurface;
                    }
                }
                else if( ( peSurface->hSurface != NULL ) && bRelease )
                {
                    vDdCloseDxApiSurface( peSurface );
                    hRet = hSurface;
                }
            }
        }
    }

    return( hRet );
}

/******************************Public*Routine******************************\
* DWORD DxDdGetMoCompGuids
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetMoCompGuids(
    HANDLE                  hDirectDraw,
    PDD_GETMOCOMPGUIDSDATA  puGetMoCompGuidsData
    )
{
    DWORD                       dwRet;
    DD_GETMOCOMPGUIDSDATA       GetMoCompGuidsData;
    LPGUID                      puGuids;
    ULONG                       cjGuids;
    HANDLE                      hSecure;

    __try
    {
        GetMoCompGuidsData
            = ProbeAndReadStructure(puGetMoCompGuidsData,
                                    DD_GETMOCOMPGUIDSDATA);

        puGuids = GetMoCompGuidsData.lpGuids;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_HANDLED;
    GetMoCompGuidsData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetMoCompGuidsData.lpDD       = peDirectDrawGlobal;
        GetMoCompGuidsData.dwNumGuids = 0;
        GetMoCompGuidsData.lpGuids    = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetMoCompGuids))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompGuids(&GetMoCompGuidsData);

            cjGuids = GetMoCompGuidsData.dwNumGuids
                     * sizeof(GUID);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetMoCompGuidsData.ddRVal == DD_OK) &&
                (cjGuids > 0) &&
                (puGuids != NULL))
            {
                hSecure = 0;
                GetMoCompGuidsData.ddRVal = DDERR_GENERIC;

                __try
                {
                    ProbeForWrite(puGuids, cjGuids, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puGuids,
                                                    cjGuids,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetMoCompGuidsData.lpGuids = puGuids;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompGuids(&GetMoCompGuidsData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDdGetMoCompGuids: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetMoCompGuids: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetMoCompGuidsData->ddRVal,
                          GetMoCompGuidsData.ddRVal);
        ProbeAndWriteUlong(&puGetMoCompGuidsData->dwNumGuids,
                           GetMoCompGuidsData.dwNumGuids);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetMoCompFormats
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetMoCompFormats(
    HANDLE                  hDirectDraw,
    PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData
    )
{
    DWORD                       dwRet;
    DD_GETMOCOMPFORMATSDATA     GetMoCompFormatsData;
    GUID                        guid;
    LPDDPIXELFORMAT             puFormats;
    ULONG                       cjFormats;
    HANDLE                      hSecure;

    __try
    {
        GetMoCompFormatsData
            = ProbeAndReadStructure(puGetMoCompFormatsData,
                                    DD_GETMOCOMPFORMATSDATA);
        guid = ProbeAndReadStructure(GetMoCompFormatsData.lpGuid,
                                    GUID);
        GetMoCompFormatsData.lpGuid = &guid;

        puFormats = GetMoCompFormatsData.lpFormats;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                      = DDHAL_DRIVER_HANDLED;
    GetMoCompFormatsData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetMoCompFormatsData.lpDD         = peDirectDrawGlobal;
        GetMoCompFormatsData.dwNumFormats = 0;
        GetMoCompFormatsData.lpFormats    = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetMoCompFormats))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompFormats(&GetMoCompFormatsData);

            cjFormats = GetMoCompFormatsData.dwNumFormats
                     * sizeof(DDPIXELFORMAT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetMoCompFormatsData.ddRVal == DD_OK) &&
                (cjFormats > 0) &&
                (puFormats != NULL))
            {
                hSecure = 0;
                GetMoCompFormatsData.ddRVal = DDERR_GENERIC;

                __try
                {
                    ProbeForWrite(puFormats, cjFormats, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puFormats,
                                                    cjFormats,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetMoCompFormatsData.lpFormats = puFormats;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompFormats(&GetMoCompFormatsData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDdGetMoCompFormats: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetMoCompFormats: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetMoCompFormatsData->ddRVal,
                          GetMoCompFormatsData.ddRVal);
        ProbeAndWriteUlong(&puGetMoCompFormatsData->dwNumFormats,
                           GetMoCompFormatsData.dwNumFormats);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteMotionCompObject
*
* Deletes a kernel-mode representation of the motion comp object.
*
*  19-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteMotionCompObject(
    HANDLE  hMotionComp,
    DWORD*  pdwRet          // For returning driver return code, may be NULL
    )
{
    BOOL                    bRet;
    DWORD                   dwRet;
    EDD_MOTIONCOMP*         peMotionComp;
    EDD_MOTIONCOMP*         peTmp;
    VOID*                   pvRemove;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    DD_DESTROYMOCOMPDATA    DestroyMoCompData;
    DXOBJ*                  pDxObj;
    DXOBJ*                  pDxObjNext;

    bRet = FALSE;
    dwRet = DDHAL_DRIVER_HANDLED;

    peMotionComp = (EDD_MOTIONCOMP*) DdHmgLock((HDD_OBJ) hMotionComp, DD_MOTIONCOMP_TYPE, FALSE);

    if (peMotionComp != NULL)
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;

        pvRemove = DdHmgRemoveObject((HDD_OBJ) hMotionComp,
                                   DdHmgQueryLock((HDD_OBJ) hMotionComp),
                                   0,
                                   TRUE,
                                   DD_MOTIONCOMP_TYPE);

        // Hold the devlock while we call the driver and while we muck
        // around in the motion comp list:

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if (peMotionComp->fl & DD_MOTIONCOMP_FLAG_DRIVER_CREATED)
        {
            // Call the driver if it created the object:

            if (peDirectDrawGlobal->MotionCompCallbacks.DestroyMoComp)
            {
                DestroyMoCompData.lpDD        = peDirectDrawGlobal;
                DestroyMoCompData.lpMoComp    = peMotionComp;
                DestroyMoCompData.ddRVal      = DDERR_GENERIC;

                dwRet = peDirectDrawGlobal->
                    MotionCompCallbacks.DestroyMoComp(&DestroyMoCompData);
            }
        }

        // Remove from the motion comp object from linked-list:

        peDirectDrawLocal = peMotionComp->peDirectDrawLocal;

        if (peDirectDrawLocal->peMotionComp_DdList == peMotionComp)
        {
            peDirectDrawLocal->peMotionComp_DdList
                = peMotionComp->peMotionComp_DdNext;
        }
        else
        {
            for (peTmp = peDirectDrawLocal->peMotionComp_DdList;
                 ( peTmp != NULL)&&(peTmp->peMotionComp_DdNext != peMotionComp);
                 peTmp = peTmp->peMotionComp_DdNext)
                 ;

            if( peTmp != NULL )
            {
                peTmp->peMotionComp_DdNext = peMotionComp->peMotionComp_DdNext;
            }
        }

        // We're all done with this object, so free the memory and
        // leave:

        DdFreeObject(peMotionComp, DD_MOTIONCOMP_TYPE);

        bRet = TRUE;
    }
    else
    {
        WARNING1("bDdDeleteMotionComp: Bad handle or object was busy\n");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCreateMoComp
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdCreateMoComp(
    HANDLE                  hDirectDraw,
    PDD_CREATEMOCOMPDATA    puCreateMoCompData
    )
{
    HANDLE                  hRet;
    DWORD                   dwRet;
    DD_CREATEMOCOMPDATA     CreateMoCompData;
    GUID                    guid;
    PBYTE                   puData;
    ULONG                   cjData;
    HANDLE                  hSecure;

    __try
    {
        CreateMoCompData =
            ProbeAndReadStructure(puCreateMoCompData,
                                  DD_CREATEMOCOMPDATA);

        guid = ProbeAndReadStructure(CreateMoCompData.lpGuid,
                                    GUID);
        CreateMoCompData.lpGuid = &guid;

        puData = (PBYTE) CreateMoCompData.lpData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    hRet                   = NULL;
    dwRet = DDHAL_DRIVER_HANDLED;
    CreateMoCompData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_MOTIONCOMP*         peMotionComp;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        // Here we do the minimal validations checks to ensure that bad
        // parameters won't crash NT.  We're not more strict than
        // checking for stuff that will crash us, as the user-mode part
        // of DirectDraw handles that.

        peMotionComp = (EDD_MOTIONCOMP*) DdHmgAlloc(sizeof(EDD_MOTIONCOMP),
                                               DD_MOTIONCOMP_TYPE,
                                               HMGR_ALLOC_LOCK);
        if (peMotionComp)
        {
            // Private data:

            peMotionComp->peDirectDrawGlobal = peDirectDrawGlobal;
            peMotionComp->peDirectDrawLocal = peDirectDrawLocal;
            cjData = CreateMoCompData.dwDataSize;

            // Public data:

            peMotionComp->lpDD     = peDirectDrawGlobal;
            RtlCopyMemory(&(peMotionComp->guid),
                  &guid,
                  sizeof(GUID));
            peMotionComp->dwUncompWidth = CreateMoCompData.dwUncompWidth;
            peMotionComp->dwUncompHeight = CreateMoCompData.dwUncompHeight;
            RtlCopyMemory(&(peMotionComp->ddUncompPixelFormat),
                  &CreateMoCompData.ddUncompPixelFormat,
                  sizeof(DDPIXELFORMAT));

            // Hold devlock for driver call

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            // Add this videoport to the list hanging off the
            // DirectDrawLocal object allocated for this process:

            peMotionComp->peMotionComp_DdNext
                    = peDirectDrawLocal->peMotionComp_DdList;
            peDirectDrawLocal->peMotionComp_DdList
                    = peMotionComp;

            // Now call the driver to create its version:

            CreateMoCompData.lpDD              = peDirectDrawGlobal;
            CreateMoCompData.lpMoComp          = peMotionComp;
            CreateMoCompData.ddRVal            = DDERR_GENERIC;
            dwRet = DDHAL_DRIVER_NOTHANDLED;    // Call is optional
            if ((!peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->MotionCompCallbacks.CreateMoComp))
            {
                hSecure = 0;
                if( puData )
                {
                    __try
                    {
                        ProbeForWrite(puData, cjData, sizeof(UCHAR));

                        hSecure = MmSecureVirtualMemory(puData,
                                                    cjData,
                                                    PAGE_READWRITE);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }
                }
                if( ( puData == NULL ) || hSecure )
                {
                    CreateMoCompData.lpData = puData;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        CreateMoComp(&CreateMoCompData);
                }
                else
                {
                    WARNING("DxDdCreateMoComp: Bad data buffer\n");
                    dwRet = DDHAL_DRIVER_HANDLED;
                }

                if( hSecure )
                {
                    MmUnsecureVirtualMemory(hSecure);
                }
                if ((CreateMoCompData.ddRVal == DD_OK))
                {
                    peMotionComp->fl |= DD_MOTIONCOMP_FLAG_DRIVER_CREATED;
                }
                else
                {
                    WARNING("DxDdCreateMoComp: Driver failed call\n");
                }
            }
            if ((dwRet == DDHAL_DRIVER_NOTHANDLED) ||
                (CreateMoCompData.ddRVal == DD_OK))
            {
                    CreateMoCompData.ddRVal = DD_OK;
                    hRet = peMotionComp->hGet();
                    DEC_EXCLUSIVE_REF_CNT( peMotionComp );
            }
            else
            {
                bDdDeleteMotionCompObject(peMotionComp->hGet(), NULL);

                CreateMoCompData.ddRVal = DDERR_GENERIC;
            }
        }
        else
        {
            WARNING("DxDdCreateMoComp: Bad parameters\n");
        }
    }
    else
    {
        WARNING("DxDdCreateMoComp: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCreateMoCompData->ddRVal, CreateMoCompData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Note that the user-mode stub always returns DDHAL_DRIVER_HANDLED
    // to DirectDraw.

    return(hRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetMoCompBuffInfo
*
*  17-Jun-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetMoCompBuffInfo(
    HANDLE                    hDirectDraw,
    PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData
    )
{
    DWORD                    dwRet;
    DD_GETMOCOMPCOMPBUFFDATA GetBuffData;
    LPDDCOMPBUFFERINFO       puBuffInfo;
    GUID                     guid;
    ULONG                    cjNumTypes;
    HANDLE                   hSecure;

    __try
    {
        GetBuffData =
            ProbeAndReadStructure(puGetBuffData,
                                  DD_GETMOCOMPCOMPBUFFDATA);
        guid = ProbeAndReadStructure(GetBuffData.lpGuid,
                                    GUID);
        GetBuffData.lpGuid = &guid;
        puBuffInfo = GetBuffData.lpCompBuffInfo;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet = DDHAL_DRIVER_HANDLED;
    GetBuffData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetBuffData.lpDD                 = peDirectDrawGlobal;
        GetBuffData.dwNumTypesCompBuffs = 0;
        GetBuffData.lpCompBuffInfo      = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetMoCompBuffInfo))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompBuffInfo(&GetBuffData);

            cjNumTypes = GetBuffData.dwNumTypesCompBuffs *
                     sizeof(DDCOMPBUFFERINFO);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetBuffData.ddRVal == DD_OK) &&
                (cjNumTypes > 0) &&
                (puBuffInfo != NULL))
            {
                hSecure = 0;
                GetBuffData.ddRVal = DDERR_GENERIC;

                __try
                {
                    ProbeForWrite(puBuffInfo, cjNumTypes, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puBuffInfo,
                                                    cjNumTypes,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetBuffData.lpCompBuffInfo = puBuffInfo;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompBuffInfo(&GetBuffData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDdGetMoCompBuffInfo: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetMoCompBuffInfo: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetBuffData->ddRVal,
                          GetBuffData.ddRVal);
        ProbeAndWriteUlong(&puGetBuffData->dwNumTypesCompBuffs,
                           GetBuffData.dwNumTypesCompBuffs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetInternalMoCompInfo
*
*  17-Jun-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetInternalMoCompInfo(
    HANDLE                    hDirectDraw,
    PDD_GETINTERNALMOCOMPDATA puGetInternalData
    )
{
    DWORD                    dwRet;
    DD_GETINTERNALMOCOMPDATA GetInternalData;
    GUID                     guid;

    __try
    {
        GetInternalData =
            ProbeAndReadStructure(puGetInternalData,
                                  DD_GETINTERNALMOCOMPDATA);
        guid = ProbeAndReadStructure(GetInternalData.lpGuid,
                                    GUID);
        GetInternalData.lpGuid = &guid;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet = DDHAL_DRIVER_HANDLED;
    GetInternalData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetInternalData.lpDD              = peDirectDrawGlobal;
        GetInternalData.dwScratchMemAlloc = 0;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetInternalMoCompInfo))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetInternalMoCompInfo(&GetInternalData);

        }
    }
    else
    {
        WARNING("DxDdGetInternalMoCompInfo: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetInternalData->ddRVal,
                          GetInternalData.ddRVal);
        ProbeAndWriteUlong(&puGetInternalData->dwScratchMemAlloc,
                           GetInternalData.dwScratchMemAlloc);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdDestroyMoComp
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdDestroyMoComp(
    HANDLE                  hMoComp,
    PDD_DESTROYMOCOMPDATA   puDestroyMoCompData
    )
{
    DWORD   dwRet;

    bDdDeleteMotionCompObject(hMoComp, &dwRet);

    __try
    {
        ProbeAndWriteRVal(&puDestroyMoCompData->ddRVal, DD_OK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdBeginMoCompFrame
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdBeginMoCompFrame(
    HANDLE                   hMoComp,
    PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData
    )
{
    DWORD                       dwRet;
    DD_BEGINMOCOMPFRAMEDATA     BeginFrameData;
    LPBYTE                      puInputData;
    ULONG                       cjInputData;
    LPBYTE                      puOutputData;
    ULONG                       cjOutputData;
    ULONG                       cjRefData;
    HANDLE                      hInputSecure;
    HANDLE                      hOutputSecure;
    DWORD                       dwNumRefSurfaces;
    DWORD                       i;
    DWORD                       j;

    __try
    {
        BeginFrameData
            = ProbeAndReadStructure(puBeginFrameData,
                                    DD_BEGINMOCOMPFRAMEDATA);

        puInputData = (PBYTE) BeginFrameData.lpInputData;
        puOutputData = (PBYTE) BeginFrameData.lpOutputData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_HANDLED;
    BeginFrameData.ddRVal    = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_SURFACE*            peSurfaceDest;
    EDD_LOCK_SURFACE        eLockSurfaceDest;

    peSurfaceDest = eLockSurfaceDest.peLock(BeginFrameData.lpDestSurface);
    peMotionComp = eLockMotionComp.peLock(hMoComp);
    if ((peMotionComp != NULL) && (peSurfaceDest != NULL))
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;
        cjInputData = BeginFrameData.dwInputDataSize;
        cjOutputData = BeginFrameData.dwOutputDataSize;

        BeginFrameData.lpDD          = peDirectDrawGlobal;
        BeginFrameData.lpMoComp      = peMotionComp;
        BeginFrameData.lpDestSurface = peSurfaceDest;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.BeginMoCompFrame))
        {
            // Secure the input buffer
            hInputSecure = 0;
            if( puInputData )
            {
                __try
                {
                    ProbeForWrite(puInputData, cjInputData, sizeof(UCHAR));

                    hInputSecure = MmSecureVirtualMemory(puInputData,
                                            cjInputData,
                                            PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }

            // Secure the output buffer
            hOutputSecure = 0;
            if( puOutputData )
            {
                __try
                {
                    ProbeForWrite(puOutputData, cjOutputData, sizeof(UCHAR));

                    hOutputSecure = MmSecureVirtualMemory(puOutputData,
                                            cjOutputData,
                                            PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }
            if( ( ( puInputData == NULL ) || hInputSecure ) &&
                ( ( puOutputData == NULL ) || hOutputSecure ) )
            {
                BeginFrameData.lpInputData = puInputData;
                BeginFrameData.lpOutputData = puOutputData;

                dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                    BeginMoCompFrame(&BeginFrameData);
                if ((BeginFrameData.ddRVal != DD_OK) &&
                    (dwRet == DDHAL_DRIVER_NOTHANDLED))
                {
                    WARNING("DxDdBeginMoCompFrame: Driver failed callad\n");
                }
            }
            else
            {
                WARNING("DxDdBeginMoCompFrame: Bad intput or output buffer\n");
                dwRet = DDHAL_DRIVER_HANDLED;
            }

            if( hInputSecure )
            {
                MmUnsecureVirtualMemory(hInputSecure);
            }
            if( hOutputSecure )
            {
                MmUnsecureVirtualMemory(hOutputSecure);
            }
        }
    }
    else
    {
        WARNING("DxDdBeginMoCompFrame: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puBeginFrameData->ddRVal,
            BeginFrameData.ddRVal);
        ProbeAndWriteUlong(&puBeginFrameData->dwOutputDataSize,
            BeginFrameData.dwOutputDataSize);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdEndMoCompFrame
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdEndMoCompFrame(
    HANDLE                  hMoComp,
    PDD_ENDMOCOMPFRAMEDATA  puEndFrameData
    )
{
    DWORD                       dwRet;
    DD_ENDMOCOMPFRAMEDATA       EndFrameData;
    LPBYTE                      puData;
    ULONG                       cjData;
    HANDLE                      hSecure;

    __try
    {
        EndFrameData
            = ProbeAndReadStructure(puEndFrameData,
                                    DD_ENDMOCOMPFRAMEDATA);

        puData = (PBYTE) EndFrameData.lpInputData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_HANDLED;
    EndFrameData.ddRVal      = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peMotionComp = eLockMotionComp.peLock(hMoComp);
    if (peMotionComp != NULL)
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;
        cjData = EndFrameData.dwInputDataSize;

        EndFrameData.lpDD         = peDirectDrawGlobal;
        EndFrameData.lpMoComp     = peMotionComp;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.EndMoCompFrame))
        {
            hSecure = 0;
            if( puData )
            {
                __try
                {
                    ProbeForWrite(puData, cjData, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puData,
                                                cjData,
                                                PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }
            if( ( puData == NULL ) || hSecure )
            {
                EndFrameData.lpInputData = puData;

                dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                    EndMoCompFrame(&EndFrameData);
                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (EndFrameData.ddRVal != DD_OK))
                {
                    WARNING("DxDdEndMoCompFrame: Driver failed call\n");
                }
            }
            else
            {
                WARNING("DxDdEndMoCompFrame: Bad data buffer\n");
            }

            if( hSecure )
            {
                MmUnsecureVirtualMemory(hSecure);
            }
        }
    }
    else
    {
        WARNING("DxDdEndMoCompFrame: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puEndFrameData->ddRVal,
            EndFrameData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdRenderMoComp
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdRenderMoComp(
    HANDLE                  hMoComp,
    PDD_RENDERMOCOMPDATA    puRenderMoCompData
    )
{
    DWORD                       dwRet;
    DD_RENDERMOCOMPDATA         RenderMoCompData;
    LPDDMOCOMPBUFFERINFO        pMacroBlocks;
    DWORD                       dwNumMacroBlocks;
    LPBYTE                      puData;
    ULONG                       cjData;
    HANDLE                      hSecure;
    LPBYTE                      puInputData;
    ULONG                       cjInputData;
    LPBYTE                      puOutputData;
    ULONG                       cjOutputData;
    DWORD                       i;
    DWORD                       j;

    __try
    {
        RenderMoCompData
            = ProbeAndReadStructure(puRenderMoCompData,
                                    DD_RENDERMOCOMPDATA);

        pMacroBlocks = RenderMoCompData.lpBufferInfo;
        dwNumMacroBlocks = RenderMoCompData.dwNumBuffers;
        puInputData = (PBYTE) RenderMoCompData.lpInputData;
        puOutputData = (PBYTE) RenderMoCompData.lpOutputData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_HANDLED;
    RenderMoCompData.ddRVal = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peMotionComp = eLockMotionComp.peLock(hMoComp);
    if (peMotionComp != NULL)
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;

        RenderMoCompData.lpDD         = peDirectDrawGlobal;
        RenderMoCompData.lpMoComp     = peMotionComp;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.RenderMoComp))
        {
            if (!BALLOC_OVERFLOW1(dwNumMacroBlocks, DDMOCOMPBUFFERINFO))
            {
                cjData = dwNumMacroBlocks * sizeof(DDMOCOMPBUFFERINFO);
                hSecure = 0;
                if (pMacroBlocks)
                {
                    __try
                    {
                        ProbeForWrite(pMacroBlocks, cjData, sizeof(UCHAR));

                        hSecure = MmSecureVirtualMemory(pMacroBlocks,
                                                cjData,
                                                PAGE_READWRITE);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }
                    for (i = 0; i < dwNumMacroBlocks; i++)
                    {
                        // HmgLock return EDD_SURFACE, but we need a pointer to
                        // a DD_SURFACE_LOCAL, so we need to adjust by the size of
                        // an OBJECT.  This means when releasing the lock, we need to
                        // reverse this adjustment.

                        pMacroBlocks[i].lpCompSurface = (PDD_SURFACE_LOCAL)
                            ((LPBYTE)(DdHmgLock((HDD_OBJ)(pMacroBlocks[i].lpCompSurface), DD_SURFACE_TYPE, FALSE))
                               + sizeof(DD_OBJECT));
                        if (pMacroBlocks[i].lpCompSurface == NULL)
                        {
                            for (j = 0; j < i; j++)
                            {
                                DEC_EXCLUSIVE_REF_CNT(((LPBYTE)(pMacroBlocks[i].lpCompSurface) - sizeof(DD_OBJECT)));
                            }
                            MmUnsecureVirtualMemory(hSecure);
                            hSecure = 0;
                            break;
                        }
                    }
                }
                if( (( pMacroBlocks == NULL ) && (dwNumMacroBlocks == 0)) ||
                    hSecure )
                {
                    HANDLE hInputSecure = 0;
                    HANDLE hOutputSecure = 0;

                    // Secure the input buffer
                    cjInputData = RenderMoCompData.dwInputDataSize;
                    cjOutputData = RenderMoCompData.dwOutputDataSize;
                    if( puInputData )
                    {
                        __try
                        {
                            ProbeForWrite(puInputData, cjInputData, sizeof(UCHAR));

                            hInputSecure = MmSecureVirtualMemory(puInputData,
                                                    cjInputData,
                                                    PAGE_READWRITE);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }

                    // Secure the output buffer
                    if( puOutputData )
                    {
                        __try
                        {
                            ProbeForWrite(puOutputData, cjOutputData, sizeof(UCHAR));

                            hOutputSecure = MmSecureVirtualMemory(puOutputData,
                                                    cjOutputData,
                                                    PAGE_READWRITE);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }
                    if( ( ( puInputData == NULL ) || hInputSecure ) &&
                        ( ( puOutputData == NULL ) || hOutputSecure ) )
                    {
                        RenderMoCompData.lpInputData = puInputData;
                        RenderMoCompData.lpOutputData = puOutputData;
                        RenderMoCompData.lpBufferInfo = pMacroBlocks;

                        dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                            RenderMoComp(&RenderMoCompData);
                        if (RenderMoCompData.ddRVal != DD_OK)
                        {
                            WARNING("DxDdEnderMoComp: Driver failed call\n");
                        }
                    }

                    if( hInputSecure )
                    {
                        MmUnsecureVirtualMemory(hInputSecure);
                    }
                    if( hOutputSecure )
                    {
                        MmUnsecureVirtualMemory(hOutputSecure);
                    }
                }

                if( hSecure )
                {
                    for (i = 0; i < dwNumMacroBlocks; i++)
                    {
                        DEC_EXCLUSIVE_REF_CNT(((LPBYTE)(pMacroBlocks[i].lpCompSurface) - sizeof(DD_OBJECT)));
                    }
                    MmUnsecureVirtualMemory(hSecure);
                }
            }
        }
    }
    else
    {
        WARNING("DxDdRenderMoComp: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puRenderMoCompData->ddRVal,
            RenderMoCompData.ddRVal);
        ProbeAndWriteUlong(&puRenderMoCompData->dwOutputDataSize,
            RenderMoCompData.dwOutputDataSize);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdQueryMoCompStatus
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdQueryMoCompStatus(
    HANDLE                  hMoComp,
    PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData
    )
{
    DWORD                       dwRet;
    DD_QUERYMOCOMPSTATUSDATA    QueryMoCompData;

    __try
    {
        QueryMoCompData
            = ProbeAndReadStructure(puQueryMoCompStatusData,
                                    DD_QUERYMOCOMPSTATUSDATA);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                  = DDHAL_DRIVER_HANDLED;
    QueryMoCompData.ddRVal = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;

    peMotionComp = eLockMotionComp.peLock(hMoComp);
    peSurface = eLockSurface.peLock(QueryMoCompData.lpSurface);
    if ((peMotionComp != NULL) && (peSurface != NULL))
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;

        QueryMoCompData.lpDD         = peDirectDrawGlobal;
        QueryMoCompData.lpMoComp     = peMotionComp;
        QueryMoCompData.lpSurface    = peSurface;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.QueryMoCompStatus))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                QueryMoCompStatus(&QueryMoCompData);
            if (QueryMoCompData.ddRVal != DD_OK)
            {
                WARNING("DxDdQueryMoCompStatus: Driver failed call\n");
            }
        }
    }
    else
    {
        WARNING("DxDdQueryMoCompStatus: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puQueryMoCompStatusData->ddRVal,
            QueryMoCompData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdAlphaBlt
*
*  24-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdAlphaBlt(
    HANDLE      hSurfaceDest,
    HANDLE      hSurfaceSrc,
    PDD_BLTDATA puBltData
    )
{
    DWORD       dwRet;
    DD_BLTDATA  BltData;

    __try
    {
        BltData
            = ProbeAndReadStructure(puBltData,
                                    DD_BLTDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet          = DDHAL_DRIVER_NOTHANDLED;
    BltData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceDest;
    EDD_SURFACE*            peSurfaceSrc;
    EDD_LOCK_SURFACE        eLockSurfaceDest;
    EDD_LOCK_SURFACE        eLockSurfaceSrc;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurfaceDest = eLockSurfaceDest.peLock(hSurfaceDest);
    BltData.lpDDDestSurface = peSurfaceDest;

    if (peSurfaceDest != NULL)
    {
        peDirectDrawGlobal = peSurfaceDest->peDirectDrawGlobal;
        if( peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MORECAPS )
        {
            // We support only a specific set of Blt calls down to the driver
            // that we're willing to support and to test.

            if (hSurfaceSrc == NULL)
            {
                // Do simpler stuff 'cause we don't need to lock a source:

                BltData.lpDDSrcSurface = NULL;
                peSurfaceSrc = NULL;

                if ((peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                    (peDirectDrawGlobal->MoreCaps.dwVSBAlphaCaps == 0) &&
                    (peDirectDrawGlobal->MoreCaps.dwSSBAlphaCaps == 0))
                {
                    WARNING("DxDdAlphaBlt: Can't blt to system memory surface");
                    return(dwRet);
                }
            }
            else
            {
                // Lock the source surface:

                peSurfaceSrc = eLockSurfaceSrc.peLock(hSurfaceSrc);
                BltData.lpDDSrcSurface = peSurfaceSrc;

                // Ensure that both surfaces belong to the same DirectDraw
                // object, and check source rectangle:

                if ((peSurfaceSrc == NULL)                               ||
                    (peSurfaceSrc->peDirectDrawLocal !=
                        peSurfaceDest->peDirectDrawLocal)            ||
                    (BltData.rSrc.left   < 0)                            ||
                    (BltData.rSrc.top    < 0)                            ||
                    (BltData.rSrc.right  > (LONG) peSurfaceSrc->wWidth)  ||
                    (BltData.rSrc.bottom > (LONG) peSurfaceSrc->wHeight) ||
                    (BltData.rSrc.left  >= BltData.rSrc.right)           ||
                    (BltData.rSrc.top   >= BltData.rSrc.bottom))
                {
                    WARNING("DxDdAlphaBlt: Invalid source surface or source rectangle\n");
                    return(dwRet);
                }

                if (peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    if (peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    {
                        if (peDirectDrawGlobal->MoreCaps.dwSSBAlphaCaps == 0)
                        {
                            WARNING("DxDdAlphaBlt: System to System Blts not supported\n");
                            return(dwRet);
                        }
                    }
                    else if (peDirectDrawGlobal->MoreCaps.dwVSBAlphaCaps == 0)
                    {
                        WARNING("DxDdAlphaBlt: Video to System Blts not supported\n");
                        return(dwRet);
                    }
                }
                else
                {
                    if (peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    {
                        if (peDirectDrawGlobal->MoreCaps.dwSVBAlphaCaps == 0)
                        {
                            WARNING("DxDdAlphaBlt: System to Video Blts not supported\n");
                            return(dwRet);
                        }
                    }
                    else if (peDirectDrawGlobal->MoreCaps.dwAlphaCaps == 0)
                    {
                        WARNING("DxDdAlphaBlt: Video to Video Blts not supported\n");
                        return(dwRet);
                    }
                }
            }

            // Make sure that we weren't given rectangle coordinates
            // which might cause the driver to crash.  Note that we
            // don't allow inverting stretch blts:

            if ((BltData.rDest.left   >= 0)                             &&
                (BltData.rDest.top    >= 0)                             &&
                (BltData.rDest.right  <= (LONG) peSurfaceDest->wWidth)  &&
                (BltData.rDest.bottom <= (LONG) peSurfaceDest->wHeight) &&
                (BltData.rDest.left    < BltData.rDest.right)           &&
                (BltData.rDest.top     < BltData.rDest.bottom))
            {
                BltData.lpDD = peDirectDrawGlobal;

                // Make sure that the surfaces aren't associated
                // with a PDEV whose mode has gone away.
                //
                // Also ensure that there are no outstanding
                // surface locks if running on a brain-dead video
                // card that crashes if the accelerator runs at
                // the same time the frame buffer is accessed.

                EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                // We will return SURFACELOST when ...
                //
                // 1) This device is suspended.
                // 2) The driver managed surface is managed by other device.
                // 3) One of surface is losted.
                // 4) The visible region has been changed when surface is primary.

                if (peDirectDrawGlobal->bSuspended)                                 // 1)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_WRONG_DRIVER) ||
                         ((peSurfaceSrc != NULL) &&
                          (peSurfaceSrc->fl & DD_SURFACE_FLAG_WRONG_DRIVER)))       // 2)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->bLost) ||
                         ((peSurfaceSrc != NULL) && (peSurfaceSrc->bLost)))         // 3)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                         (peSurfaceDest->iVisRgnUniqueness != VISRGN_UNIQUENESS())) // 4)
                {
                    // The VisRgn changed since the application last queried it;
                    // fail the call with a unique error code so that they know
                    // to requery the VisRgn and try again:

                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_VISRGNCHANGED;
                }
                else
                {
                    if (peDirectDrawGlobal->Miscellaneous2CallBacks.AlphaBlt)
                    {
                        DEVEXCLUDERECT dxo;
                        HANDLE hSecure;
                        ULONG cjData;
                        DWORD i;
                        LPRECT lpRect;

                        // Secure the clip list and ensure that all of its
                        // rectangles are valid

                        hSecure = 0;
                        if( BltData.dwRectCnt == 0 )
                        {
                            BltData.prDestRects = NULL;
                        }
                        else if ( BltData.prDestRects == NULL )
                        {
                            BltData.dwRectCnt = 0;
                        }
                        else
                        {
                            __try
                            {
                                cjData = BltData.dwRectCnt * sizeof( RECT );
                                if (!BALLOC_OVERFLOW1(BltData.dwRectCnt, RECT))
                                {
                                    ProbeForWrite(BltData.prDestRects, cjData, sizeof(UCHAR));

                                    hSecure = MmSecureVirtualMemory(BltData.prDestRects,
                                                    cjData,
                                                    PAGE_READWRITE);
                                }
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                            }
                            if( hSecure == NULL )
                            {
                                BltData.ddRVal = DDERR_OUTOFMEMORY;
                                dwRet = DDHAL_DRIVER_HANDLED;
                            }
                            else
                            {
                                // Validate each rectangle

                                lpRect = BltData.prDestRects;
                                for( i = 0; i < BltData.dwRectCnt; i++ )
                                {
                                    if ((lpRect->left   < 0)                     ||
                                        (lpRect->top    < 0)                     ||
                                        (lpRect->left   > lpRect->right )        ||
                                        (lpRect->top    > lpRect->bottom ) )
                                    {
                                        MmUnsecureVirtualMemory(hSecure);
                                        WARNING("DxDdAlphaBlt: Couldn't lock destination surface\n");
                                        dwRet = DDHAL_DRIVER_HANDLED;
                                        BltData.ddRVal = DDERR_INVALIDPARAMS;
                                        break;
                                    }
                                    lpRect++;
                                }
                            }
                        }

                        // Only do the Blt it everything has worked up until now

                        if( dwRet == DDHAL_DRIVER_NOTHANDLED )
                        {
                            // Exclude the mouse pointer if necessary:

                            if (peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY)
                            {
                                dxo.vExclude(peDirectDrawGlobal->hdev,
                                             &BltData.rDest);
                            }

                            dwRet = peDirectDrawGlobal->Miscellaneous2CallBacks.
                                AlphaBlt(&BltData);

                            if( hSecure )
                            {
                                MmUnsecureVirtualMemory(hSecure);
                            }
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdAlphaBlt: Invalid destination rectangle\n");
            }
        }
        else
        {
            WARNING("DxDdAlphaBlt: Alpha not supported\n");
        }
    }
    else
    {
        WARNING("DxDdAlphaBlt: Couldn't lock destination surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puBltData->ddRVal, BltData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}


/******************************Public*Routine******************************\
* DxDdSetGammaRamp
*
* The reason we need this function when GDI already has one is that
* DirectDraw games need the ability to set bizarre gamma ramps to
* achieve special effects.  The GDI SetDeviceGammaRamp call does a range
* check that will reject all of these gamma ramps.  When this function is
* used, DirectDraw gaurentees that the original gamma ramp gets restored
* when the game gets minimized or exits.
*
* History:
*
* Wrote it:
*  06-Jun-1998 -by- Scott MacDonald [smac]
\**************************************************************************/

#define MAX_COLORTABLE     256

BOOL
DxDdSetGammaRamp(
    HANDLE  hDirectDraw,
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    WORD *  pTemp1;
    WORD *  pTemp2;
    int     i;

    BOOL bRet = FALSE;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (lpGammaRamp)
        {
            HANDLE hSecure = NULL;
            BOOL   bError  = FALSE;

            __try
            {
                ProbeForRead(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, sizeof(BYTE));
                hSecure = MmSecureVirtualMemory(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, PAGE_READONLY);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("DxDdSetGammaRamp: Fail to capture usermode buffer\n");
                bError = TRUE;
            }

            {
                EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

                // If the gamma has not already been set by this app, get the existing gamma
                // ramp and save it so we can clean up after ourselves.

                if ((peDirectDrawLocal->pGammaRamp == NULL) && !bError)
                {
                    peDirectDrawLocal->pGammaRamp = (WORD *) PALLOCMEM(MAX_COLORTABLE * 3 * sizeof(WORD), 'pddG');
                    if (peDirectDrawLocal->pGammaRamp != NULL)
                    {
                        bRet = DxEngGetDeviceGammaRamp( peDirectDrawGlobal->hdev, peDirectDrawLocal->pGammaRamp );
                        if (!bRet)
                        {
                            bError = TRUE;
                        }
                    }
                    else
                    {
                        bError = TRUE;
                    }
                }

                // If this new gamma ramp is the same as the original ramp, we know
                // that we are restoring it.

                if ((peDirectDrawLocal->pGammaRamp != NULL) && !bError)
                {
                    pTemp1 = (WORD *) lpGammaRamp;
                    pTemp2 = peDirectDrawLocal->pGammaRamp;
                    for (i = 0; i < MAX_COLORTABLE * 3; i++)
                    {
                        if (*pTemp1++ != *pTemp2++)
                        {
                            break;
                        }
                    }
                    if (i == MAX_COLORTABLE * 3)
                    {
                        VFREEMEM(peDirectDrawLocal->pGammaRamp);
                        peDirectDrawLocal->pGammaRamp = NULL;
                    }
                }

                if ((bError == FALSE) && hSecure)
                {
                    bRet = DxEngSetDeviceGammaRamp(peDirectDrawGlobal->hdev, lpGammaRamp, FALSE);
                }
            }

            if (hSecure)
            {
                MmUnsecureVirtualMemory(hSecure);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        WARNING("DxDdSetGammaRamp: Invalid DirectDraw object specified\n");
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* DxDdCreateSurfaceEx
*
* Just notify driver of new handle association by calling its
* CreateSurfaceEx
*
* History:
*
* Wrote it:
*  25-Feb-1999 -by- Kan Qiu [kanqiu]
\**************************************************************************/

DWORD
APIENTRY
DxDdCreateSurfaceEx(
    HANDLE  hDirectDraw,
    HANDLE  hSurface,
    DWORD   dwSurfaceHandle
    )
{
    EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_SURFACE*   peSurface;
    EDD_LOCK_SURFACE        eLockSurface;

    peSurface = eLockSurface.peLock( hSurface );

    if (peSurface == NULL)
    {
        WARNING("DxDdCreateSurfaceEx: Invalid surfaces specified\n");
        return DDERR_GENERIC;
    }

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL )
    {
        EDD_DIRECTDRAW_GLOBAL *peDirectDrawGlobal =
            peDirectDrawLocal->peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        // associate user mode surface handle to kernel mode surface

        if ((peSurface->dwSurfaceHandle != 0) &&
            (peSurface->dwSurfaceHandle != dwSurfaceHandle))
        {
            WARNING("DxDdCreateSurfaceEx: called with surface which has been called already\n");
        }

        if (peDirectDrawGlobal->bSuspended)
        {
            return DDERR_SURFACELOST;
        }
        else if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx) &&
                 (dwSurfaceHandle != 0))
        {
            peSurface->dwSurfaceHandle = dwSurfaceHandle;

            DD_CREATESURFACEEXDATA CreateSurfaceExData;

            // Use the CreateSurfaceEx DDI to once again inform the
            // driver that something has changed
            CreateSurfaceExData.dwFlags        = 0;
            CreateSurfaceExData.ddRVal         = DDERR_GENERIC;
            CreateSurfaceExData.lpDDLcl        = peDirectDrawLocal;
            CreateSurfaceExData.lpDDSLcl       = peSurface;

            peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
            if (CreateSurfaceExData.ddRVal != DD_OK)
            {
                WARNING("DxDdCreateSurfaceEx: DDI call to the driver failed\n");
                return (CreateSurfaceExData.ddRVal);
            }
            else
            {
                if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    PDEVOBJ po(peDirectDrawGlobal->hdev);

                    // Mark we called CreateSurfaceEx on this surface.
                    // this information will be used when we need to call
                    // CreateSurfaceEx after video mode change.
                    peSurface->fl |= DD_SURFACE_FLAG_SYSMEM_CREATESURFACEEX;

                    ASSERTGDI(peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice(),
                              "DXG: CreateSurfaceEx: calling non-owner driver");
                }
            }
        }
        else
        {
            return DDERR_GENERIC;
        }
    }
    return DD_OK;
}

/******************************Public*Routine******************************\
* VOID DxDdCloseProcess
*
*   2-May-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID DxDdCloseProcess(W32PID w32Pid)
{
    DdHmgCloseProcess(w32Pid);
}

/******************************Public*Routine******************************\
* PVOID DxDdAllocPrivateUserMem()
*
* History:
*  28-Oct-1999 -by-  Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

PVOID
DxDdAllocPrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    SIZE_T cj,  //ZwAllocateVirtualMemory uses SIZE_T, change accordingly
    ULONG tag
    )
{
    EDD_SURFACE *peSurface = (EDD_SURFACE *) pSurfaceLocal;
    PVOID pv = NULL;

    //
    // DirectDraw can call the driver outside of it's process (e.g. switching
    // desktops, etc.), so this function helps protect against that.
    //

    if (PsGetCurrentProcess() == peSurface->peDirectDrawLocal->Process)
    {
        pv = EngAllocUserMem ( cj, tag );
    }

    return pv;
}

/******************************Public*Routine******************************\
* DxDdFreePrivateUserMem()
*
* History:
*  28-Oct-1999 -by-  Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
DxDdFreePrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    PVOID pv
    )
{
    EDD_SURFACE *peSurface = (EDD_SURFACE *) pSurfaceLocal;

    // If the surface has an aliased lock on it, then we don't want
    // to delete this memory now or else the app may fault, so we put
    // it in a list of memory to free later.
    
    if (peSurface->fl & DD_SURFACE_FLAG_ALIAS_LOCK)
    {
        DeferMemoryFree(pv, peSurface);
    }
    else
    {   
        SafeFreeUserMem(pv, peSurface->peDirectDrawLocal->Process);
    }
    return;
}

/******************************Public*Routine******************************\
* DxDdIoctl()
*
* History:
*  17-Apr-2001 -by-  Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

HRESULT
DxDdIoctl(
    ULONG   Ioctl,
    PVOID   pBuffer,
    ULONG   BufferSize
    )
{
    return DDERR_UNSUPPORTED;
}

/******************************Public*Routine******************************\
*
* DxDdLock/UnlockDirectDrawSurface
*
* Functions to allow drivers to lock and unlock DirectDraw surface handles
* that may get passed to them.
*
* Such handles are currently passed to the driver in the Direct3D texture
* interface, necessitating these functions.
*
* History:
*  Wed Oct 23 15:52:27 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PDD_SURFACE_LOCAL
DxDdLockDirectDrawSurface(HANDLE hSurface)
{
    EDD_SURFACE *peSurf;

    peSurf = (EDD_SURFACE *)DdHmgLock((HDD_OBJ)hSurface, DD_SURFACE_TYPE, FALSE);
    if (peSurf != NULL)
    {
        return (PDD_SURFACE_LOCAL)peSurf;
    }
    else
    {
        return peSurf;
    }
}

BOOL
DxDdUnlockDirectDrawSurface(PDD_SURFACE_LOCAL pSurface)
{
    if (pSurface != NULL)
    {
        DEC_EXCLUSIVE_REF_CNT((EDD_SURFACE *)pSurface);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************Public*Routine******************************\
* BOOL DxDdEnableDirectDrawRedirection
*
*  11-Apr-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL DxDdEnableDirectDrawRedirection(HDEV hdev, BOOL bEnable)
{
#ifdef DX_REDIRECTION
    LONG* pl;

    PDEVOBJ po(hdev);

    if (po.bValid())
    {
        // Hold devlock to prevent from mode change.

        EDD_DEVLOCK eDevLock(po.hdev());

        // Bump the mode uniqueness to let user-mode DirectDraw know that
        // someone else has done 'something' need to refresh user-mode
        // data.

        INC_DISPLAY_UNIQUENESS();

        // Save redirection status

        gbDxRedirection = bEnable;

        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
#else
    return (FALSE);
#endif // DX_REDIRECTION
}

/******************************Public*Routine******************************\
* VOID DxDdSetAccelLevel
*
*   2-Oct-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID DxDdSetAccelLevel(HDEV hdev, DWORD dwAccelLevel, DWORD dwOverride)
{
    if ((dwAccelLevel >= 3) || 
        (dwOverride & DRIVER_NOT_CAPABLE_DDRAW))
    {
        PDEVOBJ po(hdev);

        po.peDirectDrawGlobal()->llAssertModeTimeout = 0;
    }
}

/******************************Public*Routine******************************\
* VOID DxDdGetSurfaceLock
*
*   2-Oct-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

DWORD DxDdGetSurfaceLock(HDEV hdev)
{
    PDEVOBJ po(hdev);

    return (po.peDirectDrawGlobal()->cSurfaceLocks);
}

/******************************Public*Routine******************************\
* VOID DxDdEnumLockedSurfaceRect
*
*   2-Oct-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

PVOID DxDdEnumLockedSurfaceRect(HDEV hdev, PVOID pvSurface, RECTL *pRect)
{
    PDEVOBJ     po(hdev);

    EDD_SURFACE *peSurface;

    if (pvSurface == NULL)
    {
        peSurface = po.peDirectDrawGlobal()->peSurface_PrimaryLockList;
    }
    else
    {
        peSurface = ((EDD_SURFACE *)pvSurface)->peSurface_PrimaryLockNext;
    }

    if (peSurface)
    {
        *pRect = peSurface->rclLock;
    }

    return ((PVOID)peSurface);
}

/******************************Public*Routine******************************\
* DWORD DxDxgGenericThunk
*
*  14-Jun-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it (stub).
\**************************************************************************/

DWORD DxDxgGenericThunk(
    IN     ULONG_PTR ulIndex,
    IN     ULONG_PTR ulHandle,
    IN OUT SIZE_T   *pdwSizeOfPtr1,
    IN OUT PVOID     pvPtr1,
    IN OUT SIZE_T   *pdwSizeOfPtr2,
    IN OUT PVOID     pvPtr2)
{
    UNREFERENCED_PARAMETER(ulIndex);
    UNREFERENCED_PARAMETER(ulHandle);
    UNREFERENCED_PARAMETER(pdwSizeOfPtr1);
    UNREFERENCED_PARAMETER(pvPtr1);
    UNREFERENCED_PARAMETER(pdwSizeOfPtr2);
    UNREFERENCED_PARAMETER(pvPtr2);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\debugko.cxx ===
/******************************Module*Header*******************************\
* Module Name: debugko.cxx
*
* Contains compile in routines that match the kernel debugger extensions
*
* Created: 16-jun-1995
* Author: Andre Vachon [andreva]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if DBG

LONG gWarningLevel = 0;

// DoWarning1 is for ASM functions to call at Warning Level 1

VOID DoWarning1(PSZ psz)
{
    if (1 <= gWarningLevel)
    {
        DbgPrint("DXG: ");
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoWarning(PSZ psz, LONG ulLevel)
{
    if (ulLevel <= gWarningLevel)
    {
        DbgPrint("DXG: ");
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoRip(PSZ psz)
{
    if (gWarningLevel >= 0)
    {
        DbgPrint("DXG Assertion: ");
        DbgPrint(psz);
        DbgPrint("\n");
        DbgBreakPoint();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxgthk\dxgthk.c ===
#include <windows.h>
#include <winddi.h>

#define STANDARD_DEBUG_PREFIX "DXGTHK.SYS:"

ULONG
DriverEntry(
    PVOID DriverObject,
    PVOID RegistryPath
    );

VOID
DebugPrint(
    PCHAR DebugMessage,
    ...
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,DebugPrint)
#endif

/***************************************************************************\
* VOID DebugPrint
*
\***************************************************************************/

VOID
DebugPrint(
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;
    va_start(ap, DebugMessage);
    EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    EngDebugPrint("", "\n", ap);
    va_end(ap);

} // DebugPrint()

/***************************************************************************\
* NTSTATUS DriverEntry
*
* This routine is never actually called, but we need it to link.
*
\***************************************************************************/

ULONG
DriverEntry(
    PVOID DriverObject,
    PVOID RegistryPath
    )
{
    DebugPrint("DriverEntry should not be called");
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\dxg.cxx ===
/******************************Module*Header*******************************\
* Module Name: dxg.cxx
*
* Contains the kernel-mode code for DirectX graphics.
*
* Created: 20-Apr-2000
* Author: Hideyuki Nagase [hideyukn]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include <precomp.hxx>

extern "C" {
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );
}

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,DriverEntry)
#endif

#if defined(_X86_)
ULONG_PTR DxgUserProbeAddress;
#endif

DRVFN gaDxgFuncs[] =
{
    { INDEX_DxDxgGenericThunk,                (PFN) DxDxgGenericThunk               },
    { INDEX_DxD3dContextCreate,               (PFN) DxD3dContextCreate              },
    { INDEX_DxD3dContextDestroy,              (PFN) DxD3dContextDestroy             },
    { INDEX_DxD3dContextDestroyAll,           (PFN) DxD3dContextDestroyAll          },
    { INDEX_DxD3dValidateTextureStageState,   (PFN) DxD3dValidateTextureStageState  },
    { INDEX_DxD3dDrawPrimitives2,             (PFN) DxD3dDrawPrimitives2            },
    { INDEX_DxDdGetDriverState,               (PFN) DxDdGetDriverState              },
    { INDEX_DxDdAddAttachedSurface,           (PFN) DxDdAddAttachedSurface          },
    { INDEX_DxDdAlphaBlt,                     (PFN) DxDdAlphaBlt                    },
    { INDEX_DxDdAttachSurface,                (PFN) DxDdAttachSurface               },
    { INDEX_DxDdBeginMoCompFrame,             (PFN) DxDdBeginMoCompFrame            },
    { INDEX_DxDdBlt,                          (PFN) DxDdBlt                         },
    { INDEX_DxDdCanCreateSurface,             (PFN) DxDdCanCreateSurface            },
    { INDEX_DxDdCanCreateD3DBuffer,           (PFN) DxDdCanCreateD3DBuffer          },
    { INDEX_DxDdColorControl,                 (PFN) DxDdColorControl                },
    { INDEX_DxDdCreateDirectDrawObject,       (PFN) DxDdCreateDirectDrawObject      },
    { INDEX_DxDdCreateSurface,                (PFN) DxDdCreateSurface               },
    { INDEX_DxDdCreateD3DBuffer,              (PFN) DxDdCreateD3DBuffer             },
    { INDEX_DxDdCreateMoComp,                 (PFN) DxDdCreateMoComp                },
    { INDEX_DxDdCreateSurfaceObject,          (PFN) DxDdCreateSurfaceObject         },
    { INDEX_DxDdDeleteDirectDrawObject,       (PFN) DxDdDeleteDirectDrawObject      },
    { INDEX_DxDdDeleteSurfaceObject,          (PFN) DxDdDeleteSurfaceObject         },
    { INDEX_DxDdDestroyMoComp,                (PFN) DxDdDestroyMoComp               },
    { INDEX_DxDdDestroySurface,               (PFN) DxDdDestroySurface              },
    { INDEX_DxDdDestroyD3DBuffer,             (PFN) DxDdDestroyD3DBuffer            },
    { INDEX_DxDdEndMoCompFrame,               (PFN) DxDdEndMoCompFrame              },
    { INDEX_DxDdFlip,                         (PFN) DxDdFlip                        },
    { INDEX_DxDdFlipToGDISurface,             (PFN) DxDdFlipToGDISurface            },
    { INDEX_DxDdGetAvailDriverMemory,         (PFN) DxDdGetAvailDriverMemory        },
    { INDEX_DxDdGetBltStatus,                 (PFN) DxDdGetBltStatus                },
    { INDEX_DxDdGetDC,                        (PFN) DxDdGetDC                       },
    { INDEX_DxDdGetDriverInfo,                (PFN) DxDdGetDriverInfo               },
    { INDEX_DxDdGetDxHandle,                  (PFN) DxDdGetDxHandle                 },
    { INDEX_DxDdGetFlipStatus,                (PFN) DxDdGetFlipStatus               },
    { INDEX_DxDdGetInternalMoCompInfo,        (PFN) DxDdGetInternalMoCompInfo       },
    { INDEX_DxDdGetMoCompBuffInfo,            (PFN) DxDdGetMoCompBuffInfo           },
    { INDEX_DxDdGetMoCompGuids,               (PFN) DxDdGetMoCompGuids              },
    { INDEX_DxDdGetMoCompFormats,             (PFN) DxDdGetMoCompFormats            },
    { INDEX_DxDdGetScanLine,                  (PFN) DxDdGetScanLine                 },
    { INDEX_DxDdLock,                         (PFN) DxDdLock                        },
    { INDEX_DxDdLockD3D,                      (PFN) DxDdLockD3D                     },
    { INDEX_DxDdQueryDirectDrawObject,        (PFN) DxDdQueryDirectDrawObject       },
    { INDEX_DxDdQueryMoCompStatus,            (PFN) DxDdQueryMoCompStatus           },
    { INDEX_DxDdReenableDirectDrawObject,     (PFN) DxDdReenableDirectDrawObject    },
    { INDEX_DxDdReleaseDC,                    (PFN) DxDdReleaseDC                   },
    { INDEX_DxDdRenderMoComp,                 (PFN) DxDdRenderMoComp                },
    { INDEX_DxDdResetVisrgn,                  (PFN) DxDdResetVisrgn                 },
    { INDEX_DxDdSetColorKey,                  (PFN) DxDdSetColorKey                 },
    { INDEX_DxDdSetExclusiveMode,             (PFN) DxDdSetExclusiveMode            },
    { INDEX_DxDdSetGammaRamp,                 (PFN) DxDdSetGammaRamp                },
    { INDEX_DxDdCreateSurfaceEx,              (PFN) DxDdCreateSurfaceEx             },
    { INDEX_DxDdSetOverlayPosition,           (PFN) DxDdSetOverlayPosition          },
    { INDEX_DxDdUnattachSurface,              (PFN) DxDdUnattachSurface             },
    { INDEX_DxDdUnlock,                       (PFN) DxDdUnlock                      },
    { INDEX_DxDdUnlockD3D,                    (PFN) DxDdUnlockD3D                   },
    { INDEX_DxDdUpdateOverlay,                (PFN) DxDdUpdateOverlay               },
    { INDEX_DxDdWaitForVerticalBlank,         (PFN) DxDdWaitForVerticalBlank        },
    { INDEX_DxDvpCanCreateVideoPort,          (PFN) DxDvpCanCreateVideoPort         },
    { INDEX_DxDvpColorControl,                (PFN) DxDvpColorControl               },
    { INDEX_DxDvpCreateVideoPort,             (PFN) DxDvpCreateVideoPort            },
    { INDEX_DxDvpDestroyVideoPort,            (PFN) DxDvpDestroyVideoPort           },
    { INDEX_DxDvpFlipVideoPort,               (PFN) DxDvpFlipVideoPort              },
    { INDEX_DxDvpGetVideoPortBandwidth,       (PFN) DxDvpGetVideoPortBandwidth      },
    { INDEX_DxDvpGetVideoPortField,           (PFN) DxDvpGetVideoPortField          },
    { INDEX_DxDvpGetVideoPortFlipStatus,      (PFN) DxDvpGetVideoPortFlipStatus     },
    { INDEX_DxDvpGetVideoPortInputFormats,    (PFN) DxDvpGetVideoPortInputFormats   },
    { INDEX_DxDvpGetVideoPortLine,            (PFN) DxDvpGetVideoPortLine           },
    { INDEX_DxDvpGetVideoPortOutputFormats,   (PFN) DxDvpGetVideoPortOutputFormats  },
    { INDEX_DxDvpGetVideoPortConnectInfo,     (PFN) DxDvpGetVideoPortConnectInfo    },
    { INDEX_DxDvpGetVideoSignalStatus,        (PFN) DxDvpGetVideoSignalStatus       },
    { INDEX_DxDvpUpdateVideoPort,             (PFN) DxDvpUpdateVideoPort            },
    { INDEX_DxDvpWaitForVideoPortSync,        (PFN) DxDvpWaitForVideoPortSync       },
    { INDEX_DxDvpAcquireNotification,         (PFN) DxDvpAcquireNotification        },
    { INDEX_DxDvpReleaseNotification,         (PFN) DxDvpReleaseNotification        },
    { INDEX_DxDdHeapVidMemAllocAligned,       (PFN) DxDdHeapVidMemAllocAligned      },
    { INDEX_DxDdHeapVidMemFree,               (PFN) DxDdHeapVidMemFree              },
    { INDEX_DxDdEnableDirectDraw,             (PFN) DxDdEnableDirectDraw            },
    { INDEX_DxDdDisableDirectDraw,            (PFN) DxDdDisableDirectDraw           },
    { INDEX_DxDdSuspendDirectDraw,            (PFN) DxDdSuspendDirectDraw           },
    { INDEX_DxDdResumeDirectDraw,             (PFN) DxDdResumeDirectDraw            },
    { INDEX_DxDdDynamicModeChange,            (PFN) DxDdDynamicModeChange           },
    { INDEX_DxDdCloseProcess,                 (PFN) DxDdCloseProcess                },
    { INDEX_DxDdGetDirectDrawBounds,          (PFN) DxDdGetDirectDrawBounds         },
    { INDEX_DxDdEnableDirectDrawRedirection,  (PFN) DxDdEnableDirectDrawRedirection },
    { INDEX_DxDdAllocPrivateUserMem,          (PFN) DxDdAllocPrivateUserMem         },
    { INDEX_DxDdFreePrivateUserMem,           (PFN) DxDdFreePrivateUserMem          },
    { INDEX_DxDdLockDirectDrawSurface,        (PFN) DxDdLockDirectDrawSurface       },
    { INDEX_DxDdUnlockDirectDrawSurface,      (PFN) DxDdUnlockDirectDrawSurface     },
    { INDEX_DxDdSetAccelLevel,                (PFN) DxDdSetAccelLevel               },
    { INDEX_DxDdGetSurfaceLock,               (PFN) DxDdGetSurfaceLock              },
    { INDEX_DxDdEnumLockedSurfaceRect,        (PFN) DxDdEnumLockedSurfaceRect       },
    { INDEX_DxDdIoctl,                        (PFN) DxDdIoctl                       }
};

ULONG gcDxgFuncs = sizeof(gaDxgFuncs) / sizeof(DRVFN);

//
// Pointer to the pointer table to Win32k.sys
//

DRVFN *gpEngFuncs = NULL;

//
// This is the global pointer to the dummy page to which all of the video
// memory is mapped when we need to forcibly unmap it. Instead of causing
// the app to fault accessing unmapped memory, we remap it to this play
// area where it can doodle around till it discovers that it had "lost"
// surfaces.
//
PVOID      gpDummyPage;
LONG       gcDummyPageRefCnt;
HSEMAPHORE ghsemDummyPage;

PEPROCESS  gpepSession = NULL;

/***************************************************************************\
* NTSTATUS DriverEntry
*
* This routine is never actually called, but we need it to link.
*
\***************************************************************************/

extern "C"
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    return(STATUS_SUCCESS);
}

/***************************************************************************\
* NTSTATUS StartupDxGraphics
*
* This routine is called by win32k.sys to initialize dxg.sys.
*
\***************************************************************************/

extern "C"
NTSTATUS
DxDdStartupDxGraphics(
    ULONG          cjEng,
    DRVENABLEDATA *pdedEng,
    ULONG          cjDxg,
    DRVENABLEDATA *pdedDxg,
    DWORD         *pdwDirectDrawContext,
    PEPROCESS      pepSession
    )
{
    if ((cjEng >= sizeof(DRVENABLEDATA))  &&
        (cjDxg >= sizeof(DRVENABLEDATA)))
    {
        //
        // Initialize global variables
        //
        gpDummyPage = NULL;
        gcDummyPageRefCnt = 0;
        ghsemDummyPage = NULL;

        //
        // Give back function pointers to GDI, which they will call.
        //
        pdedDxg->iDriverVersion = 0x00080000; // Supporting until DX8.
        pdedDxg->c              = gcDxgFuncs;
        pdedDxg->pdrvfn         = gaDxgFuncs;

        //
        // pdedEng->iDriverVersion contains win32k version (= OS platform version).
        //
        //  - 0x00050001 for Whistler.
        //

        //
        // Check the function printers from GDI, which we will call.
        //
        if (pdedEng->c != INDEX_WIN32K_TABLE_SIZE)
        {
            WARNING("pdedEng->c != INDEX_WIN32K_TABLE_MAX\n");
            return STATUS_INTERNAL_ERROR;
        }

        //
        // Make sure all pointers are sorted and nothing missing.
        //
        for (ULONG i = 1; i < INDEX_WIN32K_TABLE_SIZE; i++)
        {
            if ((pdedEng->pdrvfn[i].iFunc != i) ||
                (pdedEng->pdrvfn[i].pfn == NULL))
            {
                WARNING("pdedEng->pdrvfn is not well orded or pointer is missing\n");
                return STATUS_INTERNAL_ERROR;
            }
        }

        //
        // If everything is good, keep the pointer.
        //
        gpEngFuncs = pdedEng->pdrvfn;

        //
        // Return size of DirectDraw context, so that GDI can allocate it inside HDEV.
        //
        *pdwDirectDrawContext = sizeof(EDD_DIRECTDRAW_GLOBAL);

        //
        // Initialize handle manager
        //
        if (!DdHmgCreate())
        {
            goto Error_Exit;
        }

        //
        // Create semaphore to sync dummy page global variable.
        //
        if ((ghsemDummyPage = EngCreateSemaphore()) == NULL)
        {
            goto Error_Exit;
        }

#if defined(_X86_)
        //
        // Keep our own copy of this to avoid double indirections on probing
        //
        DxgUserProbeAddress = *MmUserProbeAddress;
#endif

        //
        // Keep pointer to CsrSS process for this session.
        //
        gpepSession = pepSession;

        return(STATUS_SUCCESS);
    }

    return(STATUS_BUFFER_TOO_SMALL);

Error_Exit:

    DdHmgDestroy();

    if (ghsemDummyPage)
    {
        EngDeleteSemaphore(ghsemDummyPage);
        ghsemDummyPage = NULL;
    }

    return(STATUS_NO_MEMORY);
}

/***************************************************************************\
* NTSTATUS CleanupDxGraphics
*
* This routine is called by win32k.sys to uninitialize dxg.sys
* just before unload.
*
\***************************************************************************/

extern "C"
NTSTATUS
DxDdCleanupDxGraphics(VOID)
{
    DdHmgDestroy();

    if (ghsemDummyPage)
    {
        if (gpDummyPage)
        {
            ExFreePool(gpDummyPage);
            gpDummyPage = NULL;
            gcDummyPageRefCnt = 0;
        }

        EngDeleteSemaphore(ghsemDummyPage);
        ghsemDummyPage = NULL;
    }

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddvpe.cxx ===
/******************************Module*Header*******************************\
* Module Name: dvpe.cxx
*
* Contains all of GDI's private VideoPort APIs.
*
* Note that for videoport support, WIN32K.SYS and DXAPI.SYS are closely
* linked.  DXAPI.SYS provides two services:
*
*   1.  It handles the "software autoflipping" support for the videoports,
*       where the CPU handles the videoport field-done interrupt to
*       flip the overlay and do "bob" and "weave" for better video
*       quality.
*   2.  It provides the public DirectDraw entry points that are callable
*       by other kernel-mode WDM drivers (there is a corresponding DXAPI.SYS
*       module on Memphis/Win95 that exposes the same interface).
*
* All of the non-paged code for videoports has to go into DXAPI.SYS since
* WIN32K.SYS is marked entirely as pageable.  WIN32K.SYS handles some
* functionality on behalf of DXAPI.SYS, such as object opens and closes,
* since only WIN32K.SYS can access GDI's handle table.
*
* Created: 17-Oct-1996
* Author: Lingyun Wang [LingyunW]
*
* Copyright (c) 1996-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern PEPROCESS gpepSession;

VOID
vDdDxApiFreeDirectDraw(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    );

/////////////////////////////////////////////////////////////////////////
// DXAPI concerns:
//
// - Document that call-back may not occur in context of same process
// - Refuse to open surface, videoport objects while full-screen
//     Keep DirectDraw open so that POSTFULLSCREEN and DOSBOX can be honored
// - See InitKernelInterface for init restrictions
// - Flush DMA buffer before mode changes?
// - Invalidate dxapi data after mode change?
// - Right now, DirectDraw DXAPI objects have to be closed last

/////////////////////////////////////////////////////////////////////////
// VPE concerns:
//
// - Make sure VideoPort's not duplicated on same device
// - Document that display driver cannot use pool-allocated memory for
//     dwReserved fields on Synchronize calls
// - Close DxVideoPort objects on full-screen switch?
//     No, to support hardware that can DMA even while full-screen!
//     Okay, but what about mode changes?  There's no way they'll not
//     be able to drop frames
// - Never close DxDirectDraw objects?

/*****************************Private*Routine******************************\
* ULONG vDdNullCallBack
*
* The DXAPI register routines require a close call-back routine to notify
* the client that the object is going away.  Since we're really DirectDraw,
* we already know when the object is going away; hence, this routine doesn't
* need to do anything.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG
vDdNullCallBack(
    DWORD   dwFlags,
    PVOID   pContext,
    DWORD   dwParam1,
    DWORD   dwParam2
    )
{
    return 0;
}

/*****************************Private*Routine******************************\
* VOID vDdUnloadDxApiImage
*
* This routine performs the actual unload of DXAPI.SYS.
*
*  28-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
vDdUnloadDxApiImage(
    EDD_DIRECTDRAW_GLOBAL*   peDirectDrawGlobal
    )
{
    EDD_VIDEOPORT*        peVideoPort;
    EDD_VIDEOPORT*        peVideoPortNext;
    EDD_SURFACE*          peSurface;
    EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    // Notify clients that the resources are lost and clean up

    for (peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
        peDirectDrawLocal != NULL;
        peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext)
    {
        // If any video port still exist (which should not be the case)
        // delete all of the video port objects since the video port assumes
        // that DXAPI.SYS is loaded.

        for (peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
            peVideoPort != NULL;
            peVideoPort = peVideoPortNext)
        {
            // Don't reference peVideoPort after it's been deleted!

            peVideoPortNext = peVideoPort->peVideoPort_DdNext;
            bDdDeleteVideoPortObject(peVideoPort->hGet(), NULL);
        }

        // If a surface still has a client using it, shut it down.

        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

        while (peSurface)
        {
            if (peSurface->hSurface != NULL)
            {
                vDdDxApiFreeSurface( (DXOBJ*) peSurface->hSurface, FALSE );
                peSurface->hSurface = NULL;
            }
            if( peSurface->peDxSurface != NULL )
            {
                vDdLoseDxObjects( peDirectDrawGlobal,
                    peSurface->peDxSurface->pDxObj_List,
                    (PVOID) peSurface->peDxSurface,
                    LO_SURFACE );
            }
            peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
        }
    }
    if (peDirectDrawGlobal->hDirectDraw != NULL)
    {
        vDdDxApiFreeDirectDraw( (DXOBJ*) peDirectDrawGlobal->hDirectDraw, FALSE );
    }
    if( peDirectDrawGlobal->peDxDirectDraw != NULL )
    {
        vDdLoseDxObjects( peDirectDrawGlobal,
            peDirectDrawGlobal->peDxDirectDraw->pDxObj_List,
            (PVOID) peDirectDrawGlobal->peDxDirectDraw,
            LO_DIRECTDRAW );
    }

    EngUnloadImage(peDirectDrawGlobal->hDxApi);

    //
    // Free the memory associate with the module
    //

    peDirectDrawGlobal->hDxApi = NULL;
    peDirectDrawGlobal->dwDxApiRefCnt = 0;
}

/*****************************Private*Routine******************************\
* BOOL bDdLoadDxApi
*
* This routine loads up DXAPI.SYS and allocates the non-paged DXAPI
* structures.
*
* Returns: FALSE only if a DXAPI resource could not be allocated.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
*  16-Oct-1977 -by- smac
* Broke it out into a separate function.
\**************************************************************************/

BOOL
bDdLoadDxApi(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal
    )
{
    EDD_DIRECTDRAW_GLOBAL*   peDirectDrawGlobal;
    HANDLE                  hDxApi;
    PFNDXAPIINITIALIZE      pfnDxApiInitialize;
    DDOPENDIRECTDRAWIN      OpenDirectDrawIn;
    DDOPENDIRECTDRAWOUT     OpenDirectDrawOut;
    DWORD                   dwRet;

    DD_ASSERTDEVLOCK(peDirectDrawLocal->peDirectDrawGlobal);
    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    /*
     * Don't load if it's already loaded
     */
    if (peDirectDrawGlobal->hDxApi == NULL)
    {
        ASSERTGDI((peDirectDrawGlobal->hDirectDraw == NULL) &&
                  (peDirectDrawGlobal->hDxApi == NULL),
            "Expected NULL hDirectDraw and hDxApi");

        BOOL loaded;

        hDxApi = DxEngLoadImage(L"drivers\\dxapi.sys",FALSE);
        if (hDxApi)
        {
            peDirectDrawGlobal->hDxApi = hDxApi;
            peDirectDrawGlobal->pfnDxApi = (LPDXAPI)
                EngFindImageProcAddress(hDxApi, "_DxApi");
            peDirectDrawGlobal->pfnAutoflipUpdate = (PFNAUTOFLIPUPDATE)
                EngFindImageProcAddress(hDxApi, "_DxAutoflipUpdate");
            peDirectDrawGlobal->pfnLoseObject = (PFNLOSEOBJECT)
                EngFindImageProcAddress(hDxApi, "_DxLoseObject");
            pfnDxApiInitialize = (PFNDXAPIINITIALIZE)
                EngFindImageProcAddress(hDxApi, "_DxApiInitialize");
            peDirectDrawGlobal->pfnEnableIRQ = (PFNENABLEIRQ)
                EngFindImageProcAddress(hDxApi, "_DxEnableIRQ");
            peDirectDrawGlobal->pfnUpdateCapture = (PFNUPDATECAPTURE)
                EngFindImageProcAddress(hDxApi, "_DxUpdateCapture");

            ASSERTGDI(peDirectDrawGlobal->pfnDxApi != NULL,
                "Couldn't find DxApi'");
            ASSERTGDI(peDirectDrawGlobal->pfnAutoflipUpdate != NULL,
                "Couldn't find DxAutoflipUpdate");
            ASSERTGDI(peDirectDrawGlobal->pfnLoseObject != NULL,
                "Couldn't find DxLoseObject");
            ASSERTGDI(peDirectDrawGlobal->pfnEnableIRQ != NULL,
                "Couldn't find DxEnableIRQ");
            ASSERTGDI(peDirectDrawGlobal->pfnUpdateCapture != NULL,
                "Couldn't find DxUpdateCapture");
            ASSERTGDI(pfnDxApiInitialize != NULL,
                "Couldn't find DxApiInitialize");

            // By explicitly passing dxapi.sys its private win32k.sys
            // entry points, we don't have to export them from win32k.sys,
            // thus preventing any drivers from using those entry points
            // for their own nefarious purposes.

            pfnDxApiInitialize(DdDxApiOpenDirectDraw,
                               DdDxApiOpenVideoPort,
                               DdDxApiOpenSurface,
                               DdDxApiCloseHandle,
                               DdDxApiGetKernelCaps,
                               DdDxApiOpenCaptureDevice,
                               DdDxApiLockDevice,
                               DdDxApiUnlockDevice);

            // EngLoadImage always makes the entire driver pageable, but
            // DXAPI.SYS handles the DPC for the videoport interrupt and
            // so cannot be entirely pageable.  Consequently, we reset
            // the paging now:

            MmResetDriverPaging(pfnDxApiInitialize);

            // Now open the DXAPI version of DirectDraw:

            OpenDirectDrawIn.pfnDirectDrawClose = vDdNullCallBack;
            OpenDirectDrawIn.pContext          = NULL;
            OpenDirectDrawIn.dwDirectDrawHandle
                = (ULONG_PTR) peDirectDrawLocal->hGet();

            peDirectDrawGlobal->pfnDxApi(DD_DXAPI_OPENDIRECTDRAW,
                                         &OpenDirectDrawIn,
                                         sizeof(OpenDirectDrawIn),
                                         &OpenDirectDrawOut,
                                         sizeof(OpenDirectDrawOut));

            if (OpenDirectDrawOut.ddRVal == DD_OK)
            {
                // Success!
                peDirectDrawGlobal->hDirectDraw = OpenDirectDrawOut.hDirectDraw;
            }

            peDirectDrawGlobal->dwDxApiRefCnt = 1;
        }
        else
        {
            WARNING("bDdLoadDxApi: Couldn't load dxapi.sys\n");
            return(FALSE);
        }
    }
    else
    {
        peDirectDrawGlobal->dwDxApiRefCnt++;
    }

    return(TRUE);
}

/*****************************Private*Routine******************************\
* VOID vDdUnloadDxApi
*
* This routine unloads DXAPI.SYS
*
*  22-Oct-1997 -by- smac
\**************************************************************************/

VOID
vDdUnloadDxApi(
    EDD_DIRECTDRAW_GLOBAL*   peDirectDrawGlobal
    )
{
    DDCLOSEHANDLE           CloseHandle;
    DWORD                   dwRet;

    if ((peDirectDrawGlobal->hDxApi != NULL) &&
        (peDirectDrawGlobal->dwDxApiRefCnt > 0 ))
    {
        if( --peDirectDrawGlobal->dwDxApiRefCnt == 0 )
        {
            if (peDirectDrawGlobal->hDirectDraw != NULL)
            {
                CloseHandle.hHandle = peDirectDrawGlobal->hDirectDraw;

                peDirectDrawGlobal->pfnDxApi(DD_DXAPI_CLOSEHANDLE,
                    &CloseHandle,
                    sizeof(CloseHandle),
                    &dwRet,
                    sizeof(dwRet));

                ASSERTGDI(dwRet == DD_OK, "Unexpected failure from close");

                peDirectDrawGlobal->hDirectDraw = NULL;
            }

            vDdUnloadDxApiImage( peDirectDrawGlobal );
        }
    }
}

/*****************************Private*Routine******************************\
* BOOL bDdEnableSoftwareAutoflipping
*
* This routine loads up DXAPI.SYS, allocates the non-paged DXAPI structures
* required for software autoflipping, and enables the videoport interrupt.
*
* Returns: FALSE only if a DXAPI resource could not be allocated.  May
*          return TRUE even if the interrupt hasn't been successfully
*          enabled (because I expect that interrupts will be usable
*          on the majority of systems that support videoports, and this
*          simplifies other code by allowing it to assume that all the
*          DXAPI structures have been allocated).
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdEnableSoftwareAutoflipping(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    EDD_VIDEOPORT*          peVideoPort,
    DWORD                   dwVideoPortID,
    BOOL                    bFirst
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HANDLE                  hDxApi;
    PFNDXAPIINITIALIZE      pfnDxApiInitialize;
    DDOPENDIRECTDRAWIN      OpenDirectDrawIn;
    DDOPENDIRECTDRAWOUT     OpenDirectDrawOut;
    DDOPENVIDEOPORTIN       OpenVideoPortIn;
    DDOPENVIDEOPORTOUT      OpenVideoPortOut;
    DWORD                   dwRet;
    UNICODE_STRING          UnicodeString;

    DD_ASSERTDEVLOCK(peVideoPort->peDirectDrawGlobal);

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

    // Create a DXAPI DirectDraw object, which we'll need for software
    // autoflipping.

    if (bFirst)
    {
        bDdLoadDxApi( peDirectDrawLocal );
    }

    if (peDirectDrawGlobal->hDirectDraw != NULL)
    {
        ASSERTGDI(peVideoPort->hVideoPort == NULL, "Expected NULL hVideoPort");

        OpenVideoPortIn.hDirectDraw       = peDirectDrawGlobal->hDirectDraw;
        OpenVideoPortIn.pfnVideoPortClose = vDdNullCallBack;
        OpenVideoPortIn.pContext          = NULL;
        OpenVideoPortIn.dwVideoPortHandle = dwVideoPortID;

        peDirectDrawGlobal->pfnDxApi(DD_DXAPI_OPENVIDEOPORT,
                                     &OpenVideoPortIn,
                                     sizeof(OpenVideoPortIn),
                                     &OpenVideoPortOut,
                                     sizeof(OpenVideoPortOut));

        if (OpenVideoPortOut.ddRVal == DD_OK)
        {
            peVideoPort->hVideoPort = OpenVideoPortOut.hVideoPort;
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDdNotifyEvent
*
* This routine calls back to all registered DXAPI clients when a particular
* event (like mode change notification) occurs.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdNotifyEvent(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    DWORD                   dwEvent
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DXAPI_EVENT*        pDxEvent;

    peDxDirectDraw = peDirectDrawGlobal->peDxDirectDraw;

    if (peDxDirectDraw != NULL)
    {
        DD_ASSERTDEVLOCK(peDirectDrawGlobal);

        for (pDxEvent = peDxDirectDraw->pDxEvent_PassiveList;
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if (pDxEvent->dwEvent == dwEvent)
            {
                pDxEvent->pfnCallBack(pDxEvent->dwEvent,pDxEvent->pContext, 0, 0);
            }
        }
    }
}

/******************************Public*Routine******************************\
* DXAPI_OBJECT* pDdDxObjHandleAllocate
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DXOBJ*
pDdDxObjHandleAllocate(
    DXTYPE              iDxType,
    LPDD_NOTIFYCALLBACK pfnClose,
    DWORD               dwEvent,
    PVOID               pvContext
    )
{
    DXOBJ* pDxObj;

    ASSERTGDI(pfnClose != NULL,
        "pDdDxObjHandleAllocate: DXAPI client must supply Close function");

    pDxObj = (DXOBJ*) PALLOCNONPAGED(sizeof(*pDxObj),'xxdG');
    if (pDxObj != NULL)
    {
        pDxObj->iDxType     = iDxType;
        pDxObj->pfnClose    = pfnClose;
        pDxObj->pContext    = pvContext;
        pDxObj->dwEvent     = dwEvent;
        pDxObj->pDxObj_Next = NULL;
        pDxObj->dwFlags     = 0;
        pDxObj->pepSession  = gpepSession;
    }

    return(pDxObj);
}

// Should be macro for free build.

PVOID
pDdDxObjDataAllocate(
    ULONG cj,
    ULONG tag
    )
{
    return (PALLOCNONPAGED(cj,tag));
}

VOID
vDdDxObjFree(
    PVOID pvDxObj
    )
{
    VFREEMEM(pvDxObj);
}

/******************************Public*Routine******************************\
* VOID vDdQueryMiniportDxApiSupport
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdQueryMiniportDxApiSupport(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL bMiniportSupport;

    // Assume failure.
    bMiniportSupport = FALSE;

    if (bDdIoQueryInterface(peDirectDrawGlobal,
                            &GUID_DxApi,
                            sizeof(DXAPI_INTERFACE),
                            DXAPI_HALVERSION,
                            (INTERFACE *)&peDirectDrawGlobal->DxApiInterface))
    {
        ASSERTGDI((peDirectDrawGlobal->DxApiInterface.
                   InterfaceReference == NULL) &&
                  (peDirectDrawGlobal->DxApiInterface.
                   InterfaceDereference == NULL),
                  "Miniport shouldn't modify InterfaceReference/Dereference");

        // Assert some stuff about hooked entry points?

        peDirectDrawGlobal->HwDeviceExtension
            = peDirectDrawGlobal->DxApiInterface.Context;
        bMiniportSupport = TRUE;
    }

    // Even if the miniport doesn't support DXAPI accelerations, we still
    // allow DXAPI to work (the DXAPI Lock call doesn't require that the
    // miniport support DXAPI, for example).

    if (!bMiniportSupport)
    {
        // Zero out any capabilities:

        RtlZeroMemory(&peDirectDrawGlobal->DxApiInterface,
                sizeof(peDirectDrawGlobal->DxApiInterface));
    }
}

/******************************Public*Routine******************************\
* DWORD vDdSynchronizeSurface
*
* Updates the EDD_DXSURFACE structure using the master EDD_SURFACE
* structure, with some help from the driver.
*
* Analagous to Win95's SyncKernelSurface routine.
*
* This routine lets a driver use fields from the larger, pageable version
* of the DD_SURFACE_* structures used by the display driver to set
* fields in the smaller, non-pageable version of the corresponding
* DDSURFACEDATA structure used by the miniport.
*
* NOTE: The display driver may NOT use the reserved fields to point to
*       allocated memory, for two reasons:
*
*       1.  We don't call them when the surfaces is freed, so they'd
*           lose memory;
*       2.  We only let display drivers allocate paged memory, which
*           they can't use in the miniport since they'll be at raised
*           IRQL when we call them.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdSynchronizeSurface(
    EDD_SURFACE*    peSurface
    )
{
    EDD_DXSURFACE*          peDxSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DD_SYNCSURFACEDATA      SyncSurfaceData;

    peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

    peDxSurface = peSurface->peDxSurface;
    if (peDxSurface != NULL)
    {
        RtlZeroMemory(&SyncSurfaceData, sizeof(SyncSurfaceData));

        SyncSurfaceData.lpDD            = peDirectDrawGlobal;
        SyncSurfaceData.lpDDSurface     = peSurface;
        SyncSurfaceData.dwSurfaceOffset = (DWORD) peSurface->fpVidMem;
        SyncSurfaceData.fpLockPtr       = peSurface->fpVidMem
                + (FLATPTR) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary;
        SyncSurfaceData.lPitch          = peSurface->lPitch;

        EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

        // Call the driver to let it fill in the rest of the values:

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->DxApiCallBacks.SyncSurfaceData))
        {
            peDirectDrawGlobal->
                DxApiCallBacks.SyncSurfaceData(&SyncSurfaceData);
        }

        // Fields updated by the driver:

        peDxSurface->dwSurfaceOffset   = SyncSurfaceData.dwSurfaceOffset;
        peDxSurface->fpLockPtr         = SyncSurfaceData.fpLockPtr;
        peDxSurface->lPitch            = SyncSurfaceData.lPitch;
        peDxSurface->dwOverlayOffset   = SyncSurfaceData.dwOverlayOffset;
        peDxSurface->dwDriverReserved1 = SyncSurfaceData.dwDriverReserved1;
        peDxSurface->dwDriverReserved2 = SyncSurfaceData.dwDriverReserved2;
        peDxSurface->dwDriverReserved3 = SyncSurfaceData.dwDriverReserved3;
        peDxSurface->dwDriverReserved4 = SyncSurfaceData.dwDriverReserved4;

        // Fields taken straight from the surface structure:

        peDxSurface->ddsCaps             = peSurface->ddsCaps.dwCaps;
        peDxSurface->dwWidth             = peSurface->wWidth;
        peDxSurface->dwHeight            = peSurface->wHeight;
        peDxSurface->dwOverlayFlags      = peSurface->dwOverlayFlags;
        peDxSurface->dwFormatFlags       = peSurface->ddpfSurface.dwFlags;
        peDxSurface->dwFormatFourCC      = peSurface->ddpfSurface.dwFourCC;
        peDxSurface->dwFormatBitCount    = peSurface->ddpfSurface.dwRGBBitCount;
        peDxSurface->dwRBitMask          = peSurface->ddpfSurface.dwRBitMask;
        peDxSurface->dwGBitMask          = peSurface->ddpfSurface.dwGBitMask;
        peDxSurface->dwBBitMask          = peSurface->ddpfSurface.dwBBitMask;
        peDxSurface->dwOverlaySrcWidth   = peSurface->dwOverlaySrcWidth;
        peDxSurface->dwOverlaySrcHeight  = peSurface->dwOverlaySrcHeight;
        peDxSurface->dwOverlayDestWidth  = peSurface->dwOverlayDestWidth;
        peDxSurface->dwOverlayDestHeight = peSurface->dwOverlayDestHeight;
    }
}

/******************************Public*Routine******************************\
* DWORD vDdSynchronizeVideoPort
*
* Updates the EDD_DXVIDEOPORT structure using the master EDD_VIDEOPORT
* structure, with some help from the driver.
*
* Analagous to Win95's SyncKernelVideoPort routine.
*
* This routine lets a driver use fields from the larger, pageable version
* of the DD_VIDEOPORT_LOCAL structure used by the display driver to set
* fields in the smaller, non-pageable version of the corresponding
* DDVIDEOPORTDATA structure used by the miniport.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdSynchronizeVideoPort(
    EDD_VIDEOPORT*  peVideoPort
    )
{
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DD_SYNCVIDEOPORTDATA    SyncVideoPortData;

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

    peDxVideoPort = peVideoPort->peDxVideoPort;
    if (peDxVideoPort != NULL)
    {
        RtlZeroMemory(&SyncVideoPortData, sizeof(SyncVideoPortData));

        SyncVideoPortData.lpDD        = peDirectDrawGlobal;
        SyncVideoPortData.lpVideoPort = peVideoPort;
        SyncVideoPortData.dwVBIHeight = peVideoPort->ddvpInfo.dwVBIHeight;

        if (peVideoPort->ddvpInfo.dwVPFlags & DDVP_PRESCALE)
        {
            SyncVideoPortData.dwHeight = peVideoPort->ddvpInfo.dwPrescaleHeight;
        }
        else if (peVideoPort->ddvpInfo.dwVPFlags & DDVP_CROP)
        {
            SyncVideoPortData.dwHeight = peVideoPort->ddvpInfo.rCrop.bottom -
                                         peVideoPort->ddvpInfo.rCrop.top;
        }
        else
        {
            SyncVideoPortData.dwHeight = peVideoPort->ddvpDesc.dwFieldHeight;
        }
        if (peVideoPort->ddvpInfo.dwVPFlags & DDVP_INTERLEAVE)
        {
            SyncVideoPortData.dwHeight *= 2;
        }

        EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

        // Call the driver to let it fill in the rest of the values:

        if ((peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->DxApiCallBacks.SyncVideoPortData))
        {
            peDirectDrawGlobal->
                DxApiCallBacks.SyncVideoPortData(&SyncVideoPortData);
        }

        // Fields updated by the driver:

        peDxVideoPort->dwOriginOffset    = SyncVideoPortData.dwOriginOffset;
        peDxVideoPort->dwHeight          = SyncVideoPortData.dwHeight;
        peDxVideoPort->dwVBIHeight       = SyncVideoPortData.dwVBIHeight;
        peDxVideoPort->dwDriverReserved1 = SyncVideoPortData.dwDriverReserved1;
        peDxVideoPort->dwDriverReserved2 = SyncVideoPortData.dwDriverReserved2;
        peDxVideoPort->dwDriverReserved3 = SyncVideoPortData.dwDriverReserved3;

        // Fields taken straight from the videoport structure:

        peDxVideoPort->dwVideoPortId     = peVideoPort->ddvpDesc.dwVideoPortID;
        peDxVideoPort->dwVPFlags         = peVideoPort->ddvpInfo.dwVPFlags;
        if( ( peDxVideoPort->dwVBIHeight > 0 ) &&
            ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) &&
            !( peDxVideoPort->dwVPFlags & DDVP_VBINOINTERLEAVE ) )
        {
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED;
        }
        else
        {
            peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED;
        }
    }
}

/******************************Public*Routine******************************\
* HANDLE hDdOpenDxApiSurface
*
* Opens a DXAPI representation of a surface
*
*  20-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

HANDLE
hDdOpenDxApiSurface(
    EDD_SURFACE*            peSurface
    )
{
    DDOPENSURFACEIN     OpenSurfaceIn;
    DDOPENSURFACEOUT    OpenSurfaceOut;
    HANDLE              hHandle;

    hHandle = NULL;

    // Allocate a DXAPI object:

    OpenSurfaceIn.hDirectDraw     = peSurface->peDirectDrawGlobal->hDirectDraw;
    OpenSurfaceIn.dwSurfaceHandle = (ULONG_PTR) peSurface->hGet();
    OpenSurfaceIn.pfnSurfaceClose = vDdNullCallBack;

    peSurface->peDirectDrawGlobal->pfnDxApi(DD_DXAPI_OPENSURFACE,
        &OpenSurfaceIn,
        sizeof(OpenSurfaceIn),
        &OpenSurfaceOut,
        sizeof(OpenSurfaceOut));

    if( ( OpenSurfaceOut.ddRVal == DD_OK ) &&
        ( OpenSurfaceOut.hSurface != NULL ) )
    {
        hHandle = OpenSurfaceOut.hSurface;
        vDdSynchronizeSurface( peSurface );
    }

    return hHandle;
}

/******************************Public*Routine******************************\
* HANDLE hDdCloseDxApiSurface
*
* Closes a DXAPI representation of a surface
*
*  21-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
vDdCloseDxApiSurface(
    EDD_SURFACE*            peSurface
    )
{
    DDCLOSEHANDLE CloseHandle;
    DWORD         dwRet;

    CloseHandle.hHandle = peSurface->hSurface;

    peSurface->peDirectDrawGlobal->pfnDxApi(DD_DXAPI_CLOSEHANDLE,
        &CloseHandle,
        sizeof(CloseHandle),
        &dwRet,
        sizeof(dwRet));

    ASSERTGDI(dwRet == DD_OK, "Expected DD_OK");

    peSurface->hSurface = NULL;
}

/******************************Public*Routine******************************\
* BOOL bDdUpdateLinksAndSynchronize
*
* A bidirectional link is maintained between a videoport and its active
* surfaces:
*
*     1. From each surface to the active videoport;
*     2. From the videoport to each of its active surfaces.
*
* This routine does all the maintaining of those links, automatically
* removing links from surfaces that are no longer used, and informing
* the software autoflipper of the change.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdUpdateLinksAndSynchronize(
    EDD_VIDEOPORT*  peVideoPort,
    BOOL            bNewVideo,          // FALSE if 'video' parameters should
    EDD_SURFACE**   apeNewVideo,        //   be ignored and current video state
    ULONG           cAutoflipVideo,     //   should remain unchanged
    BOOL            bNewVbi,            // FALSE if 'VBI' parameters should
    EDD_SURFACE**   apeNewVbi,          //   be ignored and current VBI state
    ULONG           cAutoflipVbi        //   should remain unchanged
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_DXVIDEOPORT*        peDxVideoPort;
//    EDD_SURFACE*            apeTempVideo[MAX_AUTOFLIP_BUFFERS];
//    EDD_SURFACE*            apeTempVbi[MAX_AUTOFLIP_BUFFERS];
    EDD_DXSURFACE*          apeDxNewVideo[MAX_AUTOFLIP_BUFFERS];
    EDD_DXSURFACE*          apeDxNewVbi[MAX_AUTOFLIP_BUFFERS];
    ULONG                   i;
    BOOL                    bOk;

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
    peDxVideoPort = peVideoPort->peDxVideoPort;

    if (peDxVideoPort == NULL)
        return(TRUE);

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    // First, check to make sure the surfaces have been opened

    bOk = TRUE;
    for (i = 0; i < cAutoflipVideo; i++)
    {
        if( ( apeNewVideo[i] == NULL ) ||
            ( apeNewVideo[i]->hSurface == NULL ) )
        {
            bOk = FALSE;
        }
    }
    for (i = 0; i < cAutoflipVbi; i++)
    {
        if( ( apeNewVbi[i] == NULL ) ||
            ( apeNewVbi[i]->hSurface == NULL ) )
        {
            bOk = FALSE;
        }
    }

    if (!bOk)
    {
        return(FALSE);
    }

    // Remove the videoport links from the old surfaces, and stash a copy
    // of the list for later:

    for (i = 0; i < peVideoPort->cAutoflipVideo; i++)
    {
        peVideoPort->apeSurfaceVideo[i]->lpVideoPort = NULL;
        if( peVideoPort->apeSurfaceVideo[i]->peDxSurface != NULL )
        {
            peVideoPort->apeSurfaceVideo[i]->peDxSurface->peDxVideoPort = NULL;
        }
    }
    for (i = 0; i < peVideoPort->cAutoflipVbi; i++)
    {
        peVideoPort->apeSurfaceVbi[i]->lpVideoPort = NULL;
        if( peVideoPort->apeSurfaceVbi[i]->peDxSurface != NULL )
        {
            peVideoPort->apeSurfaceVbi[i]->peDxSurface->peDxVideoPort = NULL;
        }
    }

    // Now add the links to the new surfaces:

    for (i = 0; i < cAutoflipVideo; i++)
    {
        peVideoPort->apeSurfaceVideo[i] = apeNewVideo[i];
        apeNewVideo[i]->lpVideoPort = peVideoPort;
        apeDxNewVideo[i] = apeNewVideo[i]->peDxSurface;
    }
    for (i = 0; i < cAutoflipVbi; i++)
    {
        peVideoPort->apeSurfaceVbi[i] = apeNewVbi[i];
        apeNewVbi[i]->lpVideoPort = peVideoPort;
        apeDxNewVbi[i] = apeNewVbi[i]->peDxSurface;
    }

    // Now modify the autoflip buffers, being careful to synchronize with
    // the software-autoflip DPC.  Note that this does stuff like sets
    // peDxVideoPort->cAutoflipVbi.

    peDirectDrawGlobal->pfnAutoflipUpdate(peDxVideoPort,
                                          apeDxNewVideo,
                                          cAutoflipVideo,
                                          apeDxNewVbi,
                                          cAutoflipVbi);

    peVideoPort->cAutoflipVideo = cAutoflipVideo;
    peVideoPort->cAutoflipVbi   = cAutoflipVbi;

    // Finally, Update some last public fields in the videoport structure:

    peVideoPort->dwNumAutoflip    = cAutoflipVideo;
    peVideoPort->dwNumVBIAutoflip = cAutoflipVbi;
    peVideoPort->lpSurface      = (cAutoflipVideo == 0) ? NULL : apeNewVideo[0];
    peVideoPort->lpVBISurface   = (cAutoflipVbi == 0)   ? NULL : apeNewVbi[0];

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeDirectDraw
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeDirectDraw(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DXOBJ*              pDxTmp;

    ASSERTGDI(pDxObj->iDxType == DXT_DIRECTDRAW, "Invalid object");

    peDxDirectDraw = pDxObj->peDxDirectDraw;

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent,pDxObj->pContext, 0, 0);
    }

    // Remove this DXOBJ instance from the list hanging off the DXAPI object:

    if (peDxDirectDraw->pDxObj_List == pDxObj)
    {
        peDxDirectDraw->pDxObj_List = pDxObj->pDxObj_Next;
    }
    else
    {
        for (pDxTmp = peDxDirectDraw->pDxObj_List;
             pDxTmp->pDxObj_Next != pDxObj;
             pDxTmp = pDxTmp->pDxObj_Next)
        {
            ASSERTGDI(pDxTmp->iDxType == DXT_DIRECTDRAW, "Unexpected type");
            ASSERTGDI(pDxTmp->pDxObj_Next != NULL, "Couldn't find node");
        }

        pDxTmp->pDxObj_Next = pDxObj->pDxObj_Next;
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // If there are no more DXOBJ instances of the DirectDraw DXAPI object,
    // we can free the non-paged DXAPI part of the DirectDraw structure:

    if (peDxDirectDraw->pDxObj_List == NULL)
    {
        if ((peDxDirectDraw->pDxEvent_PassiveList != NULL) ||
            (peDxDirectDraw->pDxEvent_DispatchList[CLIENT_DISPATCH_LIST] != NULL))
        {
            KdPrint(("vDdDxApiFreeDirectDraw: A kernel-mode DXAPI client didn't unregister all\n"));
            KdPrint(("  its events when it received CLOSE call-backs.  This will cause at\n"));
            KdPrint(("  best a memory leak and at worst a crash!\n"));
            RIP("The DXAPI client must be fixed.");
        }

        if (peDxDirectDraw->peDirectDrawGlobal != NULL)
        {
            peDxDirectDraw->peDirectDrawGlobal->peDxDirectDraw = NULL;
        }
        vDdDxObjFree(peDxDirectDraw);
    }
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeVideoPort
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeVideoPort(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    DXOBJ*              pDxObjTmp;
    DXAPI_EVENT*        pDxEventTmp;

    ASSERTGDI(pDxObj->iDxType == DXT_VIDEOPORT, "Invalid object");

    peDxVideoPort      = pDxObj->peDxVideoPort;
    peDxDirectDraw     = peDxVideoPort->peDxDirectDraw;

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
    }

    // Remove this DXOBJ instance from the list hanging off the DXAPI object:

    if (peDxVideoPort->pDxObj_List == pDxObj)
    {
        peDxVideoPort->pDxObj_List = pDxObj->pDxObj_Next;
    }
    else
    {
        for (pDxObjTmp = peDxVideoPort->pDxObj_List;
             pDxObjTmp->pDxObj_Next != pDxObj;
             pDxObjTmp = pDxObjTmp->pDxObj_Next)
        {
            ASSERTGDI(pDxObjTmp->iDxType == DXT_VIDEOPORT, "Unexpected type");
            ASSERTGDI(pDxObjTmp->pDxObj_Next != NULL, "Couldn't find node");
        }

        pDxObjTmp->pDxObj_Next = pDxObj->pDxObj_Next;
    }

    // Free the notification event if one is present

    if (peDxVideoPort->pNotifyEvent != NULL)
    {
        PKEVENT     pTemp = NULL;
        HANDLE      hEvent = peDxVideoPort->pNotifyEventHandle;
        NTSTATUS    Status;

        peDxVideoPort->pNotifyEvent = NULL;
        peDxVideoPort->pNotifyEventHandle = NULL;

        // Make sure that the handle hasn't been freed by the OS already
        Status = ObReferenceObjectByHandle( hEvent,
                                        0,
                                        0,
                                        KernelMode,
                                        (PVOID *) &pTemp,
                                        NULL );
        if ((pTemp != NULL) && (Status != STATUS_INVALID_HANDLE))
        {
            ObDereferenceObject(pTemp);
            ZwClose (hEvent);
        }

        // Un-page lock memory

        peDxVideoPort->pNotifyBuffer = NULL;
        if (peDxVideoPort->pNotifyMdl != NULL)
        {
            MmUnlockPages (peDxVideoPort->pNotifyMdl);
            IoFreeMdl (peDxVideoPort->pNotifyMdl);
            peDxVideoPort->pNotifyMdl = NULL;
        }
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // If there are no more DXOBJ instances of the VideoPort DXAPI object,
    // we can free the non-paged DXAPI part of the VideoPort structure:

    if (peDxVideoPort->pDxObj_List == NULL)
    {
        ASSERTGDI(peDxDirectDraw != NULL, "Unexpected NULL peDxDirectDraw");

        for (pDxEventTmp = peDxDirectDraw->pDxEvent_DispatchList[CLIENT_DISPATCH_LIST];
             pDxEventTmp != NULL;
             pDxEventTmp = pDxEventTmp->pDxEvent_Next)
        {
            if (pDxEventTmp->peDxVideoPort == peDxVideoPort)
            {
                KdPrint(("vDdDxApiFreeVideoPort: A kernel-mode DXAPI client didn't unregister all\n"));
                KdPrint(("  its videoport events when it received CLOSE call-backs.  This will\n"));
                KdPrint(("  cause at best a memory leak and at worst a crash!\n"));
                RIP("The DXAPI client must be fixed.");
            }
        }

        if (peDxVideoPort->peVideoPort != NULL)
        {
            // If we are actually freeing the video port, we need to lose
            // any capture objects that are associated with it

            while( peDxVideoPort->peDxCapture != NULL )
            {
                vDdLoseDxObjects( peDxDirectDraw->peDirectDrawGlobal,
                    peDxVideoPort->peDxCapture->pDxObj_List,
                    (PVOID) peDxVideoPort->peDxCapture,
                    LO_CAPTURE );
            }

            peDxVideoPort->peVideoPort->peDxVideoPort = NULL;
        }
        vDdDxObjFree(peDxVideoPort);
    }
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeCapture
*
*  10-Apr-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeCapture(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXCAPTURE*      peDxCapture;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    ASSERTGDI(pDxObj->iDxType == DXT_CAPTURE, "Invalid object");

    peDxCapture        = pDxObj->peDxCapture;
    peDxVideoPort      = peDxCapture->peDxVideoPort;

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // Unassociate the capture object from the video port.  Since this
    // must be synchronized with the DPC, we need to call DxApi to do this.

    if( peDxVideoPort != NULL )
    {
        EDD_DXDIRECTDRAW*       peDxDirectDraw;
        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

        peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
        EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;
        peDirectDrawGlobal->pfnUpdateCapture( peDxVideoPort,
                        peDxCapture, TRUE );
    }

    vDdDxObjFree(peDxCapture);
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeSurface
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeSurface(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXSURFACE*      peDxSurface;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DXOBJ*              pDxTmp;

    ASSERTGDI(pDxObj->iDxType == DXT_SURFACE, "Invalid object");

    peDxSurface    = pDxObj->peDxSurface;
    peDxDirectDraw = peDxSurface->peDxDirectDraw;

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
    }

    // Remove this DXOBJ instance from the list hanging off the DXAPI object:

    if (peDxSurface->pDxObj_List == pDxObj)
    {
        peDxSurface->pDxObj_List = pDxObj->pDxObj_Next;
    }
    else
    {
        for (pDxTmp = peDxSurface->pDxObj_List;
             pDxTmp->pDxObj_Next != pDxObj;
             pDxTmp = pDxTmp->pDxObj_Next)
        {
            ASSERTGDI(pDxTmp->iDxType == DXT_SURFACE, "Unexpected type");
            ASSERTGDI(pDxTmp->pDxObj_Next != NULL, "Couldn't find node");
        }

        pDxTmp->pDxObj_Next = pDxObj->pDxObj_Next;
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // If there are no more DXOBJ instances of the Surface DXAPI object,
    // we can free the non-paged DXAPI part of the Surface structure:

    if (peDxSurface->pDxObj_List == NULL)
    {
        if (peDxSurface->peSurface != NULL)
        {
            peDxSurface->peSurface->peDxSurface = NULL;
        }
        vDdDxObjFree(peDxSurface);
    }
}

/******************************Public*Routine******************************\
* VOID vDdStopVideoPort
*
* Makes an emergency stop of the videoport.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdStopVideoPort(
    EDD_VIDEOPORT*  peVideoPort
    )
{
    EDD_DXVIDEOPORT*        peDxVideoPort;
    DD_UPDATEVPORTDATA      UpdateVPortData;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    b;

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
    peDxVideoPort      = peVideoPort->peDxVideoPort;

    // Stop the videoport itself:

    UpdateVPortData.lpDD             = peDirectDrawGlobal;
    UpdateVPortData.lpVideoPort      = peVideoPort;
    UpdateVPortData.lplpDDVBISurface = NULL;
    UpdateVPortData.lplpDDSurface    = NULL;
    UpdateVPortData.lpVideoInfo      = NULL;
    UpdateVPortData.dwNumAutoflip    = 0;
    UpdateVPortData.dwFlags          = DDRAWI_VPORTSTOP;

    EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

    ASSERTGDI(peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort != NULL,
        "Videoport object shouldn't have been created if UpdateVideoPort NULL");

    // Disable video port VSYNC IRQ

    if (peDxVideoPort != NULL)
    {
        // Shut down software autoflipping (the autoflipping routine peeks
        // at these values, so this is sufficient):

        peDxVideoPort->bSoftwareAutoflip = FALSE;
        peDxVideoPort->flFlags          &= ~(DD_DXVIDEOPORT_FLAG_AUTOFLIP|DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI);
        peDxVideoPort->bSkip             = FALSE;
        peDxVideoPort->dwSetStateField   = 0;

        if (peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON)
        {
            peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_ON;
            peDirectDrawGlobal->pfnEnableIRQ(peDxVideoPort, FALSE );
        }
    }


    if (!peDirectDrawGlobal->bSuspended &&
        (peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort != NULL))
    {
        peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort(&UpdateVPortData);
    }

    // Update the links to reflect the fact that no surface is a
    // destination for this videoport anymore:

    b = bDdUpdateLinksAndSynchronize(peVideoPort, TRUE, NULL, 0, TRUE, NULL, 0);

    ASSERTGDI(b, "vDdStopVideoPort: Shouldn't fail bDdUpdateLinkAndSynchronize");
}

/******************************Public*Routine******************************\
* VOID LoseDxObjects
*
* Notifies all clients using the resource that it can't be used anymore.
* It also notifies DXAPI.SYS that the resource is unusable.
*
*  04-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
vDdLoseDxObjects(
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal,
    DXOBJ*                 pDxObj,
    PVOID                  pDxThing,
    DWORD                  dwType
    )
{
    if( pDxObj != NULL )
    {
        while( pDxObj != NULL )
        {
            pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
            pDxObj = pDxObj->pDxObj_Next;
        }

        peDirectDrawGlobal->pfnLoseObject( pDxThing, (LOTYPE) dwType );
    }
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteVideoPortObject
*
* Deletes a kernel-mode representation of the videoport object.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteVideoPortObject(
    HANDLE  hVideoPort,
    DWORD*  pdwRet          // For returning driver return code, may be NULL
    )
{
    BOOL                    bRet;
    DWORD                   dwRet;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_VIDEOPORT*          peVideoPort;
    EDD_VIDEOPORT*          peTmp;
    VOID*                   pvRemove;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    DD_DESTROYVPORTDATA     DestroyVPortData;
    DXOBJ*                  pDxObj;
    DXOBJ*                  pDxObjNext;

    bRet = FALSE;
    dwRet = DDHAL_DRIVER_HANDLED;

    peVideoPort = (EDD_VIDEOPORT*) DdHmgLock((HDD_OBJ) hVideoPort, DD_VIDEOPORT_TYPE, FALSE);

    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        // Make sure the videoport has been turned off:

        vDdStopVideoPort(peVideoPort);

        // If there are any capture objects associated witht he video port,
        // lose them now

        peDxVideoPort = peVideoPort->peDxVideoPort;
        while( peDxVideoPort && (peDxVideoPort->peDxCapture != NULL) )
        {
            vDdLoseDxObjects( peDirectDrawGlobal,
                peDxVideoPort->peDxCapture->pDxObj_List,
                (PVOID) peDxVideoPort->peDxCapture,
                LO_CAPTURE );
        }

        // Free the DXAPI instance of the videoport object

        if (peVideoPort->hVideoPort != NULL)
        {
            vDdDxApiFreeVideoPort( (DXOBJ*) peVideoPort->hVideoPort, FALSE);
            peVideoPort->hVideoPort = NULL;
            peDxVideoPort = peVideoPort->peDxVideoPort;
        }

        // Notify clients that their open objects are lost

        if (peDxVideoPort) {
            vDdLoseDxObjects( peDirectDrawGlobal,
                peDxVideoPort->pDxObj_List,
                (PVOID) peDxVideoPort,
                LO_VIDEOPORT );
        }

        pvRemove = DdHmgRemoveObject((HDD_OBJ) hVideoPort,
                                   DdHmgQueryLock((HDD_OBJ) hVideoPort),
                                   0,
                                   TRUE,
                                   DD_VIDEOPORT_TYPE);

        ASSERTGDI(pvRemove != NULL, "Outstanding surfaces locks");

        // Hold the devlock while we call the driver and while we muck
        // around in the videoport list:

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if (peVideoPort->fl & DD_VIDEOPORT_FLAG_DRIVER_CREATED)
        {
            // Call the driver if it created the object:

            if (peDirectDrawGlobal->VideoPortCallBacks.DestroyVideoPort)
            {
                DestroyVPortData.lpDD        = peDirectDrawGlobal;
                DestroyVPortData.lpVideoPort = peVideoPort;
                DestroyVPortData.ddRVal      = DDERR_GENERIC;

                dwRet = peDirectDrawGlobal->
                    VideoPortCallBacks.DestroyVideoPort(&DestroyVPortData);
            }
        }

        // Remove from the videoport linked-list:

        peDirectDrawLocal = peVideoPort->peDirectDrawLocal;

        if (peDirectDrawLocal->peVideoPort_DdList == peVideoPort)
        {
            peDirectDrawLocal->peVideoPort_DdList
                = peVideoPort->peVideoPort_DdNext;
        }
        else
        {
            for (peTmp = peDirectDrawLocal->peVideoPort_DdList;
                 peTmp->peVideoPort_DdNext != peVideoPort;
                 peTmp = peTmp->peVideoPort_DdNext)
                 ;

            peTmp->peVideoPort_DdNext = peVideoPort->peVideoPort_DdNext;
        }

        // Unload DXAPI.SYS if no other video port is using it

        if (peDirectDrawLocal->peVideoPort_DdList == NULL)
        {
            vDdUnloadDxApi( peDirectDrawGlobal );
        }

        // We're all done with this object, so free the memory and
        // leave:

        DdFreeObject(peVideoPort, DD_VIDEOPORT_TYPE);

        bRet = TRUE;
    }
    else
    {
        WARNING1("bDdDeleteVideoPortObject: Bad handle or object was busy\n");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenDirectDraw
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenDirectDraw(
    DDOPENDIRECTDRAWIN*     pOpenDirectDrawIn,
    DDOPENDIRECTDRAWOUT*    pOpenDirectDrawOut,
    PKDEFERRED_ROUTINE      pfnEventDpc,
    ULONG                   DxApiPrivateVersionNumber
    )
{
    HANDLE                  hDirectDraw;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenDirectDraw: Callable only at passive level (it's not pageable)");

    hDirectDraw = 0;            // Assume failure

    // We use the private version number to ensure consistency between
    // win32k.sys and dxapi.sys.  Since dxapi.sys is dynamically loaded,
    // I am worried about a scenario where a service pack is applied that
    // updates both dxapi.sys and win32k.sys -- if the machine isn't
    // rebooted, the old win32k.sys will remain loaded but the new dxapi.sys
    // may be loaded, possibly causing a crash.

    peDirectDrawLocal
        = eLockDirectDraw.peLock((HANDLE) pOpenDirectDrawIn->dwDirectDrawHandle);
    if ((peDirectDrawLocal != NULL) ||
        (DxApiPrivateVersionNumber != DXAPI_PRIVATE_VERSION_NUMBER))
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
        pDxObj = pDdDxObjHandleAllocate(DXT_DIRECTDRAW,
                                  pOpenDirectDrawIn->pfnDirectDrawClose,
                                  DDNOTIFY_CLOSEDIRECTDRAW,
                                  pOpenDirectDrawIn->pContext);
        if (pDxObj != NULL)
        {
            // Among other things, enforce synchronization while we muck
            // around in the global DirectDraw object:

            EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

            peDxDirectDraw = peDirectDrawGlobal->peDxDirectDraw;
            if (peDxDirectDraw != NULL)
            {
                // Just add this object to the list hanging off the DirectDraw
                // object:

                pDxObj->peDxDirectDraw      = peDxDirectDraw;
                pDxObj->pDxObj_Next         = peDxDirectDraw->pDxObj_List;
                peDxDirectDraw->pDxObj_List = pDxObj;

                // Success!

                hDirectDraw = (HANDLE) pDxObj;
            }
            else
            {
                peDxDirectDraw = (EDD_DXDIRECTDRAW*) pDdDxObjDataAllocate(
                                                        sizeof(*peDxDirectDraw),
                                                        'dxdG');
                if (peDxDirectDraw)
                {
                    RtlZeroMemory(peDxDirectDraw, sizeof(*peDxDirectDraw));

                    pDxObj->peDxDirectDraw = peDxDirectDraw;

                    // We need to access some capabilities at raised IRQL,
                    // so copy those from the paged 'peDirectDrawGlobal'
                    // to the non-paged 'peDxDirectDraw' now:

                    peDxDirectDraw->DxApiInterface
                        = peDirectDrawGlobal->DxApiInterface;
                    peDxDirectDraw->HwDeviceExtension
                        = peDirectDrawGlobal->HwDeviceExtension;
                    peDxDirectDraw->dwIRQCaps
                        = peDirectDrawGlobal->DDKernelCaps.dwIRQCaps;
                    peDxDirectDraw->peDirectDrawGlobal
                        = peDirectDrawGlobal;
                    peDxDirectDraw->hdev
                        = peDirectDrawGlobal->hdev;

                    peDirectDrawGlobal->peDxDirectDraw = peDxDirectDraw;

                    peDxDirectDraw->pDxObj_List = pDxObj;

                    // Initialize our kernel structures use for interrupts
                    // and handling raised IRQL callers.

                    KeInitializeDpc(&peDxDirectDraw->EventDpc,
                                    pfnEventDpc,
                                    peDxDirectDraw);

                    KeInitializeSpinLock(&peDxDirectDraw->SpinLock);

                    // Success!

                    hDirectDraw = (HANDLE) pDxObj;
                }
            }

            if (!hDirectDraw)
            {
                vDdDxObjFree(pDxObj);
            }
        }
    }
    else
    {
        WARNING("DdDxApiOpenDirectDraw: Invalid dwDirectDrawHandle, failing\n");
    }

    pOpenDirectDrawOut->hDirectDraw = hDirectDraw;
    pOpenDirectDrawOut->ddRVal = (hDirectDraw != NULL) ? DD_OK : DDERR_GENERIC;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenVideoPort
*
* This routine lets a driver use fields from the larger, pageable version
* of the DD_SURFACE_* structures used by the display driver to set
* fields in the smaller, non-pageable version of the corresponding
* DDSURFACEDATA structure used by the miniport.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenVideoPort(
    DDOPENVIDEOPORTIN*  pOpenVideoPortIn,
    DDOPENVIDEOPORTOUT* pOpenVideoPortOut
    )
{
    HANDLE                  hVideoPort;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_VIDEOPORT*          peVideoPort;
    BOOL                    bFound;
    EDD_DIRECTDRAW_LOCAL*   peTempDirectDrawLocal;
    EDD_VIDEOPORT*          peTempVideoPort;


    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenVideoPort: Callable only at passive level (it's not pageable)");

    hVideoPort = 0;               // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pOpenVideoPortIn->hDirectDraw;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiOpenVideoPort: Invalid hDirectDraw, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (!peDxDirectDraw->bLost)
    {
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;

        // We need to get a handle to the video port, so we need to
        // go looking for it.

        bFound = FALSE;
        peTempDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
        while( ( peTempDirectDrawLocal != NULL ) && !bFound )
        {
            peTempVideoPort = peTempDirectDrawLocal->peVideoPort_DdList;
            while( peTempVideoPort != NULL )
            {
                if( peTempVideoPort->ddvpDesc.dwVideoPortID == pOpenVideoPortIn->dwVideoPortHandle )
                {
                    bFound = TRUE;
                    break;
                }
                peTempVideoPort = peTempVideoPort->peVideoPort_DdNext;
            }
            peTempDirectDrawLocal = peTempDirectDrawLocal->peDirectDrawLocalNext;
        }
        if( bFound )
        {
            peVideoPort = eLockVideoPort.peLock(
                (HANDLE) peTempVideoPort->hGet());
            if ((peVideoPort != NULL) &&
                (peVideoPort->peDirectDrawGlobal == peDirectDrawGlobal))
            {
                pDxObj = pDdDxObjHandleAllocate(DXT_VIDEOPORT,
                                      pOpenVideoPortIn->pfnVideoPortClose,
                                      DDNOTIFY_CLOSEVIDEOPORT,
                                      pOpenVideoPortIn->pContext);
                if (pDxObj != NULL)
                {

                    peDxVideoPort = peVideoPort->peDxVideoPort;
                    if (peDxVideoPort != NULL)
                    {
                        // Just add this object to the list hanging off the
                        // surface object:

                        pDxObj->peDxVideoPort      = peDxVideoPort;
                        pDxObj->pDxObj_Next        = peDxVideoPort->pDxObj_List;
                        peDxVideoPort->pDxObj_List = pDxObj;

                        // Success!

                        hVideoPort = (HANDLE) pDxObj;
                    }
                    else
                    {
                        peDxVideoPort = (EDD_DXVIDEOPORT*) pDdDxObjDataAllocate(
                                                        sizeof(*peDxVideoPort),
                                                        'sxdG');
                        if (peDxVideoPort)
                        {
                            RtlZeroMemory(peDxVideoPort, sizeof(*peDxVideoPort));

                            pDxObj->peDxVideoPort = peDxVideoPort;

                            peVideoPort->peDxVideoPort = peDxVideoPort;

                            peDxVideoPort->pDxObj_List    = pDxObj;
                            peDxVideoPort->peVideoPort    = peVideoPort;
                            peDxVideoPort->peDxDirectDraw = peDxDirectDraw;

                            peDxVideoPort->iCurrentVideo  = 1;
                            peDxVideoPort->dwVideoPortID
                                = peVideoPort->ddvpDesc.dwVideoPortID;

                            vDdSynchronizeVideoPort(peVideoPort);

                            // Success!

                            hVideoPort = (HANDLE) pDxObj;
                        }
                    }

                    if (!hVideoPort)
                    {
                        vDdDxObjFree(pDxObj);
                    }
                }
            }
            else
            {
                WARNING("DdDxApiOpenVideoPort: Invalid dwSurfaceHandle, failing.\n");
            }
        }
        else
        {
            WARNING("DdDxApiOpenVideoPort: Invalid dwSurfaceHandle, failing.\n");
        }
    }
    else
    {
        WARNING("DdDxApiOpenVideoPort: DirectDraw object is lost");
    }

    pOpenVideoPortOut->hVideoPort = hVideoPort;
    pOpenVideoPortOut->ddRVal = (hVideoPort != NULL) ? DD_OK : DDERR_GENERIC;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenSurface
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenSurface(
    DDOPENSURFACEIN*    pOpenSurfaceIn,
    DDOPENSURFACEOUT*   pOpenSurfaceOut
    )
{
    HANDLE                  hSurface;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXSURFACE*          peDxSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenSurface: Callable only at passive level (it's not pageable)");

    hSurface = 0;               // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pOpenSurfaceIn->hDirectDraw;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiOpenSurface: Invalid hDirectDraw, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (!peDxDirectDraw->bLost)
    {
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;

        peSurface = eLockSurface.peLock((HANDLE) pOpenSurfaceIn->dwSurfaceHandle);
        if ((peSurface != NULL) &&
            (peSurface->peDirectDrawGlobal == peDirectDrawGlobal))
        {
            pDxObj = pDdDxObjHandleAllocate(DXT_SURFACE,
                                      pOpenSurfaceIn->pfnSurfaceClose,
                                      DDNOTIFY_CLOSESURFACE,
                                      pOpenSurfaceIn->pContext);
            if (pDxObj != NULL)
            {
                peDxSurface = peSurface->peDxSurface;
                if (peDxSurface != NULL)
                {
                    // Just add this object to the list hanging off the
                    // surface object:

                    pDxObj->peDxSurface      = peDxSurface;
                    pDxObj->pDxObj_Next      = peDxSurface->pDxObj_List;
                    peDxSurface->pDxObj_List = pDxObj;

                    // Success!

                    hSurface = (HANDLE) pDxObj;
                }
                else
                {
                    peDxSurface = (EDD_DXSURFACE*) pDdDxObjDataAllocate(
                                                        sizeof(*peDxSurface),
                                                        'sxdG');
                    if (peDxSurface)
                    {
                        RtlZeroMemory(peDxSurface, sizeof(*peDxSurface));

                        pDxObj->peDxSurface = peDxSurface;

                        peSurface->peDxSurface = peDxSurface;

                        peDxSurface->pDxObj_List    = pDxObj;
                        peDxSurface->peSurface      = peSurface;
                        peDxSurface->peDxDirectDraw = peDxDirectDraw;
                        if( peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
                            DDCAPS2_CANBOBINTERLEAVED )
                        {
                            peDxSurface->flFlags |= DD_DXSURFACE_FLAG_CAN_BOB_INTERLEAVED;
                        }
                        if( peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
                            DDCAPS2_CANBOBNONINTERLEAVED )
                        {
                            peDxSurface->flFlags |= DD_DXSURFACE_FLAG_CAN_BOB_NONINTERLEAVED;
                        }

                        // Success!

                        hSurface = (HANDLE) pDxObj;
                    }
                }

                vDdSynchronizeSurface(peSurface);

                if (!hSurface)
                {
                    vDdDxObjFree(pDxObj);
                }
            }
        }
        else
        {
            WARNING("DdDxApiOpenSurface: Invalid dwSurfaceHandle, failing.\n");
        }
    }
    else
    {
        WARNING("DdDxApiOpenSurface: DirectDraw object lost\n");
    }

    pOpenSurfaceOut->hSurface = hSurface;
    pOpenSurfaceOut->ddRVal = (hSurface != NULL) ? DD_OK : DDERR_GENERIC;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiCloseHandle
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiCloseHandle(
    DDCLOSEHANDLE*  pCloseHandle,
    DWORD*          pdwRet
    )
{
    DXOBJ*  pDxObj = (DXOBJ*) pCloseHandle->hHandle;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiCloseHandle: Callable only at passive level (it's not pageable)");
    ASSERTGDI(pCloseHandle->hHandle != NULL,
        "DdDxApiCloseHandle: Trying to close NULL handle");

    switch(pDxObj->iDxType)
    {
    case DXT_DIRECTDRAW:
        vDdDxApiFreeDirectDraw(pDxObj, TRUE);
        break;

    case DXT_VIDEOPORT:
        vDdDxApiFreeVideoPort(pDxObj, FALSE);
        break;

    case DXT_SURFACE:
        vDdDxApiFreeSurface(pDxObj, FALSE);
        break;

    case DXT_CAPTURE:
        vDdDxApiFreeCapture(pDxObj, FALSE);
        break;

    case DXT_INVALID:
        RIP("DdDxApiCloseHandle: Invalid surface.  Same handle probably closed twice");
        break;

    default:
        RIP("DdDxApiCloseHandle: Invalid surface.");
        break;
    }

    *pdwRet = DD_OK;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenCaptureDevice
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenCaptureDevice(
    DDOPENVPCAPTUREDEVICEIN*  pOpenCaptureDeviceIn,
    DDOPENVPCAPTUREDEVICEOUT* pOpenCaptureDeviceOut
    )
{
    HANDLE                  hCaptureDevice;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObjVideoPort;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DXCAPTURE*          peDxCapture;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwRet;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenVideoPort: Callable only at passive level (it's not pageable)");

    hCaptureDevice = 0;               // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pOpenCaptureDeviceIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pOpenCaptureDeviceIn->hVideoPort;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiOpenCaptureDevice: Invalid hDirectDraw, we're about to crash");
    ASSERTGDI((pDxObjVideoPort != NULL) &&
              (pDxObjVideoPort->iDxType == DXT_VIDEOPORT),
        "DdDxApiOpenCaptureDevice: Invalid hVideoPort, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;
    peDxVideoPort  = pDxObjVideoPort->peDxVideoPort;

    ASSERTGDI((pOpenCaptureDeviceIn->dwFlags == DDOPENCAPTURE_VIDEO) ||
              (pOpenCaptureDeviceIn->dwFlags == DDOPENCAPTURE_VBI),
        "DdDxApiOpenCaptureDevice: Invalid flags specified");
    ASSERTGDI((pOpenCaptureDeviceIn->dwCaptureEveryNFields != 0),
        "DdDxApiOpenCaptureDevice: Invalid dwCaptureEveryNFields specified");
    ASSERTGDI((pOpenCaptureDeviceIn->pfnCaptureClose != 0),
        "DdDxApiOpenCaptureDevice: Invalid pfnCaptureClose specified");

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    dwRet = DDERR_INVALIDPARAMS;
    if ((!peDxDirectDraw->bLost) &&
        (!peDxVideoPort->bLost))
    {
        // Only do this if the device actually supports capturing

       dwRet = DDERR_CURRENTLYNOTAVAIL;
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;
        if ((peDirectDrawGlobal->DDKernelCaps.dwCaps &
            (DDKERNELCAPS_CAPTURE_SYSMEM|DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM)) &&
            (peDxDirectDraw->DxApiInterface.DxTransfer != NULL))
        {
#if 0 // fix bug 169385
            // See capturing target is matched.

            if (((pOpenCaptureDeviceIn->dwFlags & DDOPENCAPTURE_VBI) &&
                 (peDxVideoPort->cAutoflipVbi > 0)) ||
                ((pOpenCaptureDeviceIn->dwFlags & DDOPENCAPTURE_VIDEO) &&
                 (peDxVideoPort->cAutoflipVideo > 0)))
            {
#endif
                // Allocate the object. We only allow one handle per object.

                dwRet = DDERR_OUTOFMEMORY;
                pDxObj = pDdDxObjHandleAllocate(DXT_CAPTURE,
                                          pOpenCaptureDeviceIn->pfnCaptureClose,
                                          DDNOTIFY_CLOSECAPTURE,
                                          pOpenCaptureDeviceIn->pContext);
                if (pDxObj != NULL)
                {
                    peDxCapture = (EDD_DXCAPTURE*) pDdDxObjDataAllocate(
                                                       sizeof(*peDxCapture),
                                                       'sxdG');
                    if (peDxCapture)
                    {
                        RtlZeroMemory(peDxCapture, sizeof(*peDxCapture));
    
                        pDxObj->peDxCapture = peDxCapture;

                        peDxCapture->pDxObj_List    = pDxObj;
                        peDxCapture->peDxVideoPort  = peDxVideoPort;
                        peDxCapture->dwStartLine    = pOpenCaptureDeviceIn->dwStartLine;
                        peDxCapture->dwEndLine      = pOpenCaptureDeviceIn->dwEndLine;
                        peDxCapture->dwCaptureCountDown = 1;
                        peDxCapture->dwCaptureEveryNFields =
                             pOpenCaptureDeviceIn->dwCaptureEveryNFields;
                        if (pOpenCaptureDeviceIn->dwFlags & DDOPENCAPTURE_VBI )
                        {
                            peDxCapture->flFlags = DD_DXCAPTURE_FLAG_VBI;
                        }
                        else
                        {
                            peDxCapture->flFlags = DD_DXCAPTURE_FLAG_VIDEO;
                        }

                        // Now we need to put the capture object into the list
                        // of active capture objects, but since this list is
                        // walked at DPC time, we need to call DxApi to do this.

                        peDirectDrawGlobal->pfnUpdateCapture( peDxVideoPort,
                            peDxCapture, FALSE );

                        // Success!

                        hCaptureDevice = (HANDLE) pDxObj;
                        dwRet = DD_OK;
                    }

                    if (!hCaptureDevice)
                    {
                        vDdDxObjFree(pDxObj);
                    }
                }
#if 0 // fix bug 169385
            }
            else
            {
                WARNING("DdDxApiOpenCaptureDevice: VideoPort doesn't have surface requested by driver.\n");
            }
#endif

        }
        else
        {
            WARNING("DdDxApiOpenCaptureDevice: Device does not support capture, failing.\n");
        }
    }
    else
    {
        WARNING("DdDxApiOpenCaptureDevice: DirectDraw or VideoPort object is not valid, failing.\n");
    }

    pOpenCaptureDeviceOut->hCapture = hCaptureDevice;
    pOpenCaptureDeviceOut->ddRVal = dwRet;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiGetKernelCaps
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiGetKernelCaps(
    HANDLE              hDirectDraw,
    DDGETKERNELCAPSOUT* pGetKernelCaps
    )
{
    DXOBJ*                  pDxObjDirectDraw;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiGetKernelCaps: Callable only at passive level (it's not pageable)");

    pDxObjDirectDraw = (DXOBJ*) hDirectDraw;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiGetKernelCaps: Invalid hDirectDraw, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (!peDxDirectDraw->bLost)
    {
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;

        pGetKernelCaps->ddRVal = DD_OK;
        pGetKernelCaps->dwCaps =   peDirectDrawGlobal->DDKernelCaps.dwCaps;
        pGetKernelCaps->dwIRQCaps = peDirectDrawGlobal->DDKernelCaps.dwIRQCaps;
    }
    else
    {
        pGetKernelCaps->ddRVal = DXERR_OUTOFCAPS;
        pGetKernelCaps->dwCaps =   0;
        pGetKernelCaps->dwIRQCaps = 0;
    }
}

/******************************Public*Routine******************************\
* VOID DdDxApiLockDevice
*
*  05-Jun-1998 -by- agodfrey
\**************************************************************************/

VOID
APIENTRY
DdDxApiLockDevice(
    HDEV hdev
    )
{
    DxEngLockHdev(hdev);
}

/******************************Public*Routine******************************\
* VOID DdDxApiUnlockDevice
*
*  05-Jun-1998 -by- agodfrey
\**************************************************************************/

VOID
APIENTRY
DdDxApiUnlockDevice(
    HDEV hdev
    )
{
    DxEngUnlockHdev(hdev);
}

/******************************Public*Routine******************************\
* DWORD DxDvpCanCreateVideoPort
*
* Queries the driver to determine whether it can support a DirectDraw
* videoPort.
*
*  3-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpCanCreateVideoPort(
    HANDLE                   hDirectDraw,
    PDD_CANCREATEVPORTDATA   puCanCreateVPortData
    )
{
    DWORD                   dwRet;
    DD_CANCREATEVPORTDATA   CanCreateVideoPort;
    DDVIDEOPORTDESC         VideoPortDescription;

    __try
    {
        CanCreateVideoPort
            = ProbeAndReadStructure(puCanCreateVPortData,
                                    DD_CANCREATEVPORTDATA);

        VideoPortDescription
            = ProbeAndReadStructure(CanCreateVideoPort.lpDDVideoPortDesc,
                                    DDVIDEOPORTDESC);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                     = DDHAL_DRIVER_NOTHANDLED;
    CanCreateVideoPort.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);

    // For now, do now enable VPE on Terminal Server due to problems
    // loading DXAPI.SYS into session space vs. non-session space

    {
        if (peDirectDrawLocal != NULL)
        {
            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            CanCreateVideoPort.lpDD              = peDirectDrawGlobal;
            CanCreateVideoPort.lpDDVideoPortDesc = &VideoPortDescription;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((!peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->VideoPortCallBacks.CanCreateVideoPort))
            {
                dwRet = peDirectDrawGlobal->
                    VideoPortCallBacks.CanCreateVideoPort(&CanCreateVideoPort);
            }
        }
        else
        {
            WARNING("DxDvpCanCreateSurface: Invalid object\n");
        }
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCanCreateVPortData->ddRVal,
                          CanCreateVideoPort.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(dwRet);
}


/*****************************Private*Routine******************************\
* HANDLE DxDvpCreateVideoPort
*
* Notifies the HAL after a video port is created.
*
* This is an optional call for the driver, but we always have to 'hook'
* this call from user-mode DirectDraw.
*
* Question: A user-mode application could have absolute garbage in
*           lpDDVideoPortDesc and get it by the driver, because the
*           driver would only be monitoring for invalid data in its
*           CanCreateVideoPort call.  So should we call the driver's
*           CanCreateVideoPort here in this routine before calling
*           CreateVideoPort?
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDvpCreateVideoPort(
    HANDLE              hDirectDraw,
    PDD_CREATEVPORTDATA puCreateVPortData
    )
{
    HANDLE                  hRet;
    DWORD                   dwRet;
    DD_CREATEVPORTDATA      CreateVPortData;
    DDVIDEOPORTDESC         VideoPortDescription;
    BOOL                    bFirst;

    __try
    {
        CreateVPortData =
            ProbeAndReadStructure(puCreateVPortData,
                                  DD_CREATEVPORTDATA);

        VideoPortDescription
            = ProbeAndReadStructure(CreateVPortData.lpDDVideoPortDesc,
                                    DDVIDEOPORTDESC);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    hRet                   = 0;
    CreateVPortData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_VIDEOPORT*          peVideoPort;

    // The two items below where triple bang comments are are somewhat cryptic.
    //
    // 1. Ensure that not more than one VideoPort created
    // 2. Scott allows CanCreateVideoPort and CreateVideoPort to be optional

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);

    // For now, enable VPE on Terminal Server due to conflicts loading in
    // session space vs. non-session sapce.

    {
        if (peDirectDrawLocal != NULL)
        {
            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            // Here we do the minimal validations checks to ensure that bad
            // parameters won't crash NT.  We're not more strict than
            // checking for stuff that will crash us, as the user-mode part
            // of DirectDraw handles that.

            if (VideoPortDescription.dwVideoPortID <
                peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts)
            {

                // Check for the case where a video port has been created for
                // VBI or video and we are now creating the other one, in which
                // case we use the existing video port.

                peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
                while ((peVideoPort != NULL) && 
                    (peVideoPort->ddvpDesc.dwVideoPortID != VideoPortDescription.dwVideoPortID))
                {
                    peVideoPort = peVideoPort->peVideoPort_DdNext;
                }
                if (peVideoPort != NULL)
                {
                    peVideoPort->ddvpDesc = VideoPortDescription;
                    CreateVPortData.ddRVal = DD_OK;
                    hRet = peVideoPort->hGet();
                }
                else
                {
                    peVideoPort = (EDD_VIDEOPORT*) DdHmgAlloc(sizeof(EDD_VIDEOPORT),
                                                        DD_VIDEOPORT_TYPE,
                                                        HMGR_ALLOC_LOCK);
            
                    if (peVideoPort)
                    {
                        // Private data:

                        peVideoPort->peDirectDrawGlobal = peDirectDrawGlobal;
                        peVideoPort->peDirectDrawLocal = peDirectDrawLocal;

                        // Public data:
    
                        peVideoPort->lpDD     = peDirectDrawGlobal;
                        peVideoPort->ddvpDesc = VideoPortDescription;

                        // Hold devlock for driver call and for bDdEnableSoftware
                        // Autoflipping.

                        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                        // Add this videoport to the list hanging off the
                        // DirectDrawLocal object allocated for this process:

                        bFirst = peDirectDrawLocal->peVideoPort_DdList == NULL;
                        peVideoPort->peVideoPort_DdNext
                            = peDirectDrawLocal->peVideoPort_DdList;
                        peDirectDrawLocal->peVideoPort_DdList
                            = peVideoPort;

                        // Now call the driver to create its version:

                        CreateVPortData.lpDD              = peDirectDrawGlobal;
                        CreateVPortData.lpDDVideoPortDesc = &VideoPortDescription;
                        CreateVPortData.lpVideoPort       = peVideoPort;
                        CreateVPortData.ddRVal            = DDERR_GENERIC;

                        dwRet = DDHAL_DRIVER_NOTHANDLED;    // Call is optional
                        if ((!peDirectDrawGlobal->bSuspended) &&
                            (peDirectDrawGlobal->VideoPortCallBacks.CreateVideoPort))
                        {
                            dwRet = peDirectDrawGlobal->
                                VideoPortCallBacks.CreateVideoPort(&CreateVPortData);
                        }

                        if ((dwRet == DDHAL_DRIVER_NOTHANDLED) ||
                            (CreateVPortData.ddRVal == DD_OK))
                        {
                            CreateVPortData.ddRVal = DD_OK;
                            peVideoPort->fl |= DD_VIDEOPORT_FLAG_DRIVER_CREATED;
                        }
                        else
                        {
                            WARNING("DxDvpCreateVideoPort: Driver failed call\n");
                        }

                        if ((CreateVPortData.ddRVal == DD_OK) &&
                            (bDdEnableSoftwareAutoflipping(peDirectDrawLocal,
                                                       peVideoPort,
                                                       VideoPortDescription.dwVideoPortID,
                                                       bFirst)))
                        {
                            // Success!

                            hRet = peVideoPort->hGet();

                            DEC_EXCLUSIVE_REF_CNT( peVideoPort );
                        }
                        else
                        {
                            bDdDeleteVideoPortObject(peVideoPort->hGet(), NULL);

                            CreateVPortData.ddRVal = DDERR_GENERIC;
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDvpCreateVideoPort: Bad parameters\n");
            }
        }
        else
        {
            WARNING("DxDvpCreateVideoPort: Invalid object\n");
        }
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCreateVPortData->ddRVal, CreateVPortData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Note that the user-mode stub always returns DDHAL_DRIVER_HANDLED
    // to DirectDraw.

    return(hRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpDestroyVideoPort
*
* Notifies the HAL when the video port is destroyed.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpDestroyVideoPort(
    HANDLE                  hVideoPort,
    PDD_DESTROYVPORTDATA    puDestroyVPortData
    )
{
    DWORD   dwRet;

    bDdDeleteVideoPortObject(hVideoPort, &dwRet);

    __try
    {
        ProbeAndWriteRVal(&puDestroyVPortData->ddRVal, DD_OK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpFlipVideoPort
*
* Performs the physical flip, causing the video port to start writing data
* to the new surface.  This does not affect the actual display of this data.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpFlipVideoPort(
    HANDLE              hVideoPort,
    HANDLE              hDDSurfaceCurrent,
    HANDLE              hDDSurfaceTarget,
    PDD_FLIPVPORTDATA   puFlipVPortData
    )
{
    DWORD               dwRet;
    DD_FLIPVPORTDATA    FlipVPortData;

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    FlipVPortData.ddRVal    = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    // 1. Make sure they're videoport surfaces, and compatible, not system surfaces?
    // 2. Make sure not software autoflipping?

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
        if (peDirectDrawGlobal->VideoPortCallBacks.FlipVideoPort)
        {
            EDD_SURFACE*     peSurfaceCurrent;
            EDD_SURFACE*     peSurfaceTarget;
            EDD_LOCK_SURFACE eLockSurfaceCurrent;
            EDD_LOCK_SURFACE eLockSurfaceTarget;

            peSurfaceCurrent = eLockSurfaceCurrent.peLock(hDDSurfaceCurrent);
            peSurfaceTarget  = eLockSurfaceTarget.peLock(hDDSurfaceTarget);

            if ((peSurfaceCurrent != NULL)                                   &&
                (peSurfaceTarget != NULL)                                    &&
                (peSurfaceCurrent->peDirectDrawGlobal == peDirectDrawGlobal) &&
                (peSurfaceCurrent->peDirectDrawLocal
                    == peSurfaceTarget->peDirectDrawLocal))
            {
                FlipVPortData.lpDD        = peDirectDrawGlobal;
                FlipVPortData.lpVideoPort = peVideoPort;
                FlipVPortData.lpSurfCurr  = peSurfaceCurrent;
                FlipVPortData.lpSurfTarg  = peSurfaceTarget;

                {
                    EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                    if ((!peDirectDrawGlobal->bSuspended) &&
                        (peDirectDrawGlobal->VideoPortCallBacks.FlipVideoPort))
                    {
                         dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                                        FlipVideoPort(&FlipVPortData);
                    }
                }

                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (FlipVPortData.ddRVal == DD_OK))
                {
                    peVideoPort->lpSurface  = peSurfaceTarget;
                }
            }
            else
            {
                WARNING("DxDvpFlipVPort: Invalid source or target surface\n");
            }
        }
        else
        {
             WARNING("DxDvpFlipVPort: Driver doesn't hook call\n");
        }
    }
    else
    {
        WARNING("DxDvpFlipVPort: Invalid object\n");
    }

    __try
    {
        ProbeAndWriteRVal(&puFlipVPortData->ddRVal, FlipVPortData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxGetVideoPortBandwidth
*
* Informs the client of bandwidth requirements for any specified format,
* allowing them to better chose a format and to understand its limitations.
* This information can only be given after the video port object is created
* because the information in the DDVIDEOPORTDESC structure is required before
* accurate bandwidth information can be supplied.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortBandwidth(
    HANDLE                      hVideoPort,
    PDD_GETVPORTBANDWIDTHDATA   puGetVPortBandwidthData
    )
{
    DWORD                       dwRet;
    DD_GETVPORTBANDWIDTHDATA    GetVPortBandwidthData;
    LPDDPIXELFORMAT             pddpfFormat;
    DDPIXELFORMAT               ddpfFormat;
    DDVIDEOPORTBANDWIDTH        Bandwidth;
    LPDDVIDEOPORTBANDWIDTH      puBandwidth;

    __try
    {
        GetVPortBandwidthData = ProbeAndReadStructure(puGetVPortBandwidthData,
                                                      DD_GETVPORTBANDWIDTHDATA);

        ddpfFormat = ProbeAndReadStructure(GetVPortBandwidthData.lpddpfFormat,
                                           DDPIXELFORMAT);

        puBandwidth = GetVPortBandwidthData.lpBandwidth;

        Bandwidth = ProbeAndReadStructure(puBandwidth,DDVIDEOPORTBANDWIDTH);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                        = DDHAL_DRIVER_NOTHANDLED;
    GetVPortBandwidthData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        if (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortBandwidth)
        {
            GetVPortBandwidthData.lpDD         = peDirectDrawGlobal;
            GetVPortBandwidthData.lpVideoPort  = peVideoPort;
            GetVPortBandwidthData.lpBandwidth  = &Bandwidth;
            GetVPortBandwidthData.lpddpfFormat = &ddpfFormat;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((!peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortBandwidth))
            {
                dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                    GetVideoPortBandwidth(&GetVPortBandwidthData);
            }
        }
        else
        {
            WARNING("DxDvpGetVPortBandwidthData: Driver doesn't hook call\n");
        }
    }
    else
    {
        WARNING("DxDvpGetVPortBandwidthData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteStructure(puBandwidth, Bandwidth, DDVIDEOPORTBANDWIDTH);

        ProbeAndWriteRVal(&puGetVPortBandwidthData->ddRVal,
                          GetVPortBandwidthData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortField
*
* Sets bField to TRUE if the current field is the even field of an
* interlaced signal.  Otherwise, bField is set to FALSE.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortField(
    HANDLE                  hVideoPort,
    PDD_GETVPORTFIELDDATA   puGetVPortFieldData
    )
{
    DWORD                   dwRet;
    DD_GETVPORTFIELDDATA    GetVPortFieldData;

    __try
    {
        GetVPortFieldData = ProbeAndReadStructure(puGetVPortFieldData,
                                                  DD_GETVPORTFIELDDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_NOTHANDLED;
    GetVPortFieldData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortFieldData.lpDD        = peDirectDrawGlobal;
        GetVPortFieldData.lpVideoPort = peVideoPort;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortField))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortField(&GetVPortFieldData);
        }
    }
    else
    {
        WARNING("DxDvpCanGetVPortFieldData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortFieldData->ddRVal,
                          GetVPortFieldData.ddRVal);
        ProbeAndWriteStructure(&puGetVPortFieldData->bField,
                               GetVPortFieldData.bField,
                               BOOL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortFlipStatus
*
* Returns DDERR_WASSTILLDRAWING if a video VSYNC has not occurred since the
* flip was performed on the specified surface.  This function allows DDRAW.DLL
* to fail locks on a surface that was recently flipped from so the HAL doesn't
* have to account for this.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortFlipStatus(
    HANDLE                      hDirectDraw,
    PDD_GETVPORTFLIPSTATUSDATA  puGetVPortFlipStatusData
    )
{
    DWORD                        dwRet;
    DD_GETVPORTFLIPSTATUSDATA    GetVPortFlipStatusData;

    __try
    {
        GetVPortFlipStatusData = ProbeAndReadStructure(puGetVPortFlipStatusData,
                                                       DD_GETVPORTFLIPSTATUSDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                         = DDHAL_DRIVER_NOTHANDLED;
    GetVPortFlipStatusData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetVPortFlipStatusData.lpDD = peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortFlipStatus))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortFlipStatus(
                    &GetVPortFlipStatusData);
        }
    }
    else
    {
        WARNING("DxDvpCanGetVPortFlipStatusData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortFlipStatusData->ddRVal,
                          GetVPortFlipStatusData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortInputFormats
*
* Fills in the specified array with all of the formats that the video port
* can accept and puts that number in dwNumFormats.  If lpddpfFormats is NULL,
* it only fills in dwNumFormats with the number of formats that it can support.
* This function is needed because the supported formats may vary depending on
* the electrical connection of the video port.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortInputFormats(
    HANDLE                      hVideoPort,
    PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData
    )
{
    DWORD                       dwRet;
    DD_GETVPORTINPUTFORMATDATA  GetVPortInputFormatData;
    LPDDPIXELFORMAT             puFormat;
    ULONG                       cjFormat;
    HANDLE                      hSecure;

    __try
    {
        GetVPortInputFormatData
            = ProbeAndReadStructure(puGetVPortInputFormatData,
                                    DD_GETVPORTINPUTFORMATDATA);

        puFormat = GetVPortInputFormatData.lpddpfFormat;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                          = DDHAL_DRIVER_NOTHANDLED;
    GetVPortInputFormatData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortInputFormatData.lpDD         = peDirectDrawGlobal;
        GetVPortInputFormatData.lpVideoPort  = peVideoPort;
        GetVPortInputFormatData.lpddpfFormat = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortInputFormats))
        {
            dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortInputFormats(&GetVPortInputFormatData);

            cjFormat = GetVPortInputFormatData.dwNumFormats
                     * sizeof(DDPIXELFORMAT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetVPortInputFormatData.ddRVal == DD_OK) &&
                (cjFormat > 0) &&
                (puFormat != NULL) &&
                !BALLOC_OVERFLOW1(GetVPortInputFormatData.dwNumFormats, DDPIXELFORMAT))
            {
                GetVPortInputFormatData.ddRVal = DDERR_GENERIC;
                hSecure = 0;

                __try
                {
                    ProbeForWrite(puFormat, cjFormat, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puFormat,
                                                    cjFormat,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetVPortInputFormatData.lpddpfFormat = puFormat;

                    dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortInputFormats(&GetVPortInputFormatData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDvpGetVideoPortInputFormats: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDvpGetVPortInputFormatData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortInputFormatData->ddRVal,
                          GetVPortInputFormatData.ddRVal);
        ProbeAndWriteUlong(&puGetVPortInputFormatData->dwNumFormats,
                           GetVPortInputFormatData.dwNumFormats);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortOutputFormats
*
* Fills in the specified array with all of the formats that can be written
* to the frame buffer based on the specified input format and puts that
* number in dwNumFormats.  If lpddpfOutputFormats is NULL, it only fills
* in dwNumFormats with the number of formats that can be written to the
* frame buffer.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortOutputFormats(
    HANDLE                          hVideoPort,
    PDD_GETVPORTOUTPUTFORMATDATA    puGetVPortOutputFormatData
    )
{
    DWORD                           dwRet;
    DD_GETVPORTOUTPUTFORMATDATA     GetVPortOutputFormatData;
    LPDDPIXELFORMAT                 puOutputFormats;
    DDPIXELFORMAT                   ddpfInputFormat;
    ULONG                           cjFormat;
    HANDLE                          hSecure;

    __try
    {
        GetVPortOutputFormatData
            = ProbeAndReadStructure(puGetVPortOutputFormatData,
                                    DD_GETVPORTOUTPUTFORMATDATA);

        ddpfInputFormat
            = ProbeAndReadStructure(GetVPortOutputFormatData.lpddpfInputFormat,
                                    DDPIXELFORMAT);

        puOutputFormats = GetVPortOutputFormatData.lpddpfOutputFormats;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                           = DDHAL_DRIVER_NOTHANDLED;
    GetVPortOutputFormatData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortOutputFormatData.lpDD                = peDirectDrawGlobal;
        GetVPortOutputFormatData.lpVideoPort         = peVideoPort;
        GetVPortOutputFormatData.lpddpfInputFormat   = &ddpfInputFormat;
        GetVPortOutputFormatData.lpddpfOutputFormats = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortOutputFormats))
        {
            dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortOutputFormats(&GetVPortOutputFormatData);

            cjFormat = GetVPortOutputFormatData.dwNumFormats
                     * sizeof(DDPIXELFORMAT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetVPortOutputFormatData.ddRVal == DD_OK) &&
                (cjFormat > 0) &&
                (puOutputFormats != NULL) &&
                !BALLOC_OVERFLOW1(GetVPortOutputFormatData.dwNumFormats, DDPIXELFORMAT))
            {
                GetVPortOutputFormatData.ddRVal = DDERR_GENERIC;
                hSecure = 0;

                __try
                {
                    ProbeForWrite(puOutputFormats,
                                  cjFormat,
                                  sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puOutputFormats,
                                                    cjFormat,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetVPortOutputFormatData.lpddpfOutputFormats
                        = puOutputFormats;

                    dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortOutputFormats(&GetVPortOutputFormatData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDvpGetVideoPortOutputFormats: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDvpGetVPortOutputFormatData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortOutputFormatData->ddRVal,
                          GetVPortOutputFormatData.ddRVal);
        ProbeAndWriteUlong(&puGetVPortOutputFormatData->dwNumFormats,
                           GetVPortOutputFormatData.dwNumFormats);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxGetVideoPortLine
*
* Returns the current line counter of the video port.
*
* This function is only required if the driver sets the DDVPCAPS_READBACKLINE
* flag.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortLine(
    HANDLE                  hVideoPort,
    PDD_GETVPORTLINEDATA    puGetVPortLineData
    )
{
    DWORD               dwRet;
    DD_GETVPORTLINEDATA GetVPortLineData;

    dwRet                      = DDHAL_DRIVER_NOTHANDLED;
    GetVPortLineData.ddRVal    = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortLineData.lpDD        = peDirectDrawGlobal;
        GetVPortLineData.lpVideoPort = peVideoPort;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortLine))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortLine(&GetVPortLineData);
        }
    }
    else
    {
        WARNING("DxDvpGetVPortLineData: Invalid object\n");
    }

    __try
    {
        ProbeAndWriteStructure(puGetVPortLineData,
                               GetVPortLineData,
                               DD_GETVPORTLINEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxGetVideoPortConnectInfo
*
* Fills in the specified array with all of the connection combinations
* supported by the specified video port and puts that number in dwNumEntries.
* If lpConnect is NULL, it only fills in dwNumEntries with the number of
* DDVIDEOPORTCONNECT entries supported.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortConnectInfo(
    HANDLE                  hDirectDraw,
    PDD_GETVPORTCONNECTDATA puGetVPortConnectData
    )
{
    DWORD                   dwRet;
    DD_GETVPORTCONNECTDATA  GetVPortConnectData;
    DDVIDEOPORTCONNECT*     puConnect;
    ULONG                   cjConnect;
    HANDLE                  hSecure;

    __try
    {
        GetVPortConnectData = ProbeAndReadStructure(puGetVPortConnectData,
                                                    DD_GETVPORTCONNECTDATA);

        puConnect = GetVPortConnectData.lpConnect;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                      = DDHAL_DRIVER_NOTHANDLED;
    GetVPortConnectData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetVPortConnectData.lpDD      = peDirectDrawGlobal;
        GetVPortConnectData.lpConnect = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortConnectInfo))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortConnectInfo(
                    &GetVPortConnectData);

            cjConnect = GetVPortConnectData.dwNumEntries
                      * sizeof(DDVIDEOPORTCONNECT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetVPortConnectData.ddRVal == DD_OK) &&
                (cjConnect > 0) &&
                (puConnect != NULL) &&
                !BALLOC_OVERFLOW1(GetVPortConnectData.dwNumEntries, DDVIDEOPORTCONNECT))
            {
                GetVPortConnectData.ddRVal = DDERR_GENERIC;
                hSecure = 0;

                __try
                {
                    ProbeForWrite(puConnect, cjConnect, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puConnect,
                                                    cjConnect,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetVPortConnectData.lpConnect = puConnect;

                    dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortConnectInfo(&GetVPortConnectData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDvpGetVideoPortConnectInfo: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDvpGetVPortConnectData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortConnectData->ddRVal,
                          GetVPortConnectData.ddRVal);
        ProbeAndWriteUlong(&puGetVPortConnectData->dwNumEntries,
                           GetVPortConnectData.dwNumEntries);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DxDvpGetVideoSignalStatus
*
* If the video port is receiving a good signal, the HAL should set dwStatus
* to DDVPSQ_SIGNALOK; otherwise, it should set dwStatus to DDVPSQ_NOSIGNAL.
*
*History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoSignalStatus(
    HANDLE                  hVideoPort,
    PDD_GETVPORTSIGNALDATA  puGetVPortSignalData
    )
{
    DWORD                   dwRet;
    DD_GETVPORTSIGNALDATA   GetVPortSignalData;

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    GetVPortSignalData.ddRVal   = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortSignalData.lpDD        = peDirectDrawGlobal;
        GetVPortSignalData.lpVideoPort = peVideoPort;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoSignalStatus))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoSignalStatus(&GetVPortSignalData);
        }
    }
    else
    {
        WARNING("DxDvpGetVPortSignalData: Invalid object\n");
    }

    __try
    {
        ProbeAndWriteStructure(puGetVPortSignalData,
                               GetVPortSignalData,
                               DD_GETVPORTSIGNALDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpUpdateVideoPort
*
* Starts, stops, and changes the video port.  dwFlags can contain either
* DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, or DDRAWI_VPORTUPDATE.  To accommodate
* auto-flipping, lplpDDSurface and lplpDDVBISurface point to an array of
* surface structures rather than to a single structure.  If autoflipping is
* requested, the dwNumAutoflip field contains the number of surfaces in the
* list.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpUpdateVideoPort(
    HANDLE              hVideoPort,
    HANDLE*             phSurfaceVideo,
    HANDLE*             phSurfaceVbi,
    PDD_UPDATEVPORTDATA puUpdateVPortData
    )
{
    DWORD               dwRet;
    DD_UPDATEVPORTDATA  UpdateVPortData;
    DDVIDEOPORTINFO     VideoPortInfo;
    DDPIXELFORMAT       ddpfInputFormat;
    DDPIXELFORMAT       ddpfVBIInputFormat;
    DDPIXELFORMAT       ddpfVBIOutputFormat;
    HANDLE              ahSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    HANDLE              ahSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    EDD_SURFACE*        apeSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    EDD_SURFACE*        apeSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    DD_SURFACE_INT*     apDDSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    DD_SURFACE_INT*     apDDSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    ULONG               cAutoflipVideo;
    ULONG               cAutoflipVbi;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    __try
    {
        UpdateVPortData = ProbeAndReadStructure(puUpdateVPortData,
                                                DD_UPDATEVPORTDATA);

        // Handle VideoPortInfo structure:

        if (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP)
        {
            VideoPortInfo = ProbeAndReadStructure(UpdateVPortData.lpVideoInfo,
                                                  DDVIDEOPORTINFO);

            if (VideoPortInfo.lpddpfInputFormat != NULL)
            {
                ddpfInputFormat
                    = ProbeAndReadStructure(VideoPortInfo.lpddpfInputFormat,
                                            DDPIXELFORMAT);

                VideoPortInfo.lpddpfInputFormat = &ddpfInputFormat;
            }
            if (VideoPortInfo.dwVBIHeight > 0)
            {
                if (VideoPortInfo.lpddpfVBIInputFormat  != NULL)
                {
                    ddpfVBIInputFormat
                        = ProbeAndReadStructure(VideoPortInfo.lpddpfVBIInputFormat,
                                                DDPIXELFORMAT);

                    VideoPortInfo.lpddpfVBIInputFormat = &ddpfVBIInputFormat;
                }
                if (VideoPortInfo.lpddpfVBIOutputFormat != NULL)
                {
                    ddpfVBIOutputFormat
                        = ProbeAndReadStructure(VideoPortInfo.lpddpfVBIOutputFormat,
                                                DDPIXELFORMAT);

                    VideoPortInfo.lpddpfVBIOutputFormat = &ddpfVBIOutputFormat;
                }
            }
            else
            {
                VideoPortInfo.lpddpfVBIInputFormat  = NULL;
                VideoPortInfo.lpddpfVBIOutputFormat = NULL;
            }
        }

        // Handle arrays of surfaces:

        cAutoflipVbi = 0;
        cAutoflipVideo = 0;

        if (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP)
        {
            cAutoflipVideo = min(UpdateVPortData.dwNumAutoflip, MAX_AUTOFLIP_BUFFERS);
            if ((cAutoflipVideo == 0) && (UpdateVPortData.lplpDDSurface != NULL))
            {
                cAutoflipVideo = 1;
            }

            cAutoflipVbi = min(UpdateVPortData.dwNumVBIAutoflip, MAX_AUTOFLIP_BUFFERS);
            if ((cAutoflipVbi == 0) && (UpdateVPortData.lplpDDVBISurface != NULL))
            {
                cAutoflipVbi = 1;
            }
        }
        if (cAutoflipVideo)
        {
            ProbeForRead(phSurfaceVideo,
                         cAutoflipVideo * sizeof(HANDLE),
                         sizeof(HANDLE));
            RtlCopyMemory(ahSurfaceVideo,
                          phSurfaceVideo,
                          cAutoflipVideo * sizeof(HANDLE));
        }
        if (cAutoflipVbi)
        {
            ProbeForRead(phSurfaceVbi,
                         cAutoflipVbi * sizeof(HANDLE),
                         sizeof(HANDLE));
            RtlCopyMemory(ahSurfaceVbi,
                          phSurfaceVbi,
                          cAutoflipVbi * sizeof(HANDLE));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    UpdateVPortData.ddRVal  = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    ULONG                   i;
    EDD_SURFACE*            peSurface;

    BOOL                    bUpdateOK = TRUE;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDxVideoPort = peVideoPort->peDxVideoPort;
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        // Lock all the surfaces.  Note that bDdUpdateLinksAndSynchronize
        // will check for failure of DdHmgLock (the pointer will be NULL):

        for (i = 0; i < cAutoflipVideo; i++)
        {
            apeSurfaceVideo[i] = (EDD_SURFACE*)
                DdHmgLock((HDD_OBJ) ahSurfaceVideo[i], DD_SURFACE_TYPE, FALSE);
        }
        for (i = 0; i < cAutoflipVbi; i++)
        {
            apeSurfaceVbi[i] = (EDD_SURFACE*)
                DdHmgLock((HDD_OBJ) ahSurfaceVbi[i], DD_SURFACE_TYPE, FALSE);
        }

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort) &&
            (bUpdateOK = bDdUpdateLinksAndSynchronize(
                                          peVideoPort,
                                          TRUE,             // Update video
                                          apeSurfaceVideo,
                                          cAutoflipVideo,
                                          TRUE,             // Update VBI
                                          apeSurfaceVbi,
                                          cAutoflipVbi)))
        {
            UpdateVPortData.lpDD             = peDirectDrawGlobal;
            UpdateVPortData.lpVideoPort      = peVideoPort;
            UpdateVPortData.lplpDDSurface    = NULL;
            UpdateVPortData.lplpDDVBISurface = NULL;
            UpdateVPortData.dwNumAutoflip    = cAutoflipVideo;
            UpdateVPortData.dwNumVBIAutoflip = cAutoflipVbi;
            UpdateVPortData.lpVideoInfo
                = (UpdateVPortData.dwFlags == DDRAWI_VPORTSTOP)
                ? NULL
                : &VideoPortInfo;

            if (cAutoflipVideo != 0)
            {
                for (i = 0; i < cAutoflipVideo; i++)
                {
                    apDDSurfaceVideo[i] = apeSurfaceVideo[i];
                }
                UpdateVPortData.lplpDDSurface = apDDSurfaceVideo;
            }
            if (cAutoflipVbi != 0)
            {
                for (i = 0; i < cAutoflipVbi; i++)
                {
                    apDDSurfaceVbi[i] = apeSurfaceVbi[i];
                }
                UpdateVPortData.lplpDDVBISurface = apDDSurfaceVbi;
            }

            // Turn off software autoflipping if necessary:

            if (UpdateVPortData.dwFlags == DDRAWI_VPORTSTOP)
            {
                peDxVideoPort->bSoftwareAutoflip = FALSE;
                peDxVideoPort->flFlags &= ~(DD_DXVIDEOPORT_FLAG_AUTOFLIP|DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI);

                // Disable the video port VSYNC IRQ now

                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON )
                {
                    peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_ON;
                    peDirectDrawGlobal->pfnEnableIRQ(peDxVideoPort, FALSE );
                }
            }

            // We don't allow switching back to hardware once software
            // autoflipping has started (for various reasons, among
            // them being how do we synchronize -- the hardware would
            // start autoflipping before we could turn off the software
            // autoflipping).

            if (peDxVideoPort->bSoftwareAutoflip)
            {
                VideoPortInfo.dwVPFlags &= ~DDVP_AUTOFLIP;
            }

            // Make the HAL call:

            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.UpdateVideoPort(&UpdateVPortData);

            // If we failed due to a request for hardware autoflipping,
            // try again with software autoflipping.

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (UpdateVPortData.ddRVal != DD_OK) &&
                (peDirectDrawGlobal->DDKernelCaps.dwCaps & DDKERNELCAPS_AUTOFLIP))
            {
                VideoPortInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

                dwRet = peDirectDrawGlobal->
                    VideoPortCallBacks.UpdateVideoPort(&UpdateVPortData);

                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (UpdateVPortData.ddRVal == DD_OK))
                {
                    KdPrint(("DxDvpUpdateVideoPort: Software autoflipping\n"));

                    peDxVideoPort->bSoftwareAutoflip = TRUE;
                    UpdateVPortData.ddRVal = DD_OK;
                }
            }
            
            if ((UpdateVPortData.ddRVal == DD_OK) &&
                peDxVideoPort->bSoftwareAutoflip)
            {
                if( cAutoflipVideo > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP;
                }
                if( cAutoflipVbi > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI;
                }
            }
        }

        if (!bUpdateOK)
        {
            WARNING("DxDvpUpdateVideoPort: failed on bDdUpdateLinksAndSynchronize");
        }

        if ((dwRet == DDHAL_DRIVER_HANDLED) &&
            (UpdateVPortData.ddRVal == DD_OK))
        {
            // Success!

            peVideoPort->dwNumAutoflip    = cAutoflipVideo;
            peVideoPort->dwNumVBIAutoflip = cAutoflipVbi;
            if (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP)
            {
                peVideoPort->ddvpInfo = VideoPortInfo;

                if (VideoPortInfo.lpddpfInputFormat != NULL)
                {
                    peVideoPort->ddvpInfo.lpddpfInputFormat
                        = &peVideoPort->ddpfInputFormat;

                    peVideoPort->ddpfInputFormat = ddpfInputFormat;
                }
                else
                {
                    peVideoPort->ddvpInfo.lpddpfInputFormat = NULL;
                }
            }
        }

        // Update various DXAPI state to reflect the changes:

        vDdSynchronizeVideoPort(peVideoPort);

        // If it wasn't previously on, enable the video port VSYNC IRQ now
        //
        // if bDdUpdateLinksAndSynchronize failed, don't enable.

        if(  (bUpdateOK) &&
             (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP) &&
            !(peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON) )
        {
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_ON;
            peDirectDrawGlobal->pfnEnableIRQ(peDxVideoPort, TRUE );
        }

        // Unlock the memory that I've locked

        for (i = 0; i < cAutoflipVideo; i++)
        {
            if( apeSurfaceVideo[i] != NULL )
                DEC_EXCLUSIVE_REF_CNT( apeSurfaceVideo[i] );
        }
        for (i = 0; i < cAutoflipVbi; i++)
        {
            if( apeSurfaceVbi[i] != NULL )
                DEC_EXCLUSIVE_REF_CNT( apeSurfaceVbi[i] );
        }

    }
    else
    {
        WARNING("DxDvpUpdateVPortData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUpdateVPortData->ddRVal, UpdateVPortData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpWaitForVideoPortSync
*
* Returns at the beginning or end of either the video VSYNC or the specified
* line.  If the sync does not occur before the number of milliseconds
* specified in dwTimeOut has elapsed, the HAL should return
* DDERR_VIDEONOTACTIVE.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpWaitForVideoPortSync(
    HANDLE                      hVideoPort,
    PDD_WAITFORVPORTSYNCDATA    puWaitForVPortSyncData
    )
{
    DWORD                   dwRet;
    DD_WAITFORVPORTSYNCDATA WaitForVPortSyncData;

    __try
    {
        WaitForVPortSyncData = ProbeAndReadStructure(puWaitForVPortSyncData,
                                                     DD_WAITFORVPORTSYNCDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    WaitForVPortSyncData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        WaitForVPortSyncData.lpDD        = peDirectDrawGlobal;
        WaitForVPortSyncData.lpVideoPort = peVideoPort;

        // Cap the number of milliseconds to wait to something reasonable:

        if (WaitForVPortSyncData.dwTimeOut
                > 6 * peVideoPort->ddvpDesc.dwMicrosecondsPerField)
        {
            WaitForVPortSyncData.dwTimeOut
                = 6 * peVideoPort->ddvpDesc.dwMicrosecondsPerField;
        }

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.WaitForVideoPortSync))
        {
            dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                WaitForVideoPortSync(&WaitForVPortSyncData);
        }
    }
    else
    {
        WARNING("DxDvpWaitForVPortSyncData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puWaitForVPortSyncData->ddRVal,
                          WaitForVPortSyncData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpColorControl
*
* Gets or sets the current color controls associated with the video port.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpColorControl(
    HANDLE              hVideoPort,
    PDD_VPORTCOLORDATA  puVPortColorData
    )
{
    DWORD               dwRet;
    DD_VPORTCOLORDATA   VPortColorData;
    DDCOLORCONTROL      ColorData;

    __try
    {
        VPortColorData = ProbeAndReadStructure(puVPortColorData,
                                               DD_VPORTCOLORDATA);

        ColorData = ProbeAndReadStructure(VPortColorData.lpColorData,
                                          DDCOLORCONTROL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                 = DDHAL_DRIVER_NOTHANDLED;
    VPortColorData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        VPortColorData.lpDD        = peDirectDrawGlobal;
        VPortColorData.lpVideoPort = peVideoPort;
        VPortColorData.lpColorData = &ColorData;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.ColorControl))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.ColorControl(&VPortColorData);
        }
    }
    else
    {
        WARNING("DxDvpColorControl: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puVPortColorData->ddRVal, VPortColorData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpAcquireNotification
*
* Sets up the user mode notification of video port vsyncs.
*
* History:
*  10-Oct-2000 -Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpAcquireNotification(
    HANDLE               hVideoPort,
    HANDLE *             phEvent,
    LPDDVIDEOPORTNOTIFY  pNotify
    )
{
    PKEVENT                 pEvent = NULL;
    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    PMDL                    mdl;
    LPDDVIDEOPORTNOTIFY     pLockedBuffer;

    __try
    {
        ProbeAndWriteHandle(phEvent, NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // First check the caps to see if this device even supports a vport IRQ

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if ((peVideoPort != NULL) &&
        (peVideoPort->peDxVideoPort->pNotifyEvent == NULL))
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
        if (peDirectDrawGlobal->DDKernelCaps.dwIRQCaps & DDIRQ_VPORT0_VSYNC )
        {
            // Now setup the buffer so it can be accessed at DPC level
            mdl = IoAllocateMdl(pNotify,
                                sizeof(DDVIDEOPORTNOTIFY),
                                FALSE,
                                FALSE,
                                NULL);
            if (mdl != NULL)
            {
                __try
                {
                    MmProbeAndLockPages (mdl,
                                        KernelMode,
                                        IoWriteAccess);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    IoFreeMdl (mdl);
                    mdl = NULL;
                }
            }

            if (mdl != NULL)
            {
                pLockedBuffer = (LPDDVIDEOPORTNOTIFY) 
                    MmGetSystemAddressForMdlSafe (mdl,
                                                  NormalPagePriority);
                if (pLockedBuffer == NULL)
                {
                    MmUnlockPages (mdl);
                    IoFreeMdl (mdl);
                }
                else
                {
                    // Now set up the event that we trigger

                    HANDLE h = NULL;

                    ZwCreateEvent( &h,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

                    if (h != NULL)
                    {
                        (VOID) ObReferenceObjectByHandle( h,
                                        0,
                                        0,
                                        KernelMode,
                                        (PVOID *) &pEvent,
                                        NULL );
                    }

                    if (pEvent != NULL)
                    {
                        ObDereferenceObject(pEvent);
                        peVideoPort->peDxVideoPort->pNotifyBuffer = pLockedBuffer;
                        peVideoPort->peDxVideoPort->pNotifyMdl = mdl;
                        peVideoPort->peDxVideoPort->pNotifyEvent = pEvent;
                        peVideoPort->peDxVideoPort->pNotifyEventHandle = h;

                        __try
                        {
                            ProbeAndWriteHandle(phEvent, h);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }
                    else
                    {
                        MmUnlockPages (mdl);
                        IoFreeMdl (mdl);
                    }
                }
                // force software autoflipping
                peVideoPort->peDxVideoPort->bSoftwareAutoflip = TRUE;
            }
        }
    }

    return 0;
}

/*****************************Private*Routine******************************\
* DWORD DxDvpReleaseNotification
*
* Stops up the user mode notification of video port vsyncs.
*
* History:
*  10-Oct-2000 -Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpReleaseNotification(
    HANDLE              hVideoPort,
    HANDLE              pEvent
    )
{
    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if ((peVideoPort != NULL) &&
        (peVideoPort->peDxVideoPort->pNotifyEventHandle == pEvent) &&
        (pEvent != NULL))
    {
        PKEVENT     pTemp = NULL;
        NTSTATUS    Status;

        peVideoPort->peDxVideoPort->pNotifyEvent = NULL;
        peVideoPort->peDxVideoPort->pNotifyEventHandle = NULL;

        // Make sure that the handle hasn't been freed by the OS already
        Status = ObReferenceObjectByHandle( pEvent,
                                        0,
                                        0,
                                        KernelMode,
                                        (PVOID *) &pTemp,
                                        NULL );
        if ((pTemp != NULL) && (Status != STATUS_INVALID_HANDLE))
        {
            ObDereferenceObject(pTemp);
            ZwClose (pEvent);
        }

        peVideoPort->peDxVideoPort->pNotifyBuffer = NULL;
        if (peVideoPort->peDxVideoPort->pNotifyMdl != NULL)
        {
            MmUnlockPages (peVideoPort->peDxVideoPort->pNotifyMdl);
            IoFreeMdl (peVideoPort->peDxVideoPort->pNotifyMdl);
            peVideoPort->peDxVideoPort->pNotifyMdl = NULL;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\dxg\ddkcomp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkcomp.h
 *  Content:	Compilation environment for Win9x code in NT kernel.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Keep common code for DDraw heap.
 *
 ***************************************************************************/

#ifndef __NTDDKCOMP__
#define __NTDDKCOMP__

#if DBG
#define DEBUG
#else
#undef DEBUG
#endif

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE NULL
#endif

typedef DD_DIRECTDRAW_LOCAL *LPDDRAWI_DIRECTDRAW_LCL;
typedef DD_DIRECTDRAW_GLOBAL *LPDDRAWI_DIRECTDRAW_GBL;
typedef DD_SURFACE_LOCAL *LPDDRAWI_DDRAWSURFACE_LCL;
typedef DD_SURFACE_GLOBAL *LPDDRAWI_DDRAWSURFACE_GBL;

typedef VIDEOMEMORYINFO VIDMEMINFO;
typedef VIDMEMINFO *LPVIDMEMINFO;
typedef VIDEOMEMORY VIDMEM;
typedef VIDMEM *LPVIDMEM;

#ifndef ZeroMemory
#define ZeroMemory(pv, cBytes) RtlZeroMemory(pv, cBytes)
#endif

#define ZwCloseKey             ZwClose

#define ABS(A)      ((A) <  0  ? -(A) : (A))

//
// Sundown: in GDI, there are lots of places SIZE_T are used as interchangeable
// as ULONG or UINT or LONG or INT.  On 64bit system, SIZE_T is int64 indeed.
// Since we are not making any GDI objects large objects right now, I just
// change all SIZE_T to ULONGSIZE_T here.
//
// The new type used is to easily identify the change later.
//
#define ULONGSIZE_T ULONG

#if defined(_X86_)

//
// Keep our own copy of this to avoid double indirections on probing
//
extern ULONG_PTR DxgUserProbeAddress;

#undef  MM_USER_PROBE_ADDRESS
#define MM_USER_PROBE_ADDRESS DxgUserProbeAddress
#endif // defined(_X86_)

//
// Macro to check memory allocation overflow.
//
#define MAXIMUM_POOL_ALLOC          (PAGE_SIZE * 10000)
#define BALLOC_OVERFLOW1(c,st)      (c > (MAXIMUM_POOL_ALLOC/sizeof(st)))
#define BALLOC_OVERFLOW2(c,st1,st2) (c > (MAXIMUM_POOL_ALLOC/(sizeof(st1)+sizeof(st2))))

//
// Debugger output macros
//
#define DDASSERT(Expr) ASSERTGDI(Expr, "DDASSERT")
#define VDPF(Args)

#ifdef DEBUG
    VOID  WINAPI DoRip(PSZ);
    VOID  WINAPI DoWarning(PSZ,LONG);

    #define RIP(x) DoRip((PSZ) x)
    #define ASSERTGDI(x,y) if(!(x)) DoRip((PSZ) y)
    #define WARNING(x)  DoWarning(x,0)
    #define WARNING1(x) DoWarning(x,1)

    #define RECORD_DRIVER_EXCEPTION() DbgPrint("Driver caused exception - %s line %u\n",__FILE__,__LINE__);

#else
    #define RIP(x)
    #define ASSERTGDI(x,y)
    #define WARNING(x)
    #define WARNING1(x)

    #define RECORD_DRIVER_EXCEPTION()

#endif

//
// Allocated memory is zero-filled.
//
#define MemAlloc(cBytes)           PALLOCMEM(cBytes, 'pddD')
#define MemFree(pv)                VFREEMEM(pv)

#define PALLOCMEM(cBytes,tag)      EngAllocMem(FL_ZERO_MEMORY,cBytes,tag)
#define PALLOCNOZ(cBytes,tag)      EngAllocMem(0,cBytes,tag)
#define PALLOCNONPAGED(cBytes,tag) EngAllocMem(FL_ZERO_MEMORY|FL_NONPAGED_MEMORY,cBytes,tag)

#define VFREEMEM(pv)               EngFreeMem(pv)

//
// From ntos\inc\pool.h
//
#define SESSION_POOL_MASK          32

//
// Error messages
//
#define SAVE_ERROR_CODE(x)         EngSetLastError((x))

//
// Macro to see if terminal server or not
//
#define ISTS()                     DxEngIsTermSrv()

//
// Macro to increment display uniqueness
//
#define INC_DISPLAY_UNIQUENESS()   DxEngIncDispUniq()

//
// Macro
//
#define VISRGN_UNIQUENESS()        DxEngVisRgnUniq()

//
// Macro
//
#define SURFOBJ_HOOK(pso)          ((FLONG)DxEngGetSurfaceData(pso,SURF_HOOKFLAGS))

#endif // __NTDDKCOMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\dxkernel\inc\dxg.h ===
//TODO: from gre\pdevobj.hxx
#ifndef DRIVER_NOT_CAPABLE_DDRAW
#define DRIVER_NOT_CAPABLE_DDRAW      2
#endif
#ifndef DRIVER_NOT_CAPABLE_D3D
#define DRIVER_NOT_CAPABLE_D3D        4
#endif

#ifndef W32PID
#define W32PID ULONG
#endif

//
// The functions index which dxg.sys exports to win32k.sys
//
NTSTATUS
DxDdStartupDxGraphics(
    ULONG          cjEng,
    DRVENABLEDATA *pdedEng,
    ULONG          cjDxg,
    DRVENABLEDATA *pdedDxg,
    DWORD         *pdwDirectContext,
    PEPROCESS      pepSession
    );

NTSTATUS
DxDdCleanupDxGraphics(
    VOID
    );

typedef NTSTATUS (*PFN_StartupDxGraphics)(ULONG,DRVENABLEDATA*,ULONG,DRVENABLEDATA*,DWORD*,PEPROCESS);
typedef NTSTATUS (*PFN_CleanupDxGraphics)(VOID);

#define INDEX_DxDxgGenericThunk                     0
#define INDEX_DxD3dContextCreate                    1
#define INDEX_DxD3dContextDestroy                   2
#define INDEX_DxD3dContextDestroyAll                3
#define INDEX_DxD3dValidateTextureStageState        4
#define INDEX_DxD3dDrawPrimitives2                  5
#define INDEX_DxDdGetDriverState                    6
#define INDEX_DxDdAddAttachedSurface                7
#define INDEX_DxDdAlphaBlt                          8
#define INDEX_DxDdAttachSurface                     9
#define INDEX_DxDdBeginMoCompFrame                 10
#define INDEX_DxDdBlt                              11
#define INDEX_DxDdCanCreateSurface                 12
#define INDEX_DxDdCanCreateD3DBuffer               13
#define INDEX_DxDdColorControl                     14
#define INDEX_DxDdCreateDirectDrawObject           15
#define INDEX_DxDdCreateSurface                    16
#define INDEX_DxDdCreateD3DBuffer                  17
#define INDEX_DxDdCreateMoComp                     18
#define INDEX_DxDdCreateSurfaceObject              19
#define INDEX_DxDdDeleteDirectDrawObject           20
#define INDEX_DxDdDeleteSurfaceObject              21
#define INDEX_DxDdDestroyMoComp                    22
#define INDEX_DxDdDestroySurface                   23
#define INDEX_DxDdDestroyD3DBuffer                 24
#define INDEX_DxDdEndMoCompFrame                   25
#define INDEX_DxDdFlip                             26
#define INDEX_DxDdFlipToGDISurface                 27
#define INDEX_DxDdGetAvailDriverMemory             28
#define INDEX_DxDdGetBltStatus                     29
#define INDEX_DxDdGetDC                            30
#define INDEX_DxDdGetDriverInfo                    31
#define INDEX_DxDdGetDxHandle                      32
#define INDEX_DxDdGetFlipStatus                    33
#define INDEX_DxDdGetInternalMoCompInfo            34
#define INDEX_DxDdGetMoCompBuffInfo                35
#define INDEX_DxDdGetMoCompGuids                   36
#define INDEX_DxDdGetMoCompFormats                 37
#define INDEX_DxDdGetScanLine                      38
#define INDEX_DxDdLock                             39
#define INDEX_DxDdLockD3D                          40
#define INDEX_DxDdQueryDirectDrawObject            41
#define INDEX_DxDdQueryMoCompStatus                42
#define INDEX_DxDdReenableDirectDrawObject         43
#define INDEX_DxDdReleaseDC                        44
#define INDEX_DxDdRenderMoComp                     45
#define INDEX_DxDdResetVisrgn                      46
#define INDEX_DxDdSetColorKey                      47
#define INDEX_DxDdSetExclusiveMode                 48
#define INDEX_DxDdSetGammaRamp                     49
#define INDEX_DxDdCreateSurfaceEx                  50
#define INDEX_DxDdSetOverlayPosition               51
#define INDEX_DxDdUnattachSurface                  52
#define INDEX_DxDdUnlock                           53
#define INDEX_DxDdUnlockD3D                        54
#define INDEX_DxDdUpdateOverlay                    55
#define INDEX_DxDdWaitForVerticalBlank             56
#define INDEX_DxDvpCanCreateVideoPort              57
#define INDEX_DxDvpColorControl                    58
#define INDEX_DxDvpCreateVideoPort                 59
#define INDEX_DxDvpDestroyVideoPort                60
#define INDEX_DxDvpFlipVideoPort                   61
#define INDEX_DxDvpGetVideoPortBandwidth           62
#define INDEX_DxDvpGetVideoPortField               63
#define INDEX_DxDvpGetVideoPortFlipStatus          64
#define INDEX_DxDvpGetVideoPortInputFormats        65
#define INDEX_DxDvpGetVideoPortLine                66
#define INDEX_DxDvpGetVideoPortOutputFormats       67
#define INDEX_DxDvpGetVideoPortConnectInfo         68
#define INDEX_DxDvpGetVideoSignalStatus            69
#define INDEX_DxDvpUpdateVideoPort                 70
#define INDEX_DxDvpWaitForVideoPortSync            71
#define INDEX_DxDvpAcquireNotification             72
#define INDEX_DxDvpReleaseNotification             73
#define INDEX_DxDdHeapVidMemAllocAligned           74
#define INDEX_DxDdHeapVidMemFree                   75
#define INDEX_DxDdEnableDirectDraw                 76
#define INDEX_DxDdDisableDirectDraw                77
#define INDEX_DxDdSuspendDirectDraw                78 
#define INDEX_DxDdResumeDirectDraw                 79
#define INDEX_DxDdDynamicModeChange                80
#define INDEX_DxDdCloseProcess                     81
#define INDEX_DxDdGetDirectDrawBounds              82
#define INDEX_DxDdEnableDirectDrawRedirection      83
#define INDEX_DxDdAllocPrivateUserMem              84
#define INDEX_DxDdFreePrivateUserMem               85
#define INDEX_DxDdLockDirectDrawSurface            86
#define INDEX_DxDdUnlockDirectDrawSurface          87
#define INDEX_DxDdSetAccelLevel                    88
#define INDEX_DxDdGetSurfaceLock                   89
#define INDEX_DxDdEnumLockedSurfaceRect            90
#define INDEX_DxDdIoctl                            91

//
// Prototype definition
//

DWORD  APIENTRY DxDxgGenericThunk(
    IN     ULONG_PTR ulIndex,
    IN     ULONG_PTR ulHandle,
    IN OUT SIZE_T   *pdwSizeOfPtr1,
    IN OUT PVOID     pvPtr1,
    IN OUT SIZE_T   *pdwSizeOfPtr2,
    IN OUT PVOID     pvPtr2);

DWORD APIENTRY DxDdAddAttachedSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached,
    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);

BOOL APIENTRY DxDdAttachSurface(
    IN     HANDLE hSurfaceFrom,
    IN     HANDLE hSurfaceTo);

DWORD APIENTRY DxDdBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);

DWORD APIENTRY DxDdCanCreateSurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY DxDdColorControl(
    IN     HANDLE hSurface,
    IN OUT PDD_COLORCONTROLDATA puColorControlData);

HANDLE APIENTRY DxDdCreateDirectDrawObject(
    IN     HDC hdc);

DWORD  APIENTRY DxDdCreateSurface(
    IN     HANDLE  hDirectDraw,
    IN     HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
       OUT HANDLE* puhSurface);

HANDLE APIENTRY DxDdCreateSurfaceObject(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurface,
    IN     PDD_SURFACE_LOCAL puSurfaceLocal,
    IN     PDD_SURFACE_MORE puSurfaceMore,
    IN     PDD_SURFACE_GLOBAL puSurfaceGlobal,
    IN     BOOL bComplete);

BOOL APIENTRY DxDdDeleteSurfaceObject(
    IN     HANDLE hSurface);

BOOL APIENTRY DxDdDeleteDirectDrawObject(
    IN     HANDLE hDirectDrawLocal);

DWORD APIENTRY DxDdDestroySurface(
    IN     HANDLE hSurface,
    IN     BOOL bRealDestroy);

DWORD APIENTRY DxDdFlip(
    IN     HANDLE hSurfaceCurrent,
    IN     HANDLE hSurfaceTarget,
    IN     HANDLE hSurfaceCurrentLeft,
    IN     HANDLE hSurfaceTargetLeft,
    IN OUT PDD_FLIPDATA puFlipData);

DWORD APIENTRY DxDdGetAvailDriverMemory(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);

DWORD APIENTRY DxDdGetBltStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);

HDC APIENTRY DxDdGetDC(
    IN     HANDLE hSurface,
    IN     PALETTEENTRY* puColorTable);

DWORD APIENTRY DxDdGetDriverInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);

DWORD APIENTRY DxDdGetFlipStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);

DWORD APIENTRY DxDdGetScanLine(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETSCANLINEDATA puGetScanLineData);

DWORD APIENTRY DxDdSetExclusiveMode(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);

DWORD APIENTRY DxDdFlipToGDISurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);

DWORD APIENTRY DxDdLock(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData,
    IN HDC hdcClip);

BOOL APIENTRY DxDdQueryDirectDrawObject(
    IN     HANDLE,
    IN OUT PDD_HALINFO,
    IN OUT DWORD*,
    IN OUT LPD3DNTHAL_CALLBACKS,
    IN OUT LPD3DNTHAL_GLOBALDRIVERDATA,
    IN OUT PDD_D3DBUFCALLBACKS,
    IN OUT LPDDSURFACEDESC,
    IN OUT DWORD*,
    IN OUT VIDEOMEMORY*,
    IN OUT DWORD*,
    IN OUT DWORD*);
 
BOOL APIENTRY DxDdReenableDirectDrawObject(
    IN     HANDLE hDirectDrawLocal,
    IN OUT BOOL* pubNewMode);

BOOL APIENTRY DxDdReleaseDC(
    IN     HANDLE hSurface);

BOOL APIENTRY DxDdResetVisrgn(
    IN     HANDLE hSurface,
    IN HWND hwnd);

DWORD APIENTRY DxDdSetColorKey(
    IN     HANDLE hSurface,
    IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);

DWORD APIENTRY DxDdSetOverlayPosition(
    IN     HANDLE hSurfaceSource,
    IN     HANDLE hSurfaceDestination,
    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);

VOID  APIENTRY DxDdUnattachSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached);

DWORD APIENTRY DxDdUnlock(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY DxDdUpdateOverlay(
    IN     HANDLE hSurfaceDestination,
    IN     HANDLE hSurfaceSource,
    IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);

DWORD APIENTRY DxDdWaitForVerticalBlank(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);

HANDLE APIENTRY DxDdGetDxHandle(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     BOOL bRelease);

BOOL APIENTRY DxDdSetGammaRamp(
    IN     HANDLE hDirectDraw,
    IN     HDC hdc,
    IN     LPVOID lpGammaRamp);

DWORD APIENTRY DxDdLockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData);

DWORD APIENTRY DxDdUnlockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY DxDdCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
    IN OUT HANDLE* puhSurface);

DWORD APIENTRY DxDdCanCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY DxDdDestroyD3DBuffer(
    IN     HANDLE hSurface);

DWORD APIENTRY DxD3dContextCreate(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurfColor,
    IN     HANDLE hSurfZ,
    IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

DWORD APIENTRY DxD3dContextDestroy(
    IN     LPD3DNTHAL_CONTEXTDESTROYDATA);

DWORD APIENTRY DxD3dContextDestroyAll(
       OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

DWORD APIENTRY DxD3dValidateTextureStageState(
    IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD APIENTRY DxD3dDrawPrimitives2(
    IN     HANDLE hCmdBuf,
    IN     HANDLE hVBuf,
    IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
    IN OUT FLATPTR* pfpVidMemCmd,
    IN OUT DWORD* pdwSizeCmd,
    IN OUT FLATPTR* pfpVidMemVtx,
    IN OUT DWORD* pdwSizeVtx);

DWORD APIENTRY DxDdGetDriverState(
    IN OUT PDD_GETDRIVERSTATEDATA pdata);

DWORD APIENTRY DxDdCreateSurfaceEx(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     DWORD dwSurfaceHandle);

DWORD APIENTRY DxDdGetMoCompGuids(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);

DWORD APIENTRY DxDdGetMoCompFormats(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);

DWORD APIENTRY DxDdGetMoCompBuffInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);

DWORD APIENTRY DxDdGetInternalMoCompInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);

HANDLE APIENTRY DxDdCreateMoComp(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);

DWORD APIENTRY DxDdDestroyMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);

DWORD APIENTRY DxDdBeginMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);

DWORD APIENTRY DxDdEndMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);

DWORD APIENTRY DxDdRenderMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);

DWORD APIENTRY DxDdQueryMoCompStatus(
    IN OUT HANDLE hMoComp,
    IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

DWORD APIENTRY DxDdAlphaBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);

DWORD APIENTRY DxDvpCanCreateVideoPort(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATEVPORTDATA puCanCreateVPortData);

DWORD APIENTRY DxDvpColorControl(
    IN     HANDLE hVideoPort,
    IN OUT PDD_VPORTCOLORDATA puVPortColorData);

HANDLE APIENTRY DxDvpCreateVideoPort(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEVPORTDATA puCreateVPortData);

DWORD  APIENTRY DxDvpDestroyVideoPort(
    IN     HANDLE hVideoPort,
    IN OUT PDD_DESTROYVPORTDATA puDestroyVPortData);

DWORD  APIENTRY DxDvpFlipVideoPort(
    IN     HANDLE hVideoPort,
    IN     HANDLE hDDSurfaceCurrent,
    IN     HANDLE hDDSurfaceTarget,
    IN OUT PDD_FLIPVPORTDATA puFlipVPortData);

DWORD  APIENTRY DxDvpGetVideoPortBandwidth(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData);

DWORD  APIENTRY DxDvpGetVideoPortField(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTFIELDDATA puGetVPortFieldData);

DWORD  APIENTRY DxDvpGetVideoPortFlipStatus(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData);

DWORD  APIENTRY DxDvpGetVideoPortInputFormats(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData);

DWORD  APIENTRY DxDvpGetVideoPortLine(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTLINEDATA puGetVPortLineData);

DWORD  APIENTRY DxDvpGetVideoPortOutputFormats(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData);

DWORD  APIENTRY DxDvpGetVideoPortConnectInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETVPORTCONNECTDATA puGetVPortConnectData);

DWORD  APIENTRY DxDvpGetVideoSignalStatus(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTSIGNALDATA puGetVPortSignalData);

DWORD  APIENTRY DxDvpUpdateVideoPort(
    IN     HANDLE hVideoPort,
    IN     HANDLE* phSurfaceVideo,
    IN     HANDLE* phSurfaceVbi,
    IN OUT PDD_UPDATEVPORTDATA puUpdateVPortData);

DWORD  APIENTRY DxDvpWaitForVideoPortSync(
    IN     HANDLE hVideoPort,
    IN OUT PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData);

DWORD  APIENTRY DxDvpAcquireNotification(
    IN     HANDLE hVideoPort,
    IN OUT HANDLE* phEvent,
    IN     LPDDVIDEOPORTNOTIFY pNotify);

DWORD  APIENTRY DxDvpReleaseNotification(
    IN     HANDLE hVideoPort,
    IN     HANDLE hEvent);

FLATPTR WINAPI DxDdHeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch );

VOID    WINAPI DxDdHeapVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

//
// Private for win32k.sys
//
BOOL DxDdEnableDirectDraw(
    HDEV hdev,
    BOOL bEnableDriver
    );

VOID DxDdDisableDirectDraw(
    HDEV hdev,
    BOOL bDisableDriver
    );

VOID DxDdSuspendDirectDraw(
    HDEV    hdev,
    ULONG   fl
    );

VOID DxDdResumeDirectDraw(
    HDEV    hdev,
    ULONG   fl
    );

#define DXG_SR_DDRAW_CHILDREN    0x0001
#define DXG_SR_DDRAW_MODECHANGE  0x0002

VOID DxDdDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew,
    ULONG   fl
    );

#define DXG_MODECHANGE_TRANSFER  0x0001

VOID DxDdCloseProcess(
    W32PID  W32Pid
    );

BOOL DxDdGetDirectDrawBounds(
    HDEV    hdev,
    RECT*   prcBounds
    );

BOOL DxDdEnableDirectDrawRedirection(
    HDEV hdev,
    BOOL bEnable
    );

PVOID DxDdAllocPrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    SIZE_T cj,
    ULONG tag
    );

VOID DxDdFreePrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    PVOID pv
    );

HRESULT DxDdIoctl(
    ULONG ulIoctl,
    PVOID pBuffer,
    ULONG ulBufferSize
    );

PDD_SURFACE_LOCAL DxDdLockDirectDrawSurface(
    HANDLE hSurface
    );

BOOL DxDdUnlockDirectDrawSurface(
    PDD_SURFACE_LOCAL pSurface
    );

VOID DxDdSetAccelLevel(
    HDEV  hdev,
    DWORD dwAccelLevel,
    DWORD dwOverride
    );

DWORD DxDdGetSurfaceLock(
    HDEV  hdev
    );

PVOID DxDdEnumLockedSurfaceRect(
    HDEV   hdev,
    PVOID  pvSurface,
    RECTL *pLockedRect
    ); 

typedef DWORD (APIENTRY *PFN_DxDxgGenericThunk)(IN ULONG_PTR,IN ULONG_PTR,
                                                IN OUT SIZE_T *,IN OUT PVOID,
                                                IN OUT SIZE_T *,IN OUT PVOID);
typedef DWORD (APIENTRY *PFN_DxDdAddAttachedSurface)(IN HANDLE,IN HANDLE,IN OUT PDD_ADDATTACHEDSURFACEDATA);
typedef BOOL  (APIENTRY *PFN_DxDdAttachSurface)(IN HANDLE,IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdBlt)(IN HANDLE,IN HANDLE,IN OUT PDD_BLTDATA);
typedef DWORD (APIENTRY *PFN_DxDdCanCreateSurface)(IN HANDLE,IN OUT PDD_CANCREATESURFACEDATA);
typedef DWORD (APIENTRY *PFN_DxDdColorControl)(IN HANDLE,IN OUT PDD_COLORCONTROLDATA);
typedef HANDLE (APIENTRY *PFN_DxDdCreateDirectDrawObject)(IN HDC);
typedef DWORD (APIENTRY *PFN_DxDdCreateSurface)(IN HANDLE,IN HANDLE*,IN OUT DDSURFACEDESC*,
                                                IN OUT DD_SURFACE_GLOBAL*,IN OUT DD_SURFACE_LOCAL*,
                                                IN OUT DD_SURFACE_MORE*,IN OUT DD_CREATESURFACEDATA*,
                                                OUT HANDLE*);
typedef HANDLE (APIENTRY *PFN_DxDdCreateSurfaceObject)(IN HANDLE,IN HANDLE,IN PDD_SURFACE_LOCAL,
                                                       IN PDD_SURFACE_MORE,IN PDD_SURFACE_GLOBAL, 
                                                       IN BOOL);
typedef BOOL (APIENTRY *PFN_DxDdDeleteSurfaceObject)(IN HANDLE);
typedef BOOL (APIENTRY *PFN_DxDdDeleteDirectDrawObject)(IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdDestroySurface)(IN HANDLE,IN BOOL);
typedef DWORD (APIENTRY *PFN_DxDdFlip)(IN HANDLE,IN HANDLE,IN HANDLE,IN HANDLE,IN OUT PDD_FLIPDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetAvailDriverMemory)(IN HANDLE,IN OUT PDD_GETAVAILDRIVERMEMORYDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetBltStatus)(IN HANDLE,IN OUT PDD_GETBLTSTATUSDATA);
typedef HDC   (APIENTRY *PFN_DxDdGetDC)(IN HANDLE,IN PALETTEENTRY*);
typedef DWORD (APIENTRY *PFN_DxDdGetDriverInfo)(IN HANDLE,IN OUT PDD_GETDRIVERINFODATA);
typedef DWORD (APIENTRY *PFN_DxDdGetFlipStatus)(IN HANDLE,IN OUT PDD_GETFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetScanLine)(IN HANDLE,IN OUT PDD_GETSCANLINEDATA);
typedef DWORD (APIENTRY *PFN_DxDdSetExclusiveMode)(IN HANDLE,IN OUT PDD_SETEXCLUSIVEMODEDATA);
typedef DWORD (APIENTRY *PFN_DxDdFlipToGDISurface)(IN HANDLE,IN OUT PDD_FLIPTOGDISURFACEDATA);
typedef DWORD (APIENTRY *PFN_DxDdLock)(IN HANDLE,IN OUT PDD_LOCKDATA,IN HDC);
typedef BOOL  (APIENTRY *PFN_DxDdQueryDirectDrawObject)(IN HANDLE,IN OUT PDD_HALINFO,IN OUT DWORD*,
                                                        IN OUT LPD3DNTHAL_CALLBACKS,
                                                        IN OUT LPD3DNTHAL_GLOBALDRIVERDATA,
                                                        IN OUT PDD_D3DBUFCALLBACKS,
                                                        IN OUT LPDDSURFACEDESC,
                                                        IN OUT DWORD*, IN OUT VIDEOMEMORY*,
                                                        IN OUT DWORD*, IN OUT DWORD*);
typedef BOOL  (APIENTRY *PFN_DxDdReenableDirectDrawObject)(IN HANDLE,IN OUT BOOL*);
typedef BOOL  (APIENTRY *PFN_DxDdReleaseDC)(IN HANDLE);
typedef BOOL  (APIENTRY *PFN_DxDdResetVisrgn)(IN HANDLE,IN HWND);
typedef DWORD (APIENTRY *PFN_DxDdSetColorKey)(IN HANDLE,IN OUT PDD_SETCOLORKEYDATA);
typedef DWORD (APIENTRY *PFN_DxDdSetOverlayPosition)(IN HANDLE,IN HANDLE,IN OUT PDD_SETOVERLAYPOSITIONDATA);
typedef VOID  (APIENTRY *PFN_DxDdUnattachSurface)(IN HANDLE,IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdUnlock)(IN HANDLE,IN OUT PDD_UNLOCKDATA);
typedef DWORD (APIENTRY *PFN_DxDdUpdateOverlay)(IN HANDLE,IN HANDLE,IN OUT PDD_UPDATEOVERLAYDATA);
typedef DWORD (APIENTRY *PFN_DxDdWaitForVerticalBlank)(IN HANDLE,IN OUT PDD_WAITFORVERTICALBLANKDATA);
typedef HANDLE (APIENTRY *PFN_DxDdGetDxHandle)(IN HANDLE,IN HANDLE,IN BOOL);
typedef BOOL  (APIENTRY *PFN_DxDdSetGammaRamp)(IN HANDLE,IN HDC,IN LPVOID);
typedef DWORD (APIENTRY *PFN_DxDdLockD3D)(IN HANDLE,IN OUT PDD_LOCKDATA);
typedef DWORD (APIENTRY *PFN_DxDdUnlockD3D)(IN HANDLE,IN OUT PDD_UNLOCKDATA);
typedef DWORD (APIENTRY *PFN_DxDdCreateD3DBuffer)(IN HANDLE,IN OUT HANDLE*,
                                                  IN OUT DDSURFACEDESC*,IN OUT DD_SURFACE_GLOBAL*,
                                                  IN OUT DD_SURFACE_LOCAL*,IN OUT DD_SURFACE_MORE*,
                                                  IN OUT DD_CREATESURFACEDATA*,IN OUT HANDLE*);
typedef DWORD (APIENTRY *PFN_DxDdCanCreateD3DBuffer)(IN HANDLE,IN OUT PDD_CANCREATESURFACEDATA);
typedef DWORD (APIENTRY *PFN_DxDdDestroyD3DBuffer)(IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxD3dContextCreate)(IN HANDLE,IN HANDLE,IN HANDLE,IN OUT D3DNTHAL_CONTEXTCREATEI*);
typedef DWORD (APIENTRY *PFN_DxD3dContextDestroy)(IN LPD3DNTHAL_CONTEXTDESTROYDATA);
typedef DWORD (APIENTRY *PFN_DxD3dContextDestroyAll)(OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA);
typedef DWORD (APIENTRY *PFN_DxD3dValidateTextureStageState)(IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (APIENTRY *PFN_DxD3dDrawPrimitives2)(IN HANDLE,IN HANDLE,IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                                                   IN OUT FLATPTR*,IN OUT DWORD*,IN OUT FLATPTR*,IN OUT DWORD*);
typedef DWORD (APIENTRY *PFN_DxDdGetDriverState)(IN OUT PDD_GETDRIVERSTATEDATA);
typedef DWORD (APIENTRY *PFN_DxDdCreateSurfaceEx)(IN HANDLE,IN HANDLE,IN DWORD);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompGuids)(IN HANDLE,IN OUT PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompFormats)(IN HANDLE,IN OUT PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompBuffInfo)(IN HANDLE,IN OUT PDD_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetInternalMoCompInfo)(IN HANDLE,IN OUT PDD_GETINTERNALMOCOMPDATA);
typedef HANDLE (APIENTRY *PFN_DxDdCreateMoComp)(IN HANDLE,IN OUT PDD_CREATEMOCOMPDATA);
typedef DWORD (APIENTRY *PFN_DxDdDestroyMoComp)(IN HANDLE,IN OUT PDD_DESTROYMOCOMPDATA);
typedef DWORD (APIENTRY *PFN_DxDdBeginMoCompFrame)(IN HANDLE,IN OUT PDD_BEGINMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PFN_DxDdEndMoCompFrame)(IN HANDLE,IN OUT PDD_ENDMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PFN_DxDdRenderMoComp)(IN HANDLE,IN OUT PDD_RENDERMOCOMPDATA);
typedef DWORD (APIENTRY *PFN_DxDdQueryMoCompStatus)(IN OUT HANDLE,IN OUT PDD_QUERYMOCOMPSTATUSDATA);
typedef DWORD (APIENTRY *PFN_DxDdAlphaBlt)(IN HANDLE,IN HANDLE,IN OUT PDD_BLTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpCanCreateVideoPort)(IN HANDLE,IN OUT PDD_CANCREATEVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpColorControl)(IN HANDLE,IN OUT PDD_VPORTCOLORDATA);
typedef HANDLE (APIENTRY *PFN_DxDvpCreateVideoPort)(IN HANDLE,IN OUT PDD_CREATEVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpDestroyVideoPort)(IN HANDLE,IN OUT PDD_DESTROYVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpFlipVideoPort)(IN HANDLE,IN HANDLE,IN HANDLE,IN OUT PDD_FLIPVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortBandwidth)(IN HANDLE,IN OUT PDD_GETVPORTBANDWIDTHDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortField)(IN HANDLE,IN OUT PDD_GETVPORTFIELDDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortFlipStatus)(IN HANDLE,IN OUT PDD_GETVPORTFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortInputFormats)(IN HANDLE,IN OUT PDD_GETVPORTINPUTFORMATDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortLine)(IN HANDLE,IN OUT PDD_GETVPORTLINEDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortOutputFormats)(IN HANDLE,IN OUT PDD_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortConnectInfo)(IN HANDLE,IN OUT PDD_GETVPORTCONNECTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoSignalStatus)(IN HANDLE,IN OUT PDD_GETVPORTSIGNALDATA);
typedef DWORD (APIENTRY *PFN_DxDvpUpdateVideoPort)(IN HANDLE,IN HANDLE*,IN HANDLE*,IN OUT PDD_UPDATEVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpWaitForVideoPortSync)(IN HANDLE,IN OUT PDD_WAITFORVPORTSYNCDATA);
typedef DWORD (APIENTRY *PFN_DxDvpAcquireNotification)(IN HANDLE,IN OUT HANDLE*,IN OUT LPDDVIDEOPORTNOTIFY pNotify);
typedef DWORD (APIENTRY *PFN_DxDvpReleaseNotification)(IN HANDLE,IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompGuids)(IN HANDLE,IN OUT PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompFormats)(IN HANDLE,IN OUT PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompBuffInfo)(IN HANDLE,IN OUT PDD_GETMOCOMPCOMPBUFFDATA);
typedef FLATPTR (WINAPI *PFN_DxDdHeapVidMemAllocAligned)(LPVIDMEM,DWORD,DWORD,LPSURFACEALIGNMENT,LPLONG);
typedef VOID    (WINAPI *PFN_DxDdHeapVidMemFree)(LPVMEMHEAP,FLATPTR);
typedef BOOL  (*PFN_DxDdEnableDirectDraw)(HDEV,BOOL);
typedef VOID  (*PFN_DxDdDisableDirectDraw)(HDEV,BOOL);
typedef VOID  (*PFN_DxDdSuspendDirectDraw)(HDEV,ULONG);
typedef VOID  (*PFN_DxDdResumeDirectDraw)(HDEV,ULONG);
typedef VOID  (*PFN_DxDdDynamicModeChange)(HDEV,HDEV,ULONG);
typedef VOID  (*PFN_DxDdCloseProcess)(W32PID);
typedef BOOL  (*PFN_DxDdGetDirectDrawBounds)(HDEV,RECT*);
typedef BOOL  (*PFN_DxDdEnableDirectDrawRedirection)(HDEV,BOOL);
typedef PVOID (*PFN_DxDdAllocPrivateUserMem)(PDD_SURFACE_LOCAL,SIZE_T,ULONG);
typedef VOID  (*PFN_DxDdFreePrivateUserMem)(PDD_SURFACE_LOCAL,PVOID);
typedef PDD_SURFACE_LOCAL (*PFN_DxDdLockDirectDrawSurface)(HANDLE);
typedef BOOL  (*PFN_DxDdUnlockDirectDrawSurface)(PDD_SURFACE_LOCAL);
typedef VOID  (*PFN_DxDdSetAccelLevel)(HDEV,DWORD,DWORD);
typedef DWORD (*PFN_DxDdGetSurfaceLock)(HDEV);
typedef PVOID (*PFN_DxDdEnumLockedSurfaceRect)(HDEV,PVOID,RECTL*);
typedef HRESULT (*PFN_DxDdIoctl)(ULONG,PVOID,ULONG);

//
// The functions definiton which import from win32k.sys
//
// Functions for global win32k.sys status.
//

#define INDEX_DxEngUnused                         0
#define INDEX_DxEngIsTermSrv                      1
#define INDEX_DxEngScreenAccessCheck              2
#define INDEX_DxEngRedrawDesktop                  3
#define INDEX_DxEngDispUniq                       4
#define INDEX_DxEngIncDispUniq                    5
#define INDEX_DxEngVisRgnUniq                     6
#define INDEX_DxEngLockShareSem                   7
#define INDEX_DxEngUnlockShareSem                 8
#define INDEX_DxEngEnumerateHdev                  9
#define INDEX_DxEngLockHdev                      10
#define INDEX_DxEngUnlockHdev                    11
#define INDEX_DxEngIsHdevLockedByCurrentThread   12
#define INDEX_DxEngReferenceHdev                 13
#define INDEX_DxEngUnreferenceHdev               14
#define INDEX_DxEngGetDeviceGammaRamp            15
#define INDEX_DxEngSetDeviceGammaRamp            16
#define INDEX_DxEngSpTearDownSprites             17
#define INDEX_DxEngSpUnTearDownSprites           18
#define INDEX_DxEngSpSpritesVisible              19
#define INDEX_DxEngGetHdevData                   20
#define INDEX_DxEngSetHdevData                   21
#define INDEX_DxEngCreateMemoryDC                22
#define INDEX_DxEngGetDesktopDC                  23
#define INDEX_DxEngDeleteDC                      24
#define INDEX_DxEngCleanDC                       25
#define INDEX_DxEngSetDCOwner                    26
#define INDEX_DxEngLockDC                        27
#define INDEX_DxEngUnlockDC                      28
#define INDEX_DxEngSetDCState                    29
#define INDEX_DxEngGetDCState                    30
#define INDEX_DxEngSelectBitmap                  31
#define INDEX_DxEngSetBitmapOwner                32
#define INDEX_DxEngDeleteSurface                 33
#define INDEX_DxEngGetSurfaceData                34
#define INDEX_DxEngAltLockSurface                35
#define INDEX_DxEngUploadPaletteEntryToSurface   36
#define INDEX_DxEngMarkSurfaceAsDirectDraw       37
#define INDEX_DxEngSelectPaletteToSurface        38
#define INDEX_DxEngSyncPaletteTableWithDevice    39
#define INDEX_DxEngSetPaletteState               40
#define INDEX_DxEngGetRedirectionBitmap          41
#define INDEX_DxEngLoadImage                     42

#define INDEX_WIN32K_TABLE_SIZE                  43

// DxEngSetHdevData()

#define HDEV_SURFACEHANDLE         0  // Get only
#define HDEV_MINIPORTHANDLE        1  // Get only
#define HDEV_DITHERFORMAT          2  // Get only
#define HDEV_GCAPS                 3
#define HDEV_GCAPS2                4
#define HDEV_FUNCTIONTABLE         5  // Get only
#define HDEV_DHPDEV                6  // Get only
#define HDEV_DXDATA                7
#define HDEV_DXLOCKS               8
#define HDEV_CAPSOVERRIDE          9  // Get only
#define HDEV_DISABLED             10
#define HDEV_DDML                 11  // Get only
#define HDEV_DISPLAY              12  // Get only
#define HDEV_PARENTHDEV           13  // Get only
#define HDEV_DELETED              14  // Get only
#define HDEV_PALMANAGED           15  // Get only
#define HDEV_LDEV                 16  // Get only
#define HDEV_GRAPHICSDEVICE       17  // Get only
#define HDEV_CLONE                18  // Get only

// DxEngGetDCState()

#define DCSTATE_FULLSCREEN         1
#define DCSTATE_VISRGNCOMPLEX      2 // Get only
#define DCSTATE_HDEV               3 // Get only

// DxEngGetSurfaceData()

#define SURF_HOOKFLAGS              1
#define SURF_IS_DIRECTDRAW_SURFACE  2
#define SURF_DD_SURFACE_HANDLE      3

// DxEngSetPaletteState()

#define PALSTATE_DIBSECTION        1

#ifdef DXG_BUILD // ONLY TRUE WHEN BUILD DXG.SYS.

//
// Stub routines to call Win32k.sys
//

extern DRVFN *gpEngFuncs;

typedef BOOL (*PFN_DxEngIsTermSrv)(VOID);
typedef BOOL (*PFN_DxEngScreenAccessCheck)(VOID);
typedef BOOL (*PFN_DxEngRedrawDesktop)(VOID);
typedef ULONG (*PFN_DxEngDispUniq)(VOID);
typedef BOOL (*PFN_DxEngIncDispUniq)(VOID);
typedef ULONG (*PFN_DxEngVisRgnUniq)(VOID);
typedef BOOL (*PFN_DxEngLockShareSem)(VOID);
typedef BOOL (*PFN_DxEngUnlockShareSem)(VOID);
typedef HDEV (*PFN_DxEngEnumerateHdev)(HDEV);
typedef BOOL (*PFN_DxEngLockHdev)(HDEV);
typedef BOOL (*PFN_DxEngUnlockHdev)(HDEV);
typedef BOOL (*PFN_DxEngIsHdevLockedByCurrentThread)(HDEV);
typedef BOOL (*PFN_DxEngReferenceHdev)(HDEV);
typedef BOOL (*PFN_DxEngUnreferenceHdev)(HDEV);
typedef BOOL (*PFN_DxEngGetDeviceGammaRamp)(HDEV,PVOID);
typedef BOOL (*PFN_DxEngSetDeviceGammaRamp)(HDEV,PVOID,BOOL);
typedef BOOL (*PFN_DxEngSpTearDownSprites)(HDEV,RECTL*,BOOL);
typedef BOOL (*PFN_DxEngSpUnTearDownSprites)(HDEV,RECTL*,BOOL);
typedef BOOL (*PFN_DxEngSpSpritesVisible)(HDEV);
typedef ULONG_PTR (*PFN_DxEngGetHdevData)(HDEV,DWORD);
typedef BOOL (*PFN_DxEngSetHdevData)(HDEV,DWORD,ULONG_PTR);
typedef HDC  (*PFN_DxEngCreateMemoryDC)(HDEV);
typedef HDC  (*PFN_DxEngGetDesktopDC)(ULONG,BOOL,BOOL);
typedef BOOL (*PFN_DxEngDeleteDC)(HDC,BOOL);
typedef BOOL (*PFN_DxEngCleanDC)(HDC);
typedef BOOL (*PFN_DxEngSetDCOwner)(HDC,W32PID);
typedef PVOID (*PFN_DxEngLockDC)(HDC);
typedef BOOL (*PFN_DxEngUnlockDC)(PVOID);
typedef BOOL (*PFN_DxEngSetDCState)(HDC,DWORD,ULONG_PTR);
typedef ULONG_PTR (*PFN_DxEngGetDCState)(HDC,DWORD);
typedef HBITMAP (*PFN_DxEngSelectBitmap)(HDC,HBITMAP);
typedef BOOL (*PFN_DxEngSetBitmapOwner)(HBITMAP,W32PID);
typedef BOOL (*PFN_DxEngDeleteSurface)(HSURF hsurf);
typedef ULONG_PTR (*PFN_DxEngGetSurfaceData)(SURFOBJ*,DWORD);
typedef SURFOBJ* (*PFN_DxEngAltLockSurface)(HBITMAP);
typedef BOOL (*PFN_DxEngUploadPaletteEntryToSurface)(HDEV,SURFOBJ*,PALETTEENTRY*,ULONG);
typedef BOOL (*PFN_DxEngMarkSurfaceAsDirectDraw)(SURFOBJ*,HANDLE);
typedef HPALETTE (*PFN_DxEngSelectPaletteToSurface)(SURFOBJ*,HPALETTE);
typedef BOOL (*PFN_DxEngSyncPaletteTableWithDevice)(HPALETTE,HDEV);
typedef BOOL (*PFN_DxEngSetPaletteState)(HPALETTE,DWORD,ULONG_PTR);
typedef HBITMAP (*PFN_DxEngGetRedirectionBitmap)(HWND);
typedef HANDLE (*PFN_DxEngLoadImage)(LPWSTR,BOOL);

#define PPFNGET_DXENG(name)        ((PFN_DxEng##name)((gpEngFuncs[INDEX_DxEng##name]).pfn))
#define CALL_DXENG(name)           (*(PPFNGET_DXENG(name)))

#define DxEngIsTermSrv()           ((BOOL)(CALL_DXENG(IsTermSrv)()))
#define DxEngScreenAccessCheck()   ((BOOL)(CALL_DXENG(ScreenAccessCheck)()))
#define DxEngRedrawDesktop()       ((BOOL)(CALL_DXENG(RedrawDesktop)()))

#define DxEngDispUniq()            ((ULONG)(CALL_DXENG(DxEngDispUniq)()))
#define DxEngIncDispUniq()         ((BOOL)(CALL_DXENG(IncDispUniq)()))
#define DxEngVisRgnUniq()          ((ULONG)(CALL_DXENG(VisRgnUniq)()))

#define DxEngLockShareSem()        ((BOOL)(CALL_DXENG(LockShareSem)()))
#define DxEngUnlockShareSem()      ((BOOL)(CALL_DXENG(UnlockShareSem)()))

#define DxEngEnumerateHdev(hdev)   ((HDEV)(CALL_DXENG(EnumerateHdev)(hdev)))

#define DxEngLockHdev(hdev)        ((BOOL)(CALL_DXENG(LockHdev)(hdev)))
#define DxEngUnlockHdev(hdev)      ((BOOL)(CALL_DXENG(UnlockHdev)(hdev)))

#define DxEngIsHdevLockedByCurrentThread(hdev) \
                                   ((BOOL)(CALL_DXENG(IsHdevLockedByCurrentThread)(hdev)))

#define DxEngReferenceHdev(hdev)   ((BOOL)(CALL_DXENG(ReferenceHdev)(hdev)))
#define DxEngUnreferenceHdev(hdev) ((BOOL)(CALL_DXENG(UnreferenceHdev)(hdev)))

#define DxEngGetHdevData(hdev,dwIndex) \
                                   ((ULONG_PTR)(CALL_DXENG(GetHdevData)(hdev,dwIndex)))
#define DxEngSetHdevData(hdev,dwIndex,pData) \
                                   ((BOOL)(CALL_DXENG(SetHdevData)(hdev,dwIndex,pData)))

#define DxEngCreateMemoryDC(hdev)  ((HDC)(CALL_DXENG(CreateMemoryDC)(hdev)))
#define DxEngGetDesktopDC(ulType,bAltType,bValidate) \
                                   ((HDC)(CALL_DXENG(GetDesktopDC)(ulType,bAltType,bValidate)))
#define DxEngDeleteDC(hdc,bForce)  ((BOOL)(CALL_DXENG(DeleteDC)(hdc,bForce)))
#define DxEngCleanDC(hdc)          ((BOOL)(CALL_DXENG(CleanDC)(hdc)))

#define DxEngSetDCOwner(hdc,pidOwner) \
                                   ((BOOL)(CALL_DXENG(SetDCOwner)(hdc,pidOwner)))

#define DxEngLockDC(hdc)           ((PVOID)(CALL_DXENG(LockDC)(hdc)))
#define DxEngUnlockDC(pvLockedDC)  ((BOOL)(CALL_DXENG(UnlockDC)(pvLockedDC)))

#define DxEngSetDCState(hdc,dwState,ulData) \
                                   ((BOOL)(CALL_DXENG(SetDCState)(hdc,dwState,ulData)))
#define DxEngGetDCState(hdc,dwState) \
                                   ((ULONG_PTR)(CALL_DXENG(GetDCState)(hdc,dwState)))

#define DxEngSelectBitmap(hdc,hbm) ((HBITMAP)(CALL_DXENG(SelectBitmap)(hdc,hbm)))
#define DxEngSetBitmapOwner(hbm,pidOwner) \
                                   ((BOOL)(CALL_DXENG(SetBitmapOwner)(hbm,pidOwner)))
#define DxEngDeleteSurface(hsurf)  ((BOOL)(CALL_DXENG(DeleteSurface)(hsurf)))
#define DxEngGetSurfaceData(pso,dwIndex) \
                                   ((ULONG_PTR)(CALL_DXENG(GetSurfaceData)(pso,dwIndex)))
#define DxEngAltLockSurface(hsurf) ((SURFOBJ*)(CALL_DXENG(AltLockSurface)(hsurf)))
#define DxEngUploadPaletteEntryToSurface(hdev,pso,puColorTable,cColors) \
                                   ((BOOL)(CALL_DXENG(UploadPaletteEntryToSurface)(hdev,pso,puColorTable,cColors)))
#define DxEngMarkSurfaceAsDirectDraw(pso,hDdSurf) \
                                   ((BOOL)(CALL_DXENG(MarkSurfaceAsDirectDraw)(pso,hDdSurf)))
#define DxEngSelectPaletteToSurface(pso,hpal) \
                                   ((HPALETTE)(CALL_DXENG(SelectPaletteToSurface)(pso,hpal)))

#define DxEngGetDeviceGammaRamp(hdev,pv) \
                                   ((BOOL)(CALL_DXENG(GetDeviceGammaRamp)(hdev,pv)))
#define DxEngSetDeviceGammaRamp(hdev,pv,b) \
                                   ((BOOL)(CALL_DXENG(SetDeviceGammaRamp)(hdev,pv,b)))

#define DxEngSpTearDownSprites(hdev,prcl,b) \
                                   ((BOOL)(CALL_DXENG(SpTearDownSprites)(hdev,prcl,b)))
#define DxEngSpUnTearDownSprites(hdev,prcl,b) \
                                   ((BOOL)(CALL_DXENG(SpUnTearDownSprites)(hdev,prcl,b)))
#define DxEngSpSpritesVisible(hdev) \
                                   ((BOOL)(CALL_DXENG(SpSpritesVisible)(hdev)))

#define DxEngSetPaletteState(hpal,dwIndex,ulData) \
                                   ((BOOL)(CALL_DXENG(SetPaletteState)(hpal,dwIndex,ulData)))
#define DxEngSyncPaletteTableWithDevice(hpal,hdev) \
                                   ((BOOL)(CALL_DXENG(SyncPaletteTableWithDevice)(hpal,hdev)))

#define DxEngGetRedirectionBitmap(hWnd) \
                                   ((HBITMAP)(CALL_DXENG(GetRedirectionBitmap)(hWnd)))
#define DxEngLoadImage(pwszDriver, bLoadInSessionSpace) \
                                   ((HANDLE)(CALL_DXENG(LoadImage)(pwszDriver,bLoadInSessionSpace)))

#else // DXG_BUILD

//
// Prototype definitions for function body in win32k.sys
//

BOOL   DxEngIsTermSrv(
       VOID
       );

BOOL   DxEngScreenAccessCheck(
       VOID
       );

BOOL   DxEngRedrawDesktop(
       VOID
       );

ULONG  DxEngDispUniq(
       VOID
       );

BOOL   DxEngIncDispUniq(
       VOID
       );

ULONG  DxEngVisRgnUniq(
       VOID
       );

BOOL   DxEngLockShareSem(
       VOID
       );

BOOL   DxEngUnlockShareSem(
       VOID
       );

HDEV   DxEngEnumerateHdev(
       HDEV hdev
       );

// Functions for control HDEV status.

BOOL   DxEngLockHdev(
       HDEV hdev
       );

BOOL   DxEngUnlockHdev(
       HDEV hdev
       );

BOOL   DxEngIsHdevLockedByCurrentThread(
       HDEV hdev
       );

BOOL   DxEngReferenceHdev(
       HDEV hdev
       );

BOOL   DxEngUnreferenceHdev(
       HDEV hdev
       );

BOOL   DxEngGetDeviceGammaRamp(
       HDEV  hdev,
       PVOID pv
       );

BOOL   DxEngSetDeviceGammaRamp(
       HDEV  hdev,
       PVOID pv,
       BOOL  b
       );

BOOL   DxEngSpTearDownSprites(
       HDEV   hdev,
       RECTL* prcl,
       BOOL   b
       );

BOOL   DxEngSpUnTearDownSprites(
       HDEV   hdev,
       RECTL* prcl,
       BOOL   b
       );

BOOL   DxEngSpSpritesVisible(
       HDEV   hdev
       );

ULONG_PTR DxEngGetHdevData(
          HDEV  hdev,
          DWORD dwIndex
          );

BOOL DxEngSetHdevData(
     HDEV  hdev,
     DWORD dwIndex,
     ULONG_PTR ulData
     );

// Functions for control DC

HDC  DxEngCreateMemoryDC(
     HDEV hdev
     );

HDC  DxEngGetDesktopDC(
     ULONG ulType,
     BOOL  bAltType,
     BOOL bValidate
     );

BOOL DxEngDeleteDC(
     HDC  hdc,
     BOOL bForce
     );

BOOL DxEngCleanDC(
     HDC hdc
     );

BOOL DxEngSetDCOwner(
     HDC    hdc,
     W32PID pidOwner
     );

PVOID DxEngLockDC(
     HDC hdc
     );

BOOL DxEngUnlockDC(
     PVOID pvLockedDC
     );

BOOL DxEngSetDCState(
     HDC   hdc,
     DWORD dwState,
     ULONG_PTR ulData
     );

ULONG_PTR DxEngGetDCState(
     HDC   hdc,
     DWORD dwState
     );

// Functions for control Bitmap/Surface

HBITMAP DxEngSelectBitmap(
        HDC     hdc,
        HBITMAP hbm
        );

BOOL DxEngSetBitmapOwner(
     HBITMAP hbm,
     W32PID  pidOwner
     );

BOOL DxEngDeleteSurface(
     HSURF hsurf
     );

ULONG_PTR DxEngGetSurfaceData(
     SURFOBJ* pso,
     DWORD dwIndex);

SURFOBJ *DxEngAltLockSurface(
     HBITMAP hSurf);

BOOL DxEngUploadPaletteEntryToSurface(
     HDEV     hdev,
     SURFOBJ* pso,
     PALETTEENTRY* puColorTable,
     ULONG         cColors
     );

BOOL DxEngMarkSurfaceAsDirectDraw(
     SURFOBJ* pso,
     HANDLE   hDdSurf
     );

HPALETTE DxEngSelectPaletteToSurface(
         SURFOBJ* pso,
         HPALETTE hpal
         );

// Functions for control palette

BOOL DxEngSyncPaletteTableWithDevice(
     HPALETTE hpal,
     HDEV     hdev
     );

BOOL DxEngSetPaletteState(
     HPALETTE  hpal,
     DWORD     dwIndex,
     ULONG_PTR ulData
     );

#define PALSTATE_DIBSECTION        1

// Functions for window handle

HBITMAP DxEngGetRedirectionBitmap(
        HWND hWnd
        );

// Functions to load image file

HANDLE DxEngLoadImage(
       LPWSTR pwszDriver,
       BOOL   bLoadInSessionSpace
       );

#endif // DXG_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\kmode\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\kmode\guids.c ===
//depot/Lab04_N/Windows/Core/kmode/guids.c#1 - branch change 9 (text)
/******************************Module*Header*******************************\
* Module Name: guids.c
*
* This file contains the actual data declarations for all GUIDs used by USER
*
* 1998-10-12 Ian James  Created
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
\**************************************************************************/


/*
 * Core NT headers
 */
#include <initguid.h>

#include <ntosp.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddstor.h>
#include <wdmguid.h>
#include <devguid.h>
#include <ioevent.h>
#include <hidusage.h>
#include <hidpi.h>
#include <hidclass.h>
#include <wmidata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\kmode\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\kmode\sources.inc ===
!include $(WINCORE_PATH)\core.inc

MAJORCOMP=ntos
MINORCOMP=w32

SYNCHRONIZE_BLOCK=1

TARGETNAME=win32k
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=EXPORT_DRIVER

PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(DDK_LIB_DEST)\$(DYNLINK_LIBDIR)}

INCLUDES=$(WINCORE_PATH)\w32inc;                    \
         $(WINCORE_PATH)\w32inc\$(O);               \
         $(NTUSER_PATH)\kernel\$(ALT_PROJECT)\$(O); \
         $(NTUSER_PATH)\kernel\$(ALT_PROJECT);      \
         $(BASE_INC_PATH)

SYNCHRONIZE_DRAIN=1

NT_UP=0

TARGETLIBS= \
         $(NTUSER_PATH)\kernel\$(ALT_PROJECT)\$(O)\userk.lib                  \
         $(NTGDI_PATH)\gre\$(ALT_PROJECT)\$(O)\gre.lib                        \
         $(NTGDI_PATH)\fondrv\tt\scaler\$(O)\fscaler.lib                      \
         $(NTGDI_PATH)\fondrv\tt\ttfd\$(ALT_PROJECT)\$(O)\ttfd.lib            \
         $(NTGDI_PATH)\fondrv\bmfd\$(O)\bmfd.lib                              \
         $(NTGDI_PATH)\fondrv\vtfd\$(O)\vtfd.lib                              \
         $(NTGDI_PATH)\math\$(ALT_PROJECT)\$(O)\efloat.lib                    \
         $(NTGDI_PATH)\halftone\ht\$(O)\halftone.lib                          \
         $(SDK_LIB_PATH)\advapi32.lib                                         \
         $(NTUSER_PATH)\rtl\kernel\$(ALT_PROJECT)\$(O)\userkrtl.lib           \
         $(DDK_LIB_PATH)\videoprt.lib                                         \
         $(DRIVERS_LIB_PATH)\watchdog.lib

#
# WARNING: Do not remove the dxapi.lib below which makes win32k.sys statically
# link to dxapi.sys. This is because dxapi.sys has got VPE/WDM code which
# video miniports can also link to whoes lifetimes we cant control in win3k.sys
# Hence we link with it statically and get refcount for us so its lifetime is
# bounded by win32k.sys's lifetime.
#

LINKLIBS=$(LINKLIBS)                                                          \
	 $(DDK_LIB_PATH)\dxapi.lib                                            \
         $(DDK_LIB_PATH)\ntoskrnl.lib                                         \
         $(DDK_LIB_PATH)\hal.lib                                              \
         $(NTGDI_PATH)\halftone\ht\$(O)\halftone.lib                          \
         $(NTGDI_PATH)\gre\$(ALT_PROJECT)\$(O)\gre.lib                        \
         $(WINCORE_PATH)\rtl\kernel\$(O)\w32krtl.lib

SOURCES=..\w32init.c \
        ..\guids.c \
        w32rc.rc

DLLDEF=$(O)\win32k.def
DLLORDER=..\$(TARGETNAME).prf

NTTARGETFILE0=$(O)\services.tab

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc

DLLLIBOBJECTS=$(DLLLIBOBJECTS) \
!if $(386)
	 $(BASE_LIB_PATH)\sehprolg.obj \
	 $(BASE_LIB_PATH)\loadcfg.obj \
	 $(BASE_LIB_PATH)\seccook.obj \
!elseif $(IA64)
         $(BASE_LIB_PATH)\_memcpy.obj \
         $(BASE_LIB_PATH)\_memmove.obj \
         $(BASE_LIB_PATH)\_memset.obj \
!endif
         $(NTGDI_PATH)\gre\$(ALT_PROJECT)\$(O)\guids.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\kmode\makefile.inc ===
SERVICES_DIR=$(O)
SERVICES_TAB=$(SERVICES_DIR)\services.tab

!if $(IA64)
LINK_LIB_IGNORE_FLAG=$(LINK_LIB_IGNORE_FLAG),4210
!endif


$(SERVICES_TAB): ..\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\systable.obj: $(O)\systable.$(ASM_SUFFIX)

$(O)\systable.$(ASM_SUFFIX): $(SERVICES_TAB) ..\$(TARGET_DIRECTORY)\table.stb ..\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) -g $(SERVICES_DIR) $(TARGET_BRACES) -C -R -s ..\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\kmode\w32init.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    w32init.c

Abstract:

    This is the Win32 subsystem driver initializatiion module

Author:

    Mark Lucovsky (markl) 31-Oct-1994


Revision History:

--*/

#include "ntosp.h"
#define DO_INLINE
#include "w32p.h"
#include "windef.h"
#include "wingdi.h"
#include "winerror.h"
#include "winddi.h"
#include "usergdi.h"
#include "w32err.h"

/*
 * Globals declared and initialized in ntuser\kernel\init.c
 */
extern CONST ULONG W32ProcessSize;
extern CONST ULONG W32ProcessTag;
extern CONST ULONG W32ThreadSize;
extern CONST ULONG W32ThreadTag;
extern PFAST_MUTEX gpW32FastMutex;

__inline VOID
ReferenceW32Process(
    IN PW32PROCESS pW32Process)
{
    PEPROCESS pEProcess = pW32Process->Process;

    UserAssert(pEProcess != NULL);
    ObReferenceObject(pEProcess);

    UserAssert(pW32Process->RefCount < MAXULONG);
    InterlockedIncrement(&pW32Process->RefCount);
}

VOID
DereferenceW32Process(
    IN PW32PROCESS pW32Process)
{
    PEPROCESS pEProcess = pW32Process->Process;

    /*
     * Dereference the object. It'll get freed when ref count goes to zero.
     */
    UserAssert(pW32Process->RefCount > 0);
    if (InterlockedDecrement(&pW32Process->RefCount) == 0) {
        UserDeleteW32Process(pW32Process);
    }

    /*
     * Dereference the kernel object.
     */
    UserAssert(pEProcess != NULL);
    ObDereferenceObject(pEProcess);
}

VOID
LockW32Process(
    IN PW32PROCESS pW32Process,
    IN OUT PTL ptl)
{
    PushW32ThreadLock(pW32Process, ptl, DereferenceW32Process);
    if (pW32Process != NULL) {
        ReferenceW32Process(pW32Process);
    }
}

NTSTATUS
AllocateW32Process(
    IN OUT PEPROCESS pEProcess)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PW32PROCESS pW32Process;

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpW32FastMutex);

    /*
     * Allocate the process object if we haven't already done so.
     */
    if ((pW32Process = PsGetProcessWin32Process(pEProcess)) == NULL) {
        pW32Process = Win32AllocPoolWithQuota(W32ProcessSize, W32ProcessTag);
        if (pW32Process) {
            RtlZeroMemory(pW32Process, W32ProcessSize);
            pW32Process->Process = pEProcess;
            Status = PsSetProcessWin32Process(pEProcess, pW32Process, NULL);
            if (NT_SUCCESS(Status)) {
                ReferenceW32Process(pW32Process);
            } else {
                NtCurrentTeb()->LastErrorValue = ERROR_ACCESS_DENIED;
                Win32FreePool(pW32Process);
            }
        } else {
            NtCurrentTeb()->LastErrorValue = ERROR_NOT_ENOUGH_MEMORY;
            Status = STATUS_NO_MEMORY;
        }
    }

    ExReleaseFastMutexUnsafe(gpW32FastMutex);
    KeLeaveCriticalRegion();

    return Status;
}

extern PEPROCESS gpepCSRSS;

__inline VOID
FreeW32Process(
    IN OUT PW32PROCESS pW32Process)
{
    ASSERT(pW32Process == W32GetCurrentProcess());
    ASSERT(pW32Process != NULL);

    /*
     * Dereference the object. It'll get freed when ref count goes to zero.
     */
    DereferenceW32Process(pW32Process);
}

NTSTATUS
W32pProcessCallout(
    IN PEPROCESS Process,
    IN BOOLEAN Initialize)

/*++

Routine Description:

    This function is called whenever a Win32 process is created or deleted.
    Creattion occurs when the calling process calls NtConvertToGuiThread.

    Deletion occurs during PspExitthread processing for the last thread in
    a process.

Arguments:

    Process - Supplies the address of the W32PROCESS to initialize.

    Initialize - Supplies a boolean value that is true if the process
                 is being created.

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    PW32PROCESS pW32Process;

    if (Initialize) {
        Status = AllocateW32Process(Process);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        pW32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
        pW32Process->W32Pid = W32GetCurrentPID();
    } else {
        pW32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
    }

    TAGMSG3(DBGTAG_Callout,
            "W32: Process Callout for W32P %#p EP %#p called for %s",
            pW32Process,
            Process,
            Initialize ? "Creation" : "Deletion");

    Status = xxxUserProcessCallout(pW32Process, Initialize);
    if (Status == STATUS_ALREADY_WIN32) {
        return Status;
    }

    /*
     * Always call GDI at cleanup time. If GDI initialiatzion fails,
     * call USER for cleanup.
     */
    if (NT_SUCCESS(Status) || !Initialize) {
        Status = GdiProcessCallout(pW32Process, Initialize);
        if (!NT_SUCCESS(Status) && Initialize) {
            xxxUserProcessCallout(pW32Process, FALSE);
        }
    }

    /*
     * If this is not an initialization or initialization failed, free the
     * W32 process structure.
     */
    if (!Initialize || !NT_SUCCESS(Status)) {
        FreeW32Process(pW32Process);
    }

    return Status;
}


__inline VOID
ReferenceW32Thread(
    IN PW32THREAD pW32Thread)
{
    PETHREAD pEThread = pW32Thread->pEThread;

    UserAssert(pEThread != NULL);
    ObReferenceObject(pEThread);

    UserAssert(pW32Thread->RefCount < MAXULONG);
    InterlockedIncrement(&pW32Thread->RefCount);
}

VOID
DereferenceW32Thread(
    IN PW32THREAD pW32Thread)
{
    PETHREAD pEThread = pW32Thread->pEThread;

    /*
     * Dereference the object. It'll get freed when ref count goes to zero.
     */
    UserAssert(pW32Thread->RefCount > 0);
    if (InterlockedDecrement(&pW32Thread->RefCount) == 0) {
        UserDeleteW32Thread(pW32Thread);
    }

    /*
     * Dereference the kernel object.
     */
    UserAssert(pEThread != NULL);
    ObDereferenceObject(pEThread);
}

VOID
LockW32Thread(
    IN PW32THREAD pW32Thread,
    IN OUT PTL ptl)
{
    PushW32ThreadLock(pW32Thread, ptl, DereferenceW32Thread);
    if (pW32Thread != NULL) {
        ReferenceW32Thread(pW32Thread);
    }
}

VOID
LockExchangeW32Thread(
    IN PW32THREAD pW32Thread,
    IN OUT PTL ptl)
{
    if (pW32Thread != NULL) {
        ReferenceW32Thread(pW32Thread);
    }

    ExchangeW32ThreadLock(pW32Thread, ptl);
}

NTSTATUS
AllocateW32Thread(
    IN OUT PETHREAD pEThread)
{
    PW32THREAD pW32Thread;

    UserAssert(pEThread == PsGetCurrentThread());

    pW32Thread = Win32AllocPoolWithQuota(W32ThreadSize, W32ThreadTag);
    if (pW32Thread) {
        RtlZeroMemory(pW32Thread, W32ThreadSize);
        pW32Thread->pEThread = pEThread;
        PsSetThreadWin32Thread(pEThread, pW32Thread, NULL);
        ReferenceW32Thread(pW32Thread);
        return STATUS_SUCCESS;
    }

    return STATUS_NO_MEMORY;
}

VOID
CleanupW32ThreadLocks(
    IN PW32THREAD pW32Thread)
{
    PTL ptl;

    while (ptl = pW32Thread->ptlW32) {
        PopAndFreeW32ThreadLock(ptl);
    }
}

NTSTATUS
W32pThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType)

/*++

Routine Description:

    This function is called whenever a Win32 Thread is initialized,
    exited or deleted.

    Initialization occurs when the calling thread calls NtConvertToGuiThread.

    Exit occurs during PspExitthread processing and deletion during
    PspThreadDelete processing.

Arguments:

    Thread - Supplies the address of the ETHREAD object

    CalloutType - Supplies the callout type


Return Value:

    TBD

--*/

{
    NTSTATUS Status;

    TAGMSG2(DBGTAG_Callout,
            "W32: Thread Callout for ETHREAD %x called for %s\n",
            pEThread,
            CalloutType == PsW32ThreadCalloutInitialize ? "Initialization" :
            CalloutType == PsW32ThreadCalloutExit ? "Exit" : "Deletion");
    TAGMSG2(DBGTAG_Callout,
            "                              PID = %x   TID = %x\n",
            PsGetThreadProcessId(pEThread),
            PsGetThreadId(pEThread));

    if (CalloutType == PsW32ThreadCalloutInitialize) {
        Status = AllocateW32Thread(pEThread);
        if (!NT_SUCCESS(Status)) {
            NtCurrentTeb()->LastErrorValue = ERROR_NOT_ENOUGH_MEMORY;
            return Status;
        }
    }

   /*
    * If CalloutType == PsW32ThreadCalloutInitialize, assuming that:
    *  - GdiThreadCallout never fails.
    *  - If UserThreadCallout fails, there is no need to call
    *    GdiThreadCallout for clean up.
    */
    GdiThreadCallout(pEThread, CalloutType);

    Status = UserThreadCallout(pEThread, CalloutType);

    if (CalloutType == PsW32ThreadCalloutExit || !NT_SUCCESS(Status)) {
        FreeW32Thread(pEThread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\convdm.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    This module contains the console API for MVDM.

Author:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

BOOL
APIENTRY
VDMConsoleOperation(
    DWORD  iFunction,
    LPVOID lpData
    )

/*++

Parameters:

    iFunction - Function Index.
    VDM_HIDE_WINDOW

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_VDM_MSG a = &m.u.VDMConsoleOperation;
    LPRECT lpRect;
    LPPOINT lpPoint;
    PBOOL lpBool;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->iFunction = iFunction;
    if (iFunction == VDM_CLIENT_TO_SCREEN ||
        iFunction == VDM_SCREEN_TO_CLIENT) {
        lpPoint = (LPPOINT)lpData;
        a->Point = *lpPoint;
    } else if (iFunction == VDM_FULLSCREEN_NOPAINT) {
        a->Bool = (lpData != NULL);
    }
#if defined(FE_SB)
    else if (iFunction == VDM_SET_VIDEO_MODE) {
        a->Bool = (lpData != NULL);
    }
#endif // FE_SB
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                         ConsolepVDMOperation
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        switch (iFunction) {
            case VDM_IS_ICONIC:
            case VDM_IS_HIDDEN:
                lpBool = (PBOOL)lpData;
                *lpBool = a->Bool;
                break;
            case VDM_CLIENT_RECT:
                lpRect = (LPRECT)lpData;
                *lpRect = a->Rect;
                break;
            case VDM_CLIENT_TO_SCREEN:
            case VDM_SCREEN_TO_CLIENT:
                *lpPoint = a->Point;
                break;
            default:
                break;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\condll.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    condll.h

Abstract:

    This module contains the include files and definitions for the
    console client DLL.

Author:

    Therese Stowell (thereses) 16-Nov-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//Don't include this when building wow64 type/function database.
#if !defined(SORTPP_PASS)
#include <windows.h>
#endif

#include <winuserk.h>   // temporary
#include <conroute.h>
#include "conapi.h"

#include "ntcsrdll.h"
#include "conmsg.h"
#include <string.h>

#if defined(BUILD_WOW64)
#define SET_CONSOLE_HANDLE(HANDLE) (Wow64SetConsoleHandle(HANDLE))
#define GET_CONSOLE_HANDLE (Wow64GetConsoleHandle())
#define SET_LAST_ERROR(ERROR) (Wow64SetLastError(ERROR) )
#define SET_LAST_NT_ERROR(ERROR) (Wow64SetLastError(RtlNtStatusToDosError( ERROR ))  )
#include "ntwow64c.h"
#else
#define SET_CONSOLE_HANDLE(HANDLE) ((NtCurrentPeb())->ProcessParameters->ConsoleHandle = HANDLE)
#define GET_CONSOLE_HANDLE ((NtCurrentPeb())->ProcessParameters->ConsoleHandle)
#define SET_LAST_ERROR(ERROR) (SetLastError( ERROR ) )
#define SET_LAST_NT_ERROR(ERROR) (SetLastError( RtlNtStatusToDosError( ERROR ) ) )
#endif


#define VALID_ACCESSES (GENERIC_READ | GENERIC_WRITE)
#define VALID_SHARE_ACCESSES (FILE_SHARE_READ | FILE_SHARE_WRITE)

#define VALID_DUP_OPTIONS (DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)

#define CONSOLE_RECT_SIZE_X(RECT) ((RECT)->Right - (RECT)->Left + 1)
#define CONSOLE_RECT_SIZE_Y(RECT) ((RECT)->Bottom - (RECT)->Top + 1)

//
// this critical section is used to serialize access to the code that
// accesses the ctrl handler data structures and the code that allocs
// and frees consoles.
//

CRITICAL_SECTION DllLock;
#define LockDll() RtlEnterCriticalSection(&DllLock)
#define UnlockDll() RtlLeaveCriticalSection(&DllLock)

NTSTATUS
InitializeCtrlHandling( VOID );

VOID
InitExeName(
    VOID
    );

USHORT
GetCurrentExeName(
    LPWSTR Buffer,
    ULONG BufferLength
    );

HANDLE
APIENTRY
OpenConsoleWInternal(
    IN ULONG HandleType,
    IN ULONG DesiredAccess,
    IN BOOL InheritHandle,
    IN ULONG ShareMode
    );

BOOL
APIENTRY
ReadConsoleInternal(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved,
    IN BOOLEAN Unicode,
    IN USHORT ExeNameLength,
    IN LPWSTR ExeName
    );

BOOL
APIENTRY
WriteConsoleInternal(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
RegisterConsoleIMEInternal(
    IN HWND hWndConsoleIME,
    IN DWORD dwConsoleIMEThreadId,
    IN DWORD DesktopLength,
    IN LPWSTR Desktop,
    OUT DWORD *dwConsoleThreadId
    );

BOOL
APIENTRY
UnregisterConsoleIMEInternal(
    IN DWORD dwConsoleIMEThtreadId
    );

BOOL
APIENTRY
GetConsoleInput(
    IN HANDLE hConsoleInput,
    OUT PINPUT_RECORD lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsRead,
    IN USHORT wFlags,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
WriteConsoleInputInternal(
    IN HANDLE hConsoleInput,
    IN CONST INPUT_RECORD *lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsWritten,
    IN BOOLEAN Unicode,
    IN BOOLEAN Append
    );

BOOL
APIENTRY
ReadConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    OUT PCHAR_INFO lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN OUT PSMALL_RECT lpReadRegion,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
WriteConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    IN CONST CHAR_INFO *lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN PSMALL_RECT lpWriteRegion,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
ReadConsoleOutputString(
    IN HANDLE hConsoleOutput,
    OUT LPVOID lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwReadCoord,
    OUT LPDWORD lpNumberOfElementsRead
    );

BOOL
APIENTRY
WriteConsoleOutputString(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    );

BOOL
APIENTRY
FillConsoleOutput(
    IN HANDLE hConsoleOutput,
    IN WORD   Element,
    IN DWORD  nLength,
    IN DWORD  fFlags,
    IN COORD  dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    );

BOOL
APIENTRY
GetConsoleKeyboardLayoutNameWorker(
    OUT LPSTR pszLayout,
    IN BOOL bAnsi);

BOOL
APIENTRY
SetConsolePaletteInternal(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    );

BOOL
APIENTRY
ScrollConsoleScreenBufferInternal(
    IN HANDLE hConsoleOutput,
    IN CONST SMALL_RECT *lpScrollRectangle,
    IN CONST SMALL_RECT *lpClipRectangle,
    IN COORD dwDestinationOrigin,
    IN CONST CHAR_INFO *lpFill,
    IN BOOLEAN Unicode
    );

NTSTATUS
APIENTRY
SetConsoleOutputCPInternal(
    IN UINT wCodePageID
    );

VOID
APIENTRY
SetLastConsoleEventActiveInternal(
   VOID
   );

BOOL
APIENTRY
ConnectConsoleInternal(
   IN PWSTR pObjectDirectory,
   IN OUT PCONSOLE_API_CONNECTINFO pConnectInfo,
   OUT PBOOLEAN pServerProcess
   );


BOOL
APIENTRY
AllocConsoleInternal(
   IN LPWSTR lpTitle,
   IN DWORD dwTitleLength,
   IN LPWSTR lpDesktop,
   IN DWORD dwDesktopLength,
   IN LPWSTR lpCurDir,
   IN DWORD dwCurDirLength,
   IN LPWSTR AppName,
   IN DWORD dwAppNameLength,
   IN LPTHREAD_START_ROUTINE CtrlRoutine,
   IN LPTHREAD_START_ROUTINE PropRoutine,
   IN OUT PCONSOLE_INFO pConsoleInfo
   );

BOOL
APIENTRY
FreeConsoleInternal(
   VOID
   );

BOOL
APIENTRY
AttachConsoleInternal(
   IN DWORD dwProcessId,
   IN LPTHREAD_START_ROUTINE CtrlRoutine,
   IN LPTHREAD_START_ROUTINE PropRoutine,
   IN OUT PCONSOLE_INFO pConsoleInfo
   );

BOOL
WINAPI
GetConsoleLangId(
    OUT LANGID *lpLangId
    );

BOOL
APIENTRY
AddConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    IN LPVOID Target,
    IN UINT   TargetLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    OUT LPVOID TargetBuffer,
    IN UINT   TargetBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasesLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasExesLengthInternal(
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasesInternal(
    OUT LPVOID AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasExesInternal(
    OUT LPVOID ExeNameBuffer,
    IN DWORD ExeNameBufferLength,
    IN BOOLEAN Unicode
    );

VOID
APIENTRY
ExpungeConsoleCommandHistoryInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
SetConsoleNumberOfCommandsInternal(
    IN DWORD Number,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleCommandHistoryLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleCommandHistoryInternal(
    OUT LPVOID Commands,
    IN DWORD CommandBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleTitleInternal(
    OUT PVOID lpConsoleTitle,
    IN  DWORD nSize,
    IN  BOOLEAN Unicode
    );

BOOL
APIENTRY
SetConsoleTitleInternal(
    IN CONST VOID *lpConsoleTitle,
    IN DWORD TitleLength,  // in bytes
    IN BOOLEAN Unicode
    );

VOID
SetTEBLangID(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\ctrlc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ctrlc.c

Abstract:

    This module implements ctrl-c handling

Author:

    Therese Stowell (thereses) 1-Mar-1991

Revision History:   

--*/

#include "precomp.h"
#pragma hdrstop

#if !defined(BUILD_WOW64)

#define LIST_INCREMENT 2    // amount to grow handler list
#define INITIAL_LIST_SIZE 1 // initial length of handler list

PHANDLER_ROUTINE SingleHandler[INITIAL_LIST_SIZE]; // initial handler list
ULONG HandlerListLength;            // used length of handler list
ULONG AllocatedHandlerListLength;   // allocated length of handler list
PHANDLER_ROUTINE *HandlerList;      // pointer to handler list

#define NUMBER_OF_CTRL_EVENTS 7     // number of ctrl events
#define SYSTEM_CLOSE_EVENT 4

BOOL LastConsoleEventActive;


BOOL
DefaultHandler(
    IN ULONG CtrlType
    )

/*++

    This is the default ctrl handler.

Parameters:

    CtrlType - type of ctrl event (ctrl-c, ctrl-break).

Return Value:

    none.

--*/

{
    ExitProcess((DWORD)CONTROL_C_EXIT);
    return TRUE;
    UNREFERENCED_PARAMETER(CtrlType);
}

NTSTATUS
InitializeCtrlHandling( VOID )

/*++

    This routine initializes ctrl handling.  It is called by AllocConsole
    and the dll initialization code.

Parameters:

    none.

Return Value:

    none.

--*/

{
    AllocatedHandlerListLength = HandlerListLength = INITIAL_LIST_SIZE;
    HandlerList = SingleHandler;
    SingleHandler[0] = DefaultHandler;
    return STATUS_SUCCESS;
}

DWORD
CtrlRoutine(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread is created when ctrl-c or ctrl-break is entered,
    or when close is selected.  it calls the appropriate handlers.

Arguments:

    lpThreadParameter - what type of event happened.

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG i;
    ULONG EventNumber,OriginalEventNumber;
    DWORD fNoExit;
    DWORD dwExitCode;
    EXCEPTION_RECORD ExceptionRecord;

    SetThreadPriority(NtCurrentThread(), THREAD_PRIORITY_HIGHEST);
    OriginalEventNumber = EventNumber = PtrToUlong(lpThreadParameter);

    //
    // If this bit is set, it means we don't want to cause this process
    // to exit itself if it is a logoff or shutdown event.
    //
    fNoExit = 0x80000000 & EventNumber;
    EventNumber &= ~0x80000000;

    //
    // the ctrl_close event is set when the user selects the window
    // close option from the system menu, or EndTask, or Settings-Terminate.
    // the system close event is used when another ctrl-thread times out.
    //

    switch (EventNumber) {
    default:
        ASSERT (EventNumber < NUMBER_OF_CTRL_EVENTS);
        if (EventNumber >= NUMBER_OF_CTRL_EVENTS)
            return (DWORD)STATUS_UNSUCCESSFUL;
        break;

    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
        //
        // If the process is being debugged, give the debugger
        // a shot. If the debugger handles the exception, then
        // go back and wait.
        //

        if (!IsDebuggerPresent())
            break;

        if ( EventNumber == CTRL_C_EVENT ) {
            ExceptionRecord.ExceptionCode = DBG_CONTROL_C;
            }
        else {
            ExceptionRecord.ExceptionCode = DBG_CONTROL_BREAK;
            }
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionRecord = NULL;
        ExceptionRecord.ExceptionAddress = (PVOID)DefaultHandler;
        ExceptionRecord.NumberParameters = 0;

        try {
            RtlRaiseException(&ExceptionRecord);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            LockDll();
            try {
                if (EventNumber != CTRL_C_EVENT ||
                        (NtCurrentPeb()->ProcessParameters->ConsoleFlags & CONSOLE_IGNORE_CTRL_C) == 0) {
                    for (i=HandlerListLength;i>0;i--) {
                        if ((HandlerList[i-1])(EventNumber)) {
                            break;
                        }
                    }
                }
            } finally {
                UnlockDll();
            }
        }
        ExitThread(0);
        break;

    case SYSTEM_CLOSE_EVENT:
        ExitProcess((DWORD)CONTROL_C_EXIT);
        break;

    case SYSTEM_ROOT_CONSOLE_EVENT:
        if (!LastConsoleEventActive)
            ExitThread(0);
        break;

    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        //if (LastConsoleEventActive)
            //EventNumber = SYSTEM_ROOT_CONSOLE_EVENT;
        break;
    }

    LockDll();
    dwExitCode = 0;
    try {
        if (EventNumber != CTRL_C_EVENT ||
                (NtCurrentPeb()->ProcessParameters->ConsoleFlags & CONSOLE_IGNORE_CTRL_C) == 0) {
            for (i=HandlerListLength;i>0;i--) {

                //
                // Don't call the last handler (the default one which calls
                // ExitProcess() if this process isn't supposed to exit (system
                // process are not supposed to exit because of shutdown or
                // logoff event notification).
                //

                if ((i-1) == 0 && fNoExit) {
                    if (EventNumber == CTRL_LOGOFF_EVENT ||
                        EventNumber == CTRL_SHUTDOWN_EVENT) {
                        break;
                    }
                }

                if ((HandlerList[i-1])(EventNumber)) {
                    switch (EventNumber) {
                    case CTRL_CLOSE_EVENT:
                    case CTRL_LOGOFF_EVENT:
                    case CTRL_SHUTDOWN_EVENT:
                    case SYSTEM_ROOT_CONSOLE_EVENT:
                        dwExitCode = OriginalEventNumber;
                        break;
                    }
                    break;
                }
            }
        }
    } finally {
        UnlockDll();
    }
    ExitThread(dwExitCode);
    return STATUS_SUCCESS;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

VOID
APIENTRY
SetLastConsoleEventActiveInternal( VOID )

/*++

Routine Description:

    Sends a ConsolepNotifyLastClose command to the server.

Arguments:

    none.

Return Value:

    None.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_NOTIFYLASTCLOSE_MSG a = &m.u.SetLastConsoleEventActive;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepNotifyLastClose
                                            ),
                         sizeof( *a )
                       );
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

VOID
APIENTRY
SetLastConsoleEventActive( VOID )
// private api
{

    LastConsoleEventActive = TRUE;
    SetLastConsoleEventActiveInternal();
}

BOOL
SetCtrlHandler(
    IN PHANDLER_ROUTINE HandlerRoutine
    )

/*++

Routine Description:

    This routine adds a ctrl handler to the process's list.

Arguments:

    HandlerRoutine - pointer to ctrl handler.

Return Value:

    TRUE - success.

--*/

{
    PHANDLER_ROUTINE *NewHandlerList;

    //
    // NULL handler routine is not stored in table. It is
    // used to temporarily inhibit ^C event handling
    //

    if (!HandlerRoutine) {
        NtCurrentPeb()->ProcessParameters->ConsoleFlags |= CONSOLE_IGNORE_CTRL_C;
        return TRUE;
    }

    if (HandlerListLength == AllocatedHandlerListLength) {

        //
        // grow list
        //

        NewHandlerList = (PHANDLER_ROUTINE *) RtlAllocateHeap( RtlProcessHeap(), 0,
                                                 sizeof(PHANDLER_ROUTINE) * (HandlerListLength + LIST_INCREMENT));
        if (!NewHandlerList) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        //
        // copy list
        //

        RtlCopyMemory(NewHandlerList,HandlerList,sizeof(PHANDLER_ROUTINE) * HandlerListLength);

        if (HandlerList != SingleHandler) {

            //
            // free old list
            //

            RtlFreeHeap(RtlProcessHeap(), 0, HandlerList);
        }
        HandlerList = NewHandlerList;
        AllocatedHandlerListLength += LIST_INCREMENT;
    }
    ASSERT (HandlerListLength < AllocatedHandlerListLength);

    HandlerList[HandlerListLength] = HandlerRoutine;
    HandlerListLength++;
    return TRUE;
}

BOOL
RemoveCtrlHandler(
    IN PHANDLER_ROUTINE HandlerRoutine
    )

/*++

Routine Description:

    This routine removes a ctrl handler from the process's list.

Arguments:

    HandlerRoutine - pointer to ctrl handler.

Return Value:

    TRUE - success.

--*/

{
    ULONG i;

    //
    // NULL handler routine is not stored in table. It is
    // used to temporarily inhibit ^C event handling. Removing
    // this handler allows normal processing to occur
    //

    if ( !HandlerRoutine ) {
        NtCurrentPeb()->ProcessParameters->ConsoleFlags = 0;
        return TRUE;
        }

    for (i=0;i<HandlerListLength;i++) {
        if (*(HandlerList+i) == HandlerRoutine) {
            if (i < (HandlerListLength-1)) {
                memmove(&HandlerList[i],&HandlerList[i+1],sizeof(PHANDLER_ROUTINE) * (HandlerListLength - i - 1));
            }
            HandlerListLength -= 1;
            return TRUE;
        }
    }
    SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
APIENTRY
SetConsoleCtrlHandler(
    IN PHANDLER_ROUTINE HandlerRoutine,
    IN BOOL Add       // add or delete
    )

/*++

Routine Description:

    This routine adds or removes a ctrl handler from the process's list.

Arguments:

    HandlerRoutine - pointer to ctrl handler.

    Add - if TRUE, add handler.  else remove.

Return Value:

    TRUE - success.

--*/

{
    BOOL Success;

    LockDll();
    if (Add) {
        Success = SetCtrlHandler(HandlerRoutine);
    }
    else {
        Success = RemoveCtrlHandler(HandlerRoutine);
    }
    UnlockDll();
    return Success;
}

#endif //!defined(BUILD_WOW64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\dbcs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

Author:

    KazuM May.11.1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_SB)
#include "conime.h"

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    OUT LPDWORD lpNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpNlsMode - Supplies a pointer to the NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

#if defined(FE_IME)
    CONSOLE_API_MSG m;
    PCONSOLE_NLS_MODE_MSG a = &m.u.GetConsoleNlsMode;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->Ready = FALSE;

    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetNlsMode
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS( m.ReturnValue )) {
	Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);

        if (a->Ready == FALSE)
        {
            /*
             * If not ready conversion status on this console,
             * then one more try get status.
             */
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                                      ConsolepGetNlsMode
                                                    ),
                                 sizeof( *a )
                               );
            if (! NT_SUCCESS( m.ReturnValue )) {
                SET_LAST_NT_ERROR (m.ReturnValue);
                NtClose(a->hEvent);
                return FALSE;
            }
            else
            {
	        Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
            }
        }

	NtClose(a->hEvent);

        try {
            *lpNlsMode = a->NlsMode;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        NtClose(a->hEvent);
        return FALSE;
    }
#else
    return FALSE;
#endif

}

BOOL
APIENTRY
SetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    IN DWORD dwNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    dwNlsMode - Supplies NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

#if defined(FE_IME)
    CONSOLE_API_MSG m;
    PCONSOLE_NLS_MODE_MSG a = &m.u.SetConsoleNlsMode;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->NlsMode = dwNlsMode;

    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetNlsMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
	Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
        NtClose(a->hEvent);	
	if (Status != 0) {
	    SET_LAST_NT_ERROR(Status);
	    return FALSE;
	}
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        NtClose(a->hEvent);
        return FALSE;
    }
#else
    return FALSE;
#endif

}

BOOL
APIENTRY
GetConsoleCharType(
    IN HANDLE hConsoleHandle,
    IN COORD coordCheck,
    OUT PDWORD pdwType
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    coordCheck - set check position to these coordinates

    pdwType - receive character type

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CHAR_TYPE_MSG a = &m.u.GetConsoleCharType;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->coordCheck = coordCheck;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepCharType
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *pdwType = a->dwType;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
SetConsoleLocalEUDC(
    IN HANDLE hConsoleHandle,
    IN WORD   wCodePoint,
    IN COORD  cFontSize,
    IN PCHAR  lpSB
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    wCodePoint - Code point of font by Shift JIS code.

    cFontSize - FontSize of Font

    lpSB - Pointer of font bitmap Buffer

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_LOCAL_EUDC_MSG a = &m.u.SetConsoleLocalEUDC;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ULONG DataLength;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->CodePoint = wCodePoint;
    a->FontSize = cFontSize;

    DataLength = ((cFontSize.X + 7) / 8) * cFontSize.Y;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              DataLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             lpSB,
                             DataLength,
                             (PVOID *) &a->FontFace
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetLocalEUDC
                                            ),
                         sizeof( *a )
                       );
        CsrFreeCaptureBuffer( CaptureBuffer );

    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
SetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    IN BOOL   Blink,
    IN BOOL   DBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CURSOR_MODE_MSG a = &m.u.SetConsoleCursorMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->Blink = Blink;
    a->DBEnable = DBEnable;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursorMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
GetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    OUT PBOOL  pbBlink,
    OUT PBOOL  pbDBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CURSOR_MODE_MSG a = &m.u.GetConsoleCursorMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCursorMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *pbBlink = a->Blink;
            *pbDBEnable = a->DBEnable;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
APIENTRY
RegisterConsoleOS2(
    IN BOOL fOs2Register
    )

/*++

Description:

    This routine registers the OS/2 with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_REGISTEROS2_MSG a = &m.u.RegisterConsoleOS2;
    NTSTATUS Status;


    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->fOs2Register  = fOs2Register;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepRegisterOS2
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

BOOL
APIENTRY
SetConsoleOS2OemFormat(
    IN BOOL fOs2OemFormat
    )

/*++

Description:

    This routine sets the OS/2 OEM Format with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_SETOS2OEMFORMAT_MSG a = &m.u.SetConsoleOS2OemFormat;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->fOs2OemFormat = fOs2OemFormat;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetOS2OemFormat
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#endif //!defined(BUILD_WOW6432)

#if defined(FE_IME)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
RegisterConsoleIMEInternal(
    IN HWND hWndConsoleIME,
    IN DWORD dwConsoleIMEThreadId,
    IN DWORD DesktopLength,
    IN LPWSTR Desktop,
    OUT DWORD *dwConsoleThreadId
    )
{

   CONSOLE_API_MSG m;
   PCONSOLE_REGISTER_CONSOLEIME_MSG a = &m.u.RegisterConsoleIME;
   PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

   a->ConsoleHandle        = GET_CONSOLE_HANDLE;
   a->hWndConsoleIME       = hWndConsoleIME;
   a->dwConsoleIMEThreadId = dwConsoleIMEThreadId;
   a->DesktopLength        = DesktopLength;

   CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                             DesktopLength
                                            );
   if (CaptureBuffer == NULL) {
       SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
       return FALSE;
   }

   CsrCaptureMessageBuffer( CaptureBuffer,
                            Desktop,
                            a->DesktopLength,
                            (PVOID *) &a->Desktop
                          );

   //
   // Connect to the server process
   //

   CsrClientCallServer( (PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                             ConsolepRegisterConsoleIME
                                           ),
                        sizeof( *a )
                      );

//HS Jan.20    if (CaptureBuffer) {
       CsrFreeCaptureBuffer( CaptureBuffer );
//HS Jan.20    }

   if (!NT_SUCCESS( m.ReturnValue)) {
       SET_LAST_NT_ERROR(m.ReturnValue);
       return FALSE;
   }
   else {
       try {
           if (dwConsoleThreadId != NULL)
               *dwConsoleThreadId = a->dwConsoleThreadId;
       } except( EXCEPTION_EXECUTE_HANDLER ) {
           SET_LAST_ERROR (ERROR_INVALID_ACCESS);
           return FALSE;
       }
       return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
RegisterConsoleIME(
    IN HWND  hWndConsoleIME,
    OUT DWORD *dwConsoleThreadId
    )

/*++

Description:

    This routine register the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{
    STARTUPINFOW StartupInfo;
    DWORD dwDesktopLength;
    GetStartupInfoW(&StartupInfo);

    if (StartupInfo.lpDesktop != NULL && *StartupInfo.lpDesktop != 0) {
        dwDesktopLength = (USHORT)((wcslen(StartupInfo.lpDesktop)+1)*sizeof(WCHAR));
        dwDesktopLength = (USHORT)(min(dwDesktopLength,MAX_TITLE_LENGTH));
    } else {
        dwDesktopLength = 0;
    }

    return RegisterConsoleIMEInternal(hWndConsoleIME,
                                      GetCurrentThreadId(),
                                      dwDesktopLength,
                                      StartupInfo.lpDesktop,
                                      dwConsoleThreadId);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
UnregisterConsoleIMEInternal(
    IN DWORD dwConsoleIMEThtreadId
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_UNREGISTER_CONSOLEIME_MSG a = &m.u.UnregisterConsoleIME;

    a->ConsoleHandle        = GET_CONSOLE_HANDLE;
    a->dwConsoleIMEThreadId = dwConsoleIMEThtreadId;

    //
    // Connect to the server process
    //

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepUnregisterConsoleIME
                                            ),
                         sizeof( *a )
                       );

    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
UnregisterConsoleIME(
    )

/*++

Description:

    This routine unregister the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    return UnregisterConsoleIMEInternal(GetCurrentThreadId());

}

NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + ValueName.Length;;
    KeyValueInformation = LocalAlloc(LPTR,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwValueLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    LocalFree(KeyValueInformation);
    return Status;
}

VOID
GetCommandLineString(
    IN LPWSTR CommandLine,
    IN DWORD  dwSize
    )
{
    NTSTATUS Status;
    HANDLE hkRegistry;
    WCHAR awchBuffer[ 512 ];
    DWORD dwRet;

    dwRet = GetSystemDirectoryW(CommandLine, dwSize);
    if (dwRet)
    {
        CommandLine[dwRet++] = L'\\';
        CommandLine[dwRet]   = L'\0';
        dwSize -= dwRet;

    }
    else
    {
        CommandLine[0] = L'\0';
    }

    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE,
                          &hkRegistry);
    if (NT_SUCCESS( Status ))
    {
        Status = MyRegQueryValue(hkRegistry,
                                 MACHINE_REGISTRY_CONSOLEIME,
                                 sizeof(awchBuffer), (PBYTE)&awchBuffer);
        if (NT_SUCCESS( Status ))
        {
            dwRet = wcslen(awchBuffer);
            if (dwRet < dwSize)
            {
                wcscat(CommandLine, awchBuffer);
            }
            else
            {
                CommandLine[0] = L'\0';
                goto ErrorExit;
            }
        }
        else
        {
            goto ErrorExit;
        }

        NtClose(hkRegistry);
    }
    else
    {
        goto ErrorExit;
    }

    return;

ErrorExit:
    wcscat(CommandLine, L"conime.exe");
    return;
}


DWORD
ConsoleIMERoutine(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread is created when the create input thread.
    It invokes the console IME process.

Arguments:

    lpThreadParameter - not use.

Return Value:

    STATUS_SUCCESS - function was successful

--*/

{
    NTSTATUS Status;
    BOOL fRet;
    static BOOL fInConIMERoutine = FALSE;

    DWORD fdwCreate;
    STARTUPINFOW StartupInfo;
    STARTUPINFOW StartupInfoConsole;
    WCHAR CommandLine[MAX_PATH*2];
    PROCESS_INFORMATION ProcessInformation;
    HANDLE hEvent;
    DWORD dwWait;

    Status = STATUS_SUCCESS;

    //
    // Prevent the user from launching multiple applets attached
    // to a single console
    //

    if (fInConIMERoutine) {
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    fInConIMERoutine = TRUE;

    //
    // Create event
    //
    hEvent = CreateEventW(NULL,                 // Security attributes
                          FALSE,                // Manual reset
                          FALSE,                // Initial state
                          CONSOLEIME_EVENT);    // Event object name
    if (hEvent == NULL)
    {
        goto ErrorExit;
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        goto ErrorExit;
    }

    //
    // Get Console IME process name and event name
    //

    GetCommandLineString(CommandLine, sizeof(CommandLine)/sizeof(WCHAR));

    GetStartupInfoW(&StartupInfoConsole);
    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_HIDE;
    StartupInfo.dwFlags = STARTF_FORCEONFEEDBACK;
    StartupInfo.lpDesktop = StartupInfoConsole.lpDesktop;

    //
    // create Console IME process
    //

    fdwCreate = NORMAL_PRIORITY_CLASS | CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP;
    fRet = CreateProcessW(NULL,                // Application name
                          CommandLine,         // Command line
                          NULL,                // process security attributes
                          NULL,                // thread security attributes
                          FALSE,               // inherit handles
                          fdwCreate,           // create flags
                          NULL,                // environment
                          NULL,                // current directory
                          &StartupInfo,        // Start up information
                          &ProcessInformation  // process information
                         );
    if (! fRet)
    {
        Status = GetLastError();
    }
    else
    {
        dwWait = WaitForSingleObject(hEvent, 10 * 1000);    // wait 10 sec for console IME process
        if (dwWait == WAIT_TIMEOUT)
        {
            TerminateProcess(ProcessInformation.hProcess, 0);
        }
        CloseHandle(ProcessInformation.hThread) ;
        CloseHandle(ProcessInformation.hProcess) ;
    }

    CloseHandle(hEvent);

ErrorExit:

    fInConIMERoutine = FALSE;

    return Status;
}

#endif //!defined(BUILD_WOW6432)

#endif // FE_IME


#else // FE_SB

// Followings are stub functions for FE Console Support


#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    OUT LPDWORD lpNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpNlsMode - Supplies a pointer to the NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    IN DWORD dwNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    dwNlsMode - Supplies NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
GetConsoleCharType(
    IN HANDLE hConsoleHandle,
    IN COORD coordCheck,
    OUT PDWORD pdwType
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    coordCheck - set check position to these coordinates

    pdwType - receive character type

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleLocalEUDC(
    IN HANDLE hConsoleHandle,
    IN WORD   wCodePoint,
    IN COORD  cFontSize,
    IN PCHAR  lpSB
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    wCodePoint - Code point of font by Shift JIS code.

    cFontSize - FontSize of Font

    lpSB - Pointer of font bitmap Buffer

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    IN BOOL   Blink,
    IN BOOL   DBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
GetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    OUT PBOOL  pbBlink,
    OUT PBOOL  pbDBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
RegisterConsoleOS2(
    IN BOOL fOs2Register
    )

/*++

Description:

    This routine registers the OS/2 with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleOS2OemFormat(
    IN BOOL fOs2OemFormat
    )

/*++

Description:

    This routine sets the OS/2 OEM Format with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

#endif //!defined(BUILD_WOW6432)

#if defined(FE_IME)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
RegisterConsoleIME(
    IN HWND  hWndConsoleIME,
    OUT DWORD *dwConsoleThreadId
    )

/*++

Description:

    This routine register the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    return FALSE;

}

BOOL
APIENTRY
UnregisterConsoleIME(
    )

/*++

Description:

    This routine unregister the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    return FALSE;

}

#endif //!defined(BUILD_WOW64)

#endif // FE_IME

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\cmdline.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

        This file implements command line editing and aliasing.

Author:

    Therese Stowell (thereses) 22-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#define CONSOLE_NAME_PATH_SEPARATOR ((WCHAR)L'\\')
#define CONSOLE_NAME_PATH_TERMINATOR ((WCHAR)L'\0')

#if !defined(BUILD_WOW64)

#define FNAME_LENGTH 256
BOOLEAN ExeNameInitialized;
RTL_CRITICAL_SECTION ExeNameCriticalSection;
WCHAR ExeNameBuffer[FNAME_LENGTH];
USHORT ExeNameLength;       // in chars, not bytes
WCHAR StartDirBuffer[MAX_PATH + 1];
USHORT StartDirLength;      // in chars, not bytes

VOID
InitExeName(
    VOID)
{
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY ImageEntry;

    if (ExeNameInitialized) {
        return;
    }

    RtlInitializeCriticalSection(&ExeNameCriticalSection);
    ExeNameInitialized = TRUE;
    Peb = NtCurrentPeb();
    ImageEntry = (PLDR_DATA_TABLE_ENTRY)Peb->Ldr->InLoadOrderModuleList.Flink;
    ImageEntry = CONTAINING_RECORD(ImageEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
    ExeNameLength = ImageEntry->BaseDllName.Length/sizeof(WCHAR);
    RtlCopyMemory(ExeNameBuffer,
           ImageEntry->BaseDllName.Buffer,
           ImageEntry->BaseDllName.Length
          );
    ExeNameBuffer[ExeNameLength] = CONSOLE_NAME_PATH_TERMINATOR;
    StartDirLength = Peb->ProcessParameters->CurrentDirectory.DosPath.Length/sizeof(WCHAR);
    RtlCopyMemory(StartDirBuffer,
                  Peb->ProcessParameters->CurrentDirectory.DosPath.Buffer,
                  Peb->ProcessParameters->CurrentDirectory.DosPath.Length);
    StartDirBuffer[StartDirLength] = CONSOLE_NAME_PATH_TERMINATOR;
}


USHORT
GetCurrentExeName(
    OUT LPWSTR Buffer,
    IN ULONG BufferLength)
{
    if (!ExeNameInitialized) {
        Buffer[0] = UNICODE_NULL;
        return 0;
    }

    RtlEnterCriticalSection(&ExeNameCriticalSection);
    if (BufferLength > ExeNameLength * sizeof(WCHAR)) {
        BufferLength = ExeNameLength * sizeof(WCHAR);
    }
    RtlCopyMemory(Buffer, ExeNameBuffer, BufferLength);
    RtlLeaveCriticalSection(&ExeNameCriticalSection);
    return (USHORT)BufferLength;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

//
// Returns bytes, not chars.
//
USHORT
GetExeName(
    IN OUT LPVOID ExeName,
    IN BOOLEAN UnicodeApi,
    OUT PBOOLEAN UnicodeExe)
{
    if (ExeName == NULL) {
        return 0;
    }

    if (UnicodeApi) {
        *UnicodeExe = TRUE;
        return (USHORT)wcslen((LPWSTR)ExeName) * sizeof(WCHAR);
    } else {
        *UnicodeExe = FALSE;
        return (USHORT)strlen((LPSTR)ExeName);
    }
}

BOOL
APIENTRY
AddConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    IN LPVOID Target,
    IN UINT   TargetLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    Source - String to substitute alias string for, in input stream.

    Target - String to substitute for source.  NULL to delete an existing
        alias.

    ExeName - Exe to set alias in.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    ULONG CapturedMsgPointers;
    PCONSOLE_ADDALIAS_MSG a = &m.u.AddConsoleAliasW;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->SourceLength = (USHORT)SourceLength;
    a->Unicode = Unicode;
    CapturedMsgPointers = 2;

    a->ExeLength = GetExeName(ExeName, Unicode, &a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (Target != NULL) {
        a->TargetLength = (USHORT)TargetLength;
        CapturedMsgPointers += 1;
    } else {
        a->Target = NULL;
        a->TargetLength = 0;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer( CapturedMsgPointers,
                                              a->SourceLength + a->TargetLength + a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) Source,
                             a->SourceLength,
                             (PVOID *) &a->Source
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    if (Target != NULL) {
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) Target,
                                 a->TargetLength,
                                 (PVOID *) &a->Target
                               );
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepAddAlias
                                            ),
                         sizeof( *a )
                       );

    CsrFreeCaptureBuffer( CaptureBuffer );

    if (!NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    return TRUE;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
AddConsoleAliasW(
    IN LPWSTR Source,
    IN LPWSTR Target,
    IN LPWSTR ExeName)
{
    USHORT TargetLength;

    if (Target != NULL) {
        TargetLength = (USHORT) (lstrlenW(Target) * sizeof(WCHAR));
    } else {
        TargetLength = 0;
    }

    return AddConsoleAliasInternal(Source,
                                   lstrlenW(Source) * sizeof(WCHAR),
                                   Target,
                                   TargetLength,
                                   ExeName,
                                   TRUE);
}

BOOL
APIENTRY
AddConsoleAliasA(
    IN LPTSTR Source,
    IN LPTSTR Target,
    IN LPTSTR ExeName)
{
    USHORT TargetLength;

    if (Target != NULL) {
        TargetLength = (USHORT)lstrlenA(Target);
    } else {
        TargetLength = 0;
    }

    return AddConsoleAliasInternal(Source,
                                   lstrlenA(Source),
                                   Target,
                                   TargetLength,
                                   ExeName,
                                   FALSE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    OUT LPVOID TargetBuffer,
    IN UINT   TargetBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    Source - Name of alias to query.  NULL means query all alias names.

    Target - Where to store value of alias.  If Source is NULL, then
        value is one or more null terminated strings terminated by an extra
        null byte.  Each null terminated string is the name of an alias.

Return Value:

    Non-zero - The operation was successful, and the return value is the
        number of characters stored in the Target buffer.

    Zero - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    ULONG CapturedMsgPointers;
    PCONSOLE_GETALIAS_MSG a = &m.u.GetConsoleAliasW;

    if (Source == NULL) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;

    CapturedMsgPointers = 3;

    a->ExeLength = GetExeName(ExeName, Unicode, &a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    a->SourceLength = (USHORT) SourceLength;
    a->TargetLength = (USHORT) TargetBufferLength;

    CaptureBuffer = CsrAllocateCaptureBuffer( CapturedMsgPointers,
                                              a->SourceLength + a->TargetLength + a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) Source,
                             a->SourceLength,
                             (PVOID *) &a->Source
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->TargetLength,
                             (PVOID *) &a->Target
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAlias
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS( m.ReturnValue )) {
        RtlCopyMemory( TargetBuffer, a->Target, a->TargetLength );
    }
    else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        if (m.ReturnValue != STATUS_BUFFER_TOO_SMALL) {
            a->TargetLength = 0;
        }
    }

    CsrFreeCaptureBuffer( CaptureBuffer );

    return a->TargetLength;

}

#endif !defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleAliasW(
    IN LPWSTR Source,
    OUT LPWSTR TargetBuffer,
    IN DWORD TargetBufferLength,
    IN LPWSTR ExeName
    )
{
    return GetConsoleAliasInternal(Source,
                                   lstrlenW(Source)*sizeof(WCHAR),
                                   TargetBuffer,
                                   TargetBufferLength,
                                   ExeName,
                                   TRUE
                                  );
}

DWORD
APIENTRY
GetConsoleAliasA(
    IN LPTSTR Source,
    OUT LPTSTR TargetBuffer,
    IN DWORD TargetBufferLength,
    IN LPTSTR ExeName
    )
{
    return GetConsoleAliasInternal(Source,
                                   lstrlenA(Source),
                                   TargetBuffer,
                                   TargetBufferLength,
                                   ExeName,
                                   FALSE
                                  );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasesLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASESLENGTH_MSG a = &m.u.GetConsoleAliasesLengthW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;
    a->ExeLength = GetExeName(ExeName,Unicode,&a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer(1, a->ExeLength);
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliasesLength
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->AliasesLength;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleAliasesLengthW(
    IN LPWSTR ExeName
    )
{
    return GetConsoleAliasesLengthInternal(ExeName,
                                           TRUE
                                          );
}

DWORD
APIENTRY
GetConsoleAliasesLengthA(
    IN LPTSTR ExeName
    )
{
    return GetConsoleAliasesLengthInternal(ExeName,
                                           FALSE
                                          );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasExesLengthInternal(
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASEXESLENGTH_MSG a = &m.u.GetConsoleAliasExesLengthW;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliasExesLength
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->AliasExesLength;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleAliasExesLengthW( VOID )
{
    return GetConsoleAliasExesLengthInternal( TRUE );
}

DWORD
APIENTRY
GetConsoleAliasExesLengthA( VOID )
{
    return GetConsoleAliasExesLengthInternal( FALSE );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasesInternal(
    OUT LPVOID AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASES_MSG a = &m.u.GetConsoleAliasesW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->ExeLength = GetExeName(ExeName, Unicode, &a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }
    a->Unicode = Unicode;
    a->AliasesBufferLength = AliasBufferLength;

    CaptureBuffer = CsrAllocateCaptureBuffer(2, a->ExeLength + AliasBufferLength);
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );
    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->AliasesBufferLength,
                             (PVOID *) &a->AliasesBuffer
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliases
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( AliasBuffer, a->AliasesBuffer, a->AliasesBufferLength );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
        CsrFreeCaptureBuffer( CaptureBuffer );
        return a->AliasesBufferLength;
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleAliasesW(
    OUT LPWSTR AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPWSTR ExeName
    )
{
    return GetConsoleAliasesInternal(AliasBuffer,
                                     AliasBufferLength,
                                     ExeName,
                                     TRUE
                                    );
}

DWORD
GetConsoleAliasesA(
    OUT LPTSTR AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPTSTR ExeName
    )
{
    return GetConsoleAliasesInternal(AliasBuffer,
                                     AliasBufferLength,
                                     ExeName,
                                     FALSE
                                    );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasExesInternal(
    OUT LPVOID ExeNameBuffer,
    IN DWORD ExeNameBufferLength,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASEXES_MSG a = &m.u.GetConsoleAliasExesW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->AliasExesBufferLength = ExeNameBufferLength;
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              ExeNameBufferLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->AliasExesBufferLength,
                             (PVOID *) &a->AliasExesBuffer
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliasExes
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( ExeNameBuffer, a->AliasExesBuffer, a->AliasExesBufferLength );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
        CsrFreeCaptureBuffer( CaptureBuffer );
        return a->AliasExesBufferLength;
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleAliasExesW(
    OUT LPWSTR ExeNameBuffer,
    IN DWORD ExeNameBufferLength
    )
{
    return GetConsoleAliasExesInternal(ExeNameBuffer,
                                       ExeNameBufferLength,
                                       TRUE
                                      );
}

DWORD
GetConsoleAliasExesA(
    OUT LPTSTR ExeNameBuffer,
    IN DWORD ExeNameBufferLength
    )
{
    return GetConsoleAliasExesInternal(ExeNameBuffer,
                                       ExeNameBufferLength,
                                       FALSE
                                      );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

VOID
APIENTRY
ExpungeConsoleCommandHistoryInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_EXPUNGECOMMANDHISTORY_MSG a = &m.u.ExpungeConsoleCommandHistoryW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;
    a->ExeLength = GetExeName(ExeName, Unicode, &a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer(1, a->ExeLength);
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepExpungeCommandHistory
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );

}


#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

VOID
ExpungeConsoleCommandHistoryW(
    IN LPWSTR ExeName
    )
{
    ExpungeConsoleCommandHistoryInternal(ExeName,TRUE);
}

VOID
ExpungeConsoleCommandHistoryA(
    IN LPTSTR ExeName
    )
{
    ExpungeConsoleCommandHistoryInternal(ExeName,FALSE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
SetConsoleNumberOfCommandsInternal(
    IN DWORD Number,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETNUMBEROFCOMMANDS_MSG a = &m.u.SetConsoleNumberOfCommandsW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->NumCommands = Number;
    a->Unicode = Unicode;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer(1, a->ExeLength);
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetNumberOfCommands
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
SetConsoleNumberOfCommandsW(
    IN DWORD Number,
    IN LPWSTR ExeName
    )
{
    return SetConsoleNumberOfCommandsInternal(Number,
                                              ExeName,
                                              TRUE
                                             );
}

BOOL
SetConsoleNumberOfCommandsA(
    IN DWORD Number,
    IN LPTSTR ExeName
    )
{
    return SetConsoleNumberOfCommandsInternal(Number,
                                              ExeName,
                                              FALSE
                                             );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleCommandHistoryLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG a = &m.u.GetConsoleCommandHistoryLengthW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;
    a->ExeLength = GetExeName(ExeName, Unicode, &a->UnicodeExe);
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer(1, a->ExeLength);
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCommandHistoryLength
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );
    return a->CommandHistoryLength;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleCommandHistoryLengthW(
    IN LPWSTR ExeName
    )
{
    return GetConsoleCommandHistoryLengthInternal(ExeName,
                                                  TRUE
                                                 );
}

DWORD
GetConsoleCommandHistoryLengthA(
    IN LPTSTR ExeName
    )
{
    return GetConsoleCommandHistoryLengthInternal(ExeName,
                                                  FALSE
                                                 );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleCommandHistoryInternal(
    OUT LPVOID Commands,
    IN DWORD CommandBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETCOMMANDHISTORY_MSG a = &m.u.GetConsoleCommandHistoryW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->CommandBufferLength = CommandBufferLength;
    a->ExeLength = GetExeName(ExeName, Unicode, &a->UnicodeExe);
    a->Unicode = Unicode;
    if (a->ExeLength == 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer(2, CommandBufferLength + a->ExeLength);
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }


    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->CommandBufferLength,
                             (PVOID *) &a->CommandBuffer
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCommandHistory
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( Commands, a->CommandBuffer, a->CommandBufferLength );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
        CsrFreeCaptureBuffer( CaptureBuffer );
        return a->CommandBufferLength;
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleCommandHistoryW(
    OUT LPWSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPWSTR ExeName
    )
{
    return GetConsoleCommandHistoryInternal(Commands,
                                            CommandBufferLength,
                                            ExeName,
                                            TRUE
                                           );
}

DWORD
GetConsoleCommandHistoryA(
    OUT LPTSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPTSTR ExeName
    )
{
    return GetConsoleCommandHistoryInternal(Commands,
                                            CommandBufferLength,
                                            ExeName,
                                            FALSE
                                           );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
SetConsoleCommandHistoryMode(
    IN DWORD Flags
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETCOMMANDHISTORYMODE_MSG a = &m.u.SetConsoleCommandHistoryMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Flags = Flags;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCommandHistoryMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
}

DWORD
APIENTRY
GetConsoleTitleInternal(
    OUT PVOID lpConsoleTitle,
    IN DWORD nSize,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETTITLE_MSG a = &m.u.GetConsoleTitle;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    if (nSize == 0) {
        return 0;
    }
    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->TitleLength = nSize;
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->TitleLength
                                            );
    if (CaptureBuffer == NULL) {
        return 0;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             a->TitleLength,
                             (PVOID *) &a->Title
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetTitle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( lpConsoleTitle, a->Title, a->TitleLength);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
    }
    else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR (m.ReturnValue);
        return 0;
    }
    CsrFreeCaptureBuffer( CaptureBuffer );
    return a->TitleLength;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize
    )
{
    DWORD NumBytes;
    NumBytes = GetConsoleTitleInternal(lpConsoleTitle,
                                   nSize-sizeof(CHAR), // allow room for null
                                   FALSE
                                  );
    if (NumBytes) {
        lpConsoleTitle[NumBytes] = '\0';   // NULL terminate
    }
    return NumBytes;
}

DWORD
APIENTRY
GetConsoleTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize
    )
{
    DWORD NumBytes;
    NumBytes = GetConsoleTitleInternal(lpConsoleTitle,
                                   (nSize-1)*sizeof(WCHAR), // allow room for null
                                   TRUE
                                  );
    if (NumBytes) {
        NumBytes /= sizeof(WCHAR);
        lpConsoleTitle[NumBytes] = CONSOLE_NAME_PATH_TERMINATOR;   // NULL terminate
    }
    return NumBytes;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
SetConsoleTitleInternal(
    IN CONST VOID *lpConsoleTitle,
    IN DWORD TitleLength,  // in bytes
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETTITLE_MSG a = &m.u.SetConsoleTitle;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->TitleLength = TitleLength;
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->TitleLength
                                            );
    if (CaptureBuffer == NULL) {
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) lpConsoleTitle,
                             a->TitleLength,
                             (PVOID *) &a->Title
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetTitle
                                            ),
                         sizeof( *a )
                       );

    CsrFreeCaptureBuffer( CaptureBuffer );

    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    }
    else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
SetConsoleTitleA(
    LPCSTR lpConsoleTitle
    )
{
    DWORD TitleLength;
    try {
        TitleLength = strlen(lpConsoleTitle);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return SetConsoleTitleInternal(lpConsoleTitle,
                                   TitleLength,
                                   FALSE);
}

BOOL
APIENTRY
SetConsoleTitleW(
    LPCWSTR lpConsoleTitle
    )
{
    DWORD TitleLength;
    try {
        TitleLength = wcslen(lpConsoleTitle)*sizeof(WCHAR);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return SetConsoleTitleInternal(lpConsoleTitle,
                                   TitleLength,
                                   TRUE);
}


DWORD
GetConsoleInputExeNameA(
    IN DWORD nBufferLength,
    OUT LPSTR lpBuffer
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WCHAR TempExeNameBuffer[FNAME_LENGTH];
    DWORD n;

    n = GetConsoleInputExeNameW(FNAME_LENGTH, TempExeNameBuffer);
    if (n != 0 && n < FNAME_LENGTH) {
        RtlInitUnicodeString(&UnicodeString, TempExeNameBuffer);
        AnsiString.Buffer = lpBuffer;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = (USHORT)nBufferLength;
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_BUFFER_OVERFLOW) {
                SET_LAST_ERROR(ERROR_BUFFER_OVERFLOW);
                return n+1;
            } else {
                SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
            }
        }
    }
    return n;
}

DWORD
GetConsoleInputExeNameW(
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer
    )
{
    DWORD n;

    n = ExeNameLength;
    if (n >= nBufferLength) {
        SET_LAST_ERROR(ERROR_BUFFER_OVERFLOW);
        return n+1;
    }

    try {
        RtlEnterCriticalSection(&ExeNameCriticalSection);
        RtlCopyMemory(lpBuffer, ExeNameBuffer, n*sizeof(WCHAR));
        lpBuffer[n] = UNICODE_NULL;
    } finally {
        RtlLeaveCriticalSection(&ExeNameCriticalSection);
    }

    return TRUE;
}

BOOL
SetConsoleInputExeNameA(
    IN LPSTR lpExeName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpExeName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            SET_LAST_ERROR(ERROR_FILENAME_EXCED_RANGE);
        } else {
            SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        }
        return FALSE;
    }

    return SetConsoleInputExeNameW(Unicode->Buffer);
}

BOOL
SetConsoleInputExeNameW(
    IN LPWSTR lpExeName
    )
{
    DWORD n;

    n = lstrlenW(lpExeName);
    if (n == 0 || n >= FNAME_LENGTH) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlEnterCriticalSection(&ExeNameCriticalSection);
    try {
        RtlCopyMemory(ExeNameBuffer,lpExeName,n*sizeof(WCHAR));
        ExeNameLength = (USHORT)n;
    } finally {
        RtlLeaveCriticalSection(&ExeNameCriticalSection);
    }

    return TRUE;
}

#endif //!defined(BUILD_WOW64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\getset.c ===
//depot/lab01_n/windows/Core/ntcon/client/getset.c#5 - integrate change 19598 (text)
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    getset.c

Abstract:

    This module contains the stubs for the console get/set API.

Author:

    Therese Stowell (thereses) 14-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
GetConsoleMode(
    IN HANDLE hConsoleHandle,
    OUT LPDWORD lpMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpMode - Supplies a pointer to a dword in which to store the mode.

        Input Mode Flags:

            ENABLE_LINE_INPUT - line oriented input is on.

            ENABLE_ECHO_INPUT - characters will be written to the screen as they are
                read.

            ENABLE_WINDOW_INPUT - the caller is windows-aware

        Output Mode Flags:

            ENABLE_LINE_OUTPUT - line oriented output is on.

            ENABLE_WRAP_AT_EOL_OUTPUT - the cursor will move to the
                beginning of the next line when the end of the row
                is reached.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_MODE_MSG a = &m.u.GetConsoleMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpMode = a->Mode;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

DWORD
WINAPI
GetNumberOfConsoleFonts(
    VOID
    )

/*++

Parameters:

    none.

Return Value:

    NON-NULL - Returns the number of fonts available.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETNUMBEROFFONTS_MSG a = &m.u.GetNumberOfConsoleFonts;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetNumberOfFonts
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->NumberOfFonts;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
WINAPI
GetNumberOfConsoleInputEvents(
    IN HANDLE hConsoleInput,
    OUT LPDWORD lpNumberOfEvents
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

    lpNumberOfEvents - Pointer to number of events in input buffer.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG a = &m.u.GetNumberOfConsoleInputEvents;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetNumberOfInputEvents
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpNumberOfEvents = a->ReadyEvents;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }
    else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

COORD
WINAPI
GetLargestConsoleWindowSize(
    IN HANDLE hConsoleOutput
    )

/*++

    Returns largest window possible, given the current font.  The return value
    does not take the screen buffer size into account.

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

Return Value:

    The return value is the maximum window size in rows and columns.  A size
    of zero will be returned if an error occurs.  Extended error information
    can be retrieved by calling the GetLastError function.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETLARGESTWINDOWSIZE_MSG a = &m.u.GetLargestConsoleWindowSize;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetLargestWindowSize
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->Size;
    } else {
        COORD Dummy;
        Dummy.X = Dummy.Y = 0;
        SET_LAST_NT_ERROR (m.ReturnValue);
        return Dummy;
    }

}


BOOL
WINAPI
GetConsoleScreenBufferInfo(
    IN HANDLE hConsoleOutput,
    OUT PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleScreenBufferInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETSCREENBUFFERINFO_MSG a = &m.u.GetConsoleScreenBufferInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetScreenBufferInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            lpConsoleScreenBufferInfo->dwSize =              a->Size;
            lpConsoleScreenBufferInfo->dwCursorPosition =    a->CursorPosition;
            lpConsoleScreenBufferInfo->wAttributes =         a->Attributes;
            lpConsoleScreenBufferInfo->srWindow.Left = a->ScrollPosition.X;
            lpConsoleScreenBufferInfo->srWindow.Top = a->ScrollPosition.Y;
            lpConsoleScreenBufferInfo->srWindow.Right = lpConsoleScreenBufferInfo->srWindow.Left + a->CurrentWindowSize.X-1;
            lpConsoleScreenBufferInfo->srWindow.Bottom = lpConsoleScreenBufferInfo->srWindow.Top + a->CurrentWindowSize.Y-1;
            lpConsoleScreenBufferInfo->dwMaximumWindowSize = a->MaximumWindowSize;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
GetConsoleCursorInfo(
    IN HANDLE hConsoleOutput,
    OUT PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleCursorInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCURSORINFO_MSG a = &m.u.GetConsoleCursorInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCursorInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            lpConsoleCursorInfo->dwSize = a->CursorSize;
            lpConsoleCursorInfo->bVisible = a->Visible;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
GetConsoleSelectionInfo(
    OUT PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    )

/*++

Parameters:

    lpConsoleSelectionInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
            using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETSELECTIONINFO_MSG a = &m.u.GetConsoleSelectionInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetSelectionInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpConsoleSelectionInfo = a->SelectionInfo;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }
}

BOOL
WINAPI
GetNumberOfConsoleMouseButtons(
    OUT LPDWORD lpNumberOfMouseButtons
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

    lpNumberOfMouseButtons - pointer to the number of mouse buttons

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETMOUSEINFO_MSG a = &m.u.GetConsoleMouseInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetMouseInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpNumberOfMouseButtons = a->NumButtons;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

DWORD
WINAPI
GetConsoleFontInfo(
    IN HANDLE hConsoleOutput,
    IN BOOL bMaximumWindow,
    IN DWORD nLength,
    OUT PCONSOLE_FONT_INFO lpConsoleFontInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    bMaximumWindow - TRUE if caller wants available fonts for the maximum
        window size.  FALSE if caller wants available fonts for the current
        window size.

    nLength - Length of buffer in CONSOLE_FONT_INFOs.

    lpConsoleFontInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    NON-NULL - Returns the number of fonts returned in lpConsoleFontInfo.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETFONTINFO_MSG a = &m.u.GetConsoleFontInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->MaximumWindow = (BOOLEAN) bMaximumWindow;
    a->NumFonts = nLength;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              nLength * sizeof(CONSOLE_FONT_INFO)
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             nLength * sizeof(CONSOLE_FONT_INFO),
                             (PVOID *) &a->BufPtr
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetFontInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( lpConsoleFontInfo, a->BufPtr, a->NumFonts * sizeof(CONSOLE_FONT_INFO));
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
    }
    else {
        SET_LAST_NT_ERROR (m.ReturnValue);
    }
    CsrFreeCaptureBuffer( CaptureBuffer );
    return a->NumFonts;

}

COORD
WINAPI
GetConsoleFontSize(
    IN HANDLE hConsoleOutput,
    IN DWORD nFont
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    nFont - Supplies the index of the font to return the size of.

Return Value:

    The return value is the height and width of each character in the font.
    X field contains width. Y field contains height. Font size
    is expressed in pixels.  If both the x and y sizes are 0, the function
    was unsuccessful.  Extended error information can be retrieved by calling
    the GetLastError function.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETFONTSIZE_MSG a = &m.u.GetConsoleFontSize;
    COORD Dummy;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->FontIndex = nFont;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetFontSize
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->FontSize;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        Dummy.X = Dummy.Y = 0;
        return Dummy;
    }

}

BOOL
WINAPI
GetCurrentConsoleFont(
    IN HANDLE hConsoleOutput,
    IN BOOL bMaximumWindow,
    OUT PCONSOLE_FONT_INFO lpConsoleCurrentFont
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    bMaximumWindow - TRUE if caller wants current font for the maximum
        window size.  FALSE if caller wants current font for the current
        window size.

    lpConsoleCurrentFont - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCURRENTFONT_MSG a = &m.u.GetCurrentConsoleFont;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->MaximumWindow = (BOOLEAN) bMaximumWindow;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCurrentFont
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            lpConsoleCurrentFont->dwFontSize = a->FontSize;
            lpConsoleCurrentFont->nFont = a->FontIndex;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleMode(
    IN HANDLE hConsoleHandle,
    IN DWORD dwMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    dwMode - Supplies mode.

        Input Mode Flags:

            ENABLE_LINE_INPUT - line oriented input is on.

            ENABLE_ECHO_INPUT - characters will be written to the screen as they are
                read.

            ENABLE_WINDOW_INPUT - the caller is windows-aware

        Output Mode Flags:

            ENABLE_LINE_OUTPUT - line oriented output is on.

            ENABLE_WRAP_AT_EOL_OUTPUT - the cursor will move to the
                beginning of the next line when the end of the row
                is reached.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_MODE_MSG a = &m.u.SetConsoleMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->Mode = dwMode;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
GenerateConsoleCtrlEvent(
    IN DWORD dwCtrlEvent,
    IN DWORD dwProcessGroupId
    )

/*++

Parameters:

    dwCtrlEvent - Supplies event(s) to generate.

    dwProcessGroupId - Supplies id of process group to generate
                  event for.  Event will be generated in each
                  process with that id within the console.  If 0,
                  specified event will be generated in all processes
                  within the console.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CTRLEVENT_MSG a = &m.u.GenerateConsoleCtrlEvent;

    //
    // Check for valid Ctrl Events
    //

    if ((dwCtrlEvent != CTRL_C_EVENT) && (dwCtrlEvent != CTRL_BREAK_EVENT)) {
        SET_LAST_ERROR (ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->CtrlEvent = dwCtrlEvent;
    a->ProcessGroupId = dwProcessGroupId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGenerateCtrlEvent
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleActiveScreenBuffer(
    IN HANDLE hConsoleOutput
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.  The screen
        buffer attached to this handle becomes the displayed screen buffer.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETACTIVESCREENBUFFER_MSG a = &m.u.SetConsoleActiveScreenBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetActiveScreenBuffer
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
WINAPI
FlushConsoleInputBuffer(
    IN HANDLE hConsoleInput
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_FLUSHINPUTBUFFER_MSG a = &m.u.FlushConsoleInputBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepFlushInputBuffer
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
WINAPI
SetConsoleScreenBufferSize(
    IN HANDLE hConsoleOutput,
    IN COORD dwSize
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

    dwSize - New size of screen buffer in rows and columns

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETSCREENBUFFERSIZE_MSG a = &m.u.SetConsoleScreenBufferSize;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Size = dwSize;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetScreenBufferSize
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }


}

BOOL
WINAPI
SetConsoleCursorPosition(
    IN HANDLE hConsoleOutput,
    IN COORD dwCursorPosition
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    dwCursorPosition - Position of cursor in screen buffer

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCURSORPOSITION_MSG a = &m.u.SetConsoleCursorPosition;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->CursorPosition = dwCursorPosition;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursorPosition
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }


}

BOOL
WINAPI
SetConsoleCursorInfo(
    IN HANDLE hConsoleOutput,
    IN CONST CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleCursorOrigin - A pointer to a buffer containing the data
        to set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCURSORINFO_MSG a = &m.u.SetConsoleCursorInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    try {
        a->CursorSize = lpConsoleCursorInfo->dwSize;
        a->Visible = (BOOLEAN) lpConsoleCursorInfo->bVisible;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursorInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleWindowInfo(
    IN HANDLE hConsoleOutput,
    IN BOOL bAbsolute,
    IN CONST SMALL_RECT *lpConsoleWindow
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleWindow - A pointer to a rectangle containing the new
        dimensions of the console window in screen buffer coordinates.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETWINDOWINFO_MSG a = &m.u.SetConsoleWindowInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Absolute = bAbsolute;
    try {
        a->Window = *lpConsoleWindow;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetWindowInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
ScrollConsoleScreenBufferInternal(
    IN HANDLE hConsoleOutput,
    IN CONST SMALL_RECT *lpScrollRectangle,
    IN CONST SMALL_RECT *lpClipRectangle,
    IN COORD dwDestinationOrigin,
    IN CONST CHAR_INFO *lpFill,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpScrollRectangle - Pointer to region within screen buffer to move.

    lpClipRectangle -  Pointer to region within screen buffer that may be
        affected by this scroll.  This pointer may be NULL.

    dwDestinationOrigin - Upper left corner of new location of ScrollRectangle
        contents.

    lpFill - Pointer to structure containing new contents of ScrollRectangle region.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SCROLLSCREENBUFFER_MSG a = &m.u.ScrollConsoleScreenBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Unicode = Unicode;
    try {
        a->ScrollRectangle = *lpScrollRectangle;
        if (lpClipRectangle != NULL) {
            a->Clip = TRUE;
            a->ClipRectangle = *lpClipRectangle;
        }
        else {
            a->Clip = FALSE;
        }
        a->Fill = *lpFill;
        a->DestinationOrigin = dwDestinationOrigin;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepScrollScreenBuffer
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ScrollConsoleScreenBufferA(
    HANDLE hConsoleOutput,
    CONST SMALL_RECT *lpScrollRectangle,
    CONST SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    CONST CHAR_INFO *lpFill
    )
{
    return ScrollConsoleScreenBufferInternal(hConsoleOutput,
                                      lpScrollRectangle,
                                      lpClipRectangle,
                                      dwDestinationOrigin,
                                      lpFill,
                                      FALSE);
}

BOOL
APIENTRY
ScrollConsoleScreenBufferW(
    HANDLE hConsoleOutput,
    CONST SMALL_RECT *lpScrollRectangle,
    CONST SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    CONST CHAR_INFO *lpFill
    )
{
    return ScrollConsoleScreenBufferInternal(hConsoleOutput,
                                      lpScrollRectangle,
                                      lpClipRectangle,
                                      dwDestinationOrigin,
                                      lpFill,
                                      TRUE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
SetConsoleTextAttribute(
    IN HANDLE hConsoleOutput,
    IN WORD wAttributes
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    wAttributes - Character display attributes.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETTEXTATTRIBUTE_MSG a = &m.u.SetConsoleTextAttribute;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Attributes = wAttributes;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetTextAttribute
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleFont(
    IN HANDLE hConsoleOutput,
    IN DWORD nFont
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    nFont - Number of font to set as current font

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETFONT_MSG a = &m.u.SetConsoleFont;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->FontIndex = nFont;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetFont
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleIcon(
    IN HICON hIcon
    )

/*++

Parameters:

    hIcon - Supplies an icon handle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETICON_MSG a = &m.u.SetConsoleIcon;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->hIcon = hIcon;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetIcon
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
SetConsoleMaximumWindowSize(
    HANDLE hConsoleOutput,
    COORD dwWindowSize
    )
{
    UNREFERENCED_PARAMETER(hConsoleOutput);
    UNREFERENCED_PARAMETER(dwWindowSize);

    return TRUE;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

UINT
WINAPI
GetConsoleCP( VOID )

/**++

Parameters:

    none

Return Value:

    The code page id of the current console.  a null return value
    indicates failure.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCP_MSG a = &m.u.GetConsoleCP;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = FALSE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCP
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->wCodePageID;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleCP(
    IN UINT wCodePageID
    )

/**++

Parameters:

    wCodePageID - the code page is to set for the current console.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCP_MSG a = &m.u.SetConsoleCP;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = FALSE;
    a->wCodePageID = wCodePageID;
#if defined(FE_SB)
    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }
#endif
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCP
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
#if defined(FE_SB)
        NTSTATUS Status;

        Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
        NtClose(a->hEvent);
        if (Status != 0) {
            SET_LAST_NT_ERROR(Status);
            return FALSE;
        }
#endif
        return TRUE;
    } else {
#if defined(FE_SB)
        NtClose(a->hEvent);
#endif
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


UINT
WINAPI
GetConsoleOutputCP( VOID )

/**++

Parameters:

    none

Return Value:

    The code page id of the current console output.  a null return value
    indicates failure.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCP_MSG a = &m.u.GetConsoleCP;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = TRUE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCP
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->wCodePageID;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

NTSTATUS
APIENTRY
SetConsoleOutputCPInternal(
    IN UINT wCodePageID
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETCP_MSG a = &m.u.SetConsoleCP;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = TRUE;
    a->wCodePageID = wCodePageID;
#if defined(FE_SB)
    a->hEvent = NULL;
#endif

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCP
                                            ),
                         sizeof( *a )
                       );

    return m.ReturnValue;
}

#endif //!defined(BUILD_WOW6432)


#if !defined(BUILD_WOW64)

BOOL
WINAPI
SetConsoleOutputCP(
    IN UINT wCodePageID
    )

/**++

Parameters:

    wCodePageID - the code page is to set for the current console output.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    NTSTATUS Status;

    Status = SetConsoleOutputCPInternal(wCodePageID);

    if(NT_SUCCESS(Status)) {
        SetTEBLangID();
        return TRUE;
    }
    else {
        SET_LAST_NT_ERROR (Status);
        return FALSE;
    }
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleKeyboardLayoutNameWorker(
    OUT LPSTR pszLayout,
    IN BOOL bAnsi)

/**++

Parameters:

    pszLayout  - address of buffer of least 9 characters
    bAnsi      - TRUE  want ANSI (8-bit) chars
                 FALSE want Unicode (16-bit) chars

Return Value:

    TRUE  - success
    FALSE - failure

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG a = &m.u.GetKeyboardLayoutName;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->bAnsi = bAnsi;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetKeyboardLayoutName
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        if (bAnsi) {
           strncpy(pszLayout, a->achLayout, 9);
        } else {
           wcsncpy((LPWSTR)pszLayout, a->awchLayout, 9);
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


#endif //!defined(BUILD_WOW6432)


#if !defined(BUILD_WOW64)

BOOL
GetConsoleKeyboardLayoutNameA(
    LPSTR pszLayout)
{
    return GetConsoleKeyboardLayoutNameWorker(pszLayout, TRUE);
}

BOOL
GetConsoleKeyboardLayoutNameW(
    LPWSTR pwszLayout)
{
    return GetConsoleKeyboardLayoutNameWorker((LPSTR)pwszLayout, FALSE);
}

#endif // !defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

HWND
APIENTRY
GetConsoleWindow(
    VOID)
{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCONSOLEWINDOW_MSG a = &m.u.GetConsoleWindow;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetConsoleWindow
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->hwnd;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return NULL;
    }

}

DWORD
APIENTRY
GetConsoleProcessList(
    OUT LPDWORD lpdwProcessList,
    IN DWORD dwProcessCount)
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETCONSOLEPROCESSLIST_MSG a = &m.u.GetConsoleProcessList;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    if (dwProcessCount == 0 || lpdwProcessList == NULL) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->dwProcessCount = dwProcessCount;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              dwProcessCount * sizeof(DWORD)
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             dwProcessCount * sizeof(DWORD),
                             (PVOID *) &a->lpdwProcessList
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetConsoleProcessList
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS(m.ReturnValue)) {
        if (dwProcessCount >= a->dwProcessCount) {
            try {
                RtlCopyMemory(lpdwProcessList, a->lpdwProcessList, a->dwProcessCount * sizeof(DWORD));
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                CsrFreeCaptureBuffer( CaptureBuffer );
                SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                return 0;
            }
        }
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR (m.ReturnValue);
        return 0;
    }

    CsrFreeCaptureBuffer( CaptureBuffer );

    return a->dwProcessCount;
}

#endif // !defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\ntwow64c.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ntwow64c.h

Abstract:

    Helper functions inplemented in wow64.

Author:

    21-Sept-1998 BarryBo

Revision History:

--*/

HANDLE
Wow64GetConsoleHandle(
    VOID
    );

VOID
Wow64SetConsoleHandle(
    HANDLE hHandle
    );

VOID
Wow64SetLastError(
    DWORD dwError
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\precomp.h ===
#include "condll.h"
#include <windows.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winbasep.h>
#include <winconp.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\sources.inc ===
W32_SB=1

MAJORCOMP=windows
MINORCOMP=console

TARGETNAME=conlibk
TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBDIR)}
TARGETTYPE=LIBRARY

INCLUDES=..;                    \
   ..\..\inc;                   \
   $(WINCORE_PATH)\w32inc;      \
   $(WINCORE_PATH)\w32inc\$(O); \
   $(BASE_INC_PATH)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -D_KERNEL32_

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

# No overflow checking in kernel32.dll
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\dllinit.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module implements console dll initialization

Author:

    Therese Stowell (thereses) 11-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if !defined(BUILD_WOW64)

#include <cpl.h>

#define DEFAULT_WINDOW_TITLE (L"Command Prompt")

extern HANDLE InputWaitHandle;
extern WCHAR ExeNameBuffer[];
extern USHORT ExeNameLength;
extern WCHAR StartDirBuffer[];
extern USHORT StartDirLength;

DWORD
CtrlRoutine(
    IN LPVOID lpThreadParameter
    );

DWORD
PropRoutine(
    IN LPVOID lpThreadParameter
    );

#if defined(FE_SB)
#if defined(FE_IME)
DWORD
ConsoleIMERoutine(
    IN LPVOID lpThreadParameter
    );
#endif // FE_IME
#endif // FE_SB


#define MAX_SESSION_PATH   256
#define SESSION_ROOT       L"\\Sessions"

BOOLEAN
ConsoleApp( VOID )

/*++

    This routine determines whether the current process is a console or
    windows app.

Parameters:

    none.

Return Value:

    TRUE if console app.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = RtlImageNtHeader(GetModuleHandle(NULL));
    return ((NtHeaders != NULL) &&
            (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)) ? TRUE : FALSE;
}


VOID
SetUpAppName(
    IN OUT LPDWORD CurDirLength,
    OUT LPWSTR CurDir,
    IN OUT LPDWORD AppNameLength,
    OUT LPWSTR AppName
    )
{
    DWORD Length;

    *CurDirLength -= sizeof(WCHAR);
    Length = (StartDirLength*sizeof(WCHAR)) > *CurDirLength ? *CurDirLength : (StartDirLength*sizeof(WCHAR));
    RtlCopyMemory(CurDir,StartDirBuffer,Length+sizeof(WCHAR));
    *CurDirLength = Length + sizeof(WCHAR);   // add terminating NULL

    *AppNameLength -= sizeof(WCHAR);
    Length = (ExeNameLength*sizeof(WCHAR)) > *AppNameLength ? *AppNameLength : (ExeNameLength*sizeof(WCHAR));
    RtlCopyMemory(AppName,ExeNameBuffer,Length+sizeof(WCHAR));
    *AppNameLength = Length + sizeof(WCHAR);   // add terminating NULL
}


ULONG
ParseReserved(
    WCHAR *pchReserved,
    WCHAR *pchFind
    )
{
    ULONG dw;
    WCHAR *pch, *pchT, ch;
    UNICODE_STRING uString;

    dw = 0;
    if ((pch = wcsstr(pchReserved, pchFind)) != NULL) {
        pch += lstrlenW(pchFind);

        pchT = pch;
        while (*pchT >= '0' && *pchT <= '9')
            pchT++;

        ch = *pchT;
        *pchT = 0;
        RtlInitUnicodeString(&uString, pch);
        *pchT = ch;

        RtlUnicodeStringToInteger(&uString, 0, &dw);
    }

    return dw;
}


VOID
SetUpConsoleInfo(
    IN BOOL DllInit,
    OUT LPDWORD TitleLength,
    OUT LPWSTR Title OPTIONAL,
    OUT LPDWORD DesktopLength,
    OUT LPWSTR *Desktop OPTIONAL,
    OUT PCONSOLE_INFO ConsoleInfo
    )

/*++

    This routine fills in the ConsoleInfo structure with the values
    specified by the user.

Parameters:

    ConsoleInfo - pointer to structure to fill in.

Return Value:

    none.

--*/

{
    STARTUPINFOW StartupInfo;
    HANDLE h;
    int id;
    HANDLE ghInstance;
    BOOL Success;


    GetStartupInfoW(&StartupInfo);
    ghInstance = (HANDLE)((PVOID)NtCurrentPeb()->ImageBaseAddress );

    // these will eventually be filled in using menu input

    ConsoleInfo->nFont = 0;
    ConsoleInfo->nInputBufferSize = 0;
    ConsoleInfo->hIcon = NULL;
    ConsoleInfo->hSmIcon = NULL;
    ConsoleInfo->iIconId = 0;
    ConsoleInfo->dwStartupFlags = StartupInfo.dwFlags;
#if defined(FE_SB)
    ConsoleInfo->uCodePage = GetOEMCP();
#endif
    if (StartupInfo.lpTitle == NULL) {
        StartupInfo.lpTitle = DEFAULT_WINDOW_TITLE;
    }

    //
    // if the desktop name was specified, set up the pointers.
    //

    if (DllInit && Desktop != NULL &&
            StartupInfo.lpDesktop != NULL && *StartupInfo.lpDesktop != 0) {
        *DesktopLength = (lstrlenW(StartupInfo.lpDesktop) + 1) * sizeof(WCHAR);
        *Desktop = StartupInfo.lpDesktop;
    } else {
        *DesktopLength = 0;
        if (Desktop != NULL)
            *Desktop = NULL;
    }

    // Nope, do normal initialization (TitleLength is in BYTES, not CHARS!)
    *TitleLength = (USHORT)((lstrlenW(StartupInfo.lpTitle)+1)*sizeof(WCHAR));
    *TitleLength = (USHORT)(min(*TitleLength,MAX_TITLE_LENGTH));
    if (DllInit) {
        RtlCopyMemory(Title,StartupInfo.lpTitle,*TitleLength);
        // ensure the title is NULL terminated
        if (*TitleLength == MAX_TITLE_LENGTH)
            Title[ (MAX_TITLE_LENGTH/sizeof(WCHAR)) - 1 ] = L'\0';
    }

    if (StartupInfo.dwFlags & STARTF_USESHOWWINDOW) {
        ConsoleInfo->wShowWindow = StartupInfo.wShowWindow;
    }
    if (StartupInfo.dwFlags & STARTF_USEFILLATTRIBUTE) {
        ConsoleInfo->wFillAttribute = (WORD)StartupInfo.dwFillAttribute;
    }
    if (StartupInfo.dwFlags & STARTF_USECOUNTCHARS) {
        ConsoleInfo->dwScreenBufferSize.X = (WORD)(StartupInfo.dwXCountChars);
        ConsoleInfo->dwScreenBufferSize.Y = (WORD)(StartupInfo.dwYCountChars);
    }
    if (StartupInfo.dwFlags & STARTF_USESIZE) {
        ConsoleInfo->dwWindowSize.X = (WORD)(StartupInfo.dwXSize);
        ConsoleInfo->dwWindowSize.Y = (WORD)(StartupInfo.dwYSize);
    }
    if (StartupInfo.dwFlags & STARTF_USEPOSITION) {
        ConsoleInfo->dwWindowOrigin.X = (WORD)(StartupInfo.dwX);
        ConsoleInfo->dwWindowOrigin.Y = (WORD)(StartupInfo.dwY);
    }

    //
    // Grab information passed on lpReserved line...
    //

    if (StartupInfo.lpReserved != 0) {

        //
        // the program manager has an icon for the exe.  store the
        // index in the iIconId field.
        //

        ConsoleInfo->iIconId = ParseReserved(StartupInfo.lpReserved, L"dde.");

        //
        // The new "Chicago" way of doing things is to pass the hotkey in the
        // hStdInput field and set the STARTF_USEHOTKEY flag.  So, if this is
        // specified, we get the hotkey from there instead
        //

        if (StartupInfo.dwFlags & STARTF_USEHOTKEY) {
            ConsoleInfo->dwHotKey = HandleToUlong(StartupInfo.hStdInput);
        } else {
            ConsoleInfo->dwHotKey = ParseReserved(StartupInfo.lpReserved, L"hotkey.");
        }
    }

}

VOID
SetUpHandles(
    IN PCONSOLE_INFO ConsoleInfo
    )

/*++

    This routine sets up the console and std* handles for the process.

Parameters:

    ConsoleInfo - pointer to structure containing handles.

Return Value:

    none.

--*/

{
    if (ConsoleInfo->dwStartupFlags & STARTF_USEHOTKEY) {
        NtCurrentPeb()->ProcessParameters->WindowFlags &= ~STARTF_USEHOTKEY;
    }

    if (ConsoleInfo->dwStartupFlags & STARTF_HASSHELLDATA) {
        NtCurrentPeb()->ProcessParameters->WindowFlags &= ~STARTF_HASSHELLDATA;
    }

    SET_CONSOLE_HANDLE(ConsoleInfo->ConsoleHandle);

    if (!(ConsoleInfo->dwStartupFlags & STARTF_USESTDHANDLES)) {
        SetStdHandle(STD_INPUT_HANDLE,ConsoleInfo->StdIn);
        SetStdHandle(STD_OUTPUT_HANDLE,ConsoleInfo->StdOut);
        SetStdHandle(STD_ERROR_HANDLE,ConsoleInfo->StdErr);
    }
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
GetConsoleLangId(
    OUT LANGID *lpLangId
    )

/*++

Parameters:

    lpLangId - Supplies a pointer to a LANGID in which to store the Language ID.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_LANGID_MSG a = &m.u.GetConsoleLangId;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetLangId
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpLangId = a->LangId;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            return FALSE;
        }
        return TRUE;
    } else {
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

VOID
SetTEBLangID(
    VOID
    )

/*++

    Sets the Language Id in the TEB to Far East if code page CP are
    Japanese/Korean/Chinese.  This is done in order for FormatMessage
    to display any Far East character when cmd is running in its code page.
    All messages displayed in non-FE code page will be displayed in English.

--*/

{
    LANGID LangId;

    if (GetConsoleLangId(&LangId)) {
        SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    }
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
ConnectConsoleInternal(IN PWSTR pObjectDirectory,
                       IN OUT PCONSOLE_API_CONNECTINFO pConnectInfo,
                       OUT PBOOLEAN pServerProcess
                      )
/*++

Routine Description:

    Helper function for establishing a connection with the console server.
    Waits for the server to signal completion.

Arguments:

    pObjectDirectory -  Supplies a null terminated string that is the same
        as the value of the ObjectDirectory= argument passed to the CSRSS
        program.

    pConnectInfo - Supplies and recieves the connection information.

    pServerProcess - Recieves TRUE if this is a server process.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/
{

   NTSTATUS Status;
   ULONG ConnectionInformationLength = sizeof(CONSOLE_API_CONNECTINFO);

   Status = CsrClientConnectToServer( pObjectDirectory,
                                      CONSRV_SERVERDLL_INDEX,
                                      pConnectInfo,
                                      &ConnectionInformationLength,
                                      pServerProcess
                                    );

   if (!NT_SUCCESS( Status )) {
       return FALSE;
   }

   //
   // we return success although no console api can be called because
   // loading shouldn't fail.  we'll fail the api calls later.
   //

   if (*pServerProcess) {
       return TRUE;
   }


   //
   // if this is not a console app, return success - nothing else to do.
   //

   if (!pConnectInfo->ConsoleApp) {
       return TRUE;
   }

   //
   // wait for initialization to complete.  we have to use the NT
   // wait because the heap hasn't been initialized yet.
   //

   Status = NtWaitForMultipleObjects(NUMBER_OF_INITIALIZATION_EVENTS,
                                        pConnectInfo->ConsoleInfo.InitEvents,
                                        WaitAny,
                                        FALSE,
                                        NULL
                                        );

   if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
   }

   NtClose(pConnectInfo->ConsoleInfo.InitEvents[INITIALIZATION_SUCCEEDED]);
   NtClose(pConnectInfo->ConsoleInfo.InitEvents[INITIALIZATION_FAILED]);
   if (Status != INITIALIZATION_SUCCEEDED) {
       SET_CONSOLE_HANDLE(NULL);
       return FALSE;
   }

   return TRUE;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOLEAN
ConDllInitialize(
    IN ULONG Reason,
    IN PWSTR pObjectDirectory OPTIONAL
    )

/*++

Routine Description:

    This function implements console dll initialization.

Arguments:

    Reason - DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, etc.

    pObjectDiretory - Session directory name; only valid/required when
                      Reason == DLL_PROCESS_ATTACH.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL bStatus;
    BOOLEAN ServerProcess;

    //
    // if we're attaching the DLL, we need to connect to the server.
    // if no console exists, we also need to create it and set up stdin,
    // stdout, and stderr.
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        CONSOLE_API_CONNECTINFO ConnectionInformation;

        //
        // Remember in the connect information if this app is a console
        // app. need to actually connect to the console server for windowed
        // apps so that we know NOT to do any special work during
        // ConsoleClientDisconnectRoutine(). Store ConsoleApp info in the
        // CSR managed per-process data.
        //

        Status = RtlInitializeCriticalSection(&DllLock);
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        ConnectionInformation.CtrlRoutine = CtrlRoutine;
        ConnectionInformation.PropRoutine = PropRoutine;
#if defined(FE_SB)
#if defined(FE_IME)
        ConnectionInformation.ConsoleIMERoutine = ConsoleIMERoutine;
#endif // FE_IME
#endif // FE_SB

        ConnectionInformation.WindowVisible = TRUE;
        ConnectionInformation.ConsoleApp = ConsoleApp();
        if (GET_CONSOLE_HANDLE == CONSOLE_DETACHED_PROCESS) {
            SET_CONSOLE_HANDLE(NULL);
            ConnectionInformation.ConsoleApp = FALSE;
        } else if (GET_CONSOLE_HANDLE == CONSOLE_NEW_CONSOLE) {
            SET_CONSOLE_HANDLE(NULL);
        } else if (GET_CONSOLE_HANDLE == CONSOLE_CREATE_NO_WINDOW) {
            SET_CONSOLE_HANDLE(NULL);
            ConnectionInformation.WindowVisible = FALSE;
        }
        if (!ConnectionInformation.ConsoleApp) {
            SET_CONSOLE_HANDLE(NULL);
        }
        ConnectionInformation.ConsoleInfo.ConsoleHandle = GET_CONSOLE_HANDLE;

        //
        // if no console exists, pass parameters for console creation
        //

        if (GET_CONSOLE_HANDLE == NULL && ConnectionInformation.ConsoleApp) {
            SetUpConsoleInfo(TRUE,
                             &ConnectionInformation.TitleLength,
                             ConnectionInformation.Title,
                             &ConnectionInformation.DesktopLength,
                             &ConnectionInformation.Desktop,
                             &ConnectionInformation.ConsoleInfo);
        } else {
            ConnectionInformation.TitleLength = 0;
            ConnectionInformation.DesktopLength = 0;
        }

        if (ConnectionInformation.ConsoleApp) {
            InitExeName();
            ConnectionInformation.CurDirLength = sizeof(ConnectionInformation.CurDir);
            ConnectionInformation.AppNameLength = sizeof(ConnectionInformation.AppName);
            SetUpAppName(&ConnectionInformation.CurDirLength,
                         ConnectionInformation.CurDir,
                         &ConnectionInformation.AppNameLength,
                         ConnectionInformation.AppName);
        } else {
            ConnectionInformation.AppNameLength = 0;
            ConnectionInformation.CurDirLength = 0;
        }

        //
        // initialize ctrl handling. This should work for all apps, so
        // initialize it before we check for ConsoleApp (which means the
        // console bit was set in the module header).
        //

        InitializeCtrlHandling();

        //
        // Connect to the server process
        //

        ASSERT(pObjectDirectory != NULL);
        bStatus = ConnectConsoleInternal(pObjectDirectory,
                                         &ConnectionInformation,
                                         &ServerProcess
                                         );

        if (!bStatus) {
            return FALSE;
        }

        //
        // we return success although no console api can be called because
        // loading shouldn't fail.  we'll fail the api calls later.
        //
        if (ServerProcess) {
            return TRUE;
        }

        //
        // if this is not a console app, return success - nothing else to do.
        //

        if (!ConnectionInformation.ConsoleApp) {
            return TRUE;
        }

        //
        // if console was just created, fill in peb values
        //

        if (GET_CONSOLE_HANDLE == NULL) {
            SetUpHandles(&ConnectionInformation.ConsoleInfo);
        }

        InputWaitHandle = ConnectionInformation.ConsoleInfo.InputWaitHandle;

        SetTEBLangID();

    } else if (Reason == DLL_THREAD_ATTACH) {
        if (ConsoleApp()) {
            SetTEBLangID();
        }
    }

    return TRUE;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
AllocConsoleInternal(IN LPWSTR lpTitle,
                     IN DWORD dwTitleLength,
                     IN LPWSTR lpDesktop,
                     IN DWORD dwDesktopLength,
                     IN LPWSTR lpCurDir,
                     IN DWORD dwCurDirLength,
                     IN LPWSTR lpAppName,
                     IN DWORD dwAppNameLength,
                     IN LPTHREAD_START_ROUTINE CtrlRoutine,
                     IN LPTHREAD_START_ROUTINE PropRoutine,
                     IN OUT PCONSOLE_INFO pConsoleInfo
                     )
/*++

Routine Description:

   Marshels the parameters for the ConsolepAlloc command.

Arguments:

   See the CONSOLE_ALLOC_MSG structure and AllocConsole.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/
{
   CONSOLE_API_MSG m;
   PCONSOLE_ALLOC_MSG a = &m.u.AllocConsole;
   PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
   BOOL bStatus = FALSE;
   NTSTATUS Status;

   try {

        a->CtrlRoutine = CtrlRoutine;
        a->PropRoutine = PropRoutine;

        // Allocate 4 extra pointer sizes to compensate for any alignment done
        // by CsrCaptureMessageBuffer.

        CaptureBuffer = CsrAllocateCaptureBuffer( 5,
                                                  dwTitleLength + dwDesktopLength + dwCurDirLength +
                                                  dwAppNameLength + sizeof( CONSOLE_INFO ) + (4 * sizeof(PVOID))
                                                 );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            bStatus = FALSE;
            leave;
        }

        // Allocate the CONSOLE_INFO first so that it is aligned on a pointer
        // boundry.  This is necessary since NtWaitForMultipleObject expects
        // its arguments aligned on a handle boundry.

        CsrCaptureMessageBuffer( CaptureBuffer,
                                 pConsoleInfo,
                                 sizeof( CONSOLE_INFO ),
                                 (PVOID *) &a->ConsoleInfo
                               );

        a->TitleLength = dwTitleLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpTitle,
                                 dwTitleLength,
                                 (PVOID *) &a->Title
                               );

        a->DesktopLength = dwDesktopLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpDesktop,
                                 dwDesktopLength,
                                 (PVOID *) &a->Desktop
                               );

        a->CurDirLength = dwCurDirLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpCurDir,
                                 dwCurDirLength,
                                 (PVOID *) &a->CurDir
                               );

        a->AppNameLength = dwAppNameLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpAppName,
                                 dwAppNameLength,
                                 (PVOID *) &a->AppName
                               );

        //
        // Connect to the server process
        //

        CsrClientCallServer( (PCSR_API_MSG)&m,
                             CaptureBuffer,
                             CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                                  ConsolepAlloc
                                                ),
                             sizeof( *a )
                           );
        if (!NT_SUCCESS( m.ReturnValue )) {
            SET_LAST_NT_ERROR (m.ReturnValue);
            bStatus = FALSE;
            leave;
        }

        Status = NtWaitForMultipleObjects(NUMBER_OF_INITIALIZATION_EVENTS,
                                      a->ConsoleInfo->InitEvents,
                                      WaitAny,
                                      FALSE,
                                      NULL
                                      );
        if (!NT_SUCCESS(Status)) {
           SET_LAST_NT_ERROR(Status);
           bStatus = FALSE;
           leave;
        }

        //The handles to be closed are events, so NtClose works fine.
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_SUCCEEDED]);
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_FAILED]);
        if (Status != INITIALIZATION_SUCCEEDED) {
            SET_CONSOLE_HANDLE(NULL);
            bStatus = FALSE;
            leave;
        }
        RtlCopyMemory(pConsoleInfo, a->ConsoleInfo, sizeof(CONSOLE_INFO));
        bStatus = TRUE;
   }
   finally {
      if (CaptureBuffer) {
         CsrFreeCaptureBuffer( CaptureBuffer );
      }
   }

   return bStatus;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
AllocConsole( VOID )

/*++

Routine Description:

    This API creates a console for the calling process.

Arguments:

    none.

Return Value:

    TRUE - function was successful.

--*/

{
    CONSOLE_INFO ConsoleInfo;
    STARTUPINFOW StartupInfo;
    WCHAR CurDir[MAX_PATH+1];
    WCHAR AppName[MAX_APP_NAME_LENGTH/2];
    BOOL Status = FALSE;

    DWORD dwTitleLength;
    DWORD dwDesktopLength;
    DWORD dwCurDirLength;
    DWORD dwAppNameLength;

    LockDll();
    try {
        if (GET_CONSOLE_HANDLE != NULL) {
            SetLastError(ERROR_ACCESS_DENIED);
            Status = FALSE;
            leave;
        }

        //
        // set up initialization parameters
        //

        SetUpConsoleInfo(FALSE,
                         &dwTitleLength,
                         NULL,
                         &dwDesktopLength,
                         NULL,
                         &ConsoleInfo);

        InitExeName();
        dwCurDirLength = sizeof(CurDir);
        dwAppNameLength = sizeof(AppName);
        SetUpAppName(&dwCurDirLength,
                     CurDir,
                     &dwAppNameLength,
                     AppName);

        GetStartupInfoW(&StartupInfo);

        if (StartupInfo.lpTitle == NULL) {
            StartupInfo.lpTitle = DEFAULT_WINDOW_TITLE;
        }
        dwTitleLength = (USHORT)((lstrlenW(StartupInfo.lpTitle)+1)*sizeof(WCHAR));
        dwTitleLength = (USHORT)(min(dwTitleLength,MAX_TITLE_LENGTH));
        if (StartupInfo.lpDesktop != NULL && *StartupInfo.lpDesktop != 0) {
            dwDesktopLength = (USHORT)((lstrlenW(StartupInfo.lpDesktop)+1)*sizeof(WCHAR));
            dwDesktopLength = (USHORT)(min(dwDesktopLength,MAX_TITLE_LENGTH));
        } else {
            dwDesktopLength = 0;
        }

        Status = AllocConsoleInternal(StartupInfo.lpTitle,
                                      dwTitleLength,
                                      StartupInfo.lpDesktop,
                                      dwDesktopLength,
                                      CurDir,
                                      dwCurDirLength,
                                      AppName,
                                      dwAppNameLength,
                                      CtrlRoutine,
                                      PropRoutine,
                                      &ConsoleInfo
                                      );

        if (!Status) {
           leave;
        }

        //
        // fill in peb values
        //

        SetUpHandles(&ConsoleInfo);

        //
        // create ctrl-c thread
        //

        InitializeCtrlHandling();

        InputWaitHandle = ConsoleInfo.InputWaitHandle;

        SetTEBLangID();

        Status = TRUE;

    } finally {
        UnlockDll();
    }

    return Status;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
FreeConsoleInternal(
     VOID
     )
/*++

Routine Description:

   Marshels the parameters for the ConsolepFree command.

Arguments:

   See the CONSOLE_FREE_MSG structure and FreeConsole.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/
{

   CONSOLE_API_MSG m;
   PCONSOLE_FREE_MSG a = &m.u.FreeConsole;

   a->ConsoleHandle = GET_CONSOLE_HANDLE;

   //
   // Connect to the server process
   //

   CsrClientCallServer( (PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                             ConsolepFree
                                           ),
                        sizeof( *a )
                      );

   if (!NT_SUCCESS( m.ReturnValue )) {
      SET_LAST_NT_ERROR (m.ReturnValue);
      return FALSE;

   } else {

      SET_CONSOLE_HANDLE(NULL);
      return TRUE;
   }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
FreeConsole( VOID )

/*++

Routine Description:

    This API frees the calling process's console.

Arguments:

    none.

Return Value:

    TRUE - function was successful.

--*/

{
    BOOL Success=TRUE;

    LockDll();
    if (GET_CONSOLE_HANDLE == NULL) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        Success = FALSE;
    } else {

        Success = FreeConsoleInternal();

        if (Success) {
           CloseHandle(InputWaitHandle);
        }

    }
    UnlockDll();
    return Success;
}


DWORD
PropRoutine(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread is created when the user tries to change console
    properties from the system menu. It invokes the control panel
    applet.

Arguments:

    lpThreadParameter - not used.

Return Value:

    STATUS_SUCCESS - function was successful

--*/

{
    NTSTATUS Status;
    HANDLE hLibrary;
    APPLET_PROC pfnCplApplet;
    static BOOL fInPropRoutine = FALSE;

    //
    // Prevent the user from launching multiple applets attached
    // to a single console
    //

    if (fInPropRoutine) {
        if (lpThreadParameter) {
            CloseHandle((HANDLE)lpThreadParameter);
        }
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    fInPropRoutine = TRUE;
    hLibrary = LoadLibraryW(L"CONSOLE.DLL");
    if (hLibrary != NULL) {
        pfnCplApplet = (APPLET_PROC)GetProcAddress(hLibrary, "CPlApplet");
        if (pfnCplApplet != NULL) {
            (*pfnCplApplet)((HWND)lpThreadParameter, CPL_INIT, 0, 0);
            (*pfnCplApplet)((HWND)lpThreadParameter, CPL_DBLCLK, 0, 0);
            (*pfnCplApplet)((HWND)lpThreadParameter, CPL_EXIT, 0, 0);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
        FreeLibrary(hLibrary);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    fInPropRoutine = FALSE;

    return Status;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
AttachConsoleInternal(
    IN DWORD dwProcessId,
    IN LPTHREAD_START_ROUTINE CtrlRoutine,
    IN LPTHREAD_START_ROUTINE PropRoutine,
    IN OUT PCONSOLE_INFO pConsoleInfo
    )

/*++

Routine Description:

   Marshels the parameters for the ConsolepAttach command.

Arguments:

   See the CONSOLE_ATTACH_MSG structure and AttachConsole.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_ATTACH_MSG a = &m.u.AttachConsole;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    BOOL Status = FALSE;
    NTSTATUS St;

    try {

        a->ProcessId   = dwProcessId;
        a->CtrlRoutine = CtrlRoutine;
        a->PropRoutine = PropRoutine;

        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  sizeof( CONSOLE_INFO )
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            Status = FALSE;
            leave;
        }

        CsrCaptureMessageBuffer( CaptureBuffer,
                                 pConsoleInfo,
                                 sizeof( CONSOLE_INFO ),
                                 (PVOID *) &a->ConsoleInfo
                               );

        //
        // Connect to the server process
        //

        CsrClientCallServer( (PCSR_API_MSG)&m,
                             CaptureBuffer,
                             CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                                  ConsolepAttach
                                                ),
                             sizeof( *a )
                           );
        if (!NT_SUCCESS( m.ReturnValue )) {
            SET_LAST_NT_ERROR (m.ReturnValue);
            Status = FALSE;
            leave;
        }

        St = NtWaitForMultipleObjects(NUMBER_OF_INITIALIZATION_EVENTS,
                                      a->ConsoleInfo->InitEvents,
                                      WaitAny,
                                      FALSE,
                                      NULL
                                      );
        if (!NT_SUCCESS(St)) {
           SET_LAST_NT_ERROR(St);
           Status = FALSE;
           leave;
        }

        //The handles to be closed are events, so NtClose works fine.
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_SUCCEEDED]);
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_FAILED]);
        if (St != INITIALIZATION_SUCCEEDED) {
            SET_CONSOLE_HANDLE(NULL);
            Status = FALSE;
            leave;
        }
        RtlCopyMemory(pConsoleInfo, a->ConsoleInfo, sizeof(CONSOLE_INFO));
        Status = TRUE;
   }
   finally {
      if (CaptureBuffer) {
         CsrFreeCaptureBuffer( CaptureBuffer );
      }
   }

   return Status;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
AttachConsole(
    IN DWORD dwProcessId
    )

/*++

Routine Description:

    This API attaches the calling process to the console of the given process.

Arguments:

    none.

Return Value:

    TRUE - function was successful.

--*/

{
    CONSOLE_INFO ConsoleInfo;
    DWORD dwTitleLength;
    DWORD dwDesktopLength;
    BOOL Status = FALSE;

    LockDll();
    try {

        //
        // bail if we already have a console
        //

        if (GET_CONSOLE_HANDLE != NULL) {
            SetLastError(ERROR_ACCESS_DENIED);
            Status = FALSE;
            leave;
        }

        //
        // set up initialization parameters
        //

        SetUpConsoleInfo(FALSE,
                         &dwTitleLength,
                         NULL,
                         &dwDesktopLength,
                         NULL,
                         &ConsoleInfo);

        //
        // attach to the console
        //

        Status = AttachConsoleInternal(dwProcessId,
                                       CtrlRoutine,
                                       PropRoutine,
                                       &ConsoleInfo
                                      );

        if (!Status) {
           leave;
        }

        //
        // fill in peb values
        //

        SetUpHandles(&ConsoleInfo);

        //
        // create ctrl-c thread
        //

        InitializeCtrlHandling();

        InputWaitHandle = ConsoleInfo.InputWaitHandle;

        SetTEBLangID();

        Status = TRUE;

    } finally {
        UnlockDll();
    }

    return Status;
}

#endif //!defined(BUILD_WOW64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\private.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    private.c

Abstract:

    This file implements private APIs for Hardware Desktop Support.

Author:

    Therese Stowell (thereses) 12-13-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#if !defined(BUILD_WOW64)

typedef HANDLE (*PCONVPALFUNC)(HANDLE);
PCONVPALFUNC pfnGdiConvertPalette;

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
SetConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN HCURSOR hCursor
    )

/*++

Description:

    Sets the mouse pointer for the specified screen buffer.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    hCursor - win32 cursor handle, should be NULL to set the default
        cursor.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCURSOR_MSG a = &m.u.SetConsoleCursor;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->CursorHandle = hCursor;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursor
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

int
WINAPI
ShowConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN BOOL bShow
    )

/*++

Description:

    Sets the mouse pointer visibility counter.  If the counter is less than
    zero, the mouse pointer is not shown.

Parameters:

    hOutput - Supplies a console output handle.

    bShow - if TRUE, the display count is to be increased. if FALSE,
        decreased.

Return value:

    The return value specifies the new display count.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SHOWCURSOR_MSG a = &m.u.ShowConsoleCursor;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->bShow = bShow;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepShowCursor
                                            ),
                         sizeof( *a )
                       );
    return a->DisplayCount;

}

HMENU
APIENTRY
ConsoleMenuControl(
    IN HANDLE hConsoleOutput,
    IN UINT dwCommandIdLow,
    IN UINT dwCommandIdHigh
    )

/*++

Description:

    Sets the command id range for the current screen buffer and returns the
    menu handle.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwCommandIdLow - Specifies the lowest command id to store in the input buffer.

    dwCommandIdHigh - Specifies the highest command id to store in the input
        buffer.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_MENUCONTROL_MSG a = &m.u.ConsoleMenuControl;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->CommandIdLow =dwCommandIdLow;
    a->CommandIdHigh = dwCommandIdHigh;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepMenuControl
                                            ),
                         sizeof( *a )
                       );
    return a->hMenu;

}

BOOL
APIENTRY
SetConsolePaletteInternal(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    )
{

    CONSOLE_API_MSG m;
    PCONSOLE_SETPALETTE_MSG a = &m.u.SetConsolePalette;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->hPalette = hPalette;
    a->dwUsage = dwUsage;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetPalette
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleDisplayMode(
    IN HANDLE hConsoleOutput,
    IN DWORD dwFlags,
    OUT PCOORD lpNewScreenBufferDimensions
    )

/*++

Description:

    This routine sets the console display mode for an output buffer.
    This API is only supported on x86 machines.  Frame buffer consoles
    are always windowed.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwFlags - Specifies the display mode. Options are:

        CONSOLE_FULLSCREEN_MODE - data is displayed fullscreen

        CONSOLE_WINDOWED_MODE - data is displayed in a window

    lpNewScreenBufferDimensions - On output, contains the new dimensions of
        the screen buffer.  The dimensions are in rows and columns for
        textmode screen buffers.
Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETDISPLAYMODE_MSG a = &m.u.SetConsoleDisplayMode;
    NTSTATUS Status;

#if !defined(_X86_)
    return FALSE;
#else

    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->dwFlags = dwFlags;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetDisplayMode
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        NtClose(a->hEvent);
        return FALSE;

    }
    else {
             Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
        NtClose(a->hEvent);

         if (Status != 0) {
            SET_LAST_NT_ERROR(Status);
            return FALSE;
         }
        try {
            *lpNewScreenBufferDimensions = a->ScreenBufferDimensions;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }

#endif

}

BOOL
APIENTRY
RegisterConsoleVDM(
    IN DWORD dwRegisterFlags,
    IN HANDLE hStartHardwareEvent,
    IN HANDLE hEndHardwareEvent,
    IN HANDLE hErrorHardwareEvent,
    IN DWORD Reserved,
    OUT LPDWORD lpStateLength,
    OUT PVOID *lpState,
    IN LPWSTR lpVDMBufferSectionName,
    IN DWORD dwVDMBufferSectionNameLength,
    IN COORD VDMBufferSize OPTIONAL,
    OUT PVOID *lpVDMBuffer
    )

/*++

Description:

    This routine registers the VDM with the console.

Parameters:

    hStartHardwareEvent - the event the VDM waits on to be
        notified of gaining/losing control of the hardware.

    hEndHardwareEvent - the event the VDM sets when it is done
        saving/restoring the hardware.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_REGISTERVDM_MSG a = &m.u.RegisterConsoleVDM;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->RegisterFlags = dwRegisterFlags;
    if (dwRegisterFlags) {
        a->StartEvent = hStartHardwareEvent;
        a->EndEvent = hEndHardwareEvent;
        a->ErrorEvent = hErrorHardwareEvent;
        a->VDMBufferSectionNameLength = dwVDMBufferSectionNameLength;
        a->VDMBufferSize = VDMBufferSize;
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  dwVDMBufferSectionNameLength
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpVDMBufferSectionName,
                                 dwVDMBufferSectionNameLength,
                                 (PVOID *) &a->VDMBufferSectionName
                                   );
    } else {
        CaptureBuffer = NULL;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepRegisterVDM
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        if (dwRegisterFlags) {
            try {
                *lpStateLength = a->StateLength;
                *lpState = a->StateBuffer;
                *lpVDMBuffer = a->VDMBuffer;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                return FALSE;
            }
        }
        return TRUE;
    }
}

BOOL
APIENTRY
GetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    OUT PCOORD lpResolution,
    OUT PCOORD lpFontSize
    )

/*++

Description:

    This routine returns the video resolution and font.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    lpResolution - Pointer to structure to store screen
        resolution in.  Resolution is returned in pixels.

    lpFontSize - Pointer to structure to store font size in.
        Font size is returned in pixels.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETHARDWARESTATE_MSG a = &m.u.GetConsoleHardwareState;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetHardwareState
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        try {
            *lpResolution = a->Resolution;
            *lpFontSize = a->FontSize;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    IN COORD dwResolution,
    IN COORD dwFontSize
    )

/*++

Description:

    This routine set the video resolution and font.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwResolution - Contains screen resolution to set.
        Resolution is returned in pixels.

    dwFontSize - Contains font size to set.
        Font size is returned in pixels.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETHARDWARESTATE_MSG a = &m.u.SetConsoleHardwareState;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Resolution = dwResolution;
    a->FontSize = dwFontSize;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetHardwareState
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

BOOL
APIENTRY
GetConsoleDisplayMode(
    OUT LPDWORD lpModeFlags
    )

/*++

Description:

    This routine returns the display mode of the console.

Parameters:

    lpModeFlags - pointer to store display mode in.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETDISPLAYMODE_MSG a = &m.u.GetConsoleDisplayMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetDisplayMode
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        try {
            *lpModeFlags = a->ModeFlags;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleKeyShortcuts(
    IN BOOL bSet,
    IN BYTE bReserveKeys,
    IN LPAPPKEY lpAppKeys,
    IN DWORD dwNumAppKeys
    )

/*++

Description:

    Only one set of key shortcuts is valid per console.  Calling
    SetConsoleKeyShortcuts(set) overwrites any previous settings.
    SetConsoleKeyShortcuts(!set) removes any shortcuts.

Parameters:

    bSet - if TRUE, set shortcuts.  else remove shortcuts.

    bReserveKeys - byte containing reserve key info.

    lpAppKeys - pointer to application-defined shortcut keys.  can be null.

    dwNumAppKeys - number of app keys contained in lpAppKeys.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETKEYSHORTCUTS_MSG a = &m.u.SetConsoleKeyShortcuts;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Set = bSet;
    a->ReserveKeys = bReserveKeys;
    if (lpAppKeys == NULL || dwNumAppKeys == 0) {
        a->NumAppKeys = 0;
        CaptureBuffer = NULL;
    } else {
        a->NumAppKeys = dwNumAppKeys;
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  dwNumAppKeys * sizeof(APPKEY)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpAppKeys,
                                 dwNumAppKeys * sizeof(APPKEY),
                                 (PVOID *) &a->AppKeys
                               );
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetKeyShortcuts
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer)
        CsrFreeCaptureBuffer( CaptureBuffer );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleMenuClose(
    IN BOOL bEnable
    )

/*++

Description:

    This routine returns the display mode of the console.

Parameters:

    bEnable - if TRUE, close is enabled in the system menu.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETMENUCLOSE_MSG a = &m.u.SetConsoleMenuClose;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Enable = bEnable;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetMenuClose
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
SetConsolePalette(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    )

/*++

Description:

    Sets the palette for the console screen buffer.

Parameters:

    hOutput - Supplies a console output handle.

    hPalette - Supplies a handle to the palette to set.

    dwUsage - Specifies use of the system palette.

        SYSPAL_NOSTATIC - System palette contains no static colors
                          except black and white.

        SYSPAL_STATIC -   System palette contains static colors
                          which will not change when an application
                          realizes its logical palette.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    HANDLE hmodGdi;
    UNICODE_STRING ModuleNameString;
    NTSTATUS Status;

    if ( !pfnGdiConvertPalette ) {
        RtlInitUnicodeString( &ModuleNameString, L"gdi32" );
        Status = LdrLoadDll( UNICODE_NULL, NULL, &ModuleNameString, &hmodGdi );
        if ( !NT_SUCCESS(Status) ) {
            SET_LAST_NT_ERROR(Status);
            return FALSE;
            }
        pfnGdiConvertPalette = (PCONVPALFUNC)GetProcAddress(hmodGdi, "GdiConvertPalette");
        if (pfnGdiConvertPalette == NULL) {
            SET_LAST_NT_ERROR(STATUS_PROCEDURE_NOT_FOUND);
            return FALSE;
            }

        }

    hPalette = (*pfnGdiConvertPalette)(hPalette);

    return SetConsolePaletteInternal(hConsoleOutput,
                                     hPalette,
                                     dwUsage);
}

BOOL
APIENTRY
WriteConsoleInputVDMA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,FALSE,FALSE);
}

BOOL
APIENTRY
WriteConsoleInputVDMW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,TRUE,FALSE);
}

#endif //!defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\iostubs.c ===
//depot/Lab01_N/Windows/Core/ntcon/client/iostubs.c#2 - integrate change 10363 (text)
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    iostubs.c

Abstract:

    This module contains the stubs for the console I/O API.

Author:

    Therese Stowell (thereses) 14-Nov-1990

Revision History:
    
--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleInput(
    IN HANDLE hConsoleInput,
    OUT PINPUT_RECORD lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsRead,
    IN USHORT wFlags,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

    wFlags - Flags that control how data is read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_GETCONSOLEINPUT_MSG a = &m.u.GetConsoleInput;

    //
    // If it's not a well formed handle, don't bother going to the server.
    //

    if (!CONSOLE_HANDLE(hConsoleInput)) {
        try {
            *lpNumberOfEventsRead = 0;
            SET_LAST_ERROR(ERROR_INVALID_HANDLE);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        }
        return FALSE;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    a->NumRecords = nLength;
    a->Flags = wFlags;
    a->Unicode = Unicode;

    //
    // for speed in the case where we're only reading a few records, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    if (nLength > INPUT_RECORD_BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  nLength * sizeof(INPUT_RECORD)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 nLength * sizeof(INPUT_RECORD),
                                 (PVOID *) &a->BufPtr
                               );

    } else {
        a->BufPtr = a->Record;
        CaptureBuffer = NULL;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetConsoleInput
                                            ),
                         sizeof( *a )
                       );

    try {
        if (NT_SUCCESS( m.ReturnValue )) {
            *lpNumberOfEventsRead = a->NumRecords;
            RtlCopyMemory(lpBuffer, a->BufPtr, a->NumRecords * sizeof(INPUT_RECORD));
        }
        else {
            *lpNumberOfEventsRead = 0;
            SET_LAST_NT_ERROR(m.ReturnValue);
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }

    return NT_SUCCESS(m.ReturnValue);

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
PeekConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           CONSOLE_READ_NOREMOVE | CONSOLE_READ_NOWAIT,
                           FALSE);
}

BOOL
APIENTRY
PeekConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           CONSOLE_READ_NOREMOVE | CONSOLE_READ_NOWAIT,
                           TRUE);
}

BOOL
APIENTRY
ReadConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           0,
                           FALSE);
}

BOOL
APIENTRY
ReadConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           0,
                           TRUE);
}

BOOL
APIENTRY
ReadConsoleInputExA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    )

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           wFlags,
                           FALSE);
}

BOOL
APIENTRY
ReadConsoleInputExW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

    wFlags - Flags that control how data is read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           wFlags,
                           TRUE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleInputInternal(
    IN HANDLE hConsoleInput,
    IN CONST INPUT_RECORD *lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsWritten,
    IN BOOLEAN Unicode,
    IN BOOLEAN Append
    )

/*++
Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        written.  The handle must have been created with GENERIC_WRITE access.

    lpBuffer - Supplies the address of a buffer containing the input records
        to write to the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsWritten - Pointer to number of events written.

    Unicode - TRUE if characters are unicode

    Append - TRUE if append to end of input stream.  if FALSE, write to the
    beginning of the input stream (used by VDM).

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLEINPUT_MSG a = &m.u.WriteConsoleInput;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    a->NumRecords = nLength;
    a->Unicode = Unicode;
    a->Append = Append;

    //
    // for speed in the case where we're only writing a few records, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    if (nLength > INPUT_RECORD_BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  nLength * sizeof(INPUT_RECORD)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) lpBuffer,
                                 nLength * sizeof(INPUT_RECORD),
                                 (PVOID *) &a->BufPtr
                               );

    } else {
        a->BufPtr = a->Record;
        CaptureBuffer = NULL;
        try {
            RtlCopyMemory(a->BufPtr, lpBuffer, nLength * sizeof(INPUT_RECORD));
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsoleInput
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    try {
        *lpNumberOfEventsWritten = a->NumRecords;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleInputA(
    HANDLE hConsoleInput,
    CONST INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,FALSE,TRUE);
}

BOOL
APIENTRY
WriteConsoleInputW(
    HANDLE hConsoleInput,
    CONST INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,TRUE,TRUE);
}


#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

VOID
CopyRectangle(
    IN CONST CHAR_INFO *Source,
    IN COORD SourceSize,
    IN PSMALL_RECT SourceRect,
    OUT PCHAR_INFO Target,
    IN COORD TargetSize,
    IN COORD TargetPoint
    )

/*++

Routine Description:

    This routine copies a rectangular region, doing any necessary clipping.

Arguments:

    Source - pointer to source buffer

    SourceSize - dimensions of source buffer

    SourceRect - rectangle in source buffer to copy

    Target - pointer to target buffer

    TargetSize - dimensions of target buffer

    TargetPoint - upper left coordinates of target rectangle

Return Value:


--*/

{

#define SCREEN_BUFFER_POINTER(BASE,X,Y,XSIZE,CELLSIZE) ((ULONG_PTR)BASE + ((XSIZE * (Y)) + (X)) * (ULONG)CELLSIZE)

    CONST CHAR_INFO *SourcePtr;
    PCHAR_INFO TargetPtr;
    SHORT i,j;
    SHORT XSize,YSize;
    BOOLEAN WholeSource,WholeTarget;

    XSize = (SHORT)CONSOLE_RECT_SIZE_X(SourceRect);
    YSize = (SHORT)CONSOLE_RECT_SIZE_Y(SourceRect);

    // do clipping.  we only clip for target, not source.

    if (XSize > (SHORT)(TargetSize.X - TargetPoint.X + 1)) {
        XSize = (SHORT)(TargetSize.X - TargetPoint.X + 1);
    }
    if (YSize > (SHORT)(TargetSize.Y - TargetPoint.Y + 1)) {
        YSize = (SHORT)(TargetSize.Y - TargetPoint.Y + 1);
    }

    WholeSource = WholeTarget = FALSE;
    if (XSize == SourceSize.X) {
        ASSERT (SourceRect->Left == 0);
        if (SourceRect->Top == 0) {
            SourcePtr = Source;
        }
        else {
            SourcePtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Source,
                                                           SourceRect->Left,
                                                           SourceRect->Top,
                                                           SourceSize.X,
                                                           sizeof(CHAR_INFO));
        }
        WholeSource = TRUE;
    }
    if (XSize == TargetSize.X) {
        ASSERT (TargetPoint.X == 0);
        if (TargetPoint.Y == 0) {
            TargetPtr = Target;
        }
        else {
            TargetPtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Target,
                                                           TargetPoint.X,
                                                           TargetPoint.Y,
                                                           TargetSize.X,
                                                           sizeof(CHAR_INFO));
        }
        WholeTarget = TRUE;
    }
    if (WholeSource && WholeTarget) {
        memmove(TargetPtr,SourcePtr,XSize*YSize*sizeof(CHAR_INFO));
        return;
    }

    for (i=0;i<YSize;i++) {
        if (!WholeTarget) {
            TargetPtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Target,
                                                           TargetPoint.X,
                                                           TargetPoint.Y+i,
                                                           TargetSize.X,
                                                           sizeof(CHAR_INFO));
        }
        if (!WholeSource) {
            SourcePtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Source,
                                                           SourceRect->Left,
                                                           SourceRect->Top+i,
                                                           SourceSize.X,
                                                           sizeof(CHAR_INFO));
        }
        for (j=0;j<XSize;j++,SourcePtr++,TargetPtr++) {
            *TargetPtr = *SourcePtr;
        }
    }
}

BOOL
APIENTRY
ReadConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    OUT PCHAR_INFO lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN OUT PSMALL_RECT lpReadRegion,
    IN BOOLEAN Unicode
    )

/*++
Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the screen buffer.  This pointer is treated as the origin of
        a two dimensional array of size dwBufferSize.

    dwBufferSize - size of lpBuffer

    dwBufferCoord - coordinates of upper left point in buffer to receive
        read data.

    lpReadRegion - Supplies on input the address of a structure indicating the
        rectangle within the screen buffer to read from.  The fields in
        the structure are column and row coordinates.  On output, the fields
        contain the actual region read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_READCONSOLEOUTPUT_MSG a = &m.u.ReadConsoleOutput;
    ULONG NumChars;
    COORD SourceSize;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Unicode = Unicode;

    //
    // clip region to read based on caller's buffer size
    //

    SourceSize.X = (SHORT)CONSOLE_RECT_SIZE_X(lpReadRegion);
    if (SourceSize.X > dwBufferSize.X-dwBufferCoord.X)
        SourceSize.X = dwBufferSize.X-dwBufferCoord.X;
    SourceSize.Y = (SHORT)CONSOLE_RECT_SIZE_Y(lpReadRegion);
    if (SourceSize.Y > dwBufferSize.Y-dwBufferCoord.Y)
        SourceSize.Y = dwBufferSize.Y-dwBufferCoord.Y;

    a->CharRegion.Left = lpReadRegion->Left;
    a->CharRegion.Right = (SHORT)(lpReadRegion->Left + SourceSize.X - 1);
    a->CharRegion.Top  = lpReadRegion->Top;
    a->CharRegion.Bottom = (SHORT)(lpReadRegion->Top + SourceSize.Y - 1);

    //
    // for speed in the case where we're only reading one character, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    NumChars = SourceSize.X * SourceSize.Y;
    if (NumChars > 1) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  NumChars * sizeof(CHAR_INFO)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 NumChars * sizeof(CHAR_INFO),
                                 (PVOID *) &a->BufPtr
                               );
    }
    else {
        CaptureBuffer = NULL;
        a->BufPtr = &a->Char;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepReadConsoleOutput
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            SMALL_RECT SourceRect;

            SourceRect.Left = a->CharRegion.Left - lpReadRegion->Left;
            SourceRect.Top = a->CharRegion.Top - lpReadRegion->Top;
            SourceRect.Right = SourceRect.Left +
                    (a->CharRegion.Right - a->CharRegion.Left);
            SourceRect.Bottom =  SourceRect.Top +
                    (a->CharRegion.Bottom - a->CharRegion.Top);
            dwBufferCoord.X += SourceRect.Left;
            dwBufferCoord.Y += SourceRect.Top;
            CopyRectangle(a->BufPtr,
                          SourceSize,
                          &SourceRect,
                          lpBuffer,
                          dwBufferSize,
                          dwBufferCoord
                         );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            if (CaptureBuffer != NULL) {
                CsrFreeCaptureBuffer( CaptureBuffer );
            }
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    *lpReadRegion = a->CharRegion;
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ReadConsoleOutputW(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    )
{
    return ReadConsoleOutputInternal(hConsoleOutput,
                                     lpBuffer,
                                     dwBufferSize,
                                     dwBufferCoord,
                                     lpReadRegion,
                                     TRUE
                                    );
}

BOOL
APIENTRY
ReadConsoleOutputA(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    )
{
    return ReadConsoleOutputInternal(hConsoleOutput,
                                     lpBuffer,
                                     dwBufferSize,
                                     dwBufferCoord,
                                     lpReadRegion,
                                     FALSE
                                    );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    IN CONST CHAR_INFO *lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN PSMALL_RECT lpWriteRegion,
    IN BOOLEAN Unicode
    )

/*++
Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpBuffer - Supplies the address of a buffer containing the data to write
        to the screen buffer.  This buffer is treated as a two dimensional
        array.

    dwBufferSize - size of lpBuffer

    dwBufferCoord - coordinates of upper left point in buffer to write data
        from.

    lpWriteRegion - Supplies on input the address of a structure indicating the
        rectangle within the screen buffer to write to.  The fields in
        the structure are column and row coordinates.  On output, the fields
        contain the actual region written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{

    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLEOUTPUT_MSG a = &m.u.WriteConsoleOutput;
    ULONG NumChars;
    COORD SourceSize;
    COORD TargetPoint;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Unicode = Unicode;

    //
    // clip region to write based on caller's buffer size
    //

    SourceSize.X = (SHORT)CONSOLE_RECT_SIZE_X(lpWriteRegion);
    if (SourceSize.X > dwBufferSize.X-dwBufferCoord.X)
        SourceSize.X = dwBufferSize.X-dwBufferCoord.X;
    SourceSize.Y = (SHORT)CONSOLE_RECT_SIZE_Y(lpWriteRegion);
    if (SourceSize.Y > dwBufferSize.Y-dwBufferCoord.Y)
        SourceSize.Y = dwBufferSize.Y-dwBufferCoord.Y;

    if (SourceSize.X <= 0 ||
        SourceSize.Y <= 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    a->CharRegion.Left = lpWriteRegion->Left;
    a->CharRegion.Right = (SHORT)(lpWriteRegion->Left + SourceSize.X - 1);
    a->CharRegion.Top  = lpWriteRegion->Top;
    a->CharRegion.Bottom = (SHORT)(lpWriteRegion->Top + SourceSize.Y - 1);

    //
    // for speed in the case where we're only writing one character, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    NumChars = SourceSize.X * SourceSize.Y;
    if (NumChars > 1) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  NumChars * sizeof(CHAR_INFO)
                                                );
        if (CaptureBuffer == NULL) {
            a->ReadVM=TRUE;
            a->BufPtr = RtlAllocateHeap( RtlProcessHeap(), 0, NumChars * sizeof(CHAR_INFO));
            if (a->BufPtr == NULL) {
                SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
        } else {
            a->ReadVM=FALSE;
            CsrCaptureMessageBuffer( CaptureBuffer,
                                     NULL,
                                     NumChars * sizeof(CHAR_INFO),
                                     (PVOID *) &a->BufPtr
                                   );
        }
    }
    else {
        a->ReadVM=FALSE;
        CaptureBuffer = NULL;
        a->BufPtr = &a->Char;
    }
    try {
        SMALL_RECT SourceRect;

        SourceRect.Left = dwBufferCoord.X;
        SourceRect.Top = dwBufferCoord.Y;
        SourceRect.Right = (SHORT)(dwBufferCoord.X+SourceSize.X-1);
        SourceRect.Bottom = (SHORT)(dwBufferCoord.Y+SourceSize.Y-1);
        TargetPoint.X = 0;
        TargetPoint.Y = 0;
        CopyRectangle(lpBuffer,
                      dwBufferSize,
                      &SourceRect,
                      a->BufPtr,
                      SourceSize,
                      TargetPoint
                     );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        } else if (a->ReadVM) {
            // a->BufPtr was allocated with RtlAllocateHeap.
            RtlFreeHeap( RtlProcessHeap(), 0, a->BufPtr);  
        }
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsoleOutput
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    } else if (a->ReadVM) {
        // a->BufPtr was allocated with RtlAllocateHeap.
        RtlFreeHeap(RtlProcessHeap(),0,a->BufPtr);       
    }
    *lpWriteRegion = a->CharRegion;
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleOutputW(
    HANDLE hConsoleOutput,
    CONST CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    )
{
    return WriteConsoleOutputInternal(hConsoleOutput,
                                      lpBuffer,
                                      dwBufferSize,
                                      dwBufferCoord,
                                      lpWriteRegion,
                                      TRUE
                                      );
}

BOOL
APIENTRY
WriteConsoleOutputA(
    HANDLE hConsoleOutput,
    CONST CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    )
{
    return WriteConsoleOutputInternal(hConsoleOutput,
                                      lpBuffer,
                                      dwBufferSize,
                                      dwBufferCoord,
                                      lpWriteRegion,
                                      FALSE
                                      );
}

#endif //defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
ReadConsoleOutputString(
    IN HANDLE hConsoleOutput,
    OUT LPVOID lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwReadCoord,
    OUT LPDWORD lpNumberOfElementsRead
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpString - Supplies the address of a buffer to receive the character
        or attribute string read from the screen buffer.

    nLength - Size of lpCharacter buffer in elements.

    nSize - Size of element to read.

    fFlags - flag indicating what type of string to copy

    dwReadCoord - Screen buffer coordinates of string to read.
        read data.

    lpNumberOfElementsRead - Pointer to number of events read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_READCONSOLEOUTPUTSTRING_MSG a = &m.u.ReadConsoleOutputString;
    ULONG DataLength;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->NumRecords = nLength;
    a->StringType = fFlags;
    a->ReadCoord = dwReadCoord;

    DataLength = nLength*nSize;

    //
    // for speed in the case where the string is small, we have a buffer
    // in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    if (DataLength > sizeof(a->String)) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  DataLength
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 DataLength,
                                 (PVOID *) &a->BufPtr
                               );

    }
    else {
        a->BufPtr = a->String;
        CaptureBuffer = NULL;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepReadConsoleOutputString
                                            ),
                         sizeof( *a )
                       );

    try {
       *lpNumberOfElementsRead = a->NumRecords;
        if (NT_SUCCESS( m.ReturnValue )) {
            RtlCopyMemory(lpString, a->BufPtr, a->NumRecords * nSize);
        }
        else {
            SET_LAST_NT_ERROR(m.ReturnValue);
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    return NT_SUCCESS(m.ReturnValue);
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ReadConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpCharacter - Supplies the address of a buffer to receive the character
        string read from the screen buffer.

    nLength - Size of lpCharacter buffer in characters.

    dwReadCoord - Screen buffer coordinates of string to read.
        read data.

    lpNumberOfCharsRead - Pointer to number of chars read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return ReadConsoleOutputString(hConsoleOutput,
                                   lpCharacter,
                                   nLength,
                                   sizeof(CHAR),
                                   CONSOLE_ASCII,
                                   dwReadCoord,
                                   lpNumberOfCharsRead
                                  );
}


BOOL
APIENTRY
ReadConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPWSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    )

{
    return ReadConsoleOutputString(hConsoleOutput,
                                   lpCharacter,
                                   nLength,
                                   sizeof(WCHAR),
                                   CONSOLE_REAL_UNICODE,
                                   dwReadCoord,
                                   lpNumberOfCharsRead
                                  );
}


BOOL
APIENTRY
ReadConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    LPWORD lpAttribute,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfAttrsRead
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpAttribute - Supplies the address of a buffer to receive the attribute
        string read from the screen buffer.

    nLength - Size of lpAttribute buffer in bytes.

    dwReadCoord - Screen buffer coordinates of string to read.
        read data.

    lpNumberOfAttrsRead - Pointer to number of attrs read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return ReadConsoleOutputString(hConsoleOutput,
                                   lpAttribute,
                                   nLength,
                                   sizeof(WORD),
                                   CONSOLE_ATTRIBUTE,
                                   dwReadCoord,
                                   lpNumberOfAttrsRead
                                  );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleOutputString(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpString - Supplies the address of a buffer containing the character
        or attribute string to write to the screen buffer.

    nLength - Length of string to write, in elements.

    nSize - Size of element to read.

    fFlags - flag indicating what type of string to copy

    dwWriteCoord - Screen buffer coordinates to write the string to.

    lpNumberOfElementsWritten - Pointer to number of elements written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG a = &m.u.WriteConsoleOutputString;
    ULONG DataLength;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->NumRecords = nLength;
    a->StringType = fFlags;
    a->WriteCoord = dwWriteCoord;

    //
    // for speed in the case where the string is small, we have a buffer
    // in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    DataLength = nLength*nSize;
    if (DataLength > sizeof(a->String)) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  DataLength
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) lpString,
                                 DataLength,
                                 (PVOID *) &a->BufPtr
                               );
    }
    else {
        a->BufPtr = a->String;
        CaptureBuffer = NULL;

        try {
            RtlCopyMemory(a->BufPtr, lpString, DataLength);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsoleOutputString
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    try {
        *lpNumberOfElementsWritten = a->NumRecords;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPCSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpCharacter - Supplies the address of a buffer containing the character
        string to write to the screen buffer.

    nLength - Length of string to write, in characters.

    dwWriteCoord - Screen buffer coordinates to write the string to.

    lpNumberOfCharsWritten - Pointer to number of chars written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return WriteConsoleOutputString(hConsoleOutput,
                                    lpCharacter,
                                    nLength,
                                    sizeof(CHAR),
                                    CONSOLE_ASCII,
                                    dwWriteCoord,
                                    lpNumberOfCharsWritten
                                   );
}

BOOL
APIENTRY
WriteConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPCWSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

{
    return WriteConsoleOutputString(hConsoleOutput,
                                    lpCharacter,
                                    nLength,
                                    sizeof(WCHAR),
                                    CONSOLE_REAL_UNICODE,
                                    dwWriteCoord,
                                    lpNumberOfCharsWritten
                                   );
}

BOOL
APIENTRY
WriteConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    CONST WORD *lpAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpAttribute - Supplies the address of a buffer containing the attribute
        string to write to the screen buffer.

    nLength - Length of string to write.

    dwWriteCoord - Screen buffer coordinates to write the string to.

    lpNumberOfAttrsWritten - Pointer to number of attrs written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return WriteConsoleOutputString(hConsoleOutput,
                                    lpAttribute,
                                    nLength,
                                    sizeof(WORD),
                                    CONSOLE_ATTRIBUTE,
                                    dwWriteCoord,
                                    lpNumberOfAttrsWritten
                                   );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
FillConsoleOutput(
    IN HANDLE hConsoleOutput,
    IN WORD   Element,
    IN DWORD  nLength,
    IN DWORD  fFlags,
    IN COORD  dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    Element - The attribute or character to write.

    nLength - Number of times to write the element.

    fFlags - flag indicating what type of element to write.

    dwWriteCoord - Screen buffer coordinates to write the element to.

    lpNumberOfElementsWritten - Pointer to number of elements written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_FILLCONSOLEOUTPUT_MSG a = &m.u.FillConsoleOutput;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Length = nLength;
    a->ElementType = fFlags;
    a->Element = Element;
    a->WriteCoord = dwWriteCoord;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepFillConsoleOutput
                                            ),
                         sizeof( *a )
                       );
    try {
        *lpNumberOfElementsWritten = a->Length;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
FillConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    CHAR   cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    cCharacter - Supplies the ASCII character to write to the screen buffer.

    nLength - Number of times to write the character.

    dwWriteCoord - Screen buffer coordinates to begin writing the character
        to.

    lpNumberOfCharsWritten - Pointer to number of chars written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return FillConsoleOutput(hConsoleOutput,
                             (USHORT) cCharacter,
                             nLength,
                             CONSOLE_ASCII,
                             dwWriteCoord,
                             lpNumberOfCharsWritten
                            );
}

BOOL
APIENTRY
FillConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    WCHAR   cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    cCharacter - Supplies the ASCII character to write to the screen buffer.

    nLength - Number of times to write the character.

    dwWriteCoord - Screen buffer coordinates to begin writing the character
        to.

    lpNumberOfCharsWritten - Pointer to number of chars written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return FillConsoleOutput(hConsoleOutput,
                             (USHORT) cCharacter,
                             nLength,
                             CONSOLE_REAL_UNICODE,
                             dwWriteCoord,
                             lpNumberOfCharsWritten
                            );
}

BOOL
APIENTRY
FillConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    WORD   wAttribute,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    wAttribute - Supplies the attribute to write to the screen buffer.

    nLength - Number of times to write the attribute.

    dwWriteCoord - Screen buffer coordinates to begin writing the attribute
        to.

    lpNumberOfAttrsWritten - Pointer to number of attrs written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return FillConsoleOutput(hConsoleOutput,
                             wAttribute,
                             nLength,
                             CONSOLE_ATTRIBUTE,
                             dwWriteCoord,
                             lpNumberOfAttrsWritten
                            );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

HANDLE
WINAPI
CreateConsoleScreenBuffer(
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN CONST SECURITY_ATTRIBUTES *lpSecurityAttributes,
    IN DWORD dwFlags,
    IN PVOID lpScreenBufferData OPTIONAL
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_CREATESCREENBUFFER_MSG a = &m.u.CreateConsoleScreenBuffer;
    PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer=NULL;

    if (dwDesiredAccess & ~VALID_ACCESSES ||
        dwShareMode & ~VALID_SHARE_ACCESSES ||
        (dwFlags != CONSOLE_TEXTMODE_BUFFER &&
         dwFlags != CONSOLE_GRAPHICS_BUFFER)) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->DesiredAccess = dwDesiredAccess;
    if (ARGUMENT_PRESENT(lpSecurityAttributes)) {
        a->InheritHandle = lpSecurityAttributes->bInheritHandle;
    }
    else {
        a->InheritHandle = FALSE;
    }
    a->ShareMode = dwShareMode;
    a->Flags = dwFlags;
    if (dwFlags == CONSOLE_GRAPHICS_BUFFER) {
        if (a->InheritHandle || lpScreenBufferData == NULL) {
            SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
        GraphicsBufferInfo = lpScreenBufferData;
        try {
            a->GraphicsBufferInfo = *GraphicsBufferInfo;
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      a->GraphicsBufferInfo.dwBitMapInfoLength
                                                    );
            if (CaptureBuffer == NULL) {
                SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                return INVALID_HANDLE_VALUE;
            }
            CsrCaptureMessageBuffer( CaptureBuffer,
                                     (PCHAR) GraphicsBufferInfo->lpBitMapInfo,
                                     a->GraphicsBufferInfo.dwBitMapInfoLength,
                                     (PVOID *) &a->GraphicsBufferInfo.lpBitMapInfo
                                   );

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return INVALID_HANDLE_VALUE;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepCreateScreenBuffer
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return INVALID_HANDLE_VALUE;
    }
    else {
        if (dwFlags == CONSOLE_GRAPHICS_BUFFER) {
            try {
                GraphicsBufferInfo->hMutex = a->hMutex;
                GraphicsBufferInfo->lpBitMap = a->lpBitmap;
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                return INVALID_HANDLE_VALUE;
            }
        }
        return a->Handle;
    }
}

BOOL
WINAPI
InvalidateConsoleDIBits(
    IN HANDLE hConsoleOutput,
    IN PSMALL_RECT lpRect
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpRect - the region that needs to be updated to the screen.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_INVALIDATERECT_MSG a = &m.u.InvalidateConsoleBitmapRect;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    try {
        a->Rect = *lpRect;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return ERROR_INVALID_ACCESS;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepInvalidateBitmapRect
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }
}

#endif //!defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\client\stream.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    stream.c

Abstract:

    This module contains the stubs for the console stream API.

Author:

    Therese Stowell (thereses) 3-Dec-1990

Revision History:

    
    
--*/

#include "precomp.h"
#pragma hdrstop

#if !defined(BUILD_WOW64)

HANDLE InputWaitHandle = INVALID_HANDLE_VALUE;

HANDLE
APIENTRY
GetConsoleInputWaitHandle( VOID )
{
    return InputWaitHandle;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

HANDLE
APIENTRY
OpenConsoleWInternal(
    IN ULONG HandleType,
    IN ULONG DesiredAccess,
    IN BOOL InheritHandle,
    IN ULONG ShareMode
    )
/*++

Routine Description:

   Marshals parameters for the ConsolepOpenConsole command.

Arguments:

   See the CONSOLE_OPENCONSOLE_MSG structure and OpenConsoleW.

Return Value:

    INVALID_HANDLE_VALUE - An error occured.

--*/
{

    CONSOLE_API_MSG m;
    PCONSOLE_OPENCONSOLE_MSG a = &m.u.OpenConsole;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->HandleType    = HandleType;
    a->DesiredAccess = DesiredAccess;
    a->InheritHandle = InheritHandle;
    a->ShareMode= ShareMode;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepOpenConsole
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return INVALID_HANDLE_VALUE;
    }
    else {
        return a->Handle;
    }

}

#endif // !defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

HANDLE
APIENTRY
OpenConsoleW(
    IN LPWSTR lpConsoleDevice,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwShareMode
    )

/*++

Parameters:

    lpConsoleDevice - Supplies the console device name to open.  "CONIN$"
        indicates console input.  "CONOUT$" indicates console output.  The
        caller must have appropriate access to the console for this call to
        succeed.

    dwDesiredAccess - Supplies the caller's desired access to the console
        device.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the console device is requested.  This
            allows data to be read from the console device.

        GENERIC_WRITE - Write access to the console device is requested.  This
            allows data to be written to the console device.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process
        during a CreateProcess.  A value of TRUE indicates that the
        new process will inherit the handle.

    dwShareMode - Supplies a set of flags that indicates how this console
        device is to be shared with other openers of the console device.  A
        value of zero for this parameter indicates no sharing of the console,
        or exclusive access to the console is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            console device for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            console device for write access.

Return Value:

    Not -1 - Returns an open handle to the specified console device.
        Subsequent access to the file is controlled by the DesiredAccess
        parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    ULONG HandleType;

    try {
        if (CompareStringW(LOCALE_INVARIANT, 
                           NORM_IGNORECASE, 
                           lpConsoleDevice, 
                           -1, 
                           CONSOLE_INPUT_STRING, 
                           -1) == CSTR_EQUAL) {
            HandleType = CONSOLE_INPUT_HANDLE;
        }
        else if (CompareStringW(LOCALE_INVARIANT, 
                                NORM_IGNORECASE, 
                                lpConsoleDevice, 
                                -1, 
                                CONSOLE_OUTPUT_STRING, 
                                -1) == CSTR_EQUAL) {
            HandleType = CONSOLE_OUTPUT_HANDLE;
        }
        else {
            SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return INVALID_HANDLE_VALUE;
    }
    if (dwDesiredAccess & ~VALID_ACCESSES ||
        dwShareMode & ~VALID_SHARE_ACCESSES) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    return OpenConsoleWInternal(HandleType,
                                dwDesiredAccess,
                                bInheritHandle,
                                dwShareMode
                                );

}

#endif // !defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
ReadConsoleInternal(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved,
    IN BOOLEAN Unicode,
    IN USHORT ExeNameLength,
    IN LPWSTR ExeName
    )
/*++
Parameters:

    hConsoleInput - Supplies an open handle to "CONIN$" open for GENERIC_READ
        or the StdIn handle.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the console input.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        input buffer.

    lpReserved - Ignore unless 4.0 application, in which case it points
        to a CONSOLE_READCONSOLE_CONTROL data structure.  UNICODE only.
        If !Unicode, then call fails if this parameter is non-NULL

    Unicode - TRUE if call from ReadConsoleW, FALSE if ReadConsoleA


Return Value:

    NON-NULL - Returns the number of bytes actually read from the input buffer.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.
--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_READCONSOLE_MSG a = &m.u.ReadConsole;
    BOOLEAN Dummy;
    PCONSOLE_READCONSOLE_CONTROL pInputControl;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    a->ExeNameLength = ExeNameLength;
    RtlCopyMemory(a->Buffer, ExeName, ExeNameLength);
    a->Unicode = Unicode;

    //
    // if ansi, make capture buffer large enough to hold translated
    // string.  this will make server side code much simpler.
    //

    a->CaptureBufferSize = a->NumBytes = nNumberOfCharsToRead * sizeof(WCHAR);
    if (a->CaptureBufferSize > BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  a->CaptureBufferSize
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 a->CaptureBufferSize,
                                 (PVOID *) &a->BufPtr
                               );

    }
    else {
        a->BufPtr = a->Buffer;
        CaptureBuffer = NULL;
    }


    pInputControl = (PCONSOLE_READCONSOLE_CONTROL)lpReserved;
    a->InitialNumBytes = 0;
    a->CtrlWakeupMask = 0;
    a->ControlKeyState = 0;
    Status = STATUS_SUCCESS;
    try {
        if (Unicode &&
            ARGUMENT_PRESENT(lpReserved) &&
            NtCurrentPeb()->ImageSubsystemMajorVersion >= 4 &&
            pInputControl->nLength == sizeof(*pInputControl)
           ) {
            if ((pInputControl->nInitialChars > nNumberOfCharsToRead)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                a->InitialNumBytes = pInputControl->nInitialChars * sizeof(WCHAR);
                if (pInputControl->nInitialChars != 0) {
                    RtlCopyMemory( a->BufPtr, lpBuffer, a->InitialNumBytes );
                }
                a->CtrlWakeupMask = pInputControl->dwCtrlWakeupMask;
            }
        } else {
            pInputControl = NULL;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status) && pInputControl != NULL) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
        SET_LAST_NT_ERROR(Status);
        return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepReadConsole
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpNumberOfCharsRead = a->NumBytes;
            if (Unicode) {
                *lpNumberOfCharsRead /= sizeof(WCHAR);
                if (pInputControl != NULL) {
                    pInputControl->dwControlKeyState = a->ControlKeyState;
                }
            }
            RtlCopyMemory( lpBuffer, a->BufPtr, a->NumBytes );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            if (CaptureBuffer != NULL) {
                CsrFreeCaptureBuffer( CaptureBuffer );
            }
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    } else if (m.ReturnValue == STATUS_ALERTED) {
        // ctrl-c or ctrl-break
        NtYieldExecution();
        SET_LAST_ERROR(ERROR_OPERATION_ABORTED);
    }
    return TRUE;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ReadConsoleA(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved
    )
{

    WCHAR ExeName[BUFFER_SIZE/2];
    USHORT ExeNameLength;

    ExeNameLength = GetCurrentExeName(ExeName, sizeof(ExeName));

    return ReadConsoleInternal(hConsoleInput,
                               lpBuffer,
                               nNumberOfCharsToRead,
                               lpNumberOfCharsRead,
                               NULL,
                               FALSE,
                               ExeNameLength,
                               ExeName
                              );
    UNREFERENCED_PARAMETER(lpReserved);
}

BOOL
APIENTRY
ReadConsoleW(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved
    )
{
    WCHAR ExeName[BUFFER_SIZE/2];
    USHORT ExeNameLength;

    ExeNameLength = GetCurrentExeName(ExeName, sizeof(ExeName));

    return ReadConsoleInternal(hConsoleInput,
                               lpBuffer,
                               nNumberOfCharsToRead,
                               lpNumberOfCharsRead,
                               lpReserved,
                               TRUE,
                               ExeNameLength,
                               ExeName
                              );
    UNREFERENCED_PARAMETER(lpReserved);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleInternal(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN BOOLEAN Unicode
    )

/*++
Parameters:

    hFile - Supplies an open handle to to "CONOUT$" open for GENERIC_WRITE
        or the StdOut or StdErr handle.

    lpBuffer - Supplies the address of the data that is to be written to
        the console output.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        console output.

Return Value:

    NON-NULL - Returns the number of bytes actually written to the device.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.
--*/

{

    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLE_MSG a = &m.u.WriteConsole;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;

    if (Unicode) {
        a->NumBytes = nNumberOfCharsToWrite * sizeof(WCHAR);
    } else {
        a->NumBytes = nNumberOfCharsToWrite;
    }

    a->Unicode = Unicode;
    if (a->NumBytes > BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  a->NumBytes
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) lpBuffer,
                                 a->NumBytes,
                                 (PVOID *) &a->BufPtr
                               );
        a->BufferInMessage = FALSE;
    }
    else {
        a->BufPtr = a->Buffer;
        try {
            RtlCopyMemory( a->BufPtr, lpBuffer, a->NumBytes);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        CaptureBuffer = NULL;
        a->BufferInMessage = TRUE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsole
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    try {
       *lpNumberOfCharsWritten = a->NumBytes;
       if (Unicode) {
           *lpNumberOfCharsWritten /= sizeof(WCHAR);
       }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return TRUE;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleA(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN OUT LPVOID lpReserved
    )
{
    return WriteConsoleInternal(hConsoleOutput,
                                lpBuffer,
                                nNumberOfCharsToWrite,
                                lpNumberOfCharsWritten,
                                FALSE
                               );
    UNREFERENCED_PARAMETER(lpReserved);
}

BOOL
APIENTRY
WriteConsoleW(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN OUT LPVOID lpReserved
    )
{
    return WriteConsoleInternal(hConsoleOutput,
                                lpBuffer,
                                nNumberOfCharsToWrite,
                                lpNumberOfCharsWritten,
                                TRUE
                               );
    UNREFERENCED_PARAMETER(lpReserved);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
CloseConsoleHandle(
    IN HANDLE hConsole
    )

/*++

Parameters:

    hConsole - An open handle to console input or output.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CLOSEHANDLE_MSG a = &m.u.CloseHandle;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsole;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepCloseHandle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

HANDLE
APIENTRY
DuplicateConsoleHandle(
    IN HANDLE hSourceHandle,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwOptions
    )
/*++
Parameters:

    hSourceHandle - An open handle to the console device.

    dwDesiredAccess - The access requested to for the new handle.  This
        access must be equal to or a proper subset of the granted access
        associated with the SourceHandle.  This parameter is ignored if
        the DUPLICATE_SAME_ACCESS option is specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.


Return Value:

    Not -1 - Returns an open handle to the specified console device.
        Subsequent access to the file is controlled by the DesiredAccess
        parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.
--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_DUPHANDLE_MSG a = &m.u.DuplicateHandle;

    if (dwOptions & ~VALID_DUP_OPTIONS) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    if (((dwOptions & DUPLICATE_SAME_ACCESS) == 0) &&
         (dwDesiredAccess & ~VALID_ACCESSES)) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->SourceHandle = hSourceHandle;
    a->DesiredAccess = dwDesiredAccess;
    a->InheritHandle = (BOOLEAN) bInheritHandle;
    a->Options = dwOptions;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepDupHandle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->TargetHandle;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return INVALID_HANDLE_VALUE;
    }

}


BOOL
APIENTRY
GetConsoleHandleInformation(
    IN HANDLE hObject,
    OUT LPDWORD lpdwFlags
    )

/*++
Parameters:

    hObject - An open handle to console input or output.

    lpdwFlags - Receives flags for console object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETHANDLEINFORMATION_MSG a = &m.u.GetHandleInformation;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hObject;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetHandleInformation
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
           *lpdwFlags = a->Flags;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
APIENTRY
SetConsoleHandleInformation(
    IN HANDLE hObject,
    IN DWORD dwMask,
    IN DWORD dwFlags
    )

/*++
Parameters:

    hObject - An open handle to console input or output.

    dwMask - Flags to change.

    dwFlags - New values for flags.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETHANDLEINFORMATION_MSG a = &m.u.SetHandleInformation;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hObject;
    a->Mask = dwMask;
    a->Flags = dwFlags;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetHandleInformation
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
APIENTRY
VerifyConsoleIoHandle(
    IN HANDLE hIoHandle
    )

/*++
Parameters:

    hIoHandle - Handle to verify

Return Value:

    TRUE - handle is a valid console handle.

    FALSE - handle is not a valid console handle.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_VERIFYIOHANDLE_MSG a = &m.u.VerifyConsoleIoHandle;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hIoHandle;

    //
    // If this process doesn't have a console handle, bail immediately.
    //

    if (a->ConsoleHandle == NULL) {
        return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepVerifyIoHandle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->Valid;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }


}

#endif //!defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\conimep.h ===
// Copyright (c) 1985 - 1999, Microsoft Corporation

/*--------------------------------------------------------------------------*/
/*  Constants                                                               */
/*--------------------------------------------------------------------------*/

#if DBG==1
//#define DEBUG_MODE
//#define DEBUG_PRINT
//#define DEBUG_INFO
#endif


/*
 * Resource defines
 */
#define WINDOWMENU           1
#define ID_CONSOLEIME_ICON   2

/*
 * Menu ID's
 */
#define MM_ABOUT            8001
#define MM_EXIT                 8002
#define MM_ACCESS_VIOLATION     8003


/* String Table Defines */
#define errTitle        0
#define IDS_MENUNAME           12
#define IDS_APPNAME            13
#define IDS_CLASSNAME          14
#define IDS_TITLE              15

#define IDS_LAST               15       // Put New Strings Before this one




#ifdef DEBUG_PRINT
  #define DBGPRINT(_params_)  DbgPrint _params_
#else
  #define DBGPRINT(_params_)
#endif

#define CONSOLE_INITIAL_TABLE 10
#define CONSOLE_CONSOLE_TABLE_INCREMENT 5
#define HKL_INITIAL_TABLE 1
#define HKL_TABLE_INCREMENT 1

#define CVMAX            2048
#define NUMMAX           100
#define CMAX             160
#define MAXROW           1
#define MAXCOL           80
#define FIRSTROW         0
#define FIRSTCOL         0
#define LASTROW         (MAXROW-1)
#define LASTCOL         (MAXCOL-1)
#define TABSTOP          8
#define MAX_LISTCAND     32
#define MAX_CHARS_PER_LINE   10
#define MAX_COMP_STRING_LEN  10
#define DEFAULT_CAND_NUM_PER_PAGE 5
#define X_INDENT         10
#define Y_INDENT         10
#define DELIMITERWIDTH   3      // 1:xxx 2:xxx
#define DEFAULTCANDTABLE 100
#define DISPCHANGELIMIT  188
#define CODEDISPLEN      7      // '[F040] '
#define DEFAULT_TEMP_WIDTH 80

#define KEY_TOGGLED 0x01

#define MaxBufSize    256
#define KBDLAYOUT     TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts")
#define KBDLAYOUTTEXT TEXT("layout text")
#define KBDSEPALATER  TEXT("\\")

#define LANG_ID_TAIWAN  MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL) // 0x0404
#define LANG_ID_JAPAN   MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)            // 0x0411
#define LANG_ID_KOREA   MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT)              // 0x0412
#define LANG_ID_PRC     MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED)  // 0x0804

typedef struct _HKL_TABLE {
    HKL hkl;
    DWORD dwConversion;
} HKL_TABLE, *LPHKL_TABLE;

typedef struct _CONSOLE_TABLE {
    /*
     * Console Information
     */
    HANDLE hConsole;             // Handle of Console
    HWND hWndCon;               // Window handle of Console
    COORD ScreenBufferSize;      // Screen Buffer Size of Console
    /*
     * IMM/IME Basic Information
     */
    HKL hklActive;
    HIMC hIMC_Current;           // Handle of Input Context for current
    HIMC hIMC_Original;          // Handle of Input Context for original
    BOOL fOpen;                 // Open flag
    DWORD dwConversion;         // Conversion mode
    DWORD dwSentence;           // Sentence mode
    WORD ConsoleCP;
    WORD ConsoleOutputCP;
    WCHAR LayoutName[MaxBufSize];
    WCHAR GuideLine[10];
    /*
     * IMM/IME Composition String Information
     */
    BOOL fInComposition;         // Flag of in compositionning.
    LPCONIME_UICOMPMESSAGE lpCompStrMem;
    WORD  CompAttrColor[8];
    /*
     * IMM/IME Candidate Information
     */
    BOOL fInCandidate;           // Flag of in candidating
    LPCANDIDATELIST lpCandListMem[ MAX_LISTCAND ];
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    DWORD CandListMemAllocSize[ MAX_LISTCAND ];
    DWORD CandOff;
    DWORD CandMax;
    LPDWORD CandSep;
    DWORD CandSepAllocSize;
    BOOL fNestCandidate;
    DWORD ImmGetProperty;
    /*
     * misc
     */
    BOOL Enable;
    BOOL LateRemove;
    INT  hklListMax;
    LPHKL_TABLE lphklList;
#ifdef DEBUG_MODE
    DWORD ImeCandNum;
    DWORD CandidateCount;
    HWND hListCand[ MAX_LISTCAND ];
    WCHAR DispBuf[CMAX];
#endif
} CONSOLE_TABLE, *PCONSOLE_TABLE;

#define IPHK_HOTKEY                     0x0001          //
#define IPHK_PROCESSBYIME               0x0002          //
#define IPHK_CHECKCTRL                  0x0004          //

#define IS_IME_KBDLAYOUT(hkl) ((HIWORD(HandleToUlong(hkl)) & 0xf000) == 0xe000)
#define HKL_TO_LANGID(hkl)    (LOWORD(HandleToUlong(hkl)))

DWORD
ImmCallImeConsoleIME(
    HWND   hWnd,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam,
    PUINT  puVKey
    );

BOOL
ImmTranslateMessage(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
    );

BOOL
ImmSetActiveContextConsoleIME(
    HWND   hWnd,
    BOOL   fFlag
    );

#define UNICODE_BACKSPACE ((WCHAR)0x08)
#define UNICODE_BACKSPACE2 ((WCHAR)0x25d8)
#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_BELL ((WCHAR)0x07)
#define UNICODE_TAB ((WCHAR)0x09)
#define UNICODE_SPACE ((WCHAR)0x20)
#define UNICODE_ZERO ((WCHAR)'0')
#define UNICODE_SLASH ((WCHAR)'/')
#define UNICODE_COLON ((WCHAR)':')
#define UNICODE_LEFT ((WCHAR)'[')
#define UNICODE_RIGHT ((WCHAR)']')
#define UNICODE_HEXBASE ((WCHAR)'7')

#define JAPAN_CODEPAGE 932
#define PRC_CODEPAGE 936
#define KOREA_CODEPAGE 949
#define TAIWAN_CODEPAGE 950

#define PRCCOMPWIDTH 10

#define MODEDISP_NONE     0
#define MODEDISP_PLAURAL  1
#define MODEDISP_SINGLE   2
#define MODEDISP_AUTO     3
#define MODEDISP_PHRASE   4

// for Japanese
#define IMECModeRomanLen    4
#define IMECModeKanaLen     4
#define IMECModeAHANLen     3
#define IMECModeAZENLen     2
#define IMECModeHHANLen     3
#define IMECModeHZENLen     2
#define IMECModeKHANLen     3
#define IMECModeKZENLen     2

// for CHT /Taiwan
#define IMECModeFullShapeLen 1
#define IMECModeHalfShapeLen 1
#define IMECModeKeyboardLen  2
#define IMECModeSymbolLen    2
#define IMECGuideLen         5
#define IMECNameLength       4

/*****************************************************
 * Function definition
 *****************************************************/

//
// CONIME.C
//

BOOL
InitConsoleIME(
    HINSTANCE hInstance
    );

LRESULT FAR PASCAL
WndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
ExitList(
    HWND hWnd
    );

BOOL
InsertConsole(
    HWND    hWnd,
    HANDLE  hConsole,
    HWND    hWndConsole
    );

BOOL
GrowConsoleTable(
    VOID
    );


PCONSOLE_TABLE
SearchConsole(
    HANDLE hConsole
    );

BOOL
RemoveConsole(
    HWND hwnd,
    HANDLE hConsole
    );

BOOL
RemoveConsoleWorker(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

BOOL
InsertNewConsole(
    HWND   hWnd,
    HANDLE hConsole,
    HWND   hWndConsole
    );


BOOL
ConsoleSetFocus(
    HWND hWnd,
    HANDLE hConsole,
    HKL hKL
    );

BOOL
ConsoleKillFocus(
    HWND hWnd,
    HANDLE hConsole
    );

BOOL
ConsoleScreenBufferSize(
    HWND hWnd,
    HANDLE hConsolewParam,
    COORD ScreenBufferSize
    );

BOOL
ConImeInputLangchangeRequest(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl,
    int Direction
    );

BOOL
ConImeInputLangchange(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl
    );

LRESULT
ConsoleImeSendMessage(
    HWND   hWndConsoleIME,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InputLangchange(
    HWND hWnd,
    DWORD CharSet,
    HKL hkl );

#ifdef DEBUG_MODE

VOID
DisplayConvInformation(
    HWND hWnd
    );

VOID
DisplayInformation(
    HWND hWnd,
    HANDLE hConsole
    );

VOID
RealReDraw(
    HDC r_hdc
    );

VOID
ReDraw(
    HWND hWnd
    );
#endif

//
// CONSUBS.C
//

INT
Create(
    HWND hWnd
    );

void
ImeUIStartComposition(
    HWND hwnd
    );

void
ImeUIEndComposition(
    HWND hwnd
    );

void
ImeUIComposition(
    HWND hwnd,
    WPARAM wParam,
    LPARAM CompFlag
    );

void
DisplayCompString(
    HWND hwnd,
    int Length,
    PWCHAR CharBuf,
    PUCHAR AttrBuf
    );

void
DisplayResultString(
    HWND hwnd,
    LPWSTR lpStr
    );

BOOL
ImeUINotify(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
IsUnicodeFullWidth(
    IN WCHAR wch
    );


BOOL
ImeUIOpenStatusWindow(
    HWND hwnd
    );

BOOL
ImeUIChangeCandidate(
   HWND hwnd,
   DWORD lParam
   );

BOOL
ImeUISetOpenStatus(
    HWND hwnd
    );

BOOL
ImeUISetConversionMode(
    HWND hwnd
    );

BOOL
    ImeUIGuideLine(
    HWND hwnd
    );

DWORD
GetNLSMode(
    HWND hWnd,
    HANDLE hConsole
    );

BOOL
SetNLSMode(
    HWND hWnd,
    HANDLE hConsole,
    DWORD fdwConversion
    );


VOID
CopyDataProcess(
    HWND hWnd,
    PCOPYDATASTRUCT CopyData
    );

BOOL
ImeSysPropertyWindow(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

//
//  IMEFULL.C
//
VOID
ImeOpenClose(
    HWND hWnd,
    BOOL fFlag
    );

VOID
VirtualKeyHandler(
    HWND hWnd,
    UINT wParam,
    UINT lParam
    );

VOID
CharHandlerFromConsole(
    HWND hWnd,
    UINT Message,
    ULONG wParam,
    ULONG lParam
    );

VOID
CharHandlerToConsole(
    HWND hWnd,
    UINT Message,
    ULONG wParam,
    ULONG lParam
    );

#ifdef DEBUG_MODE
VOID
ImeUIMoveCandWin(
    HWND hwnd
    );
#endif

BOOL
IsDBCSTrailByte(
    char *base,
    char *p
    );

#ifdef DEBUG_MODE
VOID
ResetCaret(
    HWND hWnd
    );

BOOL
MoveCaret(
    HWND hwnd
    );
#endif

#ifdef DEBUG_MODE
VOID
StoreChar(
    HWND hWnd,
    WORD ch,
    UCHAR atr
    );
#endif

BOOL
ConsoleCodepageChange(
    HWND hWnd,
    HANDLE hConsole,
    BOOL Output,
    WORD CodePage
    );

//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
//L                                       L
//L     COUNTRY.C                         L
//L                                       L
//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

BOOL
ConimeHotkey(
    HWND hWnd,
    HANDLE hConsole,
    DWORD HotkeyID
    );

BOOL
GetIMEName(
    PCONSOLE_TABLE ConTbl
    );

BOOL
GetOpenStatusByCodepage(
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl
    );

BOOL
ImeUIMakeInfoString(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

BOOL
MakeInfoStringJapan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

BOOL
MakeInfoStringTaiwan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

DWORD
MakeStatusStrTaiwan1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
MakeStatusStrTaiwan2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCompositionT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCandidateT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
DispLenStructedUnicode(
    PCHAR_INFO lpString,
    DWORD SrcLength
    );

BOOL
MakeInfoStringPRC(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

DWORD
MakeStatusStrPRC1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
MakeStatusStrPRC2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCompositionP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCandidateP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

BOOL
MakeInfoStringKorea(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
//L                                       L
//L     COUNTRY2.C                        L
//L                                       L
//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

BOOL
ImeUIOpenCandidate(
   HWND hwnd,
   DWORD lParam,
   BOOL OpenFlag
   );

BOOL
OpenCandidateJapan(
    HWND hwnd,
    HIMC  hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

BOOL
OpenCandidateTaiwan(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

BOOL
OpenCandidatePRC(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

BOOL
OpenCandidateKorea(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

DWORD
DispLenUnicode(
    LPWSTR lpString
    );

DWORD
GetSystemLineJ(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole,
    BOOL EnableCodePoint
    );

DWORD
GetSystemLineT(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    );

DWORD
GetSystemLineP(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    );

VOID
NumString(
    LPWSTR StrToWrite,
    DWORD NumToDisp,
    DWORD CountDispWidth
    );

BOOL
ImeUICloseCandidate(
   HWND hwnd,
   DWORD lParam
   );

BOOL
CloseCandidateJapan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

BOOL
CloseCandidateTaiwan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

BOOL
CloseCandidatePRC(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

BOOL
CloseCandidateKorea(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
//L                                       L
//L     COUNTRY3.C                        L
//L                                       L
//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

void
GetCompositionStr(
    HWND hwnd,
    LPARAM CompFlag,
    WPARAM CompChar
    );

void
GetCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    );

void
GetCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    );

void
GetCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    );

void
GetCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag,
    WPARAM CompChar
    );

VOID
ReDisplayCompositionStr (
    HWND hwnd
    );

VOID
ReDisplayCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

VOID
ReDisplayCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

VOID
ReDisplayCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

VOID
ReDisplayCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\country.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   country.c
//
//  PURPOSE:   Console IME control.
//             FarEast country specific module for conime.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//    ImeUIMakeInfoString() - routine for make status string
//
//  History:
//
//  10.Jul.1996 v-HirShi (Hirotoshi Shimizu)    Created for TAIWAN & KOREA & PRC
//
//  COMMENTS:
//
#include "precomp.h"
#pragma hdrstop

// for Japanese
//                             none  plaural single    auto  phrase
WCHAR IMECMode[]          = { 0x7121, 0x8907, 0x5358, 0x81ea, 0x9023 };
WCHAR IMECModeRoman[]     = { 0xff9b, 0xff70, 0xff8f, 0x0020 };
WCHAR IMECModeKana[]      = { 0xff76, 0xff85, 0x0020, 0x0020 };
WCHAR IMECModeAHAN[]      = { 0x534a, 0x0041, 0x0020 };
WCHAR IMECModeAZEN[]      = { 0x5168, 0xff21 };
WCHAR IMECModeHHAN[]      = { 0x534a, 0xff71, 0x0020 };
WCHAR IMECModeHZEN[]      = { 0x5168, 0x3042 };
WCHAR IMECModeKHAN[]      = { 0x534a, 0xff76, 0x0020 };
WCHAR IMECModeKZEN[]      = { 0x5168, 0x30ab };

// for CHT /Taiwan
WCHAR IMECModeFullShape[] = { 0x5168, 0x5f62 };
WCHAR IMECModeHalfShape[] = { 0x534a, 0x5f62 };
WCHAR IMECModeKeyboard[]  = { 0x9375, 0x76e4 };
WCHAR IMECModeSymbol[]    = { 0x7b26, 0x53f7 };
WCHAR IMECGuide[9][7]     = {{ 0x5009, 0x9821, 0x8acb, 0x8f38, 0x5165, 0x5b57, 0x6839 },    // kura
                             { 0x5167, 0x78bc, 0x8acb, 0x8f38, 0x5165, 0x5167, 0x78bc },    // naima
                             { 0x55ae, 0x78bc, 0x8acb, 0x8f38, 0x5165, 0x55ae, 0x78bc },    // tanma
                             { 0x901f, 0x6210, 0x8acb, 0x8f38, 0x5165, 0x5b57, 0x6839 },    // sokusei
                             { 0x5927, 0x6613, 0x8acb, 0x8f38, 0x5165, 0x5b57, 0x6839 },    // taieki
                             { 0x82f1, 0x6570, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000 },    // eisuu
                             { 0xff55, 0xff53, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000 },    // US
                             { 0x6ce8, 0x97f3, 0x8acb, 0x8f38, 0x5165, 0x7b26, 0x865f },    // chuon fugou
                             { 0x6ce8, 0x97f3, 0x8acb, 0x3000, 0x9078, 0x3000, 0x5b57 } }; // chuon senji
/*
WCHAR IMECNAMEPRC[9][7]   = { 0x5168, 0x62fc, 0 };                   // zenhei
                            { 0x53cc, 0x62fc, 0 };                   // souhei
                            { 0x6807, 0x51c6, 0 };                   // sijun
                            { 0x53cc, 0x6253, 0 };                   // souda
                            { 0x90d1, 0x7801, 0 };                   // hou?
                            { 0x8868, 0x5f62, 0x7801, 0 };           // hyoukei
                            { 0x7e41, 0x4f53, 0x6ce8, 0x97f3, 0 };   // chuon
                            { 0x7e41, 0x4f53, 0x4ed3, 0x9889, 0 };   // kaihou
                            { 0x533a, 0x4f4d, 0 };                   // kui
                            { 0x0047, 0x0042, 0x004a, 0x5185, 0x7801, 0 };   // GBKnaikou
                            { 0x0055, 0x006e, 0x0069, 0x0063, 0x006f, 0x0064, 0x0065, 0 };   // Unicode
*/

BOOL
ConimeHotkey(
    HWND hWnd,
    HANDLE hConsole,
    DWORD HotkeyID
    )
{
//    PCONSOLE_TABLE ConTbl;
//
//    ConTbl = SearchConsole(hConsole);
//    if (ConTbl == NULL) {
//        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
//        return FALSE;
//    }

    return ImmSimulateHotKey(hWnd,(DWORD)HotkeyID);
}

BOOL
GetIMEName(
    PCONSOLE_TABLE ConTbl
    )
{
    WCHAR buf[MaxBufSize];
    WCHAR name[MaxBufSize];
    DWORD bufsize = MaxBufSize;
    LONG lResult;
    HKEY hkLayout;
    int i;

    ConTbl->LayoutName[0] = TEXT('\0');
    ConTbl->GuideLine[0] = TEXT('\0');

    if (ImmEscape(ConTbl->hklActive, ConTbl->hIMC_Current, IME_ESC_IME_NAME, (LPTSTR)&name) == 0)
    {
        if (!ImmGetIMEFileName(ConTbl->hklActive, (LPTSTR)&name, MaxBufSize ) )
        {
            if (GetKeyboardLayoutName((LPTSTR)&name) ) 
            {
                /*
                 * quick dirty ImmIsIME
                 */
                if (name[0] != TEXT('E') &&
                    name[0] != TEXT('e'))
                {
                    return FALSE;
                }

                lstrcpy( buf, KBDLAYOUT );
                lstrcat( buf, KBDSEPALATER );
                lstrcat( buf, name );
                lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       (LPCTSTR)buf,
                                       0,
                                       KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                       &hkLayout );
                if ( lResult == ERROR_SUCCESS ) {
                    lResult = RegQueryValueEx( hkLayout,
                                               KBDLAYOUTTEXT,
                                               NULL,
                                               NULL,
                                               (LPBYTE)ConTbl->LayoutName,
                                               &bufsize );
                    RegCloseKey( hkLayout );
                    if (ConTbl->LayoutName[0] != TEXT('\0')) {
                        for (i = 0; i < 8; i ++){
                            if ((ConTbl->LayoutName[0] == IMECGuide[i][0]) &&
                                (ConTbl->LayoutName[1] == IMECGuide[i][1]) ) {
                                lstrcpyn(&(ConTbl->GuideLine[0]), &(IMECGuide[i][2]), IMECGuideLen+1);
                                break;
                            }
                        }
                    }
                }
                else{
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            lstrcpy( ConTbl->LayoutName, name );
        }
    }
    else
    {
        lstrcpy( ConTbl->LayoutName, name);
    }

    return TRUE;
}

BOOL
GetOpenStatusByCodepage(
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl
    )
{
    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            return ImmGetOpenStatus(hIMC);
            break;
        case    LANG_ID_TAIWAN:
        case    LANG_ID_PRC:
        case    LANG_ID_KOREA:
            if (ImmGetOpenStatus(hIMC)) {
                return ImmIsIME(ConTbl->hklActive);
            }
            break;
        default:
            return FALSE;
    }
    return FALSE;
}

BOOL
ImeUIMakeInfoString(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            return MakeInfoStringJapan(ConTbl, lpModeInfo);
            break;
        case    LANG_ID_TAIWAN:
            return MakeInfoStringTaiwan(ConTbl, lpModeInfo);
            break;
        case    LANG_ID_PRC:
            return MakeInfoStringPRC(ConTbl, lpModeInfo);
            break;
        case    LANG_ID_KOREA:
            return MakeInfoStringKorea(ConTbl, lpModeInfo);
            break;
        default:
            return FALSE;
    }
}

BOOL
MakeInfoStringJapan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    int i , j;
    DWORD dwConversion;
    DWORD dwSentence;

    dwConversion = ConTbl->dwConversion;
    dwSentence = ConTbl->dwSentence;

    i = j = 0;
    if (ConTbl->fOpen){
        if (dwConversion & IME_CMODE_FULLSHAPE) {
            if (dwConversion & IME_CMODE_NATIVE) {
                if (dwConversion & IME_CMODE_KATAKANA) {
                    for (j = 0; j < IMECModeKZENLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeKZEN[j];
                }
                else {
                    for (j = 0; j < IMECModeHZENLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeHZEN[j];
                }
            }
            else {
                for (j = 0; j < IMECModeAZENLen; j++, i++)
                    lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeAZEN[j];
            }
        }
        else {
            if (dwConversion & IME_CMODE_NATIVE) {
                if (dwConversion & IME_CMODE_KATAKANA) {
                    for (j = 0; j < IMECModeKHANLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeKHAN[j];
                }
                else {
                    for (j = 0; j < IMECModeHHANLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeHHAN[j];
                }
            }
            else {
                for (j = 0; j < IMECModeAHANLen; j++, i++)
                    lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeAHAN[j];
            }
        }

        if (dwSentence & IME_SMODE_NONE)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_NONE];
        else if (dwSentence & IME_SMODE_PLAURALCLAUSE)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_PLAURAL];
        else if (dwSentence & IME_SMODE_SINGLECONVERT)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_SINGLE];
        else if (dwSentence & IME_SMODE_AUTOMATIC)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_AUTO];
        else if (dwSentence & IME_SMODE_PHRASEPREDICT)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_PHRASE];
        else {
            lpModeInfo->ModeString[i++].Char.UnicodeChar = 0x0020;
            lpModeInfo->ModeString[i].Char.UnicodeChar = 0x0020;
        }
        i++;

        if (GetKeyState(VK_KANA) & 1) {
            for (j = 0; j < IMECModeKanaLen; j++, i++)
                lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeKana[j];
        }
        else if (dwConversion & IME_CMODE_ROMAN) {
            for (j = 0; j < IMECModeRomanLen; j++, i++)
                lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeRoman[j];
        }
    }
    else {
        /*
         * In this case, fOpen is 0 (==close).
         * Should be fill mode text buffer in console.
         * So, console can do fill up that pass to 0 length.
         */
        i = 0;
    }
    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    lpModeInfo->ModeStringLen = i;
    lpModeInfo->Position = VIEW_RIGHT;
    return TRUE;
}


BOOL
MakeInfoStringTaiwan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    DWORD j;
    DWORD ModeInfoPtr;
    DWORD LengthForDisp;

    ModeInfoPtr = 0;

    if (ImmIsIME(ConTbl->hklActive) ){
        ModeInfoPtr = MakeStatusStrTaiwan1(ConTbl, lpModeInfo, ModeInfoPtr);
        if (ConTbl->fInComposition) {
            if (ConTbl->fInCandidate){
                ModeInfoPtr = IncludeCandidateT(ConTbl, lpModeInfo, ModeInfoPtr);
            }
            else{
                ModeInfoPtr = IncludeCompositionT(ConTbl, lpModeInfo, ModeInfoPtr);
            }
        }
        ModeInfoPtr = MakeStatusStrTaiwan2(ConTbl, lpModeInfo, ModeInfoPtr);
    }

    lpModeInfo->ModeStringLen = ModeInfoPtr;
    lpModeInfo->Position = VIEW_LEFT;
    return TRUE;
}

DWORD
MakeStatusStrTaiwan1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD Length;
    DWORD dwConversion;

    dwConversion = ConTbl->dwConversion;

    i = ModeInfoPtr;
    j = 0;
    Length = 0;
    while (Length < IMECNameLength ) {
        if (ConTbl->LayoutName[j] == 0 )
            break;
        lpModeInfo->ModeString[i].Char.UnicodeChar = ConTbl->LayoutName[j];
        Length += IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1;
        j++;
        i++;
    }
    if (Length < IMECNameLength+1) {
        for (j = Length; j < IMECNameLength+1; j++ ) {
            lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
        }
    }

    if (dwConversion & IME_CMODE_FULLSHAPE) {
        for (j = 0; j < IMECModeFullShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeFullShape[j];
    }
    else{
        for (j = 0; j < IMECModeHalfShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeHalfShape[j];
    }

    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

#if defined (CANDCOUNTPRC) //for wider candidate list space Oct.16.1996
    if (ConTbl->fInCandidate){
        for (j = 0; j < IMECGuideLen; j++ )
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECGuide[8][2+j];
    }
    else if (ConTbl->GuideLine[0]){
        for (j = 0; j < IMECGuideLen; j++ )
            lpModeInfo->ModeString[i++].Char.UnicodeChar = ConTbl->GuideLine[j];
    }
#endif

    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_COLON;

    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
MakeStatusStrTaiwan2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD LengthOfStr;
    DWORD LengthForNum;
    DWORD LengthForNum2;
    DWORD CountDispWidth;
    DWORD StatusWidth;
    DWORD i;
    DWORD j;

    i = ModeInfoPtr;

    StatusWidth = ConTbl->ScreenBufferSize.X;
    if (StatusWidth > MAXSTATUSCOL) {
        StatusWidth = MAXSTATUSCOL;
    }
#if defined (CANDCOUNTCHT) //for wider candidate list space v-hirshi Oct.16.1996
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr) + 1 + 4;
#else
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr);
#endif

    if (LengthOfStr > StatusWidth) {
        for ( ; LengthOfStr > StatusWidth; i-- ) {
            LengthOfStr -= (IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1 );
        }
    }

    for (j = 0; j < (StatusWidth - LengthOfStr); j++) {
        lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    }

#if defined (CANDCOUNTCHT) //for wider candidate list space v-hirshi Oct.16.1996
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

    if (ConTbl->dwConversion & IME_CMODE_SYMBOL) {
        for (j = 0; j < IMECModeSymbolLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeSymbol[j];
    }
    else{
        for (j = 0; j < IMECModeKeyboardLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeKeyboard[j];
    }
#endif

    for (j = ModeInfoPtr; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
IncludeCompositionT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD k;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->lpCompStrMem == NULL) {
        return i;
    }
    lpCompStrMem = ConTbl->lpCompStrMem;
    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lpCompStrMem->dwCompStrLen +  sizeof(WCHAR));

    k = 0;
    for (j = 0; k < lpCompStrMem->dwCompStrLen; j++, k += sizeof(WCHAR)) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }
    return i;
}

DWORD
IncludeCandidateT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD dwLength;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_CANDMESSAGE SystemLine;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;
    lpCompStrMem = ConTbl->lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->SystemLine == NULL) {
        return i;
    }
    SystemLine = ConTbl->SystemLine;
    dwLength = (SystemLine->AttrOff - sizeof(DWORD) ) / sizeof(WCHAR) ;
    TempBuf  = (PWCHAR)(SystemLine->String);
    TempBufA = (PUCHAR)((LPSTR)SystemLine + SystemLine->AttrOff);

    for (j = 0; TempBuf[j] != 0; j++ ) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }

    return i;
}

DWORD
DispLenStructedUnicode(
    PCHAR_INFO lpString,
    DWORD SrcLength
    )
{
    DWORD i;
    DWORD Length;

    Length = 0;

    for ( i = 0; i < SrcLength; i++) {
        Length += IsUnicodeFullWidth(lpString[i].Char.UnicodeChar) ? 2 : 1;
    }
    return Length;
}


BOOL
MakeInfoStringPRC(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    DWORD j;
    DWORD ModeInfoPtr;
    DWORD LengthForDisp;

    ModeInfoPtr = 0;

    if (ImmIsIME(ConTbl->hklActive) ){
        ModeInfoPtr = MakeStatusStrPRC1(ConTbl, lpModeInfo, ModeInfoPtr);
        if (ConTbl->fInComposition) {
            if (ConTbl->fInCandidate){
                ModeInfoPtr = IncludeCandidateP(ConTbl, lpModeInfo, ModeInfoPtr);
            }
            else{
                ModeInfoPtr = IncludeCompositionP(ConTbl, lpModeInfo, ModeInfoPtr);
            }
        }
        ModeInfoPtr = MakeStatusStrPRC2(ConTbl, lpModeInfo, ModeInfoPtr);
    }

    lpModeInfo->ModeStringLen = ModeInfoPtr;
    lpModeInfo->Position = VIEW_LEFT;
    return TRUE;
}

DWORD
MakeStatusStrPRC1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD dwConversion;
    DWORD Length;

    dwConversion = ConTbl->dwConversion;

    i = ModeInfoPtr;
    j = 0;
    Length = 0;
    while (Length < 9) {
        if (ConTbl->LayoutName[j] == 0 )
            break;
        if (ConTbl->LayoutName[j] == 0x8f93)
            break;
        lpModeInfo->ModeString[i].Char.UnicodeChar = ConTbl->LayoutName[j];
        Length += IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1;
        j++;
        i++;
    }
    if (Length < 9) {
        for (j = Length; j < 9; j++ ) {
            lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
        }
    }


    if (dwConversion & IME_CMODE_FULLSHAPE) {
        for (j = 0; j < IMECModeFullShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeFullShape[j];
    }
    else{
        for (j = 0; j < IMECModeHalfShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeHalfShape[j];
    }

// v-HirShi Oct.14.1996 delete it for get space
//  lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_COLON;

    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
MakeStatusStrPRC2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD LengthOfStr;
    DWORD LengthForNum;
    DWORD LengthForNum2;
    DWORD CountDispWidth;
    DWORD StatusWidth;
    DWORD i;
    DWORD j;

    i = ModeInfoPtr;

    StatusWidth = ConTbl->ScreenBufferSize.X;
    if (StatusWidth > MAXSTATUSCOL) {
        StatusWidth = MAXSTATUSCOL;
    }
#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr) + 1 + 4;
#else
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr);
#endif

    if (LengthOfStr > StatusWidth) {
        for ( ; LengthOfStr > StatusWidth; i-- ) {
            LengthOfStr -= (IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1 );
        }
    }
    for (j = 0; j < (StatusWidth - LengthOfStr); j++) {
        lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    }
#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

    if (ConTbl->dwConversion & IME_CMODE_SYMBOL) {
        for (j = 0; j < IMECModeSymbolLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeSymbol[j];
    }
    else{
        for (j = 0; j < IMECModeKeyboardLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeKeyboard[j];
    }
#endif

    for (j = ModeInfoPtr; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
IncludeCompositionP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD k;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->lpCompStrMem == NULL) {
        return i;
    }
    lpCompStrMem = ConTbl->lpCompStrMem;
    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lpCompStrMem->dwCompStrLen +  sizeof(WCHAR));

    k = 0;
    for (j = 0; k < lpCompStrMem->dwCompStrLen; j++, k += sizeof(WCHAR)) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }
    return i;
}

DWORD
IncludeCandidateP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD UnicodeLen;
    DWORD dwLength;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_CANDMESSAGE SystemLine;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->SystemLine == NULL) {
        return i;
    }
    lpCompStrMem = ConTbl->lpCompStrMem;
    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lpCompStrMem->dwCompStrLen +  sizeof(WCHAR));

    k = 0;
    UnicodeLen = 0;
    for (j = 0; (k < lpCompStrMem->dwCompStrLen )&&(UnicodeLen < PRCCOMPWIDTH); j++, k += sizeof(WCHAR)) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
       UnicodeLen += IsUnicodeFullWidth(TempBuf[j]) ? 2 : 1;
    }

    for ( j = UnicodeLen; j < PRCCOMPWIDTH; j++) {
        lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    }
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_COLON;

    SystemLine = ConTbl->SystemLine;
    dwLength = (SystemLine->AttrOff - sizeof(DWORD) ) / sizeof(WCHAR) ;
    TempBuf  = (PWCHAR)(SystemLine->String);
    TempBufA = (PUCHAR)((LPSTR)SystemLine + SystemLine->AttrOff);

    for (j = 0; TempBuf[j] != 0; j++ ) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }

    return i;
}

BOOL
MakeInfoStringKorea(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    int i , j;

    i = 0;
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    lpModeInfo->ModeStringLen = i;
    lpModeInfo->Position = VIEW_RIGHT;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\country2.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   country2.c
//
//  PURPOSE:   Console IME control.
//             FarEast country specific module 2 for conime.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//    ImeUIOpenCandidate() - routine for make system line string
//
//  History:
//
//  15.Jul.1996 v-HirShi (Hirotoshi Shimizu)    Created for TAIWAN & KOREA & PRC
//
//  COMMENTS:
//
#include "precomp.h"
#pragma hdrstop


BOOL
ImeUIOpenCandidate(
    HWND hwnd,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC  hIMC;

    DBGPRINT(("CONIME: Get IMN_OPENCANDIDATE Message\n"));


    ConTbl = SearchConsole(LastConsole);

    if (ConTbl->fNestCandidate)
        return TRUE;

    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return FALSE;

    //
    // Set fInCandidate variables.
    //
    ConTbl->fInCandidate = TRUE;

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            OpenCandidateJapan(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        case    LANG_ID_TAIWAN:
            OpenCandidateTaiwan(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        case    LANG_ID_PRC:
            OpenCandidatePRC(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        case    LANG_ID_KOREA:
            OpenCandidateKorea(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        default:
            return FALSE;
    }

    ImmReleaseContext( hwnd, hIMC );

    return TRUE;
}


BOOL
OpenCandidateJapan(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    BOOL EnableCodePoint;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

            if (lpCandList->dwStyle == IME_CAND_CODE){
                EnableCodePoint = TRUE;
            }
            else{
                EnableCodePoint = FALSE;
            }

            if (EnableCodePoint){
                CountDispWidth = CODEDISPLEN;
            }
            else {
                for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                     j *= 10;
                CountDispWidth *= 2;
                CountDispWidth++;
            }

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            if ( EnableCodePoint ){
                j = 0;
                ConTbl->CandSep[j++] = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = lpCandList->dwSelection % 9;
                }
                i = ConTbl->CandOff;
                for (; i < lpCandList->dwCount; i+= 9 ) {
                    ConTbl->CandSep[j++] = i;
                }
                if (i > lpCandList->dwCount) {
                    i = lpCandList->dwCount;
                }
            }
            else{
                j = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = 0;
                }
                ConTbl->CandSep[j++] = ConTbl->CandOff;
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
                dwDspLen = DispLenUnicode( lpStr );
                width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
                for( i = 1; i < lpCandList->dwCount; i++ ) {
                    lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                    dwDspLen = DispLenUnicode( lpStr );
                    width += dwDspLen + DELIMITERWIDTH;
                    if ((width > dwLength-CountDispWidth) ||
                        ( i - ConTbl->CandSep[j-1] >= 9)){
                        ConTbl->CandSep[j++] = i;
                        width = dwDspLen + DELIMITERWIDTH;
                    }
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            CopyData.dwData = CI_CONIMECANDINFO;
            CopyData.cbData = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            CopyData.lpData = SystemLine;
            StartIndex = GetSystemLineJ( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl,
                           EnableCodePoint);

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                  );
        }
    }
    return TRUE;
}

BOOL
OpenCandidateTaiwan(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );
#if defined (CANDCOUNTCHT) //for wider candidate list space v-hirshi Oct.16.1996
            dwLength -= 28; // 6+1+4+1+10+1+....+4+1
#else
            dwLength -= IMECNameLength+1+IMECModeFullShapeLen*2+1; // 4+1+2+1+....
#endif

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

            for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                 j *= 10;
            CountDispWidth *= 2;
            CountDispWidth++;

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            j = 0;
            if (OpenFlag) {
                ConTbl->CandOff = 0;
            }
            ConTbl->CandSep[j++] = ConTbl->CandOff;
            lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
            dwDspLen = DispLenUnicode( lpStr );
            width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
            for( i = 1; i < lpCandList->dwCount; i++ ) {
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                dwDspLen = DispLenUnicode( lpStr );
                width += dwDspLen + DELIMITERWIDTH;
                if ((width > dwLength-CountDispWidth) ||
                    ( i - ConTbl->CandSep[j-1] >= 9)){
                    ConTbl->CandSep[j++] = i;
                    width = dwDspLen + DELIMITERWIDTH;
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            StartIndex = GetSystemLineT( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl
                           );

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            CopyData.dwData = CI_CONIMEMODEINFO;
            CopyData.cbData = sizeof(CONIME_UIMODEINFO);
            CopyData.lpData = lpModeInfo;
            if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
                ConsoleImeSendMessage( ConTbl->hWndCon,
                                       (WPARAM)hwnd,
                                       (LPARAM)&CopyData
                                     );
            }
        }
    }
    LocalFree( lpModeInfo );
    return TRUE;
}

BOOL
OpenCandidatePRC(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );
#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
            dwLength -= (20 + PRCCOMPWIDTH); //(8+1+4+1+PRCCOMPWIDTH+1+...+5)
#else
            dwLength -= (15 + PRCCOMPWIDTH); //(8+1+4+1+PRCCOMPWIDTH+1+...)
#endif

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
            for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                 j *= 10;
            CountDispWidth *= 2;
            CountDispWidth++;
#else
            CountDispWidth = 0;
#endif

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            j = 0;
            if (OpenFlag) {
                ConTbl->CandOff = 0;
            }
            ConTbl->CandSep[j++] = ConTbl->CandOff;
            lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
            dwDspLen = DispLenUnicode( lpStr );
            width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
            for( i = 1; i < lpCandList->dwCount; i++ ) {
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                dwDspLen = DispLenUnicode( lpStr );
                width += dwDspLen + DELIMITERWIDTH;
                if ((width > dwLength-CountDispWidth) ||
                    ( i - ConTbl->CandSep[j-1] >= 9)){
                    ConTbl->CandSep[j++] = i;
                    width = dwDspLen + DELIMITERWIDTH;
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            StartIndex = GetSystemLineP( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl
                           );

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            CopyData.dwData = CI_CONIMEMODEINFO;
            CopyData.cbData = sizeof(CONIME_UIMODEINFO);
            CopyData.lpData = lpModeInfo;
            if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
                ConsoleImeSendMessage( ConTbl->hWndCon,
                                       (WPARAM)hwnd,
                                       (LPARAM)&CopyData
                                     );
            }
        }
    }
    LocalFree( lpModeInfo );
    return TRUE;
}

BOOL
OpenCandidateKorea(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    BOOL EnableCodePoint;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

            if (lpCandList->dwStyle == IME_CAND_CODE){
                EnableCodePoint = TRUE;
            }
            else{
                EnableCodePoint = FALSE;
            }

            if (EnableCodePoint){
                CountDispWidth = CODEDISPLEN;
            }
            else {
                for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                     j *= 10;
                CountDispWidth *= 2;
                CountDispWidth++;
            }

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            if ( EnableCodePoint ){
                j = 0;
                ConTbl->CandSep[j++] = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = lpCandList->dwSelection % 9;
                }
                i = ConTbl->CandOff;
                for (; i < lpCandList->dwCount; i+= 9 ) {
                    ConTbl->CandSep[j++] = i;
                }
                if (i > lpCandList->dwCount) {
                    i = lpCandList->dwCount;
                }
            }
            else{
                j = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = 0;
                }
                ConTbl->CandSep[j++] = ConTbl->CandOff;
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
                dwDspLen = DispLenUnicode( lpStr );
                width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
                for( i = 1; i < lpCandList->dwCount; i++ ) {
                    lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                    dwDspLen = DispLenUnicode( lpStr );
                    width += dwDspLen + DELIMITERWIDTH;
                    if ((width > dwLength-CountDispWidth) ||
                        ( i - ConTbl->CandSep[j-1] >= 9)){
                        ConTbl->CandSep[j++] = i;
                        width = dwDspLen + DELIMITERWIDTH;
                    }
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            CopyData.dwData = CI_CONIMECANDINFO;
            CopyData.cbData = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            CopyData.lpData = SystemLine;
            StartIndex = GetSystemLineJ( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl,
                           EnableCodePoint);

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }
    return TRUE;
}

DWORD
DispLenUnicode(
    LPWSTR lpString )
{
    DWORD i;
    DWORD Length;

    Length = 0;

    for ( i = 0; lpString[i] != 0; i++) {
        Length += IsUnicodeFullWidth(lpString[i]) ? 2 : 1;
    }
    return Length;
}

DWORD
GetSystemLineJ(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole,
    BOOL EnableCodePoint)
{
    DWORD dwStrLen;
    DWORD dwDspLen;
    DWORD i;
    DWORD j;
    DWORD SepIndex;
    DWORD SelCount;
    DWORD Length;
    DWORD dwWholeLen;
    BOOL lfBreak = FALSE;
    LPWSTR StrToWrite;
    LPSTR AttrToSel;
    LPWSTR lpStr;
    USHORT MultiChar;
    USHORT TempMulti;

    if (lpCandList->dwSelection > lpCandList->dwCount) {
        lpCandList->dwSelection = 0;
    }

    for ( SepIndex = FocusedConsole->CandMax; SepIndex > 0; SepIndex--) {
        if (lpCandList->dwSelection >= FocusedConsole->CandSep[SepIndex])
            break;
    }
    if (SepIndex == FocusedConsole->CandMax)
        SepIndex = 0;

    for ( i = 0; i < dwLength; i++) {
        Attr[i] = 0x0000;
    }
    StrToWrite = String;
    AttrToSel = Attr;
    dwWholeLen = 0;
#if 1
    // HACK HACK ntbug #69699
    // MS-IME97 & MS-IME97A does not return correct value for IME_PROP_CANDLIST_START_FROM_1.
    // These always return its starting from 0.
    // Currently there is not IME starting from 0. So we hack.
    // Actually IME should be fixed.
    SelCount = 1;
#else
    if (FocusedConsole->ImmGetProperty & IME_PROP_CANDLIST_START_FROM_1)
        SelCount = 1;
    else
        SelCount = 0;
#endif

    if (EnableCodePoint){
        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[lpCandList->dwSelection]);
        WideCharToMultiByte(CP_OEMCP, 0, lpStr, 1, (PBYTE)&TempMulti, 2, NULL, NULL);
        *StrToWrite = UNICODE_LEFT;
        StrToWrite++;
        MultiChar = (USHORT)(HIBYTE(TempMulti)| LOBYTE(TempMulti)<<8);
        for (i = 0; i < 4; i++) {
            j = (MultiChar & 0xf000 ) >> 12;
            if ( j <= 9)
                *StrToWrite = (USHORT)(j + UNICODE_ZERO);
            else
                *StrToWrite = (USHORT)(j + UNICODE_HEXBASE);
            StrToWrite++;
            MultiChar = (USHORT)(MultiChar << 4);
        }
        *StrToWrite = UNICODE_RIGHT;
        StrToWrite++;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += CountDispWidth;
        dwWholeLen += CountDispWidth;
        CountDispWidth = 0;
    }

    for (i = FocusedConsole->CandSep[SepIndex]; i < FocusedConsole->CandSep[SepIndex+1]; i++) {
        //
        // check each offset value is not over than buffer size.
        //
        if (lpCandList->dwOffset[i] >= lpCandList->dwSize)
            break;

        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
        dwStrLen = lstrlenW( lpStr );
        dwDspLen = DispLenUnicode( lpStr );

        if ( dwWholeLen + dwDspLen + DELIMITERWIDTH  > dwLength - CountDispWidth ){
            Length = 0;
            lfBreak = TRUE;
            for (j = 0; j < dwStrLen; j++ ){
                Length += IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                if (dwWholeLen + Length > dwLength - (CountDispWidth + DELIMITERWIDTH)){
                    dwStrLen = j-1;
                    dwDspLen = Length - IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                    break;
                }
            }
        }
        if ((dwWholeLen + dwDspLen + DELIMITERWIDTH + CountDispWidth ) <= dwLength )      // if minus value
            dwWholeLen += (dwDspLen + DELIMITERWIDTH);
        else {
            break;
        }

        if (i == lpCandList->dwSelection) {
            for (j = 0; j < dwStrLen+2; j++)
                *(AttrToSel+j) = 1;
        }
        *StrToWrite = (USHORT)(SelCount + UNICODE_ZERO);
        StrToWrite++;
        *StrToWrite = UNICODE_COLON;
        StrToWrite++;
        CopyMemory(StrToWrite, lpStr, dwStrLen * sizeof(WCHAR));
        StrToWrite += dwStrLen;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += dwStrLen+DELIMITERWIDTH;
        SelCount++;
        if (lfBreak)
            break;
    }
    *StrToWrite = 0;
    dwDspLen = DispLenUnicode( String );
    if (dwDspLen > (dwLength - CountDispWidth))
        return SepIndex;

    if (EnableCodePoint){
        for (i = dwDspLen; i < dwLength; i++) {
            *StrToWrite = UNICODE_SPACE;
            StrToWrite++;
        }
    }
    else {
        for (i = dwDspLen; i < (dwLength - CountDispWidth); i++) {
            *StrToWrite = UNICODE_SPACE;
            StrToWrite++;
        }

        i = (CountDispWidth-1) / 2;
        NumString(StrToWrite,lpCandList->dwSelection+1,i);
        StrToWrite+=i;
        *StrToWrite = UNICODE_SLASH;
        StrToWrite++;
        NumString(StrToWrite,lpCandList->dwCount, i);
        StrToWrite+=i;
    }
    *StrToWrite = 0;

    return SepIndex;
}

DWORD
GetSystemLineT(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    )
{
    DWORD dwStrLen;
    DWORD dwDspLen;
    DWORD i;
    DWORD j;
    DWORD SepIndex;
    DWORD SelCount;
    DWORD Length;
    DWORD dwWholeLen;
    BOOL lfBreak = FALSE;
    LPWSTR StrToWrite;
    LPSTR AttrToSel;
    LPWSTR lpStr;
    USHORT MultiChar;
    USHORT TempMulti;

    if (lpCandList->dwSelection > lpCandList->dwCount) {
        lpCandList->dwSelection = 0;
    }

    for ( SepIndex = FocusedConsole->CandMax; SepIndex > 0; SepIndex--) {
        if (lpCandList->dwSelection >= FocusedConsole->CandSep[SepIndex])
            break;
    }
    if (SepIndex == FocusedConsole->CandMax)
        SepIndex = 0;

    for ( i = 0; i < dwLength; i++) {
        Attr[i] = 0x0000;
    }
    StrToWrite = String;
    AttrToSel = Attr;
    dwWholeLen = 0;
    if (FocusedConsole->ImmGetProperty & IME_PROP_CANDLIST_START_FROM_1)
        SelCount = 1;
    else
        SelCount = 0;


    for (i = FocusedConsole->CandSep[SepIndex]; i < FocusedConsole->CandSep[SepIndex+1]; i++) {
        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
        dwStrLen = lstrlenW( lpStr );
        dwDspLen = DispLenUnicode( lpStr );

        if ( dwWholeLen + dwDspLen + DELIMITERWIDTH  > dwLength - CountDispWidth ){
            Length = 0;
            lfBreak = TRUE;
            for (j = 0; j < dwStrLen; j++ ){
                Length += IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                if (dwWholeLen + Length > dwLength - (CountDispWidth + DELIMITERWIDTH)){
                    dwStrLen = j-1;
                    dwDspLen = Length - IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                    break;
                }
            }
        }
        if ((dwWholeLen + dwDspLen + DELIMITERWIDTH + CountDispWidth ) <= dwLength )      // if minus value
            dwWholeLen += (dwDspLen + DELIMITERWIDTH);
        else {
            break;
        }

        if (i == lpCandList->dwSelection) {
            for (j = 0; j < dwStrLen+2; j++)
                *(AttrToSel+j) = 1;
        }
        *StrToWrite = (USHORT)(SelCount + UNICODE_ZERO);
        StrToWrite++;
        *StrToWrite = UNICODE_COLON;
        StrToWrite++;
        CopyMemory(StrToWrite, lpStr, dwStrLen * sizeof(WCHAR));
        StrToWrite += dwStrLen;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += dwStrLen+DELIMITERWIDTH;
        SelCount++;
        if (lfBreak)
            break;
    }
    *StrToWrite = 0;
    dwDspLen = DispLenUnicode( String );
    if (dwDspLen > (dwLength - CountDispWidth))
        return SepIndex;

    *StrToWrite = UNICODE_SPACE;
    StrToWrite++;

    i = (CountDispWidth-1) / 2;
    NumString(StrToWrite,lpCandList->dwSelection+1,i);
    StrToWrite+=i;
    *StrToWrite = UNICODE_SLASH;
    StrToWrite++;
    NumString(StrToWrite,lpCandList->dwCount, i);
    StrToWrite+=i;
    *StrToWrite = 0;

    return SepIndex;
}

DWORD
GetSystemLineP(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    )
{
    DWORD dwStrLen;
    DWORD dwDspLen;
    DWORD i;
    DWORD j;
    DWORD SepIndex;
    DWORD SelCount;
    DWORD Length;
    DWORD dwWholeLen;
    BOOL lfBreak = FALSE;
    LPWSTR StrToWrite;
    LPSTR AttrToSel;
    LPWSTR lpStr;
    USHORT MultiChar;
    USHORT TempMulti;

    if (lpCandList->dwSelection > lpCandList->dwCount) {
        lpCandList->dwSelection = 0;
    }

    for ( SepIndex = FocusedConsole->CandMax; SepIndex > 0; SepIndex--) {
        if (lpCandList->dwSelection >= FocusedConsole->CandSep[SepIndex])
            break;
    }
    if (SepIndex == FocusedConsole->CandMax)
        SepIndex = 0;

    for ( i = 0; i < dwLength; i++) {
        Attr[i] = 0x0000;
    }
    StrToWrite = String;
    AttrToSel = Attr;
    dwWholeLen = 0;
    if (FocusedConsole->ImmGetProperty & IME_PROP_CANDLIST_START_FROM_1)
        SelCount = 1;
    else
        SelCount = 0;

    for (i = FocusedConsole->CandSep[SepIndex]; i < FocusedConsole->CandSep[SepIndex+1]; i++) {
        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
        dwStrLen = lstrlenW( lpStr );
        dwDspLen = DispLenUnicode( lpStr );

        if ( dwWholeLen + dwDspLen + DELIMITERWIDTH  > dwLength - CountDispWidth ){
            Length = 0;
            lfBreak = TRUE;
            for (j = 0; j < dwStrLen; j++ ){
                Length += IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                if (dwWholeLen + Length > dwLength - (CountDispWidth + DELIMITERWIDTH)){
                    dwStrLen = j-1;
                    dwDspLen = Length - IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                    break;
                }
            }
        }
        if ((dwWholeLen + dwDspLen + DELIMITERWIDTH + CountDispWidth ) <= dwLength )      // if minus value
            dwWholeLen += (dwDspLen + DELIMITERWIDTH);
        else {
            break;
        }

        if (i == lpCandList->dwSelection) {
            for (j = 0; j < dwStrLen+2; j++)
                *(AttrToSel+j) = 1;
        }
        *StrToWrite = (USHORT)(SelCount + UNICODE_ZERO);
        StrToWrite++;
        *StrToWrite = UNICODE_COLON;
        StrToWrite++;
        CopyMemory(StrToWrite, lpStr, dwStrLen * sizeof(WCHAR));
        StrToWrite += dwStrLen;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += dwStrLen+DELIMITERWIDTH;
        SelCount++;
        if (lfBreak)
            break;
    }
    *StrToWrite = 0;
    dwDspLen = DispLenUnicode( String );
    if (dwDspLen > (dwLength - CountDispWidth))
        return SepIndex;

#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
    *StrToWrite = UNICODE_SPACE;
    StrToWrite++;

    i = (CountDispWidth-1) / 2;
    NumString(StrToWrite,lpCandList->dwSelection+1,i);
    StrToWrite+=i;
    *StrToWrite = UNICODE_SLASH;
    StrToWrite++;
    NumString(StrToWrite,lpCandList->dwCount, i);
    StrToWrite+=i;
#endif

    *StrToWrite = 0;

    return SepIndex;
}

VOID
NumString(
    LPWSTR StrToWrite,
    DWORD NumToDisp,
    DWORD CountDispWidth)
{
    DWORD i;
    DWORD k;
    k = 1;
    for (i = 1; i < CountDispWidth; i++)
        k *= 10;
    for (i = k; i > 0; i /= 10){
        k = (NumToDisp / i);
        *StrToWrite = (USHORT)(k + UNICODE_ZERO);
        if ((*StrToWrite == UNICODE_ZERO) &&
            ((*(StrToWrite-1) == UNICODE_SPACE)||(*(StrToWrite-1) == UNICODE_SLASH)) )
            *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        NumToDisp -= (i*k);
    }
}

BOOL
ImeUICloseCandidate(
   HWND hwnd,
   DWORD CandList
   )
{
    HIMC  hIMC;
    PCONSOLE_TABLE ConTbl;

    DBGPRINT(("CONIME: Get IMN_CLOSECANDIDATE Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return FALSE;

    //
    // Reset fInCandidate variables.
    //
    ConTbl->fInCandidate = FALSE;

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            CloseCandidateJapan(hwnd, hIMC, ConTbl, CandList );
            break;
        case    LANG_ID_TAIWAN:
            CloseCandidateTaiwan(hwnd, hIMC, ConTbl, CandList );
            break;
        case    LANG_ID_PRC:
            CloseCandidatePRC(hwnd, hIMC, ConTbl, CandList );
            break;
        case    LANG_ID_KOREA:
            CloseCandidateKorea(hwnd, hIMC, ConTbl, CandList );
            break;
        default:
            return FALSE;
            break;
    }
    ImmReleaseContext( hwnd, hIMC );

    return TRUE;
}

BOOL
CloseCandidateJapan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMECANDINFO;
    CopyData.cbData = 0;
    CopyData.lpData = NULL;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    return TRUE;
}

BOOL
CloseCandidateTaiwan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;
    if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }

    LocalFree( lpModeInfo );
    return TRUE;

}

BOOL
CloseCandidatePRC(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;
    if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }

    LocalFree( lpModeInfo );
    return TRUE;

}

BOOL
CloseCandidateKorea(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMECANDINFO;
    CopyData.cbData = 0;
    CopyData.lpData = NULL;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\country3.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   country3.c
//
//  PURPOSE:   Console IME control.
//             FarEast country specific module for conime.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//    GetCompositionStr() - routine for Get Composition String
//    ReDisplayCompositionStr() - foutine for re-Display Composition String
//
//  History:
//
//  17.Jul.1996 v-HirShi (Hirotoshi Shimizu)    Created for TAIWAN & KOREA & PRC
//
//  COMMENTS:
//
#include "precomp.h"
#pragma hdrstop

//**********************************************************************
//
// void GetCompositionStr()
//
// This handles WM_IME_COMPOSITION message with GCS_COMPSTR flag on.
//
//**********************************************************************

void
GetCompositionStr(
    HWND hwnd,
    LPARAM CompFlag,
    WPARAM CompChar
    )
{
    PCONSOLE_TABLE ConTbl;

    DBGPRINT(("CONIME: GetCompositionStr\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    switch (ConTbl->ConsoleOutputCP)
    {
        case    JAPAN_CODEPAGE:
            GetCompStrJapan(hwnd, ConTbl, CompFlag);
            break;
        case    TAIWAN_CODEPAGE:
            GetCompStrTaiwan(hwnd, ConTbl, CompFlag);
            break;
        case    PRC_CODEPAGE:
            GetCompStrPRC(hwnd, ConTbl, CompFlag);
            break;
        case    KOREA_CODEPAGE:
            GetCompStrKorea(hwnd, ConTbl, CompFlag, CompChar);
            break;
        default:
            break;
    }
    return;

}

void
GetCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;                // Storage for len. of composition str
    LONG        lBufLenAttr;
    COPYDATASTRUCT CopyData;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    DWORD       i;
    DWORD       CursorPos;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
         return;

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = 0;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            ImmGetCompositionString( hIMC,
                                     GCS_COMPATTR,
                                     TempBufA,
                                     lBufLenAttr );
            TempBufA[ lBufLenAttr ] = (BYTE)0;
        }

        CursorPos = ImmGetCompositionString( hIMC, GCS_CURSORPOS, NULL, 0 );
        if (CursorPos == 0)
            TempBufA[ CursorPos ]   |= (BYTE)0x20;
        else
            TempBufA[ CursorPos-1 ] |= (BYTE)0x10;

#ifdef DEBUG_INFO
        //
        // Display new composition chars.
        //
        xPos = (UINT)lBufLen;
        xPosLast = (UINT)lBufLen;

        DisplayCompString( hwnd, lBufLen / sizeof(WCHAR), TempBuf, TempBufA );
#endif

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

#ifdef DEBUG_INFO
        //
        // Displays the result string.
        //
        DisplayResultString( hwnd, TempBuf );
#endif

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
    }

    //
    // send character to Console
    //
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    ImmReleaseContext( hwnd, hIMC );

}


void
GetCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;               // Storage for len. of composition str
    LONG        lBufLenAttr;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    DWORD       i;
    DWORD       CursorPos;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return;
    }

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = 0;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            ImmGetCompositionString( hIMC,
                                     GCS_COMPATTR,
                                     TempBufA,
                                     lBufLenAttr );
            TempBufA[ lBufLenAttr ] = (BYTE)0;
        }

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
        //
        // send character to Console
        //
        CopyData.dwData = CI_CONIMECOMPOSITION;
        CopyData.cbData = lpCompStrMem->dwSize;
        CopyData.lpData = lpCompStrMem;
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              );

    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }


    LocalFree( lpModeInfo );

    ImmReleaseContext( hwnd, hIMC );
    return;

}

void
GetCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;                // Storage for len. of composition str
    LONG        lBufLenAttr;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    DWORD       i;
    DWORD       CursorPos;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return;
    }

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = 0;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            ImmGetCompositionString( hIMC,
                                     GCS_COMPATTR,
                                     TempBufA,
                                     lBufLenAttr );
            TempBufA[ lBufLenAttr ] = (BYTE)0;
        }

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
        //
        // send character to Console
        //
        CopyData.dwData = CI_CONIMECOMPOSITION;
        CopyData.cbData = lpCompStrMem->dwSize;
        CopyData.lpData = lpCompStrMem;
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              );

    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }


    LocalFree( lpModeInfo );

    ImmReleaseContext( hwnd, hIMC );
    return;

}

void
GetCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag,
    WPARAM CompChar
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;                // Storage for len. of composition str
    LONG        lBufLenAttr;
    COPYDATASTRUCT CopyData;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LONG        i;
    DWORD       CursorPos;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
         return;

//    if (CompFlag & CS_INSERTCHAR)
//    {
//        lBufLen = 1;
//        lBufLenAttr = 1;
//    }
//    else
    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = lBufLen;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }
    else
    {
        return;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;

    if (CompFlag & CS_INSERTCHAR)
    {
        *TempBuf = (WORD)CompChar;
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        *TempBufA = (BYTE)ATTR_TARGET_CONVERTED;
        TempBufA[ lBufLenAttr ] = (BYTE)0;
    }
    else if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            if ( CompFlag & GCS_COMPATTR )
            {
                ImmGetCompositionString( hIMC,
                                         GCS_COMPATTR,
                                         TempBufA,
                                         lBufLenAttr );
                TempBufA[ lBufLenAttr ] = (BYTE)0;
            }
            else
            {
                for (i = 0; i <= lBufLenAttr; i++)
                    TempBufA[ i ] = (BYTE)1;
            }
        }

// Korean  NT does not need IME cursor. v-hirshi
//        CursorPos = ImmGetCompositionString( hIMC, GCS_CURSORPOS, NULL, 0 );
//        if (CursorPos == 0)
//            TempBufA[ CursorPos ]   |= (BYTE)0x20;
//        else
//            TempBufA[ CursorPos-1 ] |= (BYTE)0x10;

#ifdef DEBUG_INFO
        //
        // Display new composition chars.
        //
        xPos = (UINT)lBufLen;
        xPosLast = (UINT)lBufLen;

        DisplayCompString( hwnd, lBufLen / sizeof(WCHAR), TempBuf, TempBufA );
#endif

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

#ifdef DEBUG_INFO
        //
        // Displays the result string.
        //
        DisplayResultString( hwnd, TempBuf );
#endif

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
    }

    //
    // send character to Console
    //
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    ImmReleaseContext( hwnd, hIMC );

}

VOID
ReDisplayCompositionStr (
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if (! ConTbl->fInComposition)
       return;

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            ReDisplayCompStrJapan(hwnd, ConTbl);
            break;
        case    LANG_ID_TAIWAN:
            ReDisplayCompStrTaiwan(hwnd, ConTbl);
            break;
        case    LANG_ID_PRC:
            ReDisplayCompStrPRC(hwnd, ConTbl);
            break;
        case    LANG_ID_KOREA:
            ReDisplayCompStrKorea(hwnd, ConTbl);
            break;
        default:
            break;
    }
    return;
}

VOID
ReDisplayCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    COPYDATASTRUCT CopyData;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    lpCompStrMem = ConTbl->lpCompStrMem;
    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );
}

VOID
ReDisplayCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return;
    }
    //
    // Display character to Console
    //
    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;

    if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }

    LocalFree( lpModeInfo );
}

VOID
ReDisplayCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return;
    }
    //
    // Display character to Console
    //
    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;

    if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }
    LocalFree( lpModeInfo );
}

VOID
ReDisplayCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{

    COPYDATASTRUCT CopyData;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    lpCompStrMem = ConTbl->lpCompStrMem;
    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\consubs.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   ConSubs.c
//
//  PURPOSE:   Console IME control.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//  10.Jul.1996 v-HirShi (Hirotoshi Shimizu)    adupt FE edition
//
//  COMMENTS:
//

#include "precomp.h"
#pragma hdrstop

INT
Create( HWND hWnd )
{
    ghDefaultIMC = ImmGetContext(hWnd) ;

#ifdef DEBUG_MODE
    {
        //
        // Select fixed pitch system font and get its text metrics
        //

        HDC hdc;
        TEXTMETRIC tm;
        WORD       patern = 0xA4A4;
        SIZE       size;
        HFONT hfntFixed;                      // fixed-pitch font
        HFONT hfntOld;                        // default font holder

        hdc = GetDC( hWnd );
        hfntFixed = GetStockObject( SYSTEM_FIXED_FONT );
        hfntOld = SelectObject( hdc, hfntFixed );
        GetTextMetrics( hdc, &tm );

        GetTextExtentPoint32( hdc, (LPWSTR)&patern, sizeof(WORD), (LPSIZE) &size );
        cxMetrics = (UINT) size.cx / 2;
        cyMetrics = (UINT) size.cy;
        ReleaseDC( hWnd, hdc );

        xPos = 0 ;
        CaretWidth = GetSystemMetrics( SM_CXBORDER );
    }
#endif

    return 0;

}

//**********************************************************************
//
// void ImeUIStartComposition()
//
// This handles WM_IME_STARTCOMPOSITION message.
//
//**********************************************************************

void ImeUIStartComposition( HWND hwnd )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    //
    // Set fInComposition variables.
    //
    ConTbl->fInComposition = TRUE;

#ifdef DEBUG_MODE
    {
        int i ;
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = UNICODE_SPACE ;
            ConvertLineAtr[i] = 0 ;
        }
    }
#endif
#ifdef DEBUG_INFO
    xPos = FIRSTCOL;
    xPosLast = FIRSTCOL;
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );
#endif
}

//**********************************************************************
//
// void ImeUIEndComposition
//
// This handles WM_IME_ENDCOMPOSITION message.
//
//**********************************************************************

void ImeUIEndComposition( HWND hwnd )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    //
    // Reset fInComposition variables.
    //
    ConTbl->fInComposition = FALSE;

    if (ConTbl->lpCompStrMem)
        LocalFree( ConTbl->lpCompStrMem );
    ConTbl->lpCompStrMem = NULL ;

#ifdef DEBUG_MODE
    {
        int i ;
        //
        // Reset the length of composition string to zero.
        //
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = UNICODE_SPACE ;
            ConvertLineAtr[i] = 0 ;
        }
    }
#endif
#ifdef DEBUG_INFO
    xPos = FIRSTCOL;
    xPosLast = FIRSTCOL;
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );
#endif
}

//**********************************************************************
//
// void ImeUIComposition()
//
// This handles WM_IME_COMPOSITION message. It here just handles
// composition string and result string. For normal case, it should
// examine all posibile flags indicated by CompFlag, then do some
// actitions to reflect what kinds of composition info. IME conversion
// engine informs.
//
//**********************************************************************

void ImeUIComposition( HWND hwnd, WPARAM CompChar, LPARAM CompFlag )
{

    DBGPRINT(("CONIME: WM_IME_COMPOSITION %08x %08x\n",CompChar,CompFlag));

#ifdef DEBUG_MODE
    {
        int i ;
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = UNICODE_SPACE ;
            ConvertLineAtr[i] = 0 ;
        }
        xPos = FIRSTCOL;
        xPosLast = FIRSTCOL;
    }
#endif

    if ( CompFlag == 0 ) {
        DBGPRINT(("                           None\n"));
        GetCompositionStr( hwnd, CompFlag, CompChar);
    }
    if ( CompFlag & GCS_RESULTSTR ) {
        DBGPRINT(("                           GCS_RESULTSTR\n"));
        GetCompositionStr( hwnd, ( CompFlag & GCS_RESULTSTR ), CompChar );
    }
    if ( CompFlag & GCS_COMPSTR ) {
        DBGPRINT(("                           GCS_COMPSTR\n"));
        GetCompositionStr( hwnd, ( CompFlag & (GCS_COMPSTR|GCS_COMPATTR)), CompChar);
    }
    if ( CompFlag & CS_INSERTCHAR ) {
        DBGPRINT(("                           CS_INSERTCHAR\n"));
        GetCompositionStr( hwnd, ( CompFlag & (CS_INSERTCHAR|GCS_COMPATTR)), CompChar);
    }
    if ( CompFlag & CS_NOMOVECARET ) {
        DBGPRINT(("                           CS_NOMOVECARET\n"));
        GetCompositionStr( hwnd, ( CompFlag & (CS_NOMOVECARET|GCS_COMPATTR)), CompChar);
    }
}


#ifdef DEBUG_INFO
//*********************************************************************
//
// void DisplayCompString()
//
// This displays composition string.
//
// This function send string to Console.
//
//*********************************************************************

void DisplayCompString( HWND hwnd, int Length, PWCHAR CharBuf, PUCHAR AttrBuf )
{
    int         i;
    CopyMemory(ConvertLine, CharBuf, Length * sizeof(WCHAR) ) ;
    if ( AttrBuf == NULL ) {
        for ( i = 0 ; i < Length ; i++ )
            ConvertLineAtr[i] = 0 ;
    }
    else {
        CopyMemory(ConvertLineAtr, AttrBuf, Length) ;
    }
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );

}

//*********************************************************************
//
// void DisplayResultString()
//
// This displays result string.
//
// This function supports only fixed pitch font.
//
//*********************************************************************

void DisplayResultString( HWND hwnd, LPWSTR lpwStr )
{

    int         StrLen = lstrlenW( lpwStr );

    CopyMemory(ConvertLine, lpwStr, StrLen*sizeof(WCHAR)) ;
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );

    // gImeUIData.uCompLen = 0;

}
#endif

//**********************************************************************
//
// BOOL ImeUINotify()
//
// This handles WM_IME_NOTIFY message.
//
//**********************************************************************

BOOL ImeUINotify( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    switch (wParam )
    {
        case IMN_OPENSTATUSWINDOW:
            ImeUIOpenStatusWindow(hwnd) ;
            break;
        case IMN_CHANGECANDIDATE:
            ImeUIChangeCandidate( hwnd, (DWORD)lParam );
            break;
        case IMN_CLOSECANDIDATE:
            ImeUICloseCandidate( hwnd, (DWORD)lParam );
            break;
        case IMN_OPENCANDIDATE:
            ImeUIOpenCandidate( hwnd, (DWORD)lParam, TRUE);
            break;
        case IMN_SETCONVERSIONMODE:
            ImeUISetConversionMode(hwnd) ;
            // IMN_SETCONVERSIONMODE should be pass to DefWindowProc
            // becuase ImeNotifyHandler in User32 does notify to shell and keyboard.
            return FALSE;
        case IMN_SETOPENSTATUS:
            ImeUISetOpenStatus( hwnd );
            // IMN_SETOPENSTATUS should be pass to DefWindowProc
            // becuase ImeNotifyHandler in User32 does notify to shell and keyboard.
            return FALSE;
        case IMN_GUIDELINE:
            ImeUIGuideLine(hwnd) ;
            break;
        default:
            return FALSE;

    }
    return TRUE;
}

/***************************************************************************\
* BOOL IsConsoleFullWidth(DWORD CodePage,WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* History:
* 04-08-92 ShunK       Created.
* Jul-27-1992 KazuM    Added Screen Information and Code Page Information.
* Jan-29-1992 V-Hirots Substruct Screen Information.
* Oct-06-1996 KazuM    Not use RtlUnicodeToMultiByteSize and WideCharToMultiByte
*                      Because 950 only defined 13500 chars,
*                      and unicode defined almost 18000 chars.
*                      So there are almost 4000 chars can not be mapped to big5 code.
\***************************************************************************/

BOOL IsUnicodeFullWidth(
    IN WCHAR wch
    )
{
    if (0x20 <= wch && wch <= 0x7e)
        /* ASCII */
        return FALSE;
    else if (0x3041 <= wch && wch <= 0x3094)
        /* Hiragana */
        return TRUE;
    else if (0x30a1 <= wch && wch <= 0x30f6)
        /* Katakana */
        return TRUE;
    else if (0x3105 <= wch && wch <= 0x312c)
        /* Bopomofo */
        return TRUE;
    else if (0x3131 <= wch && wch <= 0x318e)
        /* Hangul Elements */
        return TRUE;
    else if (0xac00 <= wch && wch <= 0xd7a3)
        /* Korean Hangul Syllables */
        return TRUE;
    else if (0xff01 <= wch && wch <= 0xff5e)
        /* Fullwidth ASCII variants */
        return TRUE;
    else if (0xff61 <= wch && wch <= 0xff9f)
        /* Halfwidth Katakana variants */
        return FALSE;
    else if ( (0xffa0 <= wch && wch <= 0xffbe) ||
              (0xffc2 <= wch && wch <= 0xffc7) ||
              (0xffca <= wch && wch <= 0xffcf) ||
              (0xffd2 <= wch && wch <= 0xffd7) ||
              (0xffda <= wch && wch <= 0xffdc)   )
        /* Halfwidth Hangule variants */
        return FALSE;
    else if (0xffe0 <= wch && wch <= 0xffe6)
        /* Fullwidth symbol variants */
        return TRUE;
    else if (0x4e00 <= wch && wch <= 0x9fa5)
        /* Han Ideographic */
        return TRUE;
    else if (0xf900 <= wch && wch <= 0xfa2d)
        /* Han Ideographic Compatibility */
        return TRUE;
    else
    {
#if 0
        /*
         * Hack this block for I don't know FONT of Console Window.
         *
         * If you would like perfect result from IsUnicodeFullWidth routine,
         * then you should enable this block and
         * you should know FONT of Console Window.
         */

        INT Width;
        TEXTMETRIC tmi;

        /* Unknown character */

        GetTextMetricsW(hDC, &tmi);
        if (IS_ANY_DBCS_CHARSET(tmi.tmCharSet))
            tmi.tmMaxCharWidth /= 2;

        GetCharWidth32(hDC, wch, wch, &Width);
        if (Width == tmi.tmMaxCharWidth)
            return FALSE;
        else if (Width == tmi.tmMaxCharWidth*2)
            return TRUE;
#else
        ULONG MultiByteSize;

        RtlUnicodeToMultiByteSize(&MultiByteSize, &wch, sizeof(WCHAR));
        if (MultiByteSize == 2)
            return TRUE ;
        else
            return FALSE ;
#endif
    }
    ASSERT(FALSE);
    return FALSE;
#if 0
    ULONG MultiByteSize;

    RtlUnicodeToMultiByteSize(&MultiByteSize, &wch, sizeof(WCHAR));
    if (MultiByteSize == 2)
        return TRUE ;
    else
        return FALSE ;
#endif
}


BOOL
ImeUIOpenStatusWindow(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC;                   // Input context handle.
    LPCONIME_UIMODEINFO lpModeInfo ;
    COPYDATASTRUCT CopyData ;

    DBGPRINT(("CONIME: Get IMN_OPENSTATUSWINDOW Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) ) ;
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return FALSE;
    }

    ImmGetConversionStatus(hIMC,
                           (LPDWORD)&ConTbl->dwConversion,
                           (LPDWORD)&ConTbl->dwSentence) ;

    CopyData.dwData = CI_CONIMEMODEINFO ;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
    CopyData.lpData = lpModeInfo ;
    if (ImeUIMakeInfoString(ConTbl,
                            lpModeInfo))
    {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              ) ;
    }

    LocalFree( lpModeInfo );

    ImmReleaseContext( hwnd, hIMC );

    return TRUE ;
}


BOOL
ImeUIChangeCandidate(
   HWND hwnd,
   DWORD lParam
   )
{
    return ImeUIOpenCandidate( hwnd, lParam, FALSE) ;
}


BOOL
ImeUISetOpenStatus(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC;                   // Input context handle.
    LPCONIME_UIMODEINFO lpModeInfo ;
    COPYDATASTRUCT CopyData ;

    DBGPRINT(("CONIME: Get IMN_SETOPENSTATUS Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    ConTbl->fOpen = GetOpenStatusByCodepage( hIMC, ConTbl ) ;

    ImmGetConversionStatus(hIMC,
                           (LPDWORD)&ConTbl->dwConversion,
                           (LPDWORD)&ConTbl->dwSentence) ;

    if (ConTbl->ScreenBufferSize.X != 0) {

        lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO)) ;
        if ( lpModeInfo == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return FALSE;
        }

        CopyData.dwData = CI_CONIMEMODEINFO ;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
        CopyData.lpData = lpModeInfo ;
        if (ImeUIMakeInfoString(ConTbl,
                                lpModeInfo))
        {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                  ) ;
        }
        LocalFree( lpModeInfo );
    }
    ImmReleaseContext( hwnd, hIMC );

    return TRUE ;
}

BOOL
ImeUISetConversionMode(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC;                   // Input context handle.
    LPCONIME_UIMODEINFO lpModeInfo ;
    COPYDATASTRUCT CopyData ;
    DWORD OldConversion ;


    DBGPRINT(("CONIME: Get IMN_SETCONVERSIONMODE Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) ) ;
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return FALSE;
    }

    OldConversion = ConTbl->dwConversion ;

    ImmGetConversionStatus(hIMC,
                           (LPDWORD)&ConTbl->dwConversion,
                           (LPDWORD)&ConTbl->dwSentence) ;

    CopyData.dwData = CI_CONIMEMODEINFO ;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
    CopyData.lpData = lpModeInfo ;
    if (ImeUIMakeInfoString(ConTbl,
                            lpModeInfo))
    {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             ) ;
    }

    LocalFree( lpModeInfo );
    ImmReleaseContext( hwnd, hIMC );
    return TRUE ;

}

BOOL
ImeUIGuideLine(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC ;                   // Input context handle.
    DWORD       Level ;
    DWORD       Index ;
    DWORD       Length ;
    LPCONIME_UIMESSAGE GuideLine ;
    COPYDATASTRUCT CopyData ;

    DBGPRINT(("CONIME: Get IMN_GUIDELINE Message "));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    Level = ImmGetGuideLine(hIMC, GGL_LEVEL, NULL, 0) ;
    Index = ImmGetGuideLine(hIMC, GGL_INDEX, NULL, 0) ;
    Length = ImmGetGuideLine(hIMC, GGL_STRING, NULL, 0) ;
    DBGPRINT(("Level=%d Index=%d Length=%d",Level,Index,Length));
    if (Length == 0) {
        CopyData.dwData = CI_CONIMESYSINFO ;
        CopyData.cbData = Length ;
        CopyData.lpData = NULL ;

        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              ) ;
    }
    else{
        GuideLine = (LPCONIME_UIMESSAGE)LocalAlloc(LPTR, Length + sizeof(WCHAR)) ;
        if (GuideLine == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return FALSE;
        }

        CopyData.dwData = CI_CONIMESYSINFO ;
        CopyData.cbData = Length + sizeof(WCHAR) ;
        CopyData.lpData = GuideLine ;
        Length = ImmGetGuideLine(hIMC, GGL_STRING, GuideLine->String, Length) ;

        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              ) ;

        LocalFree( GuideLine ) ;
    }
    ImmReleaseContext( hwnd, hIMC );
    DBGPRINT(("\n"));

    return TRUE ;
}

DWORD
GetNLSMode(
    HWND hWnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC hIMC;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return 0;
    }

    hIMC = ImmGetContext( hWnd ) ;
    if ( hIMC == (HIMC)NULL )
        return IME_CMODE_DISABLE;

    ImmGetConversionStatus(hIMC,
                           &ConTbl->dwConversion,
                           &ConTbl->dwSentence);
    ConTbl->fOpen = GetOpenStatusByCodepage( hIMC, ConTbl ) ;

    ImmReleaseContext( hWnd, hIMC );


    return ((ConTbl->fOpen ? IME_CMODE_OPEN : 0) + ConTbl->dwConversion);
}

BOOL
SetNLSMode(
    HWND hWnd,
    HANDLE hConsole,
    DWORD fdwConversion
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC hIMC;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if (fdwConversion & IME_CMODE_DISABLE)
    {
        ImmSetActiveContextConsoleIME(hWnd, FALSE) ;
        ImmAssociateContext(hWnd, (HIMC)NULL);
        ConTbl->hIMC_Current = (HIMC)NULL;
    }
    else
    {
        ImmAssociateContext(hWnd, ConTbl->hIMC_Original);
        ImmSetActiveContextConsoleIME(hWnd, TRUE) ;
        ConTbl->hIMC_Current = ConTbl->hIMC_Original;
    }

    hIMC = ImmGetContext( hWnd ) ;
    if ( hIMC == (HIMC)NULL )
        return TRUE;

    ConTbl->fOpen =(fdwConversion & IME_CMODE_OPEN) ? TRUE : FALSE ;
    ImmSetOpenStatus(hIMC, ConTbl->fOpen);

    fdwConversion &= ~(IME_CMODE_DISABLE | IME_CMODE_OPEN);
    if (ConTbl->dwConversion != fdwConversion)
    {
        ConTbl->dwConversion = fdwConversion;
        ImmSetConversionStatus(hIMC,
                               ConTbl->dwConversion,
                               ConTbl->dwSentence );
    }

    ImmReleaseContext( hWnd, hIMC );

    return TRUE;
}

BOOL
ConsoleCodepageChange(
    HWND hWnd,
    HANDLE hConsole,
    BOOL Output,
    WORD CodePage
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if (Output)
    {
        ConTbl->ConsoleOutputCP = CodePage ;
    }
    else
    {
        ConTbl->ConsoleCP = CodePage ;
    }
    return (TRUE) ;
}

BOOL
ImeSysPropertyWindow(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCONSOLE_TABLE ConTbl;
    COPYDATASTRUCT CopyData;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    CopyData.dwData = CI_CONIMEPROPERTYINFO;
    CopyData.cbData = sizeof(WPARAM);
    CopyData.lpData = &wParam;

    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hWnd,
                           (LPARAM)&CopyData
                          );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\globals.h ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   Globals.h
//
//  PURPOSE:   Contains declarations for all globally scoped names in the program.
//
//  PLATFORMS: Windows NT-J 3.51
//
//  FUNCTIONS:
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//
//  COMMENTS:
//

extern HANDLE    LastConsole ;
extern HIMC      ghDefaultIMC ;





#ifdef DEBUG_MODE
extern int       cxMetrics ;
extern int       cyMetrics ;
extern int       cxOverTypeCaret ;
extern int       xPos ;
extern int       xPosLast ;
extern int       CaretWidth;               // insert/overtype mode caret width

extern WCHAR           ConvertLine[CVMAX] ;
extern unsigned char   ConvertLineAtr[CVMAX] ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\conime.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   ConIme.c
//
//  PURPOSE:   Console IME control.
//
//  PLATFORMS: Windows NT-J 3.51
//
//  FUNCTIONS:
//    WinMain() - calls initialization functions, processes message loop
//    WndProc - Processes messages for the main window.
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//
//  COMMENTS:
//

#include "precomp.h"
#pragma hdrstop


// Global Variables

HANDLE          LastConsole;
HIMC            ghDefaultIMC;

PCONSOLE_TABLE  *ConsoleTable;
ULONG           NumberOfConsoleTable;

CRITICAL_SECTION ConsoleTableLock; // serialize console table access
#define LockConsoleTable()   RtlEnterCriticalSection(&ConsoleTableLock)
#define UnlockConsoleTable() RtlLeaveCriticalSection(&ConsoleTableLock)


BOOL            gfDoNotKillFocus;


DWORD           dwConsoleThreadId = 0;


#if DBG
ULONG InputExceptionFilter(
    PEXCEPTION_POINTERS pexi)
{
    if (pexi->ExceptionRecord->ExceptionCode != STATUS_PORT_DISCONNECTED) {
        DbgPrint("CONIME: Unexpected exception - %x, pexi = %x\n",
                pexi->ExceptionRecord->ExceptionCode, pexi);
        DbgBreakPoint();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
#else
#define InputExceptionFilter(pexi) EXCEPTION_EXECUTE_HANDLER
#endif


int
APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
    )
{
    MSG msg;
    WCHAR systemPath[MAX_PATH];

    if (GetSystemDirectory ( systemPath, MAX_PATH ) > 0 )
        SetCurrentDirectory ( systemPath );

#ifdef CUAS_ENABLE
    //
    // Disable CUAS on the conime.exe process
    //
    ImmDisableTextFrameService( -1 );
#endif

    if (!InitConsoleIME(hInstance) ) {
        DBGPRINT(("CONIME: InitConsoleIME failure!\n"));
        return FALSE;
    }
    else {
        DBGPRINT(("CONIME: InitConsoleIME successful!\n"));
    }

    try {

        while (TRUE)  {
            if (GetMessage(&msg, NULL, 0, 0)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                break;
            }
        }

    } except (InputExceptionFilter(GetExceptionInformation())) {

        if (dwConsoleThreadId)
        {
            DBGPRINT(("CONIME: Exception on WinMain!!\n"));
            UnregisterConsoleIME();
            dwConsoleThreadId = 0;
        }

    }

    return (int)msg.wParam;
}

BOOL
InitConsoleIME(
    HINSTANCE hInstance
    )
{
    HANDLE   hEvent = NULL;
    ATOM     atom   = 0;
    HWND     hWnd   = NULL;
    WNDCLASS ConsoleIMEClass;
    int      cxExecStart;
    int      cyExecStart;
    WCHAR    szMenuName[16];                 // The name of Menu
    WCHAR    szClassName[16];                // The class name of this application
    WCHAR    szTitle[16];                    // The title bar text

#ifdef DEBUG_MODE
    WCHAR    szAppName[16];                  // The name of this application

    LoadString(hInstance, IDS_TITLE,     szTitle,     sizeof(szTitle));
#else
    szTitle[0] = L'\0';
#endif

    DBGPRINT(("CONIME: Enter InitConsoleIMEl!\n"));

    RtlInitializeCriticalSection(&ConsoleTableLock);

    ConsoleTable = (PCONSOLE_TABLE *)LocalAlloc(LPTR, CONSOLE_INITIAL_TABLE * sizeof(PCONSOLE_TABLE));
    if (ConsoleTable == NULL) {
        return FALSE;
    }
    RtlZeroMemory(ConsoleTable, CONSOLE_INITIAL_TABLE * sizeof(PCONSOLE_TABLE));
    NumberOfConsoleTable = CONSOLE_INITIAL_TABLE;

    // Load the application name and description strings.
    LoadString(hInstance, IDS_MENUNAME,  szMenuName,  sizeof(szMenuName)/sizeof(szMenuName[0]));
    LoadString(hInstance, IDS_CLASSNAME, szClassName, sizeof(szClassName)/sizeof(szClassName[0]));

    hEvent = OpenEvent(EVENT_MODIFY_STATE,    // Access flag
                       FALSE,                 // Inherit
                       CONSOLEIME_EVENT);     // Event object name
    if (hEvent == NULL)
    {
        DBGPRINT(("CONIME: OpenEvent failure! %d\n",GetLastError()));
        goto ErrorExit;
    }

    // Fill in window class structure with parameters that describe the
    // main window.

    ConsoleIMEClass.style         = 0;                       // Class style(s).
    ConsoleIMEClass.lpfnWndProc   = WndProc;                 // Window Procedure
    ConsoleIMEClass.cbClsExtra    = 0;                       // No per-class extra data.
    ConsoleIMEClass.cbWndExtra    = 0;                       // No per-window extra data.
    ConsoleIMEClass.hInstance     = hInstance;               // Owner of this class
    ConsoleIMEClass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(ID_CONSOLEIME_ICON));
    ConsoleIMEClass.hCursor       = LoadCursor(NULL, IDC_ARROW); // Cursor
    ConsoleIMEClass.hbrBackground = GetStockObject(WHITE_BRUSH); // Default color
    ConsoleIMEClass.lpszMenuName  = szMenuName;              // Menu name from .RC
    ConsoleIMEClass.lpszClassName = szClassName;             // Class Name

    // Register the window class and return FALSE if unsuccesful.

    atom = RegisterClass(&ConsoleIMEClass);
    if (atom == 0)
    {
        DBGPRINT(("CONIME: RegisterClass failure! %d\n",GetLastError()));
        goto ErrorExit;
    }
    else {
        DBGPRINT(("CONIME: RegisterClass Successful!\n"));
    }

    // Guess size for now.
    cxExecStart = GetSystemMetrics(SM_CXSCREEN);
    cyExecStart = GetSystemMetrics(SM_CYMENU);

    // Create a main window for this application instance.
    hWnd = CreateWindow(szClassName,                 // See RegisterClass() call.
                        szTitle,                     // Text for window title bar.
                        WS_OVERLAPPEDWINDOW,
                        cxExecStart - (cxExecStart / 3) ,
                        cyExecStart ,
                        cxExecStart / 3 ,
                        cyExecStart * 10 ,
                        NULL,                        // Overlapped has no parent.
                        NULL,                        // Use the window class menu.
                        hInstance,
                        (LPVOID)NULL);

    // If window could not be created, return "failure"
    if (hWnd == NULL) {
        DBGPRINT(("CONIME: CreateWindow failured! %d\n",GetLastError()));
        goto ErrorExit;
    }
    else{
        DBGPRINT(("CONIME: CreateWindow Successful!\n"));
    }

    if (! RegisterConsoleIME(hWnd, &dwConsoleThreadId))
    {
        DBGPRINT(("CONIME: RegisterConsoleIME failured! %d\n",GetLastError()));
        goto ErrorExit;
    }

    if (! AttachThreadInput(GetCurrentThreadId(), dwConsoleThreadId, TRUE))
    {
        DBGPRINT(("CONIME: AttachThreadInput failured! %d\n",GetLastError()));
        goto ErrorExit;
    }

    /*
     * dwConsoleThreadId is locked until event sets of hEvent
     */
    SetEvent(hEvent);
    CloseHandle(hEvent);

#ifdef DEBUG_MODE
    LoadString(hInstance, IDS_APPNAME,   szAppName,   sizeof(szAppName));

    // Make the window visible; update its client area; and return "success"
    ShowWindow(hWnd, SW_MINIMIZE); // Show the window
    SetWindowText(hWnd, szAppName);
    UpdateWindow(hWnd);         // Sends WM_PAINT message

    {
        int i;

        for (i = 0; i < CVMAX; i++) {
            ConvertLine[i] = UNICODE_SPACE;
            ConvertLineAtr[i] = 0;
        }
        xPos = 0;
        xPosLast = 0;
    }

#endif

    return TRUE;                // We succeeded...

ErrorExit:
    if (dwConsoleThreadId)
        UnregisterConsoleIME();
    if (hWnd)
        DestroyWindow(hWnd);
    if (atom)
        UnregisterClass(szClassName,hInstance);
    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
    return FALSE;
}


//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  Processes messages
//
//  PARAMETERS:
//    hwnd     - window handle
//    uMessage - message number
//    wparam   - additional information (dependant of message number)
//    lparam   - additional information (dependant of message number)
//
//  MESSAGES:
//
//    WM_COMMAND    - exit command
//    WM_DESTROY    - destroy window
//
//  RETURN VALUE:
//
//    Depends on the message number.
//
//  COMMENTS:
//
//

LRESULT FAR PASCAL WndProc( HWND hWnd,
                         UINT Message,
                         WPARAM wParam,
                         LPARAM lParam)
{
    DWORD dwImmRet = 0;        // return value of ImmSrvProcessKey()

    try {

        switch (Message)
        {
            case CONIME_CREATE:
                DBGPRINT(("CONIME: CONIME_CREATE: Console Handle=%08x\n", wParam));
                return InsertNewConsole(hWnd,(HANDLE)wParam,(HWND)lParam);

            case CONIME_DESTROY:
                DBGPRINT(("CONIME: CONIME_DESTROY: Console Handle=%08x\n", wParam));
                return RemoveConsole(hWnd, (HANDLE)wParam);

            case CONIME_SETFOCUS:
                DBGPRINT(("CONIME: CONIME_SETFOCUS: Console Handle=%08x\n", wParam));
                return ConsoleSetFocus(hWnd, (HANDLE)wParam, (HKL)lParam);

            case CONIME_KILLFOCUS:
                DBGPRINT(("CONIME: CONIME_KILLFOCUS: Console Handle=%08x\n", wParam));
                return ConsoleKillFocus(hWnd, (HANDLE)wParam);

            case CONIME_GET_NLSMODE:
                DBGPRINT(("CONIME: CONIME_GET_NLSMODE: Console Handle=%08x\n", wParam));
                return GetNLSMode(hWnd, (HANDLE)wParam);

            case CONIME_SET_NLSMODE:
                DBGPRINT(("CONIME: CONIME_SET_NLSMODE: Console Handle=%08x\n", wParam));
                return SetNLSMode(hWnd, (HANDLE)wParam, (DWORD)lParam);

            case CONIME_HOTKEY:
                DBGPRINT(("CONIME: CONIME_HOTKEY\n"));
                return ConimeHotkey(hWnd, (HANDLE)wParam, (DWORD)lParam);

            case CONIME_NOTIFY_VK_KANA:
                DBGPRINT(("CONIME: CONIME_NOTIFY_VK_KANA\n"));
                return ImeUISetConversionMode(hWnd);

            case CONIME_NOTIFY_SCREENBUFFERSIZE: {
                COORD ScreenBufferSize;
                DBGPRINT(("CONIME: CONIME_NOTIFY_SCREENBUFFERSIZE: Console Handle=%08x\n", wParam));
                ScreenBufferSize.X = LOWORD(lParam);
                ScreenBufferSize.Y = HIWORD(lParam);
                return ConsoleScreenBufferSize(hWnd, (HANDLE)wParam, ScreenBufferSize);
            }

            case CONIME_INPUTLANGCHANGE: {
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGE: Console Handle=%08x \n",wParam));
                ConImeInputLangchange(hWnd, (HANDLE)wParam, (HKL)lParam );
                return TRUE;
            }

            case CONIME_NOTIFY_CODEPAGE: {
                BOOL Output;
                WORD Codepage;

                Codepage = HIWORD(lParam);
                Output = LOWORD(lParam);
                DBGPRINT(("CONIME: CONIME_NOTIFY_CODEPAGE: Console Handle=%08x %04x %04x\n",wParam, Output, Codepage));
                return ConsoleCodepageChange(hWnd, (HANDLE)wParam, Output, Codepage);
            }

            case WM_KEYDOWN    +CONIME_KEYDATA:
            case WM_KEYUP      +CONIME_KEYDATA:
            case WM_SYSKEYDOWN +CONIME_KEYDATA:
            case WM_SYSKEYUP   +CONIME_KEYDATA:
            case WM_DEADCHAR   +CONIME_KEYDATA:
            case WM_SYSDEADCHAR+CONIME_KEYDATA:
            case WM_SYSCHAR    +CONIME_KEYDATA:
            case WM_CHAR       +CONIME_KEYDATA:
                CharHandlerFromConsole( hWnd, Message, (ULONG)wParam, (ULONG)lParam );
                break;
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:
            case WM_DEADCHAR:
            case WM_SYSDEADCHAR:
            case WM_SYSCHAR:
            case WM_CHAR:
                CharHandlerToConsole( hWnd, Message, (ULONG)wParam, (ULONG)lParam );
                break;

            case WM_INPUTLANGCHANGE:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGE: Console Handle=%08x \n",wParam));
                InputLangchange(hWnd, (DWORD)wParam, (HKL)lParam );
                return TRUE;

            case WM_INPUTLANGCHANGEREQUEST:
                // Console IME never receive this message for this window is hidden
                // and doesn't have focus.
                //
                // However, Hot key of IME_CHOTKEY_IME_NONIME_TOGGLE/IME_THOTKEY_IME_NONIME_TOGGLE
                // are send this message by ImmSimulateHotKey API.
                //
                // If nothing processing by this message, then DefWindowProc calls
                // ActivateKeyboardLayout on kernel side.
                // And, ActivateKeyboardLayout send WM_INPUTLANGCHANGE message to focus window
                // on this message queue.
                // It window is console window procedure.
                // Console window procedure can do send CONIME_INPUTLANGCHANGE message to
                // console IME window.
                // In console window is windowed case, this sequence as well.
                // But, In console window is full screen case, message queue have not focus.
                // WM_INPUTLANGCHANGE message can not send to console window procedure.
                //
                // This code avoid console full screen mode problem.
                // Send message to console window procedure when this window receive it.
                //
                {
                    PCONSOLE_TABLE ConTbl;

                    ConTbl = SearchConsole(LastConsole);
                    if (ConTbl == NULL) {
                        return DefWindowProc(hWnd, Message, wParam, lParam);
                    }

                    PostMessage(ConTbl->hWndCon, Message, wParam, lParam);
                }
                return TRUE;    // TRUE : process this message by application

            case CONIME_INPUTLANGCHANGEREQUEST:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGEREQUEST: Console Handle=%08x \n",wParam));
                return ConImeInputLangchangeRequest(hWnd, (HANDLE)wParam, (HKL)lParam, CONIME_DIRECT);

            case CONIME_INPUTLANGCHANGEREQUESTFORWARD:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGEREQUEST: Console Handle=%08x \n",wParam));
                return ConImeInputLangchangeRequest(hWnd, (HANDLE)wParam, (HKL)lParam, CONIME_FORWARD);

            case CONIME_INPUTLANGCHANGEREQUESTBACKWARD:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGEREQUEST: Console Handle=%08x \n",wParam));
                return ConImeInputLangchangeRequest(hWnd, (HANDLE)wParam, (HKL)lParam, CONIME_BACKWARD);

#ifdef DEBUG_MODE
            case WM_MOVE:
                ImeUIMoveCandWin( hWnd );
                break;

            case WM_COMMAND: // message: command from application menu

                // Message packing of wparam and lparam have changed for Win32,
                // so use the GET_WM_COMMAND macro to unpack the commnad

                switch (LOWORD(wParam)) {
                    case MM_EXIT:
                        PostMessage(hWnd,WM_CLOSE,0,0L);
                        break;

                    case MM_ACCESS_VIOLATION:
                        {
                            PBYTE p = 0;
                            *p = 0;
                        }
                        break;
                }
                break;
#endif

            case WM_IME_STARTCOMPOSITION:
                ImeUIStartComposition( hWnd );
                break;
            case WM_IME_ENDCOMPOSITION:
                ImeUIEndComposition( hWnd );
                break;
            case WM_IME_COMPOSITION:
                ImeUIComposition( hWnd, wParam, lParam );
                break;
            case WM_IME_COMPOSITIONFULL:
                break;
            case WM_IME_NOTIFY:
                if ( !ImeUINotify( hWnd, wParam, lParam ) ) {
                    return DefWindowProc(hWnd, Message, wParam, lParam);
                }
                break;
            case WM_IME_SETCONTEXT:
                //
                // The application have to pass WM_IME_SETCONTEXT to DefWindowProc.
                // When the application want to handle the IME at the timing of
                // focus changing, the application should use WM_GETFOCUS or
                // WM_KILLFOCUS.
                //
                lParam &= ~ISC_SHOWUIALL;

                return DefWindowProc( hWnd, Message, wParam, lParam );
            case WM_IME_SYSTEM:
                switch (wParam) {
                    case IMS_CLOSEPROPERTYWINDOW:
                    case IMS_OPENPROPERTYWINDOW:
                        ImeSysPropertyWindow(hWnd, wParam, lParam);
                        break;
                    default:
                        return DefWindowProc( hWnd, Message, wParam, lParam );
                }
                break;

            case WM_CREATE:
                return Create(hWnd);
                break;

            case WM_DESTROY:
                DBGPRINT(("CONIME:Recieve WM_DESTROY\n"));
                ExitList(hWnd);
                PostQuitMessage(0);
                return 0;
                break;

            case WM_CLOSE:
                DBGPRINT(("CONIME:Recieve WM_CLOSE\n"));
                DestroyWindow(hWnd);
                return 0;
                break;

            case WM_ENABLE:{
                PCONSOLE_TABLE FocusedConsole;
                if (!wParam) {
                    FocusedConsole = SearchConsole(LastConsole);
                    if (FocusedConsole != NULL &&
                        FocusedConsole->hConsole != NULL) {
                        FocusedConsole->Enable = FALSE;
                        EnableWindow(FocusedConsole->hWndCon,FALSE);
                        gfDoNotKillFocus = TRUE;
                    }
                }
                else{
                    DWORD i;
                    LockConsoleTable();
                    for ( i = 1; i < NumberOfConsoleTable; i ++){
                        FocusedConsole = ConsoleTable[i];
                        if (FocusedConsole != NULL)
                        {
                            if ((FocusedConsole->hConsole != NULL)&&
                                (!FocusedConsole->Enable)&&
                                (!IsWindowEnabled(FocusedConsole->hWndCon))){
                                EnableWindow(FocusedConsole->hWndCon,TRUE);
                                FocusedConsole->Enable = TRUE;
                                if (!FocusedConsole->LateRemove)
                                    SetForegroundWindow(FocusedConsole->hWndCon);
                            }
                        }
                    }
                    UnlockConsoleTable();
                }
                return DefWindowProc(hWnd, Message, wParam, lParam);
                break;
            }

#ifdef DEBUG_MODE
            case WM_SETFOCUS:
                CreateCaret( hWnd,
                             NULL,
                             IsUnicodeFullWidth( ConvertLine[xPos] ) ?
                             CaretWidth*2 : CaretWidth,
                             (UINT)cyMetrics );
                SetCaretPos( xPos * cxMetrics, 0 );
                ShowCaret( hWnd );
                break;

            case WM_KILLFOCUS:
                HideCaret( hWnd );
                DestroyCaret();
                break;

            case WM_PAINT:
                {
                    PAINTSTRUCT pstruc;
                    HDC  hDC;
                    hDC = BeginPaint(hWnd,&pstruc);
                    ReDraw(hWnd);
                    EndPaint(hWnd,&pstruc);
                    break;
                }
#endif

            case WM_QUERYENDSESSION:
#ifdef HIRSHI_DEBUG
                /*
                 * If specified ntsd debugger on this process,
                 * then never catch WM_QUERYENDSESSION when logoff/shutdown because
                 * this process will terminate when ntsd process terminated.
                 */
                {
                    int i;
                    i = MessageBox(hWnd,TEXT("Could you approve exit session?"), TEXT("Console IME"),
                                   MB_ICONSTOP | MB_YESNO);
                    return (i == IDYES ? TRUE : FALSE);
                }
#endif
                return TRUE;           // Logoff or shutdown time.

            case WM_ENDSESSION:
                DBGPRINT(("CONIME:Recieve WM_ENDSESSION\n"));
                ExitList(hWnd);
                return 0;

            default:          // Passes it on if unproccessed
                return DefWindowProc(hWnd, Message, wParam, lParam);
        }

    } except (InputExceptionFilter(GetExceptionInformation())) {

        if (dwConsoleThreadId)
        {
            DBGPRINT(("CONIME: Exception on WndProc!!\n"));
            UnregisterConsoleIME();
            dwConsoleThreadId = 0;

            DestroyWindow(hWnd);
            return 0;
        }

    }


    return TRUE;
}


VOID
ExitList(
    HWND hWnd
    )
{
    ULONG i ,j;
    PCONSOLE_TABLE FocusedConsole;

    DBGPRINT(("CONIME:ExitList Processing\n"));
    ImmAssociateContext(hWnd,ghDefaultIMC);

    LockConsoleTable();

    for (i = 1; i < NumberOfConsoleTable; i++) {
        FocusedConsole = ConsoleTable[i];
        if (FocusedConsole != NULL)
        {
            if (FocusedConsole->hConsole != NULL) {
                if (FocusedConsole->Enable) {
                    ImmDestroyContext(FocusedConsole->hIMC_Original);
                    if ( FocusedConsole->lpCompStrMem != NULL) {
                        LocalFree( FocusedConsole->lpCompStrMem );
                        FocusedConsole->lpCompStrMem = NULL;
                    }
                    for (j = 0; j < MAX_LISTCAND; j++){
                        if (FocusedConsole->lpCandListMem[j] != NULL) {
                            LocalFree(FocusedConsole->lpCandListMem[j]);
                            FocusedConsole->lpCandListMem[j] = NULL;
                            FocusedConsole->CandListMemAllocSize[j] = 0;
                        }
                    }
                    if (FocusedConsole->CandSep != NULL) {
                        LocalFree(FocusedConsole->CandSep);
                        FocusedConsole->CandSepAllocSize = 0;
                    }
                    FocusedConsole->Enable = FALSE;
                }
                else
                    FocusedConsole->LateRemove = TRUE;
            }
        }
    }
    LocalFree( ConsoleTable );
    ConsoleTable = NULL;
    UnlockConsoleTable();

    if (dwConsoleThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), dwConsoleThreadId, FALSE);
        UnregisterConsoleIME();
        dwConsoleThreadId = 0;
    }
}

BOOL
InsertConsole(
    HWND    hWnd,
    HANDLE  hConsole,
    HWND    hWndConsole
    )
{
    ULONG i;
    PCONSOLE_TABLE FocusedConsole;

    i = 1;

    do {
        for (; i < NumberOfConsoleTable; i++) {
            FocusedConsole = ConsoleTable[i];

            if (FocusedConsole == NULL)
            {
                FocusedConsole = LocalAlloc(LPTR, sizeof(CONSOLE_TABLE));
                if (FocusedConsole == NULL)
                    return FALSE;
                ConsoleTable[i] = FocusedConsole;
            }

            if ((FocusedConsole->hConsole != NULL) &&
                (FocusedConsole->LateRemove)&&
                (FocusedConsole->Enable)) {
                RemoveConsoleWorker(hWnd, FocusedConsole);
            }

            if (FocusedConsole->hConsole == NULL) {
                RtlZeroMemory(FocusedConsole, sizeof(CONSOLE_TABLE));
                FocusedConsole->lphklList = LocalAlloc(LPTR, sizeof(HKL_TABLE)*HKL_INITIAL_TABLE);
                if (FocusedConsole->lphklList == NULL)
                {
                    return FALSE;
                }
                RtlZeroMemory(FocusedConsole->lphklList, sizeof(HKL_TABLE)*HKL_INITIAL_TABLE);
                FocusedConsole->hklListMax = HKL_INITIAL_TABLE ;

                FocusedConsole->hIMC_Current = ImmCreateContext();
                if (FocusedConsole->hIMC_Current == (HIMC)NULL) {
                    LocalFree(FocusedConsole);
                    FocusedConsole = NULL;
                    return FALSE;
                }

                FocusedConsole->hIMC_Original = FocusedConsole->hIMC_Current;
                FocusedConsole->hConsole      = hConsole;
                FocusedConsole->hWndCon       = hWndConsole;
//                FocusedConsole->hklActive     = NULL;
                FocusedConsole->Enable        = TRUE;
//                FocusedConsole->LateRemove    = FALSE;
//                FocusedConsole->fNestCandidate = FALSE;
//                FocusedConsole->fInComposition = FALSE;
//                FocusedConsole->fInCandidate = FALSE;
                FocusedConsole->ScreenBufferSize.X = DEFAULT_TEMP_WIDTH;

                FocusedConsole->CompAttrColor[0] = DEFAULT_COMP_ENTERED;
                FocusedConsole->CompAttrColor[1] = DEFAULT_COMP_ALREADY_CONVERTED;
                FocusedConsole->CompAttrColor[2] = DEFAULT_COMP_CONVERSION;
                FocusedConsole->CompAttrColor[3] = DEFAULT_COMP_YET_CONVERTED;
                FocusedConsole->CompAttrColor[4] = DEFAULT_COMP_INPUT_ERROR;
                FocusedConsole->CompAttrColor[5] = DEFAULT_COMP_INPUT_ERROR;
                FocusedConsole->CompAttrColor[6] = DEFAULT_COMP_INPUT_ERROR;
                FocusedConsole->CompAttrColor[7] = DEFAULT_COMP_INPUT_ERROR;

                GetIMEName(FocusedConsole);

                return TRUE;
            }
        }
    } while (GrowConsoleTable());

    DBGPRINT(("CONIME: Cannot grow Console Table\n"));
    return FALSE;
}

BOOL
GrowConsoleTable(
    VOID
    )
{
    PCONSOLE_TABLE *NewTable;
    PCONSOLE_TABLE *OldTable;
    ULONG MaxConsoleTable;

    MaxConsoleTable = NumberOfConsoleTable + CONSOLE_CONSOLE_TABLE_INCREMENT;
    NewTable = (PCONSOLE_TABLE *)LocalAlloc(LPTR, MaxConsoleTable * sizeof(PCONSOLE_TABLE));
    if (NewTable == NULL) {
        return FALSE;
    }
    CopyMemory(NewTable, ConsoleTable, NumberOfConsoleTable * sizeof(PCONSOLE_TABLE));

    OldTable = ConsoleTable;
    ConsoleTable = NewTable;
    NumberOfConsoleTable = MaxConsoleTable;

    LocalFree(OldTable);

    return TRUE;
}

PCONSOLE_TABLE
SearchConsole(
    HANDLE hConsole
    )
{
    ULONG i;
    PCONSOLE_TABLE FocusedConsole;

    LockConsoleTable();

    // conime receive ime message from console before 1st console registered.
    // this will happen after restart conime when conime dead by bogus ime's AV or 
    // other problem
    // so this fail safe code is  necessary to protect consrv.
    if (LastConsole == 0) {
        LastConsole = hConsole ;
    }

    for (i = 1; i < NumberOfConsoleTable; i++) {
        FocusedConsole = ConsoleTable[i];
        if (FocusedConsole != NULL)
        {
            if ((FocusedConsole->hConsole == hConsole)&&
                (!FocusedConsole->LateRemove)) {

                UnlockConsoleTable();
                return FocusedConsole;
            }
        }
    }
    UnlockConsoleTable();
    return NULL;
}

BOOL
RemoveConsole(
    HWND hwnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;
    BOOL ret;

    LockConsoleTable();

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL)
    {
        UnlockConsoleTable();
        return FALSE;
    }
    ret = RemoveConsoleWorker(hwnd, ConTbl);

    UnlockConsoleTable();
    return ret;
}

BOOL
RemoveConsoleWorker(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    DWORD j;

    if (ConTbl->Enable) {
        ConTbl->hConsole = NULL;
        ConTbl->ScreenBufferSize.X = 0;
        ConTbl->ConsoleCP = 0;
        ConTbl->ConsoleOutputCP = 0;
        ConTbl->hklActive = 0;

        ImmDestroyContext(ConTbl->hIMC_Original);

        if (ConTbl->lpCompStrMem != NULL){
            LocalFree(ConTbl->lpCompStrMem);
        }
        for (j = 0; j < MAX_LISTCAND; j++){
            if (ConTbl->lpCandListMem[j] != NULL) {
                LocalFree(ConTbl->lpCandListMem[j]);
            }
        }
        if (ConTbl->CandSep != NULL) {
            LocalFree(ConTbl->CandSep);
        }

        if (ConTbl->lphklList != NULL) {
            LocalFree(ConTbl->lphklList) ;
        }

        ConTbl->Enable     = FALSE;
        ConTbl->LateRemove = FALSE;
    }
    else
        ConTbl->LateRemove = TRUE;

#ifdef DEBUG_MODE
    InvalidateRect(hwnd,NULL,TRUE);
#endif
    return TRUE;
}

BOOL
InsertNewConsole(
    HWND   hWnd,
    HANDLE hConsole,
    HWND   hWndConsole
    )
{
    // conime receive ime message from console before 1st console registered.
    // this will happen after restart conime when conime dead by bogus ime's AV or 
    // other problem
    // so this fail safe code is  necessary to protect consrv.
    if (SearchConsole(hConsole) != NULL) {
        return TRUE;
    }

    LockConsoleTable();

    if (!InsertConsole(hWnd, hConsole, hWndConsole)) {
        UnlockConsoleTable();
        return FALSE;
    }

#ifdef DEBUG_MODE
    DisplayInformation(hWnd, hConsole);
#endif

    ImeUISetOpenStatus( hWndConsole );

    UnlockConsoleTable();

    return TRUE;
}


BOOL
ConsoleSetFocus(
    HWND hWnd,
    HANDLE hConsole,
    HKL hKL
    )
{
    PCONSOLE_TABLE ConTbl;
    HKL OldhKL;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if ( gfDoNotKillFocus ){
        gfDoNotKillFocus = FALSE;
    }

    OldhKL = ConTbl->hklActive ;
    ConTbl->hklActive = hKL;
    ActivateKeyboardLayout(ConTbl->hklActive, 0);
    ImmAssociateContext(hWnd, ConTbl->hIMC_Current);

    if (OldhKL == 0) {
        GetIMEName( ConTbl );
        ConTbl->ImmGetProperty = ImmGetProperty(ConTbl->hklActive , IGP_PROPERTY);
    }

//v-hirshi Jun.13.1996 #if defined(LATER_DBCS)  // kazum
    ImmSetActiveContextConsoleIME(hWnd, TRUE);
//v-hirshi Jun.13.1996 #endif

    LastConsole = hConsole;

#ifdef DEBUG_MODE
    DisplayInformation(hWnd, hConsole);
#endif

    ImeUISetOpenStatus( hWnd );
    if (ConTbl->lpCompStrMem != NULL)
        ReDisplayCompositionStr( hWnd );

    return TRUE;
}

BOOL
ConsoleKillFocus(
    HWND hWnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if ( gfDoNotKillFocus ){
        gfDoNotKillFocus = FALSE;
    }
    else{
//v-hirshi Jun.13.1996 #if defined(LATER_DBCS)  // kazum
        ImmSetActiveContextConsoleIME(hWnd, FALSE);
//v-hirshi Jun.13.1996 #endif
        ImmAssociateContext(hWnd, ghDefaultIMC);
    }

#ifdef DEBUG_MODE
    DisplayInformation(hWnd, hConsole);
#endif

    return TRUE;
}

BOOL
ConsoleScreenBufferSize(
    HWND hWnd,
    HANDLE hConsole,
    COORD ScreenBufferSize
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    ConTbl->ScreenBufferSize = ScreenBufferSize;
    return TRUE;
}

BOOL
ConImeInputLangchangeRequest(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl,
    int Direction
    )
{
    PCONSOLE_TABLE ConTbl;
    int nLayouts;
    LPHKL lphkl;
    DWORD RequiredLID = 0;
    int StartPos;
    int CurrentHklPos;
    int i;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: cannot find registered Console\n"));
        return FALSE;
    }

    switch (ConTbl->ConsoleOutputCP) {
        case JAPAN_CODEPAGE:
            RequiredLID = LANG_ID_JAPAN;
            break;
        case PRC_CODEPAGE:
            RequiredLID = LANG_ID_PRC;
            break;
        case KOREA_CODEPAGE:
            RequiredLID = LANG_ID_KOREA;
            break;
        case TAIWAN_CODEPAGE:
            RequiredLID = LANG_ID_TAIWAN;
            break;
        default:
            break;
    }

    if ( !IS_IME_KBDLAYOUT(hkl) ||
        ( HKL_TO_LANGID(hkl) == RequiredLID)) {
        return TRUE;
    }
    if (Direction == CONIME_DIRECT) {
        return FALSE;
    }

    nLayouts = GetKeyboardLayoutList(0, NULL);
    if (nLayouts == 0) {
        return FALSE;
    }
    lphkl = LocalAlloc(LPTR, nLayouts * sizeof(HKL));
    if (lphkl == NULL) {
        return FALSE;
    }
    GetKeyboardLayoutList(nLayouts, lphkl);

    for (CurrentHklPos = 0; CurrentHklPos < nLayouts; CurrentHklPos++) {
        if (ConTbl->hklActive == lphkl[CurrentHklPos] ) {
            break;
        }
    }
    if (CurrentHklPos >= nLayouts) {
        LocalFree(lphkl);
        return FALSE;
    }

    StartPos = CurrentHklPos;

    for (i = 0; i < nLayouts; i++) {
        StartPos+=Direction;
        if (StartPos < 0) {
            StartPos = nLayouts-1;
        }
        else if (StartPos >= nLayouts) {
            StartPos = 0;
        }
        
        if ((( HandleToUlong(lphkl[StartPos]) & 0xf0000000) == 0x00000000) ||
            (( HandleToUlong(lphkl[StartPos]) & 0x0000ffff) == RequiredLID)) {
            PostMessage( ConTbl->hWndCon,
                         CM_CONIME_KL_ACTIVATE,
                          HandleToUlong(lphkl[StartPos]),
                         0);
            LocalFree(lphkl);
            return FALSE;
        }
    }

    LocalFree(lphkl);
    return FALSE;

}

BOOL
ConImeInputLangchange(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl
    )
{
    PCONSOLE_TABLE ConTbl;
    LPCONIME_UIMODEINFO lpModeInfo;
    COPYDATASTRUCT CopyData;
    INT counter ;
    LPHKL_TABLE lphklListNew ;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        // cannot find specified console.
        // It might be last console lost focus.
        // try Last Console.
        ConTbl = SearchConsole(LastConsole);
        if (ConTbl == NULL) {
            DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
            return FALSE;
        }
    }

    if (ConTbl->lphklList == NULL) {
        return FALSE;
    }

    if (IS_IME_KBDLAYOUT(ConTbl->hklActive)) {
        for (counter = 0 ; counter < ConTbl->hklListMax ;counter ++) 
        {
            if (ConTbl->lphklList[counter].hkl == 0 || ConTbl->lphklList[counter].hkl == ConTbl->hklActive) {
                break;
            }
        }

        if (counter >= ConTbl->hklListMax)
        {
            ASSERT(counter == ConTbl->hklListMax);
            // reallocation
            lphklListNew = LocalAlloc(LPTR, sizeof(HKL_TABLE) * (ConTbl->hklListMax + HKL_TABLE_INCREMENT) ) ;
            if (lphklListNew != NULL)
            {
                CopyMemory(lphklListNew , ConTbl->lphklList , sizeof(HKL_TABLE) * ConTbl->hklListMax) ;
                ConTbl->hklListMax += HKL_TABLE_INCREMENT ;
                LocalFree(ConTbl->lphklList);
                ConTbl->lphklList = lphklListNew;
            }
            else {
                return FALSE ;
            }
        }
        ASSERT(ConTbl->lphklList != NULL);
        ConTbl->lphklList[counter].hkl = ConTbl->hklActive;
        ConTbl->lphklList[counter].dwConversion = ConTbl->dwConversion | (ConTbl->fOpen ? IME_CMODE_OPEN : 0)  ;
    }

    ActivateKeyboardLayout(hkl, 0);
    ConTbl->hklActive = hkl;
    GetIMEName( ConTbl );
    ImeUIOpenStatusWindow(hWnd);
    ConTbl->ImmGetProperty = ImmGetProperty(ConTbl->hklActive , IGP_PROPERTY);

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) ) ;
    if ( lpModeInfo == NULL) {
        return FALSE;
    }
    CopyData.dwData = CI_CONIMEMODEINFO ;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
    CopyData.lpData = lpModeInfo ;

    if (IS_IME_KBDLAYOUT(hkl)) {

        for (counter=0; counter < ConTbl->hklListMax ; counter++)
        {
            if (ConTbl->lphklList[counter].hkl == hkl)
            {
                SetNLSMode(hWnd, hConsole,ConTbl->lphklList[counter].dwConversion ) ;
                ImeUIOpenStatusWindow(hWnd) ;
                if (ImeUIMakeInfoString(ConTbl,
                                        lpModeInfo))
                {
                    ConsoleImeSendMessage( ConTbl->hWndCon,
                                           (WPARAM)hWnd,
                                           (LPARAM)&CopyData
                                         ) ;
                }
            }
        }
    }
    else
    {

        SetNLSMode(hWnd, hConsole,ConTbl->dwConversion & ~IME_CMODE_OPEN ) ;
        lpModeInfo->ModeStringLen = 0 ;
        lpModeInfo->Position = VIEW_RIGHT ;
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hWnd,
                               (LPARAM)&CopyData
                              ) ;
    }

    LocalFree( lpModeInfo );

    return TRUE;
}

BOOL
InputLangchange(
    HWND hWnd,
    DWORD CharSet,
    HKL hkl
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    ConTbl->hklActive = hkl;
    ActivateKeyboardLayout(ConTbl->hklActive, 0);
    GetIMEName( ConTbl );
    ImeUIOpenStatusWindow(hWnd);
    return TRUE;
}

/*
 * Console IME message pump.
 */
LRESULT
ConsoleImeSendMessage(
    HWND   hWndConsoleIME,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT lResult;
    LRESULT fNoTimeout;

    if (hWndConsoleIME == NULL)
    {
        return FALSE;
    }

    fNoTimeout = SendMessageTimeout(hWndConsoleIME,
                                    WM_COPYDATA,
                                    wParam,
                                    lParam,
                                    SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                    CONIME_SENDMSG_TIMEOUT,
                                    &lResult);

    if (fNoTimeout)
    {
        return TRUE;
    }


    /*
     * ConsoleImeMessagePump give up SendMessage to conime.
     * CONIME is hung up.
     * probably, consrv also hung up.
     */
    KdPrint(("ConsoleImeSendMessage: CONIME_SENDMSG_COUNT is hung up\n"));

    return FALSE;

}

#ifdef DEBUG_MODE

int             cxMetrics;
int             cyMetrics;
int             cxOverTypeCaret;
int             xPos;
int             xPosLast;
int             CaretWidth;                     // insert/overtype mode caret width

WCHAR           ConvertLine[CVMAX];
unsigned char   ConvertLineAtr[CVMAX];

WCHAR           DispTitle[] = TEXT(" Console Handle");

DWORD CompColor[ 8 ] = { RGB(   0,   0,   0 ),  // ATTR_INPUT
                         RGB(   0,   0, 255 ),  // ATTR_TARGET_CONVERTED
                         RGB(   0, 255,   0 ),  // ATTR_CONVERTED
                         RGB( 255,   0,   0 ),  // ATTR_TARGET_NOTCONVERTED
                         RGB( 255,   0, 255 ),  // ATTR_INPUT_ERROR
                         RGB(   0, 255, 255 ),  // ATTR_DEFAULT
                         RGB( 255, 255,   0 ),  // ATTR_DEFAULT
                         RGB( 255, 255, 255 ) };// ATTR_DEFAULT

VOID
DisplayConvInformation(
    HWND hWnd
    )
{
    RECT      Rect;
    HDC       lhdc;

    lhdc = GetDC(hWnd);
    GetClientRect(hWnd, &Rect);

    InvalidateRect(hWnd,NULL,FALSE);
    UpdateWindow(hWnd);
    ReleaseDC(hWnd, lhdc);
}

VOID
DisplayInformation(
    HWND hWnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;
    RECT      Rect;
    HDC       lhdc;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    lhdc = GetDC(hWnd);
    GetClientRect(hWnd, &Rect);

    wsprintf(ConTbl->DispBuf, TEXT("%08x"), (ULONG)hConsole);

    InvalidateRect(hWnd,NULL,FALSE);
    UpdateWindow(hWnd);
    ReleaseDC(hWnd, lhdc);
}

VOID
RealReDraw(
    HDC r_hdc
    )
{
    PCONSOLE_TABLE ConTbl;
    INT     ix, iy, i, rx, sx;
    ULONG   cnt;
    int     ColorIndex;
    int     PrevColorIndex;
    DWORD   dwColor;

    iy = 0;

    dwColor = GetTextColor( r_hdc );

    ColorIndex = ( ((int)ConvertLineAtr[0]) < 0 ) ? 0 : (int)ConvertLineAtr[0];
    ColorIndex = ( ColorIndex > 7 ) ? 0 : ColorIndex;
    PrevColorIndex = ColorIndex;
    SetTextColor( r_hdc, CompColor[ ColorIndex ] );

    rx = 0;
    sx = 0;
    for (ix = 0; ix < MAXCOL; ) {
        for (i = ix; i < MAXCOL; i++) {
            if (PrevColorIndex != (int)ConvertLineAtr[i])
                break;
            rx += IsUnicodeFullWidth(ConvertLine[ix]) ? 2 : 1;
        }
        TextOut( r_hdc, sx * cxMetrics, iy, &ConvertLine[ix], i-ix );
        sx = rx;
        ColorIndex = ( ((int)ConvertLineAtr[i]) < 0 ) ? 0 : (int)ConvertLineAtr[i];
        ColorIndex = ( ColorIndex > 7 ) ? 0 : ColorIndex;
        PrevColorIndex = ColorIndex;
        SetTextColor( r_hdc, CompColor[ ColorIndex ] );
        ix = i;
    }

    ix = 0;
    SetTextColor( r_hdc, dwColor );
    iy += cyMetrics;
    TextOut( r_hdc, ix, iy, DispTitle, lstrlenW(DispTitle));

    iy += cyMetrics;

    LockConsoleTable();

    for (cnt = 1; cnt < NumberOfConsoleTable; cnt++, iy += cyMetrics){
        ConTbl = ConsoleTable[cnt];
        if (ConTbl != NULL)
        {
            if (ConTbl->hConsole)
            {
                TextOut( r_hdc, ix, iy, ConTbl->DispBuf, lstrlenW(ConTbl->DispBuf) );
            }
        }
    }

    UnlockConsoleTable();

    return;
}

VOID
ReDraw(
    HWND hWnd
    )
{
    HDC r_hdc;
    RECT ClientRect;

    GetClientRect(hWnd, &ClientRect);
    r_hdc = GetDC(hWnd);
    FillRect(r_hdc, &ClientRect, GetStockObject(WHITE_BRUSH));
    RealReDraw(r_hdc);
    ReleaseDC(hWnd, r_hdc);
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\sources.inc ===
!IF 0

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Hirotoshi Shimizu(v-HirShi) 21-Jun-1995

!ENDIF


MAJORCOMP=windows
MINORCOMP=console

TARGETNAME=conime
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=..\..\inc;                             \
         $(WINCORE_PATH);                       \
         ..\; \
         $(BASE_INC_PATH)

USE_MSVCRT=1

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=-DWIN32 -DNT -DUNICODE -D_UNICODE \
          -DCUAS_ENABLE

SOURCES=..\conime.c \
        ..\consubs.c \
        ..\imefull.c \
        ..\country.c \
        ..\country2.c \
        ..\country3.c \
        ..\conime.rc

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

UMTYPE=windows
UMENTRY=winmain
UMAPPL=conime
UMLIBS=$(SDK_LIB_PATH)\kernel32.lib        \
       $(SDK_LIB_PATH)\kernl32p.lib        \
       $(SDK_LIB_PATH)\user32.lib          \
       $(SDK_LIB_PATH)\ntdll.lib           \
       $(SDK_LIB_PATH)\imm32.lib           \
       $(WINDOWS_LIB_PATH)\imm32p.lib      \
       $(SDK_LIB_PATH)\gdi32.lib           \
       $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\conmsg.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    conmsg.h

Abstract:

    This include file defines the message formats used to communicate
    between the client and server portions of the CONSOLE portion of the
    Windows subsystem.

Author:

    Therese Stowell (thereses) 10-Nov-1990

Revision History:

--*/

#ifndef _CONMSG_H_
#define _CONMSG_H_

#define CONSOLE_INPUT_HANDLE 1
#define CONSOLE_OUTPUT_HANDLE 2

// max lengths, in bytes!
#define MAX_TITLE_LENGTH ((MAX_PATH+1)*sizeof(WCHAR))
#define MAX_APP_NAME_LENGTH 256

#define INITIALIZATION_SUCCEEDED 0
#define INITIALIZATION_FAILED 1
#define NUMBER_OF_INITIALIZATION_EVENTS 2

#if defined(FE_SB) // for Kernel32 Single Binary
#include "winconp.h"  // need FONT_SELECT
#endif // FE_SB

typedef struct _CONSOLE_INFO {
    IN OUT HANDLE ConsoleHandle;
    OUT HANDLE InputWaitHandle;
    OUT HANDLE StdIn;
    OUT HANDLE StdOut;
    OUT HANDLE StdErr;
    OUT HANDLE InitEvents[NUMBER_OF_INITIALIZATION_EVENTS];
    IN UINT   iIconId;
    IN HICON  hIcon;
    IN HICON  hSmIcon;
    IN DWORD dwHotKey;
    IN DWORD dwStartupFlags;
    IN WORD  wFillAttribute OPTIONAL;
    IN WORD  wPopupFillAttribute OPTIONAL;
    IN WORD  wShowWindow OPTIONAL;
    IN WORD  wReserved OPTIONAL;
    IN COORD dwScreenBufferSize OPTIONAL;
    IN COORD dwWindowSize OPTIONAL;
    IN COORD dwWindowOrigin OPTIONAL;
    IN DWORD nFont OPTIONAL;
    IN DWORD nInputBufferSize OPTIONAL;
    IN COORD dwFontSize OPTIONAL;
    IN UINT  uFontFamily OPTIONAL;
    IN UINT  uFontWeight OPTIONAL;
    IN WCHAR FaceName[LF_FACESIZE];
    IN UINT  uCursorSize OPTIONAL;
    IN BOOL  bFullScreen OPTIONAL;
    IN BOOL  bQuickEdit  OPTIONAL;
    IN BOOL  bInsertMode OPTIONAL;
    IN BOOL  bAutoPosition OPTIONAL;
    IN UINT  uHistoryBufferSize OPTIONAL;
    IN UINT  uNumberOfHistoryBuffers OPTIONAL;
    IN BOOL  bHistoryNoDup OPTIONAL;
    IN COLORREF ColorTable[ 16 ] OPTIONAL;
#if defined(FE_SB) // for Kernel32 Single Binary
    IN UINT  uCodePage;
#endif // FE_SB
} CONSOLE_INFO, *PCONSOLE_INFO;


//
// This structure is filled in by the client prior to connecting to the CONSRV
// DLL in the Windows subsystem server.  The server DLL will fill in the OUT
// fields if prior to accepting the connection.
//

typedef struct _CONSOLE_API_CONNECTINFO {
    IN OUT CONSOLE_INFO ConsoleInfo;
    IN BOOLEAN ConsoleApp;
    IN BOOLEAN WindowVisible;
    IN LPTHREAD_START_ROUTINE CtrlRoutine;
    IN LPTHREAD_START_ROUTINE PropRoutine;
#if defined(FE_SB)
#if defined(FE_IME)
    IN LPTHREAD_START_ROUTINE ConsoleIMERoutine;
#endif // FE_IME
#endif // FE_SB
    IN DWORD TitleLength;
    IN WCHAR Title[MAX_TITLE_LENGTH/2];
    IN DWORD DesktopLength;
    IN LPWSTR Desktop;
    IN DWORD AppNameLength;
    IN WCHAR AppName[MAX_APP_NAME_LENGTH/2];
    IN DWORD CurDirLength;
    IN WCHAR CurDir[MAX_PATH+1];
} CONSOLE_API_CONNECTINFO, *PCONSOLE_API_CONNECTINFO;

//
// Message format for messages sent from the client to the server
//

typedef enum _CONSOLE_API_NUMBER {
    ConsolepOpenConsole = CONSRV_FIRST_API_NUMBER,
    ConsolepGetConsoleInput,
    ConsolepWriteConsoleInput,
    ConsolepReadConsoleOutput,
    ConsolepWriteConsoleOutput,
    ConsolepReadConsoleOutputString,
    ConsolepWriteConsoleOutputString,
    ConsolepFillConsoleOutput,
    ConsolepGetMode,
    ConsolepGetNumberOfFonts,
    ConsolepGetNumberOfInputEvents,
    ConsolepGetScreenBufferInfo,
    ConsolepGetCursorInfo,
    ConsolepGetMouseInfo,
    ConsolepGetFontInfo,
    ConsolepGetFontSize,
    ConsolepGetCurrentFont,
    ConsolepSetMode,
    ConsolepSetActiveScreenBuffer,
    ConsolepFlushInputBuffer,
    ConsolepGetLargestWindowSize,
    ConsolepSetScreenBufferSize,
    ConsolepSetCursorPosition,
    ConsolepSetCursorInfo,
    ConsolepSetWindowInfo,
    ConsolepScrollScreenBuffer,
    ConsolepSetTextAttribute,
    ConsolepSetFont,
    ConsolepSetIcon,
    ConsolepReadConsole,
    ConsolepWriteConsole,
    ConsolepDupHandle,
    ConsolepGetHandleInformation,
    ConsolepSetHandleInformation,
    ConsolepCloseHandle,
    ConsolepVerifyIoHandle,
    ConsolepAlloc,
    ConsolepFree,
    ConsolepGetTitle,
    ConsolepSetTitle,
    ConsolepCreateScreenBuffer,
    ConsolepInvalidateBitmapRect,
    ConsolepVDMOperation,
    ConsolepSetCursor,
    ConsolepShowCursor,
    ConsolepMenuControl,
    ConsolepSetPalette,
    ConsolepSetDisplayMode,
    ConsolepRegisterVDM,
    ConsolepGetHardwareState,
    ConsolepSetHardwareState,
    ConsolepGetDisplayMode,
    ConsolepAddAlias,
    ConsolepGetAlias,
    ConsolepGetAliasesLength,
    ConsolepGetAliasExesLength,
    ConsolepGetAliases,
    ConsolepGetAliasExes,
    ConsolepExpungeCommandHistory,
    ConsolepSetNumberOfCommands,
    ConsolepGetCommandHistoryLength,
    ConsolepGetCommandHistory,
    ConsolepSetCommandHistoryMode,
    ConsolepGetCP,
    ConsolepSetCP,
    ConsolepSetKeyShortcuts,
    ConsolepSetMenuClose,
    ConsolepNotifyLastClose,
    ConsolepGenerateCtrlEvent,
    ConsolepGetKeyboardLayoutName,
    ConsolepGetConsoleWindow,
#if defined(FE_SB) // for Kernel32 Single Binary
    ConsolepCharType,
    ConsolepSetLocalEUDC,
    ConsolepSetCursorMode,
    ConsolepGetCursorMode,
    ConsolepRegisterOS2,
    ConsolepSetOS2OemFormat,
#if defined(FE_IME)
    ConsolepGetNlsMode,
    ConsolepSetNlsMode,
    ConsolepRegisterConsoleIME,
    ConsolepUnregisterConsoleIME,
#endif // FE_IME
#endif // FE_SB
    ConsolepGetLangId,
    ConsolepAttach,
    ConsolepGetSelectionInfo,
    ConsolepGetConsoleProcessList,
    ConsolepMaxApiNumber
} CONSOLE_API_NUMBER, *PCONSOLE_API_NUMBER;

typedef struct _CONSOLE_CREATESCREENBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN ULONG DesiredAccess;
    IN BOOL InheritHandle;
    IN ULONG ShareMode;
    IN DWORD Flags;
    IN OUT CONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo;
    OUT HANDLE hMutex;
    OUT PVOID lpBitmap;
    OUT HANDLE Handle;
} CONSOLE_CREATESCREENBUFFER_MSG, *PCONSOLE_CREATESCREENBUFFER_MSG;

typedef struct _CONSOLE_OPENCONSOLE_MSG {
    IN HANDLE ConsoleHandle;
    IN ULONG HandleType;
    IN ULONG DesiredAccess;
    IN BOOL InheritHandle;
    IN ULONG ShareMode;
    OUT HANDLE Handle;
} CONSOLE_OPENCONSOLE_MSG, *PCONSOLE_OPENCONSOLE_MSG;

#define INPUT_RECORD_BUFFER_SIZE 5

typedef struct _CONSOLE_GETCONSOLEINPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    OUT INPUT_RECORD Record[INPUT_RECORD_BUFFER_SIZE];
    OUT PINPUT_RECORD  BufPtr;
    IN OUT ULONG  NumRecords;   // this value is valid even for error cases
    IN USHORT Flags;
    BOOLEAN Unicode;
} CONSOLE_GETCONSOLEINPUT_MSG, *PCONSOLE_GETCONSOLEINPUT_MSG;

typedef struct _CONSOLE_WRITECONSOLEINPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    IN INPUT_RECORD Record[INPUT_RECORD_BUFFER_SIZE];
    IN PINPUT_RECORD  BufPtr;
    IN OUT ULONG  NumRecords;  // this value is valid even for error cases
    BOOLEAN Unicode;
    BOOLEAN Append;
} CONSOLE_WRITECONSOLEINPUT_MSG, *PCONSOLE_WRITECONSOLEINPUT_MSG;

typedef struct _CONSOLE_READCONSOLEOUTPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT CHAR_INFO Char;
    OUT PCHAR_INFO BufPtr;
    IN OUT SMALL_RECT CharRegion; // this value is valid even for error cases
    BOOLEAN Unicode;
} CONSOLE_READCONSOLEOUTPUT_MSG, *PCONSOLE_READCONSOLEOUTPUT_MSG;

typedef struct _CONSOLE_WRITECONSOLEOUTPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN CHAR_INFO Char;
    IN PCHAR_INFO BufPtr;
    IN OUT SMALL_RECT CharRegion; // this value is valid even for error cases
    BOOLEAN Unicode;
    BOOLEAN ReadVM;
} CONSOLE_WRITECONSOLEOUTPUT_MSG, *PCONSOLE_WRITECONSOLEOUTPUT_MSG;

#define BUFFER_SIZE 80

/*
 * WriteOutputString and ReadInputString types
 */
#define CONSOLE_ASCII             0x1
#define CONSOLE_REAL_UNICODE      0x2
#define CONSOLE_ATTRIBUTE         0x3
#define CONSOLE_FALSE_UNICODE     0x4

typedef struct _CONSOLE_READCONSOLEOUTPUTSTRING_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD ReadCoord;
    IN DWORD  StringType;
    OUT WCHAR String[BUFFER_SIZE/2];
    OUT PWCHAR BufPtr;
    IN OUT ULONG NumRecords; // this value is valid even for error cases
} CONSOLE_READCONSOLEOUTPUTSTRING_MSG, *PCONSOLE_READCONSOLEOUTPUTSTRING_MSG;

typedef struct _CONSOLE_WRITECONSOLEOUTPUTSTRING_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD WriteCoord;
    IN DWORD  StringType;
    OUT WCHAR String[BUFFER_SIZE/2];
    IN PWCHAR BufPtr;
    IN OUT ULONG NumRecords; // this value is valid even for error cases
} CONSOLE_WRITECONSOLEOUTPUTSTRING_MSG, *PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG;

typedef struct _CONSOLE_FILLCONSOLEOUTPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD WriteCoord;
    IN DWORD  ElementType;
    IN WORD Element;
    IN OUT ULONG Length; // this value is valid even for error cases
} CONSOLE_FILLCONSOLEOUTPUT_MSG, *PCONSOLE_FILLCONSOLEOUTPUT_MSG;

typedef struct _CONSOLE_MODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN DWORD Mode;
} CONSOLE_MODE_MSG, *PCONSOLE_MODE_MSG;

typedef struct _CONSOLE_GETNUMBEROFFONTS_MSG {
    IN HANDLE ConsoleHandle;
    OUT ULONG NumberOfFonts;
} CONSOLE_GETNUMBEROFFONTS_MSG, *PCONSOLE_GETNUMBEROFFONTS_MSG;

typedef struct _CONSOLE_GETNUMBEROFINPUTEVENTS_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    OUT DWORD ReadyEvents;
} CONSOLE_GETNUMBEROFINPUTEVENTS_MSG, *PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG;

typedef struct _CONSOLE_GETLARGESTWINDOWSIZE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT COORD  Size;
} CONSOLE_GETLARGESTWINDOWSIZE_MSG, *PCONSOLE_GETLARGESTWINDOWSIZE_MSG;

typedef struct _CONSOLE_GETSCREENBUFFERINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT COORD Size;
    OUT COORD CursorPosition;
    OUT COORD ScrollPosition;
    OUT WORD  Attributes;
    OUT COORD CurrentWindowSize;
    OUT COORD MaximumWindowSize;
} CONSOLE_GETSCREENBUFFERINFO_MSG, *PCONSOLE_GETSCREENBUFFERINFO_MSG;

typedef struct _CONSOLE_GETCURSORINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT DWORD CursorSize;
    OUT BOOLEAN Visible;
} CONSOLE_GETCURSORINFO_MSG, *PCONSOLE_GETCURSORINFO_MSG;

typedef struct _CONSOLE_GETSELECTIONINFO_MSG {
    IN HANDLE ConsoleHandle;
    OUT CONSOLE_SELECTION_INFO SelectionInfo;
} CONSOLE_GETSELECTIONINFO_MSG, *PCONSOLE_GETSELECTIONINFO_MSG;

typedef struct _CONSOLE_GETMOUSEINFO_MSG {
    IN HANDLE ConsoleHandle;
    OUT ULONG NumButtons;
} CONSOLE_GETMOUSEINFO_MSG, *PCONSOLE_GETMOUSEINFO_MSG;

typedef struct _CONSOLE_GETFONTINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOLEAN MaximumWindow;
    OUT PCHAR BufPtr;
    IN OUT ULONG NumFonts;  // this value is valid even for error cases
} CONSOLE_GETFONTINFO_MSG, *PCONSOLE_GETFONTINFO_MSG;

typedef struct _CONSOLE_GETFONTSIZE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD  FontIndex;
    OUT COORD FontSize;
} CONSOLE_GETFONTSIZE_MSG, *PCONSOLE_GETFONTSIZE_MSG;

typedef struct _CONSOLE_GETCURRENTFONT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOLEAN MaximumWindow;
    OUT DWORD FontIndex;
    OUT COORD FontSize;
} CONSOLE_GETCURRENTFONT_MSG, *PCONSOLE_GETCURRENTFONT_MSG;

typedef struct _CONSOLE_SETACTIVESCREENBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
} CONSOLE_SETACTIVESCREENBUFFER_MSG, *PCONSOLE_SETACTIVESCREENBUFFER_MSG;

typedef struct _CONSOLE_FLUSHINPUTBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
} CONSOLE_FLUSHINPUTBUFFER_MSG, *PCONSOLE_FLUSHINPUTBUFFER_MSG;

typedef struct _CONSOLE_SETSCREENBUFFERSIZE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD  Size;
} CONSOLE_SETSCREENBUFFERSIZE_MSG, *PCONSOLE_SETSCREENBUFFERSIZE_MSG;

typedef struct _CONSOLE_SETCURSORPOSITION_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD  CursorPosition;
} CONSOLE_SETCURSORPOSITION_MSG, *PCONSOLE_SETCURSORPOSITION_MSG;

typedef struct _CONSOLE_SETCURSORINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD  CursorSize;
    IN BOOLEAN Visible;
} CONSOLE_SETCURSORINFO_MSG, *PCONSOLE_SETCURSORINFO_MSG;

typedef struct _CONSOLE_SETWINDOWINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOL Absolute;
    IN SMALL_RECT Window;
} CONSOLE_SETWINDOWINFO_MSG, *PCONSOLE_SETWINDOWINFO_MSG;

typedef struct _CONSOLE_SCROLLSCREENBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN SMALL_RECT ScrollRectangle;
    IN SMALL_RECT ClipRectangle;
    IN BOOL Clip;
    IN COORD  DestinationOrigin;
    IN CHAR_INFO Fill;
    IN BOOLEAN Unicode;
} CONSOLE_SCROLLSCREENBUFFER_MSG, *PCONSOLE_SCROLLSCREENBUFFER_MSG;

typedef struct _CONSOLE_SETTEXTATTRIBUTE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN WORD   Attributes;
} CONSOLE_SETTEXTATTRIBUTE_MSG, *PCONSOLE_SETTEXTATTRIBUTE_MSG;

typedef struct _CONSOLE_SETFONT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD  FontIndex;
} CONSOLE_SETFONT_MSG, *PCONSOLE_SETFONT_MSG;

typedef struct _CONSOLE_SETICON_MSG {
    IN HANDLE ConsoleHandle;
    IN HICON hIcon;
} CONSOLE_SETICON_MSG, *PCONSOLE_SETICON_MSG;

typedef struct _CONSOLE_READCONSOLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    IN USHORT ExeNameLength;
    IN OUT WCHAR   Buffer[BUFFER_SIZE/2];
    OUT PVOID  BufPtr;
    IN OUT ULONG  NumBytes;    // this value is valid even for error cases
    IN ULONG CaptureBufferSize;
    IN ULONG InitialNumBytes;
    IN ULONG CtrlWakeupMask;
    OUT ULONG ControlKeyState;
    IN BOOLEAN Unicode;
} CONSOLE_READCONSOLE_MSG, *PCONSOLE_READCONSOLE_MSG;

typedef struct _CONSOLE_WRITECONSOLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN WCHAR   Buffer[BUFFER_SIZE/2];
    IN PVOID  BufPtr;
    IN OUT ULONG  NumBytes;    // this value is valid even for error cases
    PWCHAR TransBuffer;         // used by server side only
    IN BOOLEAN BufferInMessage;
    IN BOOLEAN Unicode;
    BOOLEAN StackBuffer;        // used by server side only
    DWORD WriteFlags;           // used by server side only
} CONSOLE_WRITECONSOLE_MSG, *PCONSOLE_WRITECONSOLE_MSG;

typedef struct _CONSOLE_CLOSEHANDLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
} CONSOLE_CLOSEHANDLE_MSG, *PCONSOLE_CLOSEHANDLE_MSG;

typedef struct _CONSOLE_DUPHANDLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE SourceHandle;
    IN DWORD  DesiredAccess;
    IN BOOLEAN InheritHandle;
    IN DWORD Options;
    OUT HANDLE TargetHandle;
} CONSOLE_DUPHANDLE_MSG, *PCONSOLE_DUPHANDLE_MSG;

typedef struct _CONSOLE_GETHANDLEINFORMATION_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    OUT DWORD Flags;
} CONSOLE_GETHANDLEINFORMATION_MSG, *PCONSOLE_GETHANDLEINFORMATION_MSG;

typedef struct _CONSOLE_SETHANDLEINFORMATION_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN DWORD Mask;
    IN DWORD Flags;
} CONSOLE_SETHANDLEINFORMATION_MSG, *PCONSOLE_SETHANDLEINFORMATION_MSG;

typedef struct _CONSOLE_ADDALIAS_MSG {
    HANDLE ConsoleHandle;
    USHORT SourceLength;
    USHORT TargetLength;
    USHORT ExeLength;
    PVOID Source;
    PVOID Target;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_ADDALIAS_MSG, *PCONSOLE_ADDALIAS_MSG;

typedef struct _CONSOLE_GETALIAS_MSG {
    HANDLE ConsoleHandle;
    USHORT SourceLength;
    USHORT TargetLength;
    USHORT ExeLength;
    PVOID Source;
    PVOID Target;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETALIAS_MSG, *PCONSOLE_GETALIAS_MSG;

typedef struct _CONSOLE_GETALIASESLENGTH_MSG {
    HANDLE ConsoleHandle;
    USHORT ExeLength;
    PVOID Exe;
    DWORD AliasesLength;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETALIASESLENGTH_MSG, *PCONSOLE_GETALIASESLENGTH_MSG;

typedef struct _CONSOLE_GETALIASEXESLENGTH_MSG {
    HANDLE ConsoleHandle;
    DWORD AliasExesLength;
    BOOLEAN Unicode;
} CONSOLE_GETALIASEXESLENGTH_MSG, *PCONSOLE_GETALIASEXESLENGTH_MSG;

typedef struct _CONSOLE_GETALIASES_MSG {
    HANDLE ConsoleHandle;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
    DWORD AliasesBufferLength;
    PVOID AliasesBuffer;
} CONSOLE_GETALIASES_MSG, *PCONSOLE_GETALIASES_MSG;

typedef struct _CONSOLE_GETALIASEXES_MSG {
    HANDLE ConsoleHandle;
    DWORD AliasExesBufferLength;
    PVOID AliasExesBuffer;
    BOOLEAN Unicode;
} CONSOLE_GETALIASEXES_MSG, *PCONSOLE_GETALIASEXES_MSG;

typedef struct _CONSOLE_EXPUNGECOMMANDHISTORY_MSG {
    HANDLE ConsoleHandle;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_EXPUNGECOMMANDHISTORY_MSG, *PCONSOLE_EXPUNGECOMMANDHISTORY_MSG;

typedef struct _CONSOLE_SETNUMBEROFCOMMANDS_MSG {
    HANDLE ConsoleHandle;
    DWORD NumCommands;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_SETNUMBEROFCOMMANDS_MSG, *PCONSOLE_SETNUMBEROFCOMMANDS_MSG;

typedef struct _CONSOLE_GETCOMMANDHISTORYLENGTH_MSG {
    HANDLE ConsoleHandle;
    DWORD CommandHistoryLength;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETCOMMANDHISTORYLENGTH_MSG, *PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG;

typedef struct _CONSOLE_GETCOMMANDHISTORY_MSG {
    HANDLE ConsoleHandle;
    DWORD CommandBufferLength;
    PVOID CommandBuffer;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETCOMMANDHISTORY_MSG, *PCONSOLE_GETCOMMANDHISTORY_MSG;

typedef struct _CONSOLE_SETCOMMANDHISTORYMODE_MSG {
    HANDLE ConsoleHandle;
    DWORD Flags;
} CONSOLE_SETCOMMANDHISTORYMODE_MSG, *PCONSOLE_SETCOMMANDHISTORYMODE_MSG;

typedef struct _CONSOLE_VERIFYIOHANDLE_MSG {
    BOOL Valid;
    HANDLE ConsoleHandle;
    HANDLE Handle;
} CONSOLE_VERIFYIOHANDLE_MSG, *PCONSOLE_VERIFYIOHANDLE_MSG;

typedef struct _CONSOLE_ALLOC_MSG {
    IN PCONSOLE_INFO ConsoleInfo;
    IN DWORD TitleLength;
    IN LPWSTR Title;
    IN DWORD DesktopLength;
    IN LPWSTR Desktop;
    IN DWORD AppNameLength;
    IN LPWSTR AppName;
    IN DWORD CurDirLength;
    IN LPWSTR CurDir;
    IN LPTHREAD_START_ROUTINE CtrlRoutine;
    IN LPTHREAD_START_ROUTINE PropRoutine;
} CONSOLE_ALLOC_MSG, *PCONSOLE_ALLOC_MSG;

typedef struct _CONSOLE_FREE_MSG {
    IN HANDLE ConsoleHandle;
} CONSOLE_FREE_MSG, *PCONSOLE_FREE_MSG;

typedef struct _CONSOLE_ATTACH_MSG {
    IN DWORD ProcessId;
    IN PCONSOLE_INFO ConsoleInfo;
    IN LPTHREAD_START_ROUTINE CtrlRoutine;
    IN LPTHREAD_START_ROUTINE PropRoutine;
} CONSOLE_ATTACH_MSG, *PCONSOLE_ATTACH_MSG;

typedef struct _CONSOLE_GETTITLE_MSG {
    IN HANDLE ConsoleHandle;
    IN OUT DWORD TitleLength;
    OUT PVOID Title;
    BOOLEAN Unicode;
} CONSOLE_GETTITLE_MSG, *PCONSOLE_GETTITLE_MSG;

typedef struct _CONSOLE_SETTITLE_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD TitleLength;
    IN PVOID Title;
    BOOLEAN Unicode;
} CONSOLE_SETTITLE_MSG, *PCONSOLE_SETTITLE_MSG;

typedef struct _CONSOLE_INVALIDATERECT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    SMALL_RECT Rect;
} CONSOLE_INVALIDATERECT_MSG, *PCONSOLE_INVALIDATERECT_MSG;

typedef struct _CONSOLE_VDM_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD  iFunction;
    OUT BOOL Bool;
    IN OUT POINT Point;
    OUT RECT Rect;
} CONSOLE_VDM_MSG, *PCONSOLE_VDM_MSG;

typedef struct _CONSOLE_SETCURSOR_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN HCURSOR CursorHandle;
} CONSOLE_SETCURSOR_MSG, *PCONSOLE_SETCURSOR_MSG;

typedef struct _CONSOLE_SHOWCURSOR_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOL bShow;
    OUT int DisplayCount;
} CONSOLE_SHOWCURSOR_MSG, *PCONSOLE_SHOWCURSOR_MSG;

typedef struct _CONSOLE_MENUCONTROL_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN UINT CommandIdLow;
    IN UINT CommandIdHigh;
    OUT HMENU hMenu;
} CONSOLE_MENUCONTROL_MSG, *PCONSOLE_MENUCONTROL_MSG;

typedef struct _CONSOLE_SETPALETTE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN HPALETTE hPalette;
    IN UINT dwUsage;
} CONSOLE_SETPALETTE_MSG, *PCONSOLE_SETPALETTE_MSG;

typedef struct _CONSOLE_SETDISPLAYMODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD dwFlags;
    OUT COORD ScreenBufferDimensions;
    IN HANDLE hEvent;
} CONSOLE_SETDISPLAYMODE_MSG, *PCONSOLE_SETDISPLAYMODE_MSG;

typedef struct _CONSOLE_REGISTERVDM_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD RegisterFlags;
    IN HANDLE StartEvent;
    IN HANDLE EndEvent;
    IN HANDLE ErrorEvent;
    IN DWORD Reserved;
    OUT ULONG StateLength;
    OUT PVOID StateBuffer;
    IN LPWSTR VDMBufferSectionName;
    IN DWORD VDMBufferSectionNameLength;
    IN COORD VDMBufferSize;
    OUT PVOID VDMBuffer;
} CONSOLE_REGISTERVDM_MSG, *PCONSOLE_REGISTERVDM_MSG;

typedef struct _CONSOLE_GETHARDWARESTATE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT COORD Resolution;
    OUT COORD FontSize;
} CONSOLE_GETHARDWARESTATE_MSG, *PCONSOLE_GETHARDWARESTATE_MSG;

typedef struct _CONSOLE_SETHARDWARESTATE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD Resolution;
    IN COORD FontSize;
} CONSOLE_SETHARDWARESTATE_MSG, *PCONSOLE_SETHARDWARESTATE_MSG;

typedef struct _CONSOLE_GETDISPLAYMODE_MSG {
    IN HANDLE ConsoleHandle;
    OUT ULONG ModeFlags;
} CONSOLE_GETDISPLAYMODE_MSG, *PCONSOLE_GETDISPLAYMODE_MSG;

typedef struct _CONSOLE_GETCP_MSG {
    IN HANDLE ConsoleHandle;
    UINT wCodePageID;
    BOOL Output;
} CONSOLE_GETCP_MSG, *PCONSOLE_GETCP_MSG;

typedef struct _CONSOLE_SETCP_MSG {
    IN HANDLE ConsoleHandle;
    UINT wCodePageID;
    BOOL Output;
#if defined(FE_SB) // for Kernel32 Single Binary
    HANDLE hEvent;
#endif // FE_SB
} CONSOLE_SETCP_MSG, *PCONSOLE_SETCP_MSG;

typedef struct _CONSOLE_GETKEYBOARDLAYOUTNAME_MSG {
    IN HANDLE ConsoleHandle;
    union {
        WCHAR awchLayout[9];
        char achLayout[9];
    };
    BOOL bAnsi;
} CONSOLE_GETKEYBOARDLAYOUTNAME_MSG, *PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG;

typedef struct _CONSOLE_SETKEYSHORTCUTS_MSG {
    IN HANDLE ConsoleHandle;
    BOOL Set;
    BYTE ReserveKeys;
    DWORD NumAppKeys;
    LPAPPKEY AppKeys;
} CONSOLE_SETKEYSHORTCUTS_MSG, *PCONSOLE_SETKEYSHORTCUTS_MSG;

typedef struct _CONSOLE_SETMENUCLOSE_MSG {
    IN HANDLE ConsoleHandle;
    BOOL Enable;
} CONSOLE_SETMENUCLOSE_MSG, *PCONSOLE_SETMENUCLOSE_MSG;

typedef struct _CONSOLE_NOTIFYLASTCLOSE_MSG {
    IN HANDLE ConsoleHandle;
} CONSOLE_NOTIFYLASTCLOSE_MSG, *PCONSOLE_NOTIFYLASTCLOSE_MSG;

typedef struct _CONSOLE_CTRLEVENT_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD CtrlEvent;
    IN DWORD ProcessGroupId;
} CONSOLE_CTRLEVENT_MSG, *PCONSOLE_CTRLEVENT_MSG;

#if defined(FE_SB) // for Kernel32 Single Binary
typedef struct _CONSOLE_CHAR_TYPE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN COORD coordCheck;
    OUT DWORD dwType;
} CONSOLE_CHAR_TYPE_MSG, *PCONSOLE_CHAR_TYPE_MSG;

typedef struct _CONSOLE_LOCAL_EUDC_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN WORD CodePoint;
    IN COORD FontSize;
    IN PCHAR FontFace;
} CONSOLE_LOCAL_EUDC_MSG, *PCONSOLE_LOCAL_EUDC_MSG;

typedef struct _CONSOLE_CURSOR_MODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN BOOL Blink;
    IN BOOL DBEnable;
} CONSOLE_CURSOR_MODE_MSG, *PCONSOLE_CURSOR_MODE_MSG;

typedef struct _CONSOLE_REGISTEROS2_MSG {
    IN HANDLE ConsoleHandle;
    IN BOOL fOs2Register;
} CONSOLE_REGISTEROS2_MSG, *PCONSOLE_REGISTEROS2_MSG;

typedef struct _CONSOLE_SETOS2OEMFORMAT_MSG {
    IN HANDLE ConsoleHandle;
    IN BOOL fOs2OemFormat;
} CONSOLE_SETOS2OEMFORMAT_MSG, *PCONSOLE_SETOS2OEMFORMAT_MSG;

#if defined(FE_IME)
typedef struct _CONSOLE_NLS_MODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN OUT BOOL Ready;
    IN DWORD NlsMode;
    IN HANDLE hEvent;
} CONSOLE_NLS_MODE_MSG, *PCONSOLE_NLS_MODE_MSG;

typedef struct _CONSOLE_REGISTER_CONSOLEIME_MSG {
    IN HANDLE ConsoleHandle;
    IN HWND hWndConsoleIME;
    IN DWORD dwConsoleIMEThreadId;
    IN DWORD DesktopLength;
    IN LPWSTR Desktop;
    OUT DWORD dwConsoleThreadId;
} CONSOLE_REGISTER_CONSOLEIME_MSG, *PCONSOLE_REGISTER_CONSOLEIME_MSG;

typedef struct _CONSOLE_UNREGISTER_CONSOLEIME_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD dwConsoleIMEThreadId;
} CONSOLE_UNREGISTER_CONSOLEIME_MSG, *PCONSOLE_UNREGISTER_CONSOLEIME_MSG;
#endif // FE_IME

#endif // FE_SB

typedef struct _CONSOLE_GETCONSOLEWINDOW_MSG {
    IN HANDLE ConsoleHandle;
    OUT HWND hwnd;
} CONSOLE_GETCONSOLEWINDOW_MSG, *PCONSOLE_GETCONSOLEWINDOW_MSG;

typedef struct _CONSOLE_LANGID_MSG {
    IN HANDLE ConsoleHandle;
    OUT LANGID LangId;
} CONSOLE_LANGID_MSG, *PCONSOLE_LANGID_MSG;

typedef struct _CONSOLE_GETPROCESSLIST_MSG {
    IN HANDLE ConsoleHandle;
    IN OUT DWORD dwProcessCount;
    OUT LPDWORD lpdwProcessList;
} CONSOLE_GETCONSOLEPROCESSLIST_MSG, *PCONSOLE_GETCONSOLEPROCESSLIST_MSG;

typedef struct _CONSOLE_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        CONSOLE_OPENCONSOLE_MSG OpenConsole;
        CONSOLE_GETCONSOLEINPUT_MSG GetConsoleInput;
        CONSOLE_WRITECONSOLEINPUT_MSG WriteConsoleInput;
        CONSOLE_READCONSOLEOUTPUT_MSG ReadConsoleOutput;
        CONSOLE_WRITECONSOLEOUTPUT_MSG WriteConsoleOutput;
        CONSOLE_READCONSOLEOUTPUTSTRING_MSG ReadConsoleOutputString;
        CONSOLE_WRITECONSOLEOUTPUTSTRING_MSG WriteConsoleOutputString;
        CONSOLE_FILLCONSOLEOUTPUT_MSG FillConsoleOutput;
        CONSOLE_MODE_MSG GetConsoleMode;
        CONSOLE_GETNUMBEROFFONTS_MSG GetNumberOfConsoleFonts;
        CONSOLE_GETNUMBEROFINPUTEVENTS_MSG GetNumberOfConsoleInputEvents;
        CONSOLE_GETSCREENBUFFERINFO_MSG GetConsoleScreenBufferInfo;
        CONSOLE_GETCURSORINFO_MSG GetConsoleCursorInfo;
        CONSOLE_GETMOUSEINFO_MSG GetConsoleMouseInfo;
        CONSOLE_GETFONTINFO_MSG GetConsoleFontInfo;
        CONSOLE_GETFONTSIZE_MSG GetConsoleFontSize;
        CONSOLE_GETCURRENTFONT_MSG GetCurrentConsoleFont;
        CONSOLE_MODE_MSG SetConsoleMode;
        CONSOLE_SETACTIVESCREENBUFFER_MSG SetConsoleActiveScreenBuffer;
        CONSOLE_FLUSHINPUTBUFFER_MSG FlushConsoleInputBuffer;
        CONSOLE_GETLARGESTWINDOWSIZE_MSG GetLargestConsoleWindowSize;
        CONSOLE_SETSCREENBUFFERSIZE_MSG SetConsoleScreenBufferSize;
        CONSOLE_SETCURSORPOSITION_MSG SetConsoleCursorPosition;
        CONSOLE_SETCURSORINFO_MSG SetConsoleCursorInfo;
        CONSOLE_SETWINDOWINFO_MSG SetConsoleWindowInfo;
        CONSOLE_SCROLLSCREENBUFFER_MSG ScrollConsoleScreenBuffer;
        CONSOLE_SETTEXTATTRIBUTE_MSG SetConsoleTextAttribute;
        CONSOLE_SETFONT_MSG SetConsoleFont;
        CONSOLE_SETICON_MSG SetConsoleIcon;
        CONSOLE_READCONSOLE_MSG ReadConsole;
        CONSOLE_WRITECONSOLE_MSG WriteConsole;
        CONSOLE_DUPHANDLE_MSG DuplicateHandle;
        CONSOLE_GETHANDLEINFORMATION_MSG GetHandleInformation;
        CONSOLE_SETHANDLEINFORMATION_MSG SetHandleInformation;
        CONSOLE_CLOSEHANDLE_MSG CloseHandle;
        CONSOLE_VERIFYIOHANDLE_MSG VerifyConsoleIoHandle;
        CONSOLE_ALLOC_MSG AllocConsole;
        CONSOLE_FREE_MSG FreeConsole;
        CONSOLE_GETTITLE_MSG GetConsoleTitle;
        CONSOLE_SETTITLE_MSG SetConsoleTitle;
        CONSOLE_CREATESCREENBUFFER_MSG CreateConsoleScreenBuffer;
        CONSOLE_INVALIDATERECT_MSG InvalidateConsoleBitmapRect;
        CONSOLE_VDM_MSG VDMConsoleOperation;
        CONSOLE_SETCURSOR_MSG SetConsoleCursor;
        CONSOLE_SHOWCURSOR_MSG ShowConsoleCursor;
        CONSOLE_MENUCONTROL_MSG ConsoleMenuControl;
        CONSOLE_SETPALETTE_MSG SetConsolePalette;
        CONSOLE_SETDISPLAYMODE_MSG SetConsoleDisplayMode;
        CONSOLE_REGISTERVDM_MSG RegisterConsoleVDM;
        CONSOLE_GETHARDWARESTATE_MSG GetConsoleHardwareState;
        CONSOLE_SETHARDWARESTATE_MSG SetConsoleHardwareState;
        CONSOLE_GETDISPLAYMODE_MSG GetConsoleDisplayMode;
        CONSOLE_ADDALIAS_MSG AddConsoleAliasW;
        CONSOLE_GETALIAS_MSG GetConsoleAliasW;
        CONSOLE_GETALIASESLENGTH_MSG GetConsoleAliasesLengthW;
        CONSOLE_GETALIASEXESLENGTH_MSG GetConsoleAliasExesLengthW;
        CONSOLE_GETALIASES_MSG GetConsoleAliasesW;
        CONSOLE_GETALIASEXES_MSG GetConsoleAliasExesW;
        CONSOLE_EXPUNGECOMMANDHISTORY_MSG ExpungeConsoleCommandHistoryW;
        CONSOLE_SETNUMBEROFCOMMANDS_MSG SetConsoleNumberOfCommandsW;
        CONSOLE_GETCOMMANDHISTORYLENGTH_MSG GetConsoleCommandHistoryLengthW;
        CONSOLE_GETCOMMANDHISTORY_MSG GetConsoleCommandHistoryW;
        CONSOLE_SETCOMMANDHISTORYMODE_MSG SetConsoleCommandHistoryMode;
        CONSOLE_GETCP_MSG GetConsoleCP;
        CONSOLE_SETCP_MSG SetConsoleCP;
        CONSOLE_SETKEYSHORTCUTS_MSG SetConsoleKeyShortcuts;
        CONSOLE_SETMENUCLOSE_MSG SetConsoleMenuClose;
        CONSOLE_NOTIFYLASTCLOSE_MSG SetLastConsoleEventActive;
        CONSOLE_CTRLEVENT_MSG GenerateConsoleCtrlEvent;
        CONSOLE_GETKEYBOARDLAYOUTNAME_MSG GetKeyboardLayoutName;
        CONSOLE_GETCONSOLEWINDOW_MSG GetConsoleWindow;
#if defined(FE_SB) // for Kernel32 Single Binary
        CONSOLE_CHAR_TYPE_MSG GetConsoleCharType;
        CONSOLE_LOCAL_EUDC_MSG SetConsoleLocalEUDC;
        CONSOLE_CURSOR_MODE_MSG SetConsoleCursorMode;
        CONSOLE_CURSOR_MODE_MSG GetConsoleCursorMode;
        CONSOLE_REGISTEROS2_MSG RegisterConsoleOS2;
        CONSOLE_SETOS2OEMFORMAT_MSG SetConsoleOS2OemFormat;
#if defined(FE_IME)
        CONSOLE_NLS_MODE_MSG GetConsoleNlsMode;
        CONSOLE_NLS_MODE_MSG SetConsoleNlsMode;
        CONSOLE_REGISTER_CONSOLEIME_MSG RegisterConsoleIME;
        CONSOLE_UNREGISTER_CONSOLEIME_MSG UnregisterConsoleIME;
#endif // FE_IME
#endif // FE_SB
        CONSOLE_LANGID_MSG GetConsoleLangId;
        CONSOLE_ATTACH_MSG AttachConsole;
        CONSOLE_GETSELECTIONINFO_MSG GetConsoleSelectionInfo;
        CONSOLE_GETCONSOLEPROCESSLIST_MSG GetConsoleProcessList;
    } u;
} CONSOLE_API_MSG, *PCONSOLE_API_MSG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\conime.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    conime.h

Abstract:

    This module contains the internal structures and definitions used
    by the console IME.

Author:

    v-HirShi Jul.4.1995

Revision History:

--*/


#define CONSOLEIME_EVENT  (L"ConsoleIME_StartUp_Event")

typedef struct _CONIME_CANDMESSAGE {
    DWORD AttrOff;
    WCHAR String[];
} CONIME_CANDMESSAGE, *LPCONIME_CANDMESSAGE;

typedef struct _CONIME_UIMESSAGE {
    WCHAR String[];
} CONIME_UIMESSAGE, *LPCONIME_UIMESSAGE;

typedef struct _CONIME_UICOMPMESSAGE {
    DWORD dwSize;
    DWORD dwCompAttrLen;
    DWORD dwCompAttrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwResultStrLen;
    DWORD dwResultStrOffset;
    WORD  CompAttrColor[8];
} CONIME_UICOMPMESSAGE, *LPCONIME_UICOMPMESSAGE;

#define VIEW_LEFT  0
#define VIEW_RIGHT 1
#define MAXSTATUSCOL 160
typedef struct _CONIME_UIMODEINFO {
    DWORD ModeStringLen;
    BOOL Position;
    CHAR_INFO ModeString[MAXSTATUSCOL];
} CONIME_UIMODEINFO, *LPCONIME_UIMODEINFO;


//
// This is PCOPYDATASTRUCT->dwData values for WM_COPYDAT message consrv from conime.
//
#define CI_CONIMECOMPOSITION    0x4B425930
#define CI_CONIMEMODEINFO       0x4B425931
#define CI_CONIMESYSINFO        0x4B425932
#define CI_CONIMECANDINFO       0x4B425935
#define CI_CONIMEPROPERTYINFO   0x4B425936



//
// This message values for send/post message conime from consrv
//
#define CONIME_CREATE                   (WM_USER+0)
#define CONIME_DESTROY                  (WM_USER+1)
#define CONIME_SETFOCUS                 (WM_USER+2)
#define CONIME_KILLFOCUS                (WM_USER+3)
#define CONIME_HOTKEY                   (WM_USER+4)
#define CONIME_GET_NLSMODE              (WM_USER+5)
#define CONIME_SET_NLSMODE              (WM_USER+6)
#define CONIME_NOTIFY_SCREENBUFFERSIZE  (WM_USER+7)
#define CONIME_NOTIFY_VK_KANA           (WM_USER+8)
#define CONIME_INPUTLANGCHANGE          (WM_USER+9)
#define CONIME_NOTIFY_CODEPAGE          (WM_USER+10)
#define CONIME_INPUTLANGCHANGEREQUEST   (WM_USER+11)
#define CONIME_INPUTLANGCHANGEREQUESTFORWARD   (WM_USER+12)
#define CONIME_INPUTLANGCHANGEREQUESTBACKWARD   (WM_USER+13)
#define CONIME_KEYDATA                  (WM_USER+1024)

//
// This message values for set direction of conime langchange
//
#define CONIME_DIRECT                    0
#define CONIME_FORWARD                   1
#define CONIME_BACKWARD                 -1

//
// This message value is for send/post message to consrv
//
#define CM_CONIME_KL_ACTIVATE           (WM_USER+15)

#define CONIME_SENDMSG_TIMEOUT          (3 * 1000)    // Wait for 3sec.




//
// Default composition color attributes
//
#define DEFAULT_COMP_ENTERED            \
    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
#define DEFAULT_COMP_ALREADY_CONVERTED  \
    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED |                        \
     BACKGROUND_BLUE )
#define DEFAULT_COMP_CONVERSION         \
    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
#define DEFAULT_COMP_YET_CONVERTED      \
    (FOREGROUND_BLUE |                                                            \
     BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
#define DEFAULT_COMP_INPUT_ERROR        \
    (                                     FOREGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\imefull.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   imefull.c
//
//  PURPOSE:   Console IME control.
//
//  PLATFORMS: Windows NT-J 3.51
//
//  FUNCTIONS:
//    ImeOpenClose() - calls initialization functions, processes message loop
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//
//  COMMENTS:
//

#include "precomp.h"
#pragma hdrstop

//**********************************************************************
//
// IMEOpenClose()
//
// This routines calls IMM API to open or close IME.
//
//**********************************************************************

VOID ImeOpenClose( HWND hWnd, BOOL fFlag )
{
    HIMC            hIMC;

    //
    // If fFlag is true then open IME; otherwise close it.
    //

    if ( !( hIMC = ImmGetContext( hWnd ) ) )
        return;

    ImmSetOpenStatus( hIMC, fFlag );

    ImmReleaseContext( hWnd, hIMC );

}

#ifdef DEBUG_MODE
/************************************************************************
*
*   VirtualKeyHandler - WM_KEYDOWN handler
*
*
*   INPUT:  HWND - handle to the window for repainting output.
*           UINT - virtual key code.
*
************************************************************************/

VOID VirtualKeyHandler( HWND hWnd, UINT wParam, UINT lParam )
{
    PCONSOLE_TABLE ConTbl;
    int i;
    static int delta ;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if ( ConTbl->fInCandidate ||
         ( ConTbl->fInComposition && !MoveCaret( hWnd ) )
       )
        return;

    switch( wParam )
    {
    case VK_HOME:   // beginning of line
        xPos = FIRSTCOL;
        break;

    case VK_END:    // end of line
        xPos = xPosLast ;
        break;

    case VK_RIGHT:
        if ( IsUnicodeFullWidth( ConvertLine[xPos] ) ){
            if (xPos > xPosLast - 2 ) break;  //last character don't move
            xPos += 2;                     //skip 2 for DB Character
        }
        else
            xPos = min( xPos+1, xPosLast );
        break;

    case VK_LEFT:

        xPos = max( xPos-1, FIRSTCOL );

        if ( IsUnicodeFullWidth( ConvertLine[xPos] ) )
            xPos--;
        break;

    case VK_BACK:   // backspace

        if ( xPos > FIRSTCOL ) {
            delta = 1 ;

            //
            // DB Character so backup one more to allign on boundary
            //
            if ( IsUnicodeFullWidth( ConvertLine[xPos] ) )
                delta = 2 ;
            //
            // Fall Through to VK_DELETE to adjust row
            //
            xPos -= delta ;
            for ( i = xPos ; i < xPosLast+2 ; i++) {
                ConvertLine[i] = ConvertLine[i+delta] ;
                ConvertLineAtr[i] = ConvertLineAtr[i+delta] ;
            }
            xPosLast -= delta ;
        }
        else     //FIRST COLUMN  don't backup -- this would change for wrapping
           break;
        goto Repaint ;
        break;
    case VK_DELETE:
        if ( !IsUnicodeFullWidth( ConvertLine[xPos] ) ) {

            //
            // Move rest of line left by one, then blank out last character
            //

            for ( i = xPos; i < xPosLast; i++ ) {
                ConvertLine[i] = ConvertLine[i+1];
                ConvertLineAtr[i] = ConvertLineAtr[i+1];
            }
            xPosLast-- ;

        } else {

            //
            // Move line left by two bytes, blank out last two bytes
            //

            for ( i = xPos; i < xPosLast; i++ ) {
                ConvertLine[i] = ConvertLine[i+2];
                ConvertLineAtr[i] = ConvertLineAtr[i+2];
            }
            xPosLast -= 2 ;
        }

        goto Repaint ;
        break;

    case VK_TAB:    // tab  -- tabs are column allignment not character
        {
         int xTabMax = xPos + TABSTOP;
         int xPosPrev;

         do {
             xPosPrev = xPos;
            if ( IsUnicodeFullWidth( ConvertLine[xPos] ) ){
                if (xPos > xPosLast - 2 ) break;  //last character don't move
                xPos += 2;                     //skip 2 for DB Character
            }
            else
                xPos = min( xPos+1, xPosLast );

         } while ( (xPos % TABSTOP) &&
                   (xPos < xTabMax) &&
                   (xPos != xPosPrev));

        }
        goto Repaint ;
        break;

    case VK_RETURN: // linefeed
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = ' ' ;
            ConvertLineAtr[i] = 0 ;
        }
        xPos = FIRSTCOL;
        xPosLast = FIRSTCOL;
Repaint:
        {
        //
        // Repaint the entire line
        //
        HDC hdc;

        hdc = GetDC( hWnd );
        HideCaret( hWnd );
        DisplayConvInformation( hWnd ) ;
        ReleaseDC( hWnd, hdc );
        }
        break;
    }
    ResetCaret( hWnd );
}
#endif

/************************************************************************
*
*   CharHandler - WM_CHAR handler
*
************************************************************************/

VOID CharHandlerFromConsole( HWND hWnd, UINT Message, ULONG wParam, ULONG lParam)
{
    UINT TmpMessage ;
    DWORD dwImmRet ;
    UINT uVKey ;
    UINT wParamSave ;

    if (HIWORD(wParam) == 0){
        wParamSave = wParam ;
    }
    else {
        if (Message == WM_KEYDOWN   +CONIME_KEYDATA || Message == WM_KEYUP   +CONIME_KEYDATA ||
            Message == WM_SYSKEYDOWN+CONIME_KEYDATA || Message == WM_SYSKEYUP+CONIME_KEYDATA){
            wParamSave = 0 ;
        }
        else if(HIWORD(wParam) > 0x00ff){
            WCHAR WideChar ;
            UCHAR MultiChar ;
            WideChar = HIWORD(wParam) ;
            WideCharToMultiByte(CP_OEMCP, 0, &WideChar, 1, &MultiChar, 1, NULL, NULL) ;
            wParamSave = MultiChar ;
        }
        else {
            wParamSave = HIWORD(wParam) ;
        }
    }

    if (HIWORD(lParam) & KF_UP) // KEY_TRANSITION_UP
        TmpMessage = WM_KEYUP ;
    else
        TmpMessage = WM_KEYDOWN ;


    // Return Value of ClientImmProcessKeyConsoleIME
    // IPHK_HOTKEY          1   - the vkey is IME hotkey
    // IPHK_PROCESSBYIME    2   - the vkey is the one that the IME is waiting for
    // IPHK_CHECKCTRL       4   - not used by NT IME
    dwImmRet = ImmCallImeConsoleIME(hWnd, TmpMessage, wParam, lParam, &uVKey) ;

    if ( dwImmRet & IPHK_HOTKEY ) {
    //
    // if this vkey is the IME hotkey, we won't pass
    // it to application or hook procedure.
    // This is what Win95 does. [takaok]
    //
       return ;
    }
    else if (dwImmRet & IPHK_PROCESSBYIME) {
        BOOL Status ;

//3.51
//      uVKey = (wParamSave<<8) | uVKey ;
//      Status = ClientImmTranslateMessageMain( hWnd,uVKey,lParam);

        Status = ImmTranslateMessage(hWnd, TmpMessage, wParam, lParam);


    }
    else if (dwImmRet & IPHK_CHECKCTRL) {
        CharHandlerToConsole( hWnd, Message-CONIME_KEYDATA, wParamSave, lParam);
    }
    else
    {
        if ((Message == WM_CHAR   +CONIME_KEYDATA)||
            (Message == WM_SYSCHAR+CONIME_KEYDATA)) {
            CharHandlerToConsole( hWnd, Message-CONIME_KEYDATA, wParamSave, lParam);
        }
        else
            CharHandlerToConsole( hWnd, Message-CONIME_KEYDATA, wParam, lParam);
    }

}

VOID CharHandlerToConsole( HWND hWnd, UINT Message, ULONG wParam, ULONG lParam)
{
    PCONSOLE_TABLE ConTbl;
    WORD  ch ;
    int   NumByte = 0 ;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if (HIWORD(lParam) & KF_UP ) {
        PostMessage( ConTbl->hWndCon,
                     Message+CONIME_KEYDATA,
                     wParam,
                     lParam) ;
        return ;
    }

    ch = LOWORD(wParam) ;
    if ((ch < UNICODE_SPACE) ||
        ((ch >= UNICODE_SPACE) &&
        ((Message == WM_KEYDOWN) || (Message == WM_SYSKEYDOWN) ))) {
#ifdef DEBUG_MODE
        VirtualKeyHandler( hWnd, wParam ,lParam) ;
#endif
        PostMessage( ConTbl->hWndCon,
                     Message+CONIME_KEYDATA,
                     wParam,
                     lParam) ;
        return ;
    }

#ifdef DEBUG_MODE
    StoreChar( hWnd, ch, 0);
#endif

    PostMessage( ConTbl->hWndCon,
                 Message+CONIME_KEYDATA,
                 wParam,          //*Dest,
                 lParam) ;
}

#ifdef DEBUG_MODE
//**********************************************************************
//
// void ImeUIMove()
//
// Handler routine of WM_MOVE message.
//
//*********************************************************************

VOID ImeUIMoveCandWin( HWND hwnd )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if ( ConTbl->fInCandidate )
    {
        POINT           point;          // Storage for caret position.
        int             i;              // loop counter.
        int             NumCandWin;     // Storage for num of cand win.
        RECT            rect;           // Storage for client rect.

        //
        // If current IME state is in chosing candidate, here we
        // move all candidate windows, if any, to the appropriate
        // position based on the parent window's position.
        //

        NumCandWin = 0;

        GetCaretPos( (LPPOINT)&point );
        ClientToScreen( hwnd, (LPPOINT)&point );

        for ( i = 0; i < MAX_LISTCAND ; i++ )
        {
            if ( ConTbl->hListCand[ i ] )
            {
                GetClientRect( ConTbl->hListCand[ i ], &rect );

                MoveWindow( ConTbl->hListCand[ i ],
                            point.x + X_INDENT * NumCandWin,
                            point.y + Y_INDENT * NumCandWin + cyMetrics,
                            ( rect.right - rect.left + 1 ),
                            ( rect.bottom - rect.top + 1 ), TRUE );

                NumCandWin++;
            }
        }
    }
}
#endif

#ifdef DEBUG_MODE
/************************************************************************
*
*   ResetCaret - Reset caret shape to match input mode (overtype/insert)
*
************************************************************************/

VOID ResetCaret( HWND hWnd )
{

    HideCaret( hWnd );
    DestroyCaret();
    CreateCaret( hWnd,
         NULL,
         IsUnicodeFullWidth( ConvertLine[xPos] ) ?
           CaretWidth*2 : CaretWidth,
         cyMetrics );
    SetCaretPos( xPos * cxMetrics, 0 );
    ShowCaret( hWnd );

}

//**********************************************************************
//
// BOOL MoveCaret()
//
//**********************************************************************

BOOL MoveCaret( HWND hwnd )
{
    HIMC        hIMC;
    BOOL        retVal = TRUE;

    if ( !( hIMC = ImmGetContext( hwnd ) ) )
    return retVal;

    if ( ImmGetCompositionString( hIMC, GCS_CURSORPOS,
                  (void FAR *)NULL, 0 ) )
    retVal = FALSE;

    ImmReleaseContext( hwnd, hIMC );

    return retVal;
}
#endif

#ifdef DEBUG_MODE
/************************************************************************
*
*   StoreChar - Stores one character into text buffer and advances
*               cursor
*
************************************************************************/

VOID StoreChar( HWND hWnd, WORD ch, UCHAR atr )
{
    HDC hdc;

    if ( xPos >= CVMAX-3 )
        return;

    //
    // Store input character at current caret position
    //
    ConvertLine[xPos] = ch;
    ConvertLineAtr[xPos] = atr;
    xPos++ ;
    xPosLast = max(xPosLast,xPos) ;

    //
    // Repaint the entire line
    //
    hdc = GetDC( hWnd );
    HideCaret( hWnd );
    DisplayConvInformation( hWnd ) ;
    ResetCaret( hWnd );
    ReleaseDC( hWnd, hdc );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\conime\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winbasep.h"
#include "winconp.h"
#include "winuserp.h"
#include "immp.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ime.h>
#include "conapi.h"
#include "conime.h"
#include "conimep.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\foncache.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    foncache.h

Abstract:

        This file is definition of fullscreen dll

Author:

    Kazuhiko  Matsubara  21-June-1994

Revision History:

Notes:

--*/



typedef struct _FONT_IMAGE {
    LIST_ENTRY ImageList;                            // link list of other font size.
    COORD FontSize;
    PBYTE ImageBits;                                 // WORD aligned.
} FONT_IMAGE, *PFONT_IMAGE;

typedef struct _FONT_LOW_OFFSET {
    PFONT_IMAGE FontOffsetLow[256];                  // array is low order of Unicode <i.e LOBYTE(Unicode)>
} FONT_LOW_OFFSET, *PFONT_LOW_OFFSET;

typedef struct _FONT_HIGHLOW_OFFSET {
    PFONT_LOW_OFFSET  FontOffsetHighLow[16];         // array is high (3-0bit) order of Unicode <i.e LO4BIT(HIBYTE(Unicode))>
} FONT_HIGHLOW_OFFSET, *PFONT_HIGHLOW_OFFSET;

typedef struct _FONT_HIGHHIGH_OFFSET {
    PFONT_HIGHLOW_OFFSET FontOffsetHighHigh[16];     // array is high (7-4bit) order of Unicode <i.e HI4BIT(HIBYTE(Unicode))>
} FONT_HIGHHIGH_OFFSET, *PFONT_HIGHHIGH_OFFSET;



typedef struct _FONT_CACHE_INFORMATION {
    ULONG  FullScreenFontIndex;
    COORD  FullScreenFontSize;
    PBYTE  BaseImageBits;
    FONT_HIGHHIGH_OFFSET FontTable;
} FONT_CACHE_INFORMATION, *PFONT_CACHE_INFORMATION;


#define FONT_MATCHED   1
#define FONT_STRETCHED 2

#define ADD_IMAGE     1
#define REPLACE_IMAGE 2

#define BITMAP_BITS_BYTE_ALIGN   8                   // BYTE align is 8 bit
#define BITMAP_BITS_WORD_ALIGN  16                   // WORD align is 16 bit
#define BITMAP_ARRAY_BYTE  3                         // BYTE array is 8 bit  (shift count = 3)


typedef struct _FONT_CACHE_AREA {
    PFONT_IMAGE FontImage;
    DWORD       Area;
} FONT_CACHE_AREA, *PFONT_CACHE_AREA;


#define BITMAP_PLANES      1
#define BITMAP_BITS_PIXEL  1


#define BYTE_ALIGN  sizeof(BYTE)
#define WORD_ALIGN  sizeof(WORD)

//
// Font cache manager
//
ULONG
CreateFontCache(
    OUT PFONT_CACHE_INFORMATION *FontCache
    );

ULONG
DestroyFontCache(
    IN PFONT_CACHE_INFORMATION FontCache
    );

ULONG
GetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    );

ULONG
GetStretchedFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    );

ULONG
GetFontImagePointer(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    OUT PFONT_IMAGE *FontImage
    );

ULONG
SetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    IN CONST VOID *ImageBits
    );

DWORD
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN DWORD dwAlign
    );

NTSTATUS
GetExpandFontImage(
    PFONT_CACHE_INFORMATION FontCache,
    WCHAR wChar,
    COORD InputFontSize,
    COORD OutputFontSize,
    PWORD OutputFontImage
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\convarea.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    convarea.h

Abstract:

    This module contains the internal structures and definitions used
    by the conversion area.

Author:

    KazuM Mar.8,1993

Revision History:

--*/

#ifndef _CONVAREA_H_
#define _CONVAREA_H_

#if defined(FE_IME)
typedef struct _CONVERSION_AREA_BUFFER_INFO {
    COORD      coordCaBuffer;
    SMALL_RECT rcViewCaWindow;
    COORD      coordConView;
} CONVERSION_AREA_BUFFER_INFO,*PCONVERSION_AREA_BUFFER_INFO;



typedef struct _CONVERSIONAREA_INFORMATION {
    DWORD  ConversionAreaMode;
        #define CA_HIDDEN      0x01        // Set:Hidden    Reset:Active
        #define CA_STATUS_LINE 0x04
        #define CA_HIDE_FOR_SCROLL              0x10

    CONVERSION_AREA_BUFFER_INFO CaInfo;
    struct _SCREEN_INFORMATION *ScreenBuffer;

    struct _CONVERSIONAREA_INFORMATION *ConvAreaNext;
} CONVERSIONAREA_INFORMATION, *PCONVERSIONAREA_INFORMATION;



typedef struct _CONSOLE_IME_INFORMATION {
    DWORD ScrollFlag;
        #define HIDE_FOR_SCROLL               0x01
    LONG ScrollWaitTimeout;
        #define SCROLL_WAIT_TIMER         2
    LONG ScrollWaitCountDown;

    //
    // Composition String information
    //
    LPCONIME_UICOMPMESSAGE CompStrData;
    BOOLEAN SavedCursorVisible;  // whether cursor is visible (set by user)

    //
    // IME status/mode information
    //
    PCONVERSIONAREA_INFORMATION ConvAreaMode;
    PCONVERSIONAREA_INFORMATION ConvAreaSystem;
    DWORD  ConvAreaModePosition;
        // VIEW_LEFT  0
        // VIEW_RIGHT 1


    //
    // IME compositon string information
    //
    ULONG NumberOfConvAreaCompStr;
    PCONVERSIONAREA_INFORMATION *ConvAreaCompStr;

    //
    // Root of conversion area information
    //
    PCONVERSIONAREA_INFORMATION ConvAreaRoot;

} CONSOLE_IME_INFORMATION, *PCONSOLE_IME_INFORMATION;

#endif // FE_IME

#endif  // _CONVAREA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\eudc.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    eudc.h

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/

typedef struct _EUDC_INFORMATION {
    BOOL LocalVDMEudcMode;
    BOOL LocalKeisenEudcMode;

    HDC hDCLocalEudc;                   // Double colored DBCS hDC
    HBITMAP hBmpLocalEudc;

    PVOID EudcFontCacheInformation;     // Same as PFONT_CACHE_INFORMATION

    COORD LocalEudcSize;

    INT EudcRangeSize;
        #define EUDC_RANGE_SIZE 16
    WCHAR EudcRange[EUDC_RANGE_SIZE];
} EUDC_INFORMATION, *PEUDC_INFORMATION;


NTSTATUS
CreateEUDC(
    PCONSOLE_INFORMATION Console
    );

VOID
DeleteEUDC(
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
RegisterLocalEUDC(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN PCHAR FontFace
    );

VOID
FreeLocalEUDC(
    IN PCONSOLE_INFORMATION Console
    );

VOID
GetFitLocalEUDCFont(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar
    );

BOOL
IsEudcRange(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR ch
    );

BOOL
CheckEudcRangeInString(
    IN PCONSOLE_INFORMATION Console,
    IN  PWCHAR string,
    IN  SHORT  len,
    OUT SHORT  *find_pos
    );

INT
GetSystemEUDCRangeW(
    WORD  *pwEUDCCharTable,
    UINT   cjSize
    );

WORD
ConvertStringToHex(
    LPWSTR lpch,
    LPWSTR *endptr
    );

WORD
ConvertStringToDec(
    LPWSTR lpch,
    LPWSTR *endptr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\output.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    output.h

Abstract:

    This module contains the internal structures and definitions used
    by the output (screen) component of the NT console subsystem.

Author:

    Therese Stowell (thereses) 12-Nov-1990

Revision History:

--*/

// the characters of one row of screen buffer
// we keep the following values so that we don't write
// more pixels to the screen than we have to:
// left is initialized to screenbuffer width.  right is
// initialized to zero.
//
//      [     foo.bar    12-12-61                       ]
//       ^    ^                  ^                     ^
//       |    |                  |                     |
//     Chars Left               Right                end of Chars buffer

typedef struct _CHAR_ROW {
    SHORT Right;            // one past rightmost bound of chars in Chars array (array will be full width)
    SHORT OldRight;         // old one past rightmost bound of chars in Chars array (array will be full width)
    SHORT Left;             // leftmost bound of chars in Chars array (array will be full width)
    SHORT OldLeft;          // old leftmost bound of chars in Chars array (array will be full width)
    PWCHAR Chars;            // all chars in row up to last non-space char
#if defined(FE_SB)
    PBYTE KAttrs;            // all DBCS lead & trail bit in row
        #define ATTR_LEADING_BYTE  0x01
        #define ATTR_TRAILING_BYTE 0x02
        #define ATTR_DBCSSBCS_BYTE 0x03
        #define ATTR_SEPARATE_BYTE 0x10
        #define ATTR_EUDCFLAG_BYTE 0x20
#endif
} CHAR_ROW, *PCHAR_ROW;

// run-length encoded data structure for attributes

typedef struct _ATTR_PAIR {
    SHORT Length;            // number of times attribute appears
    WORD Attr;              // attribute
} ATTR_PAIR, *PATTR_PAIR;

// the attributes of one row of screen buffer

typedef struct _ATTR_ROW {
    SHORT Length;            // length of attr pair array
    ATTR_PAIR AttrPair;     // use this if only one pair
    PATTR_PAIR Attrs;       // attr pair array
} ATTR_ROW, *PATTR_ROW;

// information associated with one row of screen buffer

typedef struct _ROW {
    CHAR_ROW CharRow;
    ATTR_ROW AttrRow;
} ROW, *PROW;

#if defined(FE_SB)
typedef struct _DBCS_SCREEN_BUFFER {
    /*
     * all DBCS lead & trail bit buffer
     */
    PBYTE KAttrRows;
    /*
     * Temporary buffer for translate Unicode<--ASCII.
     *
     * Used as follows routine:
     *   WriteOutputString
     *   WriteRegionToScreen
     *   DoWriteConsole
     */
    PWCHAR TransBufferCharacter;
    PBYTE  TransBufferAttribute;
    /*
     * Used as follows routine:
     *   SrvWriteConsole
     */
    PWCHAR TransWriteConsole;
} DBCS_SCREEN_BUFFER, *PDBCS_SCREEN_BUFFER;
#endif

typedef struct _TEXT_BUFFER_FONT_INFO {
    struct _TEXT_BUFFER_FONT_INFO *NextTextBufferFont;
    COORD FontSize;     // Desired size.  Pixels (x,y) or Points (0, -p)
    DWORD FontNumber;   // index into fontinfo[]  -  sometimes out of date
    WCHAR FaceName[LF_FACESIZE];
    LONG Weight;
    BYTE Family;
    UINT FontCodePage;  // Code page for this font
} TEXT_BUFFER_FONT_INFO, *PTEXT_BUFFER_FONT_INFO;

typedef struct _TEXT_BUFFER_INFO {
    PROW Rows;
    PWCHAR TextRows;
    SHORT FirstRow;  // indexes top row (not necessarily 0)
    BOOLEAN CursorMoved;
    BOOLEAN CursorVisible;  // whether cursor is visible (set by user)
    BOOLEAN CursorOn;       // whether blinking cursor is on or not
    BOOLEAN DoubleCursor;   // whether the cursor size should be doubled
    BOOLEAN DelayCursor;    // don't toggle cursor on next timer message
    COORD CursorPosition;   // current position on screen (in screen buffer coords).
    ULONG CursorSize;
    WORD CursorYSize;
    WORD  UpdatingScreen;   // whether cursor is visible (set by console)
    ULONG ModeIndex;     // fullscreen font and mode
#ifdef i386
    // the following fields are used only by fullscreen textmode
    COORD WindowedWindowSize; // window size in windowed mode
    COORD WindowedScreenSize; // screen buffer size in windowed mode
    COORD MousePosition;
#endif
    ULONG Flags;        // indicate screen update hint state

    PTEXT_BUFFER_FONT_INFO ListOfTextBufferFont;
    TEXT_BUFFER_FONT_INFO  CurrentTextBufferFont;

#if defined(FE_SB)
    BOOLEAN CursorBlink;
    BOOLEAN CursorDBEnable;
    DBCS_SCREEN_BUFFER DbcsScreenBuffer;
#endif
} TEXT_BUFFER_INFO, *PTEXT_BUFFER_INFO;

typedef struct _GRAPHICS_BUFFER_INFO {
    ULONG BitMapInfoLength;
    LPBITMAPINFO lpBitMapInfo;
    PVOID BitMap;
    PVOID ClientBitMap;
    HANDLE ClientProcess;
    HANDLE hMutex;
    HANDLE hSection;
    DWORD dwUsage;
} GRAPHICS_BUFFER_INFO, *PGRAPHICS_BUFFER_INFO;

#define CONSOLE_TEXTMODE_BUFFER 1
#define CONSOLE_GRAPHICS_BUFFER 2
#define CONSOLE_OEMFONT_DISPLAY 4

typedef struct _SCREEN_INFORMATION {
    struct _CONSOLE_INFORMATION *Console;
    ULONG Flags;
    DWORD OutputMode;
    ULONG RefCount;
    CONSOLE_SHARE_ACCESS ShareAccess;   // share mode
    COORD ScreenBufferSize; // dimensions of buffer
    SMALL_RECT  Window;       // window location in screen buffer coordinates
    WORD ResizingWindow;   // > 0 if we should ignore WM_SIZE messages
    WORD Attributes;        // attributes of written text
    WORD PopupAttributes;   // attributes of popup text
    BOOLEAN WindowMaximizedX;
    BOOLEAN WindowMaximizedY;
    BOOLEAN WindowMaximized;
    UINT CommandIdLow;
    UINT CommandIdHigh;
    HCURSOR CursorHandle;
    HPALETTE hPalette;
    UINT dwUsage;
    int CursorDisplayCount;
    int WheelDelta;
    union {
        TEXT_BUFFER_INFO TextInfo;
        GRAPHICS_BUFFER_INFO GraphicsInfo;
    } BufferInfo;
    struct _SCREEN_INFORMATION *Next;
#if defined(FE_SB)
    BYTE   WriteConsoleDbcsLeadByte[2];
    BYTE   FillOutDbcsLeadChar;
    WCHAR  LineChar[6];
        #define UPPER_LEFT_CORNER   0
        #define UPPER_RIGHT_CORNER  1
        #define HORIZONTAL_LINE     2
        #define VERTICAL_LINE       3
        #define BOTTOM_LEFT_CORNER  4
        #define BOTTOM_RIGHT_CORNER 5
    BYTE BisectFlag;
        #define BISECT_LEFT   0x01
        #define BISECT_TOP    0x02
        #define BISECT_RIGHT  0x04
        #define BISECT_BOTTOM 0x08
#if defined(FE_IME)
    struct _CONVERSIONAREA_INFORMATION *ConvScreenInfo;
#else
    PVOID ConvScreenInfo;
#endif // FE_IME
#endif
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;

typedef struct _WINDOW_LIMITS {
    COORD MinimumWindowSize;    // minimum dimensions of window
    COORD MaximumWindowSize;    // maximum dimensions of window
    COORD MaxWindow;            // in pixels
    COORD FullScreenSize;
} WINDOW_LIMITS, *PWINDOW_LIMITS;

//
// the following values are used for TextInfo.Flags
//

#define TEXT_VALID_HINT 1
#define SINGLE_ATTRIBUTES_PER_LINE 2    // only one attribute per line
#if defined(FE_IME)
#define CONSOLE_CONVERSION_AREA_REDRAW 4
#endif

//
// the following value is put in CharInfo.OldLength if the value shouldn't
// be used.
//

#define INVALID_OLD_LENGTH -1

//
// the following mask is used to test for valid text attributes.
//

#if defined(FE_SB)
#define VALID_TEXT_ATTRIBUTES (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY | \
COMMON_LVB_LEADING_BYTE | COMMON_LVB_TRAILING_BYTE | COMMON_LVB_GRID_HORIZONTAL | COMMON_LVB_GRID_LVERTICAL | COMMON_LVB_GRID_RVERTICAL | COMMON_LVB_REVERSE_VIDEO | COMMON_LVB_UNDERSCORE )
#else
#define VALID_TEXT_ATTRIBUTES (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)
#endif

//
// the following macros are used to calculate 1) the cursor size in pixels
// and 2) the upper left pixel in the cursor, given the font size and
// the cursor size.
//

#define CURSOR_SIZE_IN_PIXELS(FONT_SIZE_Y,SIZE) ((((FONT_SIZE_Y)*(SIZE))+99)/100)
#define CURSOR_Y_OFFSET_IN_PIXELS(FONT_SIZE_Y,YSIZE) ((FONT_SIZE_Y) - (YSIZE))

//
// the following values are used to create the textmode cursor.
//

#define CURSOR_TIMER 1
#define CURSOR_SMALL_SIZE 25    // large enough to be one pixel on a six pixel font
#define CURSOR_BIG_SIZE 50

//
// the following macro returns TRUE if the given screen buffer is the
// active screen buffer.
//

#define ACTIVE_SCREEN_BUFFER(SCREEN_INFO) ((SCREEN_INFO)->Console->CurrentScreenBuffer == SCREEN_INFO)

//
// the following mask is used to create console windows.
//

#define CONSOLE_WINDOW_FLAGS (WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL)
#define CONSOLE_WINDOW_EX_FLAGS (WS_EX_OVERLAPPEDWINDOW | WS_EX_ACCEPTFILES | WS_EX_APPWINDOW )

#define WINDOW_SIZE_X(WINDOW) ((SHORT)(((WINDOW)->Right - (WINDOW)->Left + 1)))
#define WINDOW_SIZE_Y(WINDOW) ((SHORT)(((WINDOW)->Bottom - (WINDOW)->Top + 1)))
#define CONSOLE_WINDOW_SIZE_X(SCREEN) (WINDOW_SIZE_X(&(SCREEN)->Window))
#define CONSOLE_WINDOW_SIZE_Y(SCREEN) (WINDOW_SIZE_Y(&(SCREEN)->Window))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\clipbrd.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    clipbrd.c

Abstract:

        This file implements the clipboard functions.

Author:

    Therese Stowell (thereses) Jan-24-1992

--*/

#include "precomp.h"
#pragma hdrstop

/*++

    Here's the pseudocode for various clipboard operations

    init keyboard select (mark)
    ---------------------------
    if (already selecting)
        cancel selection
    init flags
    hidecursor
    createcursor
    init select rect
    set win text

    convert to mouse select (select)
    --------------------------------
    set flags
    destroy cursor
    showcursor
    invert old select rect
    init select rect
    invert select rect
    set win text

    re-init mouse select
    --------------------
    invert old select rect
    init select rect
    invert select rect

    cancel mouse select
    -------------------
    set flags
    reset win text
    invert old select rect

    cancel key select
    -----------------
    set flags
    reset win text
    destroy cursor
    showcursor
    invert old select rect

--*/


BOOL
MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    )

/*++

    invert a rect

--*/

{
    RECT Rect;
    PSCREEN_INFORMATION ScreenInfo;
#ifdef FE_SB
    SMALL_RECT SmallRect2;
    COORD TargetPoint;
    SHORT StringLength;
#endif  // FE_SB

    ScreenInfo = Console->CurrentScreenBuffer;
#ifdef FE_SB
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
            ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        for (SmallRect2.Top=SmallRect->Top; SmallRect2.Top <= SmallRect->Bottom;SmallRect2.Top++) {
            SmallRect2.Bottom = SmallRect2.Top;
            SmallRect2.Left = SmallRect->Left;
            SmallRect2.Right = SmallRect->Right;

            TargetPoint.X = SmallRect2.Left;
            TargetPoint.Y = SmallRect2.Top;
            StringLength = SmallRect2.Right - SmallRect2.Left + 1;
            BisectClipbrd(StringLength,TargetPoint,ScreenInfo,&SmallRect2);

            if (SmallRect2.Left <= SmallRect2.Right) {
                Rect.left = SmallRect2.Left-ScreenInfo->Window.Left;
                Rect.top = SmallRect2.Top-ScreenInfo->Window.Top;
                Rect.right = SmallRect2.Right+1-ScreenInfo->Window.Left;
                Rect.bottom = SmallRect2.Bottom+1-ScreenInfo->Window.Top;
                Rect.left *= SCR_FONTSIZE(ScreenInfo).X;
                Rect.top *= SCR_FONTSIZE(ScreenInfo).Y;
                Rect.right *= SCR_FONTSIZE(ScreenInfo).X;
                Rect.bottom *= SCR_FONTSIZE(ScreenInfo).Y;
                PatBlt(Console->hDC,
                       Rect.left,
                       Rect.top,
                       Rect.right  - Rect.left,
                       Rect.bottom - Rect.top,
                       DSTINVERT
                      );
            }
        }
    } else
#endif  // FE_SB
    {
        Rect.left = SmallRect->Left-ScreenInfo->Window.Left;
        Rect.top = SmallRect->Top-ScreenInfo->Window.Top;
        Rect.right = SmallRect->Right+1-ScreenInfo->Window.Left;
        Rect.bottom = SmallRect->Bottom+1-ScreenInfo->Window.Top;
#ifdef FE_SB
        if (!CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#else
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#endif
        {
            Rect.left *= SCR_FONTSIZE(ScreenInfo).X;
            Rect.top *= SCR_FONTSIZE(ScreenInfo).Y;
            Rect.right *= SCR_FONTSIZE(ScreenInfo).X;
            Rect.bottom *= SCR_FONTSIZE(ScreenInfo).Y;
        }

        PatBlt(Console->hDC,
                  Rect.left,
                  Rect.top,
                  Rect.right  - Rect.left,
                  Rect.bottom - Rect.top,
                  DSTINVERT
                 );
    }

    return(TRUE);
}

VOID
InvertSelection(
    IN PCONSOLE_INFORMATION Console,
    BOOL Inverting
    )
{
    BOOL Inverted;
    if (Console->Flags & CONSOLE_SELECTING &&
        Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
        Inverted = (Console->SelectionFlags & CONSOLE_SELECTION_INVERTED) ? TRUE : FALSE;
        if (Inverting == Inverted) {
            return;
        }
        if (Inverting) {
            Console->SelectionFlags |= CONSOLE_SELECTION_INVERTED;
        } else {
            Console->SelectionFlags &= ~CONSOLE_SELECTION_INVERTED;
        }
        MyInvert(Console,&Console->SelectionRect);
    }

}

VOID
InitializeMouseSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    )

/*++

    This routine initializes a selection region.

--*/

{
    Console->SelectionAnchor = CursorPosition;
    Console->SelectionRect.Left = Console->SelectionRect.Right = CursorPosition.X;
    Console->SelectionRect.Top = Console->SelectionRect.Bottom = CursorPosition.Y;

    //
    // Fire off an event to let accessibility apps know the selection has changed.
    //

    ConsoleNotifyWinEvent(Console,
                          EVENT_CONSOLE_CARET,
                          CONSOLE_CARET_SELECTION,
                          PACKCOORD(CursorPosition));
}

VOID
ExtendSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    )

/*++

    This routine extends a selection region.

--*/

{
    SMALL_RECT OldSelectionRect;
    HRGN OldRegion,NewRegion,CombineRegion;
    COORD FontSize;
    PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;

    if (CursorPosition.X < 0) {
        CursorPosition.X = 0;
    } else if (CursorPosition.X >= ScreenInfo->ScreenBufferSize.X) {
        CursorPosition.X = ScreenInfo->ScreenBufferSize.X-1;
    }

    if (CursorPosition.Y < 0) {
        CursorPosition.Y = 0;
    } else if (CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
        CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-1;
    }

    if (!(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY)) {

        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            // scroll if necessary to make cursor visible.
            MakeCursorVisible(ScreenInfo, CursorPosition);
            ASSERT(!(Console->SelectionFlags & CONSOLE_MOUSE_SELECTION));

            //
            // if the selection rect hasn't actually been started,
            // the selection cursor is still blinking.  turn it off.
            //

            ConsoleHideCursor(ScreenInfo);
        }
        Console->SelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;
        Console->SelectionRect.Left =Console->SelectionRect.Right = Console->SelectionAnchor.X;
        Console->SelectionRect.Top = Console->SelectionRect.Bottom = Console->SelectionAnchor.Y;

        // invert the cursor corner

#ifdef FE_SB
        if (!CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#else
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#endif
        {
            MyInvert(Console,&Console->SelectionRect);
        }
    } else {

        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            // scroll if necessary to make cursor visible.
            MakeCursorVisible(ScreenInfo,CursorPosition);
        }
#ifdef FE_SB
        //
        // uninvert old selection
        //
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            MyInvert(Console, &Console->SelectionRect);
        }
#endif  // FE_SB
    }

    //
    // update selection rect
    //

    OldSelectionRect = Console->SelectionRect;
    if (CursorPosition.X <= Console->SelectionAnchor.X) {
        Console->SelectionRect.Left = CursorPosition.X;
        Console->SelectionRect.Right = Console->SelectionAnchor.X;
    } else if (CursorPosition.X > Console->SelectionAnchor.X) {
        Console->SelectionRect.Right = CursorPosition.X;
        Console->SelectionRect.Left = Console->SelectionAnchor.X;
    }
    if (CursorPosition.Y <= Console->SelectionAnchor.Y) {
        Console->SelectionRect.Top = CursorPosition.Y;
        Console->SelectionRect.Bottom = Console->SelectionAnchor.Y;
    } else if (CursorPosition.Y > Console->SelectionAnchor.Y) {
        Console->SelectionRect.Bottom = CursorPosition.Y;
        Console->SelectionRect.Top = Console->SelectionAnchor.Y;
    }

    //
    // change inverted selection
    //
#ifdef FE_SB
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
        MyInvert(Console, &Console->SelectionRect);
    } else
#endif
    {
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            FontSize = CON_FONTSIZE(Console);
        } else {
            FontSize.X = 1;
            FontSize.Y = 1;
        }
        CombineRegion = CreateRectRgn(0,0,0,0);
        OldRegion = CreateRectRgn((OldSelectionRect.Left-ScreenInfo->Window.Left)*FontSize.X,
                                  (OldSelectionRect.Top-ScreenInfo->Window.Top)*FontSize.Y,
                                  (OldSelectionRect.Right-ScreenInfo->Window.Left+1)*FontSize.X,
                                  (OldSelectionRect.Bottom-ScreenInfo->Window.Top+1)*FontSize.Y
                                 );
        NewRegion = CreateRectRgn((Console->SelectionRect.Left-ScreenInfo->Window.Left)*FontSize.X,
                                  (Console->SelectionRect.Top-ScreenInfo->Window.Top)*FontSize.Y,
                                  (Console->SelectionRect.Right-ScreenInfo->Window.Left+1)*FontSize.X,
                                  (Console->SelectionRect.Bottom-ScreenInfo->Window.Top+1)*FontSize.Y
                                 );
        CombineRgn(CombineRegion,OldRegion,NewRegion,RGN_XOR);

        InvertRgn(Console->hDC,CombineRegion);
        DeleteObject(OldRegion);
        DeleteObject(NewRegion);
        DeleteObject(CombineRegion);
    }

    //
    // Fire off an event to let accessibility apps know the selection has changed.
    //

    ConsoleNotifyWinEvent(Console,
                          EVENT_CONSOLE_CARET,
                          CONSOLE_CARET_SELECTION,
                          PACKCOORD(CursorPosition));
}

VOID
CancelMouseSelection(
    IN PCONSOLE_INFORMATION Console
    )

/*++

    This routine terminates a mouse selection.

--*/

{
    PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;

    //
    // turn off selection flag
    //

    Console->Flags &= ~CONSOLE_SELECTING;

    SetWinText(Console,msgSelectMode,FALSE);

    //
    // invert old select rect.  if we're selecting by mouse, we
    // always have a selection rect.
    //

    MyInvert(Console,&Console->SelectionRect);

    ReleaseCapture();

    //
    // Mark the cursor position as changed so we'll fire off a win event.
    //

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ScreenInfo->BufferInfo.TextInfo.CursorMoved = TRUE;
    }
}

VOID
CancelKeySelection(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL JustCursor
    )

/*++

    This routine terminates a key selection.

--*/

{
    PSCREEN_INFORMATION ScreenInfo;

    if (!JustCursor) {

        //
        // turn off selection flag
        //

        Console->Flags &= ~CONSOLE_SELECTING;

        SetWinText(Console,msgMarkMode,FALSE);
    }

    //
    // invert old select rect, if we have one.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    if (Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
        MyInvert(Console,&Console->SelectionRect);
    } else {
        ConsoleHideCursor(ScreenInfo);
    }

    // restore text cursor

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        SetCursorInformation(ScreenInfo,
                             Console->TextCursorSize,
                             Console->TextCursorVisible
                            );
        SetCursorPosition(ScreenInfo,
                          Console->TextCursorPosition,
                          TRUE
                         );
    }
    ConsoleShowCursor(ScreenInfo);
}

VOID
ConvertToMouseSelect(
    IN PCONSOLE_INFORMATION Console,
    IN COORD MousePosition
    )

/*++

    This routine converts to a mouse selection from a key selection.

--*/

{
    Console->SelectionFlags |= CONSOLE_MOUSE_SELECTION | CONSOLE_MOUSE_DOWN;

    //
    // undo key selection
    //

    CancelKeySelection(Console,TRUE);

    Console->SelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;

    //
    // invert new selection
    //

    InitializeMouseSelection(Console, MousePosition);
    MyInvert(Console,&Console->SelectionRect);

    //
    // update title bar
    //

    SetWinText(Console,msgMarkMode,FALSE);
    SetWinText(Console,msgSelectMode,TRUE);

    //
    // capture mouse movement
    //

    SetCapture(Console->hWnd);
}


VOID
ClearSelection(
    IN PCONSOLE_INFORMATION Console
    )
{
    if (Console->Flags & CONSOLE_SELECTING) {
        if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
            CancelMouseSelection(Console);
        } else {
            CancelKeySelection(Console,FALSE);
        }
        UnblockWriteConsole(Console, CONSOLE_SELECTING);
    }
}

VOID
StoreSelection(
    IN PCONSOLE_INFORMATION Console
    )

/*++

 StoreSelection - Store selection (if present) into the Clipboard

--*/

{
    PCHAR_INFO Selection,CurCharInfo;
    COORD SourcePoint;
    COORD TargetSize;
    SMALL_RECT TargetRect;
    PWCHAR CurChar,CharBuf;
    HANDLE ClipboardDataHandle;
    SHORT i,j;
    BOOL Success;
    PSCREEN_INFORMATION ScreenInfo;
    BOOL bFalseUnicode;
    BOOL bMungeData;
#if defined(FE_SB)
    COORD TargetSize2;
    PWCHAR TmpClipboardData;
    SMALL_RECT SmallRect2;
    COORD TargetPoint;
    SHORT StringLength;
    WCHAR wchCARRIAGERETURN;
    WCHAR wchLINEFEED;
    int iExtra = 0;
    int iFeReserve = 1;
#endif

    //
    // See if there is a selection to get
    //

    if (!(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY)) {
        return;
    }

    //
    // read selection rectangle.  clip it first.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    if (Console->SelectionRect.Left < 0) {
        Console->SelectionRect.Left = 0;
    }
    if (Console->SelectionRect.Top < 0) {
        Console->SelectionRect.Top = 0;
    }
    if (Console->SelectionRect.Right >= ScreenInfo->ScreenBufferSize.X) {
        Console->SelectionRect.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    if (Console->SelectionRect.Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        Console->SelectionRect.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
    }

    TargetSize.X = WINDOW_SIZE_X(&Console->SelectionRect);
    TargetSize.Y = WINDOW_SIZE_Y(&Console->SelectionRect);
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
#if defined(FE_SB)

        if (CONSOLE_IS_DBCS_CP(Console)) {
            iExtra = 4 ;     // 4 is for DBCS lead or tail extra
            iFeReserve = 2 ; // FE does this for safety
            TmpClipboardData = ConsoleHeapAlloc(TMP_DBCS_TAG, (sizeof(WCHAR) * TargetSize.Y * (TargetSize.X + iExtra) + sizeof(WCHAR)));
            if (TmpClipboardData == NULL) {
                return;
            }
        } else {
            TmpClipboardData = NULL;
        }

        Selection = ConsoleHeapAlloc(TMP_TAG, sizeof(CHAR_INFO) * (TargetSize.X + iExtra) * TargetSize.Y * iFeReserve);
        if (Selection == NULL)
        {
            if (TmpClipboardData)
                ConsoleHeapFree(TmpClipboardData);
            return;
        }
#else
        Selection = ConsoleHeapAlloc(TMP_TAG, sizeof(CHAR_INFO) * TargetSize.X * TargetSize.Y);
        if (Selection == NULL)
            return;
#endif

#if defined(FE_SB)
    if (!CONSOLE_IS_DBCS_CP(Console)) {
#endif

#ifdef i386
        if ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) &&
            (Console->Flags & CONSOLE_VDM_REGISTERED)) {
            ReadRegionFromScreenHW(ScreenInfo,
                                   &Console->SelectionRect,
                                   Selection);
            CurCharInfo = Selection;
            for (i=0; i<TargetSize.Y; i++) {
                for (j=0; j<TargetSize.X; j++,CurCharInfo++) {
                    CurCharInfo->Char.UnicodeChar = SB_CharToWcharGlyph(Console->OutputCP, CurCharInfo->Char.AsciiChar);
                }
            }
        } else {
#endif
            SourcePoint.X = Console->SelectionRect.Left;
            SourcePoint.Y = Console->SelectionRect.Top;
            TargetRect.Left = TargetRect.Top = 0;
            TargetRect.Right = (SHORT)(TargetSize.X-1);
            TargetRect.Bottom = (SHORT)(TargetSize.Y-1);
            ReadRectFromScreenBuffer(ScreenInfo,
                                     SourcePoint,
                                     Selection,
                                     TargetSize,
                                     &TargetRect);
#ifdef i386
        }
#endif

        // extra 2 per line is for CRLF, extra 1 is for null
        ClipboardDataHandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                (TargetSize.Y * (TargetSize.X + 2) + 1) * sizeof(WCHAR));
        if (ClipboardDataHandle == NULL) {
            ConsoleHeapFree(Selection);
            return;
        }
#if defined(FE_SB)
    }
#endif

        //
        // convert to clipboard form
        //

#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console)) {
            if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                    !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                /*
                 * False Unicode is obtained, so we will have to convert it to
                 * Real Unicode, in which case we can't put CR or LF in now, since
                 * they will be converted into 0x266A and 0x25d9.  Temporarily
                 * mark the CR/LF positions with 0x0000 instead.
                 */
                wchCARRIAGERETURN = 0x0000;
                wchLINEFEED = 0x0000;
            } else {
                wchCARRIAGERETURN = UNICODE_CARRIAGERETURN;
                wchLINEFEED = UNICODE_LINEFEED;
            }

            CurChar = TmpClipboardData;
            bMungeData = (GetKeyState(VK_SHIFT) & KEY_PRESSED) == 0;
            for (i=0;i<TargetSize.Y;i++) {
                PWCHAR pwchLineStart = CurChar;

                SourcePoint.X = Console->SelectionRect.Left;
                SourcePoint.Y = Console->SelectionRect.Top + i;
                TargetSize2.X = TargetSize.X;
                TargetSize2.Y = 1;

                SmallRect2.Left = SourcePoint.X;
                SmallRect2.Top = SourcePoint.Y;
                SmallRect2.Right = SourcePoint.X + TargetSize2.X - 1;
                SmallRect2.Bottom = SourcePoint.Y;
                TargetPoint = SourcePoint;
                StringLength = TargetSize2.X;
                BisectClipbrd(StringLength,TargetPoint,ScreenInfo,&SmallRect2);

                SourcePoint.X = SmallRect2.Left;
                SourcePoint.Y = SmallRect2.Top;
                TargetSize2.X = SmallRect2.Right - SmallRect2.Left + 1;
                TargetSize2.Y = 1;
                TargetRect.Left = TargetRect.Top = TargetRect.Bottom = 0;
                TargetRect.Right = (SHORT)(TargetSize2.X-1);

                ReadRectFromScreenBuffer(ScreenInfo,
                                         SourcePoint,
                                         Selection,
                                         TargetSize2,
                                         &TargetRect);

                CurCharInfo = Selection;
                for (j=0;j<TargetSize2.X;j++,CurCharInfo++) {
                    if (!(CurCharInfo->Attributes & COMMON_LVB_TRAILING_BYTE))
                        *CurChar++ = CurCharInfo->Char.UnicodeChar;
                }
                // trim trailing spaces
                if (bMungeData) {
                    CurChar--;
                    while ((CurChar >= pwchLineStart) && (*CurChar == UNICODE_SPACE))
                        CurChar--;
                    CurChar++;
                    *CurChar++ = wchCARRIAGERETURN;
                    *CurChar++ = wchLINEFEED;
                }
            }
        }
        else {
#endif
        CurCharInfo = Selection;
        CurChar = CharBuf = GlobalLock(ClipboardDataHandle);
        bFalseUnicode = ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(Console->FullScreenFlags & CONSOLE_FULLSCREEN));
        bMungeData = (GetKeyState(VK_SHIFT) & KEY_PRESSED) == 0;
        for (i=0;i<TargetSize.Y;i++) {
            PWCHAR pwchLineStart = CurChar;

            for (j=0;j<TargetSize.X;j++,CurCharInfo++,CurChar++) {
                *CurChar = CurCharInfo->Char.UnicodeChar;
                if (*CurChar == 0) {
                    *CurChar = UNICODE_SPACE;
                }
            }
            // trim trailing spaces
            if (bMungeData) {
                CurChar--;
                while ((CurChar >= pwchLineStart) && (*CurChar == UNICODE_SPACE))
                    CurChar--;
                CurChar++;
            }

            if (bFalseUnicode) {
                FalseUnicodeToRealUnicode(pwchLineStart,
                        (ULONG)(CurChar - pwchLineStart), Console->OutputCP);
            }
            if (bMungeData) {
                *CurChar++ = UNICODE_CARRIAGERETURN;
                *CurChar++ = UNICODE_LINEFEED;
            }
        }
#if defined(FE_SB)
        }
#endif
        if (bMungeData) {
            if (TargetSize.Y)
                CurChar -= 2;   // don't put CRLF on last line
        }
        *CurChar = '\0';    // null terminate

#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console)) {
            // extra 4 is for CRLF and DBCS Reserved, extra 1 is for null
            ClipboardDataHandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                    (sizeof(WCHAR) * TargetSize.Y * (TargetSize.X+(4*sizeof(WCHAR)))) +
                                                        (1*sizeof(WCHAR)));
            if (ClipboardDataHandle == NULL) {
                ConsoleHeapFree(Selection);
                ConsoleHeapFree(TmpClipboardData);
                return;
            }

            CharBuf = GlobalLock(ClipboardDataHandle);
            RtlCopyMemory(CharBuf,TmpClipboardData,ConsoleHeapSize(TmpClipboardData));
            CurChar = CharBuf + (CurChar - TmpClipboardData);

            if (wchCARRIAGERETURN == 0x0000) {
                /*
                 * We have False Unicode, so we temporarily represented CRLFs with
                 * 0x0000s to avoid undesirable conversions (above).
                 * Convert to Real Unicode and restore real CRLFs.
                 */
                PWCHAR pwch;
                FalseUnicodeToRealUnicode(CharBuf,
                                    (ULONG)(CurChar - CharBuf),
                                    Console->OutputCP
                                   );
                for (pwch = CharBuf; pwch < CurChar; pwch++) {
                    if ((*pwch == 0x0000) && (pwch[1] == 0x0000)) {
                        *pwch++ = UNICODE_CARRIAGERETURN;
                        *pwch = UNICODE_LINEFEED;
                    }
                }
            }
        }
#endif

        GlobalUnlock(ClipboardDataHandle);
#if defined(FE_SB)
        if (TmpClipboardData)
            ConsoleHeapFree(TmpClipboardData);
#endif
        ConsoleHeapFree(Selection);
        Success = OpenClipboard(Console->hWnd);
        if (!Success) {
            GlobalFree(ClipboardDataHandle);
            return;
        }

        Success = EmptyClipboard();
        if (!Success) {
            GlobalFree(ClipboardDataHandle);
            return;
        }

        SetClipboardData(CF_UNICODETEXT,ClipboardDataHandle);
        CloseClipboard();   // Close clipboard
    } else {
        HBITMAP hBitmapTarget, hBitmapOld;
        HDC hDCMem;
        HPALETTE hPaletteOld;
        int Height;

        NtWaitForSingleObject(ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                              FALSE, NULL);

        hDCMem = CreateCompatibleDC(Console->hDC);
        hBitmapTarget = CreateCompatibleBitmap(Console->hDC,
                                                  TargetSize.X,
                                                  TargetSize.Y);
        if (hBitmapTarget) {
            hBitmapOld = SelectObject(hDCMem, hBitmapTarget);
            if (ScreenInfo->hPalette) {
                hPaletteOld = SelectPalette(hDCMem,
                                             ScreenInfo->hPalette,
                                             FALSE);
            }
            MyInvert(Console,&Console->SelectionRect);

            // if (DIB is a top-down)
            //      ySrc = abs(height) - rect.bottom - 1;
            // else
            //      ySrc = rect.Bottom.
            //
            Height = ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo->bmiHeader.biHeight;

            StretchDIBits(hDCMem, 0, 0,
                        TargetSize.X, TargetSize.Y,
                        Console->SelectionRect.Left + ScreenInfo->Window.Left,
                        (Height < 0) ? -Height - (Console->SelectionRect.Bottom + ScreenInfo->Window.Top) -  1
                        : Console->SelectionRect.Bottom + ScreenInfo->Window.Top,
                        TargetSize.X, TargetSize.Y,
                        ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                        ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                        ScreenInfo->BufferInfo.GraphicsInfo.dwUsage,
                        SRCCOPY);
            MyInvert(Console,&Console->SelectionRect);
            if (ScreenInfo->hPalette) {
                SelectPalette(hDCMem, hPaletteOld, FALSE);
            }
            SelectObject(hDCMem, hBitmapOld);
            OpenClipboard(Console->hWnd);
            EmptyClipboard();
            SetClipboardData(CF_BITMAP,hBitmapTarget);
            CloseClipboard();
        }
        DeleteDC(hDCMem);
        NtReleaseMutant(ScreenInfo->BufferInfo.GraphicsInfo.hMutex, NULL);
    }

}

VOID
DoCopy(
    IN PCONSOLE_INFORMATION Console
    )
{
    StoreSelection(Console);        // store selection in clipboard
    ClearSelection(Console);        // clear selection in console
}



VOID
ColorSelection(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT          Rect,
    IN ULONG                Attr
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    COORD TargetSize, Target;
    DWORD Written;

    ASSERT( Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER);
    ASSERT( Attr <= 0xff);

    //
    // See if there is a selection to get
    //

    if (!(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY)) {
    
        return;
    }

    //
    // read selection rectangle,  assumed already clipped to buffer.
    //

    ScreenInfo = Console->CurrentScreenBuffer;

    TargetSize.X = WINDOW_SIZE_X(&Console->SelectionRect);
    TargetSize.Y = WINDOW_SIZE_Y(&Console->SelectionRect);

    //
    //  Now color the selection a line at a time,  since this seems to be
    //  the only way to do it?
    //

    Target.X = Rect->Left;
    Target.Y = Rect->Top;

    for ( ; (Target.Y < Rect->Top + TargetSize.Y); ++Target.Y)  {

        Written = TargetSize.X;

        (VOID)FillOutput(  Console->CurrentScreenBuffer,
                           (USHORT)Attr,
                           Target,
                           CONSOLE_ATTRIBUTE,
                           &Written);
    }
}


/*++

Routine Description:

    This routine pastes given Unicode string into the console window.

Arguments:
    Console  -   Pointer to CONSOLE_INFORMATION structure
    pwStr    -   Unicode string that is pasted to the console window
    DataSize -   Size of the Unicode String in characters


Return Value:
    None


--*/


VOID
DoStringPaste(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR pwStr,
    IN UINT DataSize
    )
{
    PINPUT_RECORD StringData,CurRecord;
    PWCHAR CurChar;
    WCHAR Char;
    DWORD i;
    DWORD ChunkSize,j;
    ULONG EventsWritten;


    if(!pwStr) {
       return;
    }

    if (DataSize > DATA_CHUNK_SIZE) {
        ChunkSize = DATA_CHUNK_SIZE;
    } else {
        ChunkSize = DataSize;
    }

    //
    // allocate space to copy data.
    //

    StringData = ConsoleHeapAlloc(TMP_TAG, ChunkSize * sizeof(INPUT_RECORD) * 8); // 8 is maximum number of events per char
    if (StringData == NULL) {
        return;
    }

    //
    // transfer data to the input buffer in chunks
    //

    CurChar = pwStr;   // LATER remove this
    for (j = 0; j < DataSize; j += ChunkSize) {
        if (ChunkSize > DataSize - j) {
            ChunkSize = DataSize - j;
        }
        CurRecord = StringData;
        for (i = 0, EventsWritten = 0; i < ChunkSize; i++) {
            // filter out LF if not first char and preceded by CR
            Char = *CurChar;
            if (Char != UNICODE_LINEFEED || (i==0 && j==0) || (*(CurChar-1)) != UNICODE_CARRIAGERETURN) {
                SHORT KeyState;
                BYTE KeyFlags;
                BOOL AltGr=FALSE;
                BOOL Shift=FALSE;

                if (Char == 0) {
                    j = DataSize;
                    break;
                }

                KeyState = VkKeyScan(Char);
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_ENABLED() &&
                    (KeyState == -1)) {
                    WORD CharType;
                    //
                    // Determine DBCS character because these character doesn't know by VkKeyScan.
                    // GetStringTypeW(CT_CTYPE3) & C3_ALPHA can determine all linguistic characters.
                    // However, this is not include symbolic character for DBCS.
                    // IsConsoleFullWidth can help for DBCS symbolic character.
                    //
                    GetStringTypeW(CT_CTYPE3,&Char,1,&CharType);
                    if ((CharType & C3_ALPHA) ||
                        IsConsoleFullWidth(Console->hDC,Console->OutputCP,Char)) {
                        KeyState = 0;
                    }
                }
#endif

                // if VkKeyScanW fails (char is not in kbd layout), we must
                // emulate the key being input through the numpad

                if (KeyState == -1) {
                    CHAR CharString[4];
                    UCHAR OemChar;
                    PCHAR pCharString;

                    ConvertToOem(Console->OutputCP,
                                 &Char,
                                 1,
                                 &OemChar,
                                 1
                                );

                    _itoa(OemChar, CharString, 10);

                    EventsWritten++;
                    LoadKeyEvent(CurRecord,TRUE,0,VK_MENU,0x38,LEFT_ALT_PRESSED);
                    CurRecord++;

                    for (pCharString=CharString;*pCharString;pCharString++) {
                        WORD wVirtualKey, wScancode;
                        EventsWritten++;
                        wVirtualKey = *pCharString-'0'+VK_NUMPAD0;
                        wScancode = (WORD)MapVirtualKey(wVirtualKey, 0);
                        LoadKeyEvent(CurRecord,TRUE,0,wVirtualKey,wScancode,LEFT_ALT_PRESSED);
                        CurRecord++;
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,FALSE,0,wVirtualKey,wScancode,LEFT_ALT_PRESSED);
                        CurRecord++;
                    }

                    EventsWritten++;
                    LoadKeyEvent(CurRecord,FALSE,Char,VK_MENU,0x38,0);
                    CurRecord++;
                } else {
                    KeyFlags = HIBYTE(KeyState);

                    // handle yucky alt-gr keys
                    if ((KeyFlags & 6) == 6) {
                        AltGr=TRUE;
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,TRUE,0,VK_MENU,0x38,ENHANCED_KEY | LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED);
                        CurRecord++;
                    } else if (KeyFlags & 1) {
                        Shift=TRUE;
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,TRUE,0,VK_SHIFT,0x2a,SHIFT_PRESSED);
                        CurRecord++;
                    }

                    EventsWritten++;
                    LoadKeyEvent(CurRecord,
                                 TRUE,
                                 Char,
                                 LOBYTE(KeyState),
                                 (WORD)MapVirtualKey(CurRecord->Event.KeyEvent.wVirtualKeyCode,0),
                                 0);
                    if (KeyFlags & 1)
                        CurRecord->Event.KeyEvent.dwControlKeyState |= SHIFT_PRESSED;
                    if (KeyFlags & 2)
                        CurRecord->Event.KeyEvent.dwControlKeyState |= LEFT_CTRL_PRESSED;
                    if (KeyFlags & 4)
                        CurRecord->Event.KeyEvent.dwControlKeyState |= RIGHT_ALT_PRESSED;
                    CurRecord++;

                    EventsWritten++;
                    *CurRecord = *(CurRecord-1);
                    CurRecord->Event.KeyEvent.bKeyDown = FALSE;
                    CurRecord++;

                    // handle yucky alt-gr keys
                    if (AltGr) {
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,FALSE,0,VK_MENU,0x38,ENHANCED_KEY);
                        CurRecord++;
                    } else if (Shift) {
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,FALSE,0,VK_SHIFT,0x2a,0);
                        CurRecord++;
                    }
                }
            }
            CurChar++;
        }
        EventsWritten = WriteInputBuffer(Console,
                                         &Console->InputBuffer,
                                         StringData,
                                         EventsWritten
                                         );
    }
    ConsoleHeapFree(StringData);
    return;
}

VOID
DoPaste(
    IN PCONSOLE_INFORMATION Console
    )

/*++

  Perform paste request into old app by pulling out clipboard
        contents and writing them to the console's input buffer

--*/

{
    BOOL Success;
    HANDLE ClipboardDataHandle;

    if (Console->Flags & CONSOLE_SCROLLING) {
        return;
    }

    //
    // Get paste data from clipboard
    //

    Success = OpenClipboard(Console->hWnd);
    if (!Success)
        return;

    if (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
        PWCHAR pwstr;

        ClipboardDataHandle = GetClipboardData(CF_UNICODETEXT);
        if (ClipboardDataHandle == NULL) {
            CloseClipboard();   // Close clipboard
            return;
        }
        pwstr = GlobalLock(ClipboardDataHandle);
        DoStringPaste(Console,pwstr,(ULONG)GlobalSize(ClipboardDataHandle)/sizeof(WCHAR));
        GlobalUnlock(ClipboardDataHandle);

    } else {
        HBITMAP hBitmapSource,hBitmapTarget;
        HDC hDCMemSource,hDCMemTarget;
        BITMAP bm;
        PSCREEN_INFORMATION ScreenInfo;

        hBitmapSource = GetClipboardData(CF_BITMAP);
        if (hBitmapSource) {

            ScreenInfo = Console->CurrentScreenBuffer;
            NtWaitForSingleObject(ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                                  FALSE, NULL);

            hBitmapTarget = CreateDIBitmap(Console->hDC,
                                     &ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo->bmiHeader,
                                     CBM_INIT,
                                     ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                                     ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                                     ScreenInfo->BufferInfo.GraphicsInfo.dwUsage
                                    );
            if (hBitmapTarget) {
                hDCMemTarget = CreateCompatibleDC ( Console->hDC );
                if (hDCMemTarget != NULL) {
                    hDCMemSource = CreateCompatibleDC ( Console->hDC );
                    if (hDCMemSource != NULL) {
                        SelectObject( hDCMemTarget, hBitmapTarget );
                        SelectObject( hDCMemSource, hBitmapSource );
                        GetObjectW(hBitmapSource, sizeof (BITMAP), (LPSTR) &bm);
                        BitBlt ( hDCMemTarget, 0, 0, bm.bmWidth, bm.bmHeight,
                             hDCMemSource, 0, 0, SRCCOPY);
                        GetObjectW(hBitmapTarget, sizeof (BITMAP), (LPSTR) &bm);

                        // copy the bits from the DC to memory

                        GetDIBits(hDCMemTarget, hBitmapTarget, 0, bm.bmHeight,
                                  ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                                  ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                                  ScreenInfo->BufferInfo.GraphicsInfo.dwUsage);
                        DeleteDC(hDCMemSource);
                    }
                    DeleteDC(hDCMemTarget);
                }
                DeleteObject(hBitmapTarget);
                InvalidateRect(Console->hWnd,NULL,FALSE); // force repaint
            }
            NtReleaseMutant(ScreenInfo->BufferInfo.GraphicsInfo.hMutex, NULL);
        }
    }
    CloseClipboard();
    return;
}

VOID
InitSelection(
    IN PCONSOLE_INFORMATION Console
    )

/*++

    This routine initializes the selection process.  It is called
    when the user selects the Mark option from the system menu.

--*/

{
    COORD Position;
    PSCREEN_INFORMATION ScreenInfo;

    //
    // if already selecting, cancel selection.
    //

    if (Console->Flags & CONSOLE_SELECTING) {
        if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
            CancelMouseSelection(Console);
        } else {
            CancelKeySelection(Console,FALSE);
        }
    }

    //
    // set flags
    //

    Console->Flags |= CONSOLE_SELECTING;
    Console->SelectionFlags = 0;

    //
    // save old cursor position and
    // make console cursor into selection cursor.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    Console->TextCursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    Console->TextCursorVisible = (BOOLEAN)ScreenInfo->BufferInfo.TextInfo.CursorVisible;
    Console->TextCursorSize =   ScreenInfo->BufferInfo.TextInfo.CursorSize;
    ConsoleHideCursor(ScreenInfo);
    SetCursorInformation(ScreenInfo,
                         100,
                         TRUE
                        );
    Position.X = ScreenInfo->Window.Left;
    Position.Y = ScreenInfo->Window.Top;
    SetCursorPosition(ScreenInfo,
                      Position,
                      TRUE
                     );
    ConsoleShowCursor(ScreenInfo);

    //
    // init select rect
    //

    Console->SelectionAnchor = Position;

    //
    // set win text
    //

    SetWinText(Console,msgMarkMode,TRUE);

}

VOID
DoMark(
    IN PCONSOLE_INFORMATION Console
    )
{
    InitSelection(Console);        // initialize selection
}

VOID
DoSelectAll(
    IN PCONSOLE_INFORMATION Console
    )
{
    COORD Position;
    COORD WindowOrigin;
    PSCREEN_INFORMATION ScreenInfo;

    // clear any old selections
    if (Console->Flags & CONSOLE_SELECTING) {
        ClearSelection(Console);
    }

    // save the old window position
    ScreenInfo = Console->CurrentScreenBuffer;
    WindowOrigin.X = ScreenInfo->Window.Left;
    WindowOrigin.Y = ScreenInfo->Window.Top;

    // initialize selection
    Console->Flags |= CONSOLE_SELECTING;
    Console->SelectionFlags = CONSOLE_MOUSE_SELECTION | CONSOLE_SELECTION_NOT_EMPTY;
    Position.X = Position.Y = 0;
    InitializeMouseSelection(Console, Position);
    MyInvert(Console,&Console->SelectionRect);
    SetWinText(Console,msgSelectMode,TRUE);

    // extend selection
    Position.X = ScreenInfo->ScreenBufferSize.X - 1;
    Position.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
    ExtendSelection(Console, Position);

    // restore the old window position
    SetWindowOrigin(ScreenInfo, TRUE, WindowOrigin);
}

VOID
DoScroll(
    IN PCONSOLE_INFORMATION Console
    )
{
    if (!(Console->Flags & CONSOLE_SCROLLING)) {
        SetWinText(Console,msgScrollMode,TRUE);
        Console->Flags |= CONSOLE_SCROLLING;
    }
}

VOID
ClearScroll(
    IN PCONSOLE_INFORMATION Console
    )
{
    SetWinText(Console,msgScrollMode,FALSE);
    Console->Flags &= ~CONSOLE_SCROLLING;
}

VOID
ScrollIfNecessary(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    POINT CursorPos;
    RECT ClientRect;
    COORD MousePosition;

    if (Console->Flags & CONSOLE_SELECTING &&
        Console->SelectionFlags & CONSOLE_MOUSE_DOWN) {
        if (!GetCursorPos(&CursorPos)) {
            return;
        }
        if (!GetClientRect(Console->hWnd,&ClientRect)) {
            return;
        }
        MapWindowPoints(Console->hWnd,NULL,(LPPOINT)&ClientRect,2);
        if (!(PtInRect(&ClientRect,CursorPos))) {
            ScreenToClient(Console->hWnd,&CursorPos);
            MousePosition.X = (SHORT)CursorPos.x;
            MousePosition.Y = (SHORT)CursorPos.y;
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                MousePosition.X /= SCR_FONTSIZE(ScreenInfo).X;
                MousePosition.Y /= SCR_FONTSIZE(ScreenInfo).Y;
            }
            MousePosition.X += ScreenInfo->Window.Left;
            MousePosition.Y += ScreenInfo->Window.Top;

            ExtendSelection(Console,
                            MousePosition
                           );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\machine.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    machine.h

Abstract:

    This is the include file that defines detect of machine type.

Author:

    kazum    10-Aug-1994

Revision History:

--*/

#ifndef _MACHINE_ID_
#define _MACHINE_ID_

#if defined(i386)
//
// These definition is only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Build 683 compatibility.
//
// !!! should be removed.

#define MACHINEID_MICROSOFT   MACHINEID_MS_PCAT

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

//
// Functions.
//

//
// User mode ( NT API )
//

LONG
NtGetMachineIdentifierValue(
    IN OUT PULONG Value
    );

//
// User mode ( Win32 API )
//

LONG
RegGetMachineIdentifierValue(
    IN OUT PULONG Value
    );

#endif // defined(i386)
#endif // _MACHINE_ID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\bitmap.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    bitmap.c

Abstract:

        This file implements bitmap video buffer management.

Author:

    Therese Stowell (thereses) 4-Sept-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
CreateConsoleBitmap(
    IN OUT PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsInfo,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID *lpBitmap,
    OUT HANDLE *hMutex
    )
{
    NTSTATUS Status;
    LARGE_INTEGER MaximumSize;
    SIZE_T ViewSize;

    //
    // adjust bitmap info
    //


    if (GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight > 0)
    {
#if DBG
        DbgPrint("*************** Negating biHeight\n");
#endif
        GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight =
            -GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight;
    }

    if (GraphicsInfo->lpBitMapInfo->bmiHeader.biCompression != BI_RGB)
    {
#if DBG
        DbgPrint("*************** setting Compression to BI_RGB)\n");
#endif
        GraphicsInfo->lpBitMapInfo->bmiHeader.biCompression = BI_RGB;
    }

    //
    // allocate screeninfo buffer data and copy it
    //

    ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo = ConsoleHeapAlloc(BMP_TAG, GraphicsInfo->dwBitMapInfoLength);
    if (ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo == NULL) {
        return STATUS_NO_MEMORY;
    }
    ScreenInfo->BufferInfo.GraphicsInfo.BitMapInfoLength = GraphicsInfo->dwBitMapInfoLength;
    RtlCopyMemory(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
           GraphicsInfo->lpBitMapInfo,
           GraphicsInfo->dwBitMapInfoLength
          );
    ASSERT((GraphicsInfo->lpBitMapInfo->bmiHeader.biWidth *
            -GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight / 8 *
            GraphicsInfo->lpBitMapInfo->bmiHeader.biBitCount) ==
           (LONG)GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage);

    //
    // create bitmap section
    //

    MaximumSize.QuadPart = GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage;
    Status = NtCreateSection(&ScreenInfo->BufferInfo.GraphicsInfo.hSection,
                             SECTION_ALL_ACCESS,
                             NULL,
                             &MaximumSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL
                            );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
        return Status;
    }

    //
    // map server view of section
    //

    ViewSize = GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage;
    ScreenInfo->BufferInfo.GraphicsInfo.BitMap = 0;
    Status = NtMapViewOfSection(ScreenInfo->BufferInfo.GraphicsInfo.hSection,
                                NtCurrentProcess(),
                                &ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                                0L,
                                GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
        NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hSection);
        return Status;
    }

    //
    // map client view of section
    //

    ViewSize = GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage;
    *lpBitmap = 0;
    Status = NtMapViewOfSection(ScreenInfo->BufferInfo.GraphicsInfo.hSection,
                                CONSOLE_CLIENTPROCESSHANDLE(),
                                lpBitmap,
                                0L,
                                GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
        NtUnmapViewOfSection(NtCurrentProcess(),ScreenInfo->BufferInfo.GraphicsInfo.BitMap);
        NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hSection);
        return Status;
    }
    ScreenInfo->BufferInfo.GraphicsInfo.ClientProcess = CONSOLE_CLIENTPROCESSHANDLE();
    ScreenInfo->BufferInfo.GraphicsInfo.ClientBitMap = *lpBitmap;

    //
    // create mutex to serialize access to bitmap, then map handle to mutex to client side
    //

    NtCreateMutant(&ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                   MUTANT_ALL_ACCESS, NULL, FALSE);
    MapHandle(CONSOLE_CLIENTPROCESSHANDLE(),
              ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
              hMutex
             );

    ScreenInfo->BufferInfo.GraphicsInfo.dwUsage = GraphicsInfo->dwUsage;
    ScreenInfo->ScreenBufferSize.X = (WORD)GraphicsInfo->lpBitMapInfo->bmiHeader.biWidth;
    ScreenInfo->ScreenBufferSize.Y = (WORD)-GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight;
    ScreenInfo->Window.Left = 0;
    ScreenInfo->Window.Top = 0;
    ScreenInfo->Window.Right = (SHORT)(ScreenInfo->Window.Left+ScreenInfo->ScreenBufferSize.X-1);
    ScreenInfo->Window.Bottom = (SHORT)(ScreenInfo->Window.Top+ScreenInfo->ScreenBufferSize.Y-1);
    return STATUS_SUCCESS;
}


ULONG
SrvInvalidateBitMapRect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine is called to indicate that the application has modified a region
    in the bitmap.  We update the region to the screen.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_INVALIDATERECT_MSG a = (PCONSOLE_INVALIDATERECT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    UINT Codepage;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return((ULONG) Status);
    }
    if (HandleData->HandleType & CONSOLE_OUTPUT_HANDLE) {
        //ASSERT(Console->Flags & CONSOLE_VDM_REGISTERED);
        //ASSERT(!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE));
        ASSERT(Console->VDMBuffer != NULL);
        if (Console->VDMBuffer != NULL) {
            //ASSERT(HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X <= Console->VDMBufferSize.X);
            //ASSERT(HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y <= Console->VDMBufferSize.Y);
            if (HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X <= Console->VDMBufferSize.X &&
                HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y <= Console->VDMBufferSize.Y) {
                COORD TargetPoint;

                TargetPoint.X = a->Rect.Left;
                TargetPoint.Y = a->Rect.Top;
                // VDM can sometimes get out of sync with window size
                //ASSERT(a->Rect.Left >= 0);
                //ASSERT(a->Rect.Top >= 0);
                //ASSERT(a->Rect.Right < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X);
                //ASSERT(a->Rect.Bottom < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y);
                //ASSERT(a->Rect.Left <= a->Rect.Right);
                //ASSERT(a->Rect.Top <= a->Rect.Bottom);
                if ((a->Rect.Left >= 0) &&
                    (a->Rect.Top >= 0) &&
                    (a->Rect.Right < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X) &&
                    (a->Rect.Bottom < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y) &&
                    (a->Rect.Left <= a->Rect.Right) &&
                    (a->Rect.Top <= a->Rect.Bottom) ) {

                    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) && ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
                        if (CONSOLE_IS_DBCS_ENABLED() &&
                            Console->OutputCP != WINDOWSCP )
                        {
                            Codepage = USACP;
                        }
                        else

#endif
                        // we want UnicodeOem characters
                        Codepage = WINDOWSCP;
                    } else {
#if defined(FE_SB)
                        if (CONSOLE_IS_DBCS_ENABLED()) {
                            Codepage = Console->OutputCP;
                        }
                        else
#endif
                        // we want real Unicode characters
                        Codepage = Console->CP;
                    }

                    WriteRectToScreenBuffer((PBYTE)Console->VDMBuffer,
                            Console->VDMBufferSize, &a->Rect,
                            HandleData->Buffer.ScreenBuffer, TargetPoint,
                            Codepage);
                    WriteToScreen(HandleData->Buffer.ScreenBuffer,&a->Rect);
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } else {

        //
        // write data to screen
        //

        WriteToScreen(HandleData->Buffer.ScreenBuffer,&a->Rect);
    }

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

NTSTATUS
WriteRegionToScreenBitMap(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    DWORD NumScanLines;
    int   Height;
    //
    // if we have a selection, turn it off.
    //

    InvertSelection(ScreenInfo->Console,TRUE);

    NtWaitForSingleObject(ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                          FALSE, NULL);

    // The origin of (xSrc, ySrc) passed to SetDIBitsToDevice is located
    // at the DIB's bottom-left corner no matter if the DIB is
    // a top-down or bottom-up. Thus, if the DIB is a top-down, we have
    // to translate ySrc accordingly:
    // if (height < 0) {        // top-down
    //      ySrc = abs(height) - rect.Bottom -1;
    //
    // else
    //      ySrc = rect.Bottom;
    //
    Height = ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo->bmiHeader.biHeight;

    NumScanLines = SetDIBitsToDevice(ScreenInfo->Console->hDC,
                      Region->Left - ScreenInfo->Window.Left,
                      Region->Top - ScreenInfo->Window.Top,
                      Region->Right - Region->Left + 1,
                      Region->Bottom - Region->Top + 1,
                      Region->Left,
              Height < 0 ? -Height - Region->Bottom - 1 : Region->Bottom,
                      0,
                      ScreenInfo->ScreenBufferSize.Y,
                      ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                      ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                      ScreenInfo->BufferInfo.GraphicsInfo.dwUsage
                     );

    NtReleaseMutant(ScreenInfo->BufferInfo.GraphicsInfo.hMutex, NULL);

    //
    // if we have a selection, turn it on.
    //

    InvertSelection(ScreenInfo->Console,FALSE);

    if (NumScanLines == 0) {
        return STATUS_UNSUCCESSFUL;
    }
    return STATUS_SUCCESS;
}




VOID
FreeConsoleBitmap(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NtUnmapViewOfSection(NtCurrentProcess(),
                         ScreenInfo->BufferInfo.GraphicsInfo.BitMap);
    NtUnmapViewOfSection(ScreenInfo->BufferInfo.GraphicsInfo.ClientProcess,
                         ScreenInfo->BufferInfo.GraphicsInfo.ClientBitMap);
    NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hSection);
    NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hMutex);
    ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\cmdline.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

        This file implements command line editing and aliasing.

Author:

    Therese Stowell (thereses) 22-Mar-1991

Revision History:

Notes:

    The input model for the command line editing popups is complex.
    Here is the relevant pseudocode:

    CookedReadWaitRoutine
        if (CookedRead->Popup)
            Status = (*CookedRead->Popup->PopupInputRoutine)();
            if (Status == CONSOLE_STATUS_READ_COMPLETE)
                return STATUS_SUCCESS;
            return Status;

    CookedRead
        if (Command Line Editing Key)
            ProcessCommandLine
        else
            process regular key

    ProcessCommandLine
        if F7
            return CommandLinePopup

    CommandLinePopup
        draw popup
        return ProcessCommandListInput

    ProcessCommandListInput
        while (TRUE)
            GetChar
            if (wait)
                return wait
            switch (char)
                .
                .
                .


--*/

#include "precomp.h"
#pragma hdrstop

#define COPY_TO_CHAR_PROMPT_LENGTH 26
#define COPY_FROM_CHAR_PROMPT_LENGTH 28

#define COMMAND_NUMBER_PROMPT_LENGTH 22
#define COMMAND_NUMBER_LENGTH 5
#define MINIMUM_COMMAND_PROMPT_SIZE COMMAND_NUMBER_LENGTH

#if defined(FE_SB)
#define CHAR_COUNT(cch) cch
#else
#define CHAR_COUNT(cch) ((cch)/sizeof(WCHAR))
#endif


#define ALT_PRESSED     (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)
#define CTRL_PRESSED    (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)

#define CTRL_BUT_NOT_ALT(n) \
        (((n) & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)) && \
        !((n) & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)))

//
// Extended Edit Key
//

ExtKeyDefTable gaKeyDef;

CONST ExtKeyDefTable gaDefaultKeyDef = {
    {   // A
        0,                  VK_HOME,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_HOME,        0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // B
        0,                  VK_LEFT,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_LEFT,        0,      // Alt
    },
    {   // C
        0,
    },
    {   // D
        0,                  VK_DELETE,      0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // E
        0,                  VK_END,         0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // F
        0,                  VK_RIGHT,       0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_RIGHT,       0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // G
        0,
    },
    {   // H
        0,
    },
    {   // I
        0,
    },
    {   // J
        0,
    },
    {   // K
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Ctrl
    },
    {   // L
        0,
    },
    {   // M
        0,
    },
    {   // N
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // O
        0,
    },
    {   // P
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // Q
        0,
    },
    {   // R
        0,                  VK_F8,          0,      // Ctrl
    },
    {   // S
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // T
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Ctrl
    },
    {   // U
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // V
        0,
    },
    {   // W
        LEFT_CTRL_PRESSED,  VK_BACK,        EXTKEY_ERASE_PREV_WORD,    // Ctrl
    },
    {   // X
        0,
    },
    {   // Y
        0,
    },
    {   // Z
        0,
    },
};

//
// InitExtendedEditKeys
//
// Initialize the extended edit key table.
// If pKeyDefbuf is NULL, the internal default table is used.
// Otherwise, lpbyte should point to a valid ExtKeyDefBuf.
//

VOID InitExtendedEditKeys(CONST ExtKeyDefBuf* pKeyDefBuf)
{
    CONST BYTE* lpbyte;
    int i;
    DWORD dwCheckSum;

    //
    // Sanity check
    // If pKeyDefBuf is NULL, give it the default value.
    // If the version is not supported, just use the default and bail.
    //
    if (pKeyDefBuf == NULL || pKeyDefBuf->dwVersion != 0) {
#if DBG
        if (pKeyDefBuf != NULL) {
            DbgPrint("InitExtendedEditKeys: Unsupported version number(%d)\n", pKeyDefBuf->dwVersion);
        }
#endif
retry_clean:
        memcpy(gaKeyDef, gaDefaultKeyDef, sizeof gaKeyDef);
        return;
    }

    //
    // Calculate check sum
    //
    dwCheckSum = 0;
    for (lpbyte = (CONST BYTE*)pKeyDefBuf, i = FIELD_OFFSET(ExtKeyDefBuf, table); i < sizeof *pKeyDefBuf; ++i) {
        dwCheckSum += lpbyte[i];
    }
    if (dwCheckSum != pKeyDefBuf->dwCheckSum) {
#if DBG
        DbgPrint("InitExtendedEditKeys: Checksum(%d) does not match.\n", pKeyDefBuf->dwCheckSum);
#endif
        goto retry_clean;
    }

    //
    // Copy the entity
    //

    memcpy(gaKeyDef, pKeyDefBuf->table, sizeof gaKeyDef);
}

CONST ExtKeySubst* ParseEditKeyInfo(IN OUT PKEY_EVENT_RECORD pKeyEvent)
{
    CONST ExtKeyDef* pKeyDef;
    CONST ExtKeySubst* pKeySubst;

    //
    // If not extended mode, or Control key or Alt key is not pressed,
    // or virtual keycode is out of range, just bail.
    //
    if (!gExtendedEditKey ||
            (pKeyEvent->dwControlKeyState & (CTRL_PRESSED | ALT_PRESSED)) == 0 ||
            pKeyEvent->wVirtualKeyCode < 'A' || pKeyEvent->wVirtualKeyCode > 'Z') {

        return NULL;
    }

    //
    // Get the corresponding KeyDef.
    //
    pKeyDef = &gaKeyDef[pKeyEvent->wVirtualKeyCode - 'A'];

    //
    // Get the KeySubst based on the modifier status.
    //
    if (pKeyEvent->dwControlKeyState & ALT_PRESSED) {
        if (pKeyEvent->dwControlKeyState & CTRL_PRESSED) {
            pKeySubst = &pKeyDef->keys[2];
        } else {
            pKeySubst = &pKeyDef->keys[1];
        }
    } else {
        UserAssert(pKeyEvent->dwControlKeyState & CTRL_PRESSED);
        pKeySubst = &pKeyDef->keys[0];
    }

    UserAssert(pKeySubst);

    //
    // If the conbination is not defined, just bail.
    //
    if (pKeySubst->wVirKey == 0) {
        return NULL;
    }

    //
    // Substitute the input with ext key.
    //
    pKeyEvent->dwControlKeyState = pKeySubst->wMod;
    pKeyEvent->wVirtualKeyCode = pKeySubst->wVirKey;
    pKeyEvent->uChar.UnicodeChar = pKeySubst->wUnicodeChar;

    return pKeySubst;
}

//
// IsPauseKey
// returns TRUE if pKeyEvent is pause.
// The default key is Ctrl-S if extended edit keys are not specified.
//

BOOL IsPauseKey(IN PKEY_EVENT_RECORD pKeyEvent)
{
    if (gExtendedEditKey) {
        KEY_EVENT_RECORD KeyEvent = *pKeyEvent;
        CONST ExtKeySubst* pKeySubst = ParseEditKeyInfo(&KeyEvent);

        return pKeySubst != NULL && pKeySubst->wVirKey == VK_PAUSE;
    }

    return pKeyEvent->wVirtualKeyCode == L'S' && CTRL_BUT_NOT_ALT(pKeyEvent->dwControlKeyState);
}


//
// Word delimiters
//

WCHAR gaWordDelimChars[WORD_DELIM_MAX];
CONST WCHAR gaWordDelimCharsDefault[WORD_DELIM_MAX] = L"\\" L"+!:=/.<>;|&";

BOOL IsWordDelim(WCHAR wch)
{
    int i;

    //
    // Before it reaches here, L' ' case should have beeen already detected,
    // and gaWordDelimChars is specified.
    //
    UserAssert(wch != L' ' && gaWordDelimChars[0]);

    for (i = 0; gaWordDelimChars[i] && i < WORD_DELIM_MAX; ++i) {
        if (wch == gaWordDelimChars[i]) {
            return TRUE;
        }
    }

    return FALSE;
}

PEXE_ALIAS_LIST
AddExeAliasList(
    IN PCONSOLE_INFORMATION Console,
    IN LPVOID ExeName,
    IN USHORT ExeLength, // in bytes
    IN BOOLEAN UnicodeExe
    )
{
    PEXE_ALIAS_LIST AliasList;

    AliasList = ConsoleHeapAlloc(ALIAS_TAG, sizeof(EXE_ALIAS_LIST));
    if (AliasList == NULL) {
        return NULL;
    }
    if (UnicodeExe) {
        AliasList->ExeName = ConsoleHeapAlloc(ALIAS_TAG, ExeLength);
        if (AliasList->ExeName == NULL) {
            ConsoleHeapFree(AliasList);
            return NULL;
        }
        RtlCopyMemory(AliasList->ExeName,ExeName,ExeLength);
        AliasList->ExeLength = ExeLength;
    } else {
        AliasList->ExeName = ConsoleHeapAlloc(ALIAS_TAG, ExeLength*sizeof(WCHAR));
        if (AliasList->ExeName == NULL) {
            ConsoleHeapFree(AliasList);
            return NULL;
        }
        AliasList->ExeLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                                 ExeName,
                                                 ExeLength,
                                                 AliasList->ExeName,
                                                 ExeLength);
        AliasList->ExeLength *= 2;
    }
    InitializeListHead(&AliasList->AliasList);
    InsertHeadList(&Console->ExeAliasList,&AliasList->ListLink);
    return AliasList;
}

int
MyStringCompareW(
    IN LPWSTR Str1,
    IN LPWSTR Str2,
    IN USHORT Length, // in bytes
    IN BOOLEAN bCaseInsensitive
    )
{
    UNICODE_STRING String1;
    UNICODE_STRING String2;

    String1.Length = Length;
    String1.MaximumLength = Length;
    String1.Buffer = Str1;
    String2.Length = Length;
    String2.MaximumLength = Length;
    String2.Buffer = Str2;
    return RtlCompareUnicodeString(&String1,
                                   &String2,
                                   bCaseInsensitive);
}

#define my_wcsncmpi(p1, p2, n) MyStringCompareW(p1, p2, n, TRUE)
#define my_wcsncmp(p1, p2, n)  MyStringCompareW(p1, p2, n, FALSE)

PEXE_ALIAS_LIST
FindExe(
    IN PCONSOLE_INFORMATION Console,
    IN LPVOID ExeName,
    IN USHORT ExeLength, // in bytes
    IN BOOLEAN UnicodeExe
    )

/*++

    This routine searches for the specified exe alias list.  It returns
    a pointer to the exe list if found, NULL if not found.

--*/

{
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;
    LPWSTR UnicodeExeName;


    if (UnicodeExe) {
        UnicodeExeName = ExeName;
    } else {
        UnicodeExeName = ConsoleHeapAlloc(TMP_TAG, ExeLength * sizeof(WCHAR));
        if (UnicodeExeName == NULL)
            return NULL;
        ExeLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                      ExeName,
                                      ExeLength,
                                      UnicodeExeName,
                                      ExeLength);
        ExeLength *= 2;
    }
    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        if (AliasList->ExeLength == ExeLength &&
            !my_wcsncmpi(AliasList->ExeName,UnicodeExeName,ExeLength)) {
            if (!UnicodeExe) {
                ConsoleHeapFree(UnicodeExeName);
            }
            return AliasList;
        }
        ListNext = ListNext->Flink;
    }
    if (!UnicodeExe) {
        ConsoleHeapFree(UnicodeExeName);
    }
    return NULL;
}

PALIAS
FindAlias(
    IN PEXE_ALIAS_LIST AliasList,
    IN LPWSTR AliasName,
    IN USHORT AliasLength // in bytes
    )

/*++

    This routine searches for the specified alias.  If it finds one,
    it moves it to the head of the list and returns a pointer to the
    alias. Otherwise it returns NULL.

--*/

{
    PALIAS Alias;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &AliasList->AliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
        if (Alias->SourceLength == AliasLength &&
            !my_wcsncmpi(Alias->Source,AliasName,AliasLength)) {
            if (ListNext != ListHead->Flink) {
                RemoveEntryList(ListNext);
                InsertHeadList(ListHead,ListNext);
            }
            return Alias;
        }
        ListNext = ListNext->Flink;
    }
    return NULL;
}

NTSTATUS
AddAlias(
    IN PEXE_ALIAS_LIST ExeAliasList,
    IN LPWSTR Source,
    IN USHORT SourceLength,  // in bytes
    IN LPWSTR Target,
    IN USHORT TargetLength   // in bytes
    )

/*++

    This routine creates an alias and inserts it into the exe alias list.

--*/

{
    PALIAS Alias;

    Alias = ConsoleHeapAlloc(ALIAS_TAG, sizeof(ALIAS));
    if (Alias == NULL) {
        return STATUS_NO_MEMORY;
    }
    Alias->Source = ConsoleHeapAlloc(ALIAS_TAG, SourceLength);
    if (Alias->Source == NULL) {
        ConsoleHeapFree(Alias);
        return STATUS_NO_MEMORY;
    }
    Alias->Target = ConsoleHeapAlloc(ALIAS_TAG, TargetLength);
    if (Alias->Target == NULL) {
        ConsoleHeapFree(Alias->Source);
        ConsoleHeapFree(Alias);
        return STATUS_NO_MEMORY;
    }
    Alias->SourceLength = SourceLength;
    Alias->TargetLength = TargetLength;
    RtlCopyMemory(Alias->Source,Source,SourceLength);
    RtlCopyMemory(Alias->Target,Target,TargetLength);
    InsertHeadList(&ExeAliasList->AliasList,&Alias->ListLink);
    return STATUS_SUCCESS;
}

NTSTATUS
ReplaceAlias(
    IN PALIAS Alias,
    IN LPWSTR Target,
    IN USHORT TargetLength // in bytes
    )

/*++

    This routine replaces an existing target with a new target.

--*/

{
    LPWSTR NewTarget;

    NewTarget = ConsoleHeapAlloc(ALIAS_TAG, TargetLength);
    if (NewTarget == NULL) {
        return STATUS_NO_MEMORY;
    }
    ConsoleHeapFree(Alias->Target);
    Alias->Target = NewTarget;
    Alias->TargetLength = TargetLength;
    RtlCopyMemory(Alias->Target,Target,TargetLength);
    return STATUS_SUCCESS;
}


NTSTATUS
RemoveAlias(
    IN PALIAS Alias
    )

/*++

    This routine removes an alias.

--*/

{
    RemoveEntryList(&Alias->ListLink);
    ConsoleHeapFree(Alias->Source);
    ConsoleHeapFree(Alias->Target);
    ConsoleHeapFree(Alias);
    return STATUS_SUCCESS;
}

VOID
FreeAliasList(
    IN PEXE_ALIAS_LIST ExeAliasList
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PALIAS Alias;

    ListHead = &ExeAliasList->AliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
        ListNext = ListNext->Flink;
        RemoveAlias(Alias);
    }
    RemoveEntryList(&ExeAliasList->ListLink);
    ConsoleHeapFree(ExeAliasList->ExeName);
    ConsoleHeapFree(ExeAliasList);
}

VOID
FreeAliasBuffers(
    IN PCONSOLE_INFORMATION Console
    )
{
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        ListNext = ListNext->Flink;
        FreeAliasList(AliasList);
    }
}

ULONG
SrvAddConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine adds a command line alias to the global set.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{

    PCONSOLE_ADDALIAS_MSG a = (PCONSOLE_ADDALIAS_MSG)&m->u.ApiMessageData;
    PALIAS Alias;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    NTSTATUS Status;
    LPWSTR Source,Target;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Source, a->SourceLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Target,a->TargetLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->Unicode) {
        Source = a->Source;
        Target = a->Target;
    } else {
        Source = ConsoleHeapAlloc(TMP_TAG, a->SourceLength * sizeof(WCHAR));
        if (Source == NULL) {
            UnlockConsole(Console);
            return STATUS_NO_MEMORY;
        }
        Target = ConsoleHeapAlloc(TMP_TAG, a->TargetLength * sizeof(WCHAR));
        if (Target == NULL) {
            ConsoleHeapFree(Source);
            UnlockConsole(Console);
            return STATUS_NO_MEMORY;
        }
        a->SourceLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                            a->Source,
                                            a->SourceLength,
                                            Source,
                                            a->SourceLength);
        a->SourceLength *= 2;
        a->TargetLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                            a->Target,
                                            a->TargetLength,
                                            Target,
                                            a->TargetLength);
        a->TargetLength *= 2;
    }

    //
    // find specified exe.  if it's not there, add it if we're not
    // removing an alias.
    //

    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        Alias = FindAlias(ExeAliasList,Source,a->SourceLength);
        if (a->TargetLength) {
            if (Alias) {
                Status = ReplaceAlias(Alias,
                                      Target,
                                      a->TargetLength);
            } else {
                Status = AddAlias(ExeAliasList,
                                  Source,
                                  a->SourceLength,
                                  Target,
                                  a->TargetLength);
            }
        } else {
            if (Alias) {
                Status = RemoveAlias(Alias);
            }
        }
    } else {
        if (a->TargetLength) {
            ExeAliasList = AddExeAliasList(Console,a->Exe,a->ExeLength,a->UnicodeExe);
            if (ExeAliasList) {
                Status = AddAlias(ExeAliasList,
                                  Source,
                                  a->SourceLength,
                                  Target,
                                  a->TargetLength);
            } else {
                Status = STATUS_NO_MEMORY;
            }
        }
    }
    UnlockConsole(Console);
    if (!a->Unicode) {
        ConsoleHeapFree(Source);
        ConsoleHeapFree(Target);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine get a command line alias from the global set.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{

    NTSTATUS Status;
    PCONSOLE_GETALIAS_MSG a = (PCONSOLE_GETALIAS_MSG)&m->u.ApiMessageData;
    PALIAS Alias;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    LPWSTR Source,Target;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Source, a->SourceLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Target, a->TargetLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->Unicode) {
        Source = a->Source;
        Target = a->Target;
    } else {
        Source = ConsoleHeapAlloc(TMP_TAG, a->SourceLength * sizeof(WCHAR));
        if (Source == NULL) {
            UnlockConsole(Console);
            return STATUS_NO_MEMORY;
        }
        Target = ConsoleHeapAlloc(TMP_TAG, a->TargetLength * sizeof(WCHAR));
        if (Target == NULL) {
            ConsoleHeapFree(Source);
            UnlockConsole(Console);
            return STATUS_NO_MEMORY;
        }
        a->TargetLength = (USHORT)(a->TargetLength * sizeof(WCHAR));
        a->SourceLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                            a->Source,
                                            a->SourceLength,
                                            Source,
                                            a->SourceLength);
        a->SourceLength *= 2;
    }
    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        Alias = FindAlias(ExeAliasList,Source,a->SourceLength);
        if (Alias) {
            if (Alias->TargetLength + sizeof(WCHAR) > a->TargetLength) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                a->TargetLength = Alias->TargetLength + sizeof(WCHAR);
                RtlCopyMemory(Target,Alias->Target,Alias->TargetLength);
                Target[Alias->TargetLength/sizeof(WCHAR)] = L'\0';
            }
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    if (!a->Unicode) {
        if (NT_SUCCESS(Status)) {
            a->TargetLength = (USHORT)ConvertToOem(Console->CP,
                                             Target,
                                             a->TargetLength / sizeof(WCHAR),
                                             a->Target,
                                             CHAR_COUNT(a->TargetLength)
                                             );
        }
        ConsoleHeapFree(Source);
        ConsoleHeapFree(Target);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleAliasesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASESLENGTH_MSG a = (PCONSOLE_GETALIASESLENGTH_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    PALIAS Alias;
    PLIST_ENTRY ListHead, ListNext;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    a->AliasesLength = 0;
    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        ListHead = &ExeAliasList->AliasList;
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
            a->AliasesLength += Alias->SourceLength + Alias->TargetLength + (2*sizeof(WCHAR));  // +2 is for = and term null
            ListNext = ListNext->Flink;
        }
    }
    if (!a->Unicode) {
        a->AliasesLength /= sizeof(WCHAR);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

VOID
ClearAliases(
    IN PCONSOLE_INFORMATION Console
    )
{
    PEXE_ALIAS_LIST ExeAliasList;
    PLIST_ENTRY ListHead, ListNext;
    PALIAS Alias;

    ExeAliasList = FindExe(Console,
                           L"cmd.exe",
                           14,
                           TRUE);
    if (ExeAliasList == NULL) {
        return;
    }
    ListHead = &ExeAliasList->AliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
        ListNext = ListNext->Flink;
        RemoveAlias(Alias);
    }
}

DWORD
SrvGetConsoleAliases(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASES_MSG a = (PCONSOLE_GETALIASES_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    PALIAS Alias;
    PLIST_ENTRY ListHead, ListNext;
    DWORD AliasesBufferLength;
    LPWSTR AliasesBufferPtrW;
    LPSTR  AliasesBufferPtrA;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->AliasesBuffer, a->AliasesBufferLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    AliasesBufferLength = a->AliasesBufferLength;
    if (a->Unicode) {
        AliasesBufferPtrW = a->AliasesBuffer;
    } else {
        AliasesBufferPtrA = a->AliasesBuffer;
    }
    a->AliasesBufferLength = 0;
    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        ListHead = &ExeAliasList->AliasList;
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
            if (a->Unicode) {
                if ((a->AliasesBufferLength + Alias->SourceLength + Alias->TargetLength + (2*sizeof(WCHAR)))
                    <= AliasesBufferLength) {
                    RtlCopyMemory(AliasesBufferPtrW,Alias->Source,Alias->SourceLength);
                    AliasesBufferPtrW+=Alias->SourceLength/sizeof(WCHAR);
                    *AliasesBufferPtrW++= (WCHAR)'=';
                    RtlCopyMemory(AliasesBufferPtrW,Alias->Target,Alias->TargetLength);
                    AliasesBufferPtrW+=Alias->TargetLength/sizeof(WCHAR);
                    *AliasesBufferPtrW++= (WCHAR)'\0';
                    a->AliasesBufferLength += Alias->SourceLength + Alias->TargetLength + (2*sizeof(WCHAR));  // +2 is for = and term null
                } else {
                    UnlockConsole(Console);
                    return STATUS_BUFFER_OVERFLOW;
                }
            } else {
                if ((a->AliasesBufferLength + ((Alias->SourceLength + Alias->TargetLength)/sizeof(WCHAR)) + (2*sizeof(CHAR)))
                    <= AliasesBufferLength) {
                    USHORT SourceLength,TargetLength;
                    SourceLength = (USHORT)ConvertToOem(Console->CP,
                                                 Alias->Source,
                                                 Alias->SourceLength / sizeof(WCHAR),
                                                 AliasesBufferPtrA,
                                                 CHAR_COUNT(Alias->SourceLength)
                                                 );
                    AliasesBufferPtrA+=SourceLength;
                    *AliasesBufferPtrA++ = '=';
                    TargetLength = (USHORT)ConvertToOem(Console->CP,
                                                 Alias->Target,
                                                 Alias->TargetLength / sizeof(WCHAR),
                                                 AliasesBufferPtrA,
                                                 CHAR_COUNT(Alias->TargetLength)
                                                 );
                    AliasesBufferPtrA+=TargetLength;
                    *AliasesBufferPtrA++= '\0';
                    a->AliasesBufferLength += SourceLength + TargetLength + (2*sizeof(CHAR));  // +2 is for = and term null
                } else {
                    UnlockConsole(Console);
                    return STATUS_BUFFER_OVERFLOW;
                }
            }
            ListNext = ListNext->Flink;
        }
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleAliasExesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASEXESLENGTH_MSG a = (PCONSOLE_GETALIASEXESLENGTH_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    a->AliasExesLength = 0;
    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        a->AliasExesLength += AliasList->ExeLength + (1*sizeof(WCHAR)); // +1 for term null
        ListNext = ListNext->Flink;
    }
    if (!a->Unicode) {
        a->AliasExesLength /= sizeof(WCHAR);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleAliasExes(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASEXES_MSG a = (PCONSOLE_GETALIASEXES_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;
    DWORD AliasExesBufferLength;
    LPWSTR AliasExesBufferPtrW;
    LPSTR  AliasExesBufferPtrA;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->AliasExesBuffer, a->AliasExesBufferLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    AliasExesBufferLength = a->AliasExesBufferLength;
    if (a->Unicode) {
        AliasExesBufferPtrW = a->AliasExesBuffer;
    } else {
        AliasExesBufferPtrA = a->AliasExesBuffer;
    }
    a->AliasExesBufferLength = 0;
    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        if (a->Unicode) {
            if ((a->AliasExesBufferLength + AliasList->ExeLength + (1*sizeof(WCHAR)))
                <= AliasExesBufferLength) {
                RtlCopyMemory(AliasExesBufferPtrW,AliasList->ExeName,AliasList->ExeLength);
                AliasExesBufferPtrW+=AliasList->ExeLength/sizeof(WCHAR);
                *AliasExesBufferPtrW++= (WCHAR)'\0';
                a->AliasExesBufferLength += AliasList->ExeLength + (1*sizeof(WCHAR));  // +1 is term null
            } else {
                UnlockConsole(Console);
                return STATUS_BUFFER_OVERFLOW;
            }
        } else {
            if ((a->AliasExesBufferLength + (AliasList->ExeLength/sizeof(WCHAR)) + (1*sizeof(CHAR)))
                <= AliasExesBufferLength) {
                USHORT Length;
                Length = (USHORT)ConvertToOem(Console->CP,
                                        AliasList->ExeName,
                                        AliasList->ExeLength / sizeof(WCHAR),
                                        AliasExesBufferPtrA,
                                        CHAR_COUNT(AliasList->ExeLength)
                                        );
                AliasExesBufferPtrA+=Length;
                *AliasExesBufferPtrA++= (WCHAR)'\0';
                a->AliasExesBufferLength += Length + (1*sizeof(CHAR));  // +1 is term null
            } else {
                UnlockConsole(Console);
                return STATUS_BUFFER_OVERFLOW;
            }
        }
        ListNext = ListNext->Flink;
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

#define MAX_ARGS 9

NTSTATUS
MatchandCopyAlias(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR Source,
    IN USHORT SourceLength,
    OUT PWCHAR TargetBuffer,
    IN OUT PUSHORT TargetLength,
    IN LPWSTR Exe,
    IN USHORT ExeLength,
    OUT PDWORD LineCount
    )

/*++

Routine Description:

    This routine matches the input string with an alias and copies the
    alias to the input buffer.

Arguments:

    Source - string to match

    SourceLength - length of Source in bytes

    TargetBuffer - where to store matched string

    TargetLength - on input, contains size of TargetBuffer.  On output,
    contains length of alias stored in TargetBuffer.

    SourceIsCommandLine - if true, source buffer is a command line, where
        the first blank separate token is to be check for an alias, and if
        it matches, replaced with the value of the alias.  if false, then
        the source string is a null terminated alias name.

    LineCount - aliases can contain multiple commands.  $T is the command
        separator

Return Value:

    SUCCESS - match was found and alias was copied to buffer.

--*/

{
    PALIAS Alias;
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT SourceUpToFirstBlank=0;  // in chars
    PWCHAR Tmp;
    PEXE_ALIAS_LIST ExeAliasList;
    LPWSTR Args[MAX_ARGS];
    USHORT ArgsLength[MAX_ARGS];    // in bytes
    USHORT NumSourceArgs;
    LPWSTR SourcePtr;
    USHORT ArgCount,i,j,NewTargetLength;
    USHORT SourceRemainderLength;   // in chars
    PWCHAR Buffer,TargetAlias;
    PWCHAR TmpBuffer;

    //
    // alloc of exename may have failed.
    //

    if (Exe == NULL)
        return STATUS_UNSUCCESSFUL;

    //
    // find exe
    //

    ExeAliasList = FindExe(Console,Exe,ExeLength,TRUE);
    if (!ExeAliasList) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // find first blank
    //

    for (Tmp=Source,SourceUpToFirstBlank=0;
         *Tmp!=(WCHAR)' ' && SourceUpToFirstBlank<(USHORT)(SourceLength/sizeof(WCHAR));
         Tmp++,SourceUpToFirstBlank++) ;

    //
    // find char past first blank
    //

    j=SourceUpToFirstBlank;
    while (j<(USHORT)(SourceLength/sizeof(WCHAR)) && *Tmp==(WCHAR)' ') {
        Tmp++;
        j++;
    }
    SourcePtr = Tmp;
    SourceRemainderLength = (USHORT)((SourceLength/sizeof(WCHAR)) - j);

    //
    // find alias
    //

    Alias = FindAlias(ExeAliasList,Source,(USHORT)(SourceUpToFirstBlank*sizeof(WCHAR)));
    if (!Alias) {
        return STATUS_UNSUCCESSFUL;
    }

    TmpBuffer = ConsoleHeapAlloc(TMP_TAG, *TargetLength);
    if (!TmpBuffer) {
        return STATUS_NO_MEMORY;
    }

    //
    // count args in target
    //

    ArgCount=0;
    *LineCount=1;
    Tmp=Alias->Target;
    for (i=0;(USHORT)(i+1)<(USHORT)(Alias->TargetLength/sizeof(WCHAR));i++) {
        if (*Tmp == (WCHAR)'$' && *(Tmp+1) >= (WCHAR)'1' && *(Tmp+1) <= (WCHAR)'9') {
            USHORT ArgNum = *(Tmp+1) - (WCHAR)'0';
            if (ArgNum > ArgCount) {
                ArgCount = ArgNum;
            }
            Tmp++;
            i++;
        } else if (*Tmp == (WCHAR)'$' && *(Tmp+1) == (WCHAR)'*') {
            if (ArgCount==0) {
                ArgCount = 1;
            }
            Tmp++;
            i++;
        }
        Tmp++;
    }

    //
    // package up space separated strings in source into array
    // of args
    //
    //

    NumSourceArgs=0;
    Tmp = SourcePtr;
    for (i=0,j=0;i<ArgCount;i++) {
        if (j<SourceRemainderLength) {
            Args[NumSourceArgs] = Tmp;
            ArgsLength[NumSourceArgs] = 0;
            while (j++<SourceRemainderLength && *Tmp++ != (WCHAR)' ') {
                ArgsLength[NumSourceArgs] += sizeof(WCHAR);
            }
            while (j<SourceRemainderLength && *Tmp == (WCHAR)' ') {
                j++;
                Tmp++;
            }
            NumSourceArgs++;
        } else {
            break;
        }
    }

    //
    // put together the target string
    //
    // while (target)
    //     if ($)
    //        if arg && arg# <= ArgCount
    //            copy arg
    //        else if *
    //            copy arg
    //        else
    //            replace with < > etc
    //     else
    //        copy text up to next ' '
    //

    Buffer = TmpBuffer;
    NewTargetLength = 2*sizeof(WCHAR);    // for CRLF
    TargetAlias=Alias->Target;
    for (i=0;i<(USHORT)(Alias->TargetLength/sizeof(WCHAR));i++) {
        if (NewTargetLength >= *TargetLength) {
            *TargetLength = NewTargetLength;
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        if (*TargetAlias == (WCHAR)'$' && (USHORT)(i+1)<(USHORT)(Alias->TargetLength/sizeof(WCHAR))) {
            TargetAlias++;
            i++;
            if (*TargetAlias >= (WCHAR)'1' && *TargetAlias <= (WCHAR)'9') {

                //
                // do numbered parameter substitution
                //

                USHORT ArgNumber;

                ArgNumber = (USHORT)(*TargetAlias - (WCHAR)'1');
                if (ArgNumber < NumSourceArgs) {
                    if ((NewTargetLength+ArgsLength[ArgNumber])<=*TargetLength) {
                        RtlCopyMemory(Buffer,Args[ArgNumber],ArgsLength[ArgNumber]);
                        Buffer+=ArgsLength[ArgNumber]/sizeof(WCHAR);
                        NewTargetLength+=ArgsLength[ArgNumber];
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                }
            } else if (*TargetAlias == (WCHAR)'*') {

                //
                // do * parameter substitution
                //

                if (NumSourceArgs) {
                    if ((USHORT)(NewTargetLength+(SourceRemainderLength*sizeof(WCHAR)))<=*TargetLength) {
                        RtlCopyMemory(Buffer,Args[0],SourceRemainderLength*sizeof(WCHAR));
                        Buffer+=SourceRemainderLength;
                        NewTargetLength+=SourceRemainderLength*sizeof(WCHAR);
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                }
            } else if (*TargetAlias == (WCHAR)'l' || *TargetAlias == (WCHAR)'L') {

                //
                // do < substitution
                //

                *Buffer++ = (WCHAR)'<';
                NewTargetLength+=sizeof(WCHAR);
            } else if (*TargetAlias == (WCHAR)'g' || *TargetAlias == (WCHAR)'G') {

                //
                // do > substitution
                //

                *Buffer++ = (WCHAR)'>';
                NewTargetLength+=sizeof(WCHAR);
            } else if (*TargetAlias == (WCHAR)'b' || *TargetAlias == (WCHAR)'B') {

                //
                // do | substitution
                //

                *Buffer++ = (WCHAR)'|';
                NewTargetLength+=sizeof(WCHAR);
            } else if (*TargetAlias == (WCHAR)'t' || *TargetAlias == (WCHAR)'T') {

                //
                // do newline substitution
                //

                if ((USHORT)(NewTargetLength+(sizeof(WCHAR)*2))>*TargetLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }

                *LineCount += 1;
                *Buffer++ = UNICODE_CARRIAGERETURN;
                *Buffer++ = UNICODE_LINEFEED;
                NewTargetLength+=sizeof(WCHAR)*2;
            } else {

                //
                // copy $X
                //

                *Buffer++ = (WCHAR)'$';
                NewTargetLength+=sizeof(WCHAR);
                *Buffer++ = *TargetAlias;
                NewTargetLength+=sizeof(WCHAR);
            }
            TargetAlias++;
        } else {

            //
            // copy char
            //

            *Buffer++ = *TargetAlias++;
            NewTargetLength+=sizeof(WCHAR);
        }
    }
    *Buffer++ = UNICODE_CARRIAGERETURN;
    *Buffer++ = UNICODE_LINEFEED;
    RtlCopyMemory(TargetBuffer,TmpBuffer,NewTargetLength);
    ConsoleHeapFree(TmpBuffer);
    *TargetLength = NewTargetLength;
    return Status;
}

DWORD
SrvExpungeConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_EXPUNGECOMMANDHISTORY_MSG a = (PCONSOLE_EXPUNGECOMMANDHISTORY_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    EmptyCommandHistory(FindExeCommandHistory(Console,
                                              a->Exe,
                                              a->ExeLength,
                                              a->UnicodeExe));
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvSetConsoleNumberOfCommands(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETNUMBEROFCOMMANDS_MSG a = (PCONSOLE_SETNUMBEROFCOMMANDS_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    ReallocCommandHistory(Console,
                          FindExeCommandHistory(Console,
                                                a->Exe,
                                                a->ExeLength,
                                                a->UnicodeExe),
                          a->NumCommands
                         );
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleCommandHistoryLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG a = (PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    SHORT i;
    PCOMMAND_HISTORY CommandHistory;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    a->CommandHistoryLength=0;
    CommandHistory=FindExeCommandHistory(Console,
                                         a->Exe,
                                         a->ExeLength,
                                         a->UnicodeExe);
    if (CommandHistory) {
        for (i=0;i<CommandHistory->NumberOfCommands;i++) {
            a->CommandHistoryLength+=CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR);
        }
    }
    if (!a->Unicode) {
        a->CommandHistoryLength /= sizeof(WCHAR);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCOMMANDHISTORY_MSG a = (PCONSOLE_GETCOMMANDHISTORY_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    SHORT i,CommandHistoryLength;
    PCOMMAND_HISTORY CommandHistory;
    PWCHAR CommandBufferW;
    PCHAR CommandBufferA;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->CommandBuffer, a->CommandBufferLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->Unicode) {
        CommandBufferW=a->CommandBuffer;
    } else {
        CommandBufferA=a->CommandBuffer;
    }
    CommandHistoryLength=0;
    CommandHistory=FindExeCommandHistory(Console,
                                         a->Exe,
                                         a->ExeLength,
                                         a->UnicodeExe);
    if (CommandHistory) {
        for (i=0;i<CommandHistory->NumberOfCommands;i++) {
            if (a->Unicode) {
                if ((CommandHistoryLength+CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR)) <= a->CommandBufferLength) {
                    RtlCopyMemory(CommandBufferW,CommandHistory->Commands[i]->Command,CommandHistory->Commands[i]->CommandLength);
                    CommandBufferW+=CommandHistory->Commands[i]->CommandLength/sizeof(WCHAR);
                    *CommandBufferW++=(WCHAR)'\0';
                    CommandHistoryLength+=CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR);
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                    break;
                }
            } else {
                if ((CommandHistoryLength+(CommandHistory->Commands[i]->CommandLength/sizeof(WCHAR))+sizeof(CHAR)) <= a->CommandBufferLength) {
                    USHORT Length;
                    Length = (USHORT)ConvertToOem(Console->CP,
                                            CommandHistory->Commands[i]->Command,
                                            CommandHistory->Commands[i]->CommandLength / sizeof(WCHAR),
                                            CommandBufferA,
                                            CHAR_COUNT(CommandHistory->Commands[i]->CommandLength)
                                            );
                    CommandBufferA+=Length;
                    *CommandBufferA++=(WCHAR)'\0';
                    CommandHistoryLength+=CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR);
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                    break;
                }
            }
        }
    }
    a->CommandBufferLength=CommandHistoryLength;
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvSetConsoleCommandHistoryMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCOMMANDHISTORYMODE_MSG a = (PCONSOLE_SETCOMMANDHISTORYMODE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Console->InsertMode = (BOOLEAN) (a->Flags != CONSOLE_OVERSTRIKE);
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

PCOMMAND_HISTORY
ReallocCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PCOMMAND_HISTORY CurrentCommandHistory,
    IN DWORD NumCommands)
{
    PCOMMAND_HISTORY History;
    int i;

    /*
     * To protect ourselves from overflow, a limit of 0xFFFF is put on the
     * size of the command history.
     */
    if (CurrentCommandHistory == NULL ||
        CurrentCommandHistory->MaximumNumberOfCommands == (SHORT)NumCommands ||
        NumCommands > 0xFFFF) {
        return CurrentCommandHistory;
    }

    History = ConsoleHeapAlloc(HISTORY_TAG,
                               sizeof(COMMAND_HISTORY) + NumCommands * sizeof(PCOMMAND));
    if (History == NULL) {
        return CurrentCommandHistory;
    }

    *History = *CurrentCommandHistory;
    History->Flags |= CLE_RESET;
    History->NumberOfCommands = min(History->NumberOfCommands, (SHORT)NumCommands);
    History->LastAdded = History->NumberOfCommands - 1;
    History->LastDisplayed = History->NumberOfCommands - 1;
    History->FirstCommand = 0;
    History->MaximumNumberOfCommands = (SHORT)NumCommands;
    for (i = 0; i < History->NumberOfCommands; i++) {
        History->Commands[i] = CurrentCommandHistory->Commands[COMMAND_NUM_TO_INDEX(i, CurrentCommandHistory)];
    }
    for (; i < CurrentCommandHistory->NumberOfCommands; i++) {
        ConsoleHeapFree(CurrentCommandHistory->Commands[COMMAND_NUM_TO_INDEX(i, CurrentCommandHistory)]);
    }

    RemoveEntryList(&CurrentCommandHistory->ListLink);
    InitializeListHead(&History->PopupList);
    InsertHeadList(&Console->CommandHistoryList,&History->ListLink);

    ConsoleHeapFree(CurrentCommandHistory);
    return History;
}

PCOMMAND_HISTORY
FindExeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PVOID AppName,
    IN DWORD AppNameLength,
    IN BOOLEAN Unicode
    )
{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;
    PWCHAR AppNamePtr;

    if (!Unicode) {
        AppNamePtr = ConsoleHeapAlloc(TMP_TAG, AppNameLength * sizeof(WCHAR));
        if (AppNamePtr == NULL) {
            return NULL;
        }
        AppNameLength = ConvertInputToUnicode(Console->CP,
                                  AppName,
                                  AppNameLength,
                                  AppNamePtr,
                                  AppNameLength);
        AppNameLength *= 2;
    } else {
        AppNamePtr = AppName;
    }
    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;

        if (History->Flags & CLE_ALLOCATED &&
            !my_wcsncmpi(History->AppName,AppNamePtr,(USHORT)AppNameLength)) {
            if (!Unicode) {
                ConsoleHeapFree(AppNamePtr);
            }
            return History;
        }
    }
    if (!Unicode) {
        ConsoleHeapFree(AppNamePtr);
    }
    return NULL;
}

PCOMMAND_HISTORY
AllocateCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD AppNameLength,
    IN PWCHAR AppName,
    IN HANDLE ProcessHandle
    )

/*++

Routine Description:

    This routine returns the LRU command history buffer, or the command history
    buffer that corresponds to the app name.

Arguments:

    Console - pointer to console.

Return Value:

    Pointer to command history buffer.  if none are available, returns NULL.

--*/

{
    PCOMMAND_HISTORY History,BestCandidate;
    PLIST_ENTRY ListHead, ListNext;
    BOOL SameApp;

    //
    // Reuse a history buffer.  The buffer must be !CLE_ALLOCATED.
    // If possible, the buffer should have the same app name.
    //

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Blink;
    BestCandidate = NULL;
    SameApp = FALSE;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Blink;

        if ((History->Flags & CLE_ALLOCATED) == 0) {

            //
            // use LRU history buffer with same app name
            //

            if (History->AppName && !my_wcsncmpi(History->AppName,AppName,(USHORT)AppNameLength)) {
                BestCandidate = History;
                SameApp = TRUE;
                break;
            }

            //
            // second best choice is LRU history buffer
            //

            if (BestCandidate == NULL) {
                BestCandidate = History;
            }
        }
    }

    //
    // if there isn't a free buffer for the app name and the maximum number of
    // command history buffers hasn't been allocated, allocate a new one.
    //

    if (!SameApp && Console->NumCommandHistories < Console->MaxCommandHistories) {
        History = ConsoleHeapAlloc(HISTORY_TAG,
                                   sizeof(COMMAND_HISTORY) + Console->CommandHistorySize * sizeof(PCOMMAND));
        if (History == NULL) {
            return NULL;
        }

        History->AppName = ConsoleHeapAlloc(HISTORY_TAG, AppNameLength);
        if (History->AppName == NULL) {
            ConsoleHeapFree(History);
            return NULL;
        }

        RtlCopyMemory(History->AppName,AppName,AppNameLength);
        History->Flags = CLE_ALLOCATED;
        History->NumberOfCommands = 0;
        History->LastAdded = -1;
        History->LastDisplayed = -1;
        History->FirstCommand = 0;
        History->MaximumNumberOfCommands = Console->CommandHistorySize;
        InsertHeadList(&Console->CommandHistoryList,&History->ListLink);
        Console->NumCommandHistories+=1;
        History->ProcessHandle = ProcessHandle;
        InitializeListHead(&History->PopupList);
        return History;
    }

    //
    // if the app name doesn't match, copy in the new app name and free the old commands.
    //

    if (BestCandidate) {
        History = BestCandidate;
        UserAssert(CLE_NO_POPUPS(History));
        if (!SameApp) {
            SHORT i;
            if (History->AppName) {
                DBGPRINT(("Reusing %ls command history\n", History->AppName));
                ConsoleHeapFree(History->AppName);
            }
            for (i=0;i<History->NumberOfCommands;i++) {
                ConsoleHeapFree(History->Commands[i]);
            }
            History->NumberOfCommands = 0;
            History->LastAdded = -1;
            History->LastDisplayed = -1;
            History->FirstCommand = 0;
            History->AppName = ConsoleHeapAlloc(HISTORY_TAG, AppNameLength);
            if (History->AppName == NULL) {
                History->Flags &= ~CLE_ALLOCATED;
                return NULL;
            }
            RtlCopyMemory(History->AppName,AppName,AppNameLength);
        }
        History->ProcessHandle = ProcessHandle;
        History->Flags |= CLE_ALLOCATED;

        //
        // move to the front of the list
        //

        RemoveEntryList(&BestCandidate->ListLink);
        InsertHeadList(&Console->CommandHistoryList,&BestCandidate->ListLink);
    }
    return BestCandidate;
}

NTSTATUS
BeginPopup(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCOMMAND_HISTORY CommandHistory,
    IN COORD PopupSize
    )
{
    COORD Origin;
    COORD Size;
    PCLE_POPUP Popup;
    SMALL_RECT TargetRect;

    // determine popup dimensions

    Size = PopupSize;
    Size.X += 2;    // add borders
    Size.Y += 2;    // add borders
    if (Size.X >= (SHORT)(CONSOLE_WINDOW_SIZE_X(ScreenInfo))) {
        Size.X = (SHORT)(CONSOLE_WINDOW_SIZE_X(ScreenInfo));
    }
    if (Size.Y >= (SHORT)(CONSOLE_WINDOW_SIZE_Y(ScreenInfo))) {
        Size.Y = (SHORT)(CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
    }

    // make sure there's enough room for the popup borders

    if (Size.X < 2 || Size.Y < 2) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // determine origin.  center popup on window
    Origin.X = (SHORT)((CONSOLE_WINDOW_SIZE_X(ScreenInfo) - Size.X) / 2 + ScreenInfo->Window.Left);
    Origin.Y = (SHORT)((CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - Size.Y) / 2 + ScreenInfo->Window.Top);

    // allocate a popup structure

    Popup = ConsoleHeapAlloc(TMP_TAG, sizeof(CLE_POPUP));
    if (Popup == NULL) {
        return STATUS_NO_MEMORY;
    }

    // allocate a buffer

#if !defined(FE_SB)
    Popup->OldContents = ConsoleHeapAlloc(TMP_TAG, Size.X * Size.Y * sizeof(CHAR_INFO));
#else
    Popup->OldScreenSize = ScreenInfo->ScreenBufferSize;
    Popup->OldContents = ConsoleHeapAlloc(TMP_TAG, Popup->OldScreenSize.X * Size.Y * sizeof(CHAR_INFO));
#endif
    if (Popup->OldContents == NULL) {
        ConsoleHeapFree(Popup);
        return STATUS_NO_MEMORY;
    }
    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        Popup->Flags |= CLEPF_FALSE_UNICODE;
    } else {
        Popup->Flags &= ~CLEPF_FALSE_UNICODE;
    }

    //
    // fill in popup structure
    //

    InsertHeadList(&CommandHistory->PopupList,&Popup->ListLink);
    Popup->Region.Left = Origin.X;
    Popup->Region.Top = Origin.Y;
    Popup->Region.Right = (SHORT)(Origin.X + Size.X - 1);
    Popup->Region.Bottom = (SHORT)(Origin.Y + Size.Y - 1);
    Popup->Attributes = ScreenInfo->PopupAttributes;
    Popup->BottomIndex = COMMAND_INDEX_TO_NUM(CommandHistory->LastDisplayed,CommandHistory);

    //
    // copy old contents
    //

#if !defined(FE_SB)
    TargetRect = Popup->Region;
#else
    TargetRect.Left = 0;
    TargetRect.Top = Popup->Region.Top;
    TargetRect.Right = Popup->OldScreenSize.X - 1;
    TargetRect.Bottom = Popup->Region.Bottom;
#endif
    ReadScreenBuffer(ScreenInfo,
                     Popup->OldContents,
                     &TargetRect);

    ScreenInfo->Console->PopupCount++;
    DrawCommandListBorder(Popup,ScreenInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
EndPopup(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCOMMAND_HISTORY CommandHistory)
{
    COORD Size;
    SMALL_RECT SourceRect;
    PCLE_POPUP Popup;

    UserAssert(!CLE_NO_POPUPS(CommandHistory));
    if (CLE_NO_POPUPS(CommandHistory)) {
        return STATUS_UNSUCCESSFUL;
    }

    ConsoleHideCursor(ScreenInfo);
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    //
    // restore previous contents to screen
    //

#if !defined(FE_SB)
    Size.X = (SHORT)(Popup->Region.Right - Popup->Region.Left + 1);
    Size.Y = (SHORT)(Popup->Region.Bottom - Popup->Region.Top + 1);
    SourceRect = Popup->Region;
#else
    Size.X = Popup->OldScreenSize.X;
    Size.Y = (SHORT)(Popup->Region.Bottom - Popup->Region.Top + 1);
    SourceRect.Left = 0;
    SourceRect.Top = Popup->Region.Top;
    SourceRect.Right = Popup->OldScreenSize.X - 1;
    SourceRect.Bottom = Popup->Region.Bottom;
#endif
    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        /*
         * Screen buffer wants fake Unicode
         */
        if (!(Popup->Flags & CLEPF_FALSE_UNICODE)) {
#if !defined(FE_SB)
            TranslateOutputToAnsiUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size);
#else
            TranslateOutputToAnsiUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size,
                    NULL);
#endif
        }
    } else {
        /*
         * Screen buffer wants real Unicode
         */
        if (Popup->Flags & CLEPF_FALSE_UNICODE) {
#if !defined(FE_SB)
            TranslateOutputToOemUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size);
#else
            TranslateOutputToOemUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size, FALSE);
#endif
        }
    }
    WriteScreenBuffer(ScreenInfo,
                      Popup->OldContents,
                      &SourceRect
                     );
    WriteToScreen(ScreenInfo,
                  &SourceRect
                 );

    ConsoleShowCursor(ScreenInfo);

    //
    // free popup structure
    //

    RemoveEntryList(&Popup->ListLink);
    ConsoleHeapFree(Popup->OldContents);
    ConsoleHeapFree(Popup);
    ScreenInfo->Console->PopupCount--;
    return STATUS_SUCCESS;
}

VOID
CleanUpPopups(
    IN PCOOKED_READ_DATA CookedReadData
    )
{
    PCOMMAND_HISTORY CommandHistory;

    CommandHistory = CookedReadData->CommandHistory;
    if (!CommandHistory)
        return;
    while (!CLE_NO_POPUPS(CommandHistory)) {
        EndPopup(CookedReadData->ScreenInfo,CommandHistory);
    }
}


VOID
DeleteCommandLine(
    IN OUT PCOOKED_READ_DATA CookedReadData,
    IN BOOL UpdateFields
    )
{
    DWORD CharsToWrite = CookedReadData->NumberOfVisibleChars;
    COORD Coord = CookedReadData->OriginalCursorPosition;

    //
    // catch the case where the current command has scrolled off the
    // top of the screen.
    //

    if (Coord.Y < 0) {
        CharsToWrite += CookedReadData->ScreenInfo->ScreenBufferSize.X * Coord.Y;
        CharsToWrite += CookedReadData->OriginalCursorPosition.X;   // account for prompt
        CookedReadData->OriginalCursorPosition.X = 0;
        CookedReadData->OriginalCursorPosition.Y = 0;
        Coord.X = 0;
        Coord.Y = 0;
    }
#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(CookedReadData->ScreenInfo->Console) &&
        !CheckBisectStringW(CookedReadData->ScreenInfo,
                           CookedReadData->ScreenInfo->Console->CP,
                           CookedReadData->BackupLimit,
                           CharsToWrite,
                           CookedReadData->ScreenInfo->ScreenBufferSize.X
                            -CookedReadData->OriginalCursorPosition.X
                           )) {
        CharsToWrite++;
    }
#endif
    FillOutput(CookedReadData->ScreenInfo,
               (WCHAR)' ',
               Coord,
               CONSOLE_FALSE_UNICODE, // faster than real unicode
               &CharsToWrite
              );
    if (UpdateFields) {
        CookedReadData->BufPtr=CookedReadData->BackupLimit;
        CookedReadData->BytesRead=0;
        CookedReadData->CurrentPosition=0;
        CookedReadData->NumberOfVisibleChars = 0;
    }
    SetCursorPosition(CookedReadData->ScreenInfo,
                      CookedReadData->OriginalCursorPosition,
                      TRUE
                     );
}

VOID
RedrawCommandLine(
    IN OUT PCOOKED_READ_DATA CookedReadData
    )
{
    NTSTATUS Status;
    COORD CursorPosition;
    SHORT ScrollY=0;

    if (CookedReadData->Echo) {
        //
        // Draw the command line
        //
        CookedReadData->OriginalCursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                     CookedReadData->BackupLimit,
                                     CookedReadData->BackupLimit,
                                     CookedReadData->BackupLimit,
                                     &CookedReadData->BytesRead,
                                     &CookedReadData->NumberOfVisibleChars,
                                     CookedReadData->OriginalCursorPosition.X,
                                     WC_DESTRUCTIVE_BACKSPACE | WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                     &ScrollY);
        UserAssert(NT_SUCCESS(Status));
        CookedReadData->OriginalCursorPosition.Y += ScrollY;

        //
        // Move the cursor back to the right position
        //
        CursorPosition = CookedReadData->OriginalCursorPosition;
        CursorPosition.X += (SHORT)RetrieveTotalNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition,
                                                   CookedReadData->ScreenInfo->Console);
        if (CheckBisectStringW(CookedReadData->ScreenInfo,
                               CookedReadData->ScreenInfo->Console->CP,
                               CookedReadData->BackupLimit,
                               CookedReadData->CurrentPosition,
                               CookedReadData->ScreenInfo->ScreenBufferSize.X
                                -CookedReadData->OriginalCursorPosition.X)) {
            CursorPosition.X++;
        }
        Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                      CursorPosition,
                                      TRUE,
                                      NULL);
        UserAssert(NT_SUCCESS(Status));
    }
}

NTSTATUS
RetrieveNthCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN SHORT Index, // index, not command number
    IN PWCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG CommandSize)
{
    PCOMMAND CommandRecord;

    UserAssert(Index < CommandHistory->NumberOfCommands);
    CommandHistory->LastDisplayed = Index;
    CommandRecord = CommandHistory->Commands[Index];
    if (CommandRecord->CommandLength > (USHORT)BufferSize) {
        *CommandSize = (USHORT)BufferSize;  // room for CRLF?
    } else {
        *CommandSize = CommandRecord->CommandLength;
    }
    RtlCopyMemory(Buffer,CommandRecord->Command,*CommandSize);
    return STATUS_SUCCESS;
}


VOID
SetCurrentCommandLine(
    IN PCOOKED_READ_DATA CookedReadData,
    IN SHORT Index  // index, not command number
    )
/*++

    This routine copies the commandline specified by Index
    into the cooked read buffer

--*/
{
    DWORD CharsToWrite;
    NTSTATUS Status;
    SHORT ScrollY=0;

    DeleteCommandLine(CookedReadData,
                      TRUE);
    Status = RetrieveNthCommand(CookedReadData->CommandHistory,
                                Index,
                                CookedReadData->BackupLimit,
                                CookedReadData->BufferSize,
                                &CookedReadData->BytesRead);
    UserAssert(NT_SUCCESS(Status));
    UserAssert(CookedReadData->BackupLimit == CookedReadData->BufPtr);
    if (CookedReadData->Echo) {
        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                CookedReadData->BackupLimit,
                CookedReadData->BufPtr,
                CookedReadData->BufPtr,
                &CookedReadData->BytesRead,
                (PLONG)&CookedReadData->NumberOfVisibleChars,
                CookedReadData->OriginalCursorPosition.X,
                WC_DESTRUCTIVE_BACKSPACE | WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                &ScrollY);
        UserAssert(NT_SUCCESS(Status));
        CookedReadData->OriginalCursorPosition.Y += ScrollY;
    }
    CharsToWrite = CookedReadData->BytesRead/sizeof(WCHAR);
    CookedReadData->CurrentPosition = CharsToWrite;
    CookedReadData->BufPtr = CookedReadData->BackupLimit + CharsToWrite;
}

BOOL
IsCommandLinePopupKey(
    IN OUT PKEY_EVENT_RECORD KeyEvent
    )
{
    if (!(KeyEvent->dwControlKeyState &
            (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED |
             RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_ESCAPE:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_END:
        case VK_HOME:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:
        case VK_F9:
            return TRUE;
        default:
            break;
        }
    }

    //
    // Extended key handling
    //
    if (gExtendedEditKey && ParseEditKeyInfo(KeyEvent)) {
        return KeyEvent->uChar.UnicodeChar == 0;
    }

    return FALSE;
}

BOOL
IsCommandLineEditingKey(
    IN PKEY_EVENT_RECORD KeyEvent
    )
{
    if (!(KeyEvent->dwControlKeyState &
            (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED |
             RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_ESCAPE:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_END:
        case VK_HOME:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:
        case VK_INSERT:
        case VK_DELETE:
        case VK_F1:
        case VK_F2:
        case VK_F3:
        case VK_F4:
        case VK_F5:
        case VK_F6:
        case VK_F7:
        case VK_F8:
        case VK_F9:
            return TRUE;
        default:
            break;
        }
    }
    if ((KeyEvent->dwControlKeyState &
            (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_END:
        case VK_HOME:
        case VK_LEFT:
        case VK_RIGHT:
            return TRUE;
        default:
            break;
        }
    }

    //
    // Extended edit key handling
    //
    if (gExtendedEditKey && ParseEditKeyInfo(KeyEvent)) {
        //
        // If wUnicodeChar is specified in KeySubst,
        // the key should be handled as a normal key.
        // Basically this is for VK_BACK keys.
        //
        return KeyEvent->uChar.UnicodeChar == 0;
    }

    if ((KeyEvent->dwControlKeyState &
            (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_F7:
        case VK_F10:
            return TRUE;
        default:
            break;
        }
    }
    return FALSE;
}


NTSTATUS
ProcessCommandListInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the command list popup.  It returns
    when we're out of input or the user has selected a command line.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    BOOLEAN CommandLinePopupKeys = FALSE;
    PCONSOLE_READCONSOLE_MSG a;
    PHANDLE_DATA HandleData;
    SHORT Index;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    UserAssert(NT_SUCCESS(Status));
    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         &CommandLinePopupKeys,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        if (CommandLinePopupKeys) {
            switch (Char) {
            case VK_F9:

                //
                // prompt the user to enter the desired command number.
                // copy that command to the command line.
                //

                {
                COORD PopupSize;

                if (CookedReadData->CommandHistory &&
                    CookedReadData->ScreenInfo->ScreenBufferSize.X >= MINIMUM_COMMAND_PROMPT_SIZE+2) {  // 2 is for border
                    PopupSize.X = COMMAND_NUMBER_PROMPT_LENGTH+COMMAND_NUMBER_LENGTH;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                                        CookedReadData->CommandHistory,
                                        PopupSize
                                       );
                    if (NT_SUCCESS(Status)) {
                        // CommandNumberPopup does EndPopup call
                        return CommandNumberPopup(CookedReadData,
                                                  WaitReplyMessage,
                                                  WaitingThread,
                                                  WaitRoutine
                                                 );
                    }
                }
                }
                break;
            case VK_ESCAPE:
                EndPopup(CookedReadData->ScreenInfo,CommandHistory);
                HandleData->InputReadData->ReadCount += 1;
                return CONSOLE_STATUS_WAIT_NO_BLOCK;
            case VK_UP:
                UpdateCommandListPopup(-1,
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_DOWN:
                UpdateCommandListPopup(1,
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_END:
                /*
                 * Move waaay forward, UpdateCommandListPopup() can handle it.
                 */
                UpdateCommandListPopup((SHORT)(CommandHistory->NumberOfCommands),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_HOME:
                /*
                 * Move waaay back, UpdateCommandListPopup() can handle it.
                 */
                UpdateCommandListPopup((SHORT)-(CommandHistory->NumberOfCommands),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_PRIOR:
                UpdateCommandListPopup((SHORT)-POPUP_SIZE_Y(Popup),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_NEXT:
                UpdateCommandListPopup(POPUP_SIZE_Y(Popup),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_LEFT:
            case VK_RIGHT:
                Index = Popup->CurrentCommand;
                EndPopup(CookedReadData->ScreenInfo,CommandHistory);
                SetCurrentCommandLine(CookedReadData,Index);
                HandleData->InputReadData->ReadCount += 1;
                return CONSOLE_STATUS_WAIT_NO_BLOCK;
            default:
                break;
            }
        } else if (Char == UNICODE_CARRIAGERETURN) {
            ULONG i,lStringLength;
            DWORD LineCount=1;
            Index = Popup->CurrentCommand;
            EndPopup(CookedReadData->ScreenInfo,CommandHistory);
            SetCurrentCommandLine(CookedReadData,Index);
            lStringLength = CookedReadData->BytesRead;
            ProcessCookedReadInput(CookedReadData,
                                   UNICODE_CARRIAGERETURN,
                                   0,
                                   &Status);
            //
            // complete read
            //

            if (CookedReadData->Echo) {

                //
                // check for alias
                //

                i = CookedReadData->BufferSize;
                if (NT_SUCCESS(MatchandCopyAlias(CookedReadData->Console,
                                                 CookedReadData->BackupLimit,
                                                 (USHORT)lStringLength,
                                                 CookedReadData->BackupLimit,
                                                 (PUSHORT)&i,
                                                 CookedReadData->ExeName,
                                                 CookedReadData->ExeNameLength,
                                                 &LineCount
                                                ))) {
                  CookedReadData->BytesRead = i;
                }
                CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                                  CookedReadData->Console,
                                  &CookedReadData->TempHandle,
                                  NULL,
                                  FALSE
                                 );
            }
            WaitReplyMessage->ReturnValue = STATUS_SUCCESS;
            a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
            if (CookedReadData->BytesRead > CookedReadData->UserBufferSize || LineCount > 1) {
                if (LineCount > 1) {
                    PWSTR Tmp;
                    HandleData->InputReadData->InputHandleFlags |= HANDLE_MULTI_LINE_INPUT;
                    for (Tmp=CookedReadData->BackupLimit;*Tmp!=UNICODE_LINEFEED;Tmp++)
                        UserAssert(Tmp<(CookedReadData->BackupLimit+CookedReadData->BytesRead));
                    a->NumBytes = (ULONG)(Tmp-CookedReadData->BackupLimit+1)*sizeof(*Tmp);
                } else {
                    a->NumBytes = CookedReadData->UserBufferSize;
                }
                HandleData->InputReadData->InputHandleFlags |= HANDLE_INPUT_PENDING;
                HandleData->InputReadData->BufPtr = CookedReadData->BackupLimit;
                HandleData->InputReadData->BytesAvailable = CookedReadData->BytesRead - a->NumBytes;
                HandleData->InputReadData->CurrentBufPtr=(PWCHAR)((PBYTE)CookedReadData->BackupLimit+a->NumBytes);
                RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
            } else {
                a->NumBytes = CookedReadData->BytesRead;
                RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
            }
            if (!a->Unicode) {

                //
                // if ansi, translate string.
                //

                PCHAR TransBuffer;

                TransBuffer = ConsoleHeapAlloc(TMP_TAG, CHAR_COUNT(a->NumBytes));
                if (TransBuffer == NULL) {
                    return STATUS_NO_MEMORY;
                }

                a->NumBytes = (ULONG)ConvertToOem(CookedReadData->Console->CP,
                                            CookedReadData->UserBuffer,
                                            a->NumBytes / sizeof(WCHAR),
                                            TransBuffer,
                                            CHAR_COUNT(a->NumBytes)
                                            );
                RtlCopyMemory(CookedReadData->UserBuffer,TransBuffer,a->NumBytes);
                ConsoleHeapFree(TransBuffer);
            }

            return CONSOLE_STATUS_READ_COMPLETE;

        } else {
            Index = FindMatchingCommand(CookedReadData->CommandHistory,
                    &Char, 1 * sizeof(WCHAR),
                    Popup->CurrentCommand, FMCFL_JUST_LOOKING);
            if (Index != -1) {
                UpdateCommandListPopup(
                        (SHORT)(Index - Popup->CurrentCommand),
                        &Popup->CurrentCommand,
                        CommandHistory,
                        Popup,
                        CookedReadData->ScreenInfo, UCLP_WRAP);
            }
        }
    }
}

NTSTATUS
ProcessCopyFromCharInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the delete from cursor to char char popup.  It returns
    when we're out of input or the user has entered a char.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    PHANDLE_DATA HandleData;
    int i;  // char index (not byte)

    UNREFERENCED_PARAMETER(WaitingThread);

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);

        //
        // delete from cursor up to specified char
        //

        for (i=CookedReadData->CurrentPosition+1;
             i<(int)(CookedReadData->BytesRead/sizeof(WCHAR));
             i++) {
            if (CookedReadData->BackupLimit[i] == Char) {
                break;
            }
        }
        if (i!=(int)(CookedReadData->BytesRead/sizeof(WCHAR)+1)) {
                COORD CursorPosition;

                //
                // save cursor position
                //

                CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;

                //
                // deletecommandline
                //

                DeleteCommandLine(CookedReadData,
                                  FALSE);
                //
                // delete chars
                //

                RtlCopyMemory(&CookedReadData->BackupLimit[CookedReadData->CurrentPosition],
                              &CookedReadData->BackupLimit[i],
                              CookedReadData->BytesRead-(i*sizeof(WCHAR))
                              );
                CookedReadData->BytesRead -= (i-CookedReadData->CurrentPosition)*sizeof(WCHAR);

                //
                // write commandline
                //

                if (CookedReadData->Echo) {
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BackupLimit,
                                        &CookedReadData->BytesRead,
                                        (PLONG)&CookedReadData->NumberOfVisibleChars,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        NULL
                                        );
                    UserAssert(NT_SUCCESS(Status));
                }

                //
                // restore cursor position
                //

                Status = SetCursorPosition(CookedReadData->ScreenInfo,
                                           CursorPosition,
                                           TRUE);
                UserAssert(NT_SUCCESS(Status));
        }

        HandleData->InputReadData->ReadCount += 1;
        return CONSOLE_STATUS_WAIT_NO_BLOCK;
    }
}

NTSTATUS
ProcessCopyToCharInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the delete char popup.  It returns
    when we're out of input or the user has entered a char.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    PCOMMAND LastCommand;
    DWORD NumSpaces;
    SHORT ScrollY=0;
    PHANDLE_DATA HandleData;

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);

        //
        // copy up to specified char
        //

        LastCommand = GetLastCommand(CookedReadData->CommandHistory);
        if (LastCommand) {
            int i,j;

            //
            // find specified char in last command
            //

            for (i=CookedReadData->CurrentPosition+1;i<(int)(LastCommand->CommandLength/sizeof(WCHAR));i++) {
                if (LastCommand->Command[i] == Char)
                    break;
            }

            //
            // if we found it, copy up to it
            //

            if (i<(int)(LastCommand->CommandLength/sizeof(WCHAR)) && (USHORT)(LastCommand->CommandLength/sizeof(WCHAR)) > (USHORT)CookedReadData->CurrentPosition) {
                j=i-CookedReadData->CurrentPosition;
                UserAssert(j > 0);
                RtlCopyMemory(CookedReadData->BufPtr,
                       &LastCommand->Command[CookedReadData->CurrentPosition],
                       j*sizeof(WCHAR));
                CookedReadData->CurrentPosition += j;
                j*=sizeof(WCHAR);
                CookedReadData->BytesRead = max(CookedReadData->BytesRead,
                                                CookedReadData->CurrentPosition * sizeof(WCHAR));
                if (CookedReadData->Echo) {
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        (PDWORD) &j,
                                        (PLONG)&NumSpaces,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY);
                    UserAssert(NT_SUCCESS(Status));
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                    CookedReadData->NumberOfVisibleChars += NumSpaces;
                }
                CookedReadData->BufPtr+=j/sizeof(WCHAR);
            }
        }
        HandleData->InputReadData->ReadCount += 1;
        return CONSOLE_STATUS_WAIT_NO_BLOCK;
    }
    UNREFERENCED_PARAMETER(WaitingThread);
}

NTSTATUS
ProcessCommandNumberInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the delete char popup.  It returns
    when we're out of input or the user has entered a char.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    DWORD NumSpaces;
    BOOLEAN CommandLinePopupKeys;
    SHORT CommandNumber;
    PHANDLE_DATA HandleData;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData);
    UserAssert(NT_SUCCESS(Status));
    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         &CommandLinePopupKeys,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        if (Char >= (WCHAR)0x30 && Char <= (WCHAR)0x39) {
            if (Popup->NumberRead < 5) {
                DWORD CharsToWrite;
                WORD RealAttributes;

                RealAttributes = CookedReadData->ScreenInfo->Attributes;
                CookedReadData->ScreenInfo->Attributes = Popup->Attributes;
                CharsToWrite = sizeof(WCHAR);
                Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    Popup->NumberBuffer,
                                    &Popup->NumberBuffer[Popup->NumberRead],
                                    &Char,
                                    &CharsToWrite,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    NULL);
                UserAssert(NT_SUCCESS(Status));
                CookedReadData->ScreenInfo->Attributes = RealAttributes;
                Popup->NumberBuffer[Popup->NumberRead] = Char;
                Popup->NumberRead += 1;
            }
        } else if (Char == UNICODE_BACKSPACE) {
            if (Popup->NumberRead > 0) {
                DWORD CharsToWrite;
                WORD RealAttributes;

                RealAttributes = CookedReadData->ScreenInfo->Attributes;
                CookedReadData->ScreenInfo->Attributes = Popup->Attributes;
                CharsToWrite = sizeof(WCHAR);
                Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    Popup->NumberBuffer,
                                    &Popup->NumberBuffer[Popup->NumberRead],
                                    &Char,
                                    &CharsToWrite,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    NULL
                                    );
                UserAssert(NT_SUCCESS(Status));
                CookedReadData->ScreenInfo->Attributes = RealAttributes;
                Popup->NumberBuffer[Popup->NumberRead] = (WCHAR)' ';
                Popup->NumberRead -= 1;
            }
        } else if (Char == (WCHAR)VK_ESCAPE) {
            EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            if (!CLE_NO_POPUPS(CommandHistory)) {
                EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            }
            DeleteCommandLine(CookedReadData,
                              TRUE);
        } else if (Char == UNICODE_CARRIAGERETURN) {
            CHAR NumberBuffer[6];
            int i;

            for (i=0;i<Popup->NumberRead;i++) {
                NumberBuffer[i] = (CHAR)Popup->NumberBuffer[i];
            }
            NumberBuffer[i] = 0;
            CommandNumber = (SHORT)atoi(NumberBuffer);
            if ((WORD)CommandNumber >= (WORD)CookedReadData->CommandHistory->NumberOfCommands) {
                CommandNumber = (SHORT)(CookedReadData->CommandHistory->NumberOfCommands-1);
            }
            EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            if (!CLE_NO_POPUPS(CommandHistory)) {
                EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            }
            SetCurrentCommandLine(CookedReadData,COMMAND_NUM_TO_INDEX(CommandNumber,CookedReadData->CommandHistory));
        }
        HandleData->InputReadData->ReadCount += 1;
        return CONSOLE_STATUS_WAIT_NO_BLOCK;
    }
    UNREFERENCED_PARAMETER(WaitingThread);
}

NTSTATUS
CommandListPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the command list popup.  It puts up the
    popup, then calls ProcessCommandListInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    SHORT CurrentCommand;
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    CurrentCommand = COMMAND_INDEX_TO_NUM(CommandHistory->LastDisplayed,CommandHistory);

    if (CurrentCommand < (SHORT)(CommandHistory->NumberOfCommands - POPUP_SIZE_Y(Popup))) {
        Popup->BottomIndex = (SHORT)(max(CurrentCommand,POPUP_SIZE_Y(Popup)-1));
    } else {
        Popup->BottomIndex = (SHORT)(CommandHistory->NumberOfCommands-1);
    }
    Popup->CurrentCommand = CommandHistory->LastDisplayed;
    DrawCommandListPopup(Popup,
                         CommandHistory->LastDisplayed,
                         CommandHistory,
                         CookedReadData->ScreenInfo);
    Popup->PopupInputRoutine = ProcessCommandListInput;
    return ProcessCommandListInput(CookedReadData,
                                   WaitReplyMessage,
                                   WaitingThread,
                                   WaitRoutine);
}

VOID
DrawPromptPopup(
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR Prompt,
    IN ULONG PromptLength   // in chars
    )
{
    ULONG lStringLength;
    COORD WriteCoord;
    SHORT i;

    //
    // draw empty popup
    //

    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);
    lStringLength = POPUP_SIZE_X(Popup);
    for (i=0;i<POPUP_SIZE_Y(Popup);i++) {
        FillOutput(ScreenInfo,
                   Popup->Attributes,
                   WriteCoord,
                   CONSOLE_ATTRIBUTE,
                   &lStringLength
                  );
        FillOutput(ScreenInfo,
                   (WCHAR)' ',
                   WriteCoord,
                   CONSOLE_FALSE_UNICODE, // faster that real unicode
                   &lStringLength
                  );
        WriteCoord.Y += 1;
    }

    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);

    //
    // write prompt to screen
    //

    lStringLength = PromptLength;
    if (lStringLength > (ULONG)POPUP_SIZE_X(Popup))
    lStringLength = (ULONG)(POPUP_SIZE_X(Popup));
    WriteOutputString(ScreenInfo,
                      Prompt,
                      WriteCoord,
                      CONSOLE_REAL_UNICODE,
                      &lStringLength,
                      NULL
                     );
}

NTSTATUS
CopyFromCharPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the "delete up to this char" popup.  It puts up the
    popup, then calls ProcessCopyFromCharInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    WCHAR ItemString[70];
    int ItemLength;
    NTSTATUS Status;
    LANGID   LangId;

    Status = GetConsoleLangId(CookedReadData->ScreenInfo->Console->OutputCP, &LangId);
    if (NT_SUCCESS(Status)) {
        ItemLength = LoadStringEx(ghInstance,msgCmdLineF4,ItemString,70,LangId);
    }
    if (!NT_SUCCESS(Status) || ItemLength == 0) {
        ItemLength = LoadString(ghInstance,msgCmdLineF4,ItemString,70);
    }

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    DrawPromptPopup(Popup,
                    CookedReadData->ScreenInfo,
                    ItemString,
                    ItemLength
                   );
    Popup->PopupInputRoutine = ProcessCopyFromCharInput;
    return ProcessCopyFromCharInput(CookedReadData,
                                  WaitReplyMessage,
                                  WaitingThread,
                                  WaitRoutine);
}


NTSTATUS
CopyToCharPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the "delete up to this char" popup.  It puts up the
    popup, then calls ProcessCopyToCharInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    WCHAR ItemString[70];
    int ItemLength;
    NTSTATUS Status;
    LANGID   LangId;

    Status = GetConsoleLangId(CookedReadData->ScreenInfo->Console->OutputCP, &LangId);
    if (NT_SUCCESS(Status)) {
        ItemLength = LoadStringEx(ghInstance,msgCmdLineF2,ItemString,70,LangId);
    }
    if (!NT_SUCCESS(Status) || ItemLength == 0) {
        ItemLength = LoadString(ghInstance,msgCmdLineF2,ItemString,70);
    }

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
    DrawPromptPopup(Popup,
                    CookedReadData->ScreenInfo,
                    ItemString,
                    ItemLength
                   );
    Popup->PopupInputRoutine = ProcessCopyToCharInput;
    return ProcessCopyToCharInput(CookedReadData,
                                  WaitReplyMessage,
                                  WaitingThread,
                                  WaitRoutine);
}

NTSTATUS
CommandNumberPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the "enter command number" popup.  It puts up the
    popup, then calls ProcessCommandNumberInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    COORD CursorPosition;
    WCHAR ItemString[70];
    int ItemLength;
    NTSTATUS Status;
    LANGID   LangId;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    Status = GetConsoleLangId(CookedReadData->ScreenInfo->Console->OutputCP, &LangId);
    if (NT_SUCCESS(Status)) {
        ItemLength = LoadStringEx(ghInstance,msgCmdLineF9,ItemString,70,LangId);
    }
    if (!NT_SUCCESS(Status) || ItemLength == 0) {
        ItemLength = LoadString(ghInstance,msgCmdLineF9,ItemString,70);
    }

    if (ItemLength > POPUP_SIZE_X(Popup) - COMMAND_NUMBER_LENGTH) {
        ItemLength = POPUP_SIZE_X(Popup) - COMMAND_NUMBER_LENGTH;
    }
    DrawPromptPopup(Popup,
                    CookedReadData->ScreenInfo,
                    ItemString,
                    ItemLength
                   );
    CursorPosition.X = (SHORT)(Popup->Region.Right - MINIMUM_COMMAND_PROMPT_SIZE);
    CursorPosition.Y = (SHORT)(Popup->Region.Top+1);
    SetCursorPosition(CookedReadData->ScreenInfo,
                      CursorPosition,
                      TRUE
                     );
    Popup->NumberRead=0;
    Popup->PopupInputRoutine = ProcessCommandNumberInput;
    return ProcessCommandNumberInput(CookedReadData,
                                     WaitReplyMessage,
                                     WaitingThread,
                                     WaitRoutine);
}


PCOMMAND
GetLastCommand(
    IN PCOMMAND_HISTORY CommandHistory)
{
    if (CommandHistory->NumberOfCommands == 0) {
        return NULL;
    } else {
        return CommandHistory->Commands[CommandHistory->LastDisplayed];
    }
}

VOID
EmptyCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory)
{
    SHORT i;

    if (CommandHistory == NULL) {
        return;
    }

    for (i = 0; i < CommandHistory->NumberOfCommands; i++) {
        ConsoleHeapFree(CommandHistory->Commands[i]);
    }

    CommandHistory->NumberOfCommands = 0;
    CommandHistory->LastAdded = -1;
    CommandHistory->LastDisplayed = -1;
    CommandHistory->FirstCommand = 0;
    CommandHistory->Flags = CLE_RESET;
}

BOOL
AtFirstCommand(
    IN PCOMMAND_HISTORY CommandHistory)
{
    SHORT i;

    if (CommandHistory == NULL) {
        return FALSE;
    }

    if (CommandHistory->Flags & CLE_RESET) {
        return FALSE;
    }

    i = (SHORT)(CommandHistory->LastDisplayed - 1);
    if (i == -1) {
        i = (SHORT)(CommandHistory->NumberOfCommands - 1);
    }

    return (i == CommandHistory->LastAdded);
}

BOOL
AtLastCommand(
    IN PCOMMAND_HISTORY CommandHistory)
{
    if (CommandHistory == NULL) {
        return FALSE;
    } else {
        return (CommandHistory->LastDisplayed == CommandHistory->LastAdded);
    }
}

NTSTATUS
ProcessCommandLine(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine process command line editing keys.

    Return Value:

    CONSOLE_STATUS_WAIT - CommandListPopup ran out of input
    CONSOLE_STATUS_READ_COMPLETE - user hit <enter> in CommandListPopup
    STATUS_SUCCESS - everything's cool

--*/

{
    COORD CurrentPosition;
    DWORD CharsToWrite;
    NTSTATUS Status;
    BOOL UpdateCursorPosition;
    SHORT ScrollY=0;
    BOOL fStartFromDelim;

    UpdateCursorPosition = FALSE;
    if (Char == VK_F7 &&
        !(KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED))) {
        COORD PopupSize;

        if (CookedReadData->CommandHistory &&
            CookedReadData->CommandHistory->NumberOfCommands) {
            PopupSize.X = 40;
            PopupSize.Y = 10;
            Status = BeginPopup(CookedReadData->ScreenInfo,
                       CookedReadData->CommandHistory,
                       PopupSize
                      );
            if (NT_SUCCESS(Status)) {
                // CommandListPopup does EndPopup call
                return CommandListPopup(CookedReadData,
                                        WaitReplyMessage,
                                        WaitingThread,
                                        WaitRoutine
                                       );
            }
        }
    } else {
        switch (Char) {
            case VK_ESCAPE:
                DeleteCommandLine(CookedReadData,
                                  TRUE);
                break;
            case VK_UP:
            case VK_DOWN:
            case VK_F5:
                if (Char == VK_F5)
                    Char = VK_UP;
                // for doskey compatibility, buffer isn't circular
                if (Char==VK_UP && !AtFirstCommand(CookedReadData->CommandHistory) ||
                    Char==VK_DOWN && !AtLastCommand(CookedReadData->CommandHistory)) {
                    DeleteCommandLine(CookedReadData,
                                      TRUE);
                    Status = RetrieveCommand(CookedReadData->CommandHistory,
                                             Char,
                                             CookedReadData->BackupLimit,
                                             CookedReadData->BufferSize,
                                             &CookedReadData->BytesRead);
                    UserAssert(CookedReadData->BackupLimit == CookedReadData->BufPtr);
                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                CookedReadData->BackupLimit,
                                CookedReadData->BufPtr,
                                CookedReadData->BufPtr,
                                &CookedReadData->BytesRead,
                                (PLONG)&CookedReadData->NumberOfVisibleChars,
                                CookedReadData->OriginalCursorPosition.X,
                                WC_DESTRUCTIVE_BACKSPACE |
                                        WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                &ScrollY );
                        UserAssert(NT_SUCCESS(Status));
                        CookedReadData->OriginalCursorPosition.Y += ScrollY;
                    }
                    CharsToWrite = CookedReadData->BytesRead/sizeof(WCHAR);
                    CookedReadData->CurrentPosition = CharsToWrite;
                    CookedReadData->BufPtr = CookedReadData->BackupLimit + CharsToWrite;
                }
                break;
            case VK_PRIOR:
            case VK_NEXT:
                if (CookedReadData->CommandHistory &&
                    CookedReadData->CommandHistory->NumberOfCommands) {

                //
                // display oldest or newest command
                //

                SHORT CommandNumber;
                if (Char == VK_PRIOR) {
                    CommandNumber = 0;
                } else {
                    CommandNumber = (SHORT)(CookedReadData->CommandHistory->NumberOfCommands-1);
                }
                DeleteCommandLine(CookedReadData,
                                  TRUE);
                Status = RetrieveNthCommand(CookedReadData->CommandHistory,
                                            COMMAND_NUM_TO_INDEX(CommandNumber,CookedReadData->CommandHistory),
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BufferSize,
                                            &CookedReadData->BytesRead);
                UserAssert(CookedReadData->BackupLimit == CookedReadData->BufPtr);
                if (CookedReadData->Echo) {
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        &CookedReadData->BytesRead,
                                        (PLONG)&CookedReadData->NumberOfVisibleChars,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY
                                        );
                    UserAssert(NT_SUCCESS(Status));
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                }
                CharsToWrite = CookedReadData->BytesRead/sizeof(WCHAR);
                CookedReadData->CurrentPosition = CharsToWrite;
                CookedReadData->BufPtr = CookedReadData->BackupLimit + CharsToWrite;
                }
                break;
            case VK_END:
                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    DeleteCommandLine(CookedReadData,
                                      FALSE);
                    CookedReadData->BytesRead = CookedReadData->CurrentPosition*sizeof(WCHAR);
                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            &CookedReadData->BytesRead,
                                            (PLONG)&CookedReadData->NumberOfVisibleChars,
                                            CookedReadData->OriginalCursorPosition.X,
                                            WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                            NULL
                                            );
                        UserAssert(NT_SUCCESS(Status));
                    }
                } else {
                    CookedReadData->CurrentPosition = CookedReadData->BytesRead/sizeof(WCHAR);
                    CookedReadData->BufPtr = CookedReadData->BackupLimit + CookedReadData->CurrentPosition;
                    CurrentPosition.X = (SHORT)(CookedReadData->OriginalCursorPosition.X + CookedReadData->NumberOfVisibleChars);
                    CurrentPosition.Y = CookedReadData->OriginalCursorPosition.Y;
#if defined(FE_SB)
                    if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                            CookedReadData->ScreenInfo->Console->CP,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->CurrentPosition,
                                            CookedReadData->ScreenInfo->ScreenBufferSize.X-CookedReadData->OriginalCursorPosition.X,
                                            CookedReadData->OriginalCursorPosition.X,
                                            TRUE)) {
                        CurrentPosition.X++;
                    }
#endif
                    UpdateCursorPosition = TRUE;
                }
                break;
            case VK_HOME:
                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    DeleteCommandLine(CookedReadData,
                                      FALSE);
                    CookedReadData->BytesRead -= CookedReadData->CurrentPosition*sizeof(WCHAR);
                    CookedReadData->CurrentPosition = 0;
                    RtlCopyMemory(CookedReadData->BackupLimit,
                           CookedReadData->BufPtr,
                           CookedReadData->BytesRead
                           );
                    CookedReadData->BufPtr = CookedReadData->BackupLimit;
                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            &CookedReadData->BytesRead,
                                            (PLONG)&CookedReadData->NumberOfVisibleChars,
                                            CookedReadData->OriginalCursorPosition.X,
                                            WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                            NULL
                                            );
                        UserAssert(NT_SUCCESS(Status));
                    }
                    CurrentPosition = CookedReadData->OriginalCursorPosition;
                    UpdateCursorPosition = TRUE;
                } else {
                    CookedReadData->CurrentPosition = 0;
                    CookedReadData->BufPtr = CookedReadData->BackupLimit;
                    CurrentPosition = CookedReadData->OriginalCursorPosition;
                    UpdateCursorPosition = TRUE;
                }
                break;
            case VK_LEFT:
                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    PWCHAR LastWord;
                    BOOL NonSpaceCharSeen=FALSE;
                    if (CookedReadData->BufPtr != CookedReadData->BackupLimit) {
                        if (!gExtendedEditKey) {
                            LastWord = CookedReadData->BufPtr-1;
                            while (LastWord != CookedReadData->BackupLimit) {
                                if (!IS_WORD_DELIM(*LastWord)) {
                                    NonSpaceCharSeen=TRUE;
                                } else {
                                    if (NonSpaceCharSeen) {
                                        break;
                                    }
                                }
                                LastWord--;
                            }
                            if (LastWord != CookedReadData->BackupLimit) {
                                CookedReadData->BufPtr = LastWord+1;
                            } else {
                                CookedReadData->BufPtr = LastWord;
                            }
                        } else {
                            /*
                             * A bit better word skipping.
                             */
                            LastWord = CookedReadData->BufPtr - 1;
                            if (LastWord != CookedReadData->BackupLimit) {
                                if (*LastWord == L' ') {
                                    /*
                                     * Skip spaces, until the non-space character is found.
                                     */
                                    while (--LastWord != CookedReadData->BackupLimit) {
                                        UserAssert(LastWord > CookedReadData->BackupLimit);
                                        if (*LastWord != L' ') {
                                            break;
                                        }
                                    }
                                }
                                if (LastWord != CookedReadData->BackupLimit) {
                                    if (IS_WORD_DELIM(*LastWord)) {
                                        /*
                                         * Skip WORD_DELIMs until space or non WORD_DELIM is found.
                                         */
                                        while (--LastWord != CookedReadData->BackupLimit) {
                                            UserAssert(LastWord > CookedReadData->BackupLimit);
                                            if (*LastWord == L' ' || !IS_WORD_DELIM(*LastWord)) {
                                                break;
                                            }
                                        }
                                    } else {
                                        /*
                                         * Skip the regular words
                                         */
                                        while (--LastWord != CookedReadData->BackupLimit) {
                                            UserAssert(LastWord > CookedReadData->BackupLimit);
                                            if (IS_WORD_DELIM(*LastWord)) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            UserAssert(LastWord >= CookedReadData->BackupLimit);
                            if (LastWord != CookedReadData->BackupLimit) {
                                /*
                                 * LastWord is currently pointing to the last character
                                 * of the previous word, unless it backed up to the beginning
                                 * of the buffer.
                                 * Let's increment LastWord so that it points to the expeced
                                 * insertion point.
                                 */
                                ++LastWord;
                            }
                            CookedReadData->BufPtr = LastWord;
                        }
                        CookedReadData->CurrentPosition=(ULONG)(CookedReadData->BufPtr-CookedReadData->BackupLimit);
                        CurrentPosition = CookedReadData->OriginalCursorPosition;
                        // FE_SB
                        CurrentPosition.X = (SHORT)(CurrentPosition.X +
                            RetrieveTotalNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                        CookedReadData->BackupLimit,
                                                        CookedReadData->CurrentPosition,
                                                        CookedReadData->ScreenInfo->Console));
                        if (CheckBisectStringW(CookedReadData->ScreenInfo,
                                               CookedReadData->ScreenInfo->Console->CP,
                                               CookedReadData->BackupLimit,
                                               CookedReadData->CurrentPosition+1,
                                               CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                -CookedReadData->OriginalCursorPosition.X
                                               )) {
                            CurrentPosition.X++;
                        }
                        // end FE_SB
                        UpdateCursorPosition = TRUE;
                    }
                } else {
                    if (CookedReadData->BufPtr != CookedReadData->BackupLimit) {
                        CookedReadData->BufPtr--;
                        CookedReadData->CurrentPosition--;
                        CurrentPosition.X = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
                        CurrentPosition.Y = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
#if defined(FE_SB)
                        CurrentPosition.X = (SHORT)(CurrentPosition.X -
                            RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition,
                                                   CookedReadData->ScreenInfo->Console,
                                                   CookedReadData->ScreenInfo->Console->CP));
                        if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                                CookedReadData->ScreenInfo->Console->CP,
                                                CookedReadData->BackupLimit,
                                                CookedReadData->CurrentPosition+2,
                                                CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                 -CookedReadData->OriginalCursorPosition.X,
                                                CookedReadData->OriginalCursorPosition.X,
                                                TRUE)) {
                            if ((CurrentPosition.X == -2) ||
                                (CurrentPosition.X == -1)) {
                                CurrentPosition.X--;
                            }
                        }
#else
                        CurrentPosition.X = (SHORT)(CurrentPosition.X - RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                                    CookedReadData->BackupLimit,
                                                                    CookedReadData->CurrentPosition));
#endif
                        UpdateCursorPosition = TRUE;
                    }
                }
                break;
            case VK_RIGHT:
            case VK_F1:

                //
                // we don't need to check for end of buffer here because we've
                // already done it.
                //

                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    if (Char != VK_F1) {
                        if (CookedReadData->CurrentPosition < (CookedReadData->BytesRead/sizeof(WCHAR))) {
                            PWCHAR NextWord = CookedReadData->BufPtr;

                            if (!gExtendedEditKey) {
                                SHORT i;

                                for (i=(SHORT)(CookedReadData->CurrentPosition);
                                     i<(SHORT)((CookedReadData->BytesRead-1)/sizeof(WCHAR));
                                     i++) {
                                    if (IS_WORD_DELIM(*NextWord)) {
                                        i++;
                                        NextWord++;
                                        while ((i<(SHORT)((CookedReadData->BytesRead-1)/sizeof(WCHAR))) &&
                                               IS_WORD_DELIM(*NextWord)) {
                                            i++;
                                            NextWord++;
                                        }
                                        break;
                                    }
                                    NextWord++;
                                }
                            } else {
                                /*
                                 * A bit better word skipping.
                                 */
                                PWCHAR BufLast = CookedReadData->BackupLimit + CookedReadData->BytesRead / sizeof(WCHAR);

                                UserAssert(NextWord < BufLast);
                                if (*NextWord == L' ') {
                                    /*
                                     * If the current character is space,
                                     * skip to the next non-space character.
                                     */
                                    while (NextWord < BufLast) {
                                        if (*NextWord != L' ') {
                                            break;
                                        }
                                        ++NextWord;
                                    }
                                } else {
                                    /*
                                     * Skip the body part.
                                     */
                                    BOOL fStartFromDelim = IS_WORD_DELIM(*NextWord);

                                    while (++NextWord < BufLast) {
                                        if (fStartFromDelim != IS_WORD_DELIM(*NextWord)) {
                                            break;
                                        }
                                    }
                                    /*
                                     * Skip the space block.
                                     */
                                    if (NextWord < BufLast && *NextWord == L' ') {
                                        while (++NextWord < BufLast) {
                                            if (*NextWord != L' ') {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            CookedReadData->BufPtr = NextWord;
                            CookedReadData->CurrentPosition=(ULONG)(CookedReadData->BufPtr-CookedReadData->BackupLimit);
                            // FE_SB
                            CurrentPosition = CookedReadData->OriginalCursorPosition;
                            CurrentPosition.X = (SHORT)(CurrentPosition.X +
                                RetrieveTotalNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                            CookedReadData->BackupLimit,
                                                            CookedReadData->CurrentPosition,
                                                            CookedReadData->ScreenInfo->Console));
                            if (CheckBisectStringW(CookedReadData->ScreenInfo,
                                                   CookedReadData->ScreenInfo->Console->CP,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition+1,
                                                   CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                    -CookedReadData->OriginalCursorPosition.X
                                                   )) {
                                CurrentPosition.X++;
                            }
                            // end FE_SB
                            UpdateCursorPosition = TRUE;
                        }
                    }
                } else {

                    //
                    // if not at the end of the line, move cursor position right
                    //

                    if (CookedReadData->CurrentPosition < (CookedReadData->BytesRead/sizeof(WCHAR))) {
                        CurrentPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
#if defined(FE_SB)
                        CurrentPosition.X = (SHORT)(CurrentPosition.X +
                            RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition,
                                                   CookedReadData->ScreenInfo->Console,
                                                   CookedReadData->ScreenInfo->Console->CP));
                        if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                                CookedReadData->ScreenInfo->Console->CP,
                                                CookedReadData->BackupLimit,
                                                CookedReadData->CurrentPosition+2,
                                                CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                 -CookedReadData->OriginalCursorPosition.X,
                                                CookedReadData->OriginalCursorPosition.X,
                                                TRUE)) {
                            if (CurrentPosition.X == (CookedReadData->ScreenInfo->ScreenBufferSize.X-1))
                                CurrentPosition.X++;
                        }
#else
                        CurrentPosition.X = (SHORT)(CurrentPosition.X + RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                                    CookedReadData->BackupLimit,
                                                                    CookedReadData->CurrentPosition));
#endif
                        CookedReadData->BufPtr++;
                        CookedReadData->CurrentPosition++;
                        UpdateCursorPosition = TRUE;

                    //
                    // if at the end of the line, copy a character from the
                    // same position in the last command
                    //

                    } else if (CookedReadData->CommandHistory) {
                        PCOMMAND LastCommand;
                        DWORD NumSpaces;
                        LastCommand = GetLastCommand(CookedReadData->CommandHistory);
                        if (LastCommand && (USHORT)(LastCommand->CommandLength/sizeof(WCHAR)) > (USHORT)CookedReadData->CurrentPosition) {
                            *CookedReadData->BufPtr = LastCommand->Command[CookedReadData->CurrentPosition];
                            CookedReadData->BytesRead += sizeof(WCHAR);
                            CookedReadData->CurrentPosition++;
                            if (CookedReadData->Echo) {
                                CharsToWrite = sizeof(WCHAR);
                                Status = WriteCharsFromInput(
                                        CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        &CharsToWrite,
                                        (PLONG)&NumSpaces,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY);
                                UserAssert(NT_SUCCESS(Status));
                                CookedReadData->OriginalCursorPosition.Y += ScrollY;
                                CookedReadData->NumberOfVisibleChars += NumSpaces;
                            }
                            CookedReadData->BufPtr+=1;
                        }
                    }
                }
                break;
            case VK_F2:

                //
                // copy the previous command to the current command, up to but
                // not including the character specified by the user.  the user
                // is prompted via popup to enter a character.
                //

                if (CookedReadData->CommandHistory) {
                    COORD PopupSize;

                    PopupSize.X = COPY_TO_CHAR_PROMPT_LENGTH+2;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                               CookedReadData->CommandHistory,
                               PopupSize
                              );
                    if (NT_SUCCESS(Status)) {
                        // CopyToCharPopup does EndPopup call
                        return CopyToCharPopup(CookedReadData,
                                               WaitReplyMessage,
                                               WaitingThread,
                                               WaitRoutine
                                              );
                    }
                }
                break;
            case VK_F3:

                //
                // copy the remainder of the previous command to the current command.
                //

                if (CookedReadData->CommandHistory) {
                    PCOMMAND LastCommand;
                    DWORD NumSpaces;
                    int j;  // chars, not bytes
                    LastCommand = GetLastCommand(CookedReadData->CommandHistory);
                    if (LastCommand && (USHORT)(LastCommand->CommandLength/sizeof(WCHAR)) > (USHORT)CookedReadData->CurrentPosition) {
                        j = (LastCommand->CommandLength/sizeof(WCHAR)) - CookedReadData->CurrentPosition;
                        RtlCopyMemory(CookedReadData->BufPtr,
                                &LastCommand->Command[CookedReadData->CurrentPosition],
                                j*sizeof(WCHAR)
                               );
                        CookedReadData->CurrentPosition += j;
                        j *= sizeof(WCHAR);
                        CookedReadData->BytesRead += j;
                        if (CookedReadData->Echo) {
                            Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    CookedReadData->BackupLimit,
                                    CookedReadData->BufPtr,
                                    CookedReadData->BufPtr,
                                    (PDWORD) &j,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    &ScrollY);
                            UserAssert(NT_SUCCESS(Status));
                            CookedReadData->OriginalCursorPosition.Y += ScrollY;
                            CookedReadData->NumberOfVisibleChars += NumSpaces;
                        }
                        CookedReadData->BufPtr+=j/sizeof(WCHAR);
                    }
                }
                break;
            case VK_F4:

                //
                // copy the previous command to the current command, from
                // the letter specified by the user.   the user
                // is prompted via popup to enter a character.
                //

                if (CookedReadData->CommandHistory) {
                    COORD PopupSize;

                    PopupSize.X = COPY_FROM_CHAR_PROMPT_LENGTH+2;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                               CookedReadData->CommandHistory,
                               PopupSize
                              );
                    if (NT_SUCCESS(Status)) {
                        // CopyFromCharPopup does EndPopup call
                        return CopyFromCharPopup(CookedReadData,
                                               WaitReplyMessage,
                                               WaitingThread,
                                               WaitRoutine
                                              );
                    }
                }
                break;
            case VK_F6:

                //
                // place a ctrl-z in the current command line
                //

                {
                DWORD NumSpaces;
                *CookedReadData->BufPtr = (WCHAR)0x1a; // ctrl-z
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->CurrentPosition++;
                if (CookedReadData->Echo) {
                    CharsToWrite = sizeof(WCHAR);
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        &CharsToWrite,
                                        (PLONG)&NumSpaces,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY
                                        );
                    UserAssert(NT_SUCCESS(Status));
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                    CookedReadData->NumberOfVisibleChars += NumSpaces;
                }
                CookedReadData->BufPtr+=1;
                }
                break;
            case VK_F7:
                if (KeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) {
                    if (CookedReadData->CommandHistory) {
                        EmptyCommandHistory(CookedReadData->CommandHistory);
                        CookedReadData->CommandHistory->Flags |= CLE_ALLOCATED;
                    }
                }
                break;
            case VK_F8:
                if (CookedReadData->CommandHistory) {
                    SHORT i;

                    //
                    // cycles through the stored commands that start with
                    // the characters in the current command
                    //

                    i = FindMatchingCommand(CookedReadData->CommandHistory,
                            CookedReadData->BackupLimit,
                            CookedReadData->CurrentPosition*sizeof(WCHAR),
                            CookedReadData->CommandHistory->LastDisplayed, 0);
                    if (i!=-1) {
                        SHORT CurrentPosition;
                        COORD CursorPosition;

                        //
                        // save cursor position
                        //

                        CurrentPosition = (SHORT)CookedReadData->CurrentPosition;
                        CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;

                        DeleteCommandLine(CookedReadData,
                                          TRUE);
                        Status = RetrieveNthCommand(CookedReadData->CommandHistory,
                                                    i,
                                                    CookedReadData->BackupLimit,
                                                    CookedReadData->BufferSize,
                                                    &CookedReadData->BytesRead);
                        UserAssert(CookedReadData->BackupLimit == CookedReadData->BufPtr);
                        if (CookedReadData->Echo) {
                            Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    CookedReadData->BackupLimit,
                                    CookedReadData->BufPtr,
                                    CookedReadData->BufPtr,
                                    &CookedReadData->BytesRead,
                                    (PLONG)&CookedReadData->NumberOfVisibleChars,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    &ScrollY);
                            UserAssert(NT_SUCCESS(Status));
                            CookedReadData->OriginalCursorPosition.Y += ScrollY;
                        }
                        CursorPosition.Y += ScrollY;

                        //
                        // restore cursor position
                        //

                        CookedReadData->BufPtr = CookedReadData->BackupLimit + CurrentPosition;
                        CookedReadData->CurrentPosition = CurrentPosition;
                        Status = SetCursorPosition(CookedReadData->ScreenInfo,
                                                   CursorPosition,
                                                   TRUE);
                        UserAssert(NT_SUCCESS(Status));
                    }
                }
                break;
            case VK_F9:

                //
                // prompt the user to enter the desired command number.
                // copy that command to the command line.
                //

                {
                COORD PopupSize;

                if (CookedReadData->CommandHistory &&
                    CookedReadData->CommandHistory->NumberOfCommands &&
                    CookedReadData->ScreenInfo->ScreenBufferSize.X >= MINIMUM_COMMAND_PROMPT_SIZE+2) {  // 2 is for border
                    PopupSize.X = COMMAND_NUMBER_PROMPT_LENGTH+COMMAND_NUMBER_LENGTH;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                                        CookedReadData->CommandHistory,
                                        PopupSize
                                       );
                    if (NT_SUCCESS(Status)) {
                        // CommandNumberPopup does EndPopup call
                        return CommandNumberPopup(CookedReadData,
                                                  WaitReplyMessage,
                                                  WaitingThread,
                                                  WaitRoutine
                                                 );
                    }
                }
                }
                break;
            case VK_F10:
                if (KeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) {
                    ClearAliases(CookedReadData->Console);
                }
                break;
            case VK_INSERT:
                CookedReadData->InsertMode = !CookedReadData->InsertMode;
                SetCursorMode(CookedReadData->ScreenInfo,
                              (BOOLEAN)(CookedReadData->InsertMode != CookedReadData->Console->InsertMode));
                break;
        case VK_DELETE:
                if (!AT_EOL(CookedReadData)) {
                    COORD CursorPosition;

                    fStartFromDelim = IS_WORD_DELIM(*CookedReadData->BufPtr);

del_repeat:
                    //
                    // save cursor position
                    //

                    CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;

                    //
                    // deletecommandline
                    //

                    DeleteCommandLine(CookedReadData,
                                      FALSE);
                    //
                    // delete char
                    //

                    CookedReadData->BytesRead -= sizeof(WCHAR);
                    RtlCopyMemory(CookedReadData->BufPtr,
                           CookedReadData->BufPtr+1,
                           CookedReadData->BytesRead - (CookedReadData->CurrentPosition*sizeof(WCHAR))
                          );

#if defined(FE_SB)
                    {
                        PWCHAR buf = (PWCHAR)((PBYTE)CookedReadData->BackupLimit +
                                                     CookedReadData->BytesRead    );
                        *buf = (WCHAR)' ';
                    }
#endif
                    //
                    // write commandline
                    //

                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                &CookedReadData->BytesRead,
                                (PLONG)&CookedReadData->NumberOfVisibleChars,
                                CookedReadData->OriginalCursorPosition.X,
                                WC_DESTRUCTIVE_BACKSPACE |
                                        WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                NULL);
                        UserAssert(NT_SUCCESS(Status));
                    }

                    //
                    // restore cursor position
                    //

                    if (CONSOLE_IS_DBCS_ENABLED() && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                        if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                                CookedReadData->ScreenInfo->Console->CP,
                                                CookedReadData->BackupLimit,
                                                CookedReadData->CurrentPosition+1,
                                                CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                 -CookedReadData->OriginalCursorPosition.X,
                                                CookedReadData->OriginalCursorPosition.X,
                                                TRUE)) {
                            CursorPosition.X++;
                        }
                        CurrentPosition = CursorPosition;
                        if (CookedReadData->Echo) {
                            Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                                          CurrentPosition,
                                                          TRUE,
                                                          NULL);
                            UserAssert(NT_SUCCESS(Status));
                        }
                    } else {
                        Status = SetCursorPosition(CookedReadData->ScreenInfo,
                                                   CursorPosition,
                                                   TRUE);
                        UserAssert(NT_SUCCESS(Status));
                    }

                    // If Ctrl key is pressed, delete a word.
                    // If the start point was word delimiter, just remove delimiters portion only.
                    if ((KeyState & CTRL_PRESSED) && !AT_EOL(CookedReadData) &&
                            fStartFromDelim ^ !IS_WORD_DELIM(*CookedReadData->BufPtr)) {
                        DBGPRINT(("Repeating it(%x).\n", *CookedReadData->BufPtr));
                        goto del_repeat;
                    }
                }
                break;
            default:
                UserAssert(FALSE);
                break;
        }
    }
    if (UpdateCursorPosition && CookedReadData->Echo) {
        Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                      CurrentPosition,
                                      TRUE,
                                      NULL);
        UserAssert(NT_SUCCESS(Status));
    }

    return STATUS_SUCCESS;
}

PCOMMAND RemoveCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN SHORT iDel)
{
    SHORT iFirst, iLast, iDisp, nDel;
    PCOMMAND *ppcFirst, *ppcDel, pcmdDel;

    iFirst = CommandHistory->FirstCommand;
    iLast = CommandHistory->LastAdded;
    iDisp = CommandHistory->LastDisplayed;

    if (CommandHistory->NumberOfCommands == 0) {
        return NULL;
    }

    nDel = COMMAND_INDEX_TO_NUM(iDel, CommandHistory);
    if ((nDel < COMMAND_INDEX_TO_NUM(iFirst, CommandHistory)) ||
            (nDel > COMMAND_INDEX_TO_NUM(iLast, CommandHistory))) {
        return NULL;
    }

    if (iDisp == iDel) {
        CommandHistory->LastDisplayed = -1;
    }

    ppcFirst = &(CommandHistory->Commands[iFirst]);
    ppcDel = &(CommandHistory->Commands[iDel]);
    pcmdDel = *ppcDel;

    if (iDel < iLast) {
        RtlCopyMemory(ppcDel, ppcDel+1, (iLast - iDel) * sizeof(PCOMMAND));
        if ((iDisp > iDel) && (iDisp <= iLast)) {
            COMMAND_IND_DEC(iDisp, CommandHistory);
        }
        COMMAND_IND_DEC(iLast, CommandHistory);
    } else if (iFirst <= iDel) {
        RtlMoveMemory(ppcFirst+1, ppcFirst, (iDel - iFirst) * sizeof(PCOMMAND));
        if ((iDisp >= iFirst) && (iDisp < iDel)) {
            COMMAND_IND_INC(iDisp, CommandHistory);
        }
        COMMAND_IND_INC(iFirst, CommandHistory);
    }

    CommandHistory->FirstCommand = iFirst;
    CommandHistory->LastAdded = iLast;
    CommandHistory->LastDisplayed = iDisp;
    CommandHistory->NumberOfCommands--;
    return pcmdDel;
}


SHORT
FindMatchingCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR pwszIn,
    IN ULONG cbIn,                   // in bytes (!)
    IN SHORT CommandIndex,           // where to start from
    IN DWORD Flags
    )

/*++

    this routine finds the most recent command that starts with
    the letters already in the current command.  it returns the
    array index (no mod needed).

--*/

{
    SHORT i;

    if (CommandHistory->NumberOfCommands == 0) {
        return -1;
    }
    if (!(Flags & FMCFL_JUST_LOOKING) && (CommandHistory->Flags & CLE_RESET)) {
        CommandHistory->Flags &= ~CLE_RESET;
    } else {
        COMMAND_IND_PREV(CommandIndex, CommandHistory);
    }
    if (cbIn == 0) {
        return CommandIndex;
    }
    for (i=0;i<CommandHistory->NumberOfCommands;i++) {
        PCOMMAND pcmdT = CommandHistory->Commands[CommandIndex];

        if ((!(Flags & FMCFL_EXACT_MATCH) && (cbIn <= pcmdT->CommandLength)) ||
                ((USHORT)cbIn == pcmdT->CommandLength)) {
            if (!my_wcsncmp(pcmdT->Command, pwszIn, (USHORT)cbIn)) {
                return CommandIndex;
            }
        }
        COMMAND_IND_PREV(CommandIndex, CommandHistory);
    }
    return -1;
}

VOID
DrawCommandListBorder(
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    COORD WriteCoord;
    ULONG Length;
    SHORT i;

    //
    // fill attributes of top line
    //
    WriteCoord.X = Popup->Region.Left;
    WriteCoord.Y = Popup->Region.Top;
    Length = POPUP_SIZE_X(Popup) + 2;
    FillOutput(ScreenInfo,
               Popup->Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &Length
              );
    //
    // draw upper left corner
    //
    Length = 1;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[UPPER_LEFT_CORNER],
#else
               (WCHAR)0x250c,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw upper bar
    //

    WriteCoord.X += 1;
    Length = POPUP_SIZE_X(Popup);
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[HORIZONTAL_LINE],
#else
               (WCHAR)0x2500,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw upper right corner
    //

    WriteCoord.X = Popup->Region.Right;
    Length = 1;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[UPPER_RIGHT_CORNER],
#else
               (WCHAR)0x2510,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    for (i=0;i<POPUP_SIZE_Y(Popup);i++) {
        WriteCoord.Y += 1;
        WriteCoord.X = Popup->Region.Left;

        //
        // fill attributes
        //

        Length = POPUP_SIZE_X(Popup) + 2;
        FillOutput(ScreenInfo,
                   Popup->Attributes,
                   WriteCoord,
                   CONSOLE_ATTRIBUTE,
                   &Length
                  );
        Length = 1;
        FillOutput(ScreenInfo,
#if defined(FE_SB)
                   ScreenInfo->LineChar[VERTICAL_LINE],
#else
                   (WCHAR)0x2502,
#endif
                   WriteCoord,
                   CONSOLE_REAL_UNICODE,
                   &Length
                  );
        WriteCoord.X = Popup->Region.Right;
        Length = 1;
        FillOutput(ScreenInfo,
#if defined(FE_SB)
                   ScreenInfo->LineChar[VERTICAL_LINE],
#else
                   (WCHAR)0x2502,
#endif
                   WriteCoord,
                   CONSOLE_REAL_UNICODE,
                   &Length
                  );
    }

    //
    // draw bottom line
    //
    // fill attributes of top line
    //

    WriteCoord.X = Popup->Region.Left;
    WriteCoord.Y = Popup->Region.Bottom;
    Length = POPUP_SIZE_X(Popup) + 2;
    FillOutput(ScreenInfo,
               Popup->Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &Length
              );
    //
    // draw bottom left corner
    //

    Length = 1;
    WriteCoord.X = Popup->Region.Left;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[BOTTOM_LEFT_CORNER],
#else
               (WCHAR)0x2514,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw lower bar
    //

    WriteCoord.X += 1;
    Length = POPUP_SIZE_X(Popup);
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[HORIZONTAL_LINE],
#else
               (WCHAR)0x2500,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw lower right corner
    //

    WriteCoord.X = Popup->Region.Right;
    Length = 1;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER],
#else
               (WCHAR)0x2518,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );
}

VOID
UpdateHighlight(
    IN PCLE_POPUP Popup,
    IN SHORT OldCurrentCommand, // command number, not index
    IN SHORT NewCurrentCommand,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    COORD WriteCoord;
    ULONG lStringLength;
    WORD Attributes;
    SHORT TopIndex;

    if (Popup->BottomIndex < POPUP_SIZE_Y(Popup)) {
        TopIndex = 0;
    } else {
        TopIndex = (SHORT)(Popup->BottomIndex-POPUP_SIZE_Y(Popup)+1);
    }
    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    lStringLength = POPUP_SIZE_X(Popup);

    WriteCoord.Y = (SHORT)(Popup->Region.Top+1+OldCurrentCommand-TopIndex);
    FillOutput(ScreenInfo,
               Popup->Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &lStringLength
              );

    //
    // highlight new command
    //

    WriteCoord.Y = (SHORT)(Popup->Region.Top+1+NewCurrentCommand-TopIndex);
    // inverted attributes
    Attributes = (WORD)(((Popup->Attributes << 4) & 0xf0) |
                        ((Popup->Attributes >> 4) & 0x0f));
    FillOutput(ScreenInfo,
               Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &lStringLength
              );
}

VOID
DrawCommandListPopup(
    IN PCLE_POPUP Popup,
    IN SHORT CurrentCommand,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    WORD Attributes;
    ULONG lStringLength,CommandNumberLength;
    CHAR CommandNumber[COMMAND_NUMBER_SIZE];
    PCHAR CommandNumberPtr;
    COORD WriteCoord;
    SHORT i;

    //
    // draw empty popup
    //

    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);
    lStringLength = POPUP_SIZE_X(Popup);
    for (i=0;i<POPUP_SIZE_Y(Popup);i++) {
        FillOutput(ScreenInfo,
                   Popup->Attributes,
                   WriteCoord,
                   CONSOLE_ATTRIBUTE,
                   &lStringLength
                  );
        FillOutput(ScreenInfo,
                   (WCHAR)' ',
                   WriteCoord,
                   CONSOLE_FALSE_UNICODE, // faster than real unicode
                   &lStringLength
                  );
        WriteCoord.Y += 1;
    }

    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);
    for (i=max((SHORT)(Popup->BottomIndex-POPUP_SIZE_Y(Popup)+1),0);i<=Popup->BottomIndex;i++) {

        //
        // write command number to screen
        //

        CommandNumberPtr = _itoa(i,CommandNumber,10);
        CommandNumberLength = (SHORT)lstrlenA(CommandNumberPtr);
        CommandNumber[CommandNumberLength] = ':';
        CommandNumber[CommandNumberLength+1] = ' ';
        CommandNumberLength+=2;
        if (CommandNumberLength > (ULONG)POPUP_SIZE_X(Popup))
            CommandNumberLength = (ULONG)POPUP_SIZE_X(Popup);
        WriteCoord.X = (SHORT)(Popup->Region.Left+1);
        WriteOutputString(ScreenInfo,
                          CommandNumberPtr,
                          WriteCoord,
                          CONSOLE_ASCII,
                          &CommandNumberLength,
                          NULL
                         );

        //
        // write command to screen
        //

        lStringLength = CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->CommandLength/sizeof(WCHAR);
#if defined(FE_SB)
        {
            DWORD lTmpStringLength;
            LONG lPopupLength;
            LPWSTR lpStr;

            lTmpStringLength = lStringLength;
            lPopupLength = POPUP_SIZE_X(Popup) - CommandNumberLength;
            lpStr = CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command;
            while (lTmpStringLength--) {
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,*lpStr++)) {
                    lPopupLength -= 2;
                } else {
                    lPopupLength--;
                }
                if (lPopupLength <= 0) {
                    lStringLength -= lTmpStringLength;
                    if (lPopupLength < 0)
                        lStringLength--;
                    break;
                }
            }
        }
#else
        if ((lStringLength+CommandNumberLength) > (ULONG)POPUP_SIZE_X(Popup))
            lStringLength = (ULONG)(POPUP_SIZE_X(Popup)-CommandNumberLength);
#endif
        WriteCoord.X = (SHORT)(WriteCoord.X + CommandNumberLength);
#if defined(FE_SB)
        {
            PWCHAR TransBuffer;

            TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, lStringLength * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return;
            }

            RtlCopyMemory(TransBuffer,CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command,lStringLength * sizeof(WCHAR));
            WriteOutputString(ScreenInfo,
                              TransBuffer,
                              WriteCoord,
                              CONSOLE_REAL_UNICODE,
                              &lStringLength,
                              NULL
                             );
            ConsoleHeapFree(TransBuffer);
        }
#else
        WriteOutputString(ScreenInfo,
                          CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command,
                          WriteCoord,
                          CONSOLE_REAL_UNICODE,
                          &lStringLength,
                          NULL
                         );
        // convert back to true unicode (got converted by WriteOutputString)
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            FalseUnicodeToRealUnicode(CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command,
                    lStringLength,
                    ScreenInfo->Console->OutputCP);
        }
#endif

        //
        // write attributes to screen
        //

        if (COMMAND_NUM_TO_INDEX(i,CommandHistory) == CurrentCommand) {
            WriteCoord.X = (SHORT)(Popup->Region.Left+1);
            // inverted attributes
            Attributes = (WORD)(((Popup->Attributes << 4) & 0xf0) |
                                ((Popup->Attributes >> 4) & 0x0f));
            lStringLength = POPUP_SIZE_X(Popup);
            FillOutput(ScreenInfo,
                       Attributes,
                       WriteCoord,
                       CONSOLE_ATTRIBUTE,
                       &lStringLength
                      );
        }

        WriteCoord.Y += 1;
    }
}

VOID
UpdateCommandListPopup(
    IN SHORT Delta,
    IN OUT PSHORT CurrentCommand,   // real index, not command #
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD Flags
    )
{
    SHORT Size;
    SHORT CurCmdNum;
    SHORT NewCmdNum;
    BOOL Scroll=FALSE;

    if (Delta == 0) {
        return;
    }
    Size = POPUP_SIZE_Y(Popup);

    if (Flags & UCLP_WRAP) {
        CurCmdNum = *CurrentCommand;
        NewCmdNum = CurCmdNum + Delta;
        NewCmdNum = COMMAND_INDEX_TO_NUM(NewCmdNum, CommandHistory);
        CurCmdNum = COMMAND_INDEX_TO_NUM(CurCmdNum, CommandHistory);
    } else {
        CurCmdNum = COMMAND_INDEX_TO_NUM(*CurrentCommand, CommandHistory);
        NewCmdNum = CurCmdNum + Delta;
        if (NewCmdNum >= CommandHistory->NumberOfCommands) {
            NewCmdNum = (SHORT)(CommandHistory->NumberOfCommands-1);
        } else if (NewCmdNum < 0) {
            NewCmdNum = 0;
        }
    }
    Delta = NewCmdNum - CurCmdNum;

    // determine amount to scroll, if any

    if (NewCmdNum <= Popup->BottomIndex-Size) {
        Popup->BottomIndex += Delta;
        if (Popup->BottomIndex < (SHORT)(Size-1)) {
            Popup->BottomIndex = (SHORT)(Size-1);
        }
        Scroll = TRUE;
    } else if (NewCmdNum > Popup->BottomIndex) {
        Popup->BottomIndex += Delta;
        if (Popup->BottomIndex >= CommandHistory->NumberOfCommands) {
            Popup->BottomIndex = (SHORT)(CommandHistory->NumberOfCommands-1);
        }
        Scroll = TRUE;
    }


    //
    // write commands to popup
    //
    if (Scroll) {
        DrawCommandListPopup(Popup,COMMAND_NUM_TO_INDEX(NewCmdNum,CommandHistory),CommandHistory,ScreenInfo);
    } else {
        UpdateHighlight(Popup,COMMAND_INDEX_TO_NUM((*CurrentCommand),CommandHistory),NewCmdNum,ScreenInfo);
    }
    *CurrentCommand = COMMAND_NUM_TO_INDEX(NewCmdNum,CommandHistory);
}

PCOMMAND_HISTORY
FindCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )

/*++

Routine Description:

    This routine marks the command history buffer freed.

Arguments:

    Console - pointer to console.

    ProcessHandle - handle to client process.

Return Value:

    none.

--*/

{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD(ListNext, COMMAND_HISTORY, ListLink);
        ListNext = ListNext->Flink;
        if (History->ProcessHandle == ProcessHandle) {
            UserAssert(History->Flags & CLE_ALLOCATED);
            return History;
        }
    }

    return NULL;
}

VOID
FreeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )

/*++

Routine Description:

    This routine marks the command history buffer freed.

Arguments:

    Console - pointer to console.

    ProcessHandle - handle to client process.

Return Value:

    none.

--*/

{
    PCOMMAND_HISTORY History;

    History = FindCommandHistory(Console,ProcessHandle);
    if (History) {
        History->Flags &= ~CLE_ALLOCATED;
        History->ProcessHandle = NULL;
    }
}


VOID
FreeCommandHistoryBuffers(
    IN OUT PCONSOLE_INFORMATION Console
    )
{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;
    SHORT i;

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;
        RemoveEntryList(&History->ListLink);
        if (History->AppName) {
            ConsoleHeapFree(History->AppName);
        }
        for (i=0;i<History->NumberOfCommands;i++) {
            ConsoleHeapFree(History->Commands[i]);
        }
        ConsoleHeapFree(History);
    }
}

VOID
ResizeCommandHistoryBuffers(
    IN PCONSOLE_INFORMATION Console,
    IN UINT NumCommands
    )
{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;
#if defined(FE_SB)
    PCOOKED_READ_DATA CookedReadData;
    PCOMMAND_HISTORY NewHistory;
#endif

    UserAssert(NumCommands <= 0xFFFF);
    Console->CommandHistorySize = (SHORT)NumCommands;

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;

#if defined(FE_SB)
        NewHistory = ReallocCommandHistory(Console, History, NumCommands);
        CookedReadData = Console->lpCookedReadData;
        if (CookedReadData && CookedReadData->CommandHistory == History) {
            CookedReadData->CommandHistory = NewHistory;
        }
#else
        if (!(History->Flags & CLE_ALLOCATED)) {
            ReallocCommandHistory(Console, History, NumCommands);
         }
#endif
    }
}

VOID
InitializeConsoleCommandData(
    IN PCONSOLE_INFORMATION Console
    )

/*++

Routine Description:

    This routine initializes the per-console commandline recall data structures.

Arguments:

    Console - pointer to console.

Return Value:

    none

--*/

{
    Console->NumCommandHistories = 0;
    InitializeListHead(&Console->CommandHistoryList);
}

VOID
ResetCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    )

/*++
    This routine is called when escape is entered or a command is added.

--*/

{
    if (CommandHistory == NULL) {
        return;
    }
    CommandHistory->LastDisplayed = CommandHistory->LastAdded;
    CommandHistory->Flags |= CLE_RESET;
}

NTSTATUS
AddCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR Command,
    IN USHORT Length,
    IN BOOL HistoryNoDup
    )
{
    PCOMMAND *ppCmd;

    if (CommandHistory == NULL || CommandHistory->MaximumNumberOfCommands == 0) {
        return STATUS_NO_MEMORY;
    }
    UserAssert(CommandHistory->Flags & CLE_ALLOCATED);

    if (Length == 0) {
        return STATUS_SUCCESS;
    }

    if (CommandHistory->NumberOfCommands == 0 ||
        CommandHistory->Commands[CommandHistory->LastAdded]->CommandLength != Length ||
        memcmp(CommandHistory->Commands[CommandHistory->LastAdded]->Command,Command,Length)) {

        PCOMMAND pCmdReuse = NULL;

        if (HistoryNoDup) {
            SHORT i;
            i = FindMatchingCommand(CommandHistory, Command, Length,
                    CommandHistory->LastDisplayed, FMCFL_EXACT_MATCH);
            if (i != -1) {
                pCmdReuse = RemoveCommand(CommandHistory, i);
            }
        }


        //
        // find free record.  if all records are used, free the lru one.
        //

        if (CommandHistory->NumberOfCommands < CommandHistory->MaximumNumberOfCommands) {
            CommandHistory->LastAdded += 1;
            CommandHistory->NumberOfCommands++;
        } else {
            COMMAND_IND_INC(CommandHistory->LastAdded, CommandHistory);
            COMMAND_IND_INC(CommandHistory->FirstCommand, CommandHistory);
            ConsoleHeapFree(CommandHistory->Commands[CommandHistory->LastAdded]);
            if (CommandHistory->LastDisplayed == CommandHistory->LastAdded) {
                CommandHistory->LastDisplayed = -1;
            }
        }

        if (CommandHistory->LastDisplayed == -1 ||
            CommandHistory->Commands[CommandHistory->LastDisplayed]->CommandLength != Length ||
                memcmp(CommandHistory->Commands[CommandHistory->LastDisplayed]->Command,Command,Length)) {
            ResetCommandHistory(CommandHistory);
        }

        //
        // add command to array
        //

        ppCmd = &CommandHistory->Commands[CommandHistory->LastAdded];
        if (pCmdReuse) {
            *ppCmd = pCmdReuse;
        } else {
            *ppCmd = ConsoleHeapAlloc(HISTORY_TAG,
                                      Length + sizeof(COMMAND));
            if (*ppCmd == NULL) {
                COMMAND_IND_PREV(CommandHistory->LastAdded, CommandHistory);
                CommandHistory->NumberOfCommands -= 1;
                return STATUS_NO_MEMORY;
            }
            (*ppCmd)->CommandLength = Length;
            RtlCopyMemory((*ppCmd)->Command,Command,Length);
        }
    }
    CommandHistory->Flags |= CLE_RESET; // remember that we've returned a cmd
    return STATUS_SUCCESS;
}

NTSTATUS
RetrieveCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN WORD VirtualKeyCode,
    IN PWCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG CommandSize)
{
    if (CommandHistory == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(CommandHistory->Flags & CLE_ALLOCATED);

    if (CommandHistory->NumberOfCommands == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    if (CommandHistory->NumberOfCommands == 1) {
        CommandHistory->LastDisplayed = 0;
    } else if (VirtualKeyCode == VK_UP) {

        //
        // if this is the first time for this read that a command has
        // been retrieved, return the current command.  otherwise, return
        // the previous command.
        //

        if (CommandHistory->Flags & CLE_RESET) {
            CommandHistory->Flags &= ~CLE_RESET;
        } else {
            COMMAND_IND_PREV(CommandHistory->LastDisplayed, CommandHistory);
        }
    } else {
        COMMAND_IND_NEXT(CommandHistory->LastDisplayed, CommandHistory);
    }
    return RetrieveNthCommand(CommandHistory,
                              CommandHistory->LastDisplayed,
                              Buffer,
                              BufferSize,
                              CommandSize
                             );
}

ULONG
SrvGetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETTITLE_MSG a = (PCONSOLE_GETTITLE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Title, a->TitleLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    // a->TitleLength contains length in bytes
    if (a->Unicode) {
        if ((USHORT)a->TitleLength > Console->TitleLength) {
            a->TitleLength = Console->TitleLength;
        }
        RtlCopyMemory(a->Title,Console->Title,a->TitleLength);
    } else {
#if defined(FE_SB)
        a->TitleLength = (USHORT)ConvertToOem(OEMCP,
                                        Console->Title,
                                        Console->TitleLength / sizeof(WCHAR),
                                        a->Title,
                                        a->TitleLength
                                        );
#else
        a->TitleLength = (USHORT)ConvertToOem(Console->CP,
                                        Console->Title,
                                        Console->TitleLength / sizeof(WCHAR),
                                        a->Title,
                                        a->TitleLength
                                        );
#endif
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETTITLE_MSG a = (PCONSOLE_SETTITLE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    LPWSTR NewTitle;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Title, a->TitleLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (!a->Unicode) {
        NewTitle = ConsoleHeapAlloc(TITLE_TAG,
                                    a->TitleLength * sizeof(WCHAR) + sizeof(WCHAR));
        if (NewTitle == NULL) {
            UnlockConsole(Console);
            return STATUS_NO_MEMORY;
        }

        // convert title to unicode

#if defined(FE_SB)
        Console->TitleLength = (USHORT)ConvertInputToUnicode(OEMCP,
                                                 a->Title,
                                                 a->TitleLength,
                                                 NewTitle,
                                                 a->TitleLength);
#else
        Console->TitleLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                                 a->Title,
                                                 a->TitleLength,
                                                 NewTitle,
                                                 a->TitleLength);
#endif
        Console->TitleLength *= 2;
    } else {
        // a->TitleLength contains length in bytes

        NewTitle = ConsoleHeapAlloc(TITLE_TAG, a->TitleLength + sizeof(WCHAR));
        if (NewTitle == NULL) {
            UnlockConsole(Console);
            return STATUS_NO_MEMORY;
        }
        Console->TitleLength = (USHORT)a->TitleLength;
        RtlCopyMemory(NewTitle,a->Title,a->TitleLength);
    }
    NewTitle[Console->TitleLength/sizeof(WCHAR)] = 0;   // NULL terminate
    ConsoleHeapFree(Console->Title);
    Console->Title = NewTitle;
    PostMessage(Console->hWnd, CM_UPDATE_TITLE, 0, 0);
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

int
LoadStringExW(
    IN HINSTANCE hModule,
    IN UINT      wID,
    OUT LPWSTR   lpBuffer,
    IN int       cchBufferMax,
    IN WORD      wLangId
    )
{
    HANDLE hResInfo;
    HANDLE hStringSeg;
    LPTSTR lpsz;
    int cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        return 0;
    }

    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FindResourceEx(hModule,
                                  RT_STRING,
                                  (LPTSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)),
                                  wLangId)) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);

        /*
         * Lock the resource.
         */
        if (lpsz = (LPTSTR)LockResource(hStringSeg)) {

            /*
             * Move past the other strings in this segment.
             * (16 strings in a segment -> & 0x0F)
             */
            wID &= 0x0F;
            while (TRUE) {
                cch = *((UTCHAR *)lpsz++);      // PASCAL like string count
                                                // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                    // Step to start if next string
            }

            /*
             * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
             */
            if (cchBufferMax == 0) {
                *(LPTSTR *)lpBuffer = lpsz;
            } else {

                /*
                 * Account for the NULL
                 */
                cchBufferMax--;

                /*
                 * Don't copy more than the max allowed.
                 */
                if (cch > cchBufferMax)
                    cch = cchBufferMax;

                /*
                 * Copy the string into the buffer.
                 */
                RtlCopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
            }
        }
    }

    /*
     * Append a NULL.
     */
    if (cchBufferMax != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\server.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    server.h

Abstract:

    This module contains the internal structures and definitions used
    by the console server.

Author:

    Therese Stowell (thereses) 12-Nov-1990

Revision History:

--*/

#ifndef _SERVER_H_
#define _SERVER_H_

//
// This message is used to notify the input thread that a console window should
// go away.
//

typedef struct _CONSOLE_SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG SharedRead;
    ULONG SharedWrite;
} CONSOLE_SHARE_ACCESS, *PCONSOLE_SHARE_ACCESS;

#include "input.h"
#include "output.h"
#if defined(FE_IME)
#include "conime.h"
#include "convarea.h"
#endif

typedef struct _CONSOLE_PROCESS_HANDLE {
    LIST_ENTRY ListLink;
    HANDLE ProcessHandle;
    PCSR_PROCESS Process;
    ULONG TerminateCount;
    LPTHREAD_START_ROUTINE CtrlRoutine;
    LPTHREAD_START_ROUTINE PropRoutine;
} CONSOLE_PROCESS_HANDLE, *PCONSOLE_PROCESS_HANDLE;

typedef struct _INPUT_THREAD_INFO {
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HDESK Desktop;
    HWINSTA WindowStation;
    ULONG WindowCount;
#if defined(FE_IME)
    HWND  hWndConsoleIME;
#endif
} INPUT_THREAD_INFO, *PINPUT_THREAD_INFO;

typedef struct _INPUT_THREAD_INIT_INFO {
    HANDLE ThreadHandle;
    HANDLE InitCompleteEventHandle;
    HDESK DesktopHandle;
    HWINSTA WinstaHandle;
    NTSTATUS InitStatus;
} INPUT_THREAD_INIT_INFO, *PINPUT_THREAD_INIT_INFO;

typedef struct _CONSOLE_MSG {
    LIST_ENTRY ListLink;
    UINT       Message;
    WPARAM     wParam;
    LPARAM     lParam;
} CONSOLE_MSG, *PCONSOLE_MSG;

typedef struct _CONSOLE_THREAD_MSG {
    CONSOLE_MSG;
    DWORD dwThreadId;
} CONSOLE_THREAD_MSG, *PCONSOLE_THREAD_MSG;

// Flags flags

#define CONSOLE_IS_ICONIC               0x00000001
#define CONSOLE_OUTPUT_SUSPENDED        0x00000002
#define CONSOLE_HAS_FOCUS               0x00000004
#define CONSOLE_IGNORE_NEXT_MOUSE_INPUT 0x00000008
#define CONSOLE_SELECTING               0x00000010
#define CONSOLE_SCROLLING               0x00000020
#define CONSOLE_DISABLE_CLOSE           0x00000040
#define CONSOLE_NOTIFY_LAST_CLOSE       0x00000080
#define CONSOLE_NO_WINDOW               0x00000100
#define CONSOLE_VDM_REGISTERED          0x00000200
#define CONSOLE_UPDATING_SCROLL_BARS    0x00000400
#define CONSOLE_QUICK_EDIT_MODE         0x00000800
#define CONSOLE_TERMINATING             0x00001000
#define CONSOLE_CONNECTED_TO_EMULATOR   0x00002000
#define CONSOLE_FULLSCREEN_NOPAINT      0x00004000
#define CONSOLE_SHUTTING_DOWN           0x00008000
#define CONSOLE_AUTO_POSITION           0x00010000
#define CONSOLE_IGNORE_NEXT_KEYUP       0x00020000
#define CONSOLE_WOW_REGISTERED          0x00040000
#define CONSOLE_USE_PRIVATE_FLAGS       0x00080000
#define CONSOLE_HISTORY_NODUP           0x00100000
#define CONSOLE_SCROLLBAR_TRACKING      0x00200000
#define CONSOLE_IN_DESTRUCTION          0x00400000
#define CONSOLE_SETTING_WINDOW_SIZE     0x00800000
#define CONSOLE_DEFAULT_BUFFER_SIZE     0x01000000
#define CONSOLE_VDM_HIDDEN_WINDOW       0x02000000
#if defined(FE_SB)
#define CONSOLE_OS2_REGISTERED          0x20000000
#define CONSOLE_OS2_OEM_FORMAT          0x40000000
#if defined(FE_IME)
#define CONSOLE_JUST_VDM_UNREGISTERED   0x80000000
#endif // FE_IME
#endif

#define CONSOLE_SUSPENDED (CONSOLE_OUTPUT_SUSPENDED)

#if DBG
typedef struct _CONSOLE_REF_NODE
{
    struct _CONSOLE_REF_NODE *pNext;

    PVOID pStackTrace[8];
    BOOL bRef;
} CONSOLE_REF_NODE, *PCONSOLE_REF_NODE;
#endif

typedef struct _CONSOLE_INFORMATION {
    CRITICAL_SECTION ConsoleLock;   // serialize input and output using this
    ULONG RefCount;
    ULONG WaitCount;
    INPUT_INFORMATION InputBuffer;
    PSCREEN_INFORMATION CurrentScreenBuffer;
    PSCREEN_INFORMATION ScreenBuffers;  // singly linked list
    HWINSTA hWinSta;                // server handle to windowstation
    HDESK hDesk;                    // server handle to desktop
    HWND hWnd;
    HKL hklActive;                  // keyboard layout for this console window
    HDC hDC;                        // server side hDC
    HMENU hMenu;                    // handle to system menu
    HMENU hHeirMenu;                // handle to menu we append to system menu
    HPALETTE hSysPalette;
    RECT WindowRect;
    DWORD ResizeFlags;
    LIST_ENTRY OutputQueue;
    HANDLE InitEvents[NUMBER_OF_INITIALIZATION_EVENTS];
    HANDLE ClientThreadHandle;
    LIST_ENTRY ProcessHandleList;
    LIST_ENTRY CommandHistoryList;
    LIST_ENTRY ExeAliasList;
    SHORT NumCommandHistories;
    SHORT MaxCommandHistories;
    SHORT CommandHistorySize;
    USHORT OriginalTitleLength;
    USHORT TitleLength;
    LPWSTR OriginalTitle;
    LPWSTR Title;
    DWORD dwHotKey;
    HICON hIcon;
    HICON hSmIcon;
    INT iIconId;
    WORD LastAttributes;
    BYTE ReserveKeys;           // keys reserved by app (i.e. ctrl-esc)
    DWORD Flags;

    // if a wait has been satisfied, the pointer to the wait queue is stored
    // here.

    PLIST_ENTRY WaitQueue;

    // the following fields are used for selection

    DWORD SelectionFlags;
    SMALL_RECT SelectionRect;
    COORD SelectionAnchor;
    COORD TextCursorPosition;   // current position on screen (in screen buffer coords).
    ULONG TextCursorSize;
    BOOLEAN TextCursorVisible;    // whether cursor is visible (set by user)

    BOOLEAN InsertMode;     // used by command line editing

    // following fields are used when window is created

    WORD wShowWindow;
    int dwWindowOriginX;
    int dwWindowOriginY;

    WORD FullScreenFlags;
    WORD PopupCount;

    // following fields are used for the VDM

    HANDLE VDMStartHardwareEvent;
    HANDLE VDMEndHardwareEvent;
    HANDLE VDMErrorHardwareEvent;
    HANDLE VDMProcessHandle;
    HANDLE VDMProcessId;

    HANDLE VDMBufferSectionHandle;
    PCHAR_INFO VDMBuffer;
    PCHAR_INFO VDMBufferClient;
    COORD VDMBufferSize;

    HANDLE StateSectionHandle; // used for get/sethardwarestate
    PVOID StateBuffer;
    PVOID StateBufferClient;
    DWORD StateLength;

    // the following fields are used for ansi-unicode translation

    UINT CP;
    UINT OutputCP;

    //
    // these two fields are used while getting the icon from the
    // program manager via DDE.
    //

    HWND hWndProgMan;
    BOOL bIconInit;

    HANDLE ConsoleHandle;

    ULONG CtrlFlags;            // indicates outstanding ctrl requests
    ULONG LimitingProcessId;
    HANDLE TerminationEvent;

    SHORT VerticalClientToWindow;
    SHORT HorizontalClientToWindow;

    COLORREF  ColorTable[ 16 ];
    HANDLE hProcessLastNotifyClose;     // process handle of last-close-notify
    HANDLE ProcessIdLastNotifyClose;    // process unique id of last-close-notify
    HWND hWndProperties;

    PINPUT_THREAD_INFO InputThreadInfo;     // console thread info

    LIST_ENTRY MessageQueue;

#if defined(FE_SB)
    CPINFO CPInfo;
    CPINFO OutputCPInfo;

    DWORD ReadConInpNumBytesUnicode;
    DWORD ReadConInpNumBytesTemp;

    DWORD WriteConOutNumBytesUnicode;
    DWORD WriteConOutNumBytesTemp;

    PVOID lpCookedReadData;             // Same as PCOOKED_READ_DATA

    PVOID EudcInformation;              // Same as PEUDC_INFORMATION

    PVOID FontCacheInformation;         // Same as PFONT_CACHE_INFORMATION

#if defined(FE_IME)
    CONSOLE_IME_INFORMATION ConsoleIme;
#endif // FE_IME

    HDC FonthDC;                        // Double colored DBCS hDC
    HBITMAP hBitmap;
#if defined(i386)
    SMALL_RECT Os2SavedWindowRect;
#endif
    BOOLEAN fVDMVideoMode;              // FALSE : VGA Format
                                        // TRUE  : Common LVB Format
    BOOLEAN fIsDBCSCP;
    BOOLEAN fIsDBCSOutputCP;
#endif

    /*
     * Instrumentation for Windows Bug 499641.
     */
#if DBG
    PVOID ConnectStack[16];
    PVOID DisconnectStack[16];
    PCONSOLE_REF_NODE pRefNodes;
#endif
    HANDLE UnlockConsoleOwningThread;
    DWORD UnlockConsoleSkipCount;
} CONSOLE_INFORMATION, *PCONSOLE_INFORMATION;

//
// CtrlFlags definitions
//

#define CONSOLE_CTRL_C_FLAG                     1
#define CONSOLE_CTRL_BREAK_FLAG                 2
#define CONSOLE_CTRL_CLOSE_FLAG                 4
#define CONSOLE_FORCE_SHUTDOWN_FLAG             8
#define CONSOLE_CTRL_LOGOFF_FLAG                16
#define CONSOLE_CTRL_SHUTDOWN_FLAG              32

#define ADD_SCROLL_BARS_X 0x1
#define REMOVE_SCROLL_BARS_X 0x2
#define ADD_SCROLL_BARS_Y 0x4
#define REMOVE_SCROLL_BARS_Y 0x8
#define RESIZE_SCROLL_BARS 0x10
#define SCROLL_BAR_CHANGE (ADD_SCROLL_BARS_X | REMOVE_SCROLL_BARS_X | ADD_SCROLL_BARS_Y | REMOVE_SCROLL_BARS_Y | RESIZE_SCROLL_BARS)
#define BORDER_CHANGE 0x20
#define SCREEN_BUFFER_CHANGE 0x40

#define CONSOLE_INITIAL_IO_HANDLES 3
#define CONSOLE_IO_HANDLE_INCREMENT 3

#define CONSOLE_FREE_HANDLE 0
//#define CONSOLE_INPUT_HANDLE 1
//#define CONSOLE_OUTPUT_HANDLE 2
#define CONSOLE_GRAPHICS_OUTPUT_HANDLE 4
#define CONSOLE_INHERITABLE 8
#define CONSOLE_ANY_HANDLE ((ULONG)(-1))

//
// input handle flags
//

#define HANDLE_CLOSING 1
#define HANDLE_INPUT_PENDING 2
#define HANDLE_MULTI_LINE_INPUT 4

typedef struct _HANDLE_DATA {
    ULONG HandleType;
    ACCESS_MASK Access;
    ULONG ShareAccess;
    union {
        PSCREEN_INFORMATION ScreenBuffer;
        PINPUT_INFORMATION InputBuffer;
    } Buffer;
    PINPUT_READ_HANDLE_DATA InputReadData; // used only by input reads
} HANDLE_DATA, *PHANDLE_DATA;

typedef struct _CONSOLE_PER_PROCESS_DATA {
    HANDLE ConsoleHandle;
    HANDLE_DATA HandleTable[CONSOLE_INITIAL_IO_HANDLES];
    ULONG HandleTableSize;
    PHANDLE_DATA HandleTablePtr;
    BOOLEAN ConsoleApp;
    BOOLEAN RootProcess;
    DWORD ParentProcessId;
#if defined(FE_IME)
    HDESK hDesk;
    HWINSTA hWinSta;
#endif
} CONSOLE_PER_PROCESS_DATA, *PCONSOLE_PER_PROCESS_DATA;

#define CONSOLE_INITIAL_CONSOLES 10
#define CONSOLE_CONSOLE_HANDLE_INCREMENT 5
#define CONSOLE_HANDLE_ALLOCATED 1

#define INDEX_TO_HANDLE(INDEX) ((HANDLE)(((ULONG_PTR)INDEX << 2) | CONSOLE_HANDLE_SIGNATURE))
#define HANDLE_TO_INDEX(CONHANDLE) ((HANDLE)((ULONG_PTR)CONHANDLE >> 2))

#define INPUT_MODES (ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT | ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT)
#define OUTPUT_MODES (ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT)
#define PRIVATE_MODES (ENABLE_INSERT_MODE | ENABLE_QUICK_EDIT_MODE | ENABLE_PRIVATE_FLAGS)

#define CURSOR_PERCENTAGE_TO_TOP_SCAN_LINE(FONTSIZE,PERCENTAGE) ((FONTSIZE) - ((FONTSIZE) * (PERCENTAGE) / 100))

#define ConsoleLocked(CONSOLEPTR) (((CONSOLEPTR)->ConsoleLock.OwningThread) == NtCurrentTeb()->ClientId.UniqueThread)

#define CONSOLE_STATUS_WAIT ((NTSTATUS)0xC0030001L)
#define CONSOLE_STATUS_READ_COMPLETE ((NTSTATUS)0xC0030002L)
#define CONSOLE_STATUS_WAIT_NO_BLOCK ((NTSTATUS)0xC0030003L)

#define CM_CREATE_CONSOLE_WINDOW (WM_USER+0)
#define CM_DESTROY_WINDOW        (WM_USER+1)
#define CM_SET_WINDOW_SIZE       (WM_USER+2)
#define CM_BEEP                  (WM_USER+3)
#define CM_UPDATE_SCROLL_BARS    (WM_USER+4)
#define CM_UPDATE_TITLE          (WM_USER+5)
//
// CM_MODE_TRANSITION is hard-coded to WM_USER+6 in kernel\winmgr.c
//
#define CM_MODE_TRANSITION       (WM_USER+6)
#define CM_CONSOLE_SHUTDOWN      (WM_USER+7)
#define CM_HIDE_WINDOW           (WM_USER+8)
#if defined(FE_IME)
#define CM_CONIME_CREATE         (WM_USER+9)
#define CM_SET_CONSOLEIME_WINDOW (WM_USER+10)
#define CM_WAIT_CONIME_PROCESS   (WM_USER+11)
#define CM_SET_IME_CODEPAGE      (WM_USER+12)
#define CM_SET_NLSMODE           (WM_USER+13)
#define CM_GET_NLSMODE           (WM_USER+14)
#define CM_CONIME_KL_ACTIVATE    (WM_USER+15)
#endif
#define CM_CONSOLE_MSG           (WM_USER+16)
#define CM_CONSOLE_INPUT_THREAD_MSG (WM_USER+17)

#define CONSOLE_CLIENTTHREADHANDLE(pcsrthread) ((pcsrthread)->ThreadHandle)

#define CONSOLE_CLIENTPROCESSHANDLE() \
    ((CSR_SERVER_QUERYCLIENTTHREAD())->Process->ProcessHandle)

#define CONSOLE_CLIENTPROCESSID() \
    ((CSR_SERVER_QUERYCLIENTTHREAD())->Process->ClientId.UniqueProcess)

#define CONSOLE_FROMPROCESSPROCESSHANDLE(pcsrprocess) \
                                               ((pcsrprocess)->ProcessHandle)

#define CONSOLE_FROMPROCESSPERPROCESSDATA(pcsrprocess) \
    ((pcsrprocess)->ServerDllPerProcessData[CONSRV_SERVERDLL_INDEX])

#define CONSOLE_FROMTHREADPERPROCESSDATA(pcsrthread) \
    CONSOLE_FROMPROCESSPERPROCESSDATA((pcsrthread)->Process)

#define CONSOLE_PERPROCESSDATA() \
    CONSOLE_FROMTHREADPERPROCESSDATA(CSR_SERVER_QUERYCLIENTTHREAD())

#define CONSOLE_GETCONSOLEAPP() (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleApp)
#define CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(PROCESSDATA) ((PROCESSDATA)->ConsoleApp)
#define CONSOLE_SETCONSOLEAPP(VALUE) (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleApp = VALUE)
#define CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(PROCESSDATA,VALUE) ((PROCESSDATA)->ConsoleApp = VALUE)

#define CONSOLE_GETCONSOLEHANDLE() (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleHandle)
#define CONSOLE_SETCONSOLEHANDLE(VALUE) (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleHandle = VALUE)
#define CONSOLE_GETCONSOLEHANDLEFROMPROCESSDATA(PROCESSDATA) ((PROCESSDATA)->ConsoleHandle)
#define CONSOLE_SETCONSOLEHANDLEFROMPROCESSDATA(PROCESSDATA,VALUE) ((PROCESSDATA)->ConsoleHandle = VALUE)

#endif

//
// registry information structure
//

typedef struct _CONSOLE_REGISTRY_INFO {
    COORD     ScreenBufferSize;
    COORD     WindowSize;
    COORD     WindowOrigin;
    COORD     FontSize;
    UINT      FontFamily;
    UINT      FontWeight;
    WCHAR     FaceName[LF_FACESIZE];
    UINT      CursorSize;
    BOOL      FullScreen;
    BOOL      QuickEdit;
    BOOL      InsertMode;
    BOOL      AutoPosition;
    CHAR_INFO ScreenFill;
    CHAR_INFO PopupFill;
    UINT      HistoryBufferSize;
    UINT      NumberOfHistoryBuffers;
    BOOL      HistoryNoDup;
    COLORREF  ColorTable[ 16 ];
    LONGLONG  LastWriteTime;
#if defined(FE_SB) // scotthsu
    DWORD     CodePage;
#endif
} CONSOLE_REGISTRY_INFO, *PCONSOLE_REGISTRY_INFO;


//
// window class
//

#define CONSOLE_WINDOW_CLASS (L"ConsoleWindowClass")

#define CONSOLE_MAX_APP_SHORTCUTS 1

//
// this structure is used to store relevant information from the
// console for ctrl processing so we can do it without holding the
// console lock.
//

typedef struct _CONSOLE_PROCESS_TERMINATION_RECORD {
    HANDLE ProcessHandle;
    ULONG TerminateCount;
    BOOL bDebugee;
    LPTHREAD_START_ROUTINE CtrlRoutine;
} CONSOLE_PROCESS_TERMINATION_RECORD, *PCONSOLE_PROCESS_TERMINATION_RECORD;

//
// this value is used to determine the size of stack buffers for
// strings.  it should be long enough to contain the width of a
// normal screen buffer.
//

#define STACK_BUFFER_SIZE 132

//
// link information
//


#define LINK_PROP_MAIN_SIG          0x00000001
#define LINK_PROP_NT_CONSOLE_SIG    0x00000002

#if 0  // no one currently uses this...
typedef struct {

    WCHAR  pszLinkName[ MAX_PATH ];
    WCHAR  pszName[ MAX_PATH ];
    WCHAR  pszRelPath[ MAX_PATH ];
    WCHAR  pszWorkingDir[ MAX_PATH ];
    WCHAR  pszArgs[ MAX_PATH ];
    WCHAR  pszIconLocation[ MAX_PATH ];
    int    iIcon;
    int    iShowCmd;
    int    wHotKey;

} LNKPROPMAIN, * LPLNKPROPMAIN;
#endif

#ifndef _USERKDX_ /* debugging extensions */
typedef struct {

    WCHAR    pszName[ MAX_PATH ];
    WCHAR    pszIconLocation[ MAX_PATH ];
    UINT     uIcon;
    UINT     uShowCmd;
    UINT     uHotKey;
    NT_CONSOLE_PROPS console_props;
#ifdef FE_SB
    NT_FE_CONSOLE_PROPS fe_console_props;
#endif


} LNKPROPNTCONSOLE, *LPLNKPROPNTCONSOLE;
#endif

#ifndef _USERKDX_ /* debugging extensions */
typedef struct {
    LPWSTR              pszCurFile;     // current file from IPersistFile
    LPWSTR              pszRelSource;   // overrides pszCurFile in relative tracking

    LPWSTR              pszName;        // title on short volumes
    LPWSTR              pszRelPath;
    LPWSTR              pszWorkingDir;
    LPWSTR              pszArgs;
    LPWSTR              pszIconLocation;

    LPSTR               pExtraData;     // extra data to preserve for future compatibility

    SHELL_LINK_DATA     sld;
} CShellLink;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\font.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    font.h

Abstract:

    This module contains the data structures, data types,
    and procedures related to fonts.

Author:

    Therese Stowell (thereses) 15-Jan-1991

Revision History:

--*/

#define INITIAL_FONTS 20
#define FONT_INCREMENT 3

/*
 * FONT_INFO
 *
 * The distinction between the desired and actual font dimensions obtained
 * is important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Desired" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The SizeDesired is {0, 0} if the font is a raster font.
 */
typedef struct _FONT_INFO {
    HFONT hFont;
    COORD Size;      // font size obtained
    COORD SizeWant;  // 0;0 if Raster font
    LONG  Weight;
    LPWSTR FaceName;
    BYTE  Family;
#if defined(FE_SB)
    BYTE tmCharSet;
#endif
} FONT_INFO, *PFONT_INFO;

#define TM_IS_TT_FONT(x)     (((x) & TMPF_TRUETYPE) == TMPF_TRUETYPE)
#define IS_BOLD(w)           ((w) >= FW_SEMIBOLD)
#define SIZE_EQUAL(s1, s2)   (((s1).X == (s2).X) && ((s1).Y == (s2).Y))
#define POINTS_PER_INCH 72
#define MIN_PIXEL_HEIGHT 5
#define MAX_PIXEL_HEIGHT 72
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\inc\input.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    input.h

Abstract:

    This module contains the internal structures and definitions used
    by the input (keyboard and mouse) component of the NT console subsystem.

Author:

    Therese Stowell (thereses) 12-Nov-1990

Revision History:

--*/

#define DEFAULT_NUMBER_OF_EVENTS 50
#define INPUT_BUFFER_SIZE_INCREMENT 10

typedef struct _INPUT_INFORMATION {
    PINPUT_RECORD InputBuffer;
    DWORD InputBufferSize;      // size in events
    CONSOLE_SHARE_ACCESS ShareAccess;   // share mode
    DWORD InputMode;
    ULONG RefCount;             // number of handles to input buffer
    ULONG_PTR First;             // ptr to base of circular buffer
    ULONG_PTR In;                // ptr to next free event
    ULONG_PTR Out;               // ptr to next available event
    ULONG_PTR Last;              // ptr to end+1 of buffer
    LIST_ENTRY ReadWaitQueue;
    HANDLE InputWaitEvent;
#if defined(FE_SB)
#if defined(FE_IME)
    struct {
        DWORD Disable     : 1;  // High   : specifies input code page or enable/disable in NLS state
        DWORD Unavailable : 1;  // Middle : specifies console window doing menu loop or size move
        DWORD Open        : 1;  // Low    : specifies open/close in NLS state or IME hot key

        DWORD ReadyConversion:1;// if conversion mode is ready by succeed communicate to ConIME.
                                // then this field is TRUE.
        DWORD Conversion;       // conversion mode of ime (i.e IME_CMODE_xxx).
                                // this field uses by GetConsoleNlsMode
    } ImeMode;
    HWND hWndConsoleIME;        // validate hWnd when open property window by ImmConfigureIME
#endif // FE_IME
    struct _CONSOLE_INFORMATION *Console;
    INPUT_RECORD ReadConInpDbcsLeadByte;
    INPUT_RECORD WriteConInpDbcsLeadByte[2];
#endif
} INPUT_INFORMATION, *PINPUT_INFORMATION;

typedef struct _INPUT_READ_HANDLE_DATA {

    //
    // the following seven fields are solely used for input reads.
    //

    CRITICAL_SECTION ReadCountLock; // serializes access to read count
    ULONG ReadCount;            // number of reads waiting
    ULONG InputHandleFlags;

    //
    // the following four fields are used to remember input data that
    // wasn't returned on a cooked-mode read.  we do our own buffering
    // and don't return data until the user hits enter so that she can
    // edit the input.  as a result, there is often data that doesn't fit
    // into the caller's buffer.  we save it so we can return it on the
    // next cooked-mode read to this handle.
    //

    ULONG BytesAvailable;
    PWCHAR CurrentBufPtr;
    PWCHAR BufPtr;
} INPUT_READ_HANDLE_DATA, *PINPUT_READ_HANDLE_DATA;

#define UNICODE_BACKSPACE ((WCHAR)0x08)
#define UNICODE_BACKSPACE2 ((WCHAR)0x25d8)
#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_BELL ((WCHAR)0x07)
#define UNICODE_TAB ((WCHAR)0x09)
#define UNICODE_SPACE ((WCHAR)0x20)

#define TAB_SIZE 8
#define TAB_MASK (TAB_SIZE-1)
#define NUMBER_OF_SPACES_IN_TAB(POSITION) (TAB_SIZE - ((POSITION) & TAB_MASK))

#define AT_EOL(COOKEDREADDATA) ((COOKEDREADDATA)->BytesRead == ((COOKEDREADDATA)->CurrentPosition*2))
#define INSERT_MODE(COOKEDREADDATA) ((COOKEDREADDATA)->InsertMode)

#define VIRTUAL_KEY_CODE_S 0x53
#define VIRTUAL_KEY_CODE_C 0x43

#define VK_OEM_SCROLL    0x91

#define KEY_PRESSED 0x8000
#define KEY_TOGGLED 0x01
#define KEY_ENHANCED 0x01000000
#define KEY_UP_TRANSITION 1
#define KEY_PREVIOUS_DOWN 0x40000000
#define KEY_TRANSITION_UP 0x80000000

#define CONSOLE_CTRL_C_SEEN  1
#define CONSOLE_CTRL_BREAK_SEEN 2

#define LockReadCount(HANDLEPTR) RtlEnterCriticalSection(&(HANDLEPTR)->InputReadData->ReadCountLock)
#define UnlockReadCount(HANDLEPTR) RtlLeaveCriticalSection(&(HANDLEPTR)->InputReadData->ReadCountLock)

#define LoadKeyEvent(PEVENT,KEYDOWN,CHAR,KEYCODE,SCANCODE,KEYSTATE) { \
        (PEVENT)->EventType = KEY_EVENT;                              \
        (PEVENT)->Event.KeyEvent.bKeyDown = KEYDOWN;                  \
        (PEVENT)->Event.KeyEvent.wRepeatCount = 1;                    \
        (PEVENT)->Event.KeyEvent.uChar.UnicodeChar = CHAR;            \
        (PEVENT)->Event.KeyEvent.wVirtualKeyCode = KEYCODE;           \
        (PEVENT)->Event.KeyEvent.wVirtualScanCode = SCANCODE;         \
        (PEVENT)->Event.KeyEvent.dwControlKeyState = KEYSTATE;        \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\dbcs.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dbcs.h

Abstract:

Author:

Revision History:

--*/


#define UNICODE_DBCS_PADDING 0xffff

#define DEFAULT_FONTSIZE   256
#define DEFAULT_EUDCSIZE   1

#define VDM_EUDC_FONT_SIZE_X 16
#define VDM_EUDC_FONT_SIZE_Y 16

#define USACP     1252
#define KOREAN_CP 949
#define JAPAN_CP  932

#if defined(FE_SB)
#define MIN_SCRBUF_WIDTH  12    // for suport display IME status
#define MIN_SCRBUF_HEIGHT  2    // for suport display IME status
#define MIN_WINDOW_HEIGHT  1
#endif



#if defined(i386)
extern ULONG  gdwMachineId;
#endif


extern ULONG DefaultFontIndex;
extern COORD DefaultFontSize;
extern BYTE  DefaultFontFamily;


typedef struct _MODE_FONT_PAIR {
    DWORD Mode;
        #define FS_MODE_TEXT     0x0001
        #define FS_MODE_GRAPHICS 0x0002
        #define FS_MODE_FIND     0x8000
        #define FS_TEXT          (FS_MODE_FIND+FS_MODE_TEXT)
        #define FS_GRAPHICS      (FS_MODE_FIND+FS_MODE_GRAPHICS)
    COORD ScreenSize;
    COORD Resolution;
    COORD FontSize;
} MODE_FONT_PAIR, *PMODE_FONT_PAIR;

typedef struct _FS_CODEPAGE {
    SINGLE_LIST_ENTRY List;
    UINT CodePage;
} FS_CODEPAGE, *PFS_CODEPAGE;

extern PUSHORT RegInitialPalette;
extern PUCHAR RegColorBuffer;
extern PUCHAR RegColorBufferNoTranslate;
extern DWORD NUMBER_OF_MODE_FONT_PAIRS;
extern PMODE_FONT_PAIR RegModeFontPairs;
extern SINGLE_LIST_ENTRY gRegFullScreenCodePage;    // This list contain FS_CODEPAGE data.



typedef struct tagSTRINGBITMAP
{
    UINT uiWidth;
    UINT uiHeight;
    BYTE ajBits[1];
} STRINGBITMAP, *LPSTRINGBITMAP;

UINT
GetStringBitmapW(
    HDC             hdc,
    LPWSTR          pwc,
    UINT            cwc,
    UINT            cbData,
    BYTE            *pSB
    );



//
// dbcs.c
//

#if defined(FE_IME)

#if defined(i386)
NTSTATUS
ImeWmFullScreen(
    IN BOOL Foreground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif // i386


NTSTATUS
GetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN PDWORD pdwConversion
    );


NTSTATUS
SetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD fdwConversion
    );

NTSTATUS
SetImeCodePage(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
SetImeOutputCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage
    );
#endif // FE_IME

VOID
SetLineChar(
    IN PSCREEN_INFORMATION ScreenInfo
    );

BOOL
CheckBisectStringA(
    IN DWORD CodePage,
    IN PCHAR Buffer,
    IN DWORD NumBytes,
    IN LPCPINFO lpCPInfo
    );

VOID
BisectWrite(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
BisectClipbrd(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PSMALL_RECT SmallRect
    );

VOID
BisectWriteAttr(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    );

DWORD
RemoveDbcsMark(
    IN PWCHAR Dst,
    IN PWCHAR Src,
    IN DWORD NumBytes,
    IN PCHAR SrcA,
    IN BOOL OS2OemFormat
    );

DWORD
RemoveDbcsMarkCell(
    IN PCHAR_INFO Dst,
    IN PCHAR_INFO Src,
    IN DWORD NumBytes
    );

DWORD
RemoveDbcsMarkAll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PROW Row,
    IN PSHORT LeftChar,
    IN PRECT TextRect,
    IN int *TextLeft,
    IN PWCHAR Buffer,
    IN SHORT NumberOfChars
    );

BOOL
IsDBCSLeadByteConsole(
    IN BYTE AsciiChar,
    IN LPCPINFO lpCPInfo
    );

NTSTATUS
AdjustFont(
    IN PCONSOLE_INFORMATION Console,
    IN UINT CodePage
    );

NTSTATUS
ConvertToCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN UINT PrevCodePage
    );

NTSTATUS
ConvertOutputOemToNonOemUnicode(
    IN OUT LPWSTR Source,
    IN OUT PBYTE KAttrRows,
    IN int SourceLength, // in chars
    IN UINT Codepage
    );


VOID
TextOutEverything(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT LeftWindowPos,
    IN OUT PSHORT RightWindowPos,
    IN OUT PSHORT CountOfAttr,
    IN SHORT CountOfAttrOriginal,
    IN OUT PBOOL DoubleColorDBCS,
    IN BOOL LocalEUDCFlag,
    IN PROW Row,
    IN PATTR_PAIR Attr,
    IN SHORT LeftTextPos,
    IN SHORT RightTextPos,
    IN int WindowRectLeft,
    IN RECT WindowRect,
    IN SHORT NumberOfChars
    );

VOID
TextOutCommonLVB(
    IN PCONSOLE_INFORMATION Console,
    IN WORD Attributes,
    IN RECT CommonLVBRect
    );

NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD DefaultFontSize,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPWSTR AltFaceName
    );

NTSTATUS
InitializeDbcsMisc(
    VOID
    );

#if defined(i386)
NTSTATUS
RealUnicodeToNEC_OS2_Unicode(
    IN OUT LPWSTR Source,
    IN int SourceLength      // in chars
    );

BOOL
InitializeNEC_OS2_CP(
    VOID
    );
#endif

BYTE
CodePageToCharSet(
    UINT CodePage
    );

BOOL
IsAvailableFarEastCodePage(
    UINT CodePage
    );

LPTTFONTLIST
SearchTTFont(
    LPWSTR pwszFace,
    BOOL   fCodePage,
    UINT   CodePage
    );

BOOL
IsAvailableTTFont(
    LPWSTR pwszFace
    );

BOOL
IsAvailableTTFontCP(
    LPWSTR pwszFace,
    UINT CodePage
    );

LPWSTR
GetAltFaceName(
    LPWSTR pwszFace
    );

BOOL
IsAvailableFsCodePage(
    UINT CodePage
    );

#if defined(FE_IME)

VOID
ProcessCreateConsoleIME(
    IN LPMSG lpMsg,
    DWORD dwConsoleThreadId
    );

NTSTATUS
InitConsoleIMEStuff(
    HDESK hDesktop,
    DWORD dwConsoleThreadId,
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
WaitConsoleIMEStuff(
    HDESK hDesktop,
    HANDLE hThread
    );

NTSTATUS
ConSrvRegisterConsoleIME(
    PCSR_PROCESS Process,
    HDESK hDesktop,
    HWINSTA hWinSta,
    HWND  hWndConsoleIME,
    DWORD dwConsoleIMEThreadId,
    DWORD dwAction,
    DWORD *dwConsoleThreadId
    );

VOID
RemoveConsoleIME(
    PCSR_PROCESS Process,
    DWORD dwConsoleIMEThreadId
    );

NTSTATUS
ConsoleImeMessagePumpWorker(
    PCONSOLE_INFORMATION Console,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam,
    LRESULT* lplResult);


NTSTATUS
ConsoleImeMessagePump(
    PCONSOLE_INFORMATION Console,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam
    );
#endif // FE_IME


BOOL
RegisterKeisenOfTTFont(
    IN PSCREEN_INFORMATION ScreenInfo
    );

ULONG
TranslateUnicodeToOem(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR UnicodeBuffer,
    IN ULONG UnicodeCharCount,
    OUT PCHAR AnsiBuffer,
    IN ULONG AnsiByteCount,
    OUT PINPUT_RECORD DbcsLeadInpRec
    );

DWORD
ImmConversionToConsole(
    DWORD fdwConversion
    );

DWORD
ImmConversionFromConsole(
    DWORD dwNlsMode
    );

//#define DBG_KAZUM
//#define DBG_KATTR

#if defined(DBG) && defined(DBG_KATTR)
VOID
BeginKAttrCheck(
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif


//
// output.c
//
BOOL
CreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PDBCS_SCREEN_BUFFER DbcsScreenBuffer
    );

BOOL
DeleteDbcsScreenBuffer(
    IN PDBCS_SCREEN_BUFFER DbcsScreenBuffer
    );

BOOL
ReCreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN UINT OldCodePage
    );

BOOL
FE_PolyTextOutCandidate(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

VOID
FE_ConsolePolyTextOut(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );


//
// private.c
//
NTSTATUS
SetRAMFontCodePage(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
SetRAMFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR_INFO ScreenBufPtr,
    IN DWORD Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\cmdline.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmdline.h

Abstract:

    This file contains the internal structures and definitions used
    by command line input and editing.

Author:

    Therese Stowell (thereses) 15-Nov-1991

Revision History:

--*/

typedef struct _COMMAND {
    USHORT CommandLength;
    WCHAR Command[0];
} COMMAND, *PCOMMAND;

typedef
NTSTATUS
(*PCLE_POPUP_INPUT_ROUTINE)(
    IN PVOID CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

/*
 * CLE_POPUP Flags
 */
#define CLEPF_FALSE_UNICODE 0x0001

typedef struct _CLE_POPUP {
    LIST_ENTRY ListLink;    // pointer to next popup
    SMALL_RECT Region;      // region popup occupies
    WORD  Attributes;       // text attributes
    WORD  Flags;            // CLEPF_ flags
    PCHAR_INFO OldContents; // contains data under popup
    SHORT BottomIndex;      // number of command displayed on last line of popup
    SHORT CurrentCommand;
    WCHAR NumberBuffer[6];
    SHORT NumberRead;
    PCLE_POPUP_INPUT_ROUTINE PopupInputRoutine; // routine to call when input is received
#if defined(FE_SB)
    COORD OldScreenSize;
#endif
} CLE_POPUP, *PCLE_POPUP;

#define POPUP_SIZE_X(POPUP) (SHORT)(((POPUP)->Region.Right - (POPUP)->Region.Left - 1))
#define POPUP_SIZE_Y(POPUP) (SHORT)(((POPUP)->Region.Bottom - (POPUP)->Region.Top - 1))
#define COMMAND_NUMBER_SIZE 8   // size of command number buffer


/*
 * COMMAND_HISTORY Flags
 */
#define CLE_ALLOCATED 0x00000001
#define CLE_RESET     0x00000002

typedef struct _COMMAND_HISTORY {
    DWORD Flags;
    LIST_ENTRY ListLink;
    PWCHAR AppName;
    SHORT NumberOfCommands;
    SHORT LastAdded;
    SHORT LastDisplayed;
    SHORT FirstCommand;     // circular buffer
    SHORT MaximumNumberOfCommands;
    HANDLE ProcessHandle;
    LIST_ENTRY PopupList;    // pointer to top-level popup
    PCOMMAND Commands[0];
} COMMAND_HISTORY, *PCOMMAND_HISTORY;

#define DEFAULT_NUMBER_OF_COMMANDS 25
#define DEFAULT_NUMBER_OF_BUFFERS 4

typedef struct _COOKED_READ_DATA {
    PINPUT_INFORMATION InputInfo;
    PSCREEN_INFORMATION ScreenInfo;
    PCONSOLE_INFORMATION Console;
    HANDLE_DATA TempHandle;
    ULONG UserBufferSize;   // doubled size in ansi case
    PWCHAR UserBuffer;
    ULONG BufferSize;
    ULONG BytesRead;
    ULONG CurrentPosition;  // char position, not byte position
    PWCHAR BufPtr;
    PWCHAR BackupLimit;
    COORD OriginalCursorPosition;
    DWORD NumberOfVisibleChars;
    PCOMMAND_HISTORY CommandHistory;
    BOOLEAN Echo;
    BOOLEAN Processed;
    BOOLEAN Line;
    BOOLEAN InsertMode;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    HANDLE HandleIndex;
    PWCHAR ExeName;
    USHORT ExeNameLength;   // in bytes
    ULONG CtrlWakeupMask;
    ULONG ControlKeyState;
} COOKED_READ_DATA, *PCOOKED_READ_DATA;

#define COMMAND_NUM_TO_INDEX(NUM,CMDHIST) (SHORT)(((NUM+(CMDHIST)->FirstCommand)%((CMDHIST)->MaximumNumberOfCommands)))
#define COMMAND_INDEX_TO_NUM(INDEX,CMDHIST) (SHORT)(((INDEX+((CMDHIST)->MaximumNumberOfCommands)-(CMDHIST)->FirstCommand)%((CMDHIST)->MaximumNumberOfCommands)))

/*
 * COMMAND_IND_NEXT and COMMAND_IND_PREV go to the next and prev command
 * COMMAND_IND_INC  and COMMAND_IND_DEC  go to the next and prev slots
 *
 * Don't get the two confused - it matters when the cmd history is not full!
 */

#define COMMAND_IND_PREV(IND,CMDHIST)                \
{                                                    \
    if (IND <= 0) {                                  \
        IND = (CMDHIST)->NumberOfCommands;           \
    }                                                \
    IND--;                                           \
}

#define COMMAND_IND_NEXT(IND,CMDHIST)                \
{                                                    \
    ++IND;                                           \
    if (IND >= (CMDHIST)->NumberOfCommands) {        \
        IND = 0;                                     \
    }                                                \
}

#define COMMAND_IND_DEC(IND,CMDHIST)                 \
{                                                    \
    if (IND <= 0) {                                  \
        IND = (CMDHIST)->MaximumNumberOfCommands;    \
    }                                                \
    IND--;                                           \
}

#define COMMAND_IND_INC(IND,CMDHIST)                 \
{                                                    \
    ++IND;                                           \
    if (IND >= (CMDHIST)->MaximumNumberOfCommands) { \
        IND = 0;                                     \
    }                                                \
}

#define CLE_NO_POPUPS(COMMAND_HISTORY) (&(COMMAND_HISTORY)->PopupList == (COMMAND_HISTORY)->PopupList.Blink)

//
// aliases are grouped per console, per exe.
//

typedef struct _ALIAS {
    LIST_ENTRY ListLink;
    USHORT SourceLength; // in bytes
    USHORT TargetLength; // in bytes
    PWCHAR Source;
    PWCHAR Target;
} ALIAS, *PALIAS;

typedef struct _EXE_ALIAS_LIST {
    LIST_ENTRY ListLink;
    USHORT ExeLength;   // in bytes
    PWCHAR ExeName;
    LIST_ENTRY AliasList;
} EXE_ALIAS_LIST, *PEXE_ALIAS_LIST;

NTSTATUS
ProcessCommandLine(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

VOID
DeleteCommandLine(
    IN OUT PCOOKED_READ_DATA CookedReadData,
    IN BOOL UpdateFields
    );

VOID
RedrawCommandLine(
    IN PCOOKED_READ_DATA CookedReadData
    );

VOID
EmptyCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    );

PCOMMAND_HISTORY
ReallocCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PCOMMAND_HISTORY CurrentCommandHistory,
    IN DWORD NumCommands
    );

PCOMMAND_HISTORY
FindExeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PVOID AppName,
    IN DWORD AppNameLength,
    IN BOOLEAN UnicodeExe
    );

PCOMMAND_HISTORY
FindCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    );

ULONG
RetrieveNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD CodePage
#endif
    );

ULONG
RetrieveTotalNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    );

NTSTATUS
GetChar(
    IN PINPUT_INFORMATION InputInfo,
    OUT PWCHAR Char,
    IN BOOLEAN Wait,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL,
    OUT PBOOLEAN CommandLineEditingKeys OPTIONAL,
    OUT PBOOLEAN CommandLinePopupKeys OPTIONAL,
    OUT PBOOLEAN EnableScrollMode OPTIONAL,
    OUT PDWORD KeyState OPTIONAL
    );

BOOL
IsCommandLinePopupKey(
    IN OUT PKEY_EVENT_RECORD KeyEvent
    );

BOOL
IsCommandLineEditingKey(
    IN OUT PKEY_EVENT_RECORD KeyEvent
    );

VOID
CleanUpPopups(
    IN PCOOKED_READ_DATA CookedReadData
    );

BOOL
ProcessCookedReadInput(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    OUT PNTSTATUS Status
    );

VOID
DrawCommandListBorder(
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo
    );

PCOMMAND
GetLastCommand(
    IN PCOMMAND_HISTORY CommandHistory
    );

SHORT
FindMatchingCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR CurrentCommand,
    IN ULONG CurrentCommandLength,
    IN SHORT CurrentIndex,
    IN DWORD Flags
    );

#define FMCFL_EXACT_MATCH   1
#define FMCFL_JUST_LOOKING  2

NTSTATUS
CommandNumberPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

BOOLEAN
CookedReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    );

VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    );

NTSTATUS
WriteCharsFromInput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    );

//
// Values for WriteChars(),WriteCharsFromInput() dwFlags
//
#define WC_DESTRUCTIVE_BACKSPACE 0x01
#define WC_KEEP_CURSOR_VISIBLE   0x02
#define WC_ECHO                  0x04
#define WC_FALSIFY_UNICODE       0x08
#define WC_LIMIT_BACKSPACE       0x10


VOID
DrawCommandListPopup(
    IN PCLE_POPUP Popup,
    IN SHORT CurrentCommand,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
UpdateCommandListPopup(
    IN SHORT Delta,
    IN OUT PSHORT CurrentCommand,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD Flags
    );

#define UCLP_WRAP   1


//
// InitExtendedEditKey
// If lpwstr is NULL, the default value will be used.
//
VOID InitExtendedEditKeys(CONST ExtKeyDefBuf* lpbuf);

//
// IsPauseKey
// returns TRUE if pKeyEvent is pause.
// The default key is Ctrl-S if extended edit keys are not specified.
//
BOOL IsPauseKey(IN PKEY_EVENT_RECORD pKeyEvent);


//
// Word delimiters
//

#define IS_WORD_DELIM(wch)  ((wch) == L' ' || (gaWordDelimChars[0] && IsWordDelim(wch)))

extern WCHAR gaWordDelimChars[];
extern CONST WCHAR gaWordDelimCharsDefault[];
extern BOOL IsWordDelim(WCHAR);

#define WORD_DELIM_MAX  32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\consrv.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    consrv.h

Abstract:

    This module contains the include files and definitions for the
    console server DLL.

Author:

    Therese Stowell (thereses) 16-Nov-1990

Revision History:

--*/

#if DBG && defined(DEBUG_PRINT)
  #define _DBGFONTS   0x00000001
  #define _DBGFONTS2  0x00000002
  #define _DBGCHARS   0x00000004
  #define _DBGOUTPUT  0x00000008
  #define _DBGFULLSCR 0x00000010
  #define _DBGALL     0xFFFFFFFF
  extern ULONG gDebugFlag;

  #define DBGFONTS(_params_)   {if (gDebugFlag & _DBGFONTS)  DbgPrint _params_ ; }
  #define DBGFONTS2(_params_)  {if (gDebugFlag & _DBGFONTS2) DbgPrint _params_ ; }
  #define DBGCHARS(_params_)   {if (gDebugFlag & _DBGCHARS)  DbgPrint _params_ ; }
  #define DBGOUTPUT(_params_)  {if (gDebugFlag & _DBGOUTPUT) DbgPrint _params_ ; }
  #define DBGFULLSCR(_params_) {if (gDebugFlag & _DBGFULLSCR)DbgPrint _params_ ; }
  #define DBGPRINT(_params_)  DbgPrint _params_
#else
  #define DBGFONTS(_params_)
  #define DBGFONTS2(_params_)
  #define DBGCHARS(_params_)
  #define DBGOUTPUT(_params_)
  #define DBGFULLSCR(_params_)
  #define DBGPRINT(_params_)
#endif

#define CONSOLE_MAX_FONT_NAME_LENGTH 256

#define DATA_CHUNK_SIZE 8192

#define TMP_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 0))
#define BMP_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 1))
#define ALIAS_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 2))
#define HISTORY_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 3))
#define TITLE_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 4))
#define HANDLE_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 5))
#define CONSOLE_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 6))
#define ICON_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 7))
#define BUFFER_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 8))
#define WAIT_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 9))
#define FONT_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 10))
#define SCREEN_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 11))
#if defined(FE_SB)
#define TMP_DBCS_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 12))
#define SCREEN_DBCS_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 13))
#define EUDC_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 14))
#define CONVAREA_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 15))
#define IME_TAG (RTL_HEAP_MAKE_TAG(dwConBaseTag, 16))
#endif


#define GetWindowConsole(hWnd)          (PCONSOLE_INFORMATION)GetWindowLongPtr((hWnd), GWLP_USERDATA)

/*
 * Used to store some console attributes for the console.  This is a means
 * to cache the color in the extra-window-bytes, so USER/KERNEL can get
 * at it for hungapp drawing.  The window-offsets are defined in NTUSER\INC.
 *
 * The other macros are just convenient means for setting the other window
 * bytes.
 */
#define SetConsoleBkColor(hw,clr) SetWindowLong(hw, GWL_CONSOLE_BKCOLOR, clr)
#define SetConsolePid(hw,pid)     SetWindowLong(hw, GWL_CONSOLE_PID, pid)
#define SetConsoleTid(hw,tid)     SetWindowLong(hw, GWL_CONSOLE_TID, tid)


/*
 * helpful macros
 */
#define NELEM(array) (sizeof(array)/sizeof(array[0]))
#define PACKCOORD(pt)   (MAKELONG(((pt).X), ((pt).Y)))

// Text Information from PSCREEN_INFORMATION
__inline BYTE SCR_FAMILY(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.Family;
}

__inline DWORD SCR_FONTNUMBER(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FontNumber;
}

__inline LPWSTR SCR_FACENAME(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FaceName;
}

__inline COORD SCR_FONTSIZE(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FontSize;
}

__inline LONG SCR_FONTWEIGHT(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.Weight;
}

__inline UINT SCR_FONTCODEPAGE(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FontCodePage;
}


// Text Information from PCONSOLE_INFORMATION
#define CON_FAMILY(pCon)       SCR_FAMILY((pCon)->CurrentScreenBuffer)
#define CON_FONTNUMBER(pCon)   SCR_FONTNUMBER((pCon)->CurrentScreenBuffer)
#define CON_FACENAME(pCon)     SCR_FACENAME((pCon)->CurrentScreenBuffer)
#define CON_FONTSIZE(pCon)     SCR_FONTSIZE((pCon)->CurrentScreenBuffer)
#define CON_FONTWEIGHT(pCon)   SCR_FONTWEIGHT((pCon)->CurrentScreenBuffer)
#define CON_FONTCODEPAGE(pCon) SCR_FONTCODEPAGE((pCon)->CurrentScreenBuffer)

#if defined(FE_SB)

extern BOOLEAN    gfIsDBCSACP;      // TRUE if System ACP is associated with DBCS font

#define CONSOLE_IS_DBCS_ENABLED()   (gfIsDBCSACP)
#define CONSOLE_IS_IME_ENABLED()    (gfIsDBCSACP)

#define CONSOLE_IS_DBCS_OUTPUTCP(Console)   ((Console)->fIsDBCSOutputCP)
#define CONSOLE_IS_DBCS_CP(Console)         ((Console)->fIsDBCSCP)

#else   // FE_SB

#define CONSOLE_IS_DBCS_ENABLED()   (FALSE)
#define CONSOLE_IS_IME_ENABLED()    (FALSE)

#endif  // FE_SB

#ifdef UNICODE
#define LoadStringEx    LoadStringExW
#else
#define LoadStringEx    LoadStringExA
#endif

//
//  Cache the heap pointer for use by memory routines.
//

extern PWIN32HEAP pConHeap;
extern DWORD      dwConBaseTag;

//
// Wrappers for console heap code.
//

#define ConsoleHeapAlloc(Flags, Size)                   \
    Win32HeapAlloc(pConHeap, Size, Flags, Flags)

#define ConsoleHeapReAlloc(Flags, Address, Size)        \
    Win32HeapReAlloc(pConHeap, Address, Size, Flags)

#if DBG
#define ConsoleHeapFree(Address)                        \
{                                                       \
    Win32HeapFree(pConHeap, Address);                   \
    Address = IntToPtr(0xBAADF00D);                     \
}
#else
#define ConsoleHeapFree(Address)                        \
{                                                       \
    Win32HeapFree(pConHeap, Address);                   \
}
#endif

#define ConsoleHeapSize(Address)                        \
    Win32HeapSize(pConHeap, Address)

//
//  handle.c
//


#if DBG
VOID RefConsole(
    PCONSOLE_INFORMATION Console);

VOID DerefConsole(
    PCONSOLE_INFORMATION Console);

#else
__inline VOID RefConsole(
    PCONSOLE_INFORMATION Console)
{
    Console->RefCount += 1;
}

__inline VOID DerefConsole(
    PCONSOLE_INFORMATION Console)
{
    Console->RefCount -= 1;
}
#endif

NTSTATUS
ConsoleAddProcessRoutine(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS Process
    );

NTSTATUS
DereferenceConsoleHandle(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console
    );

NTSTATUS
AllocateConsoleHandle(
    OUT PHANDLE Handle
    );

NTSTATUS
FreeConsoleHandle(
    IN HANDLE Handle
    );

NTSTATUS
ValidateConsole(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
ApiPreamble(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console
    );

NTSTATUS
RevalidateConsole(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console
    );

NTSTATUS
InitializeConsoleHandleTable( VOID );

#if DBG

VOID LockConsoleHandleTable(VOID);
VOID UnlockConsoleHandleTable(VOID);
VOID LockConsole(
    IN PCONSOLE_INFORMATION Console
    );

#else

#define LockConsoleHandleTable()   RtlEnterCriticalSection(&ConsoleHandleLock)
#define UnlockConsoleHandleTable() RtlLeaveCriticalSection(&ConsoleHandleLock)
#define LockConsole(Con)           RtlEnterCriticalSection(&(Con)->ConsoleLock)

#endif // DBG

#define ConvertAttrToRGB(Con, Attr) ((Con)->ColorTable[(Attr) & 0x0F])


BOOLEAN
UnProtectHandle(
    HANDLE hObject
    );

NTSTATUS
MapEventHandles(
    IN HANDLE ClientProcessHandle,
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_INFO ConsoleInfo
    );

NTSTATUS
AllocateConsole(
    IN HANDLE ConsoleHandle,
    IN LPWSTR Title,
    IN USHORT TitleLength,
    IN HANDLE ClientProcessHandle,
    OUT PHANDLE StdIn,
    OUT PHANDLE StdOut,
    OUT PHANDLE StdErr,
    OUT PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN OUT PCONSOLE_INFO ConsoleInfo,
    IN BOOLEAN WindowVisible,
    IN DWORD ConsoleThreadId
    );

VOID
DestroyConsole(
    IN PCONSOLE_INFORMATION Console
    );

VOID
FreeCon(
    IN PCONSOLE_INFORMATION Console
    );

VOID
InsertScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
RemoveScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
FreeProcessData(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData
    );

NTSTATUS
AllocateIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN ULONG HandleType,
    OUT PHANDLE Handle
    );

NTSTATUS
GrowIoHandleTable(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData
    );

NTSTATUS
FreeIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle
    );

NTSTATUS
DereferenceIoHandleNoCheck(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    OUT PHANDLE_DATA *HandleData
    );

NTSTATUS
DereferenceIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    IN ULONG HandleType,
    IN ACCESS_MASK Access,
    OUT PHANDLE_DATA *HandleData
    );

BOOLEAN
InitializeInputHandle(
    PHANDLE_DATA HandleData,
    PINPUT_INFORMATION InputBuffer
    );

VOID
InitializeOutputHandle(
    PHANDLE_DATA HandleData,
    PSCREEN_INFORMATION ScreenBuffer
    );

ULONG
SrvVerifyConsoleIoHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// share.c
//

NTSTATUS
ConsoleAddShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA HandleData
    );


NTSTATUS
ConsoleDupShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA TargetHandleData
    );


NTSTATUS
ConsoleRemoveShare(
    IN ULONG DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess
    );

//
// find.c
//

#define SEARCH_STRING_LENGTH    (80)

VOID
DoFind(
   IN PCONSOLE_INFORMATION Console
   );

USHORT
SearchForString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWSTR SearchString,
    IN USHORT StringLength,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN Reverse,
    IN BOOLEAN SearchAndSetAttr,
    IN ULONG Attr,
    OUT PCOORD StringPosition
    );

//
// output.c
//

VOID
ScrollScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    );

VOID
SetProcessForegroundRights(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    );

VOID
SetProcessFocus(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    );

VOID
ModifyConsoleProcessFocus(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Foreground
    );

VOID
InitializeSystemMetrics( VOID );

VOID
InitializeScreenInfo( VOID );

NTSTATUS
ReadScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    OUT PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT ReadRegion
    );

NTSTATUS
WriteScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    OUT PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT WriteRegion
    );

NTSTATUS
DoCreateScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_INFO ConsoleInfo
    );

NTSTATUS
CreateScreenBuffer(
    OUT PSCREEN_INFORMATION *ScreenInformation,
    IN COORD dwWindowSize OPTIONAL,
    IN DWORD nFont OPTIONAL,
    IN COORD dwScreenBufferSize OPTIONAL,
    IN CHAR_INFO Fill,
    IN CHAR_INFO PopupFill,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Flags,
    IN PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo OPTIONAL,
    OUT PVOID *lpBitmap,
    OUT HANDLE *hMutex,
    IN UINT CursorSize,
    IN LPWSTR FaceName
    );

VOID
AbortCreateConsole(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
CreateWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DestroyWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
FreeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation
    );

NTSTATUS
ReadOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID Buffer,
    IN COORD ReadCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords // this value is valid even for error cases
    );

NTSTATUS
InitializeScrollBuffer( VOID );

NTSTATUS
GetScreenBufferInformation(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PCOORD Size,
    OUT PCOORD CursorPosition,
    OUT PCOORD ScrollPosition,
    OUT PWORD  Attributes,
    OUT PCOORD CurrentWindowSize,
    OUT PCOORD MaximumWindowSize
    );

VOID
GetWindowLimits(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PWINDOW_LIMITS WindowLimits
    );

NTSTATUS
ResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT WindowDimensions,
    IN BOOL DoScrollBarUpdate
    );

NTSTATUS
ResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    IN BOOL DoScrollBarUpdate
    );

NTSTATUS
ScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRectangle,
    IN PSMALL_RECT ClipRectangle OPTIONAL,
    IN COORD  DestinationOrigin,
    IN CHAR_INFO Fill
    );

NTSTATUS
SetWindowOrigin(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN Absolute,
    IN OUT COORD  WindowOrigin
    );

VOID
SetWindowSize(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
SetActiveScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
QueueConsoleMessage(
    PCONSOLE_INFORMATION Console,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
ConsoleNotifyWinEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Event,
    IN LONG idObjectType,
    IN LONG idObject);

LRESULT APIENTRY
ConsoleWindowProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
VerticalScroll(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    );

VOID
HorizontalScroll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    );

VOID
StreamScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#if defined(FE_SB)
VOID
FindAttrIndex(
    IN PATTR_PAIR String,
    IN SHORT Index,
    OUT PATTR_PAIR *IndexedAttr,
    OUT PSHORT CountOfAttr
    );

VOID
UpdateComplexRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD FontSize
    );

SHORT
ScrollEntireScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollValue,
    IN BOOL UpdateRowIndex
    );

VOID
UpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif

VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    );


VOID
InitializeThreadMessages(VOID);

NTSTATUS
QueueThreadMessage(
    DWORD dwThreadId,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UnqueueThreadMessage(
    DWORD dwThreadId,
    UINT* pMessage,
    WPARAM* pwParam,
    LPARAM* plParam
    );


//
// Drag/Drop on console windows (output.c)
//

UINT ConsoleDragQueryFile(
    IN HANDLE hDrop,
    IN PVOID lpFile,
    IN UINT cb
    );


VOID
DoDrop (
    IN WPARAM wParam,
    IN PCONSOLE_INFORMATION Console
    );


//
// input.c
//

NTSTATUS
ReadBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsRead,
    IN BOOL Peek,
    IN BOOL StreamRead,
    OUT PBOOL ResetWaitEvent,
    IN BOOLEAN Unicode
    );

NTSTATUS
ConsoleInputThread(
    IN PINPUT_THREAD_INIT_INFO pInputThreadInitInfo
    );

VOID
StoreKeyInfo(
    IN PMSG msg
    );

VOID
RetrieveKeyInfo(
    IN HWND hWnd,
    OUT PWORD pwVirtualKeyCode,
    OUT PWORD pwVirtualScanCode,
    IN BOOL FreeKeyInfo
    );

VOID
ClearKeyInfo(
    IN HWND hWnd
    );

NTSTATUS
ReadInputBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PINPUT_RECORD lpBuffer,
    IN OUT PDWORD nLength,
    IN BOOL Peek,
    IN BOOL WaitForData,
    IN BOOL StreamRead,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData OPTIONAL,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
#if defined(FE_SB)
    ,
    IN BOOLEAN Unicode
#endif
    );

DWORD
WriteInputBuffer(
    PCONSOLE_INFORMATION Console,
    PINPUT_INFORMATION InputBufferInformation,
    PINPUT_RECORD lpBuffer,
    DWORD nLength
    );

DWORD
PrependInputBuffer(
    PCONSOLE_INFORMATION Console,
    PINPUT_INFORMATION InputBufferInformation,
    PINPUT_RECORD lpBuffer,
    DWORD nLength
    );

NTSTATUS
CreateInputBuffer(
    IN ULONG NumberOfEvents OPTIONAL,
    IN PINPUT_INFORMATION InputBufferInformation
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    );

NTSTATUS
ReinitializeInputBuffer(
    OUT PINPUT_INFORMATION InputBufferInformation
    );

VOID
FreeInputBuffer(
    IN PINPUT_INFORMATION InputBufferInformation
    );

#if defined(FE_SB)
VOID
ProcessCreateConsoleWindow(
    IN LPMSG lpMsg
    );

NTSTATUS
WaitForMoreToRead(
    IN PINPUT_INFORMATION InputInformation,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
    );

ULONG
GetControlKeyState(
    LPARAM lParam
    );

VOID
TerminateRead(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInfo,
    IN DWORD Flag
    );
#endif

NTSTATUS
GetNumberOfReadyEvents(
    IN PINPUT_INFORMATION InputInformation,
    OUT PULONG NumberOfEvents
    );

NTSTATUS
FlushInputBuffer(
    IN PINPUT_INFORMATION InputInformation
    );

NTSTATUS
FlushAllButKeys(
    PINPUT_INFORMATION InputInformation
    );

NTSTATUS
SetInputBufferSize(
    IN PINPUT_INFORMATION InputInformation,
    IN ULONG Size
    );

BOOL
HandleSysKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN PBOOL pbUnlockConsole
    );

VOID
HandleKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
HandleMouseEvent(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
HandleMenuEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD wParam
    );

VOID
HandleFocusEvent(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL bSetFocus
    );

VOID
HandleCtrlEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD EventType
    );

#define CONSOLE_SHUTDOWN_FAILED 0
#define CONSOLE_SHUTDOWN_SUCCEEDED 1
#define CONSOLE_SHUTDOWN_SYSTEM 2

int
CreateCtrlThread(
    IN PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList,
    IN ULONG ProcessHandleListLength,
    IN PWCHAR Title,
    IN DWORD EventType,
    IN BOOL fForce
    );

VOID
UnlockConsole(
    IN PCONSOLE_INFORMATION Console
    );

ULONG
ShutdownConsole(
    IN HANDLE ConsoleHandle,
    IN DWORD dwFlags
    );

//
// link.c
//

#define LINK_NOINFO      0
#define LINK_SIMPLEINFO  1
#define LINK_FULLINFO    2

DWORD
GetLinkProperties(
    LPWSTR pszLinkName,
    LPVOID lpvBuffer,
    UINT cb
   );

DWORD
GetTitleFromLinkName(
    IN  LPWSTR szLinkName,
    OUT LPWSTR szTitle
    );

//
// misc.c
//

VOID
InitializeFonts( VOID );

BOOL
InitializeCustomCP( VOID );

#define EF_NEW         0x0001 // a newly available face
#define EF_OLD         0x0002 // a previously available face
#define EF_ENUMERATED  0x0004 // all sizes have been enumerated
#define EF_OEMFONT     0x0008 // an OEM face
#define EF_TTFONT      0x0010 // a TT face
#define EF_DEFFACE     0x0020 // the default face

NTSTATUS
EnumerateFonts( DWORD Flags );

VOID
InitializeMouseButtons( VOID );

NTSTATUS
GetMouseButtons(
    PULONG NumButtons
    );

NTSTATUS
FindTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT CodePage,
    OUT PTEXT_BUFFER_FONT_INFO TextFontInfo
    );

NTSTATUS
StoreTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex,
    IN COORD FontSize,
    IN BYTE  FontFamily,
    IN LONG  FontWeight,
    IN LPWSTR FaceName,
    IN UINT CodePage
    );

NTSTATUS
RemoveTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
GetNumFonts(
    OUT PULONG NumberOfFonts
    );

NTSTATUS
GetAvailableFonts(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PVOID Buffer,
    IN OUT PULONG NumFonts
    );

NTSTATUS
GetFontSize(
    IN DWORD  FontIndex,
    OUT PCOORD FontSize
    );

NTSTATUS
GetCurrentFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PULONG FontIndex,
    OUT PCOORD FontSize
    );

NTSTATUS
SetFont(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
SetScreenBufferFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex
#if defined(FE_SB)
    ,
    IN UINT CodePage
#endif
    );

int
ConvertToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,
    OUT LPSTR Target,
    IN int TargetLength
    );

int
ConvertInputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,
    OUT LPWSTR Target,
    IN int TargetLength
    );

#if defined(FE_SB)
WCHAR
SB_CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch
    );

WCHAR
SB_CharToWchar(
    IN UINT Codepage,
    IN char Ch
    );

#else
WCHAR
CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch
    );

WCHAR
CharToWchar(
    IN UINT Codepage,
    IN char Ch
    );
#endif

char
WcharToChar(
    IN UINT Codepage,
    IN WCHAR Wchar
    );

int
ConvertOutputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,
    OUT LPWSTR Target,
    IN int TargetLength
    );

int
ConvertOutputToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    );

NTSTATUS
RealUnicodeToFalseUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength, // in chars
    IN UINT Codepage
    );

NTSTATUS
FalseUnicodeToRealUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength, // in chars
    IN UINT Codepage
    );

VOID
InitializeSubst( VOID );

VOID
ShutdownSubst( VOID );

ULONG
SrvConsoleSubst(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

typedef struct tagFACENODE {
     struct tagFACENODE *pNext;
     DWORD  dwFlag;
     WCHAR  awch[];
} FACENODE, *PFACENODE;

BOOL DoFontEnum(
    IN HDC hDC OPTIONAL,
    IN LPWSTR pwszFace OPTIONAL,
    IN SHORT TTPointSize);

#if defined(FE_SB)
VOID
SetConsoleCPInfo(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Output
    );

BOOL
CheckBisectStringW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes
    );

BOOL
CheckBisectProcessW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes,
    IN SHORT OriginalXPosition,
    IN BOOL Echo
    );
#endif // FE_SB

//
// directio.c
//


ULONG
SrvGetConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvReadConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvReadConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvFillConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvCreateConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
TranslateOutputToPaddingUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    );

//
// getset.c
//

ULONG
SrvGetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleNumberOfFonts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleNumberOfInputEvents(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetLargestConsoleWindowSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleScreenBufferInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleSelectionInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleMouseInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleFontInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleFontSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCurrentFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGenerateConsoleCtrlEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleActiveScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvFlushConsoleInputBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleScreenBufferSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleCursorPosition(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleWindowInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvScrollConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleTextAttribute(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleIcon(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
SetScreenColors(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Attributes,
    IN WORD PopupAttributes,
    IN BOOL UpdateWholeScreen
    );

ULONG
SrvSetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleKeyboardLayoutName(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleWindow(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// stream.c
//

NTSTATUS
CookedRead(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

NTSTATUS
ReadChars(
    IN PINPUT_INFORMATION InputInfo,
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN OUT PWCHAR lpBuffer,
    IN OUT PDWORD NumBytes,
    IN DWORD InitialNumBytes,
    IN DWORD CtrlWakeupMask,
    IN PHANDLE_DATA HandleData,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCSR_API_MSG Message OPTIONAL,
    IN HANDLE HandleIndex,
    IN USHORT ExeNameLength,
    IN PWCHAR ExeName,
    IN BOOLEAN Unicode
    );

ULONG
SrvOpenConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvReadConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvDuplicateHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
UnblockWriteConsole(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Reason);

NTSTATUS
CloseInputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle
    );

NTSTATUS
CloseOutputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle,
    IN BOOLEAN FreeHandle
    );

ULONG
SrvCloseHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
MakeCursorVisible(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition
    );

#if defined(FE_SB)
HANDLE
FindActiveScreenBufferHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
WriteString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR String,
    IN ULONG NumChars,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    );
#endif

//
// cursor.c
//

NTSTATUS
SetCursorInformation(
    PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    );

NTSTATUS
SetCursorPosition(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position,
    IN BOOL  TurnOn
    );

NTSTATUS
SetCursorMode(
    PSCREEN_INFORMATION ScreenInfo,
    BOOLEAN DoubleCursor
    );

VOID
CursorTimerRoutine(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#if defined(FE_SB)
VOID
SB_InvertPixels(
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif

VOID
ConsoleHideCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
ConsoleShowCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#ifdef i386
NTSTATUS
SetCursorInformationHW(
    PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    );

NTSTATUS
SetCursorPositionHW(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position
    );
#endif

//
// cmdline.c
//

VOID
InitializeConsoleCommandData(
    IN PCONSOLE_INFORMATION Console
    );

ULONG
SrvAddConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliasesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliasExesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliases(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliasExes(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvExpungeConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvSetConsoleNumberOfCommands(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleCommandHistoryLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvSetConsoleCommandHistoryMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
MatchandCopyAlias(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR Source,
    IN USHORT SourceLength,
    OUT PWCHAR TargetBuffer,
    IN OUT PUSHORT TargetLength,
    IN LPWSTR Exe,
    IN USHORT ExeLength,
    OUT PDWORD LineCount
    );

NTSTATUS
AddCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR Command,
    IN USHORT Length,
    IN BOOL HistoryNoDup
    );

NTSTATUS
RetrieveCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN WORD VirtualKeyCode,
    IN PWCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG CommandSize
    );

PCOMMAND_HISTORY
AllocateCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD AppNameLength,
    IN PWCHAR AppName,
    IN HANDLE ProcessHandle
    );

VOID
ResetCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    );

ULONG
SrvGetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
FreeAliasBuffers(
    IN PCONSOLE_INFORMATION Console
    );

VOID
FreeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    );

VOID
FreeCommandHistoryBuffers(
    IN OUT PCONSOLE_INFORMATION Console
    );

VOID
ResizeCommandHistoryBuffers(
    IN PCONSOLE_INFORMATION Console,
    IN UINT NumCommands
    );

int
MyStringCompareW(
    IN LPWSTR Str1,
    IN LPWSTR Str2,
    IN USHORT Length,
    IN BOOLEAN bCaseInsensitive
    );

int
LoadStringExW(
    IN HINSTANCE hModule,
    IN UINT      wID,
    OUT LPWSTR   lpBuffer,
    IN int       cchBufferMax,
    IN WORD      wLangId
    );

//
// srvinit.c
//

ULONG
SrvAllocConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvFreeConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvAttachConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleProcessList(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
RemoveConsole(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE ProcessHandle,
    IN HANDLE ProcessId
    );

BOOL
MapHandle(
    IN HANDLE ClientProcessHandle,
    IN HANDLE ServerHandle,
    OUT PHANDLE ClientHandle
    );

VOID
InitializeConsoleAttributes( VOID );

VOID
GetRegistryValues(
    IN LPWSTR ConsoleTitle,
    OUT PCONSOLE_REGISTRY_INFO RegInfo
    );

#if defined(FE_SB)
NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    );

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    );

NTSTATUS
MyRegQueryValueEx(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData,
    OUT LPDWORD lpDataLength
    );

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    );
#endif

LPWSTR
TranslateConsoleTitle(
    LPWSTR ConsoleTitle,
    PUSHORT pcbTranslatedLength,
    BOOL Unexpand,
    BOOL Substitute
    );

NTSTATUS
GetConsoleLangId(
    IN UINT OutputCP,
    OUT LANGID* pLangId
    );

ULONG
SrvGetConsoleLangId(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// bitmap.c
//

NTSTATUS
CreateConsoleBitmap(
    IN OUT PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsInfo,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID *lpBitmap,
    OUT HANDLE *hMutex
    );

NTSTATUS
WriteRegionToScreenBitMap(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

ULONG
SrvInvalidateBitMapRect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvVDMConsoleOperation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// private.c
//

VOID
UpdateMousePosition(
    PSCREEN_INFORMATION ScreenInfo,
    COORD Position
    );

ULONG
SrvSetConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvShowConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvConsoleMenuControl(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsolePalette(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
SetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
UnsetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    );

ULONG
SrvRegisterConsoleVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
SrvConsoleNotifyLastClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleMenuClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleKeyShortcuts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

#ifdef i386

VOID
ReadRegionFromScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region,
    IN PCHAR_INFO ReadBufPtr
    );

VOID
ScrollHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    );

ULONG
MatchWindowSize(
#if defined(FE_SB)
    IN UINT CodePage,
#endif
    IN COORD WindowSize,
    OUT PCOORD pWindowSize
    );

BOOL
SetVideoMode(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
DisplayModeTransition(
    IN BOOL Foreground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
ConvertToWindowed(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
ConvertToFullScreen(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
SetROMFontCodePage(
    IN UINT wCodePage,
    IN ULONG ModeIndex
    );

#endif

BOOL
InitializeFullScreen( VOID );

NTSTATUS
ChangeDispSettings(
    PCONSOLE_INFORMATION Console,
    HWND hwnd,
    DWORD dwFlags
    );

#define SCREEN_BUFFER_POINTER(X,Y,XSIZE,CELLSIZE) (((XSIZE * (Y)) + (X)) * (ULONG)CELLSIZE)

//
// menu.c
//

VOID
InitSystemMenu(
    IN PCONSOLE_INFORMATION Console
    );

VOID
InitializeMenu(
    IN PCONSOLE_INFORMATION Console
    );

VOID
SetWinText(
    IN PCONSOLE_INFORMATION Console,
    IN UINT wID,
    IN BOOL Add
    );

VOID
PropertiesDlgShow(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL fCurrent
    );

VOID
PropertiesUpdate(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE hClientSection
    );

//
// fontdlg.c
//

int
FindCreateFont(
    DWORD Family,
    LPWSTR pwszTTFace,
    COORD Size,
    LONG Weight,
    UINT CodePage);

//
// clipbrd.c
//

VOID
DoCopy(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DoMark(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DoSelectAll(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DoStringPaste(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR pwStr,
    IN UINT DataSize
    );

VOID
DoPaste(
    IN PCONSOLE_INFORMATION Console
    );

VOID
InitializeMouseSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    );

VOID
ExtendSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    );

VOID
ClearSelection(
    IN PCONSOLE_INFORMATION Console
    );

VOID
StoreSelection(
    IN PCONSOLE_INFORMATION Console
    );

VOID
ColorSelection(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT          Rect,
    IN ULONG                Attr
    );

VOID
InvertSelection(
    IN PCONSOLE_INFORMATION Console,
    BOOL Inverting
    );

#if defined(FE_SB)
BOOL
SB_MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    );
#else
BOOL
MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    );
#endif

VOID
ConvertToMouseSelect(
    IN PCONSOLE_INFORMATION Console,
    IN COORD MousePosition
    );

VOID
DoScroll(
    IN PCONSOLE_INFORMATION Console
    );

VOID
ClearScroll(
    IN PCONSOLE_INFORMATION Console
    );



//
// External private functions used by consrv
//

BOOL
SetConsoleReserveKeys(
    HWND hWnd,
    DWORD fsReserveKeys
    );

int APIENTRY
GreGetDIBitsInternal(
    HDC hdc,
    HBITMAP hBitmap,
    UINT iStartScan,
    UINT cNumScan,
    LPBYTE pjBits,
    LPBITMAPINFO pBitsInfo,
    UINT iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo
    );


#if defined(FE_SB)
//
// constubs.c
//
ULONG
SrvGetConsoleCharType(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleLocalEUDC(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


ULONG
SrvSetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvRegisterConsoleOS2(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleOS2OemFormat(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

#if defined(FE_IME)
ULONG
SrvGetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvRegisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvUnregisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );
#endif // FE_IME

//
// dispatch.c
//

VOID
InvertPixels(
    IN PSCREEN_INFORMATION ScreenInfo
    );

WCHAR
CharToWchar(
    IN PCONSOLE_INFORMATION Console,
    IN UINT Codepage,
    IN char *Ch
    );

BOOL
MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    );

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\cursor.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cursor.c

Abstract:

        This file implements the NT console server cursor routines.

Author:

    Therese Stowell (thereses) 5-Dec-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//#define PROFILE_GDI
#ifdef PROFILE_GDI
LONG InvertCount;
#define INVERT_CALL InvertCount++
#else
#define INVERT_CALL
#endif

extern UINT guCaretBlinkTime;

VOID
InvertPixels(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine inverts the cursor pixels, making it either visible or
    invisible.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
#ifdef FE_SB
    if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
        PCONVERSIONAREA_INFORMATION ConvAreaInfo;
        SMALL_RECT Region;
        SMALL_RECT CursorRegion;
        SMALL_RECT ClippedRegion;

#ifdef DBG_KATTR
//        BeginKAttrCheck(ScreenInfo);
#endif

        ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot;
        CursorRegion.Left = CursorRegion.Right  = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        CursorRegion.Top  = CursorRegion.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
        while (ConvAreaInfo) {

            if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_HIDE_FOR_SCROLL))==0) {
                //
                // Do clipping region
                //
                Region.Left   = ScreenInfo->Window.Left +
                                ConvAreaInfo->CaInfo.rcViewCaWindow.Left +
                                ConvAreaInfo->CaInfo.coordConView.X;
                Region.Right  = Region.Left +
                                (ConvAreaInfo->CaInfo.rcViewCaWindow.Right -
                                 ConvAreaInfo->CaInfo.rcViewCaWindow.Left);
                Region.Top    = ScreenInfo->Window.Top +
                                ConvAreaInfo->CaInfo.rcViewCaWindow.Top +
                                ConvAreaInfo->CaInfo.coordConView.Y;
                Region.Bottom = Region.Top +
                                (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom -
                                 ConvAreaInfo->CaInfo.rcViewCaWindow.Top);
                ClippedRegion.Left   = max(Region.Left,   ScreenInfo->Window.Left);
                ClippedRegion.Top    = max(Region.Top,    ScreenInfo->Window.Top);
                ClippedRegion.Right  = min(Region.Right,  ScreenInfo->Window.Right);
                ClippedRegion.Bottom = min(Region.Bottom, ScreenInfo->Window.Bottom);
                if (ClippedRegion.Right < ClippedRegion.Left ||
                    ClippedRegion.Bottom < ClippedRegion.Top) {
                    ;
                }
                else {
                    Region = ClippedRegion;
                    ClippedRegion.Left   = max(Region.Left,   CursorRegion.Left);
                    ClippedRegion.Top    = max(Region.Top,    CursorRegion.Top);
                    ClippedRegion.Right  = min(Region.Right,  CursorRegion.Right);
                    ClippedRegion.Bottom = min(Region.Bottom, CursorRegion.Bottom);
                    if (ClippedRegion.Right < ClippedRegion.Left ||
                        ClippedRegion.Bottom < ClippedRegion.Top) {
                        ;
                    }
                    else {
                        return;
                    }
                }
            }
            ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
        }
    }
#endif  // FE_SB

    {
        ULONG CursorYSize;
        POLYPATBLT PolyData;
#ifdef FE_SB
        SHORT RowIndex;
        PROW Row;
        COORD TargetPoint;
        int iTrailing = 0;
        int iDBCursor = 1;
#endif

        INVERT_CALL;
        CursorYSize = ScreenInfo->BufferInfo.TextInfo.CursorYSize;
        if (ScreenInfo->BufferInfo.TextInfo.DoubleCursor) {
            if (ScreenInfo->BufferInfo.TextInfo.CursorSize > 50)
                CursorYSize = CursorYSize >> 1;
            else
                CursorYSize = CursorYSize << 1;
        }
#ifdef FE_SB
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        {
            TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            ASSERT(Row);

            if ((Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE) &&
                ScreenInfo->BufferInfo.TextInfo.CursorDBEnable) {

                iTrailing = 1;
                iDBCursor = 2;
            } else if ((Row->CharRow.KAttrs[TargetPoint.X] & ATTR_LEADING_BYTE) &&
                ScreenInfo->BufferInfo.TextInfo.CursorDBEnable) {

                iDBCursor = 2;
            }
        }

        PolyData.x  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X -
                    ScreenInfo->Window.Left - iTrailing) * SCR_FONTSIZE(ScreenInfo).X;
        PolyData.y  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y -
                    ScreenInfo->Window.Top) * SCR_FONTSIZE(ScreenInfo).Y +
                    (CURSOR_Y_OFFSET_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,CursorYSize));
        PolyData.cx = SCR_FONTSIZE(ScreenInfo).X * iDBCursor;
        PolyData.cy = CursorYSize;
#else
        PolyData.x  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-ScreenInfo->Window.Left)*SCR_FONTSIZE(ScreenInfo).X;
        PolyData.y  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-ScreenInfo->Window.Top)*SCR_FONTSIZE(ScreenInfo).Y+(CURSOR_Y_OFFSET_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,CursorYSize));
        PolyData.cx = SCR_FONTSIZE(ScreenInfo).X;
        PolyData.cy = CursorYSize;
#endif
        PolyData.BrClr.hbr = GetStockObject(LTGRAY_BRUSH);

        PolyPatBlt(ScreenInfo->Console->hDC, PATINVERT, &PolyData, 1, PPB_BRUSH);

        GdiFlush();
    }
}

VOID
ConsoleShowCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine makes the cursor visible both in the data structures
    and on the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ASSERT (ScreenInfo->BufferInfo.TextInfo.UpdatingScreen>0);
        if (--ScreenInfo->BufferInfo.TextInfo.UpdatingScreen == 0) {
            ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;
        }
    }
}

VOID
ConsoleHideCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine makes the cursor invisible both in the data structures
    and on the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        if (++ScreenInfo->BufferInfo.TextInfo.UpdatingScreen == 1) {
            if (ScreenInfo->BufferInfo.TextInfo.CursorVisible &&
                ScreenInfo->BufferInfo.TextInfo.CursorOn &&
                ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo &&
                !(ScreenInfo->Console->Flags & CONSOLE_IS_ICONIC)) {
                InvertPixels(ScreenInfo);
                ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;
            }
        }
    }
}

NTSTATUS
SetCursorInformation(
    IN PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    )

/*++

Routine Description:

    This routine sets the cursor size and visibility both in the data structures
    and on the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

    Size - cursor size

    Visible - cursor visibility

Return Value:

    Status

--*/

{
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ConsoleHideCursor(ScreenInfo);
        ScreenInfo->BufferInfo.TextInfo.CursorSize = Size;
        ScreenInfo->BufferInfo.TextInfo.CursorVisible = Visible;
        ScreenInfo->BufferInfo.TextInfo.CursorYSize = (WORD)CURSOR_SIZE_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,ScreenInfo->BufferInfo.TextInfo.CursorSize);
#ifdef i386
        if ((!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) &&
            ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            SetCursorInformationHW(ScreenInfo,Size,Visible);
        }
#endif
        ConsoleShowCursor(ScreenInfo);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SetCursorMode(
    IN PSCREEN_INFORMATION ScreenInfo,
    BOOLEAN DoubleCursor
    )

/*++

Routine Description:

    This routine sets a flag saying whether the cursor should be displayed
    with it's default size or it should be modified to indicate the
    insert/overtype mode has changed.

Arguments:

    ScreenInfo - pointer to screen info structure.

    DoubleCursor - should we indicated non-normal mode

Return Value:

    Status

--*/

{
    if ((ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) &&
        (ScreenInfo->BufferInfo.TextInfo.DoubleCursor != DoubleCursor)) {
        ConsoleHideCursor(ScreenInfo);
        ScreenInfo->BufferInfo.TextInfo.DoubleCursor = DoubleCursor;
#ifdef i386
        if ((!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) &&
            ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            SetCursorInformationHW(ScreenInfo,
                       ScreenInfo->BufferInfo.TextInfo.CursorSize,
                       ScreenInfo->BufferInfo.TextInfo.CursorVisible);
        }
#endif
        ConsoleShowCursor(ScreenInfo);
    }
    return STATUS_SUCCESS;
}

VOID
CursorTimerRoutine(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine is called when the timer in the console with the focus
    goes off.  It blinks the cursor.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
    if (!(ScreenInfo->Console->Flags & CONSOLE_HAS_FOCUS))
        return;

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {

        //
        // Update the cursor pos in USER so accessibility will work
        //

        if (ScreenInfo->BufferInfo.TextInfo.CursorMoved) {

            CONSOLE_CARET_INFO ConsoleCaretInfo;
            DWORD dwFlags = 0;

            ScreenInfo->BufferInfo.TextInfo.CursorMoved = FALSE;
            ConsoleCaretInfo.hwnd = ScreenInfo->Console->hWnd;
            ConsoleCaretInfo.rc.left = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X - ScreenInfo->Window.Left) * SCR_FONTSIZE(ScreenInfo).X;
            ConsoleCaretInfo.rc.top = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Top) * SCR_FONTSIZE(ScreenInfo).Y;
            ConsoleCaretInfo.rc.right = ConsoleCaretInfo.rc.left + SCR_FONTSIZE(ScreenInfo).X;
            ConsoleCaretInfo.rc.bottom = ConsoleCaretInfo.rc.top + SCR_FONTSIZE(ScreenInfo).Y;
            NtUserConsoleControl(ConsoleSetCaretInfo,
                                 &ConsoleCaretInfo,
                                 sizeof(ConsoleCaretInfo));
            if (ScreenInfo->BufferInfo.TextInfo.CursorVisible) {
                dwFlags |= CONSOLE_CARET_VISIBLE;
            }
            if (ScreenInfo->Console->Flags & CONSOLE_SELECTING) {
                dwFlags |= CONSOLE_CARET_SELECTION;
            }
            ConsoleNotifyWinEvent(ScreenInfo->Console,
                                  EVENT_CONSOLE_CARET,
                                  dwFlags,
                                  PACKCOORD(ScreenInfo->BufferInfo.TextInfo.CursorPosition));
        }

        // if the DelayCursor flag has been set, wait one more tick before toggle.
        // This is used to guarantee the cursor is on for a finite period of time
        // after a move and off for a finite period of time after a WriteString

        if (ScreenInfo->BufferInfo.TextInfo.DelayCursor) {
            ScreenInfo->BufferInfo.TextInfo.DelayCursor = FALSE;
            return;
        }

        //
        // Don't blink the cursor for remote sessions.
        //
        if ((NtCurrentPeb()->SessionId != WTSGetActiveConsoleSessionId() ||
                (guCaretBlinkTime == (UINT)-1)) &&
            ScreenInfo->BufferInfo.TextInfo.CursorOn) {
            return;
        }

        if (ScreenInfo->BufferInfo.TextInfo.CursorVisible &&
            !ScreenInfo->BufferInfo.TextInfo.UpdatingScreen) {
            InvertPixels(ScreenInfo);
            ScreenInfo->BufferInfo.TextInfo.CursorOn = !ScreenInfo->BufferInfo.TextInfo.CursorOn;
        }
    }
}

#ifdef i386
NTSTATUS
SetCursorPositionHW(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position
    )

/*++

Routine Description:

    This routine moves the cursor.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Position - Contains the new position of the cursor in screen buffer
    coordinates.

Return Value:

    none.

--*/

{
#if defined(FE_SB)
    FSVIDEO_CURSOR_POSITION CursorPosition;
    SHORT RowIndex;
    PROW Row;
    COORD TargetPoint;

    if (ScreenInfo->ConvScreenInfo)
        return STATUS_SUCCESS;

    TargetPoint.X = Position.X;
    TargetPoint.Y = Position.Y;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (!CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        CursorPosition.dwType = CHAR_TYPE_SBCS;
    else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
        CursorPosition.dwType = CHAR_TYPE_TRAILING;
    else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_LEADING_BYTE)
        CursorPosition.dwType = CHAR_TYPE_LEADING;
    else
        CursorPosition.dwType = CHAR_TYPE_SBCS;

    // set cursor position

    CursorPosition.Coord.Column = Position.X - ScreenInfo->Window.Left;
    CursorPosition.Coord.Row    = Position.Y - ScreenInfo->Window.Top;
#else
    VIDEO_CURSOR_POSITION CursorPosition;

    // set cursor position

    CursorPosition.Column = Position.X - ScreenInfo->Window.Left;
    CursorPosition.Row = Position.Y - ScreenInfo->Window.Top;
#endif

    return GdiFullscreenControl(FullscreenControlSetCursorPosition,
                                   (PVOID)&CursorPosition,
                                   sizeof(CursorPosition),
                                   NULL,
                                   0);
}
#endif

NTSTATUS
SetCursorPosition(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position,
    IN BOOL  TurnOn
    )

/*++

Routine Description:

    This routine sets the cursor position in the data structures and on
    the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

    Position - new position of cursor

    TurnOn - true if cursor should be left on, false if should be left off

Return Value:

    Status

--*/

{
    //
    // Ensure that the cursor position is within the constraints of the screen
    // buffer.
    //
    if (Position.X >= ScreenInfo->ScreenBufferSize.X ||
        Position.Y >= ScreenInfo->ScreenBufferSize.Y ||
        Position.X < 0 || Position.Y < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    ConsoleHideCursor(ScreenInfo);
    ScreenInfo->BufferInfo.TextInfo.CursorPosition = Position;
#ifdef i386
    if ((!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) &&
        ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        SetCursorPositionHW(ScreenInfo,Position);
    }
#endif
    ConsoleShowCursor(ScreenInfo);

// if we have the focus, adjust the cursor state

    if (ScreenInfo->Console->Flags & CONSOLE_HAS_FOCUS) {

        if (TurnOn) {
            ScreenInfo->BufferInfo.TextInfo.DelayCursor = FALSE;
            CursorTimerRoutine(ScreenInfo);
        } else {
            ScreenInfo->BufferInfo.TextInfo.DelayCursor = TRUE;
        }
        ScreenInfo->BufferInfo.TextInfo.CursorMoved = TRUE;
    }

    return STATUS_SUCCESS;
}

#ifdef i386
NTSTATUS
SetCursorInformationHW(
    PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    )
{
    VIDEO_CURSOR_ATTRIBUTES CursorAttr;
    ULONG FontSizeY;

    if (ScreenInfo->BufferInfo.TextInfo.DoubleCursor) {
        if (Size > 50)
            Size = Size >> 1;
        else
            Size = Size << 1;
    }
    ASSERT (Size <= 100 && Size > 0);
    FontSizeY = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) > 25 ? 8 : 16;
    CursorAttr.Height = (USHORT)CURSOR_PERCENTAGE_TO_TOP_SCAN_LINE(FontSizeY,Size);
    CursorAttr.Width = 31;
    CursorAttr.Enable = Visible;

    return GdiFullscreenControl(FullscreenControlSetCursorAttributes,
                                   (PVOID)&CursorAttr,
                                   sizeof(CursorAttr),
                                   NULL,
                                   0);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\convarea.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    convarea.c

Abstract:

Author:

    KazuM Mar.8,1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_IME)




VOID
LinkConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )
{
    PCONVERSIONAREA_INFORMATION PrevConvAreaInfo;

    if (Console->ConsoleIme.ConvAreaRoot == NULL) {
        Console->ConsoleIme.ConvAreaRoot = ConvAreaInfo;
    }
    else {
        PrevConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
        while (PrevConvAreaInfo->ConvAreaNext)
            PrevConvAreaInfo = PrevConvAreaInfo->ConvAreaNext;
        PrevConvAreaInfo->ConvAreaNext = ConvAreaInfo;
    }
}


NTSTATUS
FreeConvAreaScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine frees the memory associated with a screen buffer.

Arguments:

    ScreenInfo - screen buffer data to free.

Return Value:

Note: console handle table lock must be held when calling this routine

--*/

{
    return FreeScreenBuffer(ScreenInfo);
}



NTSTATUS
AllocateConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    )
{
    COORD dwWindowSize;
    CHAR_INFO Fill, PopupFill;
    PCONVERSIONAREA_INFORMATION ca;
    int FontIndex;
    NTSTATUS Status;

    //
    // allocate console data
    //

    if (Console->CurrentScreenBuffer == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    ca = ConsoleHeapAlloc(CONVAREA_TAG,
                          sizeof(CONVERSIONAREA_INFORMATION));
    if (ca == NULL) {
        return STATUS_NO_MEMORY;
    }

    dwWindowSize.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer);
    dwWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer);
    Fill.Attributes = Console->CurrentScreenBuffer->Attributes;
    PopupFill.Attributes = Console->CurrentScreenBuffer->PopupAttributes;
    FontIndex = FindCreateFont(CON_FAMILY(Console),
                               CON_FACENAME(Console),
                               CON_FONTSIZE(Console),
                               CON_FONTWEIGHT(Console),
                               CON_FONTCODEPAGE(Console)
                              );
    Status = CreateScreenBuffer(&ca->ScreenBuffer,
                                dwWindowSize,
                                FontIndex,
                                dwScreenBufferSize,
                                Fill,
                                PopupFill,
                                Console,
                                CONSOLE_TEXTMODE_BUFFER,
                                NULL,
                                NULL,
                                NULL,
                                CURSOR_SMALL_SIZE,
                                NULL
                               );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ca);
        return Status;
    }

    *ConvAreaInfo = ca;

    return STATUS_SUCCESS;
}



NTSTATUS
SetUpConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD coordCaBuffer,
    IN SMALL_RECT rcViewCaWindow,
    IN COORD coordConView,
    IN DWORD dwOption,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    )
{
    NTSTATUS Status;
    PCONVERSIONAREA_INFORMATION ca;

    Status = AllocateConversionArea(Console, coordCaBuffer, &ca);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ca->ConversionAreaMode    = dwOption;
    ca->CaInfo.coordCaBuffer  = coordCaBuffer;
    ca->CaInfo.rcViewCaWindow = rcViewCaWindow;
    ca->CaInfo.coordConView   = coordConView;

    ca->ConvAreaNext = NULL;

    ca->ScreenBuffer->ConvScreenInfo = ca;

    LinkConversionArea(Console, ca);

    SetUndetermineAttribute(Console);

    *ConvAreaInfo = ca;

    return STATUS_SUCCESS;
}


VOID
WriteConvRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PSMALL_RECT ConvRegion
    )

/*++

Routine Description:

Arguments:

    ClippedRegion - Rectangle of region by screen coordinate.

Return Value:

--*/

{
    SMALL_RECT Region;
    SMALL_RECT ClippedRegion;

    if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER)
        return;

    while (ConvAreaInfo) {

        if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_HIDE_FOR_SCROLL))==0) {
            //
            // Do clipping region
            //
            Region.Left   = ScreenInfo->Window.Left +
                            ConvAreaInfo->CaInfo.rcViewCaWindow.Left +
                            ConvAreaInfo->CaInfo.coordConView.X;
            Region.Right  = Region.Left +
                            (ConvAreaInfo->CaInfo.rcViewCaWindow.Right -
                             ConvAreaInfo->CaInfo.rcViewCaWindow.Left);
            Region.Top    = ScreenInfo->Window.Top +
                            ConvAreaInfo->CaInfo.rcViewCaWindow.Top +
                            ConvAreaInfo->CaInfo.coordConView.Y;
            Region.Bottom = Region.Top +
                            (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom -
                             ConvAreaInfo->CaInfo.rcViewCaWindow.Top);
            ClippedRegion.Left   = max(Region.Left,   ScreenInfo->Window.Left);
            ClippedRegion.Top    = max(Region.Top,    ScreenInfo->Window.Top);
            ClippedRegion.Right  = min(Region.Right,  ScreenInfo->Window.Right);
            ClippedRegion.Bottom = min(Region.Bottom, ScreenInfo->Window.Bottom);
            if (ClippedRegion.Right < ClippedRegion.Left ||
                ClippedRegion.Bottom < ClippedRegion.Top) {
               /* TODO: Fix this. */;
            } else {
                Region = ClippedRegion;
                ClippedRegion.Left   = max(Region.Left,   ConvRegion->Left);
                ClippedRegion.Top    = max(Region.Top,    ConvRegion->Top);
                ClippedRegion.Right  = min(Region.Right,  ConvRegion->Right);
                ClippedRegion.Bottom = min(Region.Bottom, ConvRegion->Bottom);
                if (ClippedRegion.Right < ClippedRegion.Left ||
                    ClippedRegion.Bottom < ClippedRegion.Top) {
                    /* TODO: Fix this */;
                } else {
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
                    WriteRegionToScreen(ConvAreaInfo->ScreenBuffer,
                                        &ClippedRegion
                                       );
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
                }
            }
        }
        ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
    }
}


BOOL
ConsoleImeBottomLineUse(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollOffset
    )

/*++

Routine Description:

Arguments:

    ScreenInfo -

    ScrollOffset -

Return Value:

--*/

{
    SMALL_RECT ScrollRectangle;
    COORD DestinationOrigin;
    CHAR_INFO Fill;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    SMALL_RECT WriteRegion;
    BOOL fRedraw = FALSE;

    if (!(ScreenInfo->Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL)) {
        ScreenInfo->Console->ConsoleIme.ScrollFlag |= HIDE_FOR_SCROLL;
        if (ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot) {
            do {
                if ((ConvAreaInfo->ConversionAreaMode & (CA_STATUS_LINE))==0) {
                    ConvAreaInfo->ConversionAreaMode |= CA_HIDE_FOR_SCROLL;
                    fRedraw = TRUE;
                }
            } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);

            if (fRedraw) {
                // Check code for must CONSOLE_TEXTMODE_BUFFER !!
                if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)
                {
                    ASSERT(FALSE);
                }
                else {
                    WriteRegion = ScreenInfo->Window;
                    WriteRegion.Bottom--;
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
                    WriteToScreen(ScreenInfo,&WriteRegion);
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
                }
            }
        }
    }

    if (ScrollOffset) {
        ScrollRectangle.Top = 1;
        ScrollRectangle.Left = 0;
        ScrollRectangle.Right = ScreenInfo->ScreenBufferSize.X-1;
        ScrollRectangle.Bottom = ScreenInfo->ScreenBufferSize.Y-1;
        ScrollRectangle.Bottom -= (ScrollOffset-1);
        DestinationOrigin.X = ScrollRectangle.Left;
        DestinationOrigin.Y = ScrollRectangle.Top-1;
        Fill.Char.UnicodeChar = '\0';
        Fill.Attributes = 0;
        ScrollRegion(ScreenInfo,
                     &ScrollRectangle,
                     NULL,
                     DestinationOrigin,
                     Fill
                    );
#if defined(FE_SB)
#if defined(FE_IME)
        if ( ! (ScreenInfo->Console->InputBuffer.ImeMode.Disable) &&
             ! (ScreenInfo->Console->InputBuffer.ImeMode.Unavailable) &&
             (ScreenInfo->Console->InputBuffer.ImeMode.Open) &&
             (ScrollRectangle.Left == ScreenInfo->Window.Left) &&
             (ScrollRectangle.Right == ScreenInfo->Window.Right) ) {
            ScrollRectangle.Top = ScreenInfo->Window.Bottom;
            ScrollRectangle.Bottom = ScreenInfo->Window.Bottom;
            WriteToScreen(ScreenInfo,&ScrollRectangle);
            WriteConvRegionToScreen(ScreenInfo,
                                    ScreenInfo->Console->ConsoleIme.ConvAreaRoot,
                                    &ScrollRectangle);
        }
#endif
#endif
    }
    else {
        ScreenInfo->Console->ConsoleIme.ScrollWaitCountDown = ScreenInfo->Console->ConsoleIme.ScrollWaitTimeout;
    }
    return TRUE;
}



VOID
ConsoleImeBottomLineInUse(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

Arguments:

    ScreenInfo -

Return Value:

--*/

{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    SMALL_RECT WriteRegion;
    BOOL fRedraw = FALSE;
    COORD CursorPosition;

    ScreenInfo->Console->ConsoleIme.ScrollFlag &= ~HIDE_FOR_SCROLL;
    if (ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot) {
        do {
            if (ConvAreaInfo->ConversionAreaMode & CA_HIDE_FOR_SCROLL) {
                ConvAreaInfo->ConversionAreaMode &= ~CA_HIDE_FOR_SCROLL;
                fRedraw = TRUE;
            }
        } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);

        if (fRedraw) {
            // Check code for must CONSOLE_TEXTMODE_BUFFER !!
            if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)
            {
                ASSERT(FALSE);
            }
            else {
                if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)) {
                    ConsoleHideCursor(ScreenInfo);
                    ConsoleImeBottomLineUse(ScreenInfo,1);
                    CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                    CursorPosition.Y--;
                    SetCursorPosition(ScreenInfo,CursorPosition,TRUE);
                    if (ScreenInfo->Console->lpCookedReadData) {
                        ((PCOOKED_READ_DATA)(ScreenInfo->Console->lpCookedReadData))->OriginalCursorPosition.Y--;
                    }
                    ConsoleShowCursor(ScreenInfo);
                } else if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == ScreenInfo->Window.Bottom) {
                    /* TODO: Fix this. */;
                }

                WriteRegion.Top = 0;
                WriteRegion.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
                WriteRegion.Left = 0;
                WriteRegion.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
                WriteToScreen(ScreenInfo,&WriteRegion);
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
            }
        }
    }
}



NTSTATUS
CreateConvAreaUndetermine(
    PCONSOLE_INFORMATION Console
    )
{
    PCONSOLE_IME_INFORMATION ConsoleIme = &Console->ConsoleIme;
    NTSTATUS Status;
    COORD coordCaBuffer;
    SMALL_RECT rcViewCaWindow;
    COORD coordConView;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if (ConsoleIme->ConvAreaCompStr) {
        ConsoleIme->ConvAreaCompStr =
            ConsoleHeapReAlloc(
                        0,
                        ConsoleIme->ConvAreaCompStr,
                        ConsoleHeapSize(
                                 ConsoleIme->ConvAreaCompStr)+sizeof(PCONVERSIONAREA_INFORMATION));
        if (ConsoleIme->ConvAreaCompStr == NULL)
            return STATUS_NO_MEMORY;
    }
    else {
        ConsoleIme->ConvAreaCompStr =
            ConsoleHeapAlloc(
                      CONVAREA_TAG,
                      sizeof(PCONVERSIONAREA_INFORMATION));
        if (ConsoleIme->ConvAreaCompStr == NULL)
            return STATUS_NO_MEMORY;
    }

    coordCaBuffer = Console->CurrentScreenBuffer->ScreenBufferSize;
    coordCaBuffer.Y = 1;
    rcViewCaWindow.Top    = 0;
    rcViewCaWindow.Left   = 0;
    rcViewCaWindow.Bottom = 0;
    rcViewCaWindow.Right  = 0;
    coordConView.X = 0;
    coordConView.Y = 0;
    Status = SetUpConversionArea(Console,
                                 coordCaBuffer,
                                 rcViewCaWindow,
                                 coordConView,
                                 (Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL) ?
                                     CA_HIDE_FOR_SCROLL :
                                     CA_HIDDEN,
                                 &ConvAreaInfo
                                );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ConsoleIme->ConvAreaCompStr[ConsoleIme->NumberOfConvAreaCompStr] = ConvAreaInfo;
    ConsoleIme->NumberOfConvAreaCompStr++;

    return Status;
}


NTSTATUS
CreateConvAreaModeSystem(
    PCONSOLE_INFORMATION Console
    )
{
    PCONSOLE_IME_INFORMATION ConsoleIme = &Console->ConsoleIme;
    NTSTATUS Status;
    COORD coordCaBuffer;
    SMALL_RECT rcViewCaWindow;
    COORD coordConView;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if (Console->CurrentScreenBuffer == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Create mode text buffer
     */
    coordCaBuffer = Console->CurrentScreenBuffer->ScreenBufferSize;
    coordCaBuffer.Y = 1;
    rcViewCaWindow.Top    = 0;
    rcViewCaWindow.Left   = 0;
    rcViewCaWindow.Bottom = 0;
    rcViewCaWindow.Right  = 0;
    coordConView.X = 0;
    coordConView.Y = 0;
    Status = SetUpConversionArea(Console,
                                 coordCaBuffer,
                                 rcViewCaWindow,
                                 coordConView,
                                 CA_HIDDEN+CA_STATUS_LINE,
                                 &ConvAreaInfo
                                );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ConsoleIme->ConvAreaMode = ConvAreaInfo;

    /*
     * Create system text buffer
     */
    Status = SetUpConversionArea(Console,
                                 coordCaBuffer,
                                 rcViewCaWindow,
                                 coordConView,
                                 CA_HIDDEN+CA_STATUS_LINE,
                                 &ConvAreaInfo
                                );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ConsoleIme->ConvAreaSystem = ConvAreaInfo;

    return Status;
}


#define LOCAL_BUFFER_SIZE 100
NTSTATUS
WriteUndetermineChars(
    PCONSOLE_INFORMATION Console,
    LPWSTR lpString,
    PBYTE  lpAtr,
    PWORD  lpAtrIdx,
    DWORD  NumChars  // character count
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    PSCREEN_INFORMATION ConvScreenInfo;
    WCHAR LocalBuffer[LOCAL_BUFFER_SIZE];
    BYTE LocalBufferA[LOCAL_BUFFER_SIZE];
    PWCHAR LocalBufPtr;
    PBYTE LocalBufPtrA;
    DWORD BufferSize;
    COORD Position;
    ULONG i;
    SMALL_RECT Region;
    COORD CursorPosition;
    WCHAR Char;
    WORD Attr;
    PCONSOLE_IME_INFORMATION ConsoleIme;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    DWORD ConvAreaIndex;
    NTSTATUS Status;
    ULONG NumStr;
    int WholeLen;
    int WholeRow;
    SHORT PosY;
    BOOL UndetAreaUp = FALSE;

    ConsoleIme = &Console->ConsoleIme;
    ScreenInfo = Console->CurrentScreenBuffer;

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));

    Position = ScreenInfo->BufferInfo.TextInfo.CursorPosition;

        if ((ScreenInfo->Window.Left <= Position.X && Position.X <= ScreenInfo->Window.Right) &&
            (ScreenInfo->Window.Top  <= Position.Y && Position.Y <= ScreenInfo->Window.Bottom)  ) {
            Position.X = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X - ScreenInfo->Window.Left;
            Position.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Top;
        }
        else {
            Position.X = 0;
            Position.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 2;
        }

    PosY = Position.Y;
    RtlUnicodeToMultiByteSize(&NumStr, lpString, NumChars*sizeof(WCHAR));

    WholeLen = (int)Position.X + (int)NumStr;
    WholeRow = WholeLen / CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    if ( ( PosY + WholeRow ) > ( CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 2) ) {
        PosY = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 2 - WholeRow;
        if (PosY < 0) {
            PosY = ScreenInfo->Window.Top;
        }
    }
    if (PosY != Position.Y) {
        Position.Y = PosY;
        UndetAreaUp = TRUE;
    }

    ConvAreaIndex = 0;

    BufferSize = NumChars;
    NumChars = 0;

    for (ConvAreaIndex = 0; NumChars < BufferSize; ConvAreaIndex++) {

        if (ConvAreaIndex+1 > ConsoleIme->NumberOfConvAreaCompStr) {
            Status = CreateConvAreaUndetermine(Console);
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
        ConvAreaInfo = ConsoleIme->ConvAreaCompStr[ConvAreaIndex];
        ConvScreenInfo = ConvAreaInfo->ScreenBuffer;
        ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X = Position.X;

        if ((ConvAreaInfo->ConversionAreaMode & CA_HIDDEN) ||
            (UndetAreaUp)) {
            /*
             * This conversion area need positioning onto cursor position.
             */
            CursorPosition.X = 0;
            CursorPosition.Y = (SHORT)(Position.Y + ConvAreaIndex);
            ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);
        }

        Region.Left = ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        Region.Top = 0;
        Region.Bottom = 0;

        while (NumChars < BufferSize) {
            i=0;
            LocalBufPtr = LocalBuffer;
            LocalBufPtrA = LocalBufferA;

            while (NumChars < BufferSize &&
                   i < LOCAL_BUFFER_SIZE &&
                   Position.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
                Char = *lpString;
                Attr = *lpAtr;
                if (Char >= (WCHAR)' ') {
                    if (IsConsoleFullWidth(Console->hDC,Console->OutputCP,Char)) {
                        if (i < (LOCAL_BUFFER_SIZE-1) &&
                            Position.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1) {
                            *LocalBufPtr++ = Char;
                            *LocalBufPtrA++ = ATTR_LEADING_BYTE;
                            *LocalBufPtr++ = Char;
                            *LocalBufPtrA++ = ATTR_TRAILING_BYTE;
                            Position.X+=2;
                            i+=2;
                        }
                        else {
                            Position.X++;
                            break;
                        }
                    }
                    else {
                        *LocalBufPtr++ = Char;
                        *LocalBufPtrA++ = 0;
                        Position.X++;
                        i++;
                    }
                }
                lpString++;
                lpAtr++;
                NumChars++;

                if (NumChars < BufferSize &&
                    Attr != *lpAtr)
                    break;
            }
            if (i != 0) {
                ConvScreenInfo->Attributes = lpAtrIdx[Attr & 0x07];
                if (Attr & 0x10) {
                    ConvScreenInfo->Attributes |= (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL);
                } else if (Attr & 0x20) {
                    ConvScreenInfo->Attributes |= (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL);
                }
                StreamWriteToScreenBufferIME(LocalBuffer,
                                             (SHORT)i,
                                             ConvScreenInfo,
                                             LocalBufferA);

                ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X += (SHORT)i;

                if (NumChars == BufferSize ||
                    Position.X >= CONSOLE_WINDOW_SIZE_X(ScreenInfo) ||
                    ( (Char >= (WCHAR)' ' &&
                      IsConsoleFullWidth(Console->hDC,Console->OutputCP,Char) &&
                      Position.X >= CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1) )
                   ) {

                    Region.Right = (SHORT)(ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X - 1);
                    ConsoleImeWindowInfo(Console,ConvAreaInfo,Region);

                    ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;

                    ConsoleImePaint(Console,ConvAreaInfo);

                    Position.X = 0;
                    break;
                }

                if (NumChars == BufferSize) {
                    return STATUS_SUCCESS;
                }
                continue;

            } else if (NumChars == BufferSize) {
                return STATUS_SUCCESS;
            }
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
            if (Position.X >= CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
                Position.X = 0;
                break;
            }
        }

    }

    for (; ConvAreaIndex < ConsoleIme->NumberOfConvAreaCompStr; ConvAreaIndex++) {
        ConvAreaInfo = ConsoleIme->ConvAreaCompStr[ConvAreaIndex];
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);
        }
    }

    return STATUS_SUCCESS;
}


VOID
WriteModeSystemChars(
    PCONSOLE_INFORMATION Console,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    PCHAR_INFO Buffer,
    DWORD NumberOfChars,
    DWORD ViewPosition
    )
{
    SMALL_RECT CharRegion;
    COORD CursorPosition;

    if (Buffer) {
        CharRegion.Left   = 0;
        CharRegion.Top    = 0;
        CharRegion.Right  = CalcWideCharToColumn(Console,Buffer,NumberOfChars);
        CharRegion.Right  = (CharRegion.Right ? CharRegion.Right-1 : 0);
        CharRegion.Bottom = 0;
    }
    else {
        CharRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
    }
    if (ConvAreaInfo) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            if (CharRegion.Left   != ConvAreaInfo->CaInfo.rcViewCaWindow.Left ||
                CharRegion.Top    != ConvAreaInfo->CaInfo.rcViewCaWindow.Top ||
                CharRegion.Right  != ConvAreaInfo->CaInfo.rcViewCaWindow.Right ||
                CharRegion.Bottom != ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom) {
                switch (ViewPosition) {
                    case VIEW_LEFT:
                        CursorPosition.X = 0;
                        break;
                    case VIEW_RIGHT:
                        CursorPosition.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer) - (CharRegion.Right + 1);
                        break;
                }
                CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
                ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);

                ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
            }
        }
        else {
            /*
             * This conversion area need positioning onto cursor position.
             */
            switch (ViewPosition) {
                case VIEW_LEFT:
                    CursorPosition.X = 0;
                    break;
                case VIEW_RIGHT:
                    CursorPosition.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer) - (CharRegion.Right + 1);
                    break;
            }
            CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
            ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);

            ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
        }

        if (Buffer) {
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            ConsoleImeWriteOutput(Console,ConvAreaInfo,Buffer,CharRegion,TRUE);
        }
        else {
            ConsoleImePaint(Console,ConvAreaInfo);
        }
    }
}


NTSTATUS
FillUndetermineChars(
    PCONSOLE_INFORMATION Console,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )
{
    COORD Coord;
    DWORD CharsToWrite;

    ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
    Coord.X = 0;
    Coord.Y = 0;
    CharsToWrite = ConvAreaInfo->ScreenBuffer->ScreenBufferSize.X;
    FillOutput(ConvAreaInfo->ScreenBuffer,
               (WCHAR)' ',
               Coord,
               CONSOLE_FALSE_UNICODE, // faster than real unicode
               &CharsToWrite
              );
    CharsToWrite = ConvAreaInfo->ScreenBuffer->ScreenBufferSize.X;
    FillOutput(ConvAreaInfo->ScreenBuffer,
               Console->CurrentScreenBuffer->Attributes,
               Coord,
               CONSOLE_ATTRIBUTE,
               &CharsToWrite
              );
    ConsoleImePaint(Console,ConvAreaInfo);
    return STATUS_SUCCESS;
}


NTSTATUS
ConsoleImeCompStr(
    IN PCONSOLE_INFORMATION Console,
    IN LPCONIME_UICOMPMESSAGE CompStr
    )
{
    UINT i;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if (CompStr->dwCompStrLen == 0 ||
        CompStr->dwResultStrLen != 0
       ) {

        // Cursor turn ON.
        if ((Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) &&
             Console->ConsoleIme.SavedCursorVisible                             )
        {
            Console->ConsoleIme.SavedCursorVisible = FALSE;
            SetCursorInformation(Console->CurrentScreenBuffer,
                                 Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorSize,
                                 TRUE);
        }

        /*
         * Determine string.
         */
        for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];
            if (ConvAreaInfo &&
                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                FillUndetermineChars(Console,ConvAreaInfo);
            }
        }

        if (CompStr->dwResultStrLen != 0)
        {
            if (!InsertConverTedString(Console, (LPWSTR)((PBYTE)CompStr + CompStr->dwResultStrOffset))) {
                return STATUS_INVALID_HANDLE;
            }
        }
        if (Console->ConsoleIme.CompStrData) {
            ConsoleHeapFree(Console->ConsoleIme.CompStrData);
            Console->ConsoleIme.CompStrData = NULL;
        }
    }
    else {
        LPWSTR lpStr;
        PBYTE  lpAtr;
        PWORD  lpAtrIdx;

        // Cursor turn OFF.
        if ((Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) &&
             Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorVisible  )
        {
            Console->ConsoleIme.SavedCursorVisible = TRUE;
            SetCursorInformation(Console->CurrentScreenBuffer,
                                 Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorSize,
                                 FALSE);
        }

        /*
         * Composition string.
         */
        for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];
            if (ConvAreaInfo &&
                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                FillUndetermineChars(Console,ConvAreaInfo);
            }
        }

        lpStr = (LPWSTR)((PBYTE)CompStr + CompStr->dwCompStrOffset);
        lpAtr = (PBYTE)CompStr + CompStr->dwCompAttrOffset;
        lpAtrIdx = (PWORD)CompStr->CompAttrColor;
        WriteUndetermineChars(Console, lpStr, lpAtr, lpAtrIdx, CompStr->dwCompStrLen / sizeof(WCHAR));
    }

    return STATUS_SUCCESS;
}




NTSTATUS
ConsoleImeResizeModeSystemView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    )
{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    SMALL_RECT CharRegion;
    COORD CursorPosition;

    /*
     * Mode string
     */

    ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;

    if (ConvAreaInfo &&
        (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
        ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
        ConsoleImePaint(Console,ConvAreaInfo);
        CharRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;

        if (Console->ConsoleIme.ConvAreaModePosition == VIEW_LEFT){
            CursorPosition.X = 0;
        }
        else{
            CursorPosition.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer) - (CharRegion.Right + 1);
        }

        CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
        ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);
        ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
        ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;

        WriteModeSystemChars(Console,
                             Console->ConsoleIme.ConvAreaMode,
                             NULL,
                             0,
                             Console->ConsoleIme.ConvAreaModePosition);
    }

    /*
     * System string
     */
    ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
    if (ConvAreaInfo &&
        (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {

        ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
        ConsoleImePaint(Console,ConvAreaInfo);

        CharRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        CursorPosition.X = 0;
        CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
        ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);
        ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
        ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;

        WriteModeSystemChars(Console,
                             Console->ConsoleIme.ConvAreaSystem,
                             NULL,
                             0,
                             VIEW_LEFT);
    }

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(WindowRect);
}


NTSTATUS
ConsoleImeResizeCompStrView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    )
{
    UINT i;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    LPCONIME_UICOMPMESSAGE CompStr;
    LPWSTR lpStr;
    PBYTE  lpAtr;
    PWORD  lpAtrIdx;

    /*
     * Compositon string
     */
    CompStr = Console->ConsoleIme.CompStrData;
    if (CompStr) {
        for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];
            if (ConvAreaInfo &&
                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                FillUndetermineChars(Console,ConvAreaInfo);
            }
        }

        lpStr = (LPWSTR)((PBYTE)CompStr + CompStr->dwCompStrOffset);
        lpAtr = (PBYTE)CompStr + CompStr->dwCompAttrOffset;
        lpAtrIdx = (PWORD)CompStr->CompAttrColor;

        WriteUndetermineChars(Console, lpStr, lpAtr, lpAtrIdx, CompStr->dwCompStrLen / sizeof(WCHAR));
    }
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(WindowRect);
}


NTSTATUS
ConsoleImeResizeModeSystemScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    )
{
    NTSTATUS Status;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    /*
     * Mode string
     */
    ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
    if (ConvAreaInfo) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
        }

        Status = ConsoleImeResizeScreenBuffer(ConvAreaInfo->ScreenBuffer,NewScreenSize,ConvAreaInfo);
        if (! NT_SUCCESS(Status))
            return Status;
    }

    /*
     * System string
     */
    ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
    if (ConvAreaInfo) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
        }

        Status = ConsoleImeResizeScreenBuffer(ConvAreaInfo->ScreenBuffer,NewScreenSize,ConvAreaInfo);
        if (! NT_SUCCESS(Status))
            return Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ConsoleImeResizeCompStrScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    )
{
    NTSTATUS Status;
    UINT i;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    /*
     * Compositon string
     */
    for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
        ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];

        if (ConvAreaInfo) {
            if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
                ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
                ConsoleImePaint(Console,ConvAreaInfo);
            }

            Status = ConsoleImeResizeScreenBuffer(ConvAreaInfo->ScreenBuffer,NewScreenSize,ConvAreaInfo);
            if (! NT_SUCCESS(Status))
                return Status;
        }

    }
    return STATUS_SUCCESS;
}


SHORT
CalcWideCharToColumn(
    IN PCONSOLE_INFORMATION Console,
    IN PCHAR_INFO Buffer,
    IN DWORD NumberOfChars
    )
{
    SHORT Column = 0;

    while (NumberOfChars--) {
        if (IsConsoleFullWidth(Console->hDC,Console->OutputCP,Buffer->Char.UnicodeChar))
            Column += 2;
        else
            Column++;
        Buffer++;
    }
    return Column;
}













LONG
ConsoleImePaint(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )

/*++

    This routine

--*/

{
    PSCREEN_INFORMATION ScreenInfo;
    SMALL_RECT WriteRegion;
    COORD CursorPosition;

    if (!ConvAreaInfo)
        return FALSE;

    ScreenInfo = Console->CurrentScreenBuffer;
    if (!ScreenInfo)
        return FALSE;

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));

    WriteRegion.Left   = ScreenInfo->Window.Left
                         + ConvAreaInfo->CaInfo.coordConView.X
                         + ConvAreaInfo->CaInfo.rcViewCaWindow.Left;
    WriteRegion.Right  = WriteRegion.Left
                         + (ConvAreaInfo->CaInfo.rcViewCaWindow.Right - ConvAreaInfo->CaInfo.rcViewCaWindow.Left);
    WriteRegion.Top    = ScreenInfo->Window.Top
                         + ConvAreaInfo->CaInfo.coordConView.Y
                         + ConvAreaInfo->CaInfo.rcViewCaWindow.Top;
    WriteRegion.Bottom = WriteRegion.Top
                         + (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom - ConvAreaInfo->CaInfo.rcViewCaWindow.Top);

    if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_STATUS_LINE))==(CA_STATUS_LINE)) {
        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)) {
            ConsoleHideCursor(ScreenInfo);
            ConsoleImeBottomLineUse(ScreenInfo,1);
            CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            CursorPosition.Y--;
            SetCursorPosition(ScreenInfo,CursorPosition,TRUE);
            if (ScreenInfo->Console->lpCookedReadData) {
                ((PCOOKED_READ_DATA)(ScreenInfo->Console->lpCookedReadData))->OriginalCursorPosition.Y--;
            }
            ConsoleShowCursor(ScreenInfo);
        }
        else if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == ScreenInfo->Window.Bottom) {
            WriteRegion.Top    = ScreenInfo->Window.Top
                                 + ConvAreaInfo->CaInfo.coordConView.Y
                                 + ConvAreaInfo->CaInfo.rcViewCaWindow.Top;
            WriteRegion.Bottom = WriteRegion.Top
                                 + (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom - ConvAreaInfo->CaInfo.rcViewCaWindow.Top);
        }
    }

    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
    if (!(ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN | CA_HIDE_FOR_SCROLL))) {
        WriteConvRegionToScreen(ScreenInfo,
                                ConvAreaInfo,
                                &WriteRegion
                               );
    }
    else {
        WriteToScreen(ScreenInfo,&WriteRegion);
    }
    ScreenInfo->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;

    return TRUE;
}

VOID
ConsoleImeViewInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN COORD coordConView
    )
{
    SMALL_RECT OldRegion;
    SMALL_RECT NewRegion;

    if (ConvAreaInfo->ConversionAreaMode & CA_HIDDEN) {
        ConvAreaInfo->CaInfo.coordConView = coordConView;
        NewRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        NewRegion.Left   += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Right  += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Top    += ConvAreaInfo->CaInfo.coordConView.Y;
        NewRegion.Bottom += ConvAreaInfo->CaInfo.coordConView.Y;
    }
    else {
        OldRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        OldRegion.Left   += ConvAreaInfo->CaInfo.coordConView.X;
        OldRegion.Right  += ConvAreaInfo->CaInfo.coordConView.X;
        OldRegion.Top    += ConvAreaInfo->CaInfo.coordConView.Y;
        OldRegion.Bottom += ConvAreaInfo->CaInfo.coordConView.Y;
        ConvAreaInfo->CaInfo.coordConView = coordConView;

        // Check code for must CONSOLE_TEXTMODE_BUFFER !!
        ASSERT(!(Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER));

        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
        WriteToScreen(Console->CurrentScreenBuffer,&OldRegion);

        NewRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        NewRegion.Left   += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Right  += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Top    += ConvAreaInfo->CaInfo.coordConView.Y;
        NewRegion.Bottom += ConvAreaInfo->CaInfo.coordConView.Y;
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        WriteToScreen(Console->CurrentScreenBuffer,&NewRegion);
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
    }
}

VOID
ConsoleImeWindowInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN SMALL_RECT rcViewCaWindow
    )
{
    if (rcViewCaWindow.Left   != ConvAreaInfo->CaInfo.rcViewCaWindow.Left ||
        rcViewCaWindow.Top    != ConvAreaInfo->CaInfo.rcViewCaWindow.Top ||
        rcViewCaWindow.Right  != ConvAreaInfo->CaInfo.rcViewCaWindow.Right ||
        rcViewCaWindow.Bottom != ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);

            ConvAreaInfo->CaInfo.rcViewCaWindow = rcViewCaWindow;
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            ConvAreaInfo->ScreenBuffer->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT | BISECT_TOP | BISECT_BOTTOM);
            ConsoleImePaint(Console,ConvAreaInfo);
        }
        else
            ConvAreaInfo->CaInfo.rcViewCaWindow = rcViewCaWindow;
    }
}

NTSTATUS
ConsoleImeResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )
{
    NTSTATUS Status;

    Status = ResizeScreenBuffer(ScreenInfo,
                                NewScreenSize,
                                FALSE);
    if (NT_SUCCESS(Status)) {
        ConvAreaInfo->CaInfo.coordCaBuffer = NewScreenSize;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Left   > NewScreenSize.X-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Left   = NewScreenSize.X-1;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Right  > NewScreenSize.X-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Right  = NewScreenSize.X-1;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Top    > NewScreenSize.Y-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Top    = NewScreenSize.Y-1;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom > NewScreenSize.Y-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom = NewScreenSize.Y-1;

    }

    return Status;
}

NTSTATUS
ConsoleImeWriteOutput(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PCHAR_INFO Buffer,
    IN SMALL_RECT CharRegion,
    IN BOOL fUnicode
    )
{
    NTSTATUS Status;
    PSCREEN_INFORMATION ScreenInfo;
    COORD BufferSize;
    SMALL_RECT ConvRegion;
    COORD CursorPosition;

    BufferSize.X = (SHORT)(CharRegion.Right - CharRegion.Left + 1);
    BufferSize.Y = (SHORT)(CharRegion.Bottom - CharRegion.Top + 1);

    ConvRegion = CharRegion;

    ScreenInfo = ConvAreaInfo->ScreenBuffer;

    if (!fUnicode) {
        TranslateOutputToUnicode(Console,
                                 Buffer,
                                 BufferSize
                                );
        Status = WriteScreenBuffer(ScreenInfo,
                                   Buffer,
                                   &ConvRegion
                                  );
    } else {
        CHAR_INFO StackBuffer[STACK_BUFFER_SIZE * 2];
        PCHAR_INFO TransBuffer;
        BOOL StackBufferF = FALSE;

        if (BufferSize.Y * BufferSize.X <= STACK_BUFFER_SIZE) {
            TransBuffer = StackBuffer;
            StackBufferF = TRUE;
        } else {
            TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, (BufferSize.Y * BufferSize.X) * 2 * sizeof(CHAR_INFO));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
        }
        if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
            TranslateOutputToAnsiUnicode(Console,
                                         Buffer,
                                         BufferSize,
                                         &TransBuffer[0]
                                        );
        }
        else {
            TranslateOutputToPaddingUnicode(Console,
                                            Buffer,
                                            BufferSize,
                                            &TransBuffer[0]
                                           );
        }

        Status = WriteScreenBuffer(ScreenInfo,
                                   &TransBuffer[0],
                                   &ConvRegion
                                  );
        if (!StackBufferF)
            ConsoleHeapFree(TransBuffer);
    }

    if (NT_SUCCESS(Status)) {

        ScreenInfo = Console->CurrentScreenBuffer;


        // Check code for must CONSOLE_TEXTMODE_BUFFER !!
        if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
            ASSERT(FALSE);
        }
        else if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_STATUS_LINE))==(CA_STATUS_LINE)) {
            if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)
               )
            {
                ConsoleHideCursor(ScreenInfo);
                ConsoleImeBottomLineUse(ScreenInfo,1);
                CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                CursorPosition.Y--;
                SetCursorPosition(ScreenInfo,CursorPosition,TRUE);
                if (ScreenInfo->Console->lpCookedReadData) {
                    ((PCOOKED_READ_DATA)(ScreenInfo->Console->lpCookedReadData))->OriginalCursorPosition.Y--;
                }
                ConsoleShowCursor(ScreenInfo);
            } else if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == ScreenInfo->Window.Bottom) {
                COORD WindowOrigin;
                WindowOrigin.X = ScreenInfo->Window.Left;
                WindowOrigin.Y = ScreenInfo->Window.Top+1;
                SetWindowOrigin(ScreenInfo, TRUE, WindowOrigin);
                if ( ! (ScreenInfo->Console->InputBuffer.ImeMode.Disable) &&
                     ! (ScreenInfo->Console->InputBuffer.ImeMode.Unavailable) &&
                     (ScreenInfo->Console->InputBuffer.ImeMode.Open) ) {
                    SMALL_RECT Rectangle;
                    Rectangle.Left = ScreenInfo->Window.Left;
                    Rectangle.Right = ScreenInfo->Window.Right;
                    Rectangle.Top = ScreenInfo->Window.Bottom;
                    Rectangle.Bottom = ScreenInfo->Window.Bottom;
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    WriteToScreen(ScreenInfo,&Rectangle);
                    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
                    WriteConvRegionToScreen(ScreenInfo,
                                            ScreenInfo->Console->ConsoleIme.ConvAreaRoot,
                                            &Rectangle);
                }
            }
        }

        //
        // cause screen to be updated
        //
        ConvRegion.Left   += (ScreenInfo->Window.Left + ConvAreaInfo->CaInfo.coordConView.X);
        ConvRegion.Right  += (ScreenInfo->Window.Left + ConvAreaInfo->CaInfo.coordConView.X);
        ConvRegion.Top    += (ScreenInfo->Window.Top + ConvAreaInfo->CaInfo.coordConView.Y);
        ConvRegion.Bottom += (ScreenInfo->Window.Top + ConvAreaInfo->CaInfo.coordConView.Y);


        // Check code for must CONSOLE_TEXTMODE_BUFFER !!
        if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
            ASSERT(FALSE);
        }
        else
            ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        WriteConvRegionToScreen(ScreenInfo,
                                ConvAreaInfo,
                                &ConvRegion
                               );
        ConvAreaInfo->ScreenBuffer->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT | BISECT_TOP | BISECT_BOTTOM);
    }
    return Status;
}








NTSTATUS
ImeControl(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWndConsoleIME,
    IN PCOPYDATASTRUCT lParam
    )

/*++

Routine Description:

    This routine handle WM_COPYDATA message.

Arguments:

    Console - Pointer to console information structure.

    wParam -

    lParam -

Return Value:

--*/

{
    PSCREEN_INFORMATION ScreenInfo;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    PCHAR_INFO SystemString;
    DWORD i, j;

    if (lParam == NULL) {
        // fail safe.
        return STATUS_SUCCESS;
    }

    ScreenInfo = Console->CurrentScreenBuffer;
    switch ((LONG)lParam->dwData) {
        case CI_CONIMECOMPOSITION:
            if (lParam->cbData >= sizeof(CONIME_UICOMPMESSAGE)) {
                LPCONIME_UICOMPMESSAGE CompStr;

                DBGPRINT(("CONSRV: Get IR_CONIMECOMPOSITION Message\n"));
                CompStr = (LPCONIME_UICOMPMESSAGE)lParam->lpData;
                if (CompStr && CompStr->dwSize == lParam->cbData) {
                    if (Console->ConsoleIme.CompStrData)
                        ConsoleHeapFree(Console->ConsoleIme.CompStrData);
                    Console->ConsoleIme.CompStrData = ConsoleHeapAlloc(
                                                                IME_TAG,
                                                                CompStr->dwSize);
                    if (Console->ConsoleIme.CompStrData == NULL)
                        break;
                    memmove(Console->ConsoleIme.CompStrData,CompStr,CompStr->dwSize);
                    ConsoleImeCompStr(Console, Console->ConsoleIme.CompStrData);
                }
            }
            break;
        case CI_CONIMEMODEINFO:
            if (lParam->cbData == sizeof(CONIME_UIMODEINFO)) {
                LPCONIME_UIMODEINFO lpModeInfo;

                DBGPRINT(("CONSRV: Get IR_CONIMEMODEINFO Message\n"));

                lpModeInfo = (LPCONIME_UIMODEINFO)lParam->lpData;
                if (lpModeInfo != NULL) {
                    if (! Console->InputBuffer.ImeMode.Disable) {
                        if (lpModeInfo->ModeStringLen != 0){
                            for (j = 0; j < lpModeInfo->ModeStringLen; j++ )
                                lpModeInfo->ModeString[j].Attributes = Console->CurrentScreenBuffer->Attributes;
                            Console->ConsoleIme.ConvAreaModePosition = lpModeInfo->Position;
                            WriteModeSystemChars(Console,
                                                 Console->ConsoleIme.ConvAreaMode,
                                                 (PCHAR_INFO)&lpModeInfo->ModeString,
                                                 lpModeInfo->ModeStringLen,
                                                 Console->ConsoleIme.ConvAreaModePosition);
                        } else{
                            ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
                            if (ConvAreaInfo &&
                                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                                FillUndetermineChars(Console,ConvAreaInfo);
                            }
                            ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
                            if (ConvAreaInfo &&
                                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                                FillUndetermineChars(Console,ConvAreaInfo);
                            }
                        }
                    }
                }
            }
            break;
        case CI_CONIMESYSINFO: {
            PWCHAR SourceString;

            DBGPRINT(("CONSRV: Get IR_CONIMESYSINFO Message\n"));

            if ((lParam->cbData != 0) &&
                (lParam->lpData != NULL) &&
                (! Console->InputBuffer.ImeMode.Disable)) {
                i = (lParam->cbData / sizeof(WCHAR))-1;
                SourceString = ((LPCONIME_UIMESSAGE)(lParam->lpData))->String;
                SystemString = ConsoleHeapAlloc(IME_TAG,
                                                sizeof(CHAR_INFO) * i);
                if (SystemString == NULL) {
                    break;
                }
                for (j = 0; j < i; j++ ) {
                    SystemString[j].Char.UnicodeChar = *SourceString;
                    SystemString[j].Attributes = Console->CurrentScreenBuffer->Attributes;
                    SourceString++;
                }
                WriteModeSystemChars(Console,
                                     Console->ConsoleIme.ConvAreaSystem,
                                     (PCHAR_INFO)SystemString,
                                     i,
                                     VIEW_LEFT);
                ConsoleHeapFree(SystemString);
            } else {
                ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
                if (ConvAreaInfo &&
                    (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                    FillUndetermineChars(Console,ConvAreaInfo);
                }
            }
            break;
        }
        case CI_CONIMECANDINFO:{
            PWCHAR SourceString;
            PUCHAR SourceAttr;
            DWORD LengthToWrite;
            LPCONIME_CANDMESSAGE CandInfo = (LPCONIME_CANDMESSAGE)(lParam->lpData);

            DBGPRINT(("CONSRV: Get IR_CONIMESYSINFO Message\n"));

            if ((lParam->cbData != 0) &&
                (CandInfo != NULL) ){
                SourceString = CandInfo->String;
                SourceAttr = (PUCHAR)((PBYTE)CandInfo + CandInfo->AttrOff);
                LengthToWrite = lstrlenW(SourceString);
                SystemString = ConsoleHeapAlloc(IME_TAG,
                                                sizeof(CHAR_INFO) * LengthToWrite);
                if (SystemString == NULL) {
                    break;
                }
                for (j = 0; j < LengthToWrite; j++ ) {
                    SystemString[j].Char.UnicodeChar = *SourceString;
                    if (*SourceAttr == 1 &&
                        Console->ConsoleIme.CompStrData != NULL) {
                        SystemString[j].Attributes = Console->ConsoleIme.CompStrData->CompAttrColor[1];
                    } else {
                        SystemString[j].Attributes = Console->CurrentScreenBuffer->Attributes;
                    }
                    SourceString++;
                    SourceAttr++;
                }
                WriteModeSystemChars(Console,
                                     Console->ConsoleIme.ConvAreaSystem,
                                     (PCHAR_INFO)SystemString,
                                     LengthToWrite,
                                     VIEW_LEFT);
                ConsoleHeapFree(SystemString);
            }
            else {
                ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
                if (ConvAreaInfo) {
                    SMALL_RECT rcViewCaWindow = {0, 0, 0, 0};
                    FillUndetermineChars(Console,ConvAreaInfo);
                    ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
                    ConsoleImeWindowInfo(Console,ConvAreaInfo,rcViewCaWindow);
                }
            }
            break;
        }
        case CI_CONIMEPROPERTYINFO:{
            WPARAM* wParam = (WPARAM*)(lParam->lpData);

            if ((lParam->cbData != 0) &&
                (wParam != NULL) ){
                switch (*wParam) {
                    case IMS_OPENPROPERTYWINDOW:
                        Console->InputBuffer.hWndConsoleIME = hWndConsoleIME;
                        break;
                    case IMS_CLOSEPROPERTYWINDOW:
                        Console->InputBuffer.hWndConsoleIME = NULL;
                        SetFocus(Console->hWnd);
                        break;
                }
            }
            break;
        }
    }

    return STATUS_SUCCESS;
}

BOOL
InsertConverTedString(
    IN PCONSOLE_INFORMATION Console,
    LPWSTR lpStr
    )
{
    ULONG EventsWritten;
    PINPUT_RECORD InputEvent,TmpInputEvent;
    DWORD dwControlKeyState;
    DWORD dwLen;
    DWORD dwConversion;
    BOOL fResult = FALSE;

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    if (Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER) {
        ASSERT(FALSE);
    } else if(Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorOn){
        CursorTimerRoutine(Console->CurrentScreenBuffer);
    }

    dwLen = wcslen(lpStr)+1;
    InputEvent = ConsoleHeapAlloc(IME_TAG, sizeof(INPUT_RECORD)*dwLen);
    if (InputEvent == NULL) {
        return FALSE;
    }

    TmpInputEvent = InputEvent;
    dwControlKeyState = GetControlKeyState(0);

    if (!NT_SUCCESS(GetImeKeyState(Console, &dwConversion))) {
        goto skip_and_return;
    }

    dwControlKeyState |= ImmConversionToConsole(dwConversion);

    while (*lpStr) {
        TmpInputEvent->EventType = KEY_EVENT;
        TmpInputEvent->Event.KeyEvent.bKeyDown = TRUE;
        TmpInputEvent->Event.KeyEvent.wVirtualKeyCode = 0;
        TmpInputEvent->Event.KeyEvent.wVirtualScanCode = 0;
        TmpInputEvent->Event.KeyEvent.dwControlKeyState = dwControlKeyState;
        TmpInputEvent->Event.KeyEvent.uChar.UnicodeChar = *lpStr++;
        TmpInputEvent->Event.KeyEvent.wRepeatCount = 1;
        TmpInputEvent++;
    }

    EventsWritten = WriteInputBuffer( Console,
                                      &Console->InputBuffer,
                                      InputEvent,
                                      dwLen-1
                                     );

    fResult = TRUE;

skip_and_return:
    ConsoleHeapFree(InputEvent);
    return fResult;
}


VOID
SetUndetermineAttribute(
    IN PCONSOLE_INFORMATION Console
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    ScreenInfo = Console->CurrentScreenBuffer;

    ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
    if (ConvAreaInfo != NULL) {
        do {
            ConvAreaInfo->ScreenBuffer->Attributes = ScreenInfo->Attributes;
            ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
        } while (ConvAreaInfo != NULL);
    }

    if (Console->ConsoleIme.ConvAreaMode != NULL) {
        Console->ConsoleIme.ConvAreaMode->ScreenBuffer->Attributes = ScreenInfo->Attributes;
    }

    if (Console->ConsoleIme.ConvAreaSystem != NULL) {
        Console->ConsoleIme.ConvAreaSystem->ScreenBuffer->Attributes = ScreenInfo->Attributes;
    }
}


VOID
StreamWriteToScreenBufferIME(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    )
{
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    COORD TargetPoint;

    DBGOUTPUT(("StreamWriteToScreenBuffer\n"));

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
    DBGOUTPUT(("RowIndex = %lx, Row = %lx, TargetPoint = (%d,%d)\n",
            RowIndex, Row, TargetPoint.X, TargetPoint.Y));

    //
    // copy chars
    //

//#if defined(FE_SB)
    BisectWrite(StringLength,TargetPoint,ScreenInfo);
    if (TargetPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
        TargetPoint.X+StringLength >= ScreenInfo->ScreenBufferSize.X &&
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) & ATTR_LEADING_BYTE
       ) {
        *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = UNICODE_SPACE;
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = 0;
        if (StringLength > ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) {
            *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = UNICODE_SPACE;
            *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = 0;
        }
    }
//#endif
    RtlCopyMemory(&Row->CharRow.Chars[TargetPoint.X],String,StringLength*sizeof(WCHAR));
//#if defined(FE_SB)
    RtlCopyMemory(&Row->CharRow.KAttrs[TargetPoint.X],StringA,StringLength*sizeof(CHAR));
//#endif

    // recalculate first and last non-space char

    Row->CharRow.OldLeft = Row->CharRow.Left;
    if (TargetPoint.X < Row->CharRow.Left) {
//#if defined(FE_SB)
        /*
         * CharRow.Left is leftmost bound of chars in Chars array (array will be full width)
         * i.e. type is COORD
         */
        PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X-1];
//#else
//        PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];
//#endif

        for (Char=&Row->CharRow.Chars[TargetPoint.X];Char < LastChar && *Char==(WCHAR)' ';Char++) {
            /* do nothing*/;
        }
        Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
    }

    Row->CharRow.OldRight = Row->CharRow.Right;
    if ((TargetPoint.X+StringLength) >= Row->CharRow.Right) {
        PWCHAR FirstChar = Row->CharRow.Chars;

        for (Char=&Row->CharRow.Chars[TargetPoint.X+StringLength-1];*Char==(WCHAR)' ' && Char >= FirstChar;Char--) {
            /* do nothing */;
        }
        Row->CharRow.Right = (SHORT)(Char+1-FirstChar);
    }

    //
    // see if attr string is different.  if so, allocate a new
    // attr buffer and merge the two strings.
    //

    if (Row->AttrRow.Length != 1 ||
        Row->AttrRow.Attrs->Attr != ScreenInfo->Attributes) {
        PATTR_PAIR NewAttrs;
        WORD NewAttrsLength;
        ATTR_PAIR Attrs;

//#if defined(FE_SB) && defined(FE_IME)
        if ((ScreenInfo->Attributes & (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL)) ==
            (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL)){
            SHORT i;
            for (i = 0; i < StringLength; i++ ) {
                Attrs.Length = 1;
                if (*(StringA + i) & ATTR_LEADING_BYTE) {
                    Attrs.Attr = ScreenInfo->Attributes & ~(COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL);
                } else {
                    Attrs.Attr = ScreenInfo->Attributes & ~COMMON_LVB_GRID_SINGLEFLAG;
                }

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 &Attrs,
                                 1,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)(TargetPoint.X+i),
                                 (SHORT)(TargetPoint.X+i),
                                 Row,
                                 ScreenInfo
                                ))) {
                    return;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
            }
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        else if ((ScreenInfo->Attributes & (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL)) ==
            (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL)){
            SHORT i;
            for (i = 0; i < StringLength; i++ ) {
                Attrs.Length = 1;
                if (*(StringA + i) & ATTR_TRAILING_BYTE) {
                    Attrs.Attr = ScreenInfo->Attributes & ~(COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL);
                } else {
                    Attrs.Attr = ScreenInfo->Attributes & ~COMMON_LVB_GRID_SINGLEFLAG;
                }

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 &Attrs,
                                 1,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)(TargetPoint.X+i),
                                 (SHORT)(TargetPoint.X+i),
                                 Row,
                                 ScreenInfo
                                ))) {
                    return;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
            }
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        else{
//#endif
        Attrs.Length = StringLength;
        Attrs.Attr = ScreenInfo->Attributes;
        if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                         Row->AttrRow.Length,
                         &Attrs,
                         1,
                         &NewAttrs,
                         &NewAttrsLength,
                         TargetPoint.X,
                         (SHORT)(TargetPoint.X+StringLength-1),
                         Row,
                         ScreenInfo
                        ))) {
            return;
        }
        if (Row->AttrRow.Length > 1) {
            ConsoleHeapFree(Row->AttrRow.Attrs);
        }
        else {
            ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
        }
        Row->AttrRow.Attrs = NewAttrs;
        Row->AttrRow.Length = NewAttrsLength;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
//#if defined(FE_SB) && defined(FE_IME)
    }
//#endif
    }
    ResetTextFlags(ScreenInfo,
                   TargetPoint.X,
                   TargetPoint.Y,
                   TargetPoint.X + StringLength - 1,
                   TargetPoint.Y);
}

#endif // FE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\constubs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    constubs.c

Abstract:

Author:

    KazuM Mar.05.1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)
ULONG
SrvGetConsoleCharType(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine check character type.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_CHAR_TYPE_MSG a = (PCONSOLE_CHAR_TYPE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PSCREEN_INFORMATION ScreenInfo;
    PHANDLE_DATA HandleData;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData);
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;

#if DBG && defined(DBG_KATTR)
        BeginKAttrCheck(ScreenInfo);
#endif

        if (a->coordCheck.X >= ScreenInfo->ScreenBufferSize.X ||
            a->coordCheck.Y >= ScreenInfo->ScreenBufferSize.Y) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+a->coordCheck.Y) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[a->coordCheck.X];
            if (!CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
                a->dwType = CHAR_TYPE_SBCS;
            } else if (Row->CharRow.KAttrs[a->coordCheck.X] & ATTR_TRAILING_BYTE) {
                a->dwType = CHAR_TYPE_TRAILING;
            } else if (Row->CharRow.KAttrs[a->coordCheck.X] & ATTR_LEADING_BYTE) {
                a->dwType = CHAR_TYPE_LEADING;
            } else {
                a->dwType = CHAR_TYPE_SBCS;
            }
        }
    }

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvSetConsoleLocalEUDC(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine sets Local EUDC Font.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_LOCAL_EUDC_MSG a = (PCONSOLE_LOCAL_EUDC_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    CHAR Source[4];
    WCHAR Target[2];

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData);
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->FontFace, ((a->FontSize.X + 7) / 8), a->FontSize.Y)) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    Source[0] = (char)(a->CodePoint >> 8);
    Source[1] = (char)(a->CodePoint & 0x00ff);
    Source[2] = 0;
    ConvertOutputToUnicode(Console->OutputCP,Source,2,Target,1);

    if (IsEudcRange(Console,Target[0])) {
        Status = RegisterLocalEUDC(Console,Target[0],a->FontSize,a->FontFace);
        if (NT_SUCCESS(Status)) {
            ((PEUDC_INFORMATION)(Console->EudcInformation))->LocalVDMEudcMode = TRUE;
        }
    } else {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    UnlockConsole(Console);
    return STATUS_SUCCESS;
}

ULONG
SrvSetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine sets Cursor Mode.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_CURSOR_MODE_MSG a = (PCONSOLE_CURSOR_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData);
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorBlink = (BOOLEAN)a->Blink;
    HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorDBEnable = (BOOLEAN)a->DBEnable;

    UnlockConsole(Console);
    return Status;
}


ULONG
SrvGetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine gets Cursor Mode.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_CURSOR_MODE_MSG a = (PCONSOLE_CURSOR_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData);
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    a->Blink = HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorBlink;
    a->DBEnable = HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorDBEnable;

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvRegisterConsoleOS2(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

  This function calls NEC PC-98 machine's only.

--*/

{
    PCONSOLE_REGISTEROS2_MSG a = (PCONSOLE_REGISTEROS2_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#if defined(i386)
    if (!a->fOs2Register) {
        Console->Flags &= ~ CONSOLE_OS2_REGISTERED;
        ResizeWindow(Console->CurrentScreenBuffer, &Console->Os2SavedWindowRect, FALSE);
    } else {
        Console->Flags |= CONSOLE_OS2_REGISTERED;
        Console->Os2SavedWindowRect = Console->CurrentScreenBuffer->Window;
    }
#endif

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvSetConsoleOS2OemFormat(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

  This function calls NEC PC-98 machine's only.

--*/

{
    PCONSOLE_SETOS2OEMFORMAT_MSG a = (PCONSOLE_SETOS2OEMFORMAT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

#if defined(i386)
    if (!a->fOs2OemFormat) {
        Console->Flags &= ~CONSOLE_OS2_OEM_FORMAT;
    } else {
        Console->Flags |= CONSOLE_OS2_OEM_FORMAT;
    }
#endif

    UnlockConsole(Console);
    return Status;
}

#if defined(FE_IME)
ULONG
SrvGetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine gets NLS mode for input.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_NLS_MODE_MSG a = (PCONSOLE_NLS_MODE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    HANDLE hEvent = NULL;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData);
    if (!NT_SUCCESS(Status)) {
        goto SrvGetConsoleNlsModeFailure;
    }

    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                       a->hEvent,
                       NtCurrentProcess(),
                       &hEvent,
                       0,
                       FALSE,
                       DUPLICATE_SAME_ACCESS
                       );
    if (!NT_SUCCESS(Status)) {
        goto SrvGetConsoleNlsModeFailure;
    }

    /*
     * Caller should set FALSE on a->Ready.
     */
    if (a->Ready == FALSE) {
        a->Ready = HandleData->Buffer.InputBuffer->ImeMode.ReadyConversion;

        if (a->Ready == FALSE) {
            /*
             * If not ready ImeMode.Conversion, then get conversion status
             * from ConIME.
             */
            Status = QueueConsoleMessage(Console,
                                         CM_GET_NLSMODE,
                                         (WPARAM)hEvent,
                                         0L);
            if (!NT_SUCCESS(Status)) {
                goto SrvGetConsoleNlsModeFailure;
            }
        } else {
            if (!HandleData->Buffer.InputBuffer->ImeMode.Disable) {
                a->NlsMode = ImmConversionToConsole(HandleData->Buffer.InputBuffer->ImeMode.Conversion);
            } else {
                a->NlsMode = 0;
            }

            NtSetEvent(hEvent, NULL);
            NtClose(hEvent);
        }
    } else {
        if (!HandleData->Buffer.InputBuffer->ImeMode.Disable) {
            a->NlsMode = ImmConversionToConsole(HandleData->Buffer.InputBuffer->ImeMode.Conversion);
        } else {
            a->NlsMode = 0;
        }

        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }

    UnlockConsole(Console);
    return Status;

SrvGetConsoleNlsModeFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvSetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine sets NLS mode for input.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_NLS_MODE_MSG a = (PCONSOLE_NLS_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    HANDLE hEvent = NULL;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle, &Console);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData);
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleNlsModeFailure;
    }

    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                       a->hEvent,
                       NtCurrentProcess(),
                       &hEvent,
                       0,
                       FALSE,
                       DUPLICATE_SAME_ACCESS
                       );
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleNlsModeFailure;
    }

    Status = QueueConsoleMessage(Console,
                                 CM_SET_NLSMODE,
                                 (WPARAM)hEvent,
                                 a->NlsMode);
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleNlsModeFailure;
    }

    UnlockConsole(Console);
    return Status;

SrvSetConsoleNlsModeFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvRegisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine register console IME on the current desktop.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_REGISTER_CONSOLEIME_MSG a = (PCONSOLE_REGISTER_CONSOLEIME_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    HDESK hdesk;
    HWINSTA hwinsta;
    UNICODE_STRING strDesktopName;

    UNREFERENCED_PARAMETER(ReplyStatus);

    if (!CsrValidateMessageBuffer(m, &a->Desktop, a->DesktopLength, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Connect to the windowstation and desktop.
    //

    if (!CsrImpersonateClient(NULL)) {
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    Process = CSR_SERVER_QUERYCLIENTTHREAD()->Process;
    if (a->DesktopLength) {
        RtlInitUnicodeString(&strDesktopName, a->Desktop);
    } else {
        RtlInitUnicodeString(&strDesktopName, L"Default");
    }
    hdesk = NtUserResolveDesktop(Process->ProcessHandle,
                                 &strDesktopName,
                                 FALSE,
                                 &hwinsta);

    CsrRevertToSelf();

    if (hdesk == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = ConSrvRegisterConsoleIME(Process,
                                      hdesk,
                                      hwinsta,
                                      a->hWndConsoleIME,
                                      a->dwConsoleIMEThreadId,
                                      REGCONIME_REGISTER,
                                      &a->dwConsoleThreadId);
    return Status;
}

ULONG
SrvUnregisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine unregister console IME on the current desktop.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_UNREGISTER_CONSOLEIME_MSG a = (PCONSOLE_UNREGISTER_CONSOLEIME_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Process = CSR_SERVER_QUERYCLIENTTHREAD()->Process;
    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    /*
     * If ProcessData->hDesk is NULL, then the IME process was already
     * forcibly unregistered in ConsoleClientShutdown, so there's no work
     * to do.
     */
    if (ProcessData->hDesk) {
        Status = ConSrvRegisterConsoleIME(Process,
                                          ProcessData->hDesk,
                                          ProcessData->hWinSta,
                                          NULL,
                                          a->dwConsoleIMEThreadId,
                                          REGCONIME_UNREGISTER,
                                          NULL);
    } else {
        Status = STATUS_SUCCESS;
    }

    return Status;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\conv.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    conv.h

Abstract:

    This module contains the internal structures and definitions used
    by the conversion area.

Author:

    KazuM Mar.8,1993

Revision History:

--*/

#ifndef _CONV_H_
#define _CONV_H_

#if defined(FE_IME)
//
//  Externs
//


//
// Attributes flags:
//
#define COMMON_LVB_GRID_SINGLEFLAG 0x2000 // DBCS: Grid attribute: use for ime cursor.

/*
 * Exported function
 */

/*
 * Internal function
 */

DWORD
NtUserCheckImeHotKey(
    UINT uVKey,
    LPARAM lParam
    );

BOOL
NtUserGetImeHotKey(
    IN DWORD dwID,
    OUT PUINT puModifiers,
    OUT PUINT puVKey,
    OUT HKL  *phkl);


/*
 * Prototype definition
 */

VOID
LinkConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );

NTSTATUS
FreeConvAreaScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
AllocateConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    );

NTSTATUS
SetUpConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD coordCaBuffer,
    IN SMALL_RECT rcViewCaWindow,
    IN COORD coordConView,
    IN DWORD dwOption,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    );


VOID
WriteConvRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PSMALL_RECT ClippedRegion
    );

BOOL
ConsoleImeBottomLineUse(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollOffset
    );

VOID
ConsoleImeBottomLineInUse(
    IN PSCREEN_INFORMATION ScreenInfo
    );


NTSTATUS
CreateConvAreaUndetermine(
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
CreateConvAreaModeSystem(
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
WriteUndetermineChars(
    PCONSOLE_INFORMATION Console,
    LPWSTR lpString,
    PBYTE  lpAtr,
    PWORD  lpAtrIdx,
    DWORD  NumChars
    );

NTSTATUS
FillUndetermineChars(
    PCONSOLE_INFORMATION Console,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );

NTSTATUS
ConsoleImeCompStr(
    IN PCONSOLE_INFORMATION Console,
    IN LPCONIME_UICOMPMESSAGE CompStr
    );

NTSTATUS
ConsoleImeResizeModeSystemView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    );

NTSTATUS
ConsoleImeResizeCompStrView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    );

NTSTATUS
ConsoleImeResizeModeSystemScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    );

NTSTATUS
ConsoleImeResizeCompStrScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    );

SHORT
CalcWideCharToColumn(
    IN PCONSOLE_INFORMATION Console,
    IN PCHAR_INFO Buffer,
    IN DWORD NumberOfChars
    );




LONG
ConsoleImePaint(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );




VOID
ConsoleImeViewInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN COORD coordConView
    );

VOID
ConsoleImeWindowInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN SMALL_RECT rcViewCaWindow
    );

NTSTATUS
ConsoleImeResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );

NTSTATUS
ConsoleImeWriteOutput(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PCHAR_INFO Buffer,
    IN SMALL_RECT CharRegion,
    IN BOOL fUnicode
    );


NTSTATUS
ImeControl(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWndConsoleIME,
    IN PCOPYDATASTRUCT lParam
    ) ;

BOOL
InsertConverTedString(
    IN PCONSOLE_INFORMATION Console,
    LPWSTR lpStr
    ) ;


VOID
SetUndetermineAttribute(
    IN PCONSOLE_INFORMATION Console
    ) ;

VOID
StreamWriteToScreenBufferIME(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    ) ;


//
// windows\imm\server\hotkey.c
//
DWORD
CheckImeHotKey(
    UINT uVKey,         // virtual key
    LPARAM lParam       // lparam of WM_KEYxxx message
    ) ;

//
// output.c (for use convarea.c\StreamWriteToScreenBufferIME() )
//

NTSTATUS
MergeAttrStrings(
    IN PATTR_PAIR Source,
    IN WORD SourceLength,
    IN PATTR_PAIR Merge,
    IN WORD MergeLength,
    OUT PATTR_PAIR *Target,
    OUT LPWORD TargetLength,
    IN SHORT StartIndex,
    IN SHORT EndIndex,
    IN PROW Row,
    IN PSCREEN_INFORMATION ScreenInfo
    ) ;


VOID
ResetTextFlags(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT StartX,
    IN SHORT StartY,
    IN SHORT EndX,
    IN SHORT EndY
    ) ;

#endif // FE_IME

#endif  // _CONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\dbcs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

Author:

    KazuM Mar.05.1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(FE_TEXT, CheckBisectStringA)
#pragma alloc_text(FE_TEXT, BisectWrite)
#pragma alloc_text(FE_TEXT, BisectClipbrd)
#pragma alloc_text(FE_TEXT, BisectWriteAttr)
#pragma alloc_text(FE_TEXT, IsDBCSLeadByteConsole)
#pragma alloc_text(FE_TEXT, TextOutEverything)
#pragma alloc_text(FE_TEXT, TextOutCommonLVB)
#ifdef i386
#pragma alloc_text(FE_TEXT, RealUnicodeToNEC_OS2_Unicode)
#pragma alloc_text(FE_TEXT, InitializeNEC_OS2_CP)
#endif
#pragma alloc_text(FE_TEXT, ProcessCreateConsoleIME)
#pragma alloc_text(FE_TEXT, InitConsoleIMEStuff)
#pragma alloc_text(FE_TEXT, WaitConsoleIMEStuff)
#pragma alloc_text(FE_TEXT, ConSrvRegisterConsoleIME)
#pragma alloc_text(FE_TEXT, RemoveConsoleIME)
#pragma alloc_text(FE_TEXT, ConsoleImeMessagePump)
#pragma alloc_text(FE_TEXT, RegisterKeisenOfTTFont)
#pragma alloc_text(FE_TEXT, ImmConversionToConsole)
#pragma alloc_text(FE_TEXT, ImmConversionFromConsole)
#pragma alloc_text(FE_TEXT, TranslateUnicodeToOem)


#if defined(FE_SB)

SINGLE_LIST_ENTRY gTTFontList;    // This list contain TTFONTLIST data.

#if defined(i386)
ULONG  gdwMachineId;
#endif

LPTHREAD_START_ROUTINE ConsoleIMERoutine;  // client side console IME routine
CRITICAL_SECTION ConIMEInitWindowsLock;

#if defined(i386)
/*
 * NEC PC-98 OS/2 OEM character set
 * When FormatID is 0 or 80, Convert SBCS (00h-1Fh) font.
 */
PCPTABLEINFO pGlyph_NEC_OS2_CP;
PUSHORT pGlyph_NEC_OS2_Table;
#endif // i386



#if defined(FE_IME)


#if defined(i386)
NTSTATUS
ImeWmFullScreen(
    IN BOOL Foreground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(Foreground) {
        ULONG ModeIndex;
        PCONVERSIONAREA_INFORMATION ConvAreaInfo;

        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_SETFOCUS,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)Console->hklActive
                             ))) {
            return STATUS_INVALID_HANDLE;
        }

        if (ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot) {
            if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
                ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
            } else if (!(Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER)) {
                ModeIndex = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;
            } else {
                ModeIndex = 0;
            }

            do {
#ifdef FE_SB
                // Check code for must CONSOLE_TEXTMODE_BUFFER !!
                if (!(ConvAreaInfo->ScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER)) {
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = ModeIndex;
                } else {
                    UserAssert(FALSE);
                }
#else
                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = ModeIndex;
#endif
            } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);
        }
    } else {
        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_KILLFOCUS,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)Console->hklActive))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    return Status;
}
#endif // i386



NTSTATUS
GetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN PDWORD pdwConversion
    )

/*++

Routine Description:

    This routine get IME mode for KEY_EVENT_RECORD.

Arguments:

    ConsoleInfo - Pointer to console information structure.

Return Value:

--*/

{
    DWORD dwDummy;

    /*
     * If pdwConversion is NULL, the caller doesn't want the result -- but
     * for code efficiency, let it point to the dummy dword variable, so
     * that we don't have to care from here.
     */
    if (pdwConversion == NULL) {
        pdwConversion = &dwDummy;
    }

    if (Console->InputBuffer.ImeMode.Disable) {
        *pdwConversion = 0;
    } else {
        PINPUT_THREAD_INFO InputThreadInfo;

        InputThreadInfo = TlsGetValue(InputThreadTlsIndex);

        if (InputThreadInfo != NULL) {
            LRESULT lResult;

            /*
             * We're being called on the Console Input Thread, so we're
             * clear to pump messages.
             */

            if (!NT_SUCCESS(ConsoleImeMessagePumpWorker(Console,
                    CONIME_GET_NLSMODE,
                    (WPARAM)Console->ConsoleHandle,
                    (LPARAM)0,
                    &lResult))) {

                *pdwConversion = IME_CMODE_DISABLE;
                return STATUS_INVALID_HANDLE;
            }


            *pdwConversion = (DWORD)lResult;

            if (Console->InputBuffer.ImeMode.ReadyConversion == FALSE) {
                Console->InputBuffer.ImeMode.ReadyConversion = TRUE;
            }
        } else {
            /*
             * We're being called from an LPC worker thread, so we cannot
             * pump messages.
             */
            if (Console->InputBuffer.ImeMode.ReadyConversion == FALSE) {
                *pdwConversion = 0;
                return STATUS_SUCCESS;
            }

            *pdwConversion = Console->InputBuffer.ImeMode.Conversion;
        }


        if (*pdwConversion & IME_CMODE_OPEN) {
            Console->InputBuffer.ImeMode.Open = TRUE;
        } else {
            Console->InputBuffer.ImeMode.Open = FALSE;
        }

        if (*pdwConversion & IME_CMODE_DISABLE) {
            Console->InputBuffer.ImeMode.Disable = TRUE;
        } else {
            Console->InputBuffer.ImeMode.Disable = FALSE;
        }

        Console->InputBuffer.ImeMode.Conversion = *pdwConversion;

    }

    return STATUS_SUCCESS;
}



NTSTATUS
SetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD fdwConversion
    )

/*++

Routine Description:

    This routine get IME mode for KEY_EVENT_RECORD.

Arguments:

    Console - Pointer to console information structure.

    fdwConversion - IME conversion status.

Return Value:

--*/

{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if ( (fdwConversion & IME_CMODE_DISABLE) && (! Console->InputBuffer.ImeMode.Disable) ) {
        Console->InputBuffer.ImeMode.Disable = TRUE;
        if ( Console->InputBuffer.ImeMode.Open ) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            if (Console->InputBuffer.ImeMode.Open && CONSOLE_IS_DBCS_OUTPUTCP(Console))
                ConsoleImePaint(Console, Console->ConsoleIme.ConvAreaRoot);
        }
    }
    else if ( (! (fdwConversion & IME_CMODE_DISABLE)) && Console->InputBuffer.ImeMode.Disable) {
        Console->InputBuffer.ImeMode.Disable = FALSE;
        if ( fdwConversion & IME_CMODE_OPEN ) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            if (Console->InputBuffer.ImeMode.Open && CONSOLE_IS_DBCS_OUTPUTCP(Console))
                ConsoleImePaint(Console, Console->ConsoleIme.ConvAreaRoot);
        }
    }
    else if ( (fdwConversion & IME_CMODE_DISABLE) && (Console->InputBuffer.ImeMode.Disable) ) {
        return STATUS_SUCCESS;
    }

    if ( (fdwConversion & IME_CMODE_OPEN) && (! Console->InputBuffer.ImeMode.Open)) {
        Console->InputBuffer.ImeMode.Open = TRUE;
    }
    else if ( (! (fdwConversion & IME_CMODE_OPEN)) && Console->InputBuffer.ImeMode.Open) {
        Console->InputBuffer.ImeMode.Open = FALSE;
    }

    Console->InputBuffer.ImeMode.Conversion = fdwConversion;

    if (Console->InputBuffer.ImeMode.ReadyConversion == FALSE)
        Console->InputBuffer.ImeMode.ReadyConversion = TRUE;

    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                          CONIME_SET_NLSMODE,
                          (WPARAM)Console->ConsoleHandle,
                          (LPARAM)fdwConversion
                         ))) {
        return STATUS_INVALID_HANDLE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SetImeCodePage(
    IN PCONSOLE_INFORMATION Console
    )
{
    DWORD CodePage = Console->OutputCP;
    DWORD fdwConversion;

    if (!CONSOLE_IS_DBCS_CP(Console))
    {
        if (!NT_SUCCESS(GetImeKeyState(Console, &fdwConversion))) {
            return STATUS_INVALID_HANDLE;
        }

        fdwConversion |= IME_CMODE_DISABLE;

    }
    else {
        fdwConversion = Console->InputBuffer.ImeMode.Conversion & ~IME_CMODE_DISABLE;
    }

    if (!NT_SUCCESS(SetImeKeyState(Console, fdwConversion))) {
        return STATUS_INVALID_HANDLE;
    }

    if (CONSOLE_IS_IME_ENABLED()) {
        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_NOTIFY_CODEPAGE,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)MAKELPARAM(FALSE, CodePage)
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SetImeOutputCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD PrevCodePage
    )
{
    DWORD CodePage = Console->OutputCP;

    // Output code page
    if ((ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) &&
        (IsAvailableFarEastCodePage(CodePage) || IsAvailableFarEastCodePage(PrevCodePage)))
    {
        ConvertToCodePage(Console, PrevCodePage);
        AdjustFont(Console, CodePage);
    }
    // load special ROM font, if necessary
#ifdef i386
    if ( (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) &&
         !(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER))
    {
        SetROMFontCodePage(CodePage,
                           ScreenInfo->BufferInfo.TextInfo.ModeIndex);
        SetCursorInformationHW(ScreenInfo,
                        ScreenInfo->BufferInfo.TextInfo.CursorSize,
                        ScreenInfo->BufferInfo.TextInfo.CursorVisible);
        WriteRegionToScreenHW(ScreenInfo,
                &ScreenInfo->Window);
    }
#endif

    if (CONSOLE_IS_IME_ENABLED()) {
        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_NOTIFY_CODEPAGE,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)MAKELPARAM(TRUE, CodePage)
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    return STATUS_SUCCESS;
}
#endif // FE_IME

















VOID
SetLineChar(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine setup of line character code.

Arguments:

    ScreenInfo - Pointer to screen information structure.

Return Value:

    none.

--*/

{
    if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
    {
        if (OEMCP == JAPAN_CP || OEMCP == KOREAN_CP)
        {
            /*
             * This is Japanese/Korean case,
             * These characters maps grid of half width.
             * so, same as U+2500.
             */
            ScreenInfo->LineChar[UPPER_LEFT_CORNER]   = 0x0001;
            ScreenInfo->LineChar[UPPER_RIGHT_CORNER]  = 0x0002;
            ScreenInfo->LineChar[HORIZONTAL_LINE]     = 0x0006;
            ScreenInfo->LineChar[VERTICAL_LINE]       = 0x0005;
            ScreenInfo->LineChar[BOTTOM_LEFT_CORNER]  = 0x0003;
            ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER] = 0x0004;
        }
        else
        {
            /*
             * This is FE case,
             * FE don't uses U+2500 because these grid characters
             * maps to full width.
             */
            ScreenInfo->LineChar[UPPER_LEFT_CORNER]   = L'+';
            ScreenInfo->LineChar[UPPER_RIGHT_CORNER]  = L'+';
            ScreenInfo->LineChar[HORIZONTAL_LINE]     = L'-';
            ScreenInfo->LineChar[VERTICAL_LINE]       = L'|';
            ScreenInfo->LineChar[BOTTOM_LEFT_CORNER]  = L'+';
            ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER] = L'+';
        }
    }
    else {
        ScreenInfo->LineChar[UPPER_LEFT_CORNER]   = 0x250c;
        ScreenInfo->LineChar[UPPER_RIGHT_CORNER]  = 0x2510;
        ScreenInfo->LineChar[HORIZONTAL_LINE]     = 0x2500;
        ScreenInfo->LineChar[VERTICAL_LINE]       = 0x2502;
        ScreenInfo->LineChar[BOTTOM_LEFT_CORNER]  = 0x2514;
        ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER] = 0x2518;
    }
}

BOOL
CheckBisectStringA(
    IN DWORD CodePage,
    IN PCHAR Buffer,
    IN DWORD NumBytes,
    IN LPCPINFO lpCPInfo
    )

/*++

Routine Description:

    This routine check bisected on Ascii string end.

Arguments:

    CodePage - Value of code page.

    Buffer - Pointer to Ascii string buffer.

    NumBytes - Number of Ascii string.

Return Value:

    TRUE - Bisected character.

    FALSE - Correctly.

--*/

{
    UNREFERENCED_PARAMETER(CodePage);

    while(NumBytes) {
        if (IsDBCSLeadByteConsole(*Buffer,lpCPInfo)) {
            if (NumBytes <= 1)
                return TRUE;
            else {
                Buffer += 2;
                NumBytes -= 2;
            }
        }
        else {
            Buffer++;
            NumBytes--;
        }
    }
    return FALSE;
}



VOID
BisectWrite(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine write buffer with bisect.

Arguments:

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PROW RowPrev;
    PROW RowNext;

#if DBG && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

#ifdef FE_SB
    //
    // This buffer must be in textmode.
    //
    UserAssert(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (RowIndex > 0) {
        RowPrev = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex-1];
    } else {
        RowPrev = &ScreenInfo->BufferInfo.TextInfo.Rows[ScreenInfo->ScreenBufferSize.Y-1];
    }

    if (RowIndex+1 < ScreenInfo->ScreenBufferSize.Y) {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex+1];
    } else {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[0];
    }

    //
    // Check start position of strings
    //
    if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
    {
        if (TargetPoint.X == 0) {
            RowPrev->CharRow.Chars[ScreenInfo->ScreenBufferSize.X-1] = UNICODE_SPACE;
            RowPrev->CharRow.KAttrs[ScreenInfo->ScreenBufferSize.X-1] = 0;
            ScreenInfo->BisectFlag |= BISECT_TOP;
        }
        else {
            Row->CharRow.Chars[TargetPoint.X-1] = UNICODE_SPACE;
            Row->CharRow.KAttrs[TargetPoint.X-1] = 0;
            ScreenInfo->BisectFlag |= BISECT_LEFT;
        }
    }

    //
    // Check end position of strings
    //
    if (TargetPoint.X+StringLength < ScreenInfo->ScreenBufferSize.X) {
        if (Row->CharRow.KAttrs[TargetPoint.X+StringLength] & ATTR_TRAILING_BYTE)
          {
            Row->CharRow.Chars[TargetPoint.X+StringLength] = UNICODE_SPACE;
            Row->CharRow.KAttrs[TargetPoint.X+StringLength] = 0;
            ScreenInfo->BisectFlag |= BISECT_RIGHT;
        }
    }
    else if (TargetPoint.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
        if (RowNext->CharRow.KAttrs[0] & ATTR_TRAILING_BYTE)
        {
            RowNext->CharRow.Chars[0] = UNICODE_SPACE;
            RowNext->CharRow.KAttrs[0] = 0;
            ScreenInfo->BisectFlag |= BISECT_BOTTOM;
        }
    }
}

VOID
BisectClipbrd(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PSMALL_RECT SmallRect
    )

/*++

Routine Description:

    This routine check bisect for clipboard process.

Arguments:

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PROW RowNext;

#if DBG && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

#ifdef FE_SB
    //
    // This buffer must be in textmode.
    //
    UserAssert(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (RowIndex+1 < ScreenInfo->ScreenBufferSize.Y) {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex+1];
    } else {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[0];
    }

    //
    // Check start position of strings
    //
    UserAssert(CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console));
    if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE) {
        if (TargetPoint.X == 0) {
            SmallRect->Left++;
        } else {
            SmallRect->Left--;
        }
    }
    //
    // Check end position of strings
    //
    if (TargetPoint.X+StringLength < ScreenInfo->ScreenBufferSize.X) {
        if (Row->CharRow.KAttrs[TargetPoint.X+StringLength] & ATTR_TRAILING_BYTE)
        {
            SmallRect->Right++;
        }
    }
    else if (TargetPoint.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
        if (RowNext->CharRow.KAttrs[0] & ATTR_TRAILING_BYTE)
        {
            SmallRect->Right--;
        }
    }
}


VOID
BisectWriteAttr(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine write buffer with bisect.

Arguments:

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PROW RowNext;

#if DBG && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

#ifdef FE_SB
    //
    // This buffer must be in textmode.
    //
    UserAssert(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (RowIndex+1 < ScreenInfo->ScreenBufferSize.Y) {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex+1];
    } else {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[0];
    }

    //
    // Check start position of strings
    //
    if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE){
        if (TargetPoint.X == 0) {
            ScreenInfo->BisectFlag |= BISECT_TOP;
        }
        else {
            ScreenInfo->BisectFlag |= BISECT_LEFT;
        }
    }

    //
    // Check end position of strings
    //
    if (TargetPoint.X+StringLength < ScreenInfo->ScreenBufferSize.X) {
        if (Row->CharRow.KAttrs[TargetPoint.X+StringLength] & ATTR_TRAILING_BYTE){
            ScreenInfo->BisectFlag |= BISECT_RIGHT;
        }
    }
    else if (TargetPoint.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
        if (RowNext->CharRow.KAttrs[0] & ATTR_TRAILING_BYTE){
            ScreenInfo->BisectFlag |= BISECT_BOTTOM;
        }
    }
}



/***************************************************************************\
* BOOL IsConsoleFullWidth(HDC hDC,DWORD CodePage,WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* Return:
*     FASLE : half width. Uses 1 column per one character
*     TRUE  : full width. Uses 2 columns per one character
*
* History:
* 04-08-92 ShunK       Created.
* Jul-27-1992 KazuM    Added Screen Information and Code Page Information.
* Jan-29-1992 V-Hirots Substruct Screen Information.
* Oct-06-1996 KazuM    Not use RtlUnicodeToMultiByteSize and WideCharToMultiByte
*                      Because 950 only defined 13500 chars,
*                      and unicode defined almost 18000 chars.
*                      So there are almost 4000 chars can not be mapped to big5 code.
\***************************************************************************/

BOOL IsConsoleFullWidth(
    IN HDC hDC,
    IN DWORD CodePage,
    IN WCHAR wch
    )
{
    INT Width;
    TEXTMETRIC tmi;

    if (!IsAvailableFarEastCodePage(CodePage)) {
        return FALSE;
    }

    if (0x20 <= wch && wch <= 0x7e) {
        /* ASCII */
        return FALSE;
    } else if (0x3041 <= wch && wch <= 0x3094) {
        /* Hiragana */
        return TRUE;
    } else if (0x30a1 <= wch && wch <= 0x30f6) {
        /* Katakana */
        return TRUE;
    } else if (0x3105 <= wch && wch <= 0x312c) {
        /* Bopomofo */
        return TRUE;
    } else if (0x3131 <= wch && wch <= 0x318e) {
        /* Hangul Elements */
        return TRUE;
    } else if (0xac00 <= wch && wch <= 0xd7a3) {
        /* Korean Hangul Syllables */
        return TRUE;
    } else if (0xff01 <= wch && wch <= 0xff5e) {
        /* Fullwidth ASCII variants */
        return TRUE;
    } else if (0xff61 <= wch && wch <= 0xff9f) {
        /* Halfwidth Katakana variants */
        return FALSE;
    } else if ( (0xffa0 <= wch && wch <= 0xffbe) ||
              (0xffc2 <= wch && wch <= 0xffc7) ||
              (0xffca <= wch && wch <= 0xffcf) ||
              (0xffd2 <= wch && wch <= 0xffd7) ||
              (0xffda <= wch && wch <= 0xffdc)) {
        /* Halfwidth Hangule variants */
        return FALSE;
    } else if (0xffe0 <= wch && wch <= 0xffe6) {
        /* Fullwidth symbol variants */
        return TRUE;
    } else if (0x4e00 <= wch && wch <= 0x9fa5) {
        /* Han Ideographic */
        return TRUE;
    } else if (0xf900 <= wch && wch <= 0xfa2d) {
        /* Han Compatibility Ideographs */
        return TRUE;
    } else {
        BOOL ret;

        /* Unknown character */

        ret = GetTextMetricsW(hDC, &tmi);
        if (!ret) {
            RIPMSGF1(RIP_WARNING,
                     "GetTextMetricsW failed with error 0x%x",
                     GetLastError());
            return FALSE;
        }

        if (IS_ANY_DBCS_CHARSET(tmi.tmCharSet)) {
            tmi.tmMaxCharWidth /= 2;
        }

        ret = GetCharWidth32(hDC, wch, wch, &Width);
        if (!ret) {
            RIPMSGF1(RIP_WARNING,
                     "GetCharWidth32 failed with error 0x%x",
                     GetLastError());
            return FALSE;
        }

        if (Width == tmi.tmMaxCharWidth) {
            return FALSE;
        } else if (Width == tmi.tmMaxCharWidth*2) {
            return TRUE;
        }
    }

    UserAssert(FALSE);
    return FALSE;
}


/*++

Routine Description:

    This routine remove DBCS padding code.

Arguments:

    Dst - Pointer to destination.

    Src - Pointer to source.

    NumBytes - Number of string.

    OS2OemFormat -

Return Value:

--*/

DWORD
RemoveDbcsMark(
    IN PWCHAR Dst,
    IN PWCHAR Src,
    IN DWORD NumBytes,
    IN PCHAR SrcA,
    IN BOOL OS2OemFormat
    )
{
    PWCHAR Tmp = Dst;

    if (NumBytes == 0 || NumBytes >= 0xffffffff)
        return( 0 );

#if defined(i386)
    if (OS2OemFormat) {
        RealUnicodeToNEC_OS2_Unicode(Src, NumBytes);
    }
#endif

    if (SrcA) {
        while (NumBytes--)
        {
            if (!(*SrcA++ & ATTR_TRAILING_BYTE))
                *Dst++ = *Src;
            Src++;
        }
        return (ULONG)(Dst - Tmp);
    }
    else {
        RtlCopyMemory(Dst,Src,NumBytes * sizeof(WCHAR)) ;
        return(NumBytes) ;
    }
#if !defined(i386)
    UNREFERENCED_PARAMETER(OS2OemFormat);
#endif
}

/*++

Routine Description:

    This routine remove DBCS padding code for cell format.

Arguments:

    Dst - Pointer to destination.

    Src - Pointer to source.

    NumBytes - Number of string.

Return Value:

--*/

DWORD
RemoveDbcsMarkCell(
    IN PCHAR_INFO Dst,
    IN PCHAR_INFO Src,
    IN DWORD NumBytes
    )
{
    PCHAR_INFO Tmp = Dst;
    DWORD TmpByte;

    TmpByte = NumBytes;
    while (NumBytes--) {
        if (!(Src->Attributes & COMMON_LVB_TRAILING_BYTE)){
            *Dst = *Src;
            Dst->Attributes &= ~COMMON_LVB_SBCSDBCS;
            Dst++;
        }
        Src++;
    }
    NumBytes = (ULONG)(TmpByte - (Dst - Tmp));
    RtlZeroMemory(Dst, NumBytes * sizeof(CHAR_INFO));
    Dst += NumBytes;

    return (ULONG)(Dst - Tmp);
}

DWORD
RemoveDbcsMarkAll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PROW Row,
    IN PSHORT LeftChar,
    IN PRECT TextRect,
    IN int *TextLeft,
    IN PWCHAR Buffer,
    IN SHORT NumberOfChars
    )
{
    BOOL OS2OemFormat = FALSE;

#if defined(i386)
    if ((ScreenInfo->Console->Flags & CONSOLE_OS2_REGISTERED) &&
        (ScreenInfo->Console->Flags & CONSOLE_OS2_OEM_FORMAT) &&
        (ScreenInfo->Console->OutputCP == OEMCP)) {
        OS2OemFormat = TRUE;
    }
#endif // i386

    if (NumberOfChars <= 0)
        return NumberOfChars;

    if ( !CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
    {
        return RemoveDbcsMark(Buffer,
                              &Row->CharRow.Chars[*LeftChar],
                              NumberOfChars,
                              NULL,
                              OS2OemFormat
                             );
    }
    else if ( *LeftChar > ScreenInfo->Window.Left &&  Row->CharRow.KAttrs[*LeftChar] & ATTR_TRAILING_BYTE)
    {
        TextRect->left -= SCR_FONTSIZE(ScreenInfo).X;
        --*LeftChar;
        if (TextLeft)
            *TextLeft = TextRect->left;
        return RemoveDbcsMark(Buffer,
                              &Row->CharRow.Chars[*LeftChar],
                              NumberOfChars+1,
                              &Row->CharRow.KAttrs[*LeftChar],
                              OS2OemFormat
                             );
    }
    else if (*LeftChar == ScreenInfo->Window.Left && Row->CharRow.KAttrs[*LeftChar] & ATTR_TRAILING_BYTE)
    {
        *Buffer = UNICODE_SPACE;
        return RemoveDbcsMark(Buffer+1,
                              &Row->CharRow.Chars[*LeftChar+1],
                              NumberOfChars-1,
                              &Row->CharRow.KAttrs[*LeftChar+1],
                              OS2OemFormat
                             ) + 1;
    }
    else
    {
        return RemoveDbcsMark(Buffer,
                              &Row->CharRow.Chars[*LeftChar],
                              NumberOfChars,
                              &Row->CharRow.KAttrs[*LeftChar],
                              OS2OemFormat
                             );
    }
}


BOOL
IsDBCSLeadByteConsole(
    IN BYTE AsciiChar,
    IN LPCPINFO lpCPInfo
    )
{
    int i;

    i = 0;
    while (lpCPInfo->LeadByte[i]) {
        if (lpCPInfo->LeadByte[i] <= AsciiChar && AsciiChar <= lpCPInfo->LeadByte[i+1])
            return TRUE;
        i += 2;
    }
    return FALSE;
}


NTSTATUS
AdjustFont(
    IN PCONSOLE_INFORMATION Console,
    IN UINT CodePage
    )
{
    PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;
    ULONG FontIndex;
    static const COORD NullCoord = {0, 0};
    TEXT_BUFFER_FONT_INFO TextFontInfo;
    NTSTATUS Status;

    Status = FindTextBufferFontInfo(ScreenInfo,
                                    CodePage,
                                    &TextFontInfo);
    if (NT_SUCCESS(Status)) {
        FontIndex = FindCreateFont(TextFontInfo.Family,
                                   TextFontInfo.FaceName,
                                   TextFontInfo.FontSize,
                                   TextFontInfo.Weight,
                                   CodePage);
    }
    else {
        FontIndex = FindCreateFont(0,
                                   SCR_FACENAME(ScreenInfo),
                                   NullCoord,                  // sets new font by FontSize=0
                                   0,
                                   CodePage);
    }
#ifdef i386
    if (! (Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        SetScreenBufferFont(Console->CurrentScreenBuffer,FontIndex, CodePage);
    }
    else {
        BOOL fChange = FALSE;

        if ((Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) &&
            (GetForegroundWindow() == Console->hWnd)                    )
        {
            ChangeDispSettings(Console, Console->hWnd, 0);
            fChange = TRUE;
        }
        SetScreenBufferFont(Console->CurrentScreenBuffer,FontIndex, CodePage);
        ConvertToFullScreen(Console);
        if (fChange &&
            (GetForegroundWindow() == Console->hWnd))
            ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
    }
#else
    SetScreenBufferFont(Console->CurrentScreenBuffer,FontIndex, CodePage);
#endif
    return STATUS_SUCCESS;
}


NTSTATUS
ConvertToCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN UINT PrevCodePage
    )
{
    PSCREEN_INFORMATION Cur;

    if (Console->OutputCP != OEMCP && PrevCodePage == OEMCP)
    {

        for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Cur->Next) {

            if (Cur->Flags & CONSOLE_GRAPHICS_BUFFER) {
                continue;
            }

            ConvertOutputOemToNonOemUnicode(
                Cur->BufferInfo.TextInfo.TextRows,
                Cur->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows,
                Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                Console->OutputCP);

            if ((Cur->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                RealUnicodeToFalseUnicode(
                    Cur->BufferInfo.TextInfo.TextRows,
                    Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                    Console->OutputCP);
            }
        }

        if (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {
                Cur = ConvAreaInfo->ScreenBuffer;

                if (!(Cur->Flags & CONSOLE_GRAPHICS_BUFFER)) {

                    ConvertOutputOemToNonOemUnicode(
                        Cur->BufferInfo.TextInfo.TextRows,
                        Cur->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows,
                        Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                        Console->OutputCP);

                    if ((Cur->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                        RealUnicodeToFalseUnicode(
                            Cur->BufferInfo.TextInfo.TextRows,
                            Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                            Console->OutputCP);
                    }
                }

                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }

            Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        }

#ifdef FE_SB
        else {
            UserAssert(FALSE);
        }
#endif

        SetWindowSize(Console->CurrentScreenBuffer);
        WriteToScreen(Console->CurrentScreenBuffer,&Console->CurrentScreenBuffer->Window);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ConvertOutputOemToNonOemUnicode(
    IN OUT LPWSTR Source,
    IN OUT PBYTE KAttrRows,
    IN int SourceLength, // in chars
    IN UINT Codepage
    )
{
    NTSTATUS Status;
    LPSTR  pTemp;
    LPWSTR pwTemp;
    ULONG TempLength;
    ULONG Length;
    BOOL NormalChars;
    int i;

    if (SourceLength == 0 )
        return STATUS_SUCCESS;

    NormalChars = TRUE;
    for (i=0;i<SourceLength;i++) {
        if (Source[i] > 0x7f) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }

    pTemp = ConsoleHeapAlloc(TMP_TAG, SourceLength);
    if (pTemp == NULL) {
        return STATUS_NO_MEMORY;
    }

    pwTemp = ConsoleHeapAlloc(TMP_TAG, SourceLength * sizeof(WCHAR));
    if (pwTemp == NULL) {
        ConsoleHeapFree(pTemp);
        return STATUS_NO_MEMORY;
    }

    TempLength = RemoveDbcsMark(pwTemp,
                                Source,
                                SourceLength,
                                KAttrRows,
                                FALSE);

    Status = RtlUnicodeToOemN(pTemp,
                              (ULONG)ConsoleHeapSize(pTemp),
                              &Length,
                              pwTemp,
                              TempLength * sizeof(WCHAR)
                             );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(pTemp);
        ConsoleHeapFree(pwTemp);
        return Status;
    }

    MultiByteToWideChar(Codepage,
                        0,
                        pTemp,
                        Length,
                        Source,
                        SourceLength
                       );
    ConsoleHeapFree(pTemp);
    ConsoleHeapFree(pwTemp);

    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        if (KAttrRows) {
            RtlZeroMemory(KAttrRows, SourceLength);
        }
        return STATUS_SUCCESS;
    }
}






VOID
TextOutEverything(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT LeftWindowPos,
    IN OUT PSHORT RightWindowPos,
    IN OUT PSHORT CountOfAttr,
    IN SHORT CountOfAttrOriginal,
    IN OUT PBOOL DoubleColorDBCS,
    IN BOOL LocalEUDCFlag,
    IN PROW Row,
    IN PATTR_PAIR Attr,
    IN SHORT LeftTextPos,
    IN SHORT RightTextPos,
    IN int WindowRectLeft,
    IN RECT WindowRect,
    IN SHORT NumberOfChars
    )

/*++

Routine Description:

    This routine text out everything.

Arguments:

Return Value:

--*/

{
    int   j = LeftWindowPos;
    int   TextLeft = WindowRectLeft;
    RECT TextRect = WindowRect;
    SHORT LeftChar = LeftTextPos;
    SHORT RightChar = RightTextPos;
    BOOL  DoubleColorDBCSBefore;
    BOOL  LocalEUDCFlagBefore;
    PEUDC_INFORMATION EudcInfo;

    int   RightPos  = j + *CountOfAttr - 1;
    int   RightText = LeftChar + *CountOfAttr - 1;
    BOOL  OS2OemFormat = FALSE;

#ifdef FE_SB
    //
    // This buffer must be in textmode.
    //
    UserAssert(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

#if defined(i386)
    if ((ScreenInfo->Console->Flags & CONSOLE_OS2_REGISTERED) &&
        (ScreenInfo->Console->Flags & CONSOLE_OS2_OEM_FORMAT) &&
        (ScreenInfo->Console->OutputCP == OEMCP)) {
        OS2OemFormat = TRUE;
    }
#endif // i386

#if DBG && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

    RightText = min(RightText,(ScreenInfo->ScreenBufferSize.X-1));

    LocalEUDCFlagBefore = LocalEUDCFlag ;
    EudcInfo = (PEUDC_INFORMATION)Console->EudcInformation;

    DoubleColorDBCSBefore = *DoubleColorDBCS ;
    if (DoubleColorDBCSBefore){
        RECT TmpRect;

        if (Console->FonthDC == NULL) {
            Console->FonthDC = CreateCompatibleDC(Console->hDC);
            Console->hBitmap = CreateBitmap(DEFAULT_FONTSIZE, DEFAULT_FONTSIZE, BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
            SelectObject(Console->FonthDC, Console->hBitmap);
        }

        if (LocalEUDCFlagBefore){
            if (EudcInfo->hDCLocalEudc == NULL) {
                EudcInfo->hDCLocalEudc = CreateCompatibleDC(Console->hDC);
                EudcInfo->hBmpLocalEudc = CreateBitmap(EudcInfo->LocalEudcSize.X,
                                                       EudcInfo->LocalEudcSize.Y,
                                                       BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
                SelectObject(EudcInfo->hDCLocalEudc, EudcInfo->hBmpLocalEudc);
            }
            GetFitLocalEUDCFont(Console,
                                Row->CharRow.Chars[LeftChar-1]);
            BitBlt(Console->hDC,
                   TextRect.left,
                   TextRect.top,
                   SCR_FONTSIZE(ScreenInfo).X,
                   SCR_FONTSIZE(ScreenInfo).Y,
                   EudcInfo->hDCLocalEudc,
                   SCR_FONTSIZE(ScreenInfo).X,
                   0,
                   SRCCOPY
                  );
            TextRect.left += SCR_FONTSIZE(ScreenInfo).X;
            TextLeft +=  SCR_FONTSIZE(ScreenInfo).X;
            TextRect.right += SCR_FONTSIZE(ScreenInfo).X;
            (*CountOfAttr)++;
            NumberOfChars = 0;
        }
        else{
            TmpRect.left = 0;
            TmpRect.top = 0;
            TmpRect.right = SCR_FONTSIZE(ScreenInfo).X;
            TmpRect.bottom = SCR_FONTSIZE(ScreenInfo).Y;

            SelectObject(Console->FonthDC,
                         FontInfo[SCR_FONTNUMBER(ScreenInfo)].hFont
                        );

            ExtTextOutW(Console->FonthDC,
                        0,
                        0,
                        ETO_OPAQUE,
                        &TmpRect,
                        &Row->CharRow.Chars[LeftChar-1],
                        1,
                        NULL
                       );
            BitBlt(Console->hDC,
                   TextRect.left,
                   TextRect.top,
                   SCR_FONTSIZE(ScreenInfo).X,
                   SCR_FONTSIZE(ScreenInfo).Y,
                   Console->FonthDC,
                   SCR_FONTSIZE(ScreenInfo).X,
                   0,
                   SRCCOPY
                  );
            TextRect.left += SCR_FONTSIZE(ScreenInfo).X;
            TextLeft += SCR_FONTSIZE(ScreenInfo).X;
            NumberOfChars = (SHORT)RemoveDbcsMark(ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter,
                                                  &Row->CharRow.Chars[LeftChar+1],
                                                  NumberOfChars-1,
                                                  &Row->CharRow.KAttrs[LeftChar+1],
                                                  OS2OemFormat);
        }

    }
    else {
        NumberOfChars = (SHORT)RemoveDbcsMarkAll(ScreenInfo,
                                                 Row,
                                                 &LeftChar,
                                                 &TextRect,
                                                 &TextLeft,
                                                 ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter,
                                                 NumberOfChars);
    }


    *DoubleColorDBCS = FALSE ;
    if ((NumberOfChars != 0) && (Row->CharRow.KAttrs[RightText] & ATTR_LEADING_BYTE)){
        if (RightPos >= ScreenInfo->Window.Right)
            *(ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter+NumberOfChars-1) = UNICODE_SPACE;
        else if(TextRect.right <= ScreenInfo->Window.Right * SCR_FONTSIZE(ScreenInfo).X) {
            *DoubleColorDBCS = TRUE;
            TextRect.right += SCR_FONTSIZE(ScreenInfo).X;
            if((j == *RightWindowPos)&&
               (*RightWindowPos < ScreenInfo->Window.Right))
            *RightWindowPos++;
        }
    }

    if( TextRect.left < TextRect.right){
        ExtTextOutW(Console->hDC,
                    TextLeft,
                    TextRect.top,
                    ETO_OPAQUE,
                    &TextRect,
                    ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter,
                    NumberOfChars,
                    NULL
                   );
    }
    if (LocalEUDCFlagBefore){
        DWORD dwFullWidth = (IsConsoleFullWidth(Console->hDC,
                                                Console->OutputCP,
                                                Row->CharRow.Chars[RightText+1]) ? 2 : 1);

        if (EudcInfo->hDCLocalEudc == NULL) {
            EudcInfo->hDCLocalEudc = CreateCompatibleDC(Console->hDC);
            EudcInfo->hBmpLocalEudc = CreateBitmap(EudcInfo->LocalEudcSize.X,
                                                   EudcInfo->LocalEudcSize.Y,
                                                   BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
            SelectObject(EudcInfo->hDCLocalEudc, EudcInfo->hBmpLocalEudc);
        }
        GetFitLocalEUDCFont(Console,
                            Row->CharRow.Chars[RightText+1]);
        BitBlt(Console->hDC,                      // hdcDest
               TextRect.right,                    // nXDest
               TextRect.top,                      // nYDest
               SCR_FONTSIZE(ScreenInfo).X * dwFullWidth, // nWidth
               SCR_FONTSIZE(ScreenInfo).Y,    // nHeight
               EudcInfo->hDCLocalEudc,            // hdcSrc
               0,                                 // nXSrc
               0,                                 // nYSrc
               SRCCOPY
              );

        TextRect.right += (SCR_FONTSIZE(ScreenInfo).X * dwFullWidth);
        (*CountOfAttr) += (SHORT)dwFullWidth;
        if (CountOfAttrOriginal < *CountOfAttr ){
            *DoubleColorDBCS = TRUE ;
            (*CountOfAttr)--;
            TextRect.right -= SCR_FONTSIZE(ScreenInfo).X;
        }
    }
    if (DoubleColorDBCSBefore){
        TextRect.left -= SCR_FONTSIZE(ScreenInfo).X;
    }

    TextOutCommonLVB(Console, Attr->Attr, TextRect);

}

VOID
TextOutCommonLVB(
    IN PCONSOLE_INFORMATION Console,
    IN WORD Attributes,
    IN RECT CommonLVBRect
    )
{
    HBRUSH hbrSave;
    HGDIOBJ hbr;
    int GridX;

    if (Attributes & (COMMON_LVB_GRID_HORIZONTAL |
                      COMMON_LVB_GRID_LVERTICAL  |
                      COMMON_LVB_GRID_RVERTICAL  |
                      COMMON_LVB_UNDERSCORE       )
       )
    {
        if(Attributes & COMMON_LVB_UNDERSCORE){
            if(Attributes & COMMON_LVB_REVERSE_VIDEO)
                hbr = CreateSolidBrush(ConvertAttrToRGB(Console, LOBYTE(Attributes >> 4)));
            else
                hbr = CreateSolidBrush(ConvertAttrToRGB(Console, LOBYTE(Attributes)));
            hbrSave = SelectObject(Console->hDC, hbr);
            PatBlt(Console->hDC,
                   CommonLVBRect.left,
                   CommonLVBRect.bottom-1,
                   CommonLVBRect.right-CommonLVBRect.left,
                   1,
                   PATCOPY
                  );
            SelectObject(Console->hDC, hbrSave);
            DeleteObject(hbr);
        }

        if(Attributes & (COMMON_LVB_GRID_HORIZONTAL | COMMON_LVB_GRID_LVERTICAL | COMMON_LVB_GRID_RVERTICAL)){
            hbr = CreateSolidBrush(ConvertAttrToRGB(Console, 0x0007));
            hbrSave = SelectObject(Console->hDC, hbr);

            if(Attributes & COMMON_LVB_GRID_HORIZONTAL){
                PatBlt(Console->hDC,
                       CommonLVBRect.left,
                       CommonLVBRect.top,
                       CommonLVBRect.right-CommonLVBRect.left,
                       1,
                       PATCOPY
                      );
            }
            if(Attributes & COMMON_LVB_GRID_LVERTICAL){
                for ( GridX = CommonLVBRect.left ;
                      GridX < CommonLVBRect.right ;
                      GridX += CON_FONTSIZE(Console).X){
                    PatBlt(Console->hDC,
                           GridX,
                           CommonLVBRect.top,
                           1,
                           CON_FONTSIZE(Console).Y,
                           PATCOPY
                          );
                }
            }
            if(Attributes & COMMON_LVB_GRID_RVERTICAL){
                for ( GridX = CommonLVBRect.left + CON_FONTSIZE(Console).X-1 ;
                      GridX < CommonLVBRect.right ;
                      GridX += CON_FONTSIZE(Console).X){
                    PatBlt(Console->hDC,
                           GridX,
                           CommonLVBRect.top,
                           1,
                           CON_FONTSIZE(Console).Y,
                           PATCOPY
                          );
                }
            }
            SelectObject(Console->hDC, hbrSave);
            DeleteObject(hbr);
        }
    }
}

NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD DefaultFontSize,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPWSTR AltFaceName
    )
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    COORD FontSize = DefaultFontSize;
    COORD FontDelta;
    BOOL  fDbcsCharSet = IsAvailableFarEastCodePage(CodePage);

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i=0; i < NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet) == fDbcsCharSet
           )
        {
            FontDelta.X = (SHORT)abs(FontSize.X - FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    wcscpy(AltFaceName, FontInfo[*AltFontIndex].FaceName);
    *AltFontSize = FontInfo[*AltFontIndex].Size;
    *AltFontFamily = FontInfo[*AltFontIndex].Family;

    DBGFONTS(("MakeAltRasterFont : AltFontIndex = %ld\n", *AltFontIndex));

    return STATUS_SUCCESS;
}


NTSTATUS
InitializeDbcsMisc(
    VOID)
{
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[512];
    WCHAR awchData[512];
    BYTE Buffer[512];
    DWORD Length;
    DWORD dwIndex;
    LPWSTR pwsz;
    static BOOL bDBCSInitialized = FALSE;

    if (bDBCSInitialized) {
        return STATUS_SUCCESS;
    } else {
        bDBCSInitialized = TRUE;
    }

    UserAssert(gTTFontList.Next == NULL);
    UserAssert(gRegFullScreenCodePage.Next == NULL);

    /*
     * Get TrueType Font Face name from registry.
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_TTFONT,
                          &hkRegistry);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_VERBOSE,
                "NtOpenKey(%ws) failed with status 0x%x",
                MACHINE_REGISTRY_CONSOLE_TTFONT,
                Status);
    } else {
        LPTTFONTLIST pTTFontList;

        for (dwIndex = 0; ; dwIndex++) {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue),
                                    (LPWSTR)&awchValue,
                                    sizeof(awchData),
                                    (PBYTE)&awchData);
            if (!NT_SUCCESS(Status)) {
                break;
            }

            pTTFontList = ConsoleHeapAlloc(SCREEN_DBCS_TAG, sizeof(TTFONTLIST));
            if (pTTFontList == NULL) {
                break;
            }

            pTTFontList->List.Next = NULL;
            pTTFontList->CodePage = ConvertStringToDec(awchValue, NULL);
            pwsz = awchData;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            } else {
                pTTFontList->fDisableBold = FALSE;
            }
            wcscpy(pTTFontList->FaceName1, pwsz);

            pwsz += wcslen(pwsz) + 1;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            wcscpy(pTTFontList->FaceName2, pwsz);

            PushEntryList(&gTTFontList, &(pTTFontList->List));
        }

        NtClose(hkRegistry);
    }

    /*
     * Get Full Screen from registry.
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_FULLSCREEN,
                          &hkRegistry);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_VERBOSE,
                "NtOpenKey(%ws) failed with status 0x%x",
                MACHINE_REGISTRY_CONSOLE_FULLSCREEN,
                Status);
    } else {
        /*
         * InitialPalette
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_INITIAL_PALETTE,
                                   sizeof( Buffer ), Buffer, &Length);
        if (NT_SUCCESS(Status) && Length > sizeof(DWORD)) {
            DWORD PaletteLength = ((LPDWORD)Buffer)[0];
            PUSHORT Palette;

            if (PaletteLength * sizeof(USHORT) >= (Length - sizeof(DWORD))) {
                Palette = ConsoleHeapAlloc(BUFFER_TAG, Length);
                if (Palette != NULL) {
                    RtlCopyMemory(Palette, Buffer, Length);
                    RegInitialPalette = Palette;
                }
            }
        }

        /*
         * ColorBuffer.
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_COLOR_BUFFER,
                                   sizeof(Buffer),
                                   Buffer,
                                   &Length);
        if (NT_SUCCESS(Status) && Length > sizeof(DWORD)) {
            DWORD ColorBufferLength = ((LPDWORD)Buffer)[0];
            PUCHAR Color;

            if (ColorBufferLength * sizeof(DWORD) >= (Length - sizeof(DWORD))) {
                Color = ConsoleHeapAlloc(BUFFER_TAG, Length);
                if (Color != NULL) {
                    RtlCopyMemory(Color, Buffer, Length);
                    RegColorBuffer = Color;
                }
            }
        }

        /*
         * ColorBufferNoTranslate.
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_COLOR_BUFFER_NO_TRANSLATE,
                                   sizeof(Buffer),
                                   Buffer,
                                   &Length);
        if (NT_SUCCESS(Status) && Length > sizeof(DWORD)) {
            DWORD ColorBufferLength = ((LPDWORD)Buffer)[0];
            PUCHAR Color;

            if (ColorBufferLength * sizeof(DWORD) >= (Length - sizeof(DWORD))) {
                Color = ConsoleHeapAlloc(BUFFER_TAG, Length);
                if (Color != NULL) {
                    RtlCopyMemory(Color, Buffer, Length);
                    RegColorBufferNoTranslate = Color;
                }
            }
        }

        /*
         * ModeFontPairs
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_MODE_FONT_PAIRS,
                                   sizeof(Buffer),
                                   Buffer,
                                   &Length);
        if (NT_SUCCESS(Status) && Length > sizeof(DWORD)) {
            DWORD NumOfEntries = ((LPDWORD)Buffer)[0];
            PMODE_FONT_PAIR ModeFont;

            if (NumOfEntries * sizeof(MODE_FONT_PAIR) >= (Length - sizeof(DWORD))) {
                ModeFont = ConsoleHeapAlloc(BUFFER_TAG, Length);
                if (ModeFont != NULL) {
                    Length -= sizeof(DWORD);
                    RtlCopyMemory(ModeFont, &Buffer[sizeof(DWORD)], Length);
                    RegModeFontPairs = ModeFont;
                    NUMBER_OF_MODE_FONT_PAIRS = NumOfEntries;
                }
            }
        }

        /*
         * FullScreen\CodePage
         */
        {
            HANDLE hkRegCP = NULL;

            Status = MyRegOpenKey(hkRegistry,
                                  MACHINE_REGISTRY_FS_CODEPAGE,
                                  &hkRegCP);
            if (!NT_SUCCESS(Status)) {
                RIPMSG2(RIP_VERBOSE,
                        "NtOpenKey(%ws) failed with status 0x%x",
                        MACHINE_REGISTRY_FS_CODEPAGE,
                        Status);
            } else {
                PFS_CODEPAGE pFsCodePage;

                for (dwIndex = 0; ; dwIndex++) {
                    Status = MyRegEnumValue(hkRegCP,
                                            dwIndex,
                                            sizeof(awchValue),
                                            (LPWSTR)&awchValue,
                                            sizeof(awchData),
                                            (PBYTE)&awchData);
                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    pFsCodePage = ConsoleHeapAlloc(BUFFER_TAG, sizeof(FS_CODEPAGE));
                    if (pFsCodePage == NULL) {
                        break;
                    }

                    pFsCodePage->List.Next = NULL;
                    pFsCodePage->CodePage = ConvertStringToDec(awchValue, NULL);

                    PushEntryList(&gRegFullScreenCodePage, &(pFsCodePage->List));
                }

                NtClose(hkRegCP);
            }
        }

        NtClose(hkRegistry);
    }

#if defined(i386)
    Status = NtGetMachineIdentifierValue(&gdwMachineId);
    if (!NT_SUCCESS(Status)) {
        gdwMachineId = MACHINEID_MS_PCAT;
    }
#endif

    Status = RtlInitializeCriticalSectionAndSpinCount(&ConIMEInitWindowsLock,
                                                      0x80000000);

    return Status;
}


/*
 * This routine converts a unicode string from the real unicode characters
 * to the NEC OS/2 unicode characters.
 */
#if defined(i386)
NTSTATUS
RealUnicodeToNEC_OS2_Unicode(
    IN OUT LPWSTR Source,
    IN int SourceLength      // in chars
    )
{
    NTSTATUS Status;
    LPSTR Temp;
    ULONG TempLength;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    BOOL NormalChars;
    int i;

    DBGCHARS(("RealUnicodeToNEC_OS2_Unicode U->ACP:???->U %.*ls\n",
            SourceLength > 10 ? 10 : SourceLength, Source));
    NormalChars = TRUE;

    if (pGlyph_NEC_OS2_CP == NULL || pGlyph_NEC_OS2_CP->MultiByteTable == NULL) {
        DBGCHARS(("RealUnicodeToNEC_OS2_Unicode  xfer buffer null\n"));
        return STATUS_SUCCESS;  // there's nothing we can do
    }

    /*
     * Test for characters < 0x20. If none are found, we don't have any
     * conversion to do!
     */
    for (i = 0; i < SourceLength; i++) {
        if ((USHORT)(Source[i]) < 0x20) {
            NormalChars = FALSE;
            break;
        }
    }

    if (NormalChars) {
        return STATUS_SUCCESS;
    }

    TempLength = SourceLength;
    if (TempLength > STACK_BUFFER_SIZE) {
        Temp = ConsoleHeapAlloc(TMP_TAG, TempLength);
        if (Temp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        Temp = StackBuffer;
    }
    Status = RtlUnicodeToMultiByteN(Temp,
                                    TempLength,
                                    &Length,
                                    Source,
                                    SourceLength * sizeof(WCHAR));
    if (!NT_SUCCESS(Status)) {
        if (TempLength > STACK_BUFFER_SIZE) {
            ConsoleHeapFree(Temp);
        }
        return Status;
    }

    UserAssert(pGlyph_NEC_OS2_CP != NULL && pGlyph_NEC_OS2_CP->MultiByteTable != NULL);
    Status = RtlCustomCPToUnicodeN(pGlyph_NEC_OS2_CP,
                                   Source,
                                   SourceLength * sizeof(WCHAR),
                                   &Length,
                                   Temp,
                                   TempLength);
    if (TempLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        return STATUS_SUCCESS;
    }
}

BOOL
InitializeNEC_OS2_CP(
    VOID
    )
{
    PPEB pPeb;

    pPeb = NtCurrentPeb();
    if ((pPeb == NULL) || (pPeb->OemCodePageData == NULL)) {
        return FALSE;
    }

    /*
     * Fill in the CPTABLEINFO struct
     */
    if (pGlyph_NEC_OS2_CP == NULL) {
        pGlyph_NEC_OS2_CP = ConsoleHeapAlloc(SCREEN_DBCS_TAG, sizeof(CPTABLEINFO));
        if (pGlyph_NEC_OS2_CP == NULL) {
            return FALSE;
        }
    }
    RtlInitCodePageTable(pPeb->OemCodePageData, pGlyph_NEC_OS2_CP);

    /*
     * Make a copy of the MultiByteToWideChar table
     */
    if (pGlyph_NEC_OS2_Table == NULL) {
        pGlyph_NEC_OS2_Table = ConsoleHeapAlloc(SCREEN_DBCS_TAG, 256 * sizeof(USHORT));
        if (pGlyph_NEC_OS2_Table == NULL) {
            return FALSE;
        }
    }
    RtlCopyMemory(pGlyph_NEC_OS2_Table, pGlyph_NEC_OS2_CP->MultiByteTable, 256 * sizeof(USHORT));

    /*
     * Modify the first 0x20 bytes so that they are glyphs.
     */
    MultiByteToWideChar(CP_OEMCP, MB_USEGLYPHCHARS,
            "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20"
            "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x1E\x1F\x1C\x07",
            0x20, pGlyph_NEC_OS2_Table, 0x20);


    /*
     * Point the Custom CP at the glyph table
     */
    pGlyph_NEC_OS2_CP->MultiByteTable = pGlyph_NEC_OS2_Table;

    return TRUE;
}
#endif // i386

BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo(IntToPtr(CodePage), &csi, TCI_SRCCODEPAGE)) {
        csi.ciCharset = OEM_CHARSET;
    }

    return (BYTE)csi.ciCharset;
}

BOOL
IsAvailableFarEastCodePage(
    UINT CodePage
    )
{
    BYTE CharSet = CodePageToCharSet(CodePage);

    return IS_ANY_DBCS_CHARSET(CharSet);
}

LPTTFONTLIST
SearchTTFont(
    LPWSTR pwszFace,
    BOOL   fCodePage,
    UINT   CodePage
    )
{
    PSINGLE_LIST_ENTRY pTemp = gTTFontList.Next;

    if (pwszFace) {
        while (pTemp != NULL) {
            LPTTFONTLIST pTTFontList = (LPTTFONTLIST)pTemp;

            if (wcscmp(pwszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(pwszFace, pTTFontList->FaceName2) == 0) {
                if (fCodePage) {
                    if (pTTFontList->CodePage == CodePage) {
                        return pTTFontList;
                    } else {
                        return NULL;
                    }
                } else {
                    return pTTFontList;
                }
            }

            pTemp = pTemp->Next;
        }
    }

    return NULL;
}

BOOL
IsAvailableTTFont(
    LPWSTR pwszFace
    )
{
    if (SearchTTFont(pwszFace, FALSE, 0)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IsAvailableTTFontCP(
    LPWSTR pwszFace,
    UINT CodePage
    )
{
    if (SearchTTFont(pwszFace, TRUE, CodePage)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

LPWSTR
GetAltFaceName(
    LPWSTR pwszFace
    )
{
    LPTTFONTLIST pTTFontList;

    pTTFontList = SearchTTFont(pwszFace, FALSE, 0);
    if (pTTFontList != NULL) {
        if (wcscmp(pwszFace, pTTFontList->FaceName1) == 0) {
            return pTTFontList->FaceName2;
        }

        if (wcscmp(pwszFace, pTTFontList->FaceName2) == 0) {
            return pTTFontList->FaceName1;
        }
        return NULL;
    } else {
        return NULL;
    }
}

BOOL
IsAvailableFsCodePage(
    UINT CodePage
    )
{
    PSINGLE_LIST_ENTRY pTemp = gRegFullScreenCodePage.Next;

    while (pTemp != NULL) {
        PFS_CODEPAGE pFsCodePage = (PFS_CODEPAGE)pTemp;

        if (pFsCodePage->CodePage == CodePage) {
            return TRUE;
        }

        pTemp = pTemp->Next;
    }

    return FALSE;
}


#if defined(FE_IME)
/*
 * Console IME executing logic.
 *
 * KERNEL32:ConDllInitialize
 *            If Reason is DLL_PROCESS_ATTACH
 *            |
 *            V
 * WINSRV:ConsoleClientConnectRoutine
 *          |
 *          V
 *          SetUpConsole
 *            |
 *            V
 *            AllocateConsole
 *              PostThreadMessage(CM_CREATE_CONSOLE_WINDOW)
 *          |
 *          V
 *          UnlockConsoleHandleTable
 *          InitConsoleIMEStuff
 *            |
 *            V
 *            If never register console IME
 *              hThread = InternalCreateCallbackThread(ConsoleIMERoutine)
 *              QueueThreadMessage(CM_WAIT_CONIME_PROCESS)
 *            |
 *            V
 *            QueueThreadMessage(CM_CONIME_CREATE)
 *          |
 *          V
 * KERNEL32:NtWaitForMultipleObjects(InitEvents)
 *
 *
 * WINSRV:InputThread
 *          |
 *          V
 *          GetMessage
 *            Receive CM_CREATE_CONSOLE_WINDOW
 *              |
 *              V
 *              ProcessCreateConsoleWindow
 *                |
 *                V
 *                CreateWindowsWindow
 *                  |
 *                  V
 *                  CreateWindowEx
 *                  NtSetEvent(InitEvents)
 *          |
 *          V
 *          GetMessage
 *            Receive CM_WAIT_CONIME_PROCESS (this case is never register console IME)
 *              |
 *              V
 *              WaitConsoleIMEStuff
 *                If never register console IME
 *                  NtWaitForSingleObject(hThread, 20 sec)
 *
 *
 * KERNEL32:ConsoleIMERoutine
 *            |
 *            V
 *            hEvent = CreateEvent(CONSOLEIME_EVENT)
 *            If not exist named event
 *              CreateProcess(conime.exe)
 *              WaitForSingleObject(hEvent, 10 sec)
 *              If WAIT_TIMEOUT
 *                TerminateProcess
 *            |
 *            V
 *            TerminateThread(hThread)
 *
 *
 * CONIME:WinMain
 *          |
 *          V
 *          CreateWindow
 *          RegisterConsoleIME
 *            |
 *            V
 *            WINSRV:ConSrvRegisterConsoleIME
 *                     |
 *                     V
 *                     QueueThreadMessage(CM_SET_CONSOLEIME_WINDOW)
 *          |
 *          V
 *          AttachThreadInput
 *          SetEvent(CONSOLEIME_EVENT)
 *
 *
 * WINSRV:InputThread
 *          |
 *          V
 *          GetMessage
 *            Receive CM_CONIME_CREATE
 *              |
 *              V
 *              ProcessCreateConsoleIME
 *                If available hWndConsoleIME
 *                  hIMC = SendMessage(console IME, CONIME_CREATE)
 *                Else
 *                  PostMessage(CM_CONIME_CREATE)
 *          |
 *          V
 *          GetMessage
 *            Receive CM_SET_CONSOLEIME_WINDOW
 *              TlsGetValue()->hWndConsoleIME = wParam
 *
 *
 * TerminateProcess of Console IME
 *   WINSRV:ConsoleClientDisconnectRoutine
 *            |
 *            V
 *            RemoveConsoleIME
 */

VOID
ProcessCreateConsoleIME(
    IN LPMSG lpMsg,
    DWORD dwConsoleThreadId)
{
    NTSTATUS Status;
    HANDLE ConsoleHandle = (HANDLE)lpMsg->wParam;
    PCONSOLE_INFORMATION pConsole;
    HWND hwndConIme;

    Status = RevalidateConsole(ConsoleHandle, &pConsole);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    hwndConIme = pConsole->InputThreadInfo->hWndConsoleIME;

    if (pConsole->InputThreadInfo->hWndConsoleIME != NULL) {
        LRESULT lResult;

        Status = ConsoleImeMessagePumpWorker(pConsole,
                                             CONIME_CREATE,
                                             (WPARAM)pConsole->ConsoleHandle,
                                             (LPARAM)pConsole->hWnd,
                                             &lResult);
        if (!NT_SUCCESS(Status)) {
            goto TerminateConsoleIme;
        }

        if (lResult) {
            if (!CONSOLE_IS_DBCS_CP(pConsole)) {
                pConsole->InputBuffer.ImeMode.Disable = TRUE;
            }

            CreateConvAreaModeSystem(pConsole);

            if ((pConsole->Flags & CONSOLE_HAS_FOCUS) ||
                (pConsole->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
                Status = ConsoleImeMessagePump(pConsole,
                                               CONIME_SETFOCUS,
                                               (WPARAM)pConsole->ConsoleHandle,
                                               (LPARAM)pConsole->hklActive);
                if (!NT_SUCCESS(Status)) {
                    goto TerminateConsoleIme;
                }
            }

            if (pConsole->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                Status = ConsoleImeMessagePump(pConsole,
                                               CONIME_NOTIFY_SCREENBUFFERSIZE,
                                               (WPARAM)pConsole->ConsoleHandle,
                                               MAKELPARAM(pConsole->CurrentScreenBuffer->ScreenBufferSize.X,
                                               pConsole->CurrentScreenBuffer->ScreenBufferSize.Y));
                if (!NT_SUCCESS(Status)) {
                    goto TerminateConsoleIme;
                }
            }
            Status = ConsoleImeMessagePump(pConsole,
                                           CONIME_NOTIFY_CODEPAGE,
                                           (WPARAM)pConsole->ConsoleHandle,
                                           MAKELPARAM(FALSE, pConsole->CP));
            if (!NT_SUCCESS(Status)) {
                goto TerminateConsoleIme;
            }
            Status = ConsoleImeMessagePump(pConsole,
                                           CONIME_NOTIFY_CODEPAGE,
                                           (WPARAM)pConsole->ConsoleHandle,
                                           MAKELPARAM(TRUE, pConsole->OutputCP));
            if (!NT_SUCCESS(Status)) {
                goto TerminateConsoleIme;
            }

            Status = GetImeKeyState(pConsole, NULL);
            if (!NT_SUCCESS(Status)) {
                goto TerminateConsoleIme;
            }
        }
    } else if (lpMsg->lParam) {
        /*
         * This case, First = TRUE
         * Again post message of CM_CONIME_CREATE.
         * Becase hWndConsoleIME available when CM_SET_CONSOLEIME_WINDOW message
         * and it message will be run after this.
         */
        Status = QueueThreadMessage(dwConsoleThreadId,
                                    CM_CONIME_CREATE,
                                    (WPARAM)ConsoleHandle,
                                    FALSE);
        if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING,
                        "QueueThreadMessage(CM_CONIME_CREATE) failed (0x%x)",
                        Status);
        }
    }

    UnlockConsole(pConsole);

    return;

TerminateConsoleIme:
    RIPMSG1(RIP_WARNING,
            "ProcessCreateConsoleIme failing with status 0x%x",
            Status);
    if (IsWindow(hwndConIme)) {
        PostMessage(hwndConIme, CONIME_DESTROY, (WPARAM)ConsoleHandle, (LPARAM)NULL);
    }

    UnlockConsole(pConsole);
}

NTSTATUS
InitConsoleIMEStuff(
    HDESK hDesktop,
    DWORD dwConsoleThreadId,
    PCONSOLE_INFORMATION Console
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
    HANDLE hThread = NULL;
    BOOL First = FALSE;

    if (!gfLoadConIme) {
        RIPMSG0(RIP_WARNING, "InitConsoleIMEStuff is skipping conime loading");
        return STATUS_UNSUCCESSFUL; // the return value does not really matter...
    }

    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    RegConIMEInfo.hdesk      = hDesktop;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
    if (RegConIMEInfo.dwThreadId == 0) {
        /*
         * Create a Remote Thread on client side.
         * This remote thread do create a console IME process.
         */
        hThread = InternalCreateCallbackThread(CONSOLE_CLIENTPROCESSHANDLE(),
                                               (ULONG_PTR)ConsoleIMERoutine,
                                               (ULONG_PTR)0);
        if (hThread == NULL) {
            RIPMSGF1(RIP_WARNING,
                    "CreateRemoteThread failed with error 0x%x",
                    GetLastError());
        } else {
            /*
             * CM_WAIT_CONIME_PROCESS
             * This message wait for ready to go console IME process.
             */
            Status = QueueThreadMessage(dwConsoleThreadId,
                                        CM_WAIT_CONIME_PROCESS,
                                        (WPARAM)hDesktop,
                                        (LPARAM)hThread
                                        );
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "QueueThreadMessage(CM_WAIT_CONIME_PROCESS) failed (%08x)\n", Status);
            } else {
                First = TRUE;
            }
        }
    }

    Status = QueueThreadMessage(dwConsoleThreadId,
                                CM_CONIME_CREATE,
                                (WPARAM)Console->ConsoleHandle,
                                (LPARAM)First);
    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING,
                 "QueueThreadMessage(CM_CONIME_CREATE) failed with status 0x%x",
                 Status);
    }

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    return Status;
}

NTSTATUS
WaitConsoleIMEStuff(
    HDESK hDesktop,
    HANDLE hThread
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;

    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    RegConIMEInfo.hdesk      = hDesktop;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    if (RegConIMEInfo.dwThreadId == 0) {
        int cLoops;
        LARGE_INTEGER li;

        /*
         * Do wait for ready to go console IME process.
         *
         * This wait code should after the CreateWindowsWindow
         * because doesn't finish DLL attach on client side
         * for wait a Console->InitEvents.
         */
        cLoops = 80;
        li.QuadPart = (LONGLONG)-10000 * 250;
        while (cLoops--) {
            /*
             * Sleep for a second.
             */
            Status = NtWaitForSingleObject(hThread, FALSE, &li);
            if (Status != STATUS_TIMEOUT) {
                break;
            }

            RtlEnterCriticalSection(&ConIMEInitWindowsLock);
            RegConIMEInfo.hdesk      = hDesktop;
            RegConIMEInfo.dwThreadId = 0;
            RegConIMEInfo.dwAction   = REGCONIME_QUERY;
            NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
            RtlLeaveCriticalSection(&ConIMEInitWindowsLock);
            if (RegConIMEInfo.dwThreadId != 0) {
                break;
            }
        }
    }

    NtClose(hThread);

    return Status;
}

NTSTATUS
ConSrvRegisterConsoleIME(
    PCSR_PROCESS Process,
    HDESK hDesktop,
    HWINSTA hWinSta,
    HWND  hWndConsoleIME,
    DWORD dwConsoleIMEThreadId,
    DWORD dwAction,
    DWORD *dwConsoleThreadId
    )
{
    NTSTATUS Status;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    RegConIMEInfo.hdesk      = hDesktop;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
    if (RegConIMEInfo.dwConsoleInputThreadId == 0) {
        Status = STATUS_UNSUCCESSFUL;
        goto ErrorExit;
    }

    if (RegConIMEInfo.dwThreadId == 0) {
        /*
         * Never registered console ime thread.
         */
        if (dwAction == REGCONIME_REGISTER) {
            /*
             * register
             */
            RegConIMEInfo.hdesk      = hDesktop;
            RegConIMEInfo.dwThreadId = dwConsoleIMEThreadId;
            RegConIMEInfo.dwAction   = dwAction;
            Status = NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
            if (NT_SUCCESS(Status)) {
                Status = QueueThreadMessage(RegConIMEInfo.dwConsoleInputThreadId,
                                            CM_SET_CONSOLEIME_WINDOW,
                                            (WPARAM)hWndConsoleIME,
                                            0);
                if (!NT_SUCCESS(Status)) {
                    RIPMSGF1(RIP_WARNING,
                             "QueueThreadMessage failed with status 0x%x",
                             Status);
                    Status = STATUS_UNSUCCESSFUL;
                    goto ErrorExit;
                }

                ProcessData->hDesk = hDesktop;
                ProcessData->hWinSta = hWinSta;

                if (dwConsoleThreadId) {
                    *dwConsoleThreadId = RegConIMEInfo.dwConsoleInputThreadId;
                }
            }
        } else {
            Status = STATUS_UNSUCCESSFUL;
            goto ErrorExit;
        }
    } else {
        /*
         * Do registered console ime thread.
         */
        if (dwAction == REGCONIME_UNREGISTER || dwAction == REGCONIME_TERMINATE) {
            /*
             * unregister
             */
            RegConIMEInfo.hdesk      = hDesktop;
            RegConIMEInfo.dwThreadId = dwConsoleIMEThreadId;
            RegConIMEInfo.dwAction   = dwAction;
            Status = NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
            if (NT_SUCCESS(Status)) {
                Status = QueueThreadMessage(RegConIMEInfo.dwConsoleInputThreadId,
                                            CM_SET_CONSOLEIME_WINDOW,
                                            (WPARAM)NULL,
                                            0);
                if (!NT_SUCCESS(Status)) {
                    RIPMSGF1(RIP_WARNING,
                             "QueueThreadMessage failed with status 0x%x",
                             Status);
                    Status = STATUS_UNSUCCESSFUL;
                    goto ErrorExit;
                }

                CloseDesktop(ProcessData->hDesk);
                CloseWindowStation(ProcessData->hWinSta);

                ProcessData->hDesk = NULL;
                ProcessData->hWinSta = NULL;

                if (dwConsoleThreadId) {
                    *dwConsoleThreadId = RegConIMEInfo.dwConsoleInputThreadId;
                }
            }
        } else {
            Status = STATUS_UNSUCCESSFUL;
            goto ErrorExit;
        }
    }

ErrorExit:
    if (!NT_SUCCESS(Status)) {
        CloseDesktop(hDesktop);
        CloseWindowStation(hWinSta);
    }

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    return Status;
}


VOID
RemoveConsoleIME(
    PCSR_PROCESS Process,
    DWORD dwConsoleIMEThreadId
    )
{
    NTSTATUS Status;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    //
    // This is console IME process
    //
    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    RegConIMEInfo.hdesk      = ProcessData->hDesk;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
    if (RegConIMEInfo.dwConsoleInputThreadId == 0) {
        Status = STATUS_UNSUCCESSFUL;
    } else if (dwConsoleIMEThreadId == RegConIMEInfo.dwThreadId) {
        /*
         * Unregister console IME
         */
        Status = ConSrvRegisterConsoleIME(Process,
                                          ProcessData->hDesk,
                                          ProcessData->hWinSta,
                                          NULL,
                                          dwConsoleIMEThreadId,
                                          REGCONIME_TERMINATE,
                                          NULL);
    }

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);
}


/*
 * Console IME message pump.
 *
 * Note for NT5 --- this function is build on bogus assumptions
 * (also has some nasty workaround for sloppy conime).
 * There's a chance that pConsole goes away while sendmessage
 * is processed by conime.
 * Keep in mind, anybody who calls this function should validate
 * the return status as appropriate.
 */

NTSTATUS
ConsoleImeMessagePumpWorker(
    PCONSOLE_INFORMATION Console,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam,
    LRESULT* lplResult)
{
    HWND    hWndConsoleIME = Console->InputThreadInfo->hWndConsoleIME;
    LRESULT fNoTimeout;
    PINPUT_THREAD_INFO InputThreadInfo;

    *lplResult = 0;

    if (hWndConsoleIME == NULL) {
        return STATUS_SUCCESS;
    }

    InputThreadInfo = TlsGetValue(InputThreadTlsIndex);
    if (InputThreadInfo != NULL) {
        HWND hWnd = Console->hWnd;

        /*
         * We're being called on the Console Input Thread, so we can pump
         * messages safely.
         */

        fNoTimeout = SendMessageTimeout(hWndConsoleIME,
                                        Message,
                                        wParam,
                                        lParam,
                                        SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                        CONIME_SENDMSG_TIMEOUT,
                                        lplResult);
        if (fNoTimeout) {
            return STATUS_SUCCESS;
        }

        if ((Console = GetWindowConsole(hWnd)) == NULL ||
            (Console->Flags & CONSOLE_TERMINATING)) {

            //
            // This console is terminated. ConsoleImeMessagePump gives up
            // SendMessage to conime.
            //

            return STATUS_INVALID_HANDLE;
        }

         //
         // Timeout return from SendMessageTimeout or hung hWndConsoleIME.
         //
    }

    /*
     * We're being called from an LPC worker thread, so we cannot safely
     * pump messages.
     */
    PostMessage(hWndConsoleIME, Message, wParam, lParam);

    return STATUS_SUCCESS;
}

NTSTATUS
ConsoleImeMessagePump(
    PCONSOLE_INFORMATION Console,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT lResultDummy;

    return ConsoleImeMessagePumpWorker(Console, Message, wParam, lParam, &lResultDummy);
}

#endif // FE_IME




BOOL
RegisterKeisenOfTTFont(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NTSTATUS Status;
    COORD FontSize;
    DWORD BuffSize;
    LPSTRINGBITMAP StringBitmap;
    WCHAR wChar;
    WCHAR wCharBuf[2];
    ULONG ulNumFonts;
    DWORD dwFonts;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    GetNumFonts(&ulNumFonts);
    for (dwFonts = 0; dwFonts < ulNumFonts; dwFonts++) {
        if (!TM_IS_TT_FONT(FontInfo[dwFonts].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[dwFonts].tmCharSet)) {
            GetFontSize(dwFonts, &FontSize);
            BuffSize = CalcBitmapBufferSize(FontSize,BYTE_ALIGN);
            StringBitmap = ConsoleHeapAlloc(TMP_DBCS_TAG, sizeof(STRINGBITMAP) + BuffSize);
            if (StringBitmap == NULL) {
                RIPMSGF1(RIP_WARNING,
                         "Cannot allocate 0n%d bytes",
                          sizeof(STRINGBITMAP) + BuffSize);
                return FALSE;
            }

            if (SelectObject(Console->hDC,FontInfo[dwFonts].hFont)==0) {
                goto error_return;
            }

            for (wChar=0; wChar < UNICODE_SPACE; wChar++) {
                wCharBuf[0] = wChar;
                wCharBuf[1] = TEXT('\0');
                if (GetStringBitmapW(Console->hDC,
                                     wCharBuf,
                                     1,
                                     sizeof(STRINGBITMAP) + BuffSize,
                                     (BYTE*)StringBitmap) == 0) {
                    goto error_return;
                }
                FontSize.X = (WORD)StringBitmap->uiWidth;
                FontSize.Y = (WORD)StringBitmap->uiHeight;
                Status = RegisterLocalEUDC(Console,wChar,FontSize,StringBitmap->ajBits);
                if (!NT_SUCCESS(Status)) {
error_return:
                    ConsoleHeapFree(StringBitmap);
                    return FALSE;
                }
            }

            ConsoleHeapFree(StringBitmap);
        }
        ((PEUDC_INFORMATION)(Console->EudcInformation))->LocalKeisenEudcMode = TRUE;
    }

    return TRUE;
}

ULONG
TranslateUnicodeToOem(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR UnicodeBuffer,
    IN ULONG UnicodeCharCount,
    OUT PCHAR AnsiBuffer,
    IN ULONG AnsiByteCount,
    OUT PINPUT_RECORD DbcsLeadInpRec
    )
{
    ULONG i,j;
    PWCHAR TmpUni;
    BYTE AsciiDbcs[2];
    ULONG NumBytes;

    TmpUni = ConsoleHeapAlloc(TMP_DBCS_TAG, UnicodeCharCount * sizeof(WCHAR));
    if (TmpUni == NULL) {
        return 0;
    }

    memcpy(TmpUni, UnicodeBuffer, UnicodeCharCount * sizeof(WCHAR));
    AsciiDbcs[1] = 0;
    for (i = 0, j = 0; i < UnicodeCharCount; i++, j++) {
        if (IsConsoleFullWidth(Console->hDC,Console->CP,TmpUni[i])) {
            NumBytes = sizeof(AsciiDbcs);
            ConvertToOem(Console->CP,
                         &TmpUni[i],
                         1,
                         &AsciiDbcs[0],
                         NumBytes);
            if (IsDBCSLeadByteConsole(AsciiDbcs[0],&Console->CPInfo)) {
                if (j < AnsiByteCount - 1) {  // -1 is safe DBCS in buffer
                    AnsiBuffer[j] = AsciiDbcs[0];
                    j++;
                    AnsiBuffer[j] = AsciiDbcs[1];
                    AsciiDbcs[1] = 0;
                } else if (j == AnsiByteCount - 1) {
                    AnsiBuffer[j] = AsciiDbcs[0];
                    j++;
                    break;
                } else {
                    AsciiDbcs[1] = 0;
                    break;
                }
            } else {
                AnsiBuffer[j] = AsciiDbcs[0];
                AsciiDbcs[1] = 0;
            }
        } else {
            ConvertToOem(Console->CP,
                   &TmpUni[i],
                   1,
                   &AnsiBuffer[j],
                   1);
        }
    }

    if (DbcsLeadInpRec) {
        if (AsciiDbcs[1]) {
            DbcsLeadInpRec->EventType = KEY_EVENT;
            DbcsLeadInpRec->Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[1];
        } else {
            RtlZeroMemory(DbcsLeadInpRec,sizeof(INPUT_RECORD));
        }
    }

    ConsoleHeapFree(TmpUni);
    return j;
}


DWORD
ImmConversionToConsole(
    DWORD fdwConversion
    )
{
    DWORD dwNlsMode;

    if (GetKeyState(VK_KANA) & KEY_TOGGLED) {
        fdwConversion = (fdwConversion & ~IME_CMODE_LANGUAGE) | (IME_CMODE_NATIVE | IME_CMODE_KATAKANA);
    }

    dwNlsMode = 0;
    if (fdwConversion & IME_CMODE_NATIVE) {
        if (fdwConversion & IME_CMODE_KATAKANA)
            dwNlsMode |= NLS_KATAKANA;
        else
            dwNlsMode |= NLS_HIRAGANA;
    } else {
        dwNlsMode |= NLS_ALPHANUMERIC;
    }

    if (fdwConversion & IME_CMODE_FULLSHAPE) {
        dwNlsMode |= NLS_DBCSCHAR;
    }

    if (fdwConversion & IME_CMODE_ROMAN) {
        dwNlsMode |= NLS_ROMAN;
    }

    if (fdwConversion & IME_CMODE_OPEN) {
        dwNlsMode |= NLS_IME_CONVERSION;
    }

    if (fdwConversion & IME_CMODE_DISABLE) {
        dwNlsMode |= NLS_IME_DISABLE;
    }

    return dwNlsMode;
}

DWORD
ImmConversionFromConsole(
    DWORD dwNlsMode
    )
{
    DWORD fdwConversion;

    fdwConversion = 0;
    if (dwNlsMode & (NLS_KATAKANA | NLS_HIRAGANA)) {
        fdwConversion |= IME_CMODE_NATIVE;
        if (dwNlsMode & NLS_KATAKANA)
            fdwConversion |= IME_CMODE_KATAKANA;
    }

    if (dwNlsMode & NLS_DBCSCHAR) {
        fdwConversion |= IME_CMODE_FULLSHAPE;
    }

    if (dwNlsMode & NLS_ROMAN) {
        fdwConversion |= IME_CMODE_ROMAN;
    }

    if (dwNlsMode & NLS_IME_CONVERSION) {
        fdwConversion |= IME_CMODE_OPEN;
    }

    if (dwNlsMode & NLS_IME_DISABLE) {
        fdwConversion |= IME_CMODE_DISABLE;
    }

    return fdwConversion;
}

#if DBG && defined(DBG_KATTR)
VOID
BeginKAttrCheck(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    SHORT RowIndex;
    PROW Row;
    SHORT i;

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    for (i=0;i<ScreenInfo->ScreenBufferSize.Y;i++) {
        UserAssert(Row->CharRow.KAttrs);
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\directio.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    directio.h

Abstract:

        This file implements the NT console direct I/O API

Author:

    KazuM Apr.19.1996

Revision History:

--*/

typedef struct _DIRECT_READ_DATA {
    PINPUT_INFORMATION InputInfo;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    HANDLE HandleIndex;
} DIRECT_READ_DATA, *PDIRECT_READ_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\getset.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    getset.c

Abstract:

        This file implements the NT console server console state API

Author:

    Therese Stowell (thereses) 5-Dec-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef i386
VOID
ReverseMousePointer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );
#endif

ULONG
SrvGetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_MODE_MSG a = (PCONSOLE_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_ANY_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        //
        // check handle type and access
        //

        if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
            a->Mode = HandleData->Buffer.InputBuffer->InputMode;
            if (Console->Flags & CONSOLE_USE_PRIVATE_FLAGS) {
                a->Mode |= ENABLE_PRIVATE_FLAGS;
                if (Console->InsertMode) {
                    a->Mode |= ENABLE_INSERT_MODE;
                }
                if (Console->Flags & CONSOLE_QUICK_EDIT_MODE) {
                    a->Mode |= ENABLE_QUICK_EDIT_MODE;
                }
            }
        } else {
            a->Mode = HandleData->Buffer.ScreenBuffer->OutputMode;
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleNumberOfFonts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETNUMBEROFFONTS_MSG a = (PCONSOLE_GETNUMBEROFFONTS_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
        Status = STATUS_FULLSCREEN_MODE;
    } else {
        Status = GetNumFonts(&a->NumberOfFonts);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleNumberOfInputEvents(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG a = (PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = GetNumberOfReadyEvents(HandleData->Buffer.InputBuffer,
                                      &a->ReadyEvents
                                     );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleScreenBufferInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETSCREENBUFFERINFO_MSG a = (PCONSOLE_GETSCREENBUFFERINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = GetScreenBufferInformation(HandleData->Buffer.ScreenBuffer,
                                          &a->Size,
                                          &a->CursorPosition,
                                          &a->ScrollPosition,
                                          &a->Attributes,
                                          &a->CurrentWindowSize,
                                          &a->MaximumWindowSize
                                         );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCURSORINFO_MSG a = (PCONSOLE_GETCURSORINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        a->CursorSize = HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorSize;
        a->Visible = (BOOLEAN) HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorVisible;
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleSelectionInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETSELECTIONINFO_MSG a = (PCONSOLE_GETSELECTIONINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (NT_SUCCESS(Status)) {
        if (Console->Flags & CONSOLE_SELECTING) {
            a->SelectionInfo.dwFlags = (CONSOLE_SELECTION_IN_PROGRESS |
                (Console->SelectionFlags & CONSOLE_SELECTION_VALID));
            a->SelectionInfo.dwSelectionAnchor = Console->SelectionAnchor;
            a->SelectionInfo.srSelection = Console->SelectionRect;
        } else {
            RtlZeroMemory(&a->SelectionInfo, sizeof(a->SelectionInfo));
        }

        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleMouseInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETMOUSEINFO_MSG a = (PCONSOLE_GETMOUSEINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = GetMouseButtons(&a->NumButtons);
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleFontInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETFONTINFO_MSG a = (PCONSOLE_GETFONTINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumFonts, sizeof(*a->BufPtr))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
            Status = GetAvailableFonts(HandleData->Buffer.ScreenBuffer,
                                     a->MaximumWindow,
                                     a->BufPtr,
                                     &a->NumFonts
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleFontSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETFONTSIZE_MSG a = (PCONSOLE_GETFONTSIZE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
            Status = GetFontSize(a->FontIndex,
                               &a->FontSize
                              );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleCurrentFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCURRENTFONT_MSG a = (PCONSOLE_GETCURRENTFONT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
            Status = GetCurrentFont(HandleData->Buffer.ScreenBuffer,
                                  a->MaximumWindow,
                                  &a->FontIndex,
                                  &a->FontSize
                                 );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_MODE_MSG a = (PCONSOLE_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    try {
        Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                     a->Handle,
                                     CONSOLE_ANY_HANDLE,
                                     GENERIC_WRITE,
                                     &HandleData
                                    );
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
            if (a->Mode & ~(INPUT_MODES | PRIVATE_MODES)) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
            if ((a->Mode & (ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT)) == ENABLE_ECHO_INPUT) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
            if (a->Mode & PRIVATE_MODES) {
                Console->Flags |= CONSOLE_USE_PRIVATE_FLAGS;
                if (a->Mode & ENABLE_QUICK_EDIT_MODE) {
                    Console->Flags |= CONSOLE_QUICK_EDIT_MODE;
                } else {
                    Console->Flags &= ~CONSOLE_QUICK_EDIT_MODE;
                }
                if (a->Mode & ENABLE_INSERT_MODE) {
                    Console->InsertMode = TRUE;
                } else {
                    Console->InsertMode = FALSE;
                }
            } else {
                Console->Flags &= ~CONSOLE_USE_PRIVATE_FLAGS;
            }

#ifdef i386
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER &&
                (a->Mode & ENABLE_MOUSE_INPUT) != (HandleData->Buffer.InputBuffer->InputMode & ENABLE_MOUSE_INPUT)) {
                if (a->Mode & ENABLE_MOUSE_INPUT) {
                    HandleData->Buffer.InputBuffer->InputMode |= ENABLE_MOUSE_INPUT;
                }
#if defined(FE_SB)
                // Korean HBIOS doesn't like to reverse mouse pointer.
                // Because HBIOS will initialize full screen mode again.
                // 949 = Korea WanSung Code Page.
                if (Console->OutputCP != 949) {
                    ReverseMousePointer(Console->CurrentScreenBuffer,
                                        &Console->CurrentScreenBuffer->Window);
                }
#else
                ReverseMousePointer(Console->CurrentScreenBuffer,
                                    &Console->CurrentScreenBuffer->Window);
#endif
            }
#endif
            HandleData->Buffer.InputBuffer->InputMode = a->Mode & ~PRIVATE_MODES;
        }
        else {
            if (a->Mode & ~OUTPUT_MODES) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
            HandleData->Buffer.ScreenBuffer->OutputMode = a->Mode;
        }
    } finally {
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGenerateConsoleCtrlEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_CTRLEVENT_MSG a = (PCONSOLE_CTRLEVENT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    try {
        //
        // Make sure the process group id is valid
        //
        if (a->ProcessGroupId) {
            PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
            PLIST_ENTRY ListHead, ListNext;

            Status = STATUS_INVALID_PARAMETER;
            ListHead = &Console->ProcessHandleList;
            ListNext = ListHead->Flink;
            while (ListNext != ListHead) {
                ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
                ListNext = ListNext->Flink;
                if (ProcessHandleRecord->Process->ProcessGroupId == a->ProcessGroupId) {
                    Status = STATUS_SUCCESS;
                    break;
                }
            }
        }
        if (NT_SUCCESS(Status)) {
            Console->LimitingProcessId = a->ProcessGroupId;
            HandleCtrlEvent(Console, a->CtrlEvent);
        }

    } finally {
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleActiveScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETACTIVESCREENBUFFER_MSG a = (PCONSOLE_SETACTIVESCREENBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_GRAPHICS_OUTPUT_HANDLE | CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = SetActiveScreenBuffer(HandleData->Buffer.ScreenBuffer);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}


ULONG
SrvFlushConsoleInputBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_FLUSHINPUTBUFFER_MSG a = (PCONSOLE_FLUSHINPUTBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = FlushInputBuffer(HandleData->Buffer.InputBuffer);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetLargestConsoleWindowSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETLARGESTWINDOWSIZE_MSG a = (PCONSOLE_GETLARGESTWINDOWSIZE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    WINDOW_LIMITS WindowLimits;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        COORD FontSize;

        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            a->Size.X = 80;
#if defined(FE_SB)
            a->Size.Y = CONSOLE_IS_DBCS_OUTPUTCP(Console)?25:50;
#else
            a->Size.Y = 50;
#endif
        } else {
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                FontSize = SCR_FONTSIZE(ScreenInfo);
            } else {
                FontSize.X = 1;
                FontSize.Y = 1;
            }
            GetWindowLimits(ScreenInfo, &WindowLimits);
            a->Size.X = (SHORT)(WindowLimits.FullScreenSize.X / FontSize.X);
            a->Size.Y = (SHORT)(WindowLimits.FullScreenSize.Y / FontSize.Y);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleScreenBufferSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETSCREENBUFFERSIZE_MSG a = (PCONSOLE_SETSCREENBUFFERSIZE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    WINDOW_LIMITS WindowLimits;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        ScreenInfo = HandleData->Buffer.ScreenBuffer;

        //
        // make sure requested screen buffer size isn't smaller than the window
        //

        GetWindowLimits(ScreenInfo, &WindowLimits);
        if (a->Size.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo) ||
            a->Size.Y < CONSOLE_WINDOW_SIZE_Y(ScreenInfo) ||
            a->Size.Y < WindowLimits.MinimumWindowSize.Y ||
            a->Size.X < WindowLimits.MinimumWindowSize.X) {
            Status = STATUS_INVALID_PARAMETER;
        }
        else if (a->Size.X == ScreenInfo->ScreenBufferSize.X &&
                 a->Size.Y == ScreenInfo->ScreenBufferSize.Y) {
            Status = STATUS_SUCCESS;
        } else {
            Status = ResizeScreenBuffer(ScreenInfo,
                                  a->Size,
                                  TRUE);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleCursorPosition(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCURSORPOSITION_MSG a = (PCONSOLE_SETCURSORPOSITION_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    COORD WindowOrigin;
    PSCREEN_INFORMATION ScreenInfo;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        ScreenInfo = HandleData->Buffer.ScreenBuffer;

        if (a->CursorPosition.X >= ScreenInfo->ScreenBufferSize.X ||
            a->CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y ||
            a->CursorPosition.X < 0 ||
            a->CursorPosition.Y < 0) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = SetCursorPosition(ScreenInfo,
                                       a->CursorPosition,
                                       TRUE
                                      );
        }
        if (NT_SUCCESS(Status)) {
#if defined(FE_IME)
            if (ScreenInfo->Console->Flags & CONSOLE_JUST_VDM_UNREGISTERED){
                if( ScreenInfo->Console->InputBuffer.ImeMode.Open ){
                    SHORT ScrollY = 0;
                    AdjustCursorPosition(ScreenInfo,a->CursorPosition,TRUE,&ScrollY);
                    a->CursorPosition.Y += ScrollY;
                }
                Console->Flags &= ~CONSOLE_JUST_VDM_UNREGISTERED;
            }

            // Bug fix: 442406
            // Telnet : KOR IME : WinSrv.dll : SetConsoleCursorPostion does not handle cursor positioning correctly.
            // 949 = Korea WanSung Code Page.
            else if (ScreenInfo->Console->OutputCP == 949)
            {
                if( ScreenInfo->Console->InputBuffer.ImeMode.Open ){
                    ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
                }
            }
#endif
            WindowOrigin.X = 0;
            WindowOrigin.Y = 0;
            if (ScreenInfo->Window.Left > a->CursorPosition.X) {
                WindowOrigin.X = a->CursorPosition.X - ScreenInfo->Window.Left;
            }
            else if (ScreenInfo->Window.Right < a->CursorPosition.X) {
                WindowOrigin.X = a->CursorPosition.X - ScreenInfo->Window.Right;
            }
            if (ScreenInfo->Window.Top > a->CursorPosition.Y) {
                WindowOrigin.Y = a->CursorPosition.Y - ScreenInfo->Window.Top;
            }
            else if (ScreenInfo->Window.Bottom < a->CursorPosition.Y) {
                WindowOrigin.Y = a->CursorPosition.Y - ScreenInfo->Window.Bottom;
            }
            Status = SetWindowOrigin(ScreenInfo,
                                     FALSE,
                                     WindowOrigin
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCURSORINFO_MSG a = (PCONSOLE_SETCURSORINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (a->CursorSize > 100 || a->CursorSize == 0) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = SetCursorInformation(HandleData->Buffer.ScreenBuffer,a->CursorSize,a->Visible);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleWindowInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETWINDOWINFO_MSG a = (PCONSOLE_SETWINDOWINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    COORD NewWindowSize;
    WINDOW_LIMITS WindowLimits;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (!a->Absolute) {
            a->Window.Left += ScreenInfo->Window.Left;
            a->Window.Right += ScreenInfo->Window.Right;
            a->Window.Top += ScreenInfo->Window.Top;
            a->Window.Bottom += ScreenInfo->Window.Bottom;
        }
        if (a->Window.Right < a->Window.Left ||
            a->Window.Bottom < a->Window.Top) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            NewWindowSize.X = (SHORT)(WINDOW_SIZE_X(&a->Window));
            NewWindowSize.Y = (SHORT)(WINDOW_SIZE_Y(&a->Window));
            GetWindowLimits(ScreenInfo, &WindowLimits);
            if ((NewWindowSize.X > WindowLimits.MaximumWindowSize.X ||
                 NewWindowSize.Y > WindowLimits.MaximumWindowSize.Y) &&
                 !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
#ifdef i386
                if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                    COORD NewOrigin;

                    if (NewWindowSize.X != (SHORT)(WINDOW_SIZE_X(&ScreenInfo->Window)) ||
                        NewWindowSize.Y != (SHORT)(WINDOW_SIZE_Y(&ScreenInfo->Window))) {
                        COORD WindowSize;
                        ULONG ModeIndex;

#if defined(FE_SB)
                        ModeIndex = MatchWindowSize(ScreenInfo->Console->OutputCP,NewWindowSize,&WindowSize);
#else
                        ModeIndex = MatchWindowSize(NewWindowSize,&WindowSize);
#endif
                        if (NewWindowSize.X != WindowSize.X ||
                            NewWindowSize.Y != WindowSize.Y ||
                            WindowSize.X > ScreenInfo->ScreenBufferSize.X ||
                            WindowSize.Y > ScreenInfo->ScreenBufferSize.Y) {
                            UnlockConsole(Console);
                            return (ULONG) STATUS_FULLSCREEN_MODE;
                        }
                        ScreenInfo->BufferInfo.TextInfo.ModeIndex = ModeIndex;
                        ResizeWindow(ScreenInfo,
                                     &a->Window,
                                     FALSE
                                    );
                        ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.X =
                                CONSOLE_WINDOW_SIZE_X(ScreenInfo);
                        ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.Y =
                                CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                        if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                            (!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) ) {
                            SetVideoMode(ScreenInfo);
                            WriteToScreen(ScreenInfo,&ScreenInfo->Window);
                        }
                    } else {
                        NewOrigin.X = a->Window.Left;
                        NewOrigin.Y = a->Window.Top;
                        SetWindowOrigin(ScreenInfo,
                                        TRUE,
                                        NewOrigin
                                       );
                    }
                } else
#endif
                {
                    Status = ResizeWindow(ScreenInfo,
                                          &a->Window,
                                          TRUE
                                         );
                    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
                        SetWindowSize(ScreenInfo);
                        WriteToScreen(ScreenInfo,&ScreenInfo->Window);
                    }
                }
            }
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvScrollConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SCROLLSCREENBUFFER_MSG a = (PCONSOLE_SCROLLSCREENBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSMALL_RECT ClipRect;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        if (a->Clip) {
            ClipRect = &a->ClipRectangle;
        }
        else {
            ClipRect = NULL;
        }
        if (!a->Unicode) {
#if defined(FE_SB)
            a->Fill.Char.UnicodeChar = CharToWchar(Console,
                                                   Console->OutputCP,
                                                   &a->Fill.Char.AsciiChar);
#else
            a->Fill.Char.UnicodeChar = CharToWchar(
                    Console->OutputCP, a->Fill.Char.AsciiChar);
#endif
        } else if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            RealUnicodeToFalseUnicode(&a->Fill.Char.UnicodeChar,
                                    1,
                                    Console->OutputCP
                                    );
        }
        Status = ScrollRegion(HandleData->Buffer.ScreenBuffer,
                            &a->ScrollRectangle,
                            ClipRect,
                            a->DestinationOrigin,
                            a->Fill
                           );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

VOID
UpdatePopups(
    IN PCONSOLE_INFORMATION Console,
    IN WORD NewAttributes,
    IN WORD NewPopupAttributes,
    IN WORD OldAttributes,
    IN WORD OldPopupAttributes
    )

/*

    this routine is called when the user changes the screen/popup
    colors.  it goes through the popup structures and changes
    the saved contents to reflect the new screen/popup colors.

*/

{
    PLIST_ENTRY HistoryListHead, HistoryListNext;
    PLIST_ENTRY PopupListHead, PopupListNext;
    PCOMMAND_HISTORY History;
    PCLE_POPUP Popup;
    SHORT i,j;
    PCHAR_INFO OldContents;
    WORD InvertedOldPopupAttributes,InvertedNewPopupAttributes;

    InvertedOldPopupAttributes = (WORD)(((OldPopupAttributes << 4) & 0xf0) |
                                ((OldPopupAttributes >> 4) & 0x0f));
    InvertedNewPopupAttributes = (WORD)(((NewPopupAttributes << 4) & 0xf0) |
                                ((NewPopupAttributes >> 4) & 0x0f));
    HistoryListHead = &Console->CommandHistoryList;
    HistoryListNext = HistoryListHead->Blink;
    while (HistoryListNext != HistoryListHead) {
        History = CONTAINING_RECORD( HistoryListNext, COMMAND_HISTORY, ListLink );
        HistoryListNext = HistoryListNext->Blink;
        if (History->Flags & CLE_ALLOCATED && !CLE_NO_POPUPS(History)) {
            PopupListHead = &History->PopupList;
            PopupListNext = PopupListHead->Blink;
            while (PopupListNext != PopupListHead) {
                Popup = CONTAINING_RECORD( PopupListNext, CLE_POPUP, ListLink );
                PopupListNext = PopupListNext->Blink;
                OldContents = Popup->OldContents;
                for (i=Popup->Region.Left;i<=Popup->Region.Right;i++) {
                    for (j=Popup->Region.Top;j<=Popup->Region.Bottom;j++) {
                        if (OldContents->Attributes == OldAttributes) {
                            OldContents->Attributes = NewAttributes;
                        } else if (OldContents->Attributes == OldPopupAttributes) {
                            OldContents->Attributes = NewPopupAttributes;
                        } else if (OldContents->Attributes == InvertedOldPopupAttributes) {
                            OldContents->Attributes = InvertedNewPopupAttributes;
                        }
                        OldContents++;
                    }
                }
            }
        }
    }
}


NTSTATUS
SetScreenColors(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Attributes,
    IN WORD PopupAttributes,
    IN BOOL UpdateWholeScreen
    )
{
    SHORT i,j;
    PROW Row;
    WORD DefaultAttributes,DefaultPopupAttributes;
    PCONSOLE_INFORMATION Console;
    COLORREF rgbBk;
    COLORREF rgbText;

    Console = ScreenInfo->Console;
    rgbBk = ConvertAttrToRGB(Console, LOBYTE(Attributes >> 4));
    rgbBk = GetNearestColor(Console->hDC, rgbBk);
    rgbText = ConvertAttrToRGB(Console, LOBYTE(Attributes));
    rgbText = GetNearestColor(Console->hDC, rgbText);
    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        SetDCBrushColor(Console->hDC, rgbBk);
        SetTextColor(Console->hDC, rgbText);
        SetBkColor(Console->hDC, rgbBk);
        Console->LastAttributes = Attributes;
        SetConsoleBkColor(Console->hWnd, rgbBk);
    }

    DefaultAttributes = ScreenInfo->Attributes;
    DefaultPopupAttributes = ScreenInfo->PopupAttributes;
    ScreenInfo->Attributes = Attributes;
    ScreenInfo->PopupAttributes = PopupAttributes;
#if defined(FE_IME)
    SetUndetermineAttribute( Console );
#endif

    if (UpdateWholeScreen && ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        WORD InvertedOldPopupAttributes,InvertedNewPopupAttributes;

        InvertedOldPopupAttributes = (WORD)(((DefaultPopupAttributes << 4) & 0xf0) |
                                    ((DefaultPopupAttributes >> 4) & 0x0f));
        InvertedNewPopupAttributes = (WORD)(((PopupAttributes << 4) & 0xf0) |
                                    ((PopupAttributes >> 4) & 0x0f));
        //
        // change all chars with default color
        //

        for (i=0;i<ScreenInfo->ScreenBufferSize.Y;i++) {
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[i];
            for (j=0;j<Row->AttrRow.Length;j++) {
                if (Row->AttrRow.Attrs[j].Attr == DefaultAttributes) {
                    Row->AttrRow.Attrs[j].Attr = Attributes;
                } else if (Row->AttrRow.Attrs[j].Attr == DefaultPopupAttributes) {
                    Row->AttrRow.Attrs[j].Attr = PopupAttributes;
                } else if (Row->AttrRow.Attrs[j].Attr == InvertedOldPopupAttributes) {
                    Row->AttrRow.Attrs[j].Attr = InvertedNewPopupAttributes;
                }
            }
        }

        if (Console->PopupCount)
            UpdatePopups(Console,
                         Attributes,
                         PopupAttributes,
                         DefaultAttributes,
                         DefaultPopupAttributes
                         );
        // force repaint of entire line
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        WriteToScreen(ScreenInfo,&ScreenInfo->Window);
        ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    }

    return STATUS_SUCCESS;
}

ULONG
SrvSetConsoleTextAttribute(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETTEXTATTRIBUTE_MSG a = (PCONSOLE_SETTEXTATTRIBUTE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        if (a->Attributes & ~VALID_TEXT_ATTRIBUTES) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = SetScreenColors(HandleData->Buffer.ScreenBuffer,
                                     a->Attributes,
                                     HandleData->Buffer.ScreenBuffer->PopupAttributes,
                                     FALSE
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETFONT_MSG a = (PCONSOLE_SETFONT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    try {
        Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                     a->OutputHandle,
                                     CONSOLE_OUTPUT_HANDLE,
                                     GENERIC_WRITE,
                                     &HandleData
                                    );
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
#if defined(FE_SB)
            Status = SetScreenBufferFont(ScreenInfo,a->FontIndex,ScreenInfo->Console->OutputCP);
#else
            Status = SetScreenBufferFont(ScreenInfo,a->FontIndex);
#endif
        }
    } finally {
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleIcon(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETICON_MSG a = (PCONSOLE_SETICON_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE hIcon;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->hIcon == NULL) {
        hIcon = ghDefaultIcon;
    } else {
        hIcon = CopyIcon(a->hIcon);
    }

    if (hIcon == NULL) {
        Status = STATUS_INVALID_PARAMETER;
    } else if (hIcon != Console->hIcon) {
        PostMessage(Console->hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        if (Console->hIcon != ghDefaultIcon) {
            DestroyIcon(Console->hIcon);
        }
        Console->hIcon = hIcon;

        /*
         * Small icon now
         */
        if (hIcon != ghDefaultIcon) {
            /*
             * The new one is not the default, clean-up
             */
            if (Console->hSmIcon != NULL && Console->hSmIcon != ghDefaultSmIcon) {
                DestroyIcon(Console->hSmIcon);
            }
            Console->hSmIcon = NULL;
            PostMessage(Console->hWnd, WM_SETICON, ICON_SMALL, (LPARAM)NULL);
        } else {
            /*
             * Change to default, so we can use the default small icon
             */
            if (Console->hSmIcon != ghDefaultSmIcon) {
                if (Console->hSmIcon != NULL) {
                    DestroyIcon(Console->hSmIcon);
                }
                Console->hSmIcon = ghDefaultSmIcon;
                PostMessage(Console->hWnd, WM_SETICON, ICON_SMALL, (LPARAM)ghDefaultSmIcon);
            }
        }
    }
    UnlockConsole(Console);

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}


ULONG
SrvSetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCP_MSG a = (PCONSOLE_SETCP_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE hEvent = NULL;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (a->hEvent) {
        Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                       a->hEvent,
                       NtCurrentProcess(),
                       &hEvent,
                       0,
                       FALSE,
                       DUPLICATE_SAME_ACCESS
                       );
        if (!NT_SUCCESS(Status)) {
            goto SrvSetConsoleCPFailure;
        }
    }

    if (!IsValidCodePage(a->wCodePageID)) {
        Status = STATUS_INVALID_PARAMETER;
        goto SrvSetConsoleCPFailure;
    }
    if ( IsAvailableFarEastCodePage( a->wCodePageID ) &&
         OEMCP != a->wCodePageID )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto SrvSetConsoleCPFailure;
    }

    if ( (a->Output && Console->OutputCP != a->wCodePageID) ||
         (!a->Output && Console->CP != a->wCodePageID)         ) {

        UINT CodePage;

        if (a->Output) {

            // Backup old code page
            CodePage = Console->OutputCP;

            // Set new code page
            Console->OutputCP = a->wCodePageID;

            Console->fIsDBCSOutputCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->OutputCP);

            if (!ReCreateDbcsScreenBuffer(Console, CodePage) ) {
                RIPMSG1(RIP_WARNING, "SrvSetConsoleCP: ReCreateDbcsScreenBuffer failed. Restoring to CP=%d",
                        CodePage);
                Console->OutputCP = CodePage;
                Console->fIsDBCSOutputCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(CodePage);
                Status = STATUS_NO_MEMORY;
                goto SrvSetConsoleCPFailure;
            }
            SetConsoleCPInfo(Console,a->Output);
            Status = QueueConsoleMessage(Console,
                        CM_SET_IME_CODEPAGE,
                        (WPARAM)hEvent,
                        MAKELPARAM(a->Output,CodePage)
                       );
            if (!NT_SUCCESS(Status)) {
                goto SrvSetConsoleCPFailure;
            }

            // load special ROM font, if necessary

#ifdef i386

            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
                SetROMFontCodePage(Console->OutputCP,
                                   Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex);
                WriteRegionToScreenHW(Console->CurrentScreenBuffer,
                        &Console->CurrentScreenBuffer->Window);
            }
#endif


        } else {

            // Backup old code page
            CodePage = Console->CP;

            // Set new code page
            Console->CP = a->wCodePageID;

            Console->fIsDBCSCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->CP);

            SetConsoleCPInfo(Console,a->Output);
            Status = QueueConsoleMessage(Console,
                        CM_SET_IME_CODEPAGE,
                        (WPARAM)hEvent,
                        MAKELPARAM(a->Output,CodePage)
                       );
            if (!NT_SUCCESS(Status)) {
                goto SrvSetConsoleCPFailure;
            }
        }
    }
    else {
        if (hEvent) {
            NtSetEvent(hEvent, NULL);
            NtClose(hEvent);
        }
    }

    UnlockConsole(Console);
    return STATUS_SUCCESS;

SrvSetConsoleCPFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }
    UnlockConsole(Console);
    return Status;

    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCP_MSG a = (PCONSOLE_GETCP_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (a->Output) {
        a->wCodePageID = Console->OutputCP;
    } else {
        a->wCodePageID = Console->CP;
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleKeyboardLayoutName(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG a = (PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Console->hklActive == NULL) {
        //
        // hklActive is not set yet. Let's initialize it here.
        //
        extern void GetNonBiDiKeyboardLayout(HKL * phklActive);

        RIPMSG1(RIP_WARNING, "SrvGetConsoleKeyboardLayoutName: hklActive is not initialized. pCon=%p", Console);

        SystemParametersInfo(SPI_GETDEFAULTINPUTLANG, 0, &Console->hklActive, FALSE);
        GetNonBiDiKeyboardLayout(&Console->hklActive);
    }
    ActivateKeyboardLayout(Console->hklActive, 0);
    if (a->bAnsi) {
        GetKeyboardLayoutNameA(a->achLayout);
    } else {
        GetKeyboardLayoutNameW(a->awchLayout);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}


ULONG
SrvGetConsoleWindow(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCONSOLEWINDOW_MSG a = (PCONSOLE_GETCONSOLEWINDOW_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    a->hwnd = Console->hWnd;

    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleProcessList(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_INFORMATION Console = NULL;
    NTSTATUS Status;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;
    PCONSOLE_GETCONSOLEPROCESSLIST_MSG a = (PCONSOLE_GETCONSOLEPROCESSLIST_MSG)&m->u.ApiMessageData;
    DWORD dwProcessCount = 0;
    LPDWORD lpdwProcessList;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (!CsrValidateMessageBuffer(m, &a->lpdwProcessList, a->dwProcessCount, sizeof(*a->lpdwProcessList))) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    lpdwProcessList = a->lpdwProcessList;

    /*
     * Run through the console's process list to determine if the user-supplied
     * buffer is big enough to contain them all. This is requires that we make
     * two passes over the data, but it allows this function to have the same
     * semantics as GetProcessHeaps().
     */
    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ++dwProcessCount;
        ListNext = ListNext->Flink;
    }

    /*
     * At this point we can't fail, so set the status accordingly.
     */
    Status = STATUS_SUCCESS;

    /*
     * There's not enough space in the array to hold all the pids, so we'll
     * inform the user of that by returning a number > than a->dwProcessCount
     * (but we still return STATUS_SUCCESS).
     */
    if (dwProcessCount > a->dwProcessCount) {
        goto Cleanup;
    }

    /*
     * Loop over the list of processes again and fill in the caller's buffer.
     */
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        *lpdwProcessList++ = HandleToUlong(ProcessHandleRecord->Process->ClientId.UniqueProcess);
        ListNext = ListNext->Flink;
    }

Cleanup:
    a->dwProcessCount = dwProcessCount;

    if (Console != NULL) {
        UnlockConsole(Console);
    }

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\find.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    find.c

Abstract:

        This file implements the search functionality.

Author:

    Jerry Shea (jerrysh) 1-May-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


USHORT
SearchForString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWSTR SearchString,
    IN USHORT StringLength,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN Reverse,
    IN BOOLEAN SearchAndSetAttr,
    IN ULONG Attr,
    OUT PCOORD StringPosition   // not touched for SearchAndSetAttr case.
    )
{
    PCONSOLE_INFORMATION Console;
    SMALL_RECT Rect;
    COORD MaxPosition;
    COORD EndPosition;
    COORD Position;
    BOOL RecomputeRow;
    SHORT RowIndex;
    PROW Row;
    USHORT ColumnWidth;
    WCHAR SearchString2[SEARCH_STRING_LENGTH * 2 + 1];    // search string buffer
    PWSTR pStr;

    Console = ScreenInfo->Console;

    MaxPosition.X = ScreenInfo->ScreenBufferSize.X - StringLength;
    MaxPosition.Y = ScreenInfo->ScreenBufferSize.Y - 1;

    //
    // calculate starting position
    //

    if (Console->Flags & CONSOLE_SELECTING) {
        Position.X = min(Console->SelectionAnchor.X, MaxPosition.X);
        Position.Y = Console->SelectionAnchor.Y;
    } else if (Reverse) {
        Position.X = 0;
        Position.Y = 0;
    } else {
        Position.X = MaxPosition.X;
        Position.Y = MaxPosition.Y;
    }

    //
    // prepare search string
    //
    // Raid #113599 CMD:Find(Japanese strings) does not work correctly
    //

    ASSERT(StringLength == wcslen(SearchString) && StringLength < ARRAY_SIZE(SearchString2));

    pStr = SearchString2;
    while (*SearchString) {
        *pStr++ = *SearchString;
#if defined(CON_TB_MARK)
        //
        // On the screen, one FarEast "FullWidth" character occupies two columns (double width),
        // so we have to share two screen buffer elements for one DBCS character.
        // For example, if the screen shows "AB[DBC]CD", the screen buffer will be,
        //   [L'A'] [L'B'] [DBC(Unicode)] [CON_TB_MARK] [L'C'] [L'D']
        //   (DBC:: Double Byte Character)
        // CON_TB_MARK is used to indicate that the column is the trainling byte.
        //
        // Before comparing the string with the screen buffer, we need to modify the search
        // string to match the format of the screen buffer.
        // If we find a FullWidth character in the search string, put CON_TB_MARK
        // right after it so that we're able to use NLS functions.
        //
#else
        //
        // If KAttribute is used, the above example will look like:
        // CharRow.Chars: [L'A'] [L'B'] [DBC(Unicode)] [DBC(Unicode)] [L'C'] [L'D']
        // CharRow.KAttrs:    0      0   LEADING_BYTE  TRAILING_BYTE       0      0
        //
        // We do no fixup if SearchAndSetAttr was specified.  In this case the search buffer has
        // come straight out of the console buffer,  so is already in the required format.
        //
#endif
        if (!SearchAndSetAttr && IsConsoleFullWidth(Console->hDC, Console->CP, *SearchString)) {
#if defined(CON_TB_MARK)
            *pStr++ = CON_TB_MARK;
#else
            *pStr++ = *SearchString;
#endif
        }
        ++SearchString;
    }

    *pStr = L'\0';
    ColumnWidth = (USHORT)(pStr - SearchString2);
    SearchString = SearchString2;

    //
    // set the string length in byte
    //

    StringLength = ColumnWidth * sizeof(WCHAR);

    //
    // search for the string
    //

    RecomputeRow = TRUE;
    EndPosition = Position;
    do {
#if !defined(CON_TB_MARK)
#if DBG
        int nLoop = 0;
#endif
recalc:
#endif
        if (Reverse) {
            if (--Position.X < 0) {
                Position.X = MaxPosition.X;
                if (--Position.Y < 0) {
                    Position.Y = MaxPosition.Y;
                }
                RecomputeRow = TRUE;
            }
        } else {
            if (++Position.X > MaxPosition.X) {
                Position.X = 0;
                if (++Position.Y > MaxPosition.Y) {
                    Position.Y = 0;
                }
                RecomputeRow = TRUE;
            }
        }
        if (RecomputeRow) {
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow + Position.Y) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            RecomputeRow = FALSE;
        }
#if !defined(CON_TB_MARK)
        ASSERT(nLoop++ < 2);
        if (Row->CharRow.KAttrs && (Row->CharRow.KAttrs[Position.X] & ATTR_TRAILING_BYTE)) {
            goto recalc;
        }
#endif
        if (!MyStringCompareW(SearchString, &Row->CharRow.Chars[Position.X], StringLength, IgnoreCase)) {

            //
            //  If this operation was a normal user find,  then return now.  Otherwise set
            //  the attributes of this match,  and continue searching the whole buffer.
            //

            if (!SearchAndSetAttr)  {
            
                *StringPosition = Position;
                return ColumnWidth;
            }
            else {

                Rect.Top = Rect.Bottom = Position.Y;
                Rect.Left = Position.X;
                Rect.Right = Rect.Left + ColumnWidth - 1;

                ColorSelection( Console, &Rect, Attr);
            }
        }
    } 
    while (!((Position.X == EndPosition.X) && (Position.Y == EndPosition.Y)));

    return 0;   // the string was not found
}

INT_PTR
FindDialogProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCONSOLE_INFORMATION Console;
    PSCREEN_INFORMATION ScreenInfo;
    USHORT StringLength;
    USHORT ColumnWidth;
    WCHAR szBuf[SEARCH_STRING_LENGTH + 1];
    COORD Position;
    BOOLEAN IgnoreCase;
    BOOLEAN Reverse;

    switch (Message) {
    case WM_INITDIALOG:
        SetWindowLongPtr(hWnd, DWLP_USER, lParam);
        SendDlgItemMessage(hWnd, ID_FINDSTR, EM_LIMITTEXT, ARRAY_SIZE(szBuf)-1, 0);
        CheckRadioButton(hWnd, ID_FINDUP, ID_FINDDOWN, ID_FINDDOWN);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            StringLength = (USHORT)GetDlgItemText(hWnd, ID_FINDSTR, szBuf, ARRAY_SIZE(szBuf));
            if (StringLength == 0) {
                break;
            }
            IgnoreCase = IsDlgButtonChecked(hWnd, ID_FINDCASE) == 0;
            Reverse = IsDlgButtonChecked(hWnd, ID_FINDDOWN) == 0;
            Console = (PCONSOLE_INFORMATION)GetWindowLongPtr(hWnd, DWLP_USER);
            ScreenInfo = Console->CurrentScreenBuffer;
            
            ColumnWidth = SearchForString( ScreenInfo, 
                                           szBuf, 
                                           StringLength, 
                                           IgnoreCase, 
                                           Reverse,
                                           FALSE,
                                           0,
                                           &Position);
            if (ColumnWidth != 0) {

                //
                // Clear any old selections
                //

                if (Console->Flags & CONSOLE_SELECTING) {
                    ClearSelection(Console);
                }

                //
                // Make the new selection
                //

                Console->Flags |= CONSOLE_SELECTING;
                Console->SelectionFlags = CONSOLE_MOUSE_SELECTION | CONSOLE_SELECTION_NOT_EMPTY;
                InitializeMouseSelection(Console, Position);
                Console->SelectionRect.Right = Console->SelectionRect.Left + ColumnWidth - 1;
                MyInvert(Console,&Console->SelectionRect);
                SetWinText(Console,msgSelectMode,TRUE);

                //
                // Make sure the hilited text will be visible
                //

                if (Console->SelectionRect.Left < ScreenInfo->Window.Left) {
                    Position.X = Console->SelectionRect.Left;
                } else if (Console->SelectionRect.Right > ScreenInfo->Window.Right) {
                    Position.X = Console->SelectionRect.Right - CONSOLE_WINDOW_SIZE_X(ScreenInfo) + 1;
                } else {
                    Position.X = ScreenInfo->Window.Left;
                }
                if (Console->SelectionRect.Top < ScreenInfo->Window.Top) {
                    Position.Y = Console->SelectionRect.Top;
                } else if (Console->SelectionRect.Bottom > ScreenInfo->Window.Bottom) {
                    Position.Y = Console->SelectionRect.Bottom - CONSOLE_WINDOW_SIZE_Y(ScreenInfo) + 1;
                } else {
                    Position.Y = ScreenInfo->Window.Top;
                }
                SetWindowOrigin(ScreenInfo, TRUE, Position);
                return TRUE;
            } else {

                //
                // The string wasn't found
                //

                Beep(800, 200);
            }
            break;
        case IDCANCEL:
            EndDialog(hWnd, 0);
            return TRUE;
        }
        break;
    default:
        break;
    }
    return FALSE;
}

VOID
DoFind(
   IN PCONSOLE_INFORMATION Console)
{
    ++DialogBoxCount;
    DialogBoxParam(ghInstance,
                   MAKEINTRESOURCE(ID_FINDDLG),
                   Console->hWnd,
                   FindDialogProc,
                   (LPARAM)Console);
    --DialogBoxCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\dispatch.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define WWSB_NOFE
#include "dispatch.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "dispatch.h"
#undef  WWSB_FE

#if defined(FE_SB)


NTSTATUS
DoSrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_DoSrvWriteConsole(m,ReplyStatus,Console,HandleData);
    else
        return SB_DoSrvWriteConsole(m,ReplyStatus,Console,HandleData);
}

NTSTATUS
WriteOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PVOID Buffer,
    IN COORD WriteCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords, // this value is valid even for error cases
    OUT PULONG NumColumns OPTIONAL
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_WriteOutputString(ScreenInfo, Buffer, WriteCoord, StringType, NumRecords, NumColumns);
    else
        return SB_WriteOutputString(ScreenInfo, Buffer, WriteCoord, StringType, NumRecords, NumColumns);
}


VOID
WriteRectToScreenBuffer(
    PBYTE Source,
    COORD SourceSize,
    PSMALL_RECT SourceRect,
    PSCREEN_INFORMATION ScreenInfo,
    COORD TargetPoint,
    IN UINT Codepage
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_WriteRectToScreenBuffer(Source,SourceSize,SourceRect,ScreenInfo,TargetPoint,Codepage);
    else
        SB_WriteRectToScreenBuffer(Source,SourceSize,SourceRect,ScreenInfo,TargetPoint,Codepage);
}

VOID
WriteToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    PSMALL_RECT Region    // region is inclusive
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_WriteToScreen(ScreenInfo, Region);
    else
        SB_WriteToScreen(ScreenInfo, Region);
}

VOID
WriteRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_WriteRegionToScreen(ScreenInfo, Region);
    else
        SB_WriteRegionToScreen(ScreenInfo, Region);
}

NTSTATUS
FillOutput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Element,
    IN COORD WriteCoord,
    IN ULONG ElementType,
    IN OUT PULONG Length // this value is valid even for error cases
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_FillOutput(ScreenInfo, Element, WriteCoord, ElementType, Length);
    else
        return SB_FillOutput(ScreenInfo, Element, WriteCoord, ElementType, Length);
}

VOID
FillRectangle(
    IN CHAR_INFO Fill,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT TargetRect
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_FillRectangle(Fill, ScreenInfo, TargetRect);
    else
        SB_FillRectangle(Fill, ScreenInfo, TargetRect);
}


ULONG
DoWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN PCONSOLE_INFORMATION Console,
    IN PCSR_THREAD Thread
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_DoWriteConsole(m,Console,Thread);
    else
        return SB_DoWriteConsole(m,Console,Thread);
}


NTSTATUS
WriteChars(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpRealUnicodeString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_WriteChars(ScreenInfo,lpBufferBackupLimit,lpBuffer,lpRealUnicodeString,NumBytes,NumSpaces,OriginalXPosition,dwFlags,ScrollY);
    else
        return SB_WriteChars(ScreenInfo,lpBufferBackupLimit,lpBuffer,lpRealUnicodeString,NumBytes,NumSpaces,OriginalXPosition,dwFlags,ScrollY);
}



NTSTATUS
AdjustCursorPosition(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_AdjustCursorPosition(ScreenInfo, CursorPosition, KeepCursorVisible, ScrollY);
    else
        return SB_AdjustCursorPosition(ScreenInfo, CursorPosition, KeepCursorVisible, ScrollY);
}

NTSTATUS
TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToAnsiUnicode(Console,OutputBuffer,Size,OutputBufferR);
    else
        return SB_TranslateOutputToAnsiUnicode(Console,OutputBuffer,Size);
}

NTSTATUS
TranslateOutputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size)
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToUnicode(Console,OutputBuffer,Size);
    else
        return SB_TranslateOutputToUnicode(Console,OutputBuffer,Size);
}

NTSTATUS
TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToOemUnicode(Console,OutputBuffer,Size,fRemoveDbcsMark);
    else
        return SB_TranslateOutputToOemUnicode(Console,OutputBuffer,Size);
}

NTSTATUS
TranslateOutputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToOem(Console,OutputBuffer,Size);
    else
        return SB_TranslateOutputToOem(Console,OutputBuffer,Size);
}

ULONG
TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    )
{
    if (CONSOLE_IS_DBCS_CP(Console))
        return FE_TranslateInputToUnicode(Console,InputRecords,NumRecords,DBCSLeadByte);
    else
        return SB_TranslateInputToUnicode(Console,InputRecords,NumRecords);
}

ULONG
TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    )
{
    if (CONSOLE_IS_DBCS_CP(Console))
        return FE_TranslateInputToOem(Console,InputRecords,NumRecords,UnicodeLength,DbcsLeadInpRec);
    else
        return SB_TranslateInputToOem(Console,InputRecords,NumRecords);
}

WCHAR
CharToWchar(
    IN PCONSOLE_INFORMATION Console,
    IN UINT Codepage,
    IN char *Ch
    )
{
    WCHAR wc;
    if (CONSOLE_IS_DBCS_CP(Console))
    {
        if (IsDBCSLeadByteConsole(*Ch, &Console->OutputCPInfo))
        {
            ConvertOutputToUnicode(Console->OutputCP,
                                   Ch,
                                   2,
                                   &wc,
                                   1);
        }
        else
        {
            ConvertOutputToUnicode(Console->OutputCP,
                                   Ch,
                                   1,
                                   &wc,
                                   1);
        }
    }
    else
    {
        wc = SB_CharToWchar(Codepage, *Ch);
    }
    return wc;
}


#ifdef i386
VOID
WriteRegionToScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        FE_WriteRegionToScreenHW(ScreenInfo,Region);
    else
        SB_WriteRegionToScreenHW(ScreenInfo,Region);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\dispatch.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/


#undef WWSB
#if defined(WWSB_NOFE)
  #define WWSB(fn) SB_##fn
#elif defined(WWSB_FE)
  #define WWSB(fn) FE_##fn
#else
  #define WWSB(fn) fn
#endif

NTSTATUS
WWSB(DoSrvWriteConsole)(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData
    );


NTSTATUS
WWSB(WriteOutputString)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PVOID Buffer,
    IN COORD WriteCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords, // this value is valid even for error cases
    OUT PULONG NumColumns OPTIONAL
    );


VOID
WWSB(WriteRectToScreenBuffer)(
    PBYTE Source,
    COORD SourceSize,
    PSMALL_RECT SourceRect,
    PSCREEN_INFORMATION ScreenInfo,
    COORD TargetPoint,
    IN UINT Codepage
    );


VOID
WWSB(WriteToScreen)(
    IN PSCREEN_INFORMATION ScreenInfo,
    PSMALL_RECT Region    // region is inclusive
    );


VOID
WWSB(WriteRegionToScreen)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );


NTSTATUS
WWSB(FillOutput)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Element,
    IN COORD WriteCoord,
    IN ULONG ElementType,
    IN OUT PULONG Length // this value is valid even for error cases
    );


VOID
WWSB(FillRectangle)(
    IN CHAR_INFO Fill,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT TargetRect
    );


ULONG
WWSB(DoWriteConsole)(
    IN OUT PCSR_API_MSG m,
    IN PCONSOLE_INFORMATION Console,
    IN PCSR_THREAD Thread
    );


NTSTATUS
WWSB(WriteChars)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpRealUnicodeString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    );


NTSTATUS
WWSB(AdjustCursorPosition)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    );


NTSTATUS
TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    );
NTSTATUS
FE_TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    );
NTSTATUS
SB_TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    );


NTSTATUS
WWSB(TranslateOutputToUnicode)(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size);


NTSTATUS
TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    );
NTSTATUS
FE_TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    );
NTSTATUS
SB_TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    );


NTSTATUS
WWSB(TranslateOutputToOem)(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    );


ULONG
TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    );
ULONG
FE_TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    );
ULONG
SB_TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    );


ULONG
TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    );
ULONG
FE_TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    );
ULONG
SB_TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    );


#ifdef i386
VOID
WWSB(WriteRegionToScreenHW)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );
#endif


VOID
StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo
    );
VOID
FE_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    );
VOID
SB_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo
    );

/*
 * SB/FE neutral defines for use from _stream.h and _output.h
 *
 * Each of these functions appears in dispatch.c, but we don't want SB_ or FE_
 * routines to call the dispatching subroutines, we want to call the SB_ or FE_
 * subroutines directly.  eg: There should be no calls to WriteChars from
 * anywhere in _stream.h : instead, we should call WWSB_WriteChars (etc.)
 */
#if defined(WWSB_NOFE)
  #define WWSB_WriteChars            SB_WriteChars
  #define WWSB_AdjustCursorPosition  SB_AdjustCursorPosition
  #define WWSB_DoWriteConsole        SB_DoWriteConsole
  #define WWSB_DoSrvWriteConsole     SB_DoSrvWriteConsole
  #define WWSB_WriteToScreen         SB_WriteToScreen
  #define WWSB_WriteOutputString     SB_WriteOutputString
  #define WWSB_FillOutput            SB_FillOutput
  #define WWSB_FillRectangle         SB_FillRectangle
  #define WWSB_PolyTextOutCandidate  SB_PolyTextOutCandidate
  #define WWSB_ConsolePolyTextOut    SB_ConsolePolyTextOut
  #define WWSB_WriteRegionToScreen   SB_WriteRegionToScreen
  #define WWSB_WriteRegionToScreenHW SB_WriteRegionToScreenHW
  #define WWSB_WriteRectToScreenBuffer SB_WriteRectToScreenBuffer
#endif

#if defined(WWSB_FE)
  #undef  WWSB_WriteChars
  #define WWSB_WriteChars            FE_WriteChars
  #undef  WWSB_AdjustCursorPosition
  #define WWSB_AdjustCursorPosition  FE_AdjustCursorPosition
  #undef  WWSB_DoWriteConsole
  #define WWSB_DoWriteConsole        FE_DoWriteConsole
  #undef  WWSB_DoSrvWriteConsole
  #define WWSB_DoSrvWriteConsole     FE_DoSrvWriteConsole
  #undef  WWSB_WriteToScreen
  #define WWSB_WriteToScreen         FE_WriteToScreen
  #undef  WWSB_WriteOutputString
  #define WWSB_WriteOutputString     FE_WriteOutputString
  #undef  WWSB_FillOutput
  #define WWSB_FillOutput            FE_FillOutput
  #undef  WWSB_FillRectangle
  #define WWSB_FillRectangle         FE_FillRectangle
  #undef  WWSB_PolyTextOutCandidate
  #define WWSB_PolyTextOutCandidate  FE_PolyTextOutCandidate
  #undef  WWSB_ConsolePolyTextOut
  #define WWSB_ConsolePolyTextOut    FE_ConsolePolyTextOut
  #undef  WWSB_WriteRegionToScreen
  #define WWSB_WriteRegionToScreen   FE_WriteRegionToScreen
  #undef  WWSB_WriteRegionToScreenHW
  #define WWSB_WriteRegionToScreenHW FE_WriteRegionToScreenHW
  #undef  WWSB_WriteRectToScreenBuffer
  #define WWSB_WriteRectToScreenBuffer FE_WriteRectToScreenBuffer
#endif

/*
 * define WWSB_NEUTRAL_FILE in _stream.h _output.h and _priv.h
 * This will guard against calling the dispatching versions when we can just
 * call the underlying FE_ or SB_ routine directly.
 */
#ifdef WWSB_NEUTRAL_FILE
  #define WriteChars                 Should_not_call_WriteChars
  #define AdjustCursorPosition       Should_not_call_AdjustCursorPosition
  #define DoWriteConsole             Should_not_call_DoWriteConsole
  #define DoSrvWriteConsole          Should_not_call_DoSrvWriteConsole
  #define WriteToScreen              Should_not_call_WriteToScreen
  #define WriteOutputString          Should_not_call_WriteOutputString
  #define FillOutput                 Should_not_call_FillOutput
  #define FillRectangle              Should_not_call_FillRectangle
  #define PolyTextOutCandidate       Should_not_call_PolyTextOutCandidate
  #define ConsolePolyTextOut         Should_not_call_ConsolePolyTextOut
  #define WriteRegionToScreen        Should_not_call_WriteRegionToScreen
  #define WriteRegionToScreenHW      Should_not_call_WriteRegionToScreenHW
  #define WriteRectToScreenBuffer    Should_not_call_WriteRectToScreenBuffer
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\foncache.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    foncache.c

Abstract:

        This file is EUDC font cache

Author:

    Kazuhiko  Matsubara  21-June-1994

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_SB)


VOID
RebaseFontImageList(
    IN PFONT_IMAGE NewFontImage,
    IN PBYTE OldFontImage
    )
{
    PLIST_ENTRY ImageList;
    PBYTE BaseImage = (PBYTE)NewFontImage;

    do {
        ImageList = &NewFontImage->ImageList;
        if (ImageList->Blink)
            ImageList->Blink = (PLIST_ENTRY)((PBYTE)ImageList->Blink - OldFontImage + BaseImage);
        if (ImageList->Flink)
            ImageList->Flink = (PLIST_ENTRY)((PBYTE)ImageList->Flink - OldFontImage + BaseImage);
    } while (NewFontImage = (PFONT_IMAGE)ImageList->Flink);
}





ULONG
CreateFontCache(
    OUT PFONT_CACHE_INFORMATION *FontCache
    )
{
    //
    // allocate font cache data
    //

    *FontCache = ConsoleHeapAlloc(HEAP_ZERO_MEMORY,sizeof(FONT_CACHE_INFORMATION));
    if (*FontCache == NULL) {
        return (ULONG)STATUS_NO_MEMORY;
    }

    return (ULONG)(STATUS_SUCCESS);
}


ULONG
DestroyFontCache(
    IN PFONT_CACHE_INFORMATION FontCache
    )
{
    if (FontCache != NULL)
    {
        PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
        PFONT_LOW_OFFSET     FontOffsetLow;
        PFONT_IMAGE          FontImage;
        UINT i, j, k;

        for (i=0;
             i < sizeof(FontCache->FontTable.FontOffsetHighHigh)/sizeof(PFONT_HIGHLOW_OFFSET);
             i++)
        {
            if (FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[i])
            {
                for (j=0;
                     j < sizeof(FontOffsetHighLow->FontOffsetHighLow)/sizeof(PFONT_LOW_OFFSET);
                     j++)
                {
                    if (FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[j])
                    {
                        for (k=0;
                             k < sizeof(FontOffsetLow->FontOffsetLow)/sizeof(PFONT_IMAGE);
                             k++)
                        {
                            if (FontImage = FontOffsetLow->FontOffsetLow[k])
                            {
                                ConsoleHeapFree(FontImage);
                            }
                        }
                        ConsoleHeapFree(FontOffsetLow);
                    }
                }
                ConsoleHeapFree(FontOffsetHighLow);
            }
        }
        if (FontCache->BaseImageBits) {
            ConsoleHeapFree(FontCache->BaseImageBits);
        }
        ConsoleHeapFree(FontCache);
    }
    return (ULONG)(STATUS_SUCCESS);
}

ULONG
RebaseFontCache(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN PBYTE OldBaseImage
    )
{
    if (FontCache != NULL)
    {
        PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
        PFONT_LOW_OFFSET     FontOffsetLow;
        PFONT_IMAGE          FontImage;
        UINT i, j, k;

        for (i=0;
             i < sizeof(FontCache->FontTable.FontOffsetHighHigh)/sizeof(PFONT_HIGHLOW_OFFSET);
             i++)
        {
            if (FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[i])
            {
                for (j=0;
                     j < sizeof(FontOffsetHighLow->FontOffsetHighLow)/sizeof(PFONT_LOW_OFFSET);
                     j++)
                {
                    if (FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[j])
                    {
                        for (k=0;
                             k < sizeof(FontOffsetLow->FontOffsetLow)/sizeof(PFONT_IMAGE);
                             k++)
                        {
                            if (FontImage = FontOffsetLow->FontOffsetLow[k])
                            {
                                LIST_ENTRY ImageList;

                                do {
                                    ImageList = FontImage->ImageList;
                                    if (FontImage->ImageBits) {
                                        FontImage->ImageBits = FontImage->ImageBits - OldBaseImage
                                                               + FontCache->BaseImageBits;
                                    }
                                } while (FontImage = (PFONT_IMAGE)ImageList.Flink);
                            }
                        }
                    }
                }
            }
        }
    }
    return (ULONG)(STATUS_SUCCESS);
}



#define CALC_BITMAP_BITS_FOR_X( FontSizeX, dwAlign ) \
    ( ( ( FontSizeX * BITMAP_BITS_PIXEL + (dwAlign-1) ) & ~(dwAlign-1)) >> BITMAP_ARRAY_BYTE )




DWORD
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN DWORD dwAlign
    )
{
    DWORD uiCount;

    uiCount = CALC_BITMAP_BITS_FOR_X(FontSize.X,
                                     (dwAlign==BYTE_ALIGN ? BITMAP_BITS_BYTE_ALIGN : BITMAP_BITS_WORD_ALIGN));
    uiCount = uiCount * BITMAP_PLANES * FontSize.Y;
    return uiCount;
}

VOID
AlignCopyMemory(
    OUT PBYTE pDestBits,
    IN DWORD dwDestAlign,
    IN PBYTE pSrcBits,
    IN DWORD dwSrcAlign,
    IN COORD FontSize
    )
{
    DWORD dwDestBufferSize;
    COORD coord;

    if (dwDestAlign == dwSrcAlign) {
        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
        return;
    }

    switch (dwDestAlign) {
        default:
        case WORD_ALIGN:
            switch (dwSrcAlign) {
                default:
                //
                // pDest = WORD, pSrc = WORD
                //
                case WORD_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    break;
                //
                // pDest = WORD, pSrc = BYTE
                //
                case BYTE_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                        ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    }
                    else {
                        RtlZeroMemory(pDestBits, dwDestBufferSize);
                        for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                            for (coord.X=0;
                                 coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                 coord.X++) {
                                *pDestBits++ = *pSrcBits++;
                            }
                            if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                pDestBits++;
                        }
                    }
                    break;
            }
            break;
        case BYTE_ALIGN:
            switch (dwSrcAlign) {
                //
                // pDest = BYTE, pSrc = BYTE
                //
                case BYTE_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    break;
                default:
                //
                // pDest = BYTE, pSrc = WORD
                //
                case WORD_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                        ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    }
                    else {
                        RtlZeroMemory(pDestBits, dwDestBufferSize);
                        for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                            for (coord.X=0;
                                 coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                 coord.X++) {
                                *pDestBits++ = *pSrcBits++;
                            }
                            if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                pSrcBits++;
                        }
                    }
                    break;
            }
            break;
    }
}



NTSTATUS
GetStretchImage(
    IN COORD FontSize,
    IN PFONT_IMAGE FontImage,
    OUT PFONT_IMAGE *pFontImage
    )
{
    PFONT_IMAGE NearFont;
    DWORD Find;
    COORD FontDelta;
    HDC hDC;
    HDC hSrcMemDC, hDestMemDC;
    HBITMAP hSrcBmp, hDestBmp;
    DWORD BufferSize;
    NTSTATUS Status = STATUS_NO_MEMORY;

    Find = (DWORD)-1;
    NearFont = NULL;
    do {
        FontDelta.X = (SHORT) abs(FontSize.X - FontImage->FontSize.X);
        FontDelta.Y = (SHORT) abs(FontSize.Y - FontImage->FontSize.Y);
        if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
        {
            Find = (DWORD)(FontDelta.X + FontDelta.Y);
            NearFont = FontImage;
        }
    }
    while (FontImage = (PFONT_IMAGE)FontImage->ImageList.Flink);

    if (NearFont == NULL)
        return STATUS_ACCESS_DENIED;

    if ((hDC = CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)) != NULL) {
        hSrcMemDC  = CreateCompatibleDC(hDC);
        hDestMemDC = CreateCompatibleDC(hDC);

        hSrcBmp  = CreateBitmap(NearFont->FontSize.X,
                                NearFont->FontSize.Y,
                                BITMAP_PLANES, BITMAP_BITS_PIXEL,
                                NearFont->ImageBits);
        hDestBmp = CreateBitmap(FontSize.X,
                                FontSize.Y,
                                BITMAP_PLANES, BITMAP_BITS_PIXEL,
                                NULL);
        if (hSrcMemDC && hSrcBmp && hDestMemDC && hDestBmp) {
            SelectObject(hSrcMemDC,  hSrcBmp);
            SelectObject(hDestMemDC, hDestBmp);

            if (! StretchBlt(hDestMemDC, 0, 0, FontSize.X, FontSize.Y,
                             hSrcMemDC,  0, 0, NearFont->FontSize.X, NearFont->FontSize.Y,
                             SRCCOPY)) {
                Status = GetLastError();
            } else {
                BufferSize = CalcBitmapBufferSize(FontSize, WORD_ALIGN);
                GetBitmapBits(hDestBmp, BufferSize, (*pFontImage)->ImageBits);
                Status = STATUS_SUCCESS;
            }
        }

        if (hSrcMemDC) {
            DeleteDC(hSrcMemDC);
        }
        if (hDestMemDC) {
            DeleteDC(hDestMemDC);
        }
        if (hSrcBmp) {
            DeleteObject(hSrcBmp);
        }
        if (hDestBmp) {
            DeleteObject(hDestBmp);
        }
        DeleteDC(hDC);
    }

    return Status;
}



NTSTATUS
GetFontImageInternal(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    OUT PFONT_IMAGE *pFontImage,
    IN DWORD GetFlag
    )
{
    PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
    PFONT_LOW_OFFSET     FontOffsetLow;
    PFONT_IMAGE          FontImage;
    WORD  HighHighIndex, HighLowIndex;
    WORD  LowIndex;
    DWORD Flag;

    HighHighIndex = (HIBYTE(wChar)) >> 4;
    HighLowIndex  = (HIBYTE(wChar)) & 0x0f;
    LowIndex      = LOBYTE(wChar);

    FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[HighHighIndex];
    if (FontOffsetHighLow == NULL)
        return STATUS_ACCESS_DENIED;

    FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[HighLowIndex];
    if (FontOffsetLow == NULL)
        return STATUS_ACCESS_DENIED;

    FontImage = FontOffsetLow->FontOffsetLow[LowIndex];
    if (FontImage == NULL)
        return STATUS_ACCESS_DENIED;


    Flag = ADD_IMAGE;
    do {
        if (FontImage->FontSize.X == FontSize.X &&
            FontImage->FontSize.Y == FontSize.Y   ) {
            //
            // Replace font image
            //
            Flag = REPLACE_IMAGE;
            break;
        }
    }
    while (FontImage = (PFONT_IMAGE)FontImage->ImageList.Flink);

    switch (GetFlag)
    {
        //
        // Get matched size font.
        //
        case FONT_MATCHED:
            if (Flag != REPLACE_IMAGE)
                return STATUS_ACCESS_DENIED;

            *pFontImage = FontImage;
            break;

        //
        // Get stretched size font.
        //
        case FONT_STRETCHED:
            if (Flag == REPLACE_IMAGE &&
                FontImage->ImageBits != NULL) {

                *pFontImage = FontImage;

            }
            else {
                GetStretchImage(FontSize,
                                FontOffsetLow->FontOffsetLow[LowIndex],
                                pFontImage
                               );
            }
            break;
    }

    return STATUS_SUCCESS;
}

//
// See Raid #362907, stress failure
//

VOID UnlinkAndShrinkFontImagesByOne(
    PFONT_IMAGE* ppFontImage,
    PFONT_IMAGE pFontImageRemove)
{
    PFONT_IMAGE OldFontImage = *ppFontImage;
    SIZE_T OldFontSize = ConsoleHeapSize(OldFontImage);
    PFONT_IMAGE NewFontImage;

    RIPMSG0(RIP_WARNING, "UnlinkAndShrinkFontImagesByOne entered.");

    if (OldFontImage== NULL) {
        RIPMSG0(RIP_ERROR, "UnlinkAndShrinkFontImagesByOne: *ppFontImage is NULL.");
        //
        // There's nothing to shrink.
        //
        return;
    }

    if (OldFontImage == pFontImageRemove) {
        RIPMSG0(RIP_WARNING, "UnlinkAndShrinkFontImagesByOne: unshrinking just one element.");
        //
        // There's just one entry. Let's free it and set
        // ppFontImage as NULL, and bail out.
        //
        UserAssert(OldFontSize < sizeof(FONT_IMAGE) * 2);

        *ppFontImage = NULL;
        ConsoleHeapFree(OldFontImage);
        return;
    }

#if DBG
    //
    // Double check the integrity of the linked list.
    //
    {
        PFONT_IMAGE FontImageTmp;

        //
        // Search the tail element
        //
        for (FontImageTmp = OldFontImage; FontImageTmp->ImageList.Flink; FontImageTmp = (PFONT_IMAGE)FontImageTmp->ImageList.Flink)
            ;

        UserAssert(FontImageTmp == pFontImageRemove);
    }
#endif

    //
    // Remove the tail element
    //
    pFontImageRemove->ImageList.Blink->Flink = NULL;

    //
    // Shrink the contiguous memory chunk
    //
    // Note: this code assumes sizeof(FONT_IMAGE) is larger than
    // HEAP_GRANULARITY. If not, the heap block actually does not
    // shrink, and the assert below will hit.
    //
    NewFontImage = ConsoleHeapReAlloc(HEAP_ZERO_MEMORY,
                               OldFontImage,
                               OldFontSize - sizeof(FONT_IMAGE));
    if (NewFontImage == NULL) {
        //
        // Win32HeapRealloc firstly allocates a new memory and then
        // copies the content. If the allocation fails, it leaves the
        // original heap as is.
        //
        // Even though the realloc fails, the last element (pFontImageRemove) is
        // already removed from the linked list. The next time SetImageFontInternal
        // is called, a new FontImage might be added to this memory chunk, but the
        // the code always links the newly extended memory.
        // This leaves the sizeof(FONT_IMAGE) memory unused, but it's safe. Assuming
        // sizeof(FONT_IMAGE) is small, memory waste should be minimum.
        //
        // It's OK for us to just bail out here.
        //
        RIPMSG0(RIP_WARNING, "UnlinkAndShrinkFontImagesByOne: failed to shrink ppFontImage.");
        return;
    }
    UserAssert(ConsoleHeapSize(NewFontImage) != OldFontSize);

    if (NewFontImage != OldFontImage) {
        //
        // Rebase Font Image Linked List
        //
        RebaseFontImageList(NewFontImage, (PBYTE)OldFontImage);
        *ppFontImage = NewFontImage;
    }
}

NTSTATUS
SetFontImageInternal(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    IN CONST VOID *ImageBits
    )
{
    PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
    PFONT_LOW_OFFSET     FontOffsetLow;
    PFONT_IMAGE          FontImage;
    PFONT_IMAGE          FontImageTmp;
    WORD  HighHighIndex, HighLowIndex;
    WORD  LowIndex;
    DWORD Flag;
    DWORD BufferSize;

    HighHighIndex = (HIBYTE(wChar)) >> 4;
    HighLowIndex  = (HIBYTE(wChar)) & 0x0f;
    LowIndex      = LOBYTE(wChar);

    /*
     * When Console is being destroyed, all font cache information
     * will be freed (see DestroyFontCache), so no memory leak
     * is expected on those, even if we cleanup everything on
     * error return...
     */

    FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[HighHighIndex];
    if (FontOffsetHighLow == NULL) {
        FontOffsetHighLow = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, sizeof(FONT_HIGHLOW_OFFSET));
        if (FontOffsetHighLow == NULL) {
            RIPMSG1(RIP_WARNING, "SetFontImageInternal: cannot allocate memory (%d bytes)",
                      sizeof(FONT_HIGHLOW_OFFSET));
            return STATUS_NO_MEMORY;
        }

        FontCache->FontTable.FontOffsetHighHigh[HighHighIndex] = FontOffsetHighLow;
    }

    FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[HighLowIndex];
    if (FontOffsetLow == NULL) {
        FontOffsetLow = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, sizeof(FONT_LOW_OFFSET));
        if (FontOffsetLow == NULL) {
            RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate FontOffsetLow.");
            return STATUS_NO_MEMORY;
        }

        FontOffsetHighLow->FontOffsetHighLow[HighLowIndex] = FontOffsetLow;
    }

    FontImage = FontOffsetLow->FontOffsetLow[LowIndex];
    if (FontImage == NULL) {
        FontImage = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, sizeof(FONT_IMAGE));
        if (FontImage == NULL) {
            RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate FontImage");
            return STATUS_NO_MEMORY;
        }
    }

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        //
        // Reset registered font
        //
        if (FontImage != NULL)
        {
            ConsoleHeapFree(FontImage);
            FontOffsetLow->FontOffsetLow[LowIndex] = NULL;
        }
        return STATUS_SUCCESS;
    }

    Flag = ADD_IMAGE;
    FontImageTmp = FontImage;
    do {
        if (FontImageTmp->FontSize.X == FontSize.X &&
            FontImageTmp->FontSize.Y == FontSize.Y   ) {
            //
            // Replace font image
            //
            Flag = REPLACE_IMAGE;
            FontImage = FontImageTmp;
            break;
        }
    }
    while (FontImageTmp = (PFONT_IMAGE)FontImageTmp->ImageList.Flink);

    switch (Flag) {
        case ADD_IMAGE:
            if (FontOffsetLow->FontOffsetLow[LowIndex] != NULL)
            {
                PFONT_IMAGE OldFontImage = FontOffsetLow->FontOffsetLow[LowIndex];
                SIZE_T OldFontSize = ConsoleHeapSize(OldFontImage);
                PFONT_IMAGE NewFontImage;

                NewFontImage = ConsoleHeapReAlloc(HEAP_ZERO_MEMORY,
                                           OldFontImage,
                                           OldFontSize + sizeof(FONT_IMAGE));
                if (NewFontImage == NULL) {
                    RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate NewFontImage");
                    return STATUS_NO_MEMORY;
                }

                FontOffsetLow->FontOffsetLow[LowIndex] = NewFontImage;

                // Rebase Font Image List
                RebaseFontImageList(NewFontImage, (PBYTE)OldFontImage);

                NewFontImage = (PFONT_IMAGE)((PBYTE)NewFontImage + OldFontSize);

                NewFontImage->FontSize = FontSize;

                //
                // Connect link list.
                //
                (NewFontImage-1)->ImageList.Flink = (PLIST_ENTRY)NewFontImage;
                NewFontImage->ImageList.Blink = (PLIST_ENTRY)(NewFontImage-1);

                FontImage = NewFontImage;
            }
            else
            {
                FontImage->FontSize = FontSize;
                FontOffsetLow->FontOffsetLow[LowIndex] = FontImage;
            }

            //
            // Allocate Image Buffer
            //
            BufferSize = CalcBitmapBufferSize(FontSize,WORD_ALIGN);

            if (FontCache->BaseImageBits == NULL)
            {
                FontCache->BaseImageBits = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, BufferSize);
                if (FontCache->BaseImageBits == NULL) {
                    RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate FontCache->BaseImageBits");
                    UnlinkAndShrinkFontImagesByOne(&FontOffsetLow->FontOffsetLow[LowIndex], FontImage);
                    return STATUS_NO_MEMORY;
                }

                FontImage->ImageBits = FontCache->BaseImageBits;
            }
            else
            {
                PBYTE OldBaseImage = FontCache->BaseImageBits;
                SIZE_T OldImageSize = ConsoleHeapSize(OldBaseImage);
                FontCache->BaseImageBits = ConsoleHeapReAlloc(HEAP_ZERO_MEMORY,
                                                       OldBaseImage,
                                                       OldImageSize + BufferSize);
                if (FontCache->BaseImageBits == NULL) {
                    RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to reallocate FontCache->BaseImageBits");
                    //
                    // When reallocation fails, we preserve the old baseImageBits
                    // so that other FontImage->ImageBits can be still valid.
                    //
                    FontCache->BaseImageBits = OldBaseImage;
                    //
                    // Remove the tail element that we failed to add image.
                    //
                    UnlinkAndShrinkFontImagesByOne(&FontOffsetLow->FontOffsetLow[LowIndex], FontImage);
                    return STATUS_NO_MEMORY;
                }

                // Rebase font image pointer
                RebaseFontCache(FontCache, OldBaseImage);

                FontImage->ImageBits = FontCache->BaseImageBits + OldImageSize;
            }

            AlignCopyMemory(FontImage->ImageBits,// pDestBits
                            WORD_ALIGN,          // dwDestAlign
                            (PVOID)ImageBits,    // pSrcBits
                            dwAlign,             // dwSrcAlign
                            FontSize);

            break;

        case REPLACE_IMAGE:
            if (FontImage->ImageBits == NULL) {
                RIPMSG0(RIP_WARNING, "SetFontImageInternal: FontImage->ImageBits is NULL.");
                return STATUS_NO_MEMORY;
            }

            AlignCopyMemory(FontImage->ImageBits,// pDestBits
                            WORD_ALIGN,          // dwDestAlign
                            (PVOID)ImageBits,    // pSrcBits
                            dwAlign,             // dwSrcAlign
                            FontSize);

            break;
    }

    return STATUS_SUCCESS;
}





ULONG
GetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    )
{
    NTSTATUS Status;
    PFONT_IMAGE FontImage;

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    Status = GetFontImageInternal(FontCache,wChar,FontSize,&FontImage,FONT_MATCHED);
    if (! NT_SUCCESS(Status) )
        return (ULONG)Status;

    if (FontImage->ImageBits == NULL ||
        ImageBits == NULL)
        return STATUS_SUCCESS;

    AlignCopyMemory((PVOID)ImageBits,    // pDestBits
                    dwAlign,             // dwDestAlign
                    FontImage->ImageBits,// pSrcBits
                    WORD_ALIGN,          // dwSrcAlign
                    FontSize);

    return STATUS_SUCCESS;
}

ULONG
GetStretchedFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    )
{
    NTSTATUS Status;
    PFONT_IMAGE FontImage;
    FONT_IMAGE  FontBuff;
    DWORD BufferSize;

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    FontImage = &FontBuff;

    BufferSize = CalcBitmapBufferSize(FontSize,WORD_ALIGN);
    FontImage->ImageBits = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, BufferSize);
    if (FontImage->ImageBits == NULL) {
        RIPMSG0(RIP_WARNING, "GetStretchedFontImage: failed to allocate FontImage->ImageBits");
        return (ULONG)STATUS_NO_MEMORY;
    }

    Status = GetFontImageInternal(FontCache,wChar,FontSize,&FontImage,FONT_STRETCHED);
    if (! NT_SUCCESS(Status) )
    {
        ConsoleHeapFree(FontBuff.ImageBits);
        return (ULONG)Status;
    }

    if (FontImage->ImageBits == NULL)
    {
        ConsoleHeapFree(FontBuff.ImageBits);
        return (ULONG)STATUS_SUCCESS;
    }

    AlignCopyMemory((PVOID)ImageBits,    // pDestBits
                    dwAlign,             // dwDestAlign
                    FontImage->ImageBits,// pSrcBits
                    WORD_ALIGN,          // dwSrcAlign
                    FontSize);

    ConsoleHeapFree(FontBuff.ImageBits);

    return (ULONG)STATUS_SUCCESS;
}

ULONG
GetFontImagePointer(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    OUT PFONT_IMAGE *FontImage
    )
{
    NTSTATUS Status;

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    Status = GetFontImageInternal(FontCache,wChar,FontSize,(PFONT_IMAGE*)FontImage,FONT_MATCHED);
    if (! NT_SUCCESS(Status) )
        return (ULONG)Status;

    if ((*FontImage)->ImageBits == NULL)
        return (ULONG)STATUS_ACCESS_DENIED;

    return Status;
}

ULONG
SetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    IN CONST VOID *ImageBits
    )
{
    return SetFontImageInternal(FontCache,wChar,FontSize,dwAlign,ImageBits);
}


NTSTATUS
GetExpandImage(
    COORD InputFontSize,
    PWORD InputFontImage,
    COORD OutputFontSize,
    PWORD OutputFontImage
    )
{
    NTSTATUS Status;
    DWORD InputRow = CALC_BITMAP_BITS_FOR_X(InputFontSize.X, BITMAP_BITS_WORD_ALIGN);
    DWORD OutputRow = CALC_BITMAP_BITS_FOR_X(OutputFontSize.X, BITMAP_BITS_WORD_ALIGN);
    DWORD InputBufferSize = CalcBitmapBufferSize(InputFontSize,WORD_ALIGN);
    DWORD OutputBufferSize = CalcBitmapBufferSize(OutputFontSize,WORD_ALIGN);

    Status = STATUS_NO_MEMORY;

    RtlZeroMemory(OutputFontImage,OutputBufferSize);

    ASSERT(InputRow==OutputRow);

    if (InputFontSize.Y < OutputFontSize.Y)
        RtlCopyMemory(OutputFontImage, InputFontImage, InputBufferSize);
    else
        RtlCopyMemory(OutputFontImage, InputFontImage, OutputBufferSize);

    return STATUS_SUCCESS;
}

NTSTATUS
GetExpandFontImage(
    PFONT_CACHE_INFORMATION FontCache,
    WCHAR wChar,
    COORD InputFontSize,
    COORD OutputFontSize,
    PWORD OutputFontImage
    )
{
    NTSTATUS Status;
    DWORD InputBufferSize;
    PWORD InputFontImage;

    if (InputFontSize.X == 0 &&
        InputFontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    if (OutputFontSize.X == 0 &&
        OutputFontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    InputBufferSize = CalcBitmapBufferSize(InputFontSize,WORD_ALIGN);
    InputFontImage = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, InputBufferSize);
    if (InputFontImage==NULL)
        return STATUS_NO_MEMORY;


    Status = GetFontImage(FontCache,
                          wChar,
                          InputFontSize,
                          WORD_ALIGN,
                          InputFontImage);
    if (! NT_SUCCESS(Status) )
    {
        ConsoleHeapFree(InputFontImage);
        return Status;
    }

    Status = GetExpandImage(InputFontSize,
                            InputFontImage,
                            OutputFontSize,
                            OutputFontImage);

    ConsoleHeapFree(InputFontImage);

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\directio.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    directio.c

Abstract:

        This file implements the NT console direct I/O API

Author:

    Therese Stowell (thereses) 6-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)
#define WWSB_FE
#include "dispatch.h" // get the FE_ prototypes
#undef  WWSB_FE
#pragma alloc_text(FE_TEXT, FE_TranslateInputToOem)
#pragma alloc_text(FE_TEXT, FE_TranslateInputToUnicode)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToOem)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToOemUnicode)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToUnicode)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToAnsiUnicode)
#endif


#if defined(FE_SB)
ULONG
SB_TranslateInputToOem
#else
NTSTATUS
TranslateInputToOem
#endif
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    )
{
    ULONG i;

    DBGCHARS(("TranslateInputToOem\n"));
    for (i=0;i<NumRecords;i++) {
        if (InputRecords[i].EventType == KEY_EVENT) {
            InputRecords[i].Event.KeyEvent.uChar.AsciiChar = WcharToChar(
                    Console->CP, InputRecords[i].Event.KeyEvent.uChar.UnicodeChar);
        }
    }
#if defined(FE_SB)
    return NumRecords;
#else
    return STATUS_SUCCESS;
#endif
}

#if defined(FE_SB)
ULONG
FE_TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    )
{
    ULONG i,j;
    PINPUT_RECORD TmpInpRec;
    BYTE AsciiDbcs[2];
    ULONG NumBytes;

    ASSERT(NumRecords >= UnicodeLength);

    TmpInpRec = ConsoleHeapAlloc(TMP_DBCS_TAG, NumRecords*sizeof(INPUT_RECORD));
    if (TmpInpRec == NULL)
        return 0;

    memcpy(TmpInpRec,InputRecords,NumRecords*sizeof(INPUT_RECORD));
    AsciiDbcs[1] = 0;
    for (i=0,j=0; i<UnicodeLength; i++,j++) {
        if (TmpInpRec[i].EventType == KEY_EVENT) {
            if (IsConsoleFullWidth(Console->hDC,
                                   Console->CP,TmpInpRec[i].Event.KeyEvent.uChar.UnicodeChar)) {
                NumBytes = sizeof(AsciiDbcs);
                ConvertToOem(Console->CP,
                       &TmpInpRec[i].Event.KeyEvent.uChar.UnicodeChar,
                       1,
                       &AsciiDbcs[0],
                       NumBytes
                       );
                if (IsDBCSLeadByteConsole(AsciiDbcs[0],&Console->CPInfo)) {
                    if (j < NumRecords-1) {  // -1 is safe DBCS in buffer
                        InputRecords[j] = TmpInpRec[i];
                        InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                        InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[0];
                        j++;
                        InputRecords[j] = TmpInpRec[i];
                        InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                        InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[1];
                        AsciiDbcs[1] = 0;
                    }
                    else if (j == NumRecords-1) {
                        InputRecords[j] = TmpInpRec[i];
                        InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                        InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[0];
                        j++;
                        break;
                    }
                    else {
                        AsciiDbcs[1] = 0;
                        break;
                    }
                }
                else {
                    InputRecords[j] = TmpInpRec[i];
                    InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                    InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[0];
                    AsciiDbcs[1] = 0;
                }
            }
            else {
                InputRecords[j] = TmpInpRec[i];
                ConvertToOem(Console->CP,
                       &InputRecords[j].Event.KeyEvent.uChar.UnicodeChar,
                       1,
                       &InputRecords[j].Event.KeyEvent.uChar.AsciiChar,
                       1
                       );
            }
        }
    }
    if (DbcsLeadInpRec) {
        if (AsciiDbcs[1]) {
            *DbcsLeadInpRec = TmpInpRec[i];
            DbcsLeadInpRec->Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[1];
        }
        else {
            RtlZeroMemory(DbcsLeadInpRec,sizeof(INPUT_RECORD));
        }
    }
    ConsoleHeapFree(TmpInpRec);
    return j;
}
#endif



#if defined(FE_SB)
ULONG
SB_TranslateInputToUnicode
#else
NTSTATUS
TranslateInputToUnicode
#endif
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    )
{
    ULONG i;
    DBGCHARS(("TranslateInputToUnicode\n"));
    for (i=0;i<NumRecords;i++) {
        if (InputRecords[i].EventType == KEY_EVENT) {
#if defined(FE_SB)
            InputRecords[i].Event.KeyEvent.uChar.UnicodeChar = SB_CharToWchar(
                    Console->CP, InputRecords[i].Event.KeyEvent.uChar.AsciiChar);
#else
            InputRecords[i].Event.KeyEvent.uChar.UnicodeChar = CharToWchar(
                    Console->CP, InputRecords[i].Event.KeyEvent.uChar.AsciiChar);
#endif
        }
    }
#if defined(FE_SB)
    return i;
#else
    return STATUS_SUCCESS;
#endif
}

#if defined(FE_SB)
ULONG
FE_TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    )
{
    ULONG i,j;
    INPUT_RECORD AsciiDbcs[2];
    CHAR Strings[2];
    WCHAR UnicodeDbcs[2];
    PWCHAR Uni;
    ULONG NumBytes;

    if (DBCSLeadByte->Event.KeyEvent.uChar.AsciiChar) {
        AsciiDbcs[0] = *DBCSLeadByte;
        Strings[0] = DBCSLeadByte->Event.KeyEvent.uChar.AsciiChar;
    }
    else{
        RtlZeroMemory(AsciiDbcs,sizeof(AsciiDbcs));
    }
    for (i=j=0; i<NumRecords; i++) {
        if (InputRecords[i].EventType == KEY_EVENT) {
            if (AsciiDbcs[0].Event.KeyEvent.uChar.AsciiChar) {
                AsciiDbcs[1] = InputRecords[i];
                Strings[1] = InputRecords[i].Event.KeyEvent.uChar.AsciiChar;
                NumBytes = sizeof(Strings);
                NumBytes = ConvertInputToUnicode(Console->CP,
                                                 &Strings[0],
                                                 NumBytes,
                                                 &UnicodeDbcs[0],
                                                 NumBytes);
                Uni = &UnicodeDbcs[0];
                while (NumBytes--) {
                    InputRecords[j] = AsciiDbcs[0];
                    InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = *Uni++;
                    j++;
                }
                RtlZeroMemory(AsciiDbcs,sizeof(AsciiDbcs));
                if (DBCSLeadByte->Event.KeyEvent.uChar.AsciiChar)
                    RtlZeroMemory(DBCSLeadByte,sizeof(INPUT_RECORD));
            }
            else if (IsDBCSLeadByteConsole(InputRecords[i].Event.KeyEvent.uChar.AsciiChar,&Console->CPInfo)) {
                if (i < NumRecords-1) {
                    AsciiDbcs[0] = InputRecords[i];
                    Strings[0] = InputRecords[i].Event.KeyEvent.uChar.AsciiChar;
                }
                else {
                    *DBCSLeadByte = InputRecords[i];
                    break;
                }
            }
            else {
                CHAR c;
                InputRecords[j] = InputRecords[i];
                c = InputRecords[i].Event.KeyEvent.uChar.AsciiChar;
                ConvertInputToUnicode(Console->CP,
                      &c,
                      1,
                      &InputRecords[j].Event.KeyEvent.uChar.UnicodeChar,
                      1);
                j++;
            }
        }
        else {
            InputRecords[j++] = InputRecords[i];
        }
    }
    return j;
}
#endif


BOOLEAN
DirectReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )

/*++

Routine Description:

    This routine is called to complete a direct read that blocked in
    ReadInputBuffer.  The context of the read was saved in the DirectReadData
    structure.  This routine is called when events have been written to
    the input buffer.  It is called in the context of the writing thread.

Arguments:

    WaitQueue - Pointer to queue containing wait block.

    WaitingThread - Pointer to waiting thread.

    WaitReplyMessage - Pointer to reply message to return to dll when
        read is completed.

    DirectReadData - Context of read.

    SatisfyParameter1 - Unused.

    SatisfyParameter2 - Unused.

    WaitFlags - Flags indicating status of wait.

Return Value:

--*/

{
    PCONSOLE_GETCONSOLEINPUT_MSG a;
    PINPUT_RECORD Buffer;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PDIRECT_READ_DATA DirectReadData;
    PHANDLE_DATA HandleData;
    BOOLEAN RetVal = TRUE;
#if defined(FE_SB)
    BOOLEAN fAddDbcsLead = FALSE;
    PDWORD  nLength;
#endif

    a = (PCONSOLE_GETCONSOLEINPUT_MSG)&WaitReplyMessage->u.ApiMessageData;
    DirectReadData = (PDIRECT_READ_DATA) WaitParameter;

    Status = DereferenceIoHandleNoCheck(DirectReadData->ProcessData,
                                        DirectReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // see if this routine was called by CloseInputHandle.  if it
    // was, see if this wait block corresponds to the dying handle.
    // if it doesn't, just return.
    //

    if (SatisfyParameter1 != NULL &&
        SatisfyParameter1 != HandleData) {
        return FALSE;
    }

    //
    // if ctrl-c or ctrl-break was seen, ignore it.
    //

    if ((ULONG_PTR)SatisfyParameter2 & (CONSOLE_CTRL_C_SEEN | CONSOLE_CTRL_BREAK_SEEN)) {
        return FALSE;
    }

    Console = DirectReadData->Console;

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_CP(Console) && !a->Unicode) {
        if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
            if (a->NumRecords == 1) {
                Buffer = &a->Record[0];
                *Buffer = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte;
                if (!(a->Flags & CONSOLE_READ_NOREMOVE))
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                return TRUE;
            }
        }
    }
#endif

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    try {
        LockReadCount(HandleData);
        ASSERT(HandleData->InputReadData->ReadCount);
        HandleData->InputReadData->ReadCount -= 1;
        UnlockReadCount(HandleData);

        //
        // see if called by CsrDestroyProcess or CsrDestroyThread
        // via CsrNotifyWaitBlock.   if so, just decrement the ReadCount
        // and return.
        //

        if (WaitFlags & CSR_PROCESS_TERMINATING) {
            Status = STATUS_THREAD_IS_TERMINATING;
            leave;
        }

        //
        // We must see if we were woken up because the handle is being
        // closed.  if so, we decrement the read count.  if it goes to
        // zero, we wake up the close thread.  otherwise, we wake up any
        // other thread waiting for data.
        //

        if (HandleData->InputReadData->InputHandleFlags & HANDLE_CLOSING) {
            ASSERT (SatisfyParameter1 == HandleData);
            Status = STATUS_ALERTED;
            leave;
        }

        //
        // if we get to here, this routine was called either by the input
        // thread or a write routine.  both of these callers grab the
        // current console lock.
        //

        //
        // this routine should be called by a thread owning the same
        // lock on the same console as we're reading from.
        //

        ASSERT (ConsoleLocked(Console));

        //
        // if the read buffer is contained within the message, we need to
        // reset the buffer pointer because the message copied from the
        // stack to heap space when the wait block was created.
        //

        if (a->NumRecords <= INPUT_RECORD_BUFFER_SIZE) {
            Buffer = a->Record;
        } else {
            Buffer = a->BufPtr;
        }
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console) ) {
            Console->ReadConInpNumBytesUnicode = a->NumRecords;
            if (!a->Unicode) {
                /*
                 * ASCII : a->NumRecords is ASCII byte count
                 */
                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    /*
                     * Saved DBCS Traling byte
                     */
                    if (Console->ReadConInpNumBytesUnicode != 1) {
                        Console->ReadConInpNumBytesUnicode--;
                        Buffer++;
                        fAddDbcsLead = TRUE;
                        nLength = &Console->ReadConInpNumBytesUnicode;
                    }
                    else {
                        ASSERT(Console->ReadConInpNumBytesUnicode==1);
                    }
                }
                else {
                    nLength = &Console->ReadConInpNumBytesUnicode;
                }
            }
            else {
                nLength = &a->NumRecords;
            }
        }
        else {
            nLength = &a->NumRecords;
        }
        Status = ReadInputBuffer(DirectReadData->InputInfo,
                                 Buffer,
                                 nLength,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 WaitReplyMessage,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 TRUE,
                                 a->Unicode
                                );
#else
        Status = ReadInputBuffer(DirectReadData->InputInfo,
                                 Buffer,
                                 &a->NumRecords,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 WaitReplyMessage,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 TRUE
                                );
#endif
        if (Status == CONSOLE_STATUS_WAIT) {
            RetVal = FALSE;
        }
    } finally {

        //
        // if the read was completed (status != wait), free the direct read
        // data.
        //

        if (Status != CONSOLE_STATUS_WAIT) {
            if (Status == STATUS_SUCCESS && !a->Unicode) {
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_CP(Console) ) {
                    if (fAddDbcsLead &&
                        HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        a->NumRecords--;
                    }
                    a->NumRecords = FE_TranslateInputToOem(
                                        Console,
                                        Buffer,
                                        a->NumRecords,
                                        Console->ReadConInpNumBytesUnicode,
                                        a->Flags & CONSOLE_READ_NOREMOVE ?
                                            NULL :
                                            &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
                    if (fAddDbcsLead &&
                        HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        *(Buffer-1) = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte;
                        if (!(a->Flags & CONSOLE_READ_NOREMOVE))
                            RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                        a->NumRecords++;
                        Buffer--;
                    }
                }
                else {
                    TranslateInputToOem(Console,
                                         Buffer,
                                         a->NumRecords,
                                         Console->ReadConInpNumBytesUnicode,
                                         a->Flags & CONSOLE_READ_NOREMOVE ?
                                             NULL :
                                             &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte
                                        );
                }
#else
                TranslateInputToOem(Console,
                                     Buffer,
                                     a->NumRecords
                                    );
#endif
            }
            WaitReplyMessage->ReturnValue = Status;
            ConsoleHeapFree(DirectReadData);
        }
    }

    return RetVal;

    //
    // satisfy the unreferenced parameter warnings.
    //

    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(WaitingThread);
    UNREFERENCED_PARAMETER(SatisfyParameter2);
}


ULONG
SrvGetConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine reads or peeks input events.  In both cases, the events
    are copied to the user's buffer.  In the read case they are removed
    from the input buffer and in the peek case they are not.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_GETCONSOLEINPUT_MSG a = (PCONSOLE_GETCONSOLEINPUT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PINPUT_RECORD Buffer;
    DIRECT_READ_DATA DirectReadData;
#ifdef FE_SB
    BOOLEAN fAddDbcsLead = FALSE;
    PDWORD  nLength;
#endif

    if (a->Flags & ~CONSOLE_READ_VALID) {
        return (ULONG)STATUS_INVALID_PARAMETER;
    }

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumRecords = 0;
    } else {

        if (a->NumRecords <= INPUT_RECORD_BUFFER_SIZE) {
            Buffer = a->Record;
        } else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, sizeof(*Buffer))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // if we're reading, wait for data.  if we're peeking, don't.
        //

        DirectReadData.InputInfo = HandleData->Buffer.InputBuffer;
        DirectReadData.Console = Console;
        DirectReadData.ProcessData = CONSOLE_PERPROCESSDATA();
        DirectReadData.HandleIndex = HANDLE_TO_INDEX(a->InputHandle);
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console) ) {
            Console->ReadConInpNumBytesUnicode = a->NumRecords;
            if (!a->Unicode) {
                /*
                 * ASCII : a->NumRecords is ASCII byte count
                 */
                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    /*
                     * Saved DBCS Traling byte
                     */
                    *Buffer = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte;
                    if (!(a->Flags & CONSOLE_READ_NOREMOVE))
                        RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));

                    if (Console->ReadConInpNumBytesUnicode == 1) {
                        UnlockConsole(Console);
                        return STATUS_SUCCESS;
                    }
                    else {
                        Console->ReadConInpNumBytesUnicode--;
                        Buffer++;
                        fAddDbcsLead = TRUE;
                        nLength = &Console->ReadConInpNumBytesUnicode;
                    }
                }
                else {
                    nLength = &Console->ReadConInpNumBytesUnicode;
                }
            }
            else {
                nLength = &a->NumRecords;
            }
        }
        else {
            nLength = &a->NumRecords;
        }
        Status = ReadInputBuffer(HandleData->Buffer.InputBuffer,
                                 Buffer,
                                 nLength,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 m,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 FALSE,
                                 a->Unicode
                                );
        if (Status == CONSOLE_STATUS_WAIT) {
            *ReplyStatus = CsrReplyPending;
        } else if (!a->Unicode) {
            a->NumRecords = TranslateInputToOem(Console,
                                                Buffer,
                                                fAddDbcsLead ?
                                                    a->NumRecords-1 :
                                                    a->NumRecords,
                                                Console->ReadConInpNumBytesUnicode,
                                                a->Flags & CONSOLE_READ_NOREMOVE ?
                                                    NULL :
                                                    &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte
                                               );
            if (fAddDbcsLead)
            {
                a->NumRecords++;
                Buffer--;
            }
        }
#else
        Status = ReadInputBuffer(HandleData->Buffer.InputBuffer,
                                 Buffer,
                                 &a->NumRecords,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 m,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 FALSE
                                );
        if (Status == CONSOLE_STATUS_WAIT) {
            *ReplyStatus = CsrReplyPending;
        } else if (!a->Unicode) {
            TranslateInputToOem(Console,
                                 Buffer,
                                 a->NumRecords
                                );
        }
#endif
    }
    UnlockConsole(Console);
    return Status;
}

ULONG
SrvWriteConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_WRITECONSOLEINPUT_MSG a = (PCONSOLE_WRITECONSOLEINPUT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PINPUT_RECORD Buffer;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumRecords = 0;
    } else {
        if (a->NumRecords <= INPUT_RECORD_BUFFER_SIZE) {
            Buffer = a->Record;
        } else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, sizeof(*Buffer))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }
        if (!a->Unicode) {
#if defined(FE_SB)
            a->NumRecords = TranslateInputToUnicode(Console,
                                    Buffer,
                                    a->NumRecords,
                                    &HandleData->Buffer.InputBuffer->WriteConInpDbcsLeadByte[0]
                                   );
#else
            TranslateInputToUnicode(Console,
                                    Buffer,
                                    a->NumRecords
                                   );
#endif
        }
        if (a->Append) {
            a->NumRecords = WriteInputBuffer(Console,
                                             HandleData->Buffer.InputBuffer,
                                             Buffer,
                                             a->NumRecords
                                            );
        } else {
            a->NumRecords = PrependInputBuffer(Console,
                                             HandleData->Buffer.InputBuffer,
                                             Buffer,
                                             a->NumRecords
                                            );

        }
    }
    UnlockConsole(Console);
    return((ULONG) Status);
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

NTSTATUS
SB_TranslateOutputToOem
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app reads oem from the output buffer
// the app wants real OEM characters.  We have real Unicode or UnicodeOem.
{
    SHORT i,j;
    UINT Codepage;
    DBGCHARS(("SB_TranslateOutputToOem(Console=%lx, OutputBuffer=%lx)\n",
            Console, OutputBuffer));

    j = Size.X * Size.Y;

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED() &&
            Console->OutputCP != WINDOWSCP ) {
                Codepage = USACP;
        }
        else
#endif
        // we have UnicodeOem characters
        Codepage = WINDOWSCP;
    } else {
        // we have real Unicode characters
        Codepage = Console->OutputCP;    // BUG FIX by KazuM Jun.2.97
    }

    for (i=0;i<j;i++,OutputBuffer++) {
        OutputBuffer->Char.AsciiChar = WcharToChar(Codepage,
                OutputBuffer->Char.UnicodeChar);
    }
    return STATUS_SUCCESS;
}

#if defined(FE_SB)
NTSTATUS
FE_TranslateOutputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app reads oem from the output buffer
// the app wants real OEM characters.  We have real Unicode or UnicodeOem.
{
    SHORT i,j;
    UINT Codepage;
    PCHAR_INFO TmpBuffer,SaveBuffer;
    CHAR  AsciiDbcs[2];
    ULONG NumBytes;
    DBGCHARS(("FE_TranslateOutputToOem(Console=%lx, OutputBuffer=%lx)\n",
            Console, OutputBuffer));

    SaveBuffer = TmpBuffer =
        ConsoleHeapAlloc(TMP_DBCS_TAG, Size.X * Size.Y * sizeof(CHAR_INFO) * 2);
    if (TmpBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
        if (CONSOLE_IS_DBCS_ENABLED() &&
            Console->OutputCP != WINDOWSCP ) {
                Codepage = USACP;
        }
        else
            // we have UnicodeOem characters
            Codepage = WINDOWSCP;
    } else {
        // we have real Unicode characters
        Codepage = Console->OutputCP;
    }

    memcpy(TmpBuffer,OutputBuffer,Size.X * Size.Y * sizeof(CHAR_INFO));
    for (i=0; i < Size.Y; i++) {
        for (j=0; j < Size.X; j++) {
            if (TmpBuffer->Attributes & COMMON_LVB_LEADING_BYTE) {
                if (j < Size.X-1) {  // -1 is safe DBCS in buffer
                    j++;
                    NumBytes = sizeof(AsciiDbcs);
                    NumBytes = ConvertOutputToOem(Codepage,
                                   &TmpBuffer->Char.UnicodeChar,
                                   1,
                                   &AsciiDbcs[0],
                                   NumBytes);
                    OutputBuffer->Char.AsciiChar = AsciiDbcs[0];
                    OutputBuffer->Attributes = TmpBuffer->Attributes;
                    OutputBuffer++;
                    TmpBuffer++;
                    OutputBuffer->Char.AsciiChar = AsciiDbcs[1];
                    OutputBuffer->Attributes = TmpBuffer->Attributes;
                    OutputBuffer++;
                    TmpBuffer++;
                }
                else {
                    OutputBuffer->Char.AsciiChar = ' ';
                    OutputBuffer->Attributes = TmpBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                    OutputBuffer++;
                    TmpBuffer++;
                }
            }
            else if (!(TmpBuffer->Attributes & COMMON_LVB_SBCSDBCS)){
                ConvertOutputToOem(Codepage,
                    &TmpBuffer->Char.UnicodeChar,
                    1,
                    &OutputBuffer->Char.AsciiChar,
                    1);
                OutputBuffer->Attributes = TmpBuffer->Attributes;
                OutputBuffer++;
                TmpBuffer++;
            }
        }
    }
    ConsoleHeapFree(SaveBuffer);
    return STATUS_SUCCESS;
}
#endif

NTSTATUS
SB_TranslateOutputToOemUnicode
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app reads unicode from the output buffer
{
    SHORT i,j;
    DBGCHARS(("SB_TranslateOutputToOemUnicode\n"));

    j = Size.X * Size.Y;

    for (i=0;i<j;i++,OutputBuffer++) {
        FalseUnicodeToRealUnicode(&OutputBuffer->Char.UnicodeChar,
                                1,
                                Console->OutputCP
                                );
    }
    return STATUS_SUCCESS;
}

#if defined(FE_SB)
NTSTATUS
FE_TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    )
// this is used when the app reads unicode from the output buffer
{
    SHORT i,j;
    DBGCHARS(("FE_TranslateOutputToOemUnicode\n"));

    j = Size.X * Size.Y;

    if (fRemoveDbcsMark)
        RemoveDbcsMarkCell(OutputBuffer,OutputBuffer,j);

    for (i=0;i<j;i++,OutputBuffer++) {
        FalseUnicodeToRealUnicode(&OutputBuffer->Char.UnicodeChar,
                                1,
                                Console->OutputCP
                                );
    }
    return STATUS_SUCCESS;
}
#endif


NTSTATUS
SB_TranslateOutputToUnicode
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app writes oem to the output buffer
// we want UnicodeOem or Unicode in the buffer, depending on font & fullscreen
{
    SHORT i,j;
    UINT Codepage;
    DBGCHARS(("SB_TranslateOutputToUnicode %lx %lx (%lx,%lx)\n",
            Console, OutputBuffer, Size.X, Size.Y));

    j = Size.X * Size.Y;

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED() &&
            (Console->OutputCP != WINDOWSCP) ) {
                Codepage = USACP;
        }
        else
#endif
        // we want UnicodeOem characters
        Codepage = WINDOWSCP;
    } else {
        // we want real Unicode characters
        Codepage = Console->OutputCP;    // BUG FIX by KazuM Jun.2.97
    }
    for (i = 0; i < j; i++, OutputBuffer++) {
#if defined(FE_SB)
        OutputBuffer->Char.UnicodeChar = SB_CharToWchar(
                Codepage, OutputBuffer->Char.AsciiChar);
#else
        OutputBuffer->Char.UnicodeChar = CharToWchar(
                Codepage, OutputBuffer->Char.AsciiChar);
#endif
    }
    return STATUS_SUCCESS;
}

#if defined(FE_SB)
NTSTATUS
FE_TranslateOutputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app writes oem to the output buffer
// we want UnicodeOem or Unicode in the buffer, depending on font & fullscreen
{
    SHORT i,j;
    UINT Codepage;
    CHAR  AsciiDbcs[2];
    WCHAR UnicodeDbcs[2];
    DBGCHARS(("FE_TranslateOutputToUnicode %lx %lx (%lx,%lx)\n",
            Console, OutputBuffer, Size.X, Size.Y));

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
        if (CONSOLE_IS_DBCS_ENABLED() &&
            (Console->OutputCP != WINDOWSCP) ) {
                Codepage = USACP;
        }
        else
            // we want UnicodeOem characters
            Codepage = WINDOWSCP;
    } else {
        // we want real Unicode characters
        Codepage = Console->OutputCP;
    }

    for (i=0; i < Size.Y; i++) {
        for (j=0; j < Size.X; j++) {
            OutputBuffer->Attributes &= ~COMMON_LVB_SBCSDBCS;
            if (IsDBCSLeadByteConsole(OutputBuffer->Char.AsciiChar,&Console->OutputCPInfo)) {
                if (j < Size.X-1) {  // -1 is safe DBCS in buffer
                    j++;
                    AsciiDbcs[0] = OutputBuffer->Char.AsciiChar;
                    AsciiDbcs[1] = (OutputBuffer+1)->Char.AsciiChar;
                    ConvertOutputToUnicode(Codepage,
                                           &AsciiDbcs[0],
                                           2,
                                           &UnicodeDbcs[0],
                                           2);
                    OutputBuffer->Char.UnicodeChar = UnicodeDbcs[0];
                    OutputBuffer->Attributes |= COMMON_LVB_LEADING_BYTE;
                    OutputBuffer++;
                    OutputBuffer->Char.UnicodeChar = UNICODE_DBCS_PADDING;
                    OutputBuffer->Attributes &= ~COMMON_LVB_SBCSDBCS;
                    OutputBuffer->Attributes |= COMMON_LVB_TRAILING_BYTE;
                    OutputBuffer++;
                }
                else {
                    OutputBuffer->Char.UnicodeChar = UNICODE_SPACE;
                    OutputBuffer++;
                }
            }
            else {
                CHAR c;
                c=OutputBuffer->Char.AsciiChar;
                ConvertOutputToUnicode(Codepage,
                                       &c,
                                       1,
                                       &OutputBuffer->Char.UnicodeChar,
                                       1);
                OutputBuffer++;
            }
        }
    }
    return STATUS_SUCCESS;
}
#endif


NTSTATUS
SB_TranslateOutputToAnsiUnicode (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app writes unicode to the output buffer
{
    SHORT i,j;
    DBGCHARS(("TranslateOutputToAnsiUnicode\n"));

    j = Size.X * Size.Y;

    for (i=0;i<j;i++,OutputBuffer++) {
        RealUnicodeToFalseUnicode(&OutputBuffer->Char.UnicodeChar,
                                1,
                                Console->OutputCP
                                );
    }
    return STATUS_SUCCESS;
}

NTSTATUS
FE_TranslateOutputToAnsiUnicodeInternal(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR,
    IN BOOL fRealUnicodeToFalseUnicode
    )
// this is used when the app writes unicode to the output buffer
{
    SHORT i,j;
    DBGCHARS(("TranslateOutputToAnsiUnicode\n"));

    for (i=0; i < Size.Y; i++) {
        for (j=0; j < Size.X; j++) {
            WCHAR wch = OutputBuffer->Char.UnicodeChar;

            if (fRealUnicodeToFalseUnicode) {
                RealUnicodeToFalseUnicode(&OutputBuffer->Char.UnicodeChar,
                                          1,
                                          Console->OutputCP
                                         );
            }

            if (OutputBufferR) {
                OutputBufferR->Attributes = OutputBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                if (IsConsoleFullWidth(Console->hDC,
                                       Console->OutputCP,OutputBuffer->Char.UnicodeChar)) {
                    if (j == Size.X-1){
                        OutputBufferR->Char.UnicodeChar = UNICODE_SPACE;
                    }
                    else{
                        OutputBufferR->Char.UnicodeChar = OutputBuffer->Char.UnicodeChar;
                        OutputBufferR->Attributes |= COMMON_LVB_LEADING_BYTE;
                        OutputBufferR++;
                        OutputBufferR->Char.UnicodeChar = UNICODE_DBCS_PADDING;
                        OutputBufferR->Attributes = OutputBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                        OutputBufferR->Attributes |= COMMON_LVB_TRAILING_BYTE;
                    }
                }
                else{
                    OutputBufferR->Char.UnicodeChar = OutputBuffer->Char.UnicodeChar;
                }
                OutputBufferR++;
            }

            if (IsConsoleFullWidth(Console->hDC,
                                   Console->OutputCP,
                                   wch)) {
                if (j != Size.X-1){
                    j++;
                }
            }
            OutputBuffer++;
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
FE_TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    )
// this is used when the app writes unicode to the output buffer
{
    return FE_TranslateOutputToAnsiUnicodeInternal(Console,
                                                   OutputBuffer,
                                                   Size,
                                                   OutputBufferR,
                                                   TRUE
                                                   );
}

NTSTATUS
TranslateOutputToPaddingUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    )
{
    return FE_TranslateOutputToAnsiUnicodeInternal(Console,
                                                   OutputBuffer,
                                                   Size,
                                                   OutputBufferR,
                                                   FALSE
                                                   );
}

ULONG
SrvReadConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_READCONSOLEOUTPUT_MSG a = (PCONSOLE_READCONSOLEOUTPUT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCHAR_INFO Buffer;

    DBGOUTPUT(("SrvReadConsoleOutput\n"));
    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        //
        // a region of zero size is indicated by the right and bottom
        // coordinates being less than the left and top.
        //

        a->CharRegion.Right = (USHORT) (a->CharRegion.Left-1);
        a->CharRegion.Bottom = (USHORT) (a->CharRegion.Top-1);
    }
    else {
        COORD BufferSize;

        BufferSize.X = (SHORT)(a->CharRegion.Right - a->CharRegion.Left + 1);
        BufferSize.Y = (SHORT)(a->CharRegion.Bottom - a->CharRegion.Top + 1);

        if ((BufferSize.X == 1) && (BufferSize.Y == 1)) {
            Buffer = &a->Char;
        }
        else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, BufferSize.X * BufferSize.Y, sizeof(*Buffer))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }

        Status = ReadScreenBuffer(HandleData->Buffer.ScreenBuffer,
                                  Buffer,
                                  &a->CharRegion
                                 );
        if (!a->Unicode) {
            TranslateOutputToOem(Console,
                                  Buffer,
                                  BufferSize
                                 );
        } else if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            TranslateOutputToOemUnicode(Console,
                                        Buffer,
                                        BufferSize
#if defined(FE_SB)
                                        ,
                                        TRUE
#endif
                                       );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvWriteConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_WRITECONSOLEOUTPUT_MSG a = (PCONSOLE_WRITECONSOLEOUTPUT_MSG)&m->u.ApiMessageData;
    PSCREEN_INFORMATION ScreenBufferInformation;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCHAR_INFO Buffer;
#if defined(FE_SB)
    PCHAR_INFO TransBuffer = NULL;
#endif

    DBGOUTPUT(("SrvWriteConsoleOutput\n"));
    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {

        //
        // a region of zero size is indicated by the right and bottom
        // coordinates being less than the left and top.
        //

        a->CharRegion.Right = (USHORT) (a->CharRegion.Left-1);
        a->CharRegion.Bottom = (USHORT) (a->CharRegion.Top-1);
    } else {

        COORD BufferSize;
        ULONG NumBytes;

        BufferSize.X = (SHORT)(a->CharRegion.Right - a->CharRegion.Left + 1);
        BufferSize.Y = (SHORT)(a->CharRegion.Bottom - a->CharRegion.Top + 1);
        NumBytes = BufferSize.X * BufferSize.Y * sizeof(*Buffer);

        if ((BufferSize.X == 1) && (BufferSize.Y == 1)) {
            Buffer = &a->Char;
        } else if (a->ReadVM) {
            Buffer = ConsoleHeapAlloc(TMP_TAG, NumBytes);
            if (Buffer == NULL) {
                UnlockConsole(Console);
                return (ULONG)STATUS_NO_MEMORY;
            }
            Status = NtReadVirtualMemory(CONSOLE_CLIENTPROCESSHANDLE(),
                                         a->BufPtr,
                                         Buffer,
                                         NumBytes,
                                         NULL
                                        );
            if (!NT_SUCCESS(Status)) {
                ConsoleHeapFree(Buffer);
                UnlockConsole(Console);
                return (ULONG)STATUS_NO_MEMORY;
            }
        } else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, NumBytes, sizeof(BYTE))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }
        ScreenBufferInformation = HandleData->Buffer.ScreenBuffer;

        if (!a->Unicode) {
            TranslateOutputToUnicode(Console,
                                     Buffer,
                                     BufferSize
                                    );
#if defined(FE_SB)
            Status = WriteScreenBuffer(ScreenBufferInformation,
                                       Buffer,
                                       &a->CharRegion
                                      );
#endif
        } else if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, (BufferSize.Y * BufferSize.X) * 2 * sizeof(CHAR_INFO));
                if (TransBuffer == NULL) {
                    UnlockConsole(Console);
                    return (ULONG)STATUS_NO_MEMORY;
                }
                FE_TranslateOutputToAnsiUnicode(Console,
                                            Buffer,
                                            BufferSize,
                                            &TransBuffer[0]
                                           );
                Status = WriteScreenBuffer(ScreenBufferInformation,
                                            &TransBuffer[0],
                                            &a->CharRegion
                                           );
                ConsoleHeapFree(TransBuffer);
            } else {
                SB_TranslateOutputToAnsiUnicode(Console,
                                                Buffer,
                                                BufferSize
                                               );
                Status = WriteScreenBuffer(ScreenBufferInformation,
                                            Buffer,
                                            &a->CharRegion
                                           );
            }
#else
            TranslateOutputToAnsiUnicode(Console,
                                        Buffer,
                                        BufferSize
                                       );
#endif
        }
#if defined(FE_SB)
        else
#endif
        Status = WriteScreenBuffer(ScreenBufferInformation,
                                    Buffer,
                                    &a->CharRegion
                                   );

        if (a->ReadVM) {
            ConsoleHeapFree(Buffer);
        }
        if (NT_SUCCESS(Status)) {

            //
            // cause screen to be updated
            //

#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                Console->Flags & CONSOLE_JUST_VDM_UNREGISTERED ){
                int MouseRec;
                MouseRec = Console->InputBuffer.InputMode;
                Console->InputBuffer.InputMode &= ~ENABLE_MOUSE_INPUT;
                Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                WriteToScreen(ScreenBufferInformation,&a->CharRegion );
                Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
                Console->InputBuffer.InputMode = MouseRec;
            }
            else
#endif
            WriteToScreen(ScreenBufferInformation,
                          &a->CharRegion
                         );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}


ULONG
SrvReadConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PVOID Buffer;
    PCONSOLE_READCONSOLEOUTPUTSTRING_MSG a = (PCONSOLE_READCONSOLEOUTPUTSTRING_MSG)&m->u.ApiMessageData;
    ULONG nSize;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {

        //
        // a region of zero size is indicated by the right and bottom
        // coordinates being less than the left and top.
        //

        a->NumRecords = 0;
    } else {
        if (a->StringType == CONSOLE_ASCII)
            nSize = sizeof(CHAR);
        else
            nSize = sizeof(WORD);
        if ((a->NumRecords*nSize) > sizeof(a->String)) {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, nSize)) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }
        else {
            Buffer = a->String;
        }
        Status = ReadOutputString(HandleData->Buffer.ScreenBuffer,
                                Buffer,
                                a->ReadCoord,
                                a->StringType,
                                &a->NumRecords
                               );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvWriteConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG a = (PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PVOID Buffer;
    ULONG nSize;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumRecords = 0;
    } else {
        if (a->WriteCoord.X < 0 ||
            a->WriteCoord.Y < 0) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            if (a->StringType == CONSOLE_ASCII)
                nSize = sizeof(CHAR);
            else
                nSize = sizeof(WORD);
            if ((a->NumRecords*nSize) > sizeof(a->String)) {
                Buffer = a->BufPtr;
                if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, nSize)) {
                    UnlockConsole(Console);
                    return STATUS_INVALID_PARAMETER;
                }
            }
            else {
                Buffer = a->String;
            }
            Status = WriteOutputString(HandleData->Buffer.ScreenBuffer,
                                     Buffer,
                                     a->WriteCoord,
                                     a->StringType,
                                     &a->NumRecords,
                                     NULL
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvFillConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_FILLCONSOLEOUTPUT_MSG a = (PCONSOLE_FILLCONSOLEOUTPUT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->Length = 0;
    } else {
        Status = FillOutput(HandleData->Buffer.ScreenBuffer,
                          a->Element,
                          a->WriteCoord,
                          a->ElementType,
                          &a->Length
                         );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}


ULONG
SrvCreateConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine creates a screen buffer and returns a handle to it.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_CREATESCREENBUFFER_MSG a = (PCONSOLE_CREATESCREENBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE Handle;
    PHANDLE_DATA HandleData;
    PCONSOLE_SHARE_ACCESS ShareAccess;
    CHAR_INFO Fill;
    COORD WindowSize;
    PSCREEN_INFORMATION ScreenInfo;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    ULONG HandleType;
    int FontIndex;

    DBGOUTPUT(("SrvCreateConsoleScreenBuffer\n"));

    /*
     * Verify that the Flags value is legit, or malicious code could make us
     * fault. Windows Bug #209416.
     */
    if (a->Flags != CONSOLE_TEXTMODE_BUFFER &&
        a->Flags != CONSOLE_GRAPHICS_BUFFER) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->Flags & CONSOLE_GRAPHICS_BUFFER) {
        if (!CsrValidateMessageBuffer(m, &a->GraphicsBufferInfo.lpBitMapInfo, a->GraphicsBufferInfo.dwBitMapInfoLength, sizeof(BYTE))) {
            UnlockConsole(Console);
            return STATUS_INVALID_PARAMETER;
        }
    }

    try {
        Handle = INVALID_HANDLE_VALUE;
        ProcessData = CONSOLE_PERPROCESSDATA();
        HandleType = (a->Flags & CONSOLE_GRAPHICS_BUFFER) ?
                      CONSOLE_GRAPHICS_OUTPUT_HANDLE : CONSOLE_OUTPUT_HANDLE;
        if (a->InheritHandle)
            HandleType |= CONSOLE_INHERITABLE;
        Status = AllocateIoHandle(ProcessData,
                                  HandleType,
                                  &Handle
                                 );
        if (!NT_SUCCESS(Status)) {
            leave;
        }
        Status = DereferenceIoHandleNoCheck(ProcessData,
                                     Handle,
                                     &HandleData
                                    );
        ASSERT (NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        // create new screen buffer
        //

        Fill.Char.UnicodeChar = (WCHAR)' ';
        Fill.Attributes = Console->CurrentScreenBuffer->Attributes;
        WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer);
        WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer);
        FontIndex = FindCreateFont(CON_FAMILY(Console),
                                   CON_FACENAME(Console),
                                   CON_FONTSIZE(Console),
                                   CON_FONTWEIGHT(Console),
                                   CON_FONTCODEPAGE(Console)
                                  );
        Status = CreateScreenBuffer(&ScreenInfo,WindowSize,
                                    FontIndex,
                                    WindowSize,
                                    Fill,Fill,Console,
                                    a->Flags,&a->GraphicsBufferInfo,
                                    &a->lpBitmap,&a->hMutex,
                                    CURSOR_SMALL_SIZE,
                                    NULL);
        if (!NT_SUCCESS(Status)) {
            leave;
        }
        InitializeOutputHandle(HandleData,ScreenInfo);
        ShareAccess = &ScreenInfo->ShareAccess;

        Status = ConsoleAddShare(a->DesiredAccess,
                                 a->ShareMode,
                                 ShareAccess,
                                 HandleData
                                );
        if (!NT_SUCCESS(Status)) {
            HandleData->Buffer.ScreenBuffer->RefCount--;
            FreeScreenBuffer(ScreenInfo);
            leave;
        }
        InsertScreenBuffer(Console, ScreenInfo);
        a->Handle = INDEX_TO_HANDLE(Handle);
    } finally {
        if (!NT_SUCCESS(Status) && Handle != INVALID_HANDLE_VALUE) {
            FreeIoHandle(ProcessData,
                         Handle
                        );
        }
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\eudc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    eudc.c

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)


NTSTATUS
CreateEUDC(
    PCONSOLE_INFORMATION Console
    )
{
    PEUDC_INFORMATION EudcInfo;

    EudcInfo = ConsoleHeapAlloc(EUDC_TAG, sizeof(EUDC_INFORMATION));
    if (EudcInfo == NULL) {
        return STATUS_NO_MEMORY;
    }
    EudcInfo->LocalVDMEudcMode = FALSE;
    EudcInfo->LocalKeisenEudcMode = FALSE;
    EudcInfo->hDCLocalEudc = NULL;
    EudcInfo->hBmpLocalEudc = NULL;
    EudcInfo->EudcFontCacheInformation = NULL;
    EudcInfo->LocalEudcSize.X = DEFAULT_EUDCSIZE;
    EudcInfo->LocalEudcSize.Y = DEFAULT_EUDCSIZE;

    RtlZeroMemory(&EudcInfo->EudcRange,sizeof(EudcInfo->EudcRange));
    EudcInfo->EudcRangeSize = GetSystemEUDCRangeW(EudcInfo->EudcRange, EUDC_RANGE_SIZE);
    if (EudcInfo->EudcRangeSize)
        EudcInfo->EudcRangeSize--;    // remove terminator

    Console->EudcInformation = (PVOID)EudcInfo;

    return STATUS_SUCCESS;
}

VOID
DeleteEUDC(
    PCONSOLE_INFORMATION Console
    )
{
    PEUDC_INFORMATION EudcInfo = Console->EudcInformation;

    if (EudcInfo->hDCLocalEudc) {
         ReleaseDC(NULL, EudcInfo->hDCLocalEudc);
         DeleteObject(EudcInfo->hBmpLocalEudc);
    }
}

NTSTATUS
RegisterLocalEUDC(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN PCHAR FontFace
    )
{
    NTSTATUS Status;
    PCHAR TmpBuff;
    DWORD BuffSize;
    PEUDC_INFORMATION EudcInfo = Console->EudcInformation;

    if (EudcInfo->EudcFontCacheInformation == NULL) {
        Status = (NTSTATUS)CreateFontCache(&(PFONT_CACHE_INFORMATION)EudcInfo->EudcFontCacheInformation);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "RegisterLocalEUDC: failed in CreateFontCache, Status is %08x", Status);
            return Status;
        }
    }

    BuffSize = CalcBitmapBufferSize(FontSize, BYTE_ALIGN);
    TmpBuff = FontFace;
    while(BuffSize--)
        *TmpBuff++ = ~(*TmpBuff);

    return (NTSTATUS)SetFontImage(EudcInfo->EudcFontCacheInformation,
                                  wChar,
                                  FontSize,
                                  BYTE_ALIGN,
                                  FontFace
                                 );
}

VOID
FreeLocalEUDC(
    IN PCONSOLE_INFORMATION Console
    )
{
    PEUDC_INFORMATION EudcInfo = Console->EudcInformation;

    if (EudcInfo->EudcFontCacheInformation != NULL) {
        DestroyFontCache((PFONT_CACHE_INFORMATION)EudcInfo->EudcFontCacheInformation);
    }

    ConsoleHeapFree(Console->EudcInformation);
}

VOID
GetFitLocalEUDCFont(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar
    )
{
    NTSTATUS Status;
    COORD FontSize;
    VOID *FontFace;
    DWORD BuffSize;
    PEUDC_INFORMATION EudcInfo;
    PFONT_CACHE_INFORMATION FontCacheInfo;

    EudcInfo = (PEUDC_INFORMATION)Console->EudcInformation;
    FontCacheInfo = (PFONT_CACHE_INFORMATION)EudcInfo->EudcFontCacheInformation;

    FontSize = CON_FONTSIZE(Console);
    if (IsConsoleFullWidth(Console->hDC,Console->OutputCP,wChar)) {
        FontSize.X *= 2;
    }

    if ((EudcInfo->LocalEudcSize.X != FontSize.X) ||
        (EudcInfo->LocalEudcSize.Y != FontSize.Y)   ) {
        ReleaseDC(NULL, EudcInfo->hDCLocalEudc);
        DeleteObject(EudcInfo->hBmpLocalEudc);
        EudcInfo->hDCLocalEudc = CreateCompatibleDC(Console->hDC);
        EudcInfo->hBmpLocalEudc = CreateBitmap(FontSize.X, FontSize.Y, BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
        SelectObject(EudcInfo->hDCLocalEudc, EudcInfo->hBmpLocalEudc);
        EudcInfo->LocalEudcSize.X = FontSize.X;
        EudcInfo->LocalEudcSize.Y = FontSize.Y;
    }

    BuffSize = CalcBitmapBufferSize(FontSize,WORD_ALIGN);
    FontFace = ConsoleHeapAlloc(TMP_DBCS_TAG, BuffSize);
    if (FontFace == NULL) {
        RIPMSG0(RIP_WARNING, "GetFitLocalEUDCFont: failed to allocate FontFace.");
        return;
    }

    Status = (NTSTATUS)GetFontImage(FontCacheInfo,
                                    wChar,
                                    FontSize,
                                    WORD_ALIGN,
                                    FontFace
                                   );
    if (! NT_SUCCESS(Status)) {

        if ((Console->Flags & CONSOLE_VDM_REGISTERED) &&
            FontSize.X == DefaultFontSize.X * 2       &&
            FontSize.Y == DefaultFontSize.Y           &&
            FontSize.X == VDM_EUDC_FONT_SIZE_X        &&
            FontSize.Y - 2 == VDM_EUDC_FONT_SIZE_Y      ) {

            COORD TmpFontSize = FontSize;

            TmpFontSize.Y -= 2;
            RtlFillMemory((PVOID)FontFace,BuffSize,0xff);
            Status = (NTSTATUS)GetFontImage(FontCacheInfo,
                                            wChar,
                                            TmpFontSize,
                                            WORD_ALIGN,
                                            FontFace
                                           );
            if (! NT_SUCCESS(Status)) {
                Status = (NTSTATUS)GetStretchedFontImage(FontCacheInfo,
                                                         wChar,
                                                         FontSize,
                                                         WORD_ALIGN,
                                                         FontFace
                                                        );
                if (! NT_SUCCESS(Status)) {
                    ASSERT(FALSE);
                    ConsoleHeapFree(FontFace);
                    return;
                }
            }
        }
        else {
            Status = (NTSTATUS)GetStretchedFontImage(FontCacheInfo,
                                                     wChar,
                                                     FontSize,
                                                     WORD_ALIGN,
                                                     FontFace
                                                    );
            if (! NT_SUCCESS(Status)) {
                ASSERT(FALSE);
                ConsoleHeapFree(FontFace);
                return;
            }
        }

        Status = (NTSTATUS)SetFontImage(FontCacheInfo,
                                        wChar,
                                        FontSize,
                                        WORD_ALIGN,
                                        FontFace
                                       );
        if (! NT_SUCCESS(Status)) {
            ASSERT(FALSE);
            ConsoleHeapFree(FontFace);
            return;
        }
    }

    SetBitmapBits(EudcInfo->hBmpLocalEudc, BuffSize, (PBYTE)FontFace);

    ConsoleHeapFree(FontFace);
}

BOOL
IsEudcRange(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR ch
    )
{
    PEUDC_INFORMATION EudcInfo;
    int i;

    EudcInfo = (PEUDC_INFORMATION)Console->EudcInformation;

    for (i=0; i < EudcInfo->EudcRangeSize; i+=2)
    {
        if (EudcInfo->EudcRange[i] <= ch && ch <= EudcInfo->EudcRange[i+1])
            return TRUE;
    }
    return FALSE;
}

BOOL
CheckEudcRangeInString(
    IN PCONSOLE_INFORMATION Console,
    IN  PWCHAR string,
    IN  SHORT  len,
    OUT SHORT  *find_pos
    )
{
    SHORT i;

    for (i = 0; i < len; i++,string++)
    {
        if (IsEudcRange(Console, *string))
        {
            *find_pos = i;
            return TRUE;
        }
    }
    return FALSE;
}

LPWSTR
SkipWhite(
    LPWSTR lpch
    )
{
    if( lpch == NULL )
        return( NULL );

    for ( ; ; lpch++ )
    {
        switch (*lpch)
        {
            case L' ':
            case L'\t':
            case L'\r':
            case L'\n':
                break;

            default:
                return(lpch);
        }
    }
}

WORD
ConvertStringToHex(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val << 4) + (ch - L'0');
        else if (L'A' <= ch && ch <= L'F')
            val = (val << 4) + (ch - L'A' + 10);
        else if (L'a' <= ch && ch <= L'f')
            val = (val << 4) + (ch - L'a' + 10);
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

WORD
ConvertStringToDec(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val * 10) + (ch - L'0');
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

INT
GetSystemEUDCRangeW(
    WORD  *pwEUDCCharTable,
    UINT   cjSize)
{
    NTSTATUS Status;
    HKEY     hkRegistry;
    UNICODE_STRING SystemACPString;
    WCHAR    awcACP[10];
    WCHAR    awchBuffer[512];
    INT      iEntry = 0;

    /*
     * Check parameter
     *
     * If pwEUDCWideCharTable == NULL && cjSize == 0
     * We have to return the needed buffer size to store data
     */
    if ((pwEUDCCharTable == NULL && cjSize != 0) ||
       (pwEUDCCharTable != NULL && cjSize == 0)) {
        return 0;
    }

    /*
     * Open registry key.
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_EUDC,
                          &hkRegistry);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING,
                "GetSystemEUDCRangeW: RegOpenKeyExW(%ws) failed, error = 0x%x",
                MACHINE_REGISTRY_EUDC, 
                GetLastError());
        return 0;
    }

    /*
     * Convert ACP to Unicode string.
     */
    SystemACPString.Length        = 0;
    SystemACPString.MaximumLength = ARRAY_SIZE(awcACP);
    SystemACPString.Buffer        = awcACP;
    RtlIntegerToUnicodeString(WINDOWSCP, 10, &SystemACPString);

    /*
     * Read registry data.
     */
    Status = MyRegQueryValue(hkRegistry,
                             awcACP,
                             sizeof(awchBuffer), (PBYTE)&awchBuffer);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_VERBOSE,
                "GetSystemEUDCRangeW: NtQueryValueKey(%ws) failed, error = 0x%x",
                awcACP,
                GetLastError());
    } else {
        LPWSTR pwszBuf = awchBuffer;

        /*
         * Parse the data.
         */
        while (pwszBuf != NULL && *pwszBuf != UNICODE_NULL) {
            WORD ch1,ch2;

            /*
             * Get Start Range value.
             */
            pwszBuf = SkipWhite(pwszBuf);
            ch1 = ConvertStringToHex(pwszBuf, &pwszBuf);

            pwszBuf = SkipWhite(pwszBuf);
            if (*pwszBuf != L'-') {
                RIPMSG0(RIP_WARNING, "GetSystemEUDCRangeW: Invalid format");
                iEntry = 0;
                goto Error;
            }

            /*
             * Get End Range value.
             */
            pwszBuf = SkipWhite(pwszBuf + 1);
            ch2 = ConvertStringToHex(pwszBuf, &pwszBuf);

            /*
             * Confirm the data sort order is correct.
             */
            if (ch1 > ch2) {
                RIPMSG0(RIP_WARNING, "GetSystemEUDCRangeW: Sort order is incorrect");
                iEntry = 0;
                goto Error;
            }

            /*
             * Move pointer to next.
             */
            pwszBuf = SkipWhite(pwszBuf);
            if (*pwszBuf == L',') {
                pwszBuf = SkipWhite(pwszBuf + 1);
            }

            /*
             * Above, if pwszBuf is NULL, we've reached the EOD.
             */
            iEntry++;

            /*
             * If caller buffer is large enough to store the data, store it.
             * Even if that's not the case, we have to continue to parse the
             * data to compute the number of entry.
             */

            /*
             * 3 - Because we have to store NULL as a mark of EOD.
             */
            if (cjSize >= 3) {
                *pwEUDCCharTable++ = ch1;
                *pwEUDCCharTable++ = ch2;
                cjSize -= 2;
            }
        }

        *pwEUDCCharTable = UNICODE_NULL;

        iEntry = iEntry * 2 + 1;
    }

Error:
    /*
     * Close registry handle.
     */
    UserAssert(hkRegistry != NULL);
    NtClose(hkRegistry);

    return iEntry;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\globals.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This module contains the global variables used by the
    console server DLL.

Author:

    Jerry Shea (jerrysh) 21-Sep-1993

Revision History:

--*/

extern CONSOLE_REGISTRY_INFO DefaultRegInfo;
extern PFONT_INFO FontInfo;

extern UINT       OEMCP;
extern UINT       WINDOWSCP;
extern HANDLE     ghInstance;
extern HICON      ghDefaultIcon;
extern HICON      ghDefaultSmIcon;
extern HCURSOR    ghNormalCursor;
extern CRITICAL_SECTION ConsoleHandleLock;
extern int        DialogBoxCount;
extern LPTHREAD_START_ROUTINE CtrlRoutine;  // client side ctrl-thread routine

// IME
extern LPTHREAD_START_ROUTINE ConsoleIMERoutine;  // client side console IME routine


extern BOOL FullScreenInitialized;
extern CRITICAL_SECTION ConsoleVDMCriticalSection;
extern PCONSOLE_INFORMATION ConsoleVDMOnSwitching;

extern DWORD      InputThreadTlsIndex;

extern int        MinimumWidthX;
extern SHORT      VerticalScrollSize;
extern SHORT      HorizontalScrollSize;
extern SHORT      VerticalClientToWindow;
extern SHORT      HorizontalClientToWindow;
extern BOOL       fOneTimeInitialized;
extern UINT       ConsoleOutputCP;
extern UINT       ProgmanHandleMessage;

extern DWORD      gExtendedEditKey;
extern BOOL       gfTrimLeadingZeros;
extern BOOL       gfEnableColorSelection;

extern BOOL       gfLoadConIme;

// FE
extern ULONG NumberOfFonts;

extern CRITICAL_SECTION gInputThreadMsgLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\menu.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    menu.h

Abstract:

    This module contains the definitions for console system menu

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

/*
 * IDs of various STRINGTABLE entries
 *
 */

#define msgNoFullScreen      0x1007
#define msgCmdLineF2         0x1008
#define msgCmdLineF4         0x1009
#define msgCmdLineF9         0x100A
#define msgSelectMode        0x100B
#define msgMarkMode          0x100C
#define msgScrollMode        0x100D

/* Menu Item strings */
#define cmCopy               0xFFF0
#define cmPaste              0xFFF1
#define cmMark               0xFFF2
#define cmScroll             0xFFF3
#define cmFind               0xFFF4
#define cmSelectAll          0xFFF5
#define cmEdit               0xFFF6
#define cmControl            0xFFF7
#define cmDefaults           0xFFF8

/*
 * MENU IDs
 *
 */
#define ID_WOMENU           500

/*
 * DIALOG IDs
 */
#define ID_FINDDLG          600
#define ID_FINDSTR          601
#define ID_FINDCASE         602
#define ID_FINDUP           603
#define ID_FINDDOWN         604
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\menu.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    menu.c

Abstract:

        This file implements the system menu management.

Author:

    Therese Stowell (thereses) Jan-24-1992 (swiped from Win3.1)

--*/

#include "precomp.h"
#pragma hdrstop


VOID
MyModifyMenuItem(
    IN PCONSOLE_INFORMATION Console,
    IN UINT ItemId
    )
/*++

   This routine edits the indicated control to one word. This is used to
        trim the Accelerator key text off of the end of the standard menu
        items because we don't support the accelerators.

--*/

{
    WCHAR ItemString[30];
    int ItemLength;
    MENUITEMINFO mii;

    ItemLength = LoadString(ghInstance,ItemId,ItemString,NELEM(ItemString));
    if (ItemLength == 0) {
        //DbgPrint("LoadString in MyModifyMenu failed %d\n",GetLastError());
        return;
    }

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STRING;
    mii.dwTypeData = ItemString;

    if (ItemId == SC_CLOSE) {
        mii.fMask |= MIIM_BITMAP;
        mii.hbmpItem = HBMMENU_POPUP_CLOSE;
    }

    SetMenuItemInfo(Console->hMenu, ItemId, FALSE, &mii);

}

VOID
InitSystemMenu(
    IN PCONSOLE_INFORMATION Console
    )
{
    WCHAR ItemString[30];
    int ItemLength;

    //
    // load the clipboard menu.
    //

    Console->hHeirMenu = LoadMenu(ghInstance, MAKEINTRESOURCE(ID_WOMENU));
    if (Console->hHeirMenu) {
        ItemLength = LoadString(ghInstance,cmEdit,ItemString,NELEM(ItemString));
        if (ItemLength == 0)
            RIPMSG1(RIP_WARNING, "LoadString 1 failed 0x%x", GetLastError());
    } else {
        RIPMSG1(RIP_WARNING, "LoadMenu 1 failed 0x%x", GetLastError());
    }

    //
    // Edit the accelerators off of the standard items.
    //

    MyModifyMenuItem(Console, SC_CLOSE);

    //
    // Append the clipboard menu to system menu.
    //

    if (!AppendMenu(Console->hMenu,
                    MF_POPUP | MF_STRING,
                    (ULONG_PTR)Console->hHeirMenu,
                    ItemString)) {
        RIPMSG1(RIP_WARNING, "AppendMenu 1 failed 0x%x", GetLastError());
    }

    //
    // Add other items to system menu
    //

    ItemLength = LoadString(ghInstance, cmDefaults, ItemString, ARRAY_SIZE(ItemString));
    if (ItemLength == 0)
        RIPMSG2(RIP_WARNING, "LoadString 0x%x failed 0x%x", cmDefaults, GetLastError());
    if (ItemLength) {
        if (!AppendMenu(Console->hMenu, MF_STRING, cmDefaults, ItemString)) {
            RIPMSG2(RIP_WARNING, "AppendMenu 0x%x failed 0x%x", cmDefaults, GetLastError());
        }
    }
    ItemLength = LoadString(ghInstance,cmControl,ItemString,NELEM(ItemString));
    if (ItemLength == 0)
        RIPMSG2(RIP_WARNING, "LoadString 0x%x failed 0x%x\n", cmControl, GetLastError());
    if (ItemLength) {
        if (!AppendMenu(Console->hMenu, MF_STRING, cmControl, ItemString)) {
            RIPMSG2(RIP_WARNING, "AppendMenu 0x%x failed 0x%x\n", cmControl, GetLastError());
        }
    }
}


VOID
InitializeMenu(
    IN PCONSOLE_INFORMATION Console
    )
/*++

    this initializes the system menu when a WM_INITMENU message
    is read.

--*/

{
    HMENU hMenu = Console->hMenu;
    HMENU hHeirMenu = Console->hHeirMenu;

    //
    // if we're in graphics mode, disable size menu
    //

    if (!(Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        EnableMenuItem(hMenu,SC_SIZE,MF_GRAYED);
    }

    //
    // if the console is iconic, disable Mark and Scroll.
    //

    if (Console->Flags & CONSOLE_IS_ICONIC) {
        EnableMenuItem(hHeirMenu,cmMark,MF_GRAYED);
        EnableMenuItem(hHeirMenu,cmScroll,MF_GRAYED);
    } else {

        //
        // if the console is not iconic
        //   if there are no scroll bars
        //       or we're in mark mode
        //       disable scroll
        //   else
        //       enable scroll
        //
        //   if we're in scroll mode
        //       disable mark
        //   else
        //       enable mark

        if ((Console->CurrentScreenBuffer->WindowMaximizedX &&
             Console->CurrentScreenBuffer->WindowMaximizedY) ||
             Console->Flags & CONSOLE_SELECTING) {
            EnableMenuItem(hHeirMenu,cmScroll,MF_GRAYED);
        } else {
            EnableMenuItem(hHeirMenu,cmScroll,MF_ENABLED);
        }
        if (Console->Flags & CONSOLE_SCROLLING) {
            EnableMenuItem(hHeirMenu,cmMark,MF_GRAYED);
        } else {
            EnableMenuItem(hHeirMenu,cmMark,MF_ENABLED);
        }
    }

    //
    // if we're selecting or scrolling, disable Paste.
    // otherwise enable it.
    //

    if (Console->Flags & (CONSOLE_SELECTING | CONSOLE_SCROLLING)) {
        EnableMenuItem(hHeirMenu,cmPaste,MF_GRAYED);
    } else {
        EnableMenuItem(hHeirMenu,cmPaste,MF_ENABLED);
    }

    //
    // if app has active selection, enable copy; else disabled
    //

    if (Console->Flags & CONSOLE_SELECTING &&
        Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
        EnableMenuItem(hHeirMenu,cmCopy,MF_ENABLED);
    } else {
        EnableMenuItem(hHeirMenu,cmCopy,MF_GRAYED);
    }

    //
    // disable close
    //

    if (Console->Flags & CONSOLE_DISABLE_CLOSE)
        EnableMenuItem(hMenu,SC_CLOSE,MF_GRAYED);
    else
        EnableMenuItem(hMenu,SC_CLOSE,MF_ENABLED);

    //
    // enable Move if not iconic
    //

    if (Console->Flags & CONSOLE_IS_ICONIC) {
        EnableMenuItem(hMenu,SC_MOVE,MF_GRAYED);
    } else {
        EnableMenuItem(hMenu,SC_MOVE,MF_ENABLED);
    }

    //
    // enable Settings if not already doing it
    //

    if (Console->hWndProperties && IsWindow(Console->hWndProperties)) {
        EnableMenuItem(hMenu,cmControl,MF_GRAYED);
    } else {
        EnableMenuItem(hMenu,cmControl,MF_ENABLED);
        Console->hWndProperties = NULL;
    }
}

VOID
SetWinText(
    IN PCONSOLE_INFORMATION Console,
    IN UINT wID,
    IN BOOL Add
    )

/*++

    This routine adds or removes the name to or from the
    beginning of the window title.  The possible names
    are "Scroll", "Mark", "Paste", and "Copy".

--*/

{
    WCHAR TextBuf[256];
    PWCHAR TextBufPtr;
    int TextLength;
    int NameLength;
    WCHAR NameString[20];

    NameLength = LoadString(ghInstance,wID,NameString,
                                  sizeof(NameString)/sizeof(WCHAR));
    if (Add) {
        RtlCopyMemory(TextBuf,NameString,NameLength*sizeof(WCHAR));
        TextBuf[NameLength] = ' ';
        TextBufPtr = TextBuf + NameLength + 1;
    } else {
        TextBufPtr = TextBuf;
    }
    TextLength = GetWindowText(Console->hWnd,
                                  TextBufPtr,
                                  sizeof(TextBuf)/sizeof(WCHAR)-NameLength-1);
    if (TextLength == 0)
        return;
    if (Add) {
        TextBufPtr = TextBuf;
    } else {
        /*
         * The window title might have already been reset, so make sure
         * the name is there before trying to remove it.
         */
        if (wcsncmp(NameString, TextBufPtr, NameLength) != 0)
            return;
        TextBufPtr = TextBuf + NameLength + 1;
    }
    SetWindowText(Console->hWnd,TextBufPtr);
}


VOID
PropertiesDlgShow(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL fCurrent
    )

/*++

    Displays the properties dialog and updates the window state,
    if necessary.

--*/

{
    HANDLE hSection = NULL;
    HANDLE hClientSection = NULL;
    HANDLE hThread;
    SIZE_T ulViewSize;
    LARGE_INTEGER li;
    NTSTATUS Status;
    PCONSOLE_STATE_INFO pStateInfo;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PSCREEN_INFORMATION ScreenInfo;
    LPTHREAD_START_ROUTINE MyPropRoutine;

    /*
     * Map the shared memory block handle into the client side process's
     * address space.
     */
    ProcessHandleRecord = CONTAINING_RECORD(Console->ProcessHandleList.Blink,
                                            CONSOLE_PROCESS_HANDLE,
                                            ListLink);
    /*
     * For global properties pass in hWnd for the hClientSection
     */
    if (!fCurrent) {
        hClientSection = Console->hWnd;
        goto PropCallback;
    }

    /*
     * Create a shared memory block.
     */
    li.QuadPart = sizeof(CONSOLE_STATE_INFO) + Console->OriginalTitleLength;
    Status = NtCreateSection(&hSection,
                             SECTION_ALL_ACCESS,
                             NULL,
                             &li,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x creating file mapping", Status);
        return;
    }

    /*
     * Get a pointer to the shared memory block.
     */
    pStateInfo = NULL;
    ulViewSize = 0;
    Status = NtMapViewOfSection(hSection,
                                NtCurrentProcess(),
                                &pStateInfo,
                                0,
                                0,
                                NULL,
                                &ulViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x mapping view of file", Status);
        NtClose(hSection);
        return;
    }

    /*
     * Fill in the shared memory block with the current values.
     */
    ScreenInfo = Console->CurrentScreenBuffer;
    pStateInfo->Length = li.LowPart;
    pStateInfo->ScreenBufferSize = ScreenInfo->ScreenBufferSize;
    pStateInfo->WindowSize.X = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    pStateInfo->WindowSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    pStateInfo->WindowPosX = Console->WindowRect.left;
    pStateInfo->WindowPosY = Console->WindowRect.top;
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        pStateInfo->FontSize = SCR_FONTSIZE(ScreenInfo);
        pStateInfo->FontFamily = SCR_FAMILY(ScreenInfo);
        pStateInfo->FontWeight = SCR_FONTWEIGHT(ScreenInfo);
        wcscpy(pStateInfo->FaceName, SCR_FACENAME(ScreenInfo));
#if defined(FE_SB)
// if TT font has external leading, the Size.Y <> SizeWant.Y
// if we still pass actual Size.Y to console.cpl to query font,
// it will be incorrect. Jun-26-1996

        if (CONSOLE_IS_DBCS_ENABLED() &&
            TM_IS_TT_FONT(SCR_FAMILY(ScreenInfo)))
        {
            if (SCR_FONTNUMBER(ScreenInfo) < NumberOfFonts) {
                pStateInfo->FontSize = FontInfo[SCR_FONTNUMBER(ScreenInfo)].SizeWant;
            }
        }
#endif
        pStateInfo->CursorSize = ScreenInfo->BufferInfo.TextInfo.CursorSize;
    }
    pStateInfo->FullScreen = Console->FullScreenFlags & CONSOLE_FULLSCREEN;
    pStateInfo->QuickEdit = Console->Flags & CONSOLE_QUICK_EDIT_MODE;
    pStateInfo->AutoPosition = Console->Flags & CONSOLE_AUTO_POSITION;
    pStateInfo->InsertMode = Console->InsertMode;
    pStateInfo->ScreenAttributes = ScreenInfo->Attributes;
    pStateInfo->PopupAttributes = ScreenInfo->PopupAttributes;
    pStateInfo->HistoryBufferSize = Console->CommandHistorySize;
    pStateInfo->NumberOfHistoryBuffers = Console->MaxCommandHistories;
    pStateInfo->HistoryNoDup = Console->Flags & CONSOLE_HISTORY_NODUP;
    RtlCopyMemory(pStateInfo->ColorTable,
                  Console->ColorTable,
                  sizeof(Console->ColorTable));
    pStateInfo->hWnd = Console->hWnd;
    wcscpy(pStateInfo->ConsoleTitle, Console->OriginalTitle);
#if defined(FE_SB)
    pStateInfo->CodePage = Console->OutputCP;
#endif
    NtUnmapViewOfSection(NtCurrentProcess(), pStateInfo);

    Status = NtDuplicateObject(NtCurrentProcess(),
                               hSection,
                               ProcessHandleRecord->ProcessHandle,
                               &hClientSection,
                               0,
                               0,
                               DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x mapping handle to client", Status);
        NtClose(hSection);
        return;
    }

PropCallback:
    /*
     * Get a pointer to the client-side properties routine.
     */
    MyPropRoutine = ProcessHandleRecord->PropRoutine;
    ASSERT(MyPropRoutine);

    /*
     * Call back into the client process to spawn the properties dialog.
     */
    UnlockConsole(Console);
    hThread = InternalCreateCallbackThread(ProcessHandleRecord->ProcessHandle,
                                           (ULONG_PTR)MyPropRoutine,
                                           (ULONG_PTR)hClientSection);
    if (!hThread) {
        RIPMSG1(RIP_WARNING, "CreateRemoteThread failed 0x%x", GetLastError());
    }
    LockConsole(Console);

    /*
     * Close any open handles and free allocated memory.
     */
    if (hThread)
        NtClose(hThread);
    if (hSection)
        NtClose(hSection);

    return;
}


VOID
PropertiesUpdate(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE hClientSection
    )

/*++

    Updates the console state from information sent by the properties
    dialog box.

--*/

{
    HANDLE hSection;
    SIZE_T ulViewSize;
    NTSTATUS Status;
    PCONSOLE_STATE_INFO pStateInfo;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PSCREEN_INFORMATION ScreenInfo;
    ULONG FontIndex;
    WINDOWPLACEMENT wp;
    COORD NewSize;
    WINDOW_LIMITS WindowLimits;

    /*
     * Map the shared memory block handle into our address space.
     */
    ProcessHandleRecord = CONTAINING_RECORD(Console->ProcessHandleList.Blink,
                                            CONSOLE_PROCESS_HANDLE,
                                            ListLink);
    Status = NtDuplicateObject(ProcessHandleRecord->ProcessHandle,
                               hClientSection,
                               NtCurrentProcess(),
                               &hSection,
                               0,
                               0,
                               DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x mapping client handle", Status);
        return;
    }

    /*
     * Get a pointer to the shared memory block.
     */
    pStateInfo = NULL;
    ulViewSize = 0;
    Status = NtMapViewOfSection(hSection,
                                NtCurrentProcess(),
                                &pStateInfo,
                                0,
                                0,
                                NULL,
                                &ulViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READONLY);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error %x mapping view of file", Status);
        NtClose(hSection);
        return;
    }

    /*
     * Verify the size of the shared memory block.
     */
    if (ulViewSize < sizeof(CONSOLE_STATE_INFO)) {
        RIPMSG0(RIP_WARNING, "sizeof(hSection) < sizeof(CONSOLE_STATE_INFO)");
        NtUnmapViewOfSection(NtCurrentProcess(), pStateInfo);
        NtClose(hSection);
        return;
    }

    ScreenInfo = Console->CurrentScreenBuffer;
#if defined(FE_SB)
    if (Console->OutputCP != pStateInfo->CodePage)
    {
        UINT CodePage = Console->OutputCP;

        Console->OutputCP = pStateInfo->CodePage;
        if (CONSOLE_IS_DBCS_ENABLED())
            Console->fIsDBCSOutputCP = !!IsAvailableFarEastCodePage(Console->OutputCP);
        else
            Console->fIsDBCSOutputCP = FALSE;
        SetConsoleCPInfo(Console,TRUE);
#if defined(FE_IME)
        SetImeOutputCodePage(Console, ScreenInfo, CodePage);
#endif // FE_IME
    }
    if (Console->CP != pStateInfo->CodePage)
    {
        UINT CodePage = Console->CP;

        Console->CP = pStateInfo->CodePage;
        if (CONSOLE_IS_DBCS_ENABLED())
            Console->fIsDBCSCP = !!IsAvailableFarEastCodePage(Console->CP);
        else
            Console->fIsDBCSCP = FALSE;
        SetConsoleCPInfo(Console,FALSE);
#if defined(FE_IME)
        SetImeCodePage(Console);
#endif // FE_IME
    }
#endif // FE_SB

    /*
     * Update the console state from the supplied values.
     */
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED) &&
        (pStateInfo->ScreenBufferSize.X != ScreenInfo->ScreenBufferSize.X ||
         pStateInfo->ScreenBufferSize.Y != ScreenInfo->ScreenBufferSize.Y)) {

        PCOOKED_READ_DATA CookedReadData = Console->lpCookedReadData;

        if (CookedReadData && CookedReadData->NumberOfVisibleChars) {
            DeleteCommandLine(CookedReadData, FALSE);
        }
        ResizeScreenBuffer(ScreenInfo,
                           pStateInfo->ScreenBufferSize,
                           TRUE);
        if (CookedReadData && CookedReadData->NumberOfVisibleChars) {
            RedrawCommandLine(CookedReadData);
        }
    }
#if !defined(FE_SB)
    FontIndex = FindCreateFont(pStateInfo->FontFamily,
                               pStateInfo->FaceName,
                               pStateInfo->FontSize,
                               pStateInfo->FontWeight);
#else
    FontIndex = FindCreateFont(pStateInfo->FontFamily,
                               pStateInfo->FaceName,
                               pStateInfo->FontSize,
                               pStateInfo->FontWeight,
                               pStateInfo->CodePage);
#endif

#if defined(FE_SB)
#if defined(i386)
    if (! (Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
    }
    else {
        ChangeDispSettings(Console, Console->hWnd, 0);
        SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
        ConvertToFullScreen(Console);
        ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
    }
#else // i386
    SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
#endif
#else // FE_SB
    SetScreenBufferFont(ScreenInfo, FontIndex);
#endif // FE_SB
    SetCursorInformation(ScreenInfo,
                         pStateInfo->CursorSize,
                         ScreenInfo->BufferInfo.TextInfo.CursorVisible);

    GetWindowLimits(ScreenInfo, &WindowLimits);
    NewSize.X = min(pStateInfo->WindowSize.X, WindowLimits.MaximumWindowSize.X);
    NewSize.Y = min(pStateInfo->WindowSize.Y, WindowLimits.MaximumWindowSize.Y);
    if (NewSize.X != CONSOLE_WINDOW_SIZE_X(ScreenInfo) ||
        NewSize.Y != CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) {
        wp.length = sizeof(wp);
        GetWindowPlacement(Console->hWnd, &wp);
        wp.rcNormalPosition.right += (NewSize.X - CONSOLE_WINDOW_SIZE_X(ScreenInfo)) *
                            SCR_FONTSIZE(ScreenInfo).X;
        wp.rcNormalPosition.bottom += (NewSize.Y - CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) *
                             SCR_FONTSIZE(ScreenInfo).Y;
        SetWindowPlacement(Console->hWnd, &wp);
    }

#ifdef i386
    if (FullScreenInitialized && ! GetSystemMetrics(SM_REMOTESESSION)) {
        if (pStateInfo->FullScreen == FALSE) {
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                ConvertToWindowed(Console);
#if defined(FE_SB)
                /*
                 * Should not sets 0 always.
                 * because exist CONSOLE_FULLSCREEN_HARDWARE bit by avobe
                 *   else {
                 *       ChangeDispSettings(Console, Console->hWnd, 0);
                 *       SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
                 *       ConvertToFullScreen(Console);
                 *       ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
                 *   }
                 * block.
                 *
                 * This block enable as follows:
                 *   1. console window is full screen
                 *   2. open property by ALT+SPACE
                 *   3. changes window mode by settings.
                 */
                Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;
#else
                ASSERT(!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE));
                Console->FullScreenFlags = 0;
#endif

                ChangeDispSettings(Console, Console->hWnd, 0);
            }
        } else {
            if (Console->FullScreenFlags == 0) {
                ConvertToFullScreen(Console);
                Console->FullScreenFlags |= CONSOLE_FULLSCREEN;

                ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
            }
        }
    }
#endif
    if (pStateInfo->QuickEdit) {
        Console->Flags |= CONSOLE_QUICK_EDIT_MODE;
    } else {
        Console->Flags &= ~CONSOLE_QUICK_EDIT_MODE;
    }
    if (pStateInfo->AutoPosition) {
        Console->Flags |= CONSOLE_AUTO_POSITION;
    } else {
        Console->Flags &= ~CONSOLE_AUTO_POSITION;
        SetWindowPos(Console->hWnd, NULL,
                        pStateInfo->WindowPosX,
                        pStateInfo->WindowPosY,
                        0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }
    if (Console->InsertMode != pStateInfo->InsertMode) {
        SetCursorMode(ScreenInfo, FALSE);
        Console->InsertMode = (pStateInfo->InsertMode != FALSE);
#ifdef FE_SB
        if (Console->lpCookedReadData) {
            ((PCOOKED_READ_DATA)Console->lpCookedReadData)->InsertMode = Console->InsertMode;
        }
#endif
    }

    RtlCopyMemory(Console->ColorTable,
                  pStateInfo->ColorTable,
                  sizeof(Console->ColorTable));
    SetScreenColors(ScreenInfo,
                    pStateInfo->ScreenAttributes,
                    pStateInfo->PopupAttributes,
                    TRUE);

    ResizeCommandHistoryBuffers(Console, pStateInfo->HistoryBufferSize);
    Console->MaxCommandHistories = (SHORT)pStateInfo->NumberOfHistoryBuffers;
    if (pStateInfo->HistoryNoDup) {
        Console->Flags |= CONSOLE_HISTORY_NODUP;
    } else {
        Console->Flags &= ~CONSOLE_HISTORY_NODUP;
    }

#if defined(FE_IME)
    SetUndetermineAttribute(Console) ;
#endif

    NtUnmapViewOfSection(NtCurrentProcess(), pStateInfo);
    NtClose(hSection);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\link.c ===
//---------------------------------------------------------------------------
//
// link.c       link management routines (reading, etc.)
//
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//---------------------------------------------------------------------------



#include "precomp.h"
#pragma hdrstop


DWORD
GetTitleFromLinkName(
    IN  LPWSTR szLinkName,
    OUT LPWSTR szTitle
    )
/*++

Routine Description:

    This routine returns the title (i.e., display name of the link) in szTitle,
    and the number of bytes (not chars) in szTitle.

Arguments:

    szLinkName - fully qualified path to link file
    szTitle    - pointer to buffer to contain title (display name) of the link

    i.e.:
    "C:\nt\desktop\A Link File Name.lnk" --> "A Link File Name"

Return Value:

    number of bytes copied to szTitle

--*/
{
    DWORD dwLen;
    LPWSTR pLnk, pDot;
    LPWSTR pPath = szLinkName;

    ASSERT(szLinkName);

    // find filename at end of fully qualified link name and point pLnk to it
    for (pLnk = pPath; *pPath; pPath++)
    {
        if ( (pPath[0] == L'\\' || pPath[0] == L':') &&
              pPath[1] &&
             (pPath[1] != L'\\')
            )
            pLnk = pPath + 1;
    }

    // find extension (.lnk)
    pPath = pLnk;
    for (pDot = NULL; *pPath; pPath++)
    {
        switch (*pPath) {
        case L'.':
            pDot = pPath;       // remember the last dot
            break;
        case L'\\':
        case L' ':              // extensions can't have spaces
            pDot = NULL;        // forget last dot, it was in a directory
            break;
        }
    }

    // if we found the extension, pDot points to it, if not, pDot
    // is NULL.

    if (pDot)
    {
        dwLen = (ULONG)((pDot - pLnk) * sizeof(WCHAR));
    }
    else
    {
        dwLen = lstrlenW(pLnk) * sizeof(WCHAR);
    }
    dwLen = min(dwLen, MAX_TITLE_LENGTH);

    RtlCopyMemory(szTitle, pLnk, dwLen);

    return dwLen;
}


BOOL ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode )
{
    USHORT cch;
    DWORD  dwBytesRead;
    BOOL   fResult = TRUE;

    if (bUnicode)
    {
        LPWSTR lpWStr;

        fResult &= ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL );
        lpWStr = ConsoleHeapAlloc(HEAP_ZERO_MEMORY, (cch + 1) * sizeof(WCHAR));
        if (lpWStr) {
            fResult &= ReadFile( hFile, (LPVOID)lpWStr, cch*sizeof(WCHAR), &dwBytesRead, NULL );
            lpWStr[cch] = L'\0';
        }
        *(LPWSTR *)lpVoid = lpWStr;
    } else {
        LPSTR lpStr;

        fResult &= ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL );
        lpStr = ConsoleHeapAlloc(HEAP_ZERO_MEMORY, cch + 1);
        if (lpStr) {
            fResult &= ReadFile( hFile, (LPVOID)lpStr, cch, &dwBytesRead, NULL );
            lpStr[cch] = '\0';
        }
        *(LPSTR *)lpVoid = lpStr;
    }

    return fResult;

}


BOOL LoadLink( LPWSTR pszLinkName, CShellLink * this )
{
    HANDLE hFile;
    DWORD dwBytesRead, cbSize, cbTotal, cbToRead;
    BOOL fResult = TRUE;
    LPSTR pTemp = NULL;

    // Try to open the file
    hFile = CreateFile(pszLinkName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // Now, read out data...

    fResult = ReadFile( hFile, (LPVOID)&this->sld, sizeof(this->sld), &dwBytesRead, NULL );
    fResult &= ((dwBytesRead == sizeof(this->sld)) && (this->sld.cbSize == sizeof(this->sld)));
    if (!fResult) {
        // This is a bad .lnk file. Bail.
        goto ErrorExit;
    }

    // read all of the members

    if (this->sld.dwFlags & SLDF_HAS_ID_LIST)
    {
        // Read the size of the IDLIST
        cbSize = 0; // need to zero out to get HIWORD 0 'cause USHORT is only 2 bytes
        fResult &= ReadFile( hFile, (LPVOID)&cbSize, sizeof(USHORT), &dwBytesRead, NULL );
        fResult &= (dwBytesRead == sizeof(USHORT));
        if (cbSize)
        {
            fResult &=
                (SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT)!=0xFFFFFFFF);
        }
        else
        {
            goto ErrorExit;
        }
    }

    if (this->sld.dwFlags & (SLDF_HAS_LINK_INFO))
    {

        fResult &= ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL );
        fResult &= (dwBytesRead == sizeof(cbSize));
        if (cbSize >= sizeof(cbSize))
        {
            cbSize -= sizeof(cbSize);
            fResult &=
                (SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT)!=0xFFFFFFFF);
        }

    }

    if (this->sld.dwFlags & SLDF_HAS_NAME)
        fResult &= ReadString( hFile, &this->pszName, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_RELPATH)
        fResult &= ReadString( hFile, &this->pszRelPath, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_WORKINGDIR)
        fResult &= ReadString( hFile, &this->pszWorkingDir, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_ARGS)
        fResult &= ReadString( hFile, &this->pszArgs, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_ICONLOCATION)
        fResult &= ReadString( hFile, &this->pszIconLocation, this->sld.dwFlags & SLDF_UNICODE);

    // Read in extra data sections
    this->pExtraData = NULL;
    cbTotal = 0;
    while (TRUE)
    {

        LPSTR pReadData = NULL;

        cbSize = 0;
        fResult &= ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL );

        if (cbSize < sizeof(cbSize))
            break;

        if (pTemp)
        {
            pTemp = (void *)ConsoleHeapReAlloc(
                                         HEAP_ZERO_MEMORY,
                                         this->pExtraData,
                                         cbTotal + cbSize + sizeof(DWORD)
                                        );
            if (pTemp)
            {
                this->pExtraData = pTemp;
            }
        }
        else
        {
            this->pExtraData = pTemp = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, cbTotal + cbSize + sizeof(DWORD) );

        }

        if (!pTemp)
            break;

        cbToRead = cbSize - sizeof(cbSize);
        pReadData = pTemp + cbTotal;

        fResult &= ReadFile( hFile, (LPVOID)(pReadData + sizeof(cbSize)), cbToRead, &dwBytesRead, NULL );
        if (dwBytesRead == cbToRead) {
            // got all of the extra data, comit it
            *((UNALIGNED DWORD *)pReadData) = cbSize;
            cbTotal += cbSize;
        } else {
            break;
        }
    }

ErrorExit:
    CloseHandle( hFile );

    return fResult;

}


DWORD GetLinkProperties( LPWSTR pszLinkName, LPVOID lpvBuffer, UINT cb )
{
    CShellLink mld;
    DWORD fResult;
    LPNT_CONSOLE_PROPS lpExtraData;
    DWORD dwSize = 0;

    // Zero out structure on the stack
    RtlZeroMemory( &mld, sizeof(mld) );

    // Load link data
    if (!LoadLink( pszLinkName, &mld )) {
        RIPMSG1(RIP_WARNING, "LoadLink %ws failed", pszLinkName);
        fResult = LINK_NOINFO;
        goto Cleanup;
    }

    // Check return buffer -- is it big enough?
    ASSERT(cb >= sizeof( LNKPROPNTCONSOLE));

    // Zero out callers buffer
    RtlZeroMemory( lpvBuffer, cb );

    // Copy relevant shell link data into caller's buffer
    if (mld.pszName)
        lstrcpy( ((LPLNKPROPNTCONSOLE)lpvBuffer)->pszName, mld.pszName );
    if (mld.pszIconLocation)
        lstrcpy( ((LPLNKPROPNTCONSOLE)lpvBuffer)->pszIconLocation, mld.pszIconLocation );
    ((LPLNKPROPNTCONSOLE)lpvBuffer)->uIcon = mld.sld.iIcon;
    ((LPLNKPROPNTCONSOLE)lpvBuffer)->uShowCmd = mld.sld.iShowCmd;
    ((LPLNKPROPNTCONSOLE)lpvBuffer)->uHotKey = mld.sld.wHotkey;
    fResult = LINK_SIMPLEINFO;

    // Find console properties in extra data section
    for( lpExtraData = (LPNT_CONSOLE_PROPS)mld.pExtraData;
         lpExtraData && lpExtraData->cbSize;
         (LPBYTE)lpExtraData += dwSize
        )
    {
        dwSize = lpExtraData->cbSize;
        if (dwSize)
        {
            if (lpExtraData->dwSignature == NT_CONSOLE_PROPS_SIG)
            {

                RtlCopyMemory( &((LPLNKPROPNTCONSOLE)lpvBuffer)->console_props,
                               lpExtraData,
                               sizeof( NT_CONSOLE_PROPS )
                             );
                fResult = LINK_FULLINFO;
#if !defined(FE_SB)
                break;
#endif
            }
#if defined(FE_SB)
            if (lpExtraData->dwSignature == NT_FE_CONSOLE_PROPS_SIG)
            {
                LPNT_FE_CONSOLE_PROPS lpFEExtraData = (LPNT_FE_CONSOLE_PROPS)lpExtraData;

                RtlCopyMemory( &((LPLNKPROPNTCONSOLE)lpvBuffer)->fe_console_props,
                               lpFEExtraData,
                               sizeof( NT_FE_CONSOLE_PROPS )
                             );
            }
#endif
        }
    }

Cleanup:
    if (mld.pszName)
        ConsoleHeapFree( mld.pszName );
    if (mld.pszRelPath)
        ConsoleHeapFree( mld.pszRelPath );
    if (mld.pszWorkingDir)
        ConsoleHeapFree( mld.pszWorkingDir );
    if (mld.pszArgs)
        ConsoleHeapFree( mld.pszArgs );
    if (mld.pszIconLocation)
        ConsoleHeapFree( mld.pszIconLocation );
    if (mld.pExtraData)
        ConsoleHeapFree( mld.pExtraData );

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\handle.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This file manages console and io handles.

Author:

    Therese Stowell (thereses) 16-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// array of pointers to consoles
//

PCONSOLE_INFORMATION  InitialConsoleHandles[CONSOLE_INITIAL_CONSOLES];
PCONSOLE_INFORMATION  *ConsoleHandles;
ULONG NumberOfConsoleHandles;

CRITICAL_SECTION ConsoleHandleLock; // serializes console handle table access

ULONG ConsoleId = 47; // unique number identifying console

//
// Macros to manipulate console handles
//

#define HandleFromIndex(i)  (LongToHandle(((i & 0xFFFF) | (ConsoleId++ << 16))))
#define IndexFromHandle(h)  ((USHORT)((ULONG_PTR)h & 0xFFFF))
#define ConsoleHandleTableLocked() (ConsoleHandleLock.OwningThread == NtCurrentTeb()->ClientId.UniqueThread)

VOID
AddProcessToList(
    IN OUT PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_PROCESS_HANDLE ProcessHandleRecord,
    IN HANDLE ProcessHandle
    );

VOID
FreeInputHandle(
    IN PHANDLE_DATA HandleData
    );


#if DBG
VOID RefConsole(
    PCONSOLE_INFORMATION Console)
{
    PCONSOLE_REF_NODE pNode;

    UserAssert(Console->RefCount < 0xFFFFFFFF);
    Console->RefCount += 1;

    pNode = ConsoleHeapAlloc(TMP_TAG, sizeof(CONSOLE_REF_NODE));
    if (pNode == NULL) {
        return;
    }

    RtlZeroMemory(pNode, sizeof(CONSOLE_REF_NODE));
    RtlWalkFrameChain(pNode->pStackTrace, ARRAY_SIZE(pNode->pStackTrace), 0);
    pNode->bRef = TRUE;
    pNode->pNext = Console->pRefNodes;
    Console->pRefNodes = pNode;
}

VOID DerefConsole(
    PCONSOLE_INFORMATION Console)
{
    PCONSOLE_REF_NODE pNode;

    UserAssert(Console->RefCount > 0);
    Console->RefCount -= 1;

    pNode = ConsoleHeapAlloc(TMP_TAG, sizeof(CONSOLE_REF_NODE));
    if (pNode == NULL) {
        return;
    }

    RtlZeroMemory(pNode, sizeof(CONSOLE_REF_NODE));
    RtlWalkFrameChain(pNode->pStackTrace, ARRAY_SIZE(pNode->pStackTrace), 0);
    pNode->bRef = FALSE;
    pNode->pNext = Console->pRefNodes;
    Console->pRefNodes = pNode;
}
#endif

NTSTATUS
InitializeConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine initializes the global console handle table.

Arguments:

    none.

Return Value:

    none.

--*/

{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSectionAndSpinCount(&ConsoleHandleLock,
                                                      0x80000000);

    RtlZeroMemory(InitialConsoleHandles, sizeof(InitialConsoleHandles));
    ConsoleHandles = InitialConsoleHandles;
    NumberOfConsoleHandles = NELEM(InitialConsoleHandles);

    return Status;
}


#if DBG

VOID
LockConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine locks the global console handle table. It also verifies
    that we're not in the USER critical section. This is necessary to
    prevent potential deadlocks. This routine is only defined in debug
    builds.

Arguments:

    none.

Return Value:

    none.

--*/

{
    RtlEnterCriticalSection(&ConsoleHandleLock);
}


VOID
UnlockConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine unlocks the global console handle table. This routine
    is only defined in debug builds.

Arguments:

    none.

Return Value:

    none.

--*/

{
    RtlLeaveCriticalSection(&ConsoleHandleLock);
}


VOID
LockConsole(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine locks the console. This routine is only defined
    in debug builds.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ASSERT(!ConsoleHandleTableLocked());
    RtlEnterCriticalSection(&(Console->ConsoleLock));
    ASSERT(ConsoleLocked(Console));
}

#endif // DBG


NTSTATUS
DereferenceConsoleHandle(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console)

/*++

Routine Description:

    This routine converts a console handle value into a pointer to the
    console data structure.

Arguments:

    ConsoleHandle - console handle to convert.

    Console - On output, contains pointer to the console data structure.

Return Value:

    none.

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    ULONG i;

    ASSERT(ConsoleHandleTableLocked());

    i = IndexFromHandle(ConsoleHandle);
    if ((i >= NumberOfConsoleHandles) ||
        ((*Console = ConsoleHandles[i]) == NULL) ||
        ((*Console)->ConsoleHandle != ConsoleHandle)) {
        *Console = NULL;
        return STATUS_INVALID_HANDLE;
    }
    if ((*Console)->Flags & CONSOLE_TERMINATING) {
        *Console = NULL;
        return STATUS_PROCESS_IS_TERMINATING;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GrowConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine grows the console handle table.

Arguments:

    none

Return Value:

--*/

{
    PCONSOLE_INFORMATION *NewTable;
    PCONSOLE_INFORMATION *OldTable;
    ULONG i;
    ULONG MaxConsoleHandles;

    ASSERT(ConsoleHandleTableLocked());

    MaxConsoleHandles = NumberOfConsoleHandles + CONSOLE_CONSOLE_HANDLE_INCREMENT;
    ASSERT(MaxConsoleHandles <= 0xFFFF);
    NewTable = ConsoleHeapAlloc(HANDLE_TAG, MaxConsoleHandles * sizeof(PCONSOLE_INFORMATION));
    if (NewTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlCopyMemory(NewTable, ConsoleHandles,
                  NumberOfConsoleHandles * sizeof(PCONSOLE_INFORMATION));
    for (i=NumberOfConsoleHandles;i<MaxConsoleHandles;i++) {
        NewTable[i] = NULL;
    }
    OldTable = ConsoleHandles;
    ConsoleHandles = NewTable;
    NumberOfConsoleHandles = MaxConsoleHandles;
    if (OldTable != InitialConsoleHandles) {
        ConsoleHeapFree(OldTable);
    }
    return STATUS_SUCCESS;
}


NTSTATUS
AllocateConsoleHandle(
    OUT PHANDLE Handle)

/*++

Routine Description:

    This routine allocates a console handle from the global table.

Arguments:

    Handle - Pointer to store handle in.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    ULONG i;
    NTSTATUS Status;

    ASSERT(ConsoleHandleTableLocked());

    //
    // have to start allocation at 1 because 0 indicates no console handle
    // in ConDllInitialize.
    //

    for (i=1;i<NumberOfConsoleHandles;i++) {
        if (ConsoleHandles[i] == NULL) {
            ConsoleHandles[i] = (PCONSOLE_INFORMATION) CONSOLE_HANDLE_ALLOCATED;
            *Handle = HandleFromIndex(i);
            return STATUS_SUCCESS;
        }
    }

    //
    // grow console handle table
    //

    Status = GrowConsoleHandleTable();
    if (!NT_SUCCESS(Status))
        return Status;
    for ( ;i<NumberOfConsoleHandles;i++) {
        if (ConsoleHandles[i] == NULL) {
            ConsoleHandles[i] = (PCONSOLE_INFORMATION) CONSOLE_HANDLE_ALLOCATED;
            *Handle = HandleFromIndex(i);
            return STATUS_SUCCESS;
        }
    }
    ASSERT (FALSE);
    return STATUS_UNSUCCESSFUL;
}



NTSTATUS
FreeConsoleHandle(
    IN HANDLE Handle)

/*++

Routine Description:

    This routine frees a console handle from the global table.

Arguments:

    Handle - Handle to free.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    ULONG i;

    ASSERT(ConsoleHandleTableLocked());

    ASSERT (Handle != NULL);
    i = IndexFromHandle(Handle);
    if ((i >= NumberOfConsoleHandles) || (ConsoleHandles[i] == NULL)) {
        ASSERT (FALSE);
    } else {
        ConsoleHandles[i] = NULL;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
ValidateConsole(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine ensures that the given console pointer is valid.

Arguments:

    Console - Console pointer to validate.

--*/

{
    ULONG i;

    if (Console != NULL) {
        for (i = 0; i < NumberOfConsoleHandles; i++) {
            if (ConsoleHandles[i] == Console) {
                return STATUS_SUCCESS;
            }
        }
    }
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
InitializeIoHandleTable(
    IN OUT PCONSOLE_INFORMATION Console,
    OUT PCONSOLE_PER_PROCESS_DATA ProcessData,
    OUT PHANDLE StdIn,
    OUT PHANDLE StdOut,
    OUT PHANDLE StdErr)

/*++

Routine Description:

    This routine initializes a process's handle table for the first
    time (there is no parent process).  It also sets up stdin, stdout,
    and stderr.

Arguments:

    Console - Pointer to console information structure.

    ProcessData - Pointer to per process data structure.

    Stdin - Pointer in which to return StdIn handle.

    StdOut - Pointer in which to return StdOut handle.

    StdErr - Pointer in which to return StdErr handle.

Return Value:

--*/

{
    ULONG i;
    HANDLE Handle;
    NTSTATUS Status;
    PHANDLE_DATA HandleData, InputHandleData;

    //
    // HandleTablePtr gets set up by ConsoleAddProcessRoutine.
    // it will be != to HandleTable if the new process was created
    // using "start xxx" at the command line and cmd.exe has >
    // CONSOLE_INITIAL_IO_HANDLES.
    //

    if (ProcessData->HandleTablePtr != ProcessData->HandleTable) {
        UserAssert(ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES);
        ConsoleHeapFree(ProcessData->HandleTablePtr);
        ProcessData->HandleTablePtr = ProcessData->HandleTable;
    }

    for (i = 0;i < CONSOLE_INITIAL_IO_HANDLES; i++) {
        ProcessData->HandleTable[i].HandleType = CONSOLE_FREE_HANDLE;
    }

    ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;

    //
    // Set up stdin, stdout, and stderr.
    //
    // stdin
    //

    Status = AllocateIoHandle(ProcessData, CONSOLE_INPUT_HANDLE, &Handle);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandleNoCheck(ProcessData, Handle, &InputHandleData);
    UserAssert(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!InitializeInputHandle(InputHandleData, &Console->InputBuffer)) {
        return STATUS_NO_MEMORY;
    }
    InputHandleData->HandleType |= CONSOLE_INHERITABLE;

    Status = ConsoleAddShare(GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Console->InputBuffer.ShareAccess,
                             InputHandleData);
    UserAssert(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    *StdIn = INDEX_TO_HANDLE(Handle);

    //
    // stdout
    //

    Status = AllocateIoHandle(ProcessData, CONSOLE_OUTPUT_HANDLE, &Handle);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = DereferenceIoHandleNoCheck(ProcessData, Handle, &HandleData);
    UserAssert(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    InitializeOutputHandle(HandleData,Console->CurrentScreenBuffer);
    HandleData->HandleType |= CONSOLE_INHERITABLE;
    Status = ConsoleAddShare(GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Console->ScreenBuffers->ShareAccess,
                             HandleData);
    UserAssert(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    *StdOut = INDEX_TO_HANDLE(Handle);

    //
    // stderr
    //

    Status = AllocateIoHandle(ProcessData, CONSOLE_OUTPUT_HANDLE, &Handle);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = DereferenceIoHandleNoCheck(ProcessData, Handle, &HandleData);
    UserAssert(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    InitializeOutputHandle(HandleData,Console->CurrentScreenBuffer);
    HandleData->HandleType |= CONSOLE_INHERITABLE;
    Status = ConsoleAddShare(GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Console->ScreenBuffers->ShareAccess,
                             HandleData);
    UserAssert(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    *StdErr = INDEX_TO_HANDLE(Handle);
    return STATUS_SUCCESS;

Cleanup:
    FreeInputHandle(InputHandleData);
    return Status;
}

NTSTATUS
InheritIoHandleTable(
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_PER_PROCESS_DATA ParentProcessData)

/*++

Routine Description:

    This routine creates a process's handle table from the parent
    process's handle table.  ProcessData contains the process data
    copied directly from the parent to the child process by CSR.
    This routine allocates a new handle table, if necessary, then
    invalidates non-inherited handles and increments the sharing
    and reference counts for inherited handles.

Arguments:

    ProcessData - Pointer to per process data structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG i;
    NTSTATUS Status;

    //
    // Copy handles from parent process.  If the table size
    // is CONSOLE_INITIAL_IO_HANDLES, CSR has done the copy
    // for us.
    //

    UNREFERENCED_PARAMETER(Console);

    ASSERT(ParentProcessData->HandleTableSize != 0);
    ASSERT(ParentProcessData->HandleTableSize <= 0x0000FFFF);

    if (ParentProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
        ProcessData->HandleTableSize = ParentProcessData->HandleTableSize;
        ProcessData->HandleTablePtr = ConsoleHeapAlloc(HANDLE_TAG, ProcessData->HandleTableSize * sizeof(HANDLE_DATA));

        if (ProcessData->HandleTablePtr == NULL) {
            ProcessData->HandleTablePtr = ProcessData->HandleTable;
            ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
            return STATUS_NO_MEMORY;
        }
        RtlCopyMemory(ProcessData->HandleTablePtr,
            ParentProcessData->HandleTablePtr,
            ProcessData->HandleTableSize * sizeof(HANDLE_DATA));
    }

    ASSERT(!(Console->Flags & CONSOLE_SHUTTING_DOWN));

    //
    // Allocate any memory associated with each handle.
    //

    Status = STATUS_SUCCESS;
    for (i = 0;i < ProcessData->HandleTableSize; i++) {

        if (NT_SUCCESS(Status) && ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INHERITABLE) {

            if (ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INPUT_HANDLE) {
                ProcessData->HandleTablePtr[i].InputReadData = ConsoleHeapAlloc(HANDLE_TAG, sizeof(INPUT_READ_HANDLE_DATA));
                if (!ProcessData->HandleTablePtr[i].InputReadData) {
                    ProcessData->HandleTablePtr[i].HandleType = CONSOLE_FREE_HANDLE;
                    Status = STATUS_NO_MEMORY;
                    continue;
                }
                ProcessData->HandleTablePtr[i].InputReadData->InputHandleFlags = 0;
                ProcessData->HandleTablePtr[i].InputReadData->ReadCount = 0;
                Status = RtlInitializeCriticalSection(&ProcessData->HandleTablePtr[i].InputReadData->ReadCountLock);
                if (!NT_SUCCESS(Status)) {
                    ConsoleHeapFree(ProcessData->HandleTablePtr[i].InputReadData);
                    ProcessData->HandleTablePtr[i].InputReadData = NULL;
                    ProcessData->HandleTablePtr[i].HandleType = CONSOLE_FREE_HANDLE;
                    continue;
                }
            }
        } else {
            ProcessData->HandleTablePtr[i].HandleType = CONSOLE_FREE_HANDLE;
        }
    }

    //
    // If something failed, we need to free any input data we allocated and
    // free the handle table.
    //

    if (!NT_SUCCESS(Status)) {
        for (i=0;i<ProcessData->HandleTableSize;i++) {
            if (ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INPUT_HANDLE) {
                FreeInputHandle(&ProcessData->HandleTablePtr[i]);
            }
        }
        if (ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
            ConsoleHeapFree(ProcessData->HandleTablePtr);
            ProcessData->HandleTablePtr = ProcessData->HandleTable;
            ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
        }
        return Status;
    }

    //
    // All the memory allocations succeeded. Now go through and increment the
    // object reference counts and dup the shares.
    //

    for (i=0;i<ProcessData->HandleTableSize;i++) {
        if (ProcessData->HandleTablePtr[i].HandleType != CONSOLE_FREE_HANDLE) {
            PCONSOLE_SHARE_ACCESS ShareAccess;

            if (ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INPUT_HANDLE) {
                ProcessData->HandleTablePtr[i].Buffer.InputBuffer->RefCount++;
                ShareAccess = &ProcessData->HandleTablePtr[i].Buffer.InputBuffer->ShareAccess;
            } else {
                ProcessData->HandleTablePtr[i].Buffer.ScreenBuffer->RefCount++;
                ShareAccess = &ProcessData->HandleTablePtr[i].Buffer.ScreenBuffer->ShareAccess;
            }

            Status = ConsoleDupShare(ProcessData->HandleTablePtr[i].Access,
                                     ProcessData->HandleTablePtr[i].ShareAccess,
                                     ShareAccess,
                                     &ProcessData->HandleTablePtr[i]
                                    );
            ASSERT (NT_SUCCESS(Status));
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ConsoleAddProcessRoutine(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS Process)
{
    PCONSOLE_PER_PROCESS_DATA ProcessData, ParentProcessData;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);
    ProcessData->HandleTablePtr = ProcessData->HandleTable;
    ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
    CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData,FALSE);


    if (ParentProcess) {
        ProcessData->RootProcess = FALSE;
        ProcessData->ParentProcessId = HandleToUlong(ParentProcess->ClientId.UniqueProcess);
        ParentProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(ParentProcess);


        //
        // If both the parent and new processes are console apps,
        // inherit handles from the parent process.
        //

        if (ParentProcessData->ConsoleHandle != NULL &&
                (Process->Flags & CSR_PROCESS_CONSOLEAPP)) {
            if (!(NT_SUCCESS(RevalidateConsole(ParentProcessData->ConsoleHandle,
                                               &Console)))) {
                ProcessData->ConsoleHandle = NULL;
                return STATUS_PROCESS_IS_TERMINATING;
            }

            //
            // Don't add the process if the console is being shutdown.
            //

            if (Console->Flags & CONSOLE_SHUTTING_DOWN) {
                Status = STATUS_PROCESS_IS_TERMINATING;
            } else {
                ProcessHandleRecord = ConsoleHeapAlloc(HANDLE_TAG, sizeof(CONSOLE_PROCESS_HANDLE));
                if (ProcessHandleRecord == NULL) {
                    Status = STATUS_NO_MEMORY;
                } else {

                    //
                    // duplicate parent's handle table
                    //

                    Status = InheritIoHandleTable(Console, ProcessData, ParentProcessData);
                    if (NT_SUCCESS(Status)) {
                        ProcessHandleRecord->Process = Process;
                        ProcessHandleRecord->CtrlRoutine = NULL;
                        ProcessHandleRecord->PropRoutine = NULL;
                        AddProcessToList(Console,ProcessHandleRecord,Process->ProcessHandle);

                        //
                        // increment console reference count
                        //

                        RefConsole(Console);
                    } else {
                        ConsoleHeapFree(ProcessHandleRecord);
                    }
                }
            }
            if (!NT_SUCCESS(Status)) {
                ProcessData->ConsoleHandle = NULL;
                for (i=0;i<CONSOLE_INITIAL_IO_HANDLES;i++) {
                    ProcessData->HandleTable[i].HandleType = CONSOLE_FREE_HANDLE;
                }
            }
            UnlockConsole(Console);
        } else {
            ProcessData->ConsoleHandle = NULL;
        }
    } else {
        ProcessData->ConsoleHandle = NULL;
    }
    return Status;
}

NTSTATUS
MapEventHandles(
    IN HANDLE ClientProcessHandle,
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_INFO ConsoleInfo)
{
    if (!MapHandle(ClientProcessHandle,
                   Console->InitEvents[INITIALIZATION_SUCCEEDED],
                   &ConsoleInfo->InitEvents[INITIALIZATION_SUCCEEDED]
                  )) {
        return STATUS_NO_MEMORY;
    }
    if (!MapHandle(ClientProcessHandle,
                   Console->InitEvents[INITIALIZATION_FAILED],
                   &ConsoleInfo->InitEvents[INITIALIZATION_FAILED]
                  )) {
        return STATUS_NO_MEMORY;
    }
    if (!MapHandle(ClientProcessHandle,
                   Console->InputBuffer.InputWaitEvent,
                   &ConsoleInfo->InputWaitHandle
                  )) {
        return STATUS_NO_MEMORY;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
AllocateConsole(
    IN HANDLE ConsoleHandle,
    IN LPWSTR Title,
    IN USHORT TitleLength,
    IN HANDLE ClientProcessHandle,
    OUT PHANDLE StdIn,
    OUT PHANDLE StdOut,
    OUT PHANDLE StdErr,
    OUT PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN OUT PCONSOLE_INFO ConsoleInfo,
    IN BOOLEAN WindowVisible,
    IN DWORD dwConsoleThreadId)

/*++

Routine Description:

    This routine allocates and initialized a console and its associated
    data - input buffer and screen buffer.

Arguments:

    ConsoleHandle - Handle of console to allocate.

    dwWindowSize - Initial size of screen buffer window, in rows and columns.

    nFont - Initial number of font text is displayed in.

    dwScreenBufferSize - Initial size of screen buffer, in rows and columns.

    nInputBufferSize - Initial size of input buffer, in events.

    dwWindowFlags -

    StdIn - On return, contains handle to stdin.

    StdOut - On return, contains handle to stdout.

    StdErr - On return, contains handle to stderr.

    ProcessData - On return, contains the initialized per-process data.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    BOOL Success;

    //
    // allocate console data
    //

    Console = ConsoleHeapAlloc(CONSOLE_TAG | HEAP_ZERO_MEMORY,
                               sizeof(CONSOLE_INFORMATION));
    if (Console == NULL) {
        return STATUS_NO_MEMORY;
    }
    ConsoleHandles[IndexFromHandle(ConsoleHandle)] = Console;

    Console->Flags = WindowVisible ? 0 : CONSOLE_NO_WINDOW;
    Console->hIcon = ConsoleInfo->hIcon;
    Console->hSmIcon = ConsoleInfo->hSmIcon;
    Console->iIconId = ConsoleInfo->iIconId;
    Console->dwHotKey = ConsoleInfo->dwHotKey;
#if !defined(FE_SB)
    Console->CP = OEMCP;
    Console->OutputCP = ConsoleOutputCP;
#endif
    Console->ReserveKeys = CONSOLE_NOSHORTCUTKEY;
    Console->ConsoleHandle = ConsoleHandle;
    Console->bIconInit = TRUE;
    Console->VerticalClientToWindow = VerticalClientToWindow;
    Console->HorizontalClientToWindow = HorizontalClientToWindow;
#if defined(FE_SB)
    SetConsoleCPInfo(Console,TRUE);
    SetConsoleCPInfo(Console,FALSE);
#endif

    //
    // must wait for window to be destroyed or client impersonation won't
    // work.
    //

    Status = NtDuplicateObject(NtCurrentProcess(),
                              CONSOLE_CLIENTTHREADHANDLE(CSR_SERVER_QUERYCLIENTTHREAD()),
                              NtCurrentProcess(),
                              &Console->ClientThreadHandle,
                              0,
                              FALSE,
                              DUPLICATE_SAME_ACCESS
                             );
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit5;
    }

#if DBG
    //
    // Make sure the handle isn't protected so we can close it later
    //
    UnProtectHandle(Console->ClientThreadHandle);
#endif // DBG

    InitializeListHead(&Console->OutputQueue);
    InitializeListHead(&Console->ProcessHandleList);
    InitializeListHead(&Console->ExeAliasList);
    InitializeListHead(&Console->MessageQueue);

    Status = NtCreateEvent(&Console->InitEvents[INITIALIZATION_SUCCEEDED],
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit4a;
    }
    Status = NtCreateEvent(&Console->InitEvents[INITIALIZATION_FAILED],
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit4;
    }
    Status = RtlInitializeCriticalSection(&Console->ConsoleLock);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit3a;
    }
    InitializeConsoleCommandData(Console);

    //
    // initialize input buffer
    //

#if defined(FE_SB)
    Status = CreateInputBuffer(ConsoleInfo->nInputBufferSize,
                               &Console->InputBuffer,
                               Console);
#else
    Status = CreateInputBuffer(ConsoleInfo->nInputBufferSize,
                               &Console->InputBuffer);
#endif
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit3;
    }

    Console->Title = ConsoleHeapAlloc(TITLE_TAG, TitleLength+sizeof(WCHAR));
    if (Console->Title == NULL) {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit2;
    }
    RtlCopyMemory(Console->Title,Title,TitleLength);
    Console->Title[TitleLength/sizeof(WCHAR)] = (WCHAR)0;   // NULL terminate
    Console->TitleLength = TitleLength;

    Console->OriginalTitle = TranslateConsoleTitle(Console->Title, &Console->OriginalTitleLength, TRUE, FALSE);
    if (Console->OriginalTitle == NULL) {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit1;
    }

    Status = NtCreateEvent(&Console->TerminationEvent,
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit1a;
    }

    //
    // initialize screen buffer. we don't call OpenConsole to do this
    // because we need to specify the font, windowsize, etc.
    //

    Status = DoCreateScreenBuffer(Console,
                                  ConsoleInfo);
    if (!NT_SUCCESS(Status)){
        goto ErrorExit1b;
    }


    Console->CurrentScreenBuffer = Console->ScreenBuffers;
#if defined(FE_SB)
#if defined(FE_IME)
    SetUndetermineAttribute(Console);
#endif
    Status = CreateEUDC(Console);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit1c;
    }
#endif

    Status = InitializeIoHandleTable(Console,
                                     ProcessData,
                                     StdIn,
                                     StdOut,
                                     StdErr);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit0;
    }

    //
    // map event handles
    //

    Status = MapEventHandles(ClientProcessHandle, Console, ConsoleInfo);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit0;
    }

    Success = PostThreadMessage(dwConsoleThreadId,
                                CM_CREATE_CONSOLE_WINDOW,
                                (WPARAM)ConsoleHandle,
                                (LPARAM)ClientProcessHandle);
    if (!Success) {
        RIPMSG1(RIP_WARNING, "PostThreadMessage failed 0x%x", GetLastError());
        Status = STATUS_UNSUCCESSFUL;
        goto ErrorExit0;
    }

    return STATUS_SUCCESS;

ErrorExit0: Console->ScreenBuffers->RefCount = 0;
#if defined(FE_SB)
            if (Console->EudcInformation != NULL) {
                ConsoleHeapFree(Console->EudcInformation);
            }
ErrorExit1c:
#endif
            FreeScreenBuffer(Console->ScreenBuffers);
ErrorExit1b: NtClose(Console->TerminationEvent);
ErrorExit1a: ConsoleHeapFree(Console->OriginalTitle);
ErrorExit1: ConsoleHeapFree(Console->Title);
ErrorExit2: Console->InputBuffer.RefCount = 0;
            FreeInputBuffer(&Console->InputBuffer);
ErrorExit3: RtlDeleteCriticalSection(&Console->ConsoleLock);

ErrorExit3a: NtClose(Console->InitEvents[INITIALIZATION_FAILED]);
ErrorExit4: NtClose(Console->InitEvents[INITIALIZATION_SUCCEEDED]);
ErrorExit4a: NtClose(Console->ClientThreadHandle);
ErrorExit5:  ConsoleHeapFree(Console);
    return Status;
}

VOID
DestroyConsole(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine frees a console structure if it's not being referenced.

Arguments:

    Console - Console to free.

Return Value:


--*/

{
    HANDLE ConsoleHandle = Console->ConsoleHandle;

    //
    // Make sure we have the console locked and it really is going away.
    //

    ASSERT(ConsoleLocked(Console));
    ASSERT(Console->hWnd == NULL);

    //
    // Mark this console as being destroyed.
    //

    Console->Flags |= CONSOLE_IN_DESTRUCTION;

    //
    // Unlock this console.
    //

    RtlLeaveCriticalSection(&Console->ConsoleLock);

    //
    // If the console still exists and no one is waiting on it, free it.
    //

    LockConsoleHandleTable();
    if (Console == ConsoleHandles[IndexFromHandle(ConsoleHandle)] &&
        Console->ConsoleHandle == ConsoleHandle &&
        Console->ConsoleLock.OwningThread == NULL &&
        Console->WaitCount == 0) {

        FreeConsoleHandle(ConsoleHandle);
        RtlDeleteCriticalSection(&Console->ConsoleLock);

#if DBG
        if (Console->pRefNodes != NULL) {
            ConsoleHeapFree(Console->pRefNodes);
        }
#endif

        ConsoleHeapFree(Console);
    }
    UnlockConsoleHandleTable();
}

VOID
FreeCon(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine frees a console and its associated
    data - input buffer and screen buffer.

Arguments:

    ConsoleHandle - Handle of console to free.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    HWND hWnd;
    USERTHREAD_USEDESKTOPINFO utudi;
    NTSTATUS Status;

    Console->Flags |= CONSOLE_TERMINATING;
    NtSetEvent(Console->TerminationEvent,NULL);
    hWnd = Console->hWnd;

    //
    // Wait 10 seconds or until the input thread replies
    // to synchronize the window destruction with
    // the termination of the thread
    //

    if (hWnd != NULL) {
        UnlockConsole(Console);
        utudi.hThread = NULL;
        utudi.drdRestore.pdeskRestore = NULL;

        Status = NtUserSetInformationThread(NtCurrentThread(),
                                            UserThreadUseActiveDesktop,
                                            &utudi, sizeof(utudi));
        ASSERT(NT_SUCCESS(Status));

        if (NT_SUCCESS(Status)) {
            SendMessageTimeout(hWnd, CM_DESTROY_WINDOW, 0, 0, SMTO_BLOCK, 10000, NULL);
            Status = NtUserSetInformationThread(NtCurrentThread(),
                                                UserThreadUseDesktop,
                                                &utudi,
                                                sizeof(utudi));
            ASSERT(NT_SUCCESS(Status));
        }
    } else {
        AbortCreateConsole(Console);
    }
}

VOID
InsertScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo)

/*++

Routine Description:

    This routine inserts the screen buffer pointer into the console's
    list of screen buffers.

Arguments:

    Console - Pointer to console information structure.

    ScreenInfo - Pointer to screen information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ScreenInfo->Next = Console->ScreenBuffers;
    Console->ScreenBuffers = ScreenInfo;
}

VOID
RemoveScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo)

/*++

Routine Description:

    This routine removes the screen buffer pointer from the console's
    list of screen buffers.

Arguments:

    Console - Pointer to console information structure.

    ScreenInfo - Pointer to screen information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    PSCREEN_INFORMATION Prev,Cur;

    if (ScreenInfo == Console->ScreenBuffers) {
        Console->ScreenBuffers = ScreenInfo->Next;
        return;
    }
    Prev = Cur = Console->ScreenBuffers;
    while (Cur != NULL) {
        if (ScreenInfo == Cur)
            break;
        Prev = Cur;
        Cur = Cur->Next;
    }
    ASSERT (Cur != NULL);
    if (Cur != NULL) {
        Prev->Next = Cur->Next;
    }
}

NTSTATUS
GrowIoHandleTable(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData)

/*++

Routine Description:

    This routine grows the per-process io handle table.

Arguments:

    ProcessData - Pointer to the per-process data structure.

Return Value:

--*/

{
    PHANDLE_DATA NewTable;
    ULONG i;
    ULONG MaxFileHandles;

    MaxFileHandles = ProcessData->HandleTableSize + CONSOLE_IO_HANDLE_INCREMENT;
    NewTable = ConsoleHeapAlloc(HANDLE_TAG, MaxFileHandles * sizeof(HANDLE_DATA));
    if (NewTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlCopyMemory(NewTable, ProcessData->HandleTablePtr,
                  ProcessData->HandleTableSize * sizeof(HANDLE_DATA));
    for (i=ProcessData->HandleTableSize;i<MaxFileHandles;i++) {
        NewTable[i].HandleType = CONSOLE_FREE_HANDLE;
    }
    if (ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
        ConsoleHeapFree(ProcessData->HandleTablePtr);
    }
    ProcessData->HandleTablePtr = NewTable;
    ProcessData->HandleTableSize = MaxFileHandles;
    ASSERT(ProcessData->HandleTableSize != 0);
    ASSERT(ProcessData->HandleTableSize <= 0x0000FFFF);

    return STATUS_SUCCESS;
}

VOID
FreeProcessData(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData)

/*++

Routine Description:

    This routine frees any per-process data allocated by the console.

Arguments:

    ProcessData - Pointer to the per-process data structure.

Return Value:

--*/

{
    if (ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
        ConsoleHeapFree(ProcessData->HandleTablePtr);
        ProcessData->HandleTablePtr = ProcessData->HandleTable;
        ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
    }
}

VOID
InitializeOutputHandle(
    PHANDLE_DATA HandleData,
    PSCREEN_INFORMATION ScreenBuffer)

/*++

Routine Description:

    This routine initializes the output-specific fields of the handle data
    structure.

Arguments:

    HandleData - Pointer to handle data structure.

    ScreenBuffer - Pointer to screen buffer data structure.

Return Value:

--*/

{
    HandleData->Buffer.ScreenBuffer = ScreenBuffer;
    HandleData->Buffer.ScreenBuffer->RefCount++;
}

BOOLEAN
InitializeInputHandle(
    PHANDLE_DATA HandleData,
    PINPUT_INFORMATION InputBuffer)

/*++

Routine Description:

    This routine initializes the input-specific fields of the handle data
    structure.

Arguments:

    HandleData - Pointer to handle data structure.

    InputBuffer - Pointer to input buffer data structure.

Return Value:

--*/

{
    NTSTATUS Status;

    HandleData->InputReadData = ConsoleHeapAlloc(HANDLE_TAG, sizeof(INPUT_READ_HANDLE_DATA));
    if (!HandleData->InputReadData) {
        return FALSE;
    }

    Status = RtlInitializeCriticalSection(&HandleData->InputReadData->ReadCountLock);
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(HandleData->InputReadData);
        HandleData->InputReadData = NULL;
        return FALSE;
    }

    HandleData->InputReadData->ReadCount = 0;
    HandleData->InputReadData->InputHandleFlags = 0;
    HandleData->Buffer.InputBuffer = InputBuffer;
    HandleData->Buffer.InputBuffer->RefCount++;
    return TRUE;
}

VOID
FreeInputHandle(
    IN PHANDLE_DATA HandleData)
{
    if (HandleData->InputReadData) {
        RtlDeleteCriticalSection(&HandleData->InputReadData->ReadCountLock);
        ConsoleHeapFree(HandleData->InputReadData);
        HandleData->InputReadData = NULL;
    }
}

NTSTATUS
AllocateIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN ULONG HandleType,
    OUT PHANDLE Handle)

/*++

Routine Description:

    This routine allocates an input or output handle from the process's
    handle table.

    This routine initializes all non-type specific fields in the handle
    data structure.

Arguments:

    ProcessData - Pointer to per process data structure.

    HandleType - Flag indicating input or output handle.

    Handle - On return, contains allocated handle.  Handle is an index
    internally.  When returned to the API caller, it is translated into
    a handle.

Return Value:

Note:

    The console lock must be held when calling this routine.  The handle
    is allocated from the per-process handle table.  Holding the console
    lock serializes both threads within the calling process and any other
    process that shares the console.

--*/

{
    ULONG i;
    NTSTATUS Status;

    for (i = 0;i < ProcessData->HandleTableSize; i++) {
        if (ProcessData->HandleTablePtr[i].HandleType == CONSOLE_FREE_HANDLE) {
            ProcessData->HandleTablePtr[i].HandleType = HandleType;
            *Handle = LongToHandle(i);

            return STATUS_SUCCESS;
        }
    }

    Status = GrowIoHandleTable(ProcessData);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    for ( ;i < ProcessData->HandleTableSize; i++) {
        if (ProcessData->HandleTablePtr[i].HandleType == CONSOLE_FREE_HANDLE) {
            ProcessData->HandleTablePtr[i].HandleType = HandleType;
            *Handle = LongToHandle(i);
            return STATUS_SUCCESS;
        }
    }
    ASSERT (FALSE);
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
FreeIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle)

/*++

Routine Description:

    This routine frees an input or output handle from the process's
    handle table.

Arguments:

    ProcessData - Pointer to per process data structure.

    Handle - Handle to free.

Return Value:

Note:

    The console lock must be held when calling this routine.  The handle
    is freed from the per-process handle table.  Holding the console
    lock serializes both threads within the calling process and any other
    process that shares the console.

--*/

{
    NTSTATUS Status;
    PHANDLE_DATA HandleData;

    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 Handle,
                                 &HandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
        FreeInputHandle(HandleData);
    }
    HandleData->HandleType = CONSOLE_FREE_HANDLE;
    return STATUS_SUCCESS;
}

NTSTATUS
DereferenceIoHandleNoCheck(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    OUT PHANDLE_DATA *HandleData)

/*++

Routine Description:

    This routine verifies a handle's validity, then returns a pointer to
    the handle data structure.

Arguments:

    ProcessData - Pointer to per process data structure.

    Handle - Handle to dereference.

    HandleData - On return, pointer to handle data structure.

Return Value:

--*/

{
    if (((ULONG_PTR)Handle >= ProcessData->HandleTableSize) ||
        (ProcessData->HandleTablePtr[(ULONG_PTR)Handle].HandleType == CONSOLE_FREE_HANDLE) ) {
        return STATUS_INVALID_HANDLE;
    }
    *HandleData = &ProcessData->HandleTablePtr[(ULONG_PTR)Handle];
    return STATUS_SUCCESS;
}

NTSTATUS
DereferenceIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    IN ULONG HandleType,
    IN ACCESS_MASK Access,
    OUT PHANDLE_DATA *HandleData)

/*++

Routine Description:

    This routine verifies a handle's validity, then returns a pointer to
    the handle data structure.

Arguments:

    ProcessData - Pointer to per process data structure.

    Handle - Handle to dereference.

    HandleData - On return, pointer to handle data structure.

Return Value:

--*/

{
    ULONG_PTR Index;

    if (!CONSOLE_HANDLE(Handle)) {
        return STATUS_INVALID_HANDLE;
    }
    Index = (ULONG_PTR)HANDLE_TO_INDEX(Handle);
    if ((Index >= ProcessData->HandleTableSize) ||
        (ProcessData->HandleTablePtr[Index].HandleType == CONSOLE_FREE_HANDLE) ||
        !(ProcessData->HandleTablePtr[Index].HandleType & HandleType) ||
        !(ProcessData->HandleTablePtr[Index].Access & Access) ) {
        return STATUS_INVALID_HANDLE;
    }
    *HandleData = &ProcessData->HandleTablePtr[Index];
    return STATUS_SUCCESS;
}


ULONG
SrvVerifyConsoleIoHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)

/*++

Routine Description:

    This routine verifies that a console io handle is valid.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_VERIFYIOHANDLE_MSG a = (PCONSOLE_VERIFYIOHANDLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    PHANDLE_DATA HandleData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (NT_SUCCESS(Status)) {
        ProcessData = CONSOLE_PERPROCESSDATA();
        Status = DereferenceIoHandleNoCheck(ProcessData,
                                     HANDLE_TO_INDEX(a->Handle),
                                     &HandleData
                                    );
        UnlockConsole(Console);
    }
    a->Valid = (NT_SUCCESS(Status));
    return STATUS_SUCCESS;
}


NTSTATUS
ApiPreamble(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console)
{
    NTSTATUS Status;

    //
    // If this process doesn't have a console handle, bail immediately.
    //

    if (ConsoleHandle == NULL || ConsoleHandle != CONSOLE_GETCONSOLEHANDLE()) {
        return STATUS_INVALID_HANDLE;
    }

#ifdef i386
    //Do not lock the console if we are in the special case:
    //(1). we are in the middle of handshaking with ntvdm doing
    //     full-screen to windowed mode transition
    //(2). the calling process is THE ntvdm process(this implies that the
    //     the console has vdm registered.
    //(3). the console handle is the same one.
    // if (1), (2) and (3) are true then the console is already locked
    // (locked by the windowproc while processing the WM_FULLSCREEN
    // message)

    RtlEnterCriticalSection(&ConsoleVDMCriticalSection);
    if (ConsoleVDMOnSwitching != NULL &&
        ConsoleVDMOnSwitching->ConsoleHandle == ConsoleHandle &&
        ConsoleVDMOnSwitching->VDMProcessId == CONSOLE_CLIENTPROCESSID()) {
        RIPMSG1(RIP_WARNING, "ApiPreamble - Thread %lx Entered VDM CritSec", GetCurrentThreadId());
        *Console = ConsoleVDMOnSwitching;
        return STATUS_SUCCESS;
    }
    RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);
#endif

    Status = RevalidateConsole(ConsoleHandle,
                               Console
                              );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Make sure the console has been initialized and the window is valid
    //

    if ((*Console)->hWnd == NULL || ((*Console)->Flags & CONSOLE_TERMINATING)) {
        KdPrint(("CONSRV: bogus window for console %lx\n", *Console));
        UnlockConsole(*Console);
        return STATUS_INVALID_HANDLE;
    }

    return Status;
}

NTSTATUS
RevalidateConsole(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console)
{
    NTSTATUS Status;

    LockConsoleHandleTable();
    Status = DereferenceConsoleHandle(ConsoleHandle,
                                      Console
                                     );
    if (!NT_SUCCESS(Status)) {
        UnlockConsoleHandleTable();
        return Status;
    }

    //
    // The WaitCount ensures the console won't go away between the time
    // we unlock the console handle table and we lock the console.
    //

    InterlockedIncrement(&(*Console)->WaitCount);
    UnlockConsoleHandleTable();
    try {
        LockConsole(*Console);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        InterlockedDecrement(&(*Console)->WaitCount);
        return GetExceptionCode();
    }
    InterlockedDecrement(&(*Console)->WaitCount);

    //
    // If the console was marked for destruction while we were waiting to
    // lock it, try to destroy it and return.
    //

    if ((*Console)->Flags & CONSOLE_IN_DESTRUCTION) {
        DestroyConsole(*Console);
        *Console = NULL;
        return STATUS_INVALID_HANDLE;
    }

    //
    // If the console was marked for termination while we were waiting to
    // lock it, bail out.
    //

    if ((*Console)->Flags & CONSOLE_TERMINATING) {
        UnlockConsole(*Console);
        *Console = NULL;
        return STATUS_PROCESS_IS_TERMINATING;
    }

    return Status;
}


#if DBG

BOOLEAN
UnProtectHandle(
    HANDLE hObject)
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject(hObject,
                           ObjectHandleFlagInformation,
                           &HandleInfo,
                           sizeof(HandleInfo),
                           NULL
                          );
    if (NT_SUCCESS(Status)) {
        HandleInfo.ProtectFromClose = FALSE;
        Status = NtSetInformationObject(hObject,
                                        ObjectHandleFlagInformation,
                                        &HandleInfo,
                                        sizeof(HandleInfo)
                                       );
        if (NT_SUCCESS(Status)) {
            return TRUE;
        }
    }

    return FALSE;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\hard.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    NtHard.c

Abstract:

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(i386)


#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")



#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 256)

NTSTATUS
NtGetMachineIdentifierValue(
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the
                identifier location of the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    //
    // Set default as PC/AT
    //

    *Value = MACHINEID_MS_PCAT;

    KeyName.Buffer = REGISTRY_HARDWARE_DESCRIPTION;
    KeyName.Length = sizeof(REGISTRY_HARDWARE_DESCRIPTION) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(REGISTRY_HARDWARE_DESCRIPTION);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    ValueName.Buffer = REGISTRY_MACHINE_IDENTIFIER;
    ValueName.Length = sizeof(REGISTRY_MACHINE_IDENTIFIER) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(REGISTRY_MACHINE_IDENTIFIER);

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    Status = NtQueryValueKey(Handle,
                             &ValueName,
                             KeyValueFullInformation,
                             KeyValueInformation,
                             RequestLength,
                             &ResultLength);

    ASSERT( Status != STATUS_BUFFER_OVERFLOW );

    NtClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PWCHAR DataPtr;
            UNICODE_STRING DetectedString, TargetString1, TargetString2;

            //
            // Return contents to the caller.
            //

            DataPtr = (PWCHAR)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);

            //
            // Initialize strings.
            //

            RtlInitUnicodeString( &DetectedString, DataPtr );
            RtlInitUnicodeString( &TargetString1, FUJITSU_FMR_NAME );
            RtlInitUnicodeString( &TargetString2, NEC_PC98_NAME );

            //
            // Check the hardware platform
            //

            if (RtlPrefixUnicodeString( &TargetString1 , &DetectedString , TRUE)) {

                //
                // Fujitsu FMR Series.
                //

                *Value = MACHINEID_FUJITSU_FMR;

            } else if (RtlPrefixUnicodeString( &TargetString2 , &DetectedString , TRUE)) {

                //
                // NEC PC-9800 Seriss
                //

                *Value = MACHINEID_NEC_PC98;

            } else {

                //
                // Standard PC/AT comapatibles
                //

                *Value = MACHINEID_MS_PCAT;

            }

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

    }

    return Status;
}
#endif // defined(i386)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\misc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    misc.c

Abstract:

        This file implements the NT console server font routines.

Author:

    Therese Stowell (thereses) 22-Jan-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG && defined(DEBUG_PRINT)
#error yo!
ULONG gDebugFlag;
#endif

ULONG NumberOfMouseButtons;

PFONT_INFO FontInfo;
ULONG FontInfoLength;
ULONG NumberOfFonts;

WCHAR DefaultFaceName[LF_FACESIZE];
COORD DefaultFontSize;
BYTE  DefaultFontFamily;
ULONG DefaultFontIndex = 0;

typedef struct _FONTENUMDC {
    HDC hDC;
    BOOL bFindFaces;
    BOOL bFarEastOK;
    SHORT TTPointSize;
} FONTENUMDC, *PFONTENUMDC;

/*
 * Custom CP for glyph translations
 */
CPTABLEINFO GlyphCP;
USHORT GlyphTable[256];


#define FONT_BUFFER_SIZE 12

#define CHAR_NULL      ((char)0)
/*
 * Initial default fonts and face names
 */
PFACENODE gpFaceNames;


NTSTATUS
GetMouseButtons(
    PULONG NumButtons
    )
{
    *NumButtons = NumberOfMouseButtons;
    return STATUS_SUCCESS;
}

VOID
InitializeMouseButtons( VOID )
{
    NumberOfMouseButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
}

PFACENODE AddFaceNode(PFACENODE *ppStart, LPWSTR pwsz) {
    PFACENODE pNew;
    PFACENODE *ppTmp;
    int cb;

    /*
     * Is it already here?
     */
    for (ppTmp = ppStart; *ppTmp; ppTmp = &((*ppTmp)->pNext)) {
        if (wcscmp(((*ppTmp)->awch), pwsz) == 0) {
            // already there !
            return *ppTmp;
        }
    }

    cb = (wcslen(pwsz) + 1) * sizeof(WCHAR);
    pNew = ConsoleHeapAlloc(FONT_TAG, sizeof(FACENODE) + cb);
    if (pNew == NULL) {
        return NULL;
    }

    pNew->pNext = NULL;
    pNew->dwFlag = 0;
    wcscpy(pNew->awch, pwsz);
    *ppTmp = pNew;
    return pNew;
}

VOID
InitializeFonts( VOID )
{
    WCHAR FontName[CONSOLE_MAX_FONT_NAME_LENGTH];
    int i;
    static CONST LPWSTR FontList[] = {L"woafont",
                                      L"ega80woa.fon",
                                      L"ega40woa.fon",
                                      L"cga80woa.fon",
                                      L"cga40woa.fon"};

    //
    // Read software.ini to get the values for "woafont",
    // "ega80woa.fon", "ega40woa.fon", "cga80woa.fon", and
    // "cga40woa.fon", respectively, to pass to AddFontResource.
    //
    // If any of the entries are empty or non-existent,
    // GetPrivateProfileString will return a NULL (empty) string.
    // If such is the case, the call to AddPermanentFontResource will
    // simply fail.
    //

    OpenProfileUserMapping();

    for (i = 0; i < NELEM(FontList); i++) {
        GetPrivateProfileString(L"386enh", FontList[i], L"",
                FontName, NELEM(FontName), L"system.ini");
        GdiAddFontResourceW(FontName, AFRW_ADD_LOCAL_FONT,NULL);
    }

    CloseProfileUserMapping();
}


/***************************************************************************\
* FontEnum
*
* This routine is called exactly once by GDI for each font in the system,
* and is used to store the FONT_INFO structure.
\***************************************************************************/
int CALLBACK
FontEnum(
    LPENUMLOGFONTW lpLogFont,
    LPNEWTEXTMETRICW lpTextMetric,
    int nFontType,
    LPARAM lParam
    )
{
    PFONTENUMDC pfed = (PFONTENUMDC)lParam;
    HDC hDC = pfed->hDC;
    BOOL bFindFaces = pfed->bFindFaces;
    HFONT hFont;
    TEXTMETRICW tmi;
    LONG nFont;
    LONG nFontNew;
    COORD SizeToShow;
    COORD SizeActual;
    COORD SizeWant;
    BYTE tmFamily;
    SIZE Size;
    LPWSTR pwszFace = lpLogFont->elfLogFont.lfFaceName;
    PFACENODE pFN;

    DBGFONTS(("  FontEnum \"%ls\" (%d,%d) weight 0x%lx(%d) -- %s\n",
            pwszFace,
            lpLogFont->elfLogFont.lfWidth, lpLogFont->elfLogFont.lfHeight,
            lpLogFont->elfLogFont.lfWeight, lpLogFont->elfLogFont.lfWeight,
            bFindFaces ? "Finding Faces" : "Creating Fonts"));

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //

    if
    (
      !(lpLogFont->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
      (lpLogFont->elfLogFont.lfItalic)                        ||
      !(lpTextMetric->ntmFlags & NTM_NONNEGATIVE_AC)
    )
    {
        if (!IsAvailableTTFont(pwszFace))
        {
            DBGFONTS(("    REJECT  face (variable pitch, italic, or neg a&c)\n"));
            return bFindFaces ? TRUE : FALSE;  // unsuitable font
        }
    }

    if (nFontType == TRUETYPE_FONTTYPE) {
        lpLogFont->elfLogFont.lfHeight = pfed->TTPointSize;
        lpLogFont->elfLogFont.lfWidth  = 0;
        lpLogFont->elfLogFont.lfWeight = FW_NORMAL;
    }

    /*
     * reject TT fonts for whoom family is not modern, that is do not use
     * FF_DONTCARE    // may be surprised unpleasantly
     * FF_DECORATIVE  // likely to be symbol fonts
     * FF_SCRIPT      // cursive, inappropriate for console
     * FF_SWISS OR FF_ROMAN // variable pitch
     */

    if ((nFontType == TRUETYPE_FONTTYPE) &&
            ((lpLogFont->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN)) {
        DBGFONTS(("    REJECT  face (TT but not FF_MODERN)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject non-TT fonts that aren't OEM
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
#if defined(FE_SB)
            (!CONSOLE_IS_DBCS_ENABLED() ||
            !IS_ANY_DBCS_CHARSET(lpLogFont->elfLogFont.lfCharSet)) &&
#endif
            (lpLogFont->elfLogFont.lfCharSet != OEM_CHARSET)) {
        DBGFONTS(("    REJECT  face (not TT nor OEM)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject non-TT fonts that are virtical font
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
            (pwszFace[0] == L'@')) {
        DBGFONTS(("    REJECT  face (not TT and TATEGAKI)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject non-TT fonts that aren't Terminal
     */
    if (CONSOLE_IS_DBCS_ENABLED() &&
        (nFontType != TRUETYPE_FONTTYPE) &&
            (wcscmp(pwszFace, L"Terminal") != 0)) {
        DBGFONTS(("    REJECT  face (not TT nor Terminal)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject Far East TT fonts that aren't Far East charset.
     */
    if (IsAvailableTTFont(pwszFace) &&
        !IS_ANY_DBCS_CHARSET(lpLogFont->elfLogFont.lfCharSet) &&
        !IsAvailableTTFontCP(pwszFace,0)
       ) {
        DBGFONTS(("    REJECT  face (Far East TT and not Far East charset)\n"));
        return TRUE;    // should be enumerate next charset.
    }

    /*
     * Add or find the facename
     */
    pFN = AddFaceNode(&gpFaceNames, pwszFace);
    if (pFN == NULL) {
        return FALSE;
    }

    if (bFindFaces) {
        if (nFontType == TRUETYPE_FONTTYPE) {
            DBGFONTS(("NEW TT FACE %ls\n", pwszFace));
            pFN->dwFlag |= EF_TTFONT;
        } else if (nFontType == RASTER_FONTTYPE) {
            DBGFONTS(("NEW OEM FACE %ls\n",pwszFace));
            pFN->dwFlag |= EF_OEMFONT;
        }
        return 0;
    }


    if (IS_BOLD(lpLogFont->elfLogFont.lfWeight)) {
        DBGFONTS2(("    A bold font (weight %d)\n", lpLogFont->elfLogFont.lfWeight));
        // return 0;
    }

    /* get font info */
    SizeWant.Y = (SHORT)lpLogFont->elfLogFont.lfHeight;
    SizeWant.X = (SHORT)lpLogFont->elfLogFont.lfWidth;
CreateBoldFont:
    lpLogFont->elfLogFont.lfQuality = DEFAULT_QUALITY;
    hFont = CreateFontIndirectW(&lpLogFont->elfLogFont);
    if (!hFont) {
        DBGFONTS(("    REJECT  font (can't create)\n"));
        RIPMSG0(RIP_WARNING, "FontEnum: CreateFontIndirectW returned NULL hFont.");
        return 0;  // same font in other sizes may still be suitable
    }

    DBGFONTS2(("    hFont = %lx\n", hFont));

    //
    // for reasons unbeknownst to me, removing this code causes GDI
    // to yack, claiming that the font is owned by another process.
    //

    SelectObject(hDC,hFont);
    if (!GetTextMetricsW(hDC, &tmi)) {
        tmi = *((LPTEXTMETRICW)lpTextMetric);
    }

    if (GetTextExtentPoint32W(hDC, L"0", 1, &Size)) {
        SizeActual.X = (SHORT)Size.cx;
    } else {
        SizeActual.X = (SHORT)(tmi.tmMaxCharWidth);
    }
    SizeActual.Y = (SHORT)(tmi.tmHeight + tmi.tmExternalLeading);
    DBGFONTS2(("    actual size %d,%d\n", SizeActual.X, SizeActual.Y));
    tmFamily = tmi.tmPitchAndFamily;
    if (TM_IS_TT_FONT(tmFamily) && (SizeWant.Y >= 0)) {
        SizeToShow = SizeWant;
        if (SizeWant.X == 0) {
            // Asking for zero width height gets a default aspect-ratio width
            // It's better to show that width rather than 0.
            SizeToShow.X = SizeActual.X;
        }
    } else {
        SizeToShow = SizeActual;
    }
    DBGFONTS2(("    SizeToShow = (%d,%d), SizeActual = (%d,%d)\n",
            SizeToShow.X, SizeToShow.Y, SizeActual.X, SizeActual.Y));

    // there's a GDI bug - this assert fails occasionally
    //ASSERT (tmi.tmw.tmMaxCharWidth == lpTextMetric->tmMaxCharWidth);

    /*
     * NOW, determine whether this font entry has already been cached
     * LATER : it may be possible to do this before creating the font, if
     * we can trust the dimensions & other info from lpTextMetric.
     * Sort by size:
     *  1) By pixelheight (negative Y values)
     *  2) By height (as shown)
     *  3) By width (as shown)
     */
    for (nFont = 0; nFont < (LONG)NumberOfFonts; ++nFont) {
        COORD SizeShown;

        if (FontInfo[nFont].hFont == NULL) {
            DBGFONTS(("!   Font %x has a NULL hFont\n", nFont));
            continue;
        }


        if (FontInfo[nFont].SizeWant.X > 0) {
            SizeShown.X = FontInfo[nFont].SizeWant.X;
        } else {
            SizeShown.X = FontInfo[nFont].Size.X;
        }

        if (FontInfo[nFont].SizeWant.Y > 0) {
            // This is a font specified by cell height.
            SizeShown.Y = FontInfo[nFont].SizeWant.Y;
        } else {
            SizeShown.Y = FontInfo[nFont].Size.Y;
            if (FontInfo[nFont].SizeWant.Y < 0) {
                // This is a TT font specified by character height.
                if (SizeWant.Y < 0 && SizeWant.Y > FontInfo[nFont].SizeWant.Y) {
                    // Requested pixelheight is smaller than this one.
                    DBGFONTS(("INSERT %d pt at %x, before %d pt\n",
                            -SizeWant.Y, nFont, -FontInfo[nFont].SizeWant.Y));
                    nFontNew = nFont;
                    goto InsertNewFont;
                }
            }
        }

        // DBGFONTS(("    SizeShown(%x) = (%d,%d)\n",nFont,SizeShown.X,SizeShown.Y));

        if (SIZE_EQUAL(SizeShown, SizeToShow) &&
                FontInfo[nFont].Family == tmFamily &&
                FontInfo[nFont].Weight == tmi.tmWeight &&
                wcscmp(FontInfo[nFont].FaceName, pwszFace) == 0) {
            /*
             * Already have this font
             */
            DBGFONTS2(("    Already have the font\n"));
            DeleteObject(hFont);
            pfed->bFarEastOK = TRUE;
            return TRUE;
        }


        if ((SizeToShow.Y < SizeShown.Y) ||
                (SizeToShow.Y == SizeShown.Y && SizeToShow.X < SizeShown.X)) {
            /*
             * This new font is smaller than nFont
             */
            DBGFONTS(("INSERT at %x, SizeToShow = (%d,%d)\n", nFont,
                    SizeToShow.X,SizeToShow.Y));
            nFontNew = nFont;
            goto InsertNewFont;
        }
    }

    /*
     * The font we are adding should be appended to the list,
     * since it is bigger (or equal) to the last one.
     */
    nFontNew = (LONG)NumberOfFonts;

InsertNewFont: // at nFontNew

//  ASSERT ((lpTextMetric->tmPitchAndFamily & 1) == 0);
    /* If we have to grow our font table, do it */

    if (NumberOfFonts == FontInfoLength) {
        PFONT_INFO Temp;

        FontInfoLength += FONT_INCREMENT;
        Temp = ConsoleHeapReAlloc(FONT_TAG, FontInfo, sizeof(FONT_INFO) * FontInfoLength);
        if (Temp == NULL) {
            RIPMSG0(RIP_WARNING, "FontEnum: failed to allocate PFONT_INFO");
            FontInfoLength -= FONT_INCREMENT;
            return FALSE;
        }
        FontInfo = Temp;
    }

    if (nFontNew < (LONG)NumberOfFonts) {
        RtlMoveMemory(&FontInfo[nFontNew+1],
                &FontInfo[nFontNew],
                sizeof(FONT_INFO)*(NumberOfFonts - nFontNew));
        //
        // Fix up DefaultFontIndex if nFontNew less than DefaultFontIndex.
        //
        if (nFontNew < (LONG)DefaultFontIndex &&
            DefaultFontIndex+1 < NumberOfFonts) {
            DefaultFontIndex++;
        }
    }

    /*
     * Store the font info
     */
    FontInfo[nFontNew].hFont = hFont;
    FontInfo[nFontNew].Family = tmFamily;
    FontInfo[nFontNew].Size = SizeActual;
    if (TM_IS_TT_FONT(tmFamily)) {
        FontInfo[nFontNew].SizeWant = SizeWant;
    } else {
        FontInfo[nFontNew].SizeWant.X = 0;
        FontInfo[nFontNew].SizeWant.Y = 0;
    }
    FontInfo[nFontNew].Weight = tmi.tmWeight;
    FontInfo[nFont].FaceName = pFN->awch;
#if defined(FE_SB)
    FontInfo[nFontNew].tmCharSet = tmi.tmCharSet;
#endif

    ++NumberOfFonts;

    if (nFontType == TRUETYPE_FONTTYPE && !IS_BOLD(FontInfo[nFontNew].Weight)) {
          lpLogFont->elfLogFont.lfWeight = FW_BOLD;
          goto CreateBoldFont;
    }

    pfed->bFarEastOK = TRUE;  // and continue enumeration
    return TRUE;
}

BOOL
DoFontEnum(
    HDC hDC,
    LPWSTR pwszFace,
    SHORT TTPointSize)
{
    BOOL bDeleteDC = FALSE;
    BOOL bFindFaces = (pwszFace == NULL);
    FONTENUMDC fed;
    LOGFONTW LogFont;

    DBGFONTS(("DoFontEnum \"%ls\"\n", pwszFace));

    if (hDC == NULL) {
        hDC = CreateDCW(L"DISPLAY", NULL, NULL, NULL);
        bDeleteDC = TRUE;
    }

    fed.hDC = hDC;
    fed.bFindFaces = bFindFaces;
    fed.bFarEastOK = FALSE;
    fed.TTPointSize = TTPointSize;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (pwszFace) {
        wcscpy(LogFont.lfFaceName, pwszFace);
    }

    /*
     * EnumFontFamiliesEx function enumerates one font in every face in
     * every character set.
     */
    EnumFontFamiliesExW(hDC, &LogFont, (FONTENUMPROC)FontEnum, (LPARAM)&fed, 0);
    if (bDeleteDC) {
        DeleteDC(hDC);
    }

    return fed.bFarEastOK;
}


NTSTATUS
EnumerateFonts(
    DWORD Flags)
{
    TEXTMETRIC tmi;
    HDC hDC;
    PFACENODE pFN;
    ULONG ulOldEnumFilter;
    DWORD FontIndex;
    DWORD dwFontType = 0;

    DBGFONTS(("EnumerateFonts %lx\n", Flags));

    dwFontType = (EF_TTFONT|EF_OEMFONT|EF_DEFFACE) & Flags;

    if (FontInfo == NULL) {
        //
        // Allocate memory for the font array.
        //
        NumberOfFonts = 0;

        FontInfo = ConsoleHeapAlloc(FONT_TAG, sizeof(FONT_INFO) * INITIAL_FONTS);
        if (FontInfo == NULL) {
            return STATUS_NO_MEMORY;
        }
        FontInfoLength = INITIAL_FONTS;
    }

    hDC = CreateDCW(L"DISPLAY",NULL,NULL,NULL);

    // Before enumeration, turn off font enumeration filters.
    ulOldEnumFilter = SetFontEnumeration(0);
    // restore all the other flags
    SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);

    if (Flags & EF_DEFFACE) {
        SelectObject(hDC,GetStockObject(OEM_FIXED_FONT));

        if (GetTextMetricsW(hDC, &tmi)) {
            DefaultFontSize.X = (SHORT)(tmi.tmMaxCharWidth);
            DefaultFontSize.Y = (SHORT)(tmi.tmHeight+tmi.tmExternalLeading);
            DefaultFontFamily = tmi.tmPitchAndFamily;
#if defined(FE_SB)
            if (IS_ANY_DBCS_CHARSET(tmi.tmCharSet))
                DefaultFontSize.X /= 2;
#endif
        }
        GetTextFaceW(hDC, LF_FACESIZE, DefaultFaceName);
#if defined(FE_SB)
        DBGFONTS(("Default (OEM) Font %ls (%d,%d) CharSet 0x%02X\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y,
                tmi.tmCharSet));
#else
        DBGFONTS(("Default (OEM) Font %ls (%d,%d)\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y));
#endif

        // Make sure we are going to enumerate the OEM face.
        pFN = AddFaceNode(&gpFaceNames, DefaultFaceName);
        if (pFN) {
            pFN->dwFlag |= EF_DEFFACE | EF_OEMFONT;
        }
    }

    // Use DoFontEnum to get all fonts from the system.  Our FontEnum
    // proc puts just the ones we want into an array
    //
    for (pFN = gpFaceNames; pFN; pFN = pFN->pNext) {
        DBGFONTS(("\"%ls\" is %s%s%s%s%s%s\n", pFN->awch,
            pFN->dwFlag & EF_NEW        ? "NEW "        : " ",
            pFN->dwFlag & EF_OLD        ? "OLD "        : " ",
            pFN->dwFlag & EF_ENUMERATED ? "ENUMERATED " : " ",
            pFN->dwFlag & EF_OEMFONT    ? "OEMFONT "    : " ",
            pFN->dwFlag & EF_TTFONT     ? "TTFONT "     : " ",
            pFN->dwFlag & EF_DEFFACE    ? "DEFFACE "    : " "));

        if ((pFN->dwFlag & dwFontType) == 0) {
            // not the kind of face we want
            continue;
        }
        if (pFN->dwFlag & EF_ENUMERATED) {
            // we already enumerated this face
            continue;
        }

        DoFontEnum(hDC, pFN->awch, DefaultFontSize.Y);
        pFN->dwFlag |= EF_ENUMERATED;
    }


    // After enumerating fonts, restore the font enumeration filter.
    SetFontEnumeration(ulOldEnumFilter);

    DeleteDC(hDC);

    // Make sure the default font is set correctly
    if (NumberOfFonts > 0 && DefaultFontSize.X == 0 && DefaultFontSize.Y == 0) {
        DefaultFontSize.X = FontInfo[0].Size.X;
        DefaultFontSize.Y = FontInfo[0].Size.Y;
        DefaultFontFamily = FontInfo[0].Family;
    }

    for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
        if (FontInfo[FontIndex].Size.X == DefaultFontSize.X &&
            FontInfo[FontIndex].Size.Y == DefaultFontSize.Y &&
            FontInfo[FontIndex].Family == DefaultFontFamily) {
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_ENABLED() &&
                !IS_ANY_DBCS_CHARSET(FontInfo[FontIndex].tmCharSet))
            {
                continue ;
            }
#endif
            break;
        }
    }
    ASSERT(FontIndex < NumberOfFonts);
    if (FontIndex < NumberOfFonts) {
        DefaultFontIndex = FontIndex;
    } else {
        DefaultFontIndex = 0;
    }
    DBGFONTS(("EnumerateFonts : DefaultFontIndex = %ld\n", DefaultFontIndex));

    return STATUS_SUCCESS;
}


/*
 * Get the font index for a new font
 * If necessary, attempt to create the font.
 * Always return a valid FontIndex (even if not correct)
 * Family:   Find/Create a font with of this Family
 *           0    - don't care
 * pwszFace: Find/Create a font with this face name.
 *           NULL or L""  - use DefaultFaceName
 * Size:     Must match SizeWant or actual Size.
 */
int
FindCreateFont(
    DWORD Family,
    LPWSTR pwszFace,
    COORD Size,
    LONG Weight,
    UINT CodePage)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    int i;
    int FontIndex = NOT_CREATED_NOR_FOUND;
    int BestMatch = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    WCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    LPWSTR pwszAltFace = NULL;

    BYTE CharSet = CodePageToCharSet(CodePage);

    DBGFONTS(("FindCreateFont Family=%x %ls (%d,%d) %d %d %x\n",
            Family, pwszFace, Size.X, Size.Y, Weight, CodePage, CharSet));

    if (CONSOLE_IS_DBCS_ENABLED() &&
        !IS_ANY_DBCS_CHARSET(CharSet))
    {
        MakeAltRasterFont(CodePage, FontInfo[DefaultFontIndex].Size,
                          &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

        if (pwszFace == NULL || *pwszFace == L'\0') {
            pwszFace = AltFaceName;
        }
        if (Size.Y == 0) {
            Size.X = AltFontSize.X;
            Size.Y = AltFontSize.Y;
        }
    }
    else {
        if (pwszFace == NULL || *pwszFace == L'\0') {
            pwszFace = DefaultFaceName;
        }
        if (Size.Y == 0) {
            Size.X = DefaultFontSize.X;
            Size.Y = DefaultFontSize.Y;
        }
    }

    if (IsAvailableTTFont(pwszFace)) {
        pwszAltFace = GetAltFaceName(pwszFace);
    }
    else {
        pwszAltFace = pwszFace;
    }

    /*
     * Try to find the exact font
     */
TryFindExactFont:
    for (i=0; i < (int)NumberOfFonts; i++) {
        /*
         * If looking for a particular Family, skip non-matches
         */
        if ((Family != 0) &&
                ((BYTE)Family != FontInfo[i].Family)) {
            continue;
        }

        /*
         * Skip non-matching sizes
         */
        if ((FontInfo[i].SizeWant.Y != Size.Y) &&
             !SIZE_EQUAL(FontInfo[i].Size, Size)) {
            continue;
        }

        /*
         * Skip non-matching weights
         */
        if ((Weight != 0) && (Weight != FontInfo[i].Weight)) {
            continue;
        }
#if defined(FE_SB)
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                FontInfo[i].tmCharSet != CharSet) {
            continue;
        }
#endif

        /*
         * Size (and maybe Family) match.
         *  If we don't care about the name, or if it matches, use this font.
         *  Else if name doesn't match and it is a raster font, consider it.
         */
        if ((pwszFace == NULL) || (pwszFace[0] == L'\0') ||
                wcscmp(FontInfo[i].FaceName, pwszFace) == 0 ||
                wcscmp(FontInfo[i].FaceName, pwszAltFace) == 0
           ) {
            FontIndex = i;
            goto FoundFont;
        } else if (!TM_IS_TT_FONT(FontInfo[i].Family)) {
            BestMatch = i;
        }
    }

    /*
     * Didn't find the exact font, so try to create it
     */
    if (FontIndex == NOT_CREATED_NOR_FOUND) {
        ULONG ulOldEnumFilter;
        ulOldEnumFilter = SetFontEnumeration(0);
        // restore all the other flags
        SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);
        if (Size.Y < 0) {
            Size.Y = -Size.Y;
        }
        bFontOK = DoFontEnum(NULL, pwszFace, Size.Y);
        SetFontEnumeration(ulOldEnumFilter);
        if (bFontOK) {
            DBGFONTS(("FindCreateFont created font!\n"));
            FontIndex = CREATED_BUT_NOT_FOUND;
            goto TryFindExactFont;
        } else {
            DBGFONTS(("FindCreateFont failed to create font!\n"));
        }
    }

    /*
     * Failed to find exact match, but we have a close Raster Font
     * fit - only the name doesn't match.
     */
    if (BestMatch >= 0) {
        FontIndex = BestMatch;
        goto FoundFont;
    }

    /*
     * Failed to find exact match, even after enumeration, so now try
     * to find a font of same family and same size or bigger
     */
    for (i=0; i < (int)NumberOfFonts; i++) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED()) {
            if ((Family != 0) &&
                    ((BYTE)Family != FontInfo[i].Family)) {
                continue;
            }

            if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                    FontInfo[i].tmCharSet != CharSet) {
                continue;
            }
        }
        else {
#endif
        if ((BYTE)Family != FontInfo[i].Family) {
            continue;
        }
#if defined(FE_SB)
        }
#endif

        if (FontInfo[i].Size.Y >= Size.Y &&
                FontInfo[i].Size.X >= Size.X) {
            // Same family, size >= desired.
            FontIndex = i;
            break;
        }
    }

    if (FontIndex < 0) {
        DBGFONTS(("FindCreateFont defaults!\n"));
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED() &&
            !IsAvailableFarEastCodePage(CodePage))
        {
            FontIndex = AltFontIndex;
        }
        else
#endif
        FontIndex = DefaultFontIndex;
    }

FoundFont:
    DBGFONTS(("FindCreateFont returns %x : %ls (%d,%d)\n", FontIndex,
            FontInfo[FontIndex].FaceName,
            FontInfo[FontIndex].Size.X, FontInfo[FontIndex].Size.Y));
    return FontIndex;

#undef NOT_CREATED_NOR_FOUND
#undef CREATED_BUT_NOT_FOUND
}


NTSTATUS
FindTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT CodePage,
    OUT PTEXT_BUFFER_FONT_INFO TextFontInfo
    )

/*++

Routine Description:

    This routine find a font information which correspond to code page value.

Arguments:

Return Value:

--*/

{
    PTEXT_BUFFER_FONT_INFO CurrentFont;

    CurrentFont = ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont;

    while (CurrentFont != NULL) {
        if (CurrentFont->FontCodePage == CodePage) {
            *TextFontInfo = *CurrentFont;
            return STATUS_SUCCESS;
        }
        CurrentFont = CurrentFont->NextTextBufferFont;
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
StoreTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex,
    IN COORD FontSize,
    IN BYTE  FontFamily,
    IN LONG  FontWeight,
    IN LPWSTR FaceName,
    IN UINT CodePage
    )

/*++

Routine Description:

    This routine store a font information in CurrentTextBufferFont and ListOfTextBufferFont.
    If specified code page does not exist in ListOfTextBufferFont, then create new list.

Arguments:

Return Value:

--*/

{
    PTEXT_BUFFER_FONT_INFO CurrentFont, PrevFont;

    CurrentFont = ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont;

    while (CurrentFont != NULL) {
        if (CurrentFont->FontCodePage == CodePage) {
            CurrentFont->FontNumber   = FontIndex;
            CurrentFont->FontSize     = FontSize;
            CurrentFont->Family       = FontFamily;
            CurrentFont->Weight       = FontWeight;
            // CurrentFont->FontCodePage = CodePage; // Redundant
            wcscpy(CurrentFont->FaceName, FaceName);
            break;
        }
        PrevFont    = CurrentFont;
        CurrentFont = CurrentFont->NextTextBufferFont;
    }

    if (CurrentFont == NULL) {
        CurrentFont = ConsoleHeapAlloc(FONT_TAG, sizeof(TEXT_BUFFER_FONT_INFO));
        if (CurrentFont == NULL) {
            return STATUS_NO_MEMORY;
        }

        CurrentFont->NextTextBufferFont = NULL;
        CurrentFont->FontNumber   = FontIndex;
        CurrentFont->FontSize     = FontSize;
        CurrentFont->Family       = FontFamily;
        CurrentFont->Weight       = FontWeight;
        CurrentFont->FontCodePage = CodePage;
        wcscpy(CurrentFont->FaceName, FaceName);

        if (ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont == NULL) {
            ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont = CurrentFont;
        }
        else {
            PrevFont->NextTextBufferFont = CurrentFont;
        }
    }

    ScreenInfo->BufferInfo.TextInfo.CurrentTextBufferFont = *CurrentFont;
    ScreenInfo->BufferInfo.TextInfo.CurrentTextBufferFont.NextTextBufferFont = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RemoveTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine all remove a font information in ListOfTextBufferFont.

Arguments:

Return Value:

--*/

{
    PTEXT_BUFFER_FONT_INFO CurrentFont;

    CurrentFont = ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont;

    while (CurrentFont != NULL) {
        PTEXT_BUFFER_FONT_INFO NextFont;

        NextFont = CurrentFont->NextTextBufferFont;
        ConsoleHeapFree(CurrentFont);

        CurrentFont = NextFont;
    }

    ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
GetNumFonts(
    OUT PULONG NumFonts
    )
{
    *NumFonts = NumberOfFonts;
    return STATUS_SUCCESS;
}


NTSTATUS
GetAvailableFonts(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PVOID Buffer,
    IN OUT PULONG NumFonts
    )
{
    PCONSOLE_FONT_INFO BufPtr;
    ULONG i;
    COORD WindowSize;
    WINDOW_LIMITS WindowLimits;

    //
    // if the buffer is too small to return all the fonts, return
    // the number that will fit.
    //

    *NumFonts = (*NumFonts > NumberOfFonts) ? NumberOfFonts : *NumFonts;

    //
    // convert font size in pixels to font size in rows/columns
    //

    BufPtr = (PCONSOLE_FONT_INFO)Buffer;

    if (MaximumWindow) {
        GetWindowLimits(ScreenInfo, &WindowLimits);
        WindowSize = WindowLimits.MaximumWindowSize;
    }
    else {
        WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    }
    for (i=0;i<*NumFonts;i++,BufPtr++) {
        BufPtr->nFont = i;
        BufPtr->dwFontSize.X = WindowSize.X * SCR_FONTSIZE(ScreenInfo).X / FontInfo[i].Size.X;
        BufPtr->dwFontSize.Y = WindowSize.Y * SCR_FONTSIZE(ScreenInfo).Y / FontInfo[i].Size.Y;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GetFontSize(
    IN DWORD  FontIndex,
    OUT PCOORD FontSize
    )
{
    if (FontIndex >= NumberOfFonts)
        return STATUS_INVALID_PARAMETER;
    *FontSize = FontInfo[FontIndex].Size;
    return STATUS_SUCCESS;
}

NTSTATUS
GetCurrentFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PULONG FontIndex,
    OUT PCOORD FontSize
    )
{
    COORD WindowSize;
    WINDOW_LIMITS WindowLimits;

    if (MaximumWindow) {
        GetWindowLimits(ScreenInfo, &WindowLimits);
        WindowSize = WindowLimits.MaximumWindowSize;
    }
    else {
        WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    }
    *FontIndex = SCR_FONTNUMBER(ScreenInfo);
    *FontSize = WindowSize;
    return STATUS_SUCCESS;
}

NTSTATUS
SetScreenBufferFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex,
    IN UINT CodePage
    )
{
    COORD FontSize;
    WINDOW_LIMITS WindowLimits;
    NTSTATUS Status;
    ULONG ulFlagPrev;
    DBGFONTS(("SetScreenBufferFont %lx %x\n", ScreenInfo, FontIndex));

    if (ScreenInfo == NULL) {
        /* If shutdown occurs with font dlg up */
        return STATUS_SUCCESS;
    }

    /*
     * Don't try to set the font if we're not in text mode
     */
    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = GetFontSize(FontIndex, &FontSize);
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    ulFlagPrev = ScreenInfo->Flags;
    if (TM_IS_TT_FONT(FontInfo[FontIndex].Family)) {
        ScreenInfo->Flags &= ~CONSOLE_OEMFONT_DISPLAY;
    } else {
        ScreenInfo->Flags |= CONSOLE_OEMFONT_DISPLAY;
    }

    /*
     * Convert from UnicodeOem to Unicode or vice-versa if necessary
     */
    if ((ulFlagPrev & CONSOLE_OEMFONT_DISPLAY) != (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY)) {
        if (ulFlagPrev & CONSOLE_OEMFONT_DISPLAY) {
            /*
             * Must convert from UnicodeOem to real Unicode
             */
            DBGCHARS(("SetScreenBufferFont converts UnicodeOem to Unicode\n"));
            FalseUnicodeToRealUnicode(
                    ScreenInfo->BufferInfo.TextInfo.TextRows,
                    ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y,
                    ScreenInfo->Console->OutputCP);
        } else {
            /*
             * Must convert from real Unicode to UnicodeOem
             */
            DBGCHARS(("SetScreenBufferFont converts Unicode to UnicodeOem\n"));
            RealUnicodeToFalseUnicode(
                    ScreenInfo->BufferInfo.TextInfo.TextRows,
                    ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y,
                    ScreenInfo->Console->OutputCP);
        }
    }

    /*
     * Store font properties
     */
    Status = StoreTextBufferFontInfo(ScreenInfo,
                                     FontIndex,
                                     FontSize,
                                     FontInfo[FontIndex].Family,
                                     FontInfo[FontIndex].Weight,
                                     FontInfo[FontIndex].FaceName,
                                     CodePage);
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    //
    // set font
    //
    Status = SetFont(ScreenInfo);
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    //
    // if window is growing, make sure it's not bigger than the screen.
    //

    GetWindowLimits(ScreenInfo, &WindowLimits);
    if (WindowLimits.MaximumWindowSize.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
        ScreenInfo->Window.Right -= CONSOLE_WINDOW_SIZE_X(ScreenInfo) - WindowLimits.MaximumWindowSize.X;
        ScreenInfo->WindowMaximizedX = (ScreenInfo->Window.Left == 0 &&
                                        (SHORT)(ScreenInfo->Window.Right+1) == ScreenInfo->ScreenBufferSize.X);
    }
    if (WindowLimits.MaximumWindowSize.Y < CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) {
        ScreenInfo->Window.Bottom -= CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - WindowLimits.MaximumWindowSize.Y;
        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y > ScreenInfo->Window.Bottom) {
            ScreenInfo->Window.Top += ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Bottom;
            ScreenInfo->Window.Bottom += ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Bottom;
        }
        ScreenInfo->WindowMaximizedY = (ScreenInfo->Window.Top == 0 &&
                                        (SHORT)(ScreenInfo->Window.Bottom+1) == ScreenInfo->ScreenBufferSize.Y);
    }
    if (WindowLimits.MinimumWindowSize.X > CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
        if (WindowLimits.MinimumWindowSize.X > ScreenInfo->ScreenBufferSize.X) {
            COORD NewBufferSize;

            NewBufferSize.X = WindowLimits.MinimumWindowSize.X;
            NewBufferSize.Y = ScreenInfo->ScreenBufferSize.Y;
            ResizeScreenBuffer(ScreenInfo,
                               NewBufferSize,
                               FALSE
                              );
        }
        if ((ScreenInfo->Window.Left+WindowLimits.MinimumWindowSize.X) > ScreenInfo->ScreenBufferSize.X) {
            ScreenInfo->Window.Left = 0;
            ScreenInfo->Window.Right = WindowLimits.MinimumWindowSize.X-1;
        } else {
            ScreenInfo->Window.Right = ScreenInfo->Window.Left+WindowLimits.MinimumWindowSize.X-1;
        }
        ScreenInfo->WindowMaximizedX = (ScreenInfo->Window.Left == 0 &&
                                        (SHORT)(ScreenInfo->Window.Right+1) == ScreenInfo->ScreenBufferSize.X);
    }

    SetLineChar(ScreenInfo);
    {
        COORD WindowedWindowSize;

        WindowedWindowSize.X = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        WindowedWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);


#if defined(FE_IME)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;

            ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {

                Status = StoreTextBufferFontInfo(ConvAreaInfo->ScreenBuffer,
                                                 SCR_FONTNUMBER(ScreenInfo),
                                                 SCR_FONTSIZE(ScreenInfo),
                                                 SCR_FAMILY(ScreenInfo),
                                                 SCR_FONTWEIGHT(ScreenInfo),
                                                 SCR_FACENAME(ScreenInfo),
                                                 SCR_FONTCODEPAGE(ScreenInfo));
                if (!NT_SUCCESS(Status)) {
                    return((ULONG) Status);
                }

                ConvAreaInfo->ScreenBuffer->Window = ScreenInfo->Window;
                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;

                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }
        }
#endif // FE_IME
    }

    //
    // resize window.  this will take care of the scroll bars too.
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        SetWindowSize(ScreenInfo);
    }

    //
    // adjust cursor size.
    //

    SetCursorInformation(ScreenInfo,
                         ScreenInfo->BufferInfo.TextInfo.CursorSize,
                         (BOOLEAN)ScreenInfo->BufferInfo.TextInfo.CursorVisible
                        );

    WriteToScreen(ScreenInfo,
                  &ScreenInfo->Window);
    return STATUS_SUCCESS;
}


NTSTATUS
SetFont(
    IN OUT PSCREEN_INFORMATION ScreenInfo
    )
{
    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        int FontIndex = FindCreateFont(SCR_FAMILY(ScreenInfo),
                                       SCR_FACENAME(ScreenInfo),
                                       SCR_FONTSIZE(ScreenInfo),
                                       SCR_FONTWEIGHT(ScreenInfo),
                                       SCR_FONTCODEPAGE(ScreenInfo));
        if (SelectObject(ScreenInfo->Console->hDC,FontInfo[FontIndex].hFont)==0)
            return STATUS_INVALID_PARAMETER;

        if ((DWORD)FontIndex != SCR_FONTNUMBER(ScreenInfo)) {
            NTSTATUS Status;
            Status = StoreTextBufferFontInfo(ScreenInfo,
                                             FontIndex,
                                             FontInfo[FontIndex].Size,
                                             FontInfo[FontIndex].Family,
                                             FontInfo[FontIndex].Weight,
                                             FontInfo[FontIndex].FaceName,
                                             ScreenInfo->Console->OutputCP);
            if (!NT_SUCCESS(Status)) {
                return((ULONG) Status);
            }
        }

        // hack to get text realized into DC.  this is to force the
        // attribute cache to get flushed to the server side, since
        // we select the font with a client side DC and call ExtTextOut
        // with a server side DC.
        // we then need to reset the text color, since the incorrect
        // client side color has been flushed to the server.
        {
        TEXTMETRIC tmi;

        GetTextMetricsW( ScreenInfo->Console->hDC, &tmi);
        ASSERT ((tmi.tmPitchAndFamily & 1) == 0);
        ScreenInfo->Console->LastAttributes = ScreenInfo->Attributes;
        SetTextColor(ScreenInfo->Console->hDC,ConvertAttrToRGB(ScreenInfo->Console, LOBYTE(ScreenInfo->Attributes)));
        SetBkColor(ScreenInfo->Console->hDC,ConvertAttrToRGB(ScreenInfo->Console, LOBYTE(ScreenInfo->Attributes >> 4)));
        }
    }
    return STATUS_SUCCESS;
}

int
ConvertToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
{
    DBGCHARS(("ConvertToOem U->%d %.*ls\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
    if (Codepage == OEMCP) {
        ULONG Length;
        NTSTATUS Status;

        Status = RtlUnicodeToOemN(Target,
                                  TargetLength,
                                  &Length,
                                  Source,
                                  SourceLength * sizeof(WCHAR)
                                 );
        if (!NT_SUCCESS(Status)) {
            return 0;
        } else {
            return Length;
        }
    } else {
        return WideCharToMultiByte(Codepage,
                                   0,
                                   Source,
                                   SourceLength,
                                   Target,
                                   TargetLength,
                                   NULL,
                                   NULL);
    }
}

int
ConvertInputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,    // in chars
    OUT LPWSTR Target,
    IN int TargetLength     // in chars
    )
/*
    data in the output buffer is the true unicode value
*/
{
    DBGCHARS(("ConvertInputToUnicode %d->U %.*s\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
    if (Codepage == OEMCP) {
        ULONG Length;
        NTSTATUS Status;

        Status = RtlOemToUnicodeN(Target,
                                  TargetLength * sizeof(WCHAR),
                                  &Length,
                                  Source,
                                  SourceLength
                                 );
        if (!NT_SUCCESS(Status)) {
            return 0;
        } else {
            return Length / sizeof(WCHAR);
        }
    } else {
        return MultiByteToWideChar(Codepage,
                                   0,
                                   Source,
                                   SourceLength,
                                   Target,
                                   TargetLength);
    }
}

int
ConvertOutputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,    // in chars
    OUT LPWSTR Target,
    IN int TargetLength     // in chars
    )
/*
    output data is always translated via the ansi codepage
    so glyph translation works.
*/

{
    NTSTATUS Status;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    LPSTR pszT;

    DBGCHARS(("ConvertOutputToUnicode %d->U %.*s\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
    if (Codepage == OEMCP) {
        Status = RtlCustomCPToUnicodeN(&GlyphCP,
                           Target,
                           TargetLength * sizeof(WCHAR),
                           &Length,
                           Source,
                           SourceLength
                          );
        if (!NT_SUCCESS(Status)) {
            return 0;
        } else {
            return Length / sizeof(WCHAR);
        }
    }

    if (TargetLength > STACK_BUFFER_SIZE) {
        pszT = ConsoleHeapAlloc(TMP_TAG, SourceLength);
        if (pszT == NULL) {
            return 0;
        }
    } else {
        pszT = StackBuffer;
    }
    RtlCopyMemory(pszT, Source, SourceLength);
    Length = MultiByteToWideChar(Codepage, MB_USEGLYPHCHARS,
            pszT, SourceLength, Target, TargetLength);
    if (pszT != StackBuffer) {
        ConsoleHeapFree(pszT);
    }
    return Length;
}

#if defined(FE_SB)
WCHAR
SB_CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch)
#else
WCHAR
CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch)
#endif
{
    WCHAR wch = UNICODE_NULL;
    if (Codepage == OEMCP) {
        RtlCustomCPToUnicodeN(&GlyphCP, &wch, sizeof(wch), NULL, &Ch, sizeof(Ch));
    } else {
        MultiByteToWideChar(Codepage, MB_USEGLYPHCHARS, &Ch, 1, &wch, 1);
    }
#ifdef DEBUG_PRINT
    if (Ch > 0x7F) {
        DBGCHARS(("CharToWcharGlyph %d 0x%02x -> 0x%04x\n",Codepage,(UCHAR)Ch,wch));
    }
#endif
    return wch;
}

#if defined(FE_SB)
WCHAR
SB_CharToWchar(
    IN UINT Codepage,
    IN char Ch)
#else
WCHAR
CharToWchar(
    IN UINT Codepage,
    IN char Ch)
#endif
{
    WCHAR wch = UNICODE_NULL;
    if (Codepage == OEMCP) {
        RtlOemToUnicodeN(&wch, sizeof(wch), NULL, &Ch, sizeof(Ch));
    } else {
        MultiByteToWideChar(Codepage, 0, &Ch, 1, &wch, 1);
    }
#ifdef DEBUG_PRINT
    if (Ch > 0x7F) {
        DBGCHARS(("CharToWchar %d 0x%02x -> 0x%04x\n",Codepage,(UCHAR)Ch,wch));
    }
#endif
    return wch;
}

char
WcharToChar(
    IN UINT Codepage,
    IN WCHAR Wchar)
{
    char ch = CHAR_NULL;
    if (Codepage == OEMCP) {
        RtlUnicodeToOemN(&ch, sizeof(ch), NULL, &Wchar, sizeof(Wchar));
    } else {
        WideCharToMultiByte(Codepage, 0, &Wchar, 1, &ch, 1, NULL, NULL);
    }
#ifdef DEBUG_PRINT
    if (Wchar > 0x007F) {
        DBGCHARS(("WcharToChar %d 0x%04x -> 0x%02x\n",Codepage,Wchar,(UCHAR)ch));
    }
#endif
    return ch;
}

int
ConvertOutputToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
/*
    Converts SourceLength Unicode characters from Source into
    not more than TargetLength Codepage characters at Target.
    Returns the number characters put in Target. (0 if failure)
*/

{
    if (Codepage == OEMCP) {
        NTSTATUS Status;
        ULONG Length;
        // Can do this in place
        Status = RtlUnicodeToOemN(Target,
                                  TargetLength,
            